package com.qaf.framework.stepdefs;

import com.qaf.framework.util.TestContextManager;
import com.qaf.framework.util.ApiResponse;
import com.qmetry.qaf.automation.step.QAFTestStep;
import com.qmetry.qaf.automation.util.Reporter;
import com.qmetry.qaf.automation.util.Validator;
import org.json.JSONObject;
import org.json.JSONArray;
import static org.hamcrest.Matchers.*;
import static org.testng.Assert.*;

public class GenericJsonValidationSteps {
    
    /**
     * Generic step to store any captured UI data as expected JSON with a key
     * Usage: I store the captured UI data as expected JSON with key "employee"
     */
    @QAFTestStep(description = "I store the captured UI data as expected JSON with key {storageKey}")
    public void storeCapturedUiDataAsJson(String storageKey) {
        // Get the JSON that was prepared from UI capture (from context)
        JSONObject capturedJson = (JSONObject) TestContextManager.getContext("expected." + storageKey + ".response");
        
        if (capturedJson != null) {
            // Store it with the given key for later comparison
            TestContextManager.setContext("expected.json." + storageKey, capturedJson);
            Reporter.log("Stored expected JSON for key: " + storageKey);
        } else {
            Reporter.log("No captured JSON found for key: expected." + storageKey + ".response");
        }
    }
    
    /**
     * Generic step to validate complete API response against stored expected JSON
     * Usage: I validate the API response against expected JSON stored with key "employee"
     */
    @QAFTestStep(description = "I validate the API response against expected JSON stored with key {storageKey}")
    public void validateApiResponseAgainstExpectedJson(String storageKey) {
        // Get actual API response
        ApiResponse apiResponse = TestContextManager.getApiResponse();
        if (apiResponse == null) {
            fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        // Get expected JSON
        JSONObject expectedJson = (JSONObject) TestContextManager.getContext("expected.json." + storageKey);
        if (expectedJson == null) {
            fail("No expected JSON found for key: " + storageKey);
            return;
        }
        
        // Parse actual response
        JSONObject actualJson = new JSONObject(apiResponse.getResponseBody());
        
        // Perform deep comparison
        Reporter.log("Starting JSON comparison for: " + storageKey);
        boolean matches = compareJson(expectedJson, actualJson, "");
        
        if (!matches) {
            Reporter.log("=== JSON Mismatch Details ===");
            Reporter.log("Expected JSON: " + expectedJson.toString(2));
            Reporter.log("Actual JSON: " + actualJson.toString(2));
        }
        
        assertTrue(matches, "API response does not match expected JSON for: " + storageKey);
    }
    
    /**
     * Generic step to validate API response contains expected structure
     * Usage: I validate the API response has the same structure as expected JSON with key "employee"
     */
    @QAFTestStep(description = "I validate the API response has the same structure as expected JSON with key {storageKey}")
    public void validateApiResponseStructure(String storageKey) {
        ApiResponse apiResponse = TestContextManager.getApiResponse();
        JSONObject expectedJson = (JSONObject) TestContextManager.getContext("expected.json." + storageKey);
        
        if (apiResponse == null || expectedJson == null) {
            fail("Missing API response or expected JSON for key: " + storageKey);
            return;
        }
        
        JSONObject actualJson = new JSONObject(apiResponse.getResponseBody());
        boolean structureMatches = validateJsonStructure(expectedJson, actualJson, "");
        
        assertTrue(structureMatches, "API response structure does not match expected for: " + storageKey);
    }
    
    /**
     * Generic step to validate specific path in API response against expected value
     * Usage: I validate the API response field "Employees[0].empInfo[0].empId" equals "787187"
     */
    @QAFTestStep(description = "I validate the API response field {jsonPath} equals {expectedValue}")
    public void validateJsonFieldValue(String jsonPath, String expectedValue) {
        ApiResponse apiResponse = TestContextManager.getApiResponse();
        if (apiResponse == null) {
            fail("No API response available");
            return;
        }
        
        JSONObject actualJson = new JSONObject(apiResponse.getResponseBody());
        Object actualValue = getValueByPath(actualJson, jsonPath);
        
        if (actualValue == null) {
            fail("Path not found in response: " + jsonPath);
            return;
        }
        
        String actualStr = String.valueOf(actualValue);
        assertEquals(actualStr, expectedValue, "Value mismatch at path: " + jsonPath);
    }
    
    /**
     * Alternative simplified step for complete JSON comparison
     * Usage: the API response should match the captured "employees" data
     */
    @QAFTestStep(description = "the API response should match the captured {dataType} data")
    public void apiResponseShouldMatchCapturedData(String dataType) {
        // Get expected JSON from context (set by UI capture steps)
        JSONObject expectedJson = (JSONObject) TestContextManager.getContext("expected." + dataType + ".response");
        
        // Get actual API response
        ApiResponse apiResponse = TestContextManager.getApiResponse();
        
        if (expectedJson == null || apiResponse == null) {
            fail("Missing expected data or API response for: " + dataType);
            return;
        }
        
        JSONObject actualJson = new JSONObject(apiResponse.getResponseBody());
        
        // Simple comparison first
        boolean quickMatch = actualJson.similar(expectedJson);
        
        if (quickMatch) {
            Reporter.log(dataType + " API response matches expected data perfectly");
            return;
        }
        
        // If quick match fails, do detailed comparison
        Reporter.log("Performing detailed comparison for: " + dataType);
        boolean detailedMatch = compareJson(expectedJson, actualJson, "");
        
        assertTrue(detailedMatch, dataType + " API response does not match expected data");
    }
    
    // Helper methods
    
    private boolean compareJson(JSONObject expected, JSONObject actual, String path) {
        boolean allMatch = true;
        
        // Check all expected keys exist in actual
        for (String key : expected.keySet()) {
            String currentPath = path.isEmpty() ? key : path + "." + key;
            
            if (!actual.has(key)) {
                Reporter.log("Missing key at path: " + currentPath);
                allMatch = false;
                continue;
            }
            
            Object expectedValue = expected.get(key);
            Object actualValue = actual.get(key);
            
            if (expectedValue instanceof JSONObject && actualValue instanceof JSONObject) {
                if (!compareJson((JSONObject) expectedValue, (JSONObject) actualValue, currentPath)) {
                    allMatch = false;
                }
            } else if (expectedValue instanceof JSONArray && actualValue instanceof JSONArray) {
                if (!compareJsonArrays((JSONArray) expectedValue, (JSONArray) actualValue, currentPath)) {
                    allMatch = false;
                }
            } else {
                if (!compareValues(expectedValue, actualValue, currentPath)) {
                    allMatch = false;
                }
            }
        }
        
        return allMatch;
    }
    
    private boolean compareJsonArrays(JSONArray expected, JSONArray actual, String path) {
        if (expected.length() != actual.length()) {
            Reporter.log("Array length mismatch at " + path + " - Expected: " + expected.length() + ", Actual: " + actual.length());
            return false;
        }
        
        boolean allMatch = true;
        for (int i = 0; i < expected.length(); i++) {
            String currentPath = path + "[" + i + "]";
            Object expectedItem = expected.get(i);
            Object actualItem = actual.get(i);
            
            if (expectedItem instanceof JSONObject && actualItem instanceof JSONObject) {
                if (!compareJson((JSONObject) expectedItem, (JSONObject) actualItem, currentPath)) {
                    allMatch = false;
                }
            } else if (expectedItem instanceof JSONArray && actualItem instanceof JSONArray) {
                if (!compareJsonArrays((JSONArray) expectedItem, (JSONArray) actualItem, currentPath)) {
                    allMatch = false;
                }
            } else {
                if (!compareValues(expectedItem, actualItem, currentPath)) {
                    allMatch = false;
                }
            }
        }
        
        return allMatch;
    }
    
    private boolean compareValues(Object expected, Object actual, String path) {
        // Handle null values
        if (expected == JSONObject.NULL && actual == JSONObject.NULL) {
            return true;
        }
        
        String expectedStr = String.valueOf(expected);
        String actualStr = String.valueOf(actual);
        
        // Handle numeric comparisons with tolerance
        if (isNumeric(expectedStr) && isNumeric(actualStr)) {
            try {
                double expectedNum = Double.parseDouble(expectedStr);
                double actualNum = Double.parseDouble(actualStr);
                
                if (Math.abs(expectedNum - actualNum) > 0.0001) {
                    Reporter.log("Numeric value mismatch at " + path + " - Expected: " + expectedStr + ", Actual: " + actualStr);
                    return false;
                }
                return true;
            } catch (NumberFormatException e) {
                // Fall through to string comparison
            }
        }
        
        // String comparison
        if (!expectedStr.equals(actualStr)) {
            Reporter.log("Value mismatch at " + path + " - Expected: " + expectedStr + ", Actual: " + actualStr);
            return false;
        }
        
        return true;
    }
    
    private boolean validateJsonStructure(JSONObject expected, JSONObject actual, String path) {
        for (String key : expected.keySet()) {
            String currentPath = path.isEmpty() ? key : path + "." + key;
            
            if (!actual.has(key)) {
                Reporter.log("Missing key in structure: " + currentPath);
                return false;
            }
            
            Object expectedValue = expected.get(key);
            Object actualValue = actual.get(key);
            
            // Check type compatibility
            if (expectedValue instanceof JSONObject && !(actualValue instanceof JSONObject)) {
                Reporter.log("Type mismatch at " + currentPath + " - Expected: Object, Actual: " + actualValue.getClass().getSimpleName());
                return false;
            }
            
            if (expectedValue instanceof JSONArray && !(actualValue instanceof JSONArray)) {
                Reporter.log("Type mismatch at " + currentPath + " - Expected: Array, Actual: " + actualValue.getClass().getSimpleName());
                return false;
            }
            
            // Recurse for nested structures
            if (expectedValue instanceof JSONObject) {
                if (!validateJsonStructure((JSONObject) expectedValue, (JSONObject) actualValue, currentPath)) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    private Object getValueByPath(JSONObject json, String path) {
        String[] parts = path.split("\\.");
        Object current = json;
        
        for (String part : parts) {
            if (current == null) return null;
            
            // Handle array notation like "tranches[0]"
            if (part.contains("[")) {
                String arrayName = part.substring(0, part.indexOf("["));
                int index = Integer.parseInt(part.substring(part.indexOf("[") + 1, part.indexOf("]")));
                
                if (current instanceof JSONObject) {
                    JSONArray array = ((JSONObject) current).getJSONArray(arrayName);
                    current = array.get(index);
                }
            } else {
                if (current instanceof JSONObject) {
                    current = ((JSONObject) current).get(part);
                }
            }
        }
        
        return current;
    }
    
    private boolean isNumeric(String str) {
        try {
            Double.parseDouble(str);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
