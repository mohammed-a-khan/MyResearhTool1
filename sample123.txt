package com.qaf.framework.stepdefs;

import com.qaf.framework.util.TestContextManager;
import com.qaf.framework.util.ApiResponse;
import com.qmetry.qaf.automation.step.QAFTestStep;
import com.qmetry.qaf.automation.util.Reporter;
import com.qmetry.qaf.automation.util.Validator;
import org.json.JSONObject;
import org.json.JSONArray;
import static org.hamcrest.Matchers.*;
import static org.testng.Assert.*;
import java.util.*;

public class GenericJsonValidationSteps {
    
    private List<String> comparisonLogs = new ArrayList<>();
    private boolean deepLogging = true;
    
    /**
     * Generic step to store any captured UI data as expected JSON with a key
     * Usage: I store the captured UI data as expected JSON with key "employees"
     */
    @QAFTestStep(description = "I store the captured UI data as expected JSON with key {storageKey}")
    public void storeCapturedUiDataAsJson(String storageKey) {
        JSONObject capturedJson = (JSONObject) TestContextManager.getContext("expected." + storageKey + ".response");
        
        if (capturedJson != null) {
            TestContextManager.setContext("expected.json." + storageKey, capturedJson);
            Reporter.log("Stored expected JSON for key: " + storageKey);
        } else {
            Reporter.log("No captured JSON found for key: expected." + storageKey + ".response");
        }
    }
    
    /**
     * Main validation step - compares any two JSON structures
     * Usage: the API response should match the captured "employees" data
     */
    @QAFTestStep(description = "the API response should match the captured {dataType} data")
    public void apiResponseShouldMatchCapturedData(String dataType) {
        comparisonLogs.clear();
        
        // Get expected JSON from context
        JSONObject expectedJson = (JSONObject) TestContextManager.getContext("expected." + dataType + ".response");
        
        // Get actual API response
        ApiResponse apiResponse = TestContextManager.getApiResponse();
        
        if (expectedJson == null || apiResponse == null) {
            fail("Missing expected data or API response for: " + dataType);
            return;
        }
        
        JSONObject actualJson = new JSONObject(apiResponse.getResponseBody());
        
        Reporter.log("=== Starting JSON Comparison for: " + dataType + " ===");
        
        // Perform comparison
        boolean matches = compareJsonElements(expectedJson, actualJson, "root");
        
        // Log results
        Reporter.log("=== Comparison Summary ===");
        Reporter.log("Total comparison points: " + comparisonLogs.size());
        
        int errors = 0;
        for (String log : comparisonLogs) {
            if (log.contains("ERROR") || log.contains("âœ—")) {
                Reporter.log(log);
                errors++;
            } else if (deepLogging) {
                Reporter.log(log);
            }
        }
        
        if (!deepLogging && errors == 0) {
            Reporter.log("All " + comparisonLogs.size() + " comparison points matched successfully!");
        }
        
        Reporter.log("=== Comparison Result: " + (matches ? "PASS" : "FAIL") + " ===");
        Reporter.log("Errors found: " + errors);
        
        if (!matches) {
            Reporter.log("=== Expected JSON ===");
            Reporter.log(expectedJson.toString(2));
            Reporter.log("=== Actual JSON ===");
            Reporter.log(actualJson.toString(2));
        }
        
        assertTrue(matches, dataType + " API response does not match expected data. Found " + errors + " mismatches.");
    }
    
    /**
     * Enable/disable deep logging
     */
    @QAFTestStep(description = "I {enableDisable} deep JSON comparison logging")
    public void setDeepLogging(String enableDisable) {
        deepLogging = "enable".equalsIgnoreCase(enableDisable);
        Reporter.log("Deep JSON comparison logging: " + (deepLogging ? "ENABLED" : "DISABLED"));
    }
    
    /**
     * Generic comparison method that handles any JSON element type
     */
    private boolean compareJsonElements(Object expected, Object actual, String path) {
        // Handle null cases
        if (expected == null && actual == null) {
            logComparison(path, "Both null", true);
            return true;
        }
        
        if (expected == null || actual == null) {
            logComparison(path, "Null mismatch - Expected: " + expected + ", Actual: " + actual, false);
            return false;
        }
        
        // Handle JSONObject.NULL
        if (expected == JSONObject.NULL && actual == JSONObject.NULL) {
            logComparison(path, "Both JSON null", true);
            return true;
        }
        
        if ((expected == JSONObject.NULL && actual != JSONObject.NULL) || 
            (expected != JSONObject.NULL && actual == JSONObject.NULL)) {
            logComparison(path, "JSON null mismatch - Expected: " + expected + ", Actual: " + actual, false);
            return false;
        }
        
        // Determine type and compare accordingly
        if (expected instanceof JSONObject && actual instanceof JSONObject) {
            return compareJsonObjects((JSONObject) expected, (JSONObject) actual, path);
        } else if (expected instanceof JSONArray && actual instanceof JSONArray) {
            return compareJsonArrays((JSONArray) expected, (JSONArray) actual, path);
        } else {
            // Primitive comparison
            return comparePrimitives(expected, actual, path);
        }
    }
    
    /**
     * Compare two JSON objects
     */
    private boolean compareJsonObjects(JSONObject expected, JSONObject actual, String path) {
        boolean allMatch = true;
        
        Set<String> allKeys = new HashSet<>();
        allKeys.addAll(expected.keySet());
        allKeys.addAll(actual.keySet());
        
        for (String key : allKeys) {
            String currentPath = path + "." + key;
            
            if (!expected.has(key)) {
                logComparison(currentPath, "Extra key in actual (not in expected)", false);
                // This might be acceptable, so we don't set allMatch = false
                continue;
            }
            
            if (!actual.has(key)) {
                logComparison(currentPath, "Missing key in actual", false);
                allMatch = false;
                continue;
            }
            
            Object expectedValue = expected.get(key);
            Object actualValue = actual.get(key);
            
            if (!compareJsonElements(expectedValue, actualValue, currentPath)) {
                allMatch = false;
            }
        }
        
        return allMatch;
    }
    
    /**
     * Compare two JSON arrays - tries both ordered and unordered comparison
     */
    private boolean compareJsonArrays(JSONArray expected, JSONArray actual, String path) {
        if (expected.length() != actual.length()) {
            logComparison(path, "Array length mismatch - Expected: " + expected.length() + ", Actual: " + actual.length(), false);
            return false;
        }
        
        if (expected.length() == 0) {
            logComparison(path, "Both arrays empty", true);
            return true;
        }
        
        // First try ordered comparison
        boolean orderedMatch = tryOrderedComparison(expected, actual, path);
        
        if (orderedMatch) {
            logComparison(path, "Arrays match in order", true);
            return true;
        }
        
        // If ordered comparison fails and arrays contain objects, try unordered
        if (expected.get(0) instanceof JSONObject) {
            boolean unorderedMatch = tryUnorderedComparison(expected, actual, path);
            if (unorderedMatch) {
                logComparison(path, "Arrays match (unordered)", true);
                return true;
            }
        }
        
        logComparison(path, "Arrays do not match (tried both ordered and unordered comparison)", false);
        return false;
    }
    
    /**
     * Try comparing arrays in order
     */
    private boolean tryOrderedComparison(JSONArray expected, JSONArray actual, String path) {
        for (int i = 0; i < expected.length(); i++) {
            String currentPath = path + "[" + i + "]";
            if (!compareJsonElements(expected.get(i), actual.get(i), currentPath + "(ordered)")) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Try comparing arrays unordered (for arrays of objects)
     */
    private boolean tryUnorderedComparison(JSONArray expected, JSONArray actual, String path) {
        List<JSONObject> expectedList = new ArrayList<>();
        List<JSONObject> actualList = new ArrayList<>();
        
        for (int i = 0; i < expected.length(); i++) {
            expectedList.add(expected.getJSONObject(i));
            actualList.add(actual.getJSONObject(i));
        }
        
        List<JSONObject> unmatchedActual = new ArrayList<>(actualList);
        
        for (int i = 0; i < expectedList.size(); i++) {
            JSONObject expectedObj = expectedList.get(i);
            boolean foundMatch = false;
            
            for (int j = 0; j < unmatchedActual.size(); j++) {
                JSONObject actualObj = unmatchedActual.get(j);
                
                // Try to match without logging each attempt
                List<String> tempLogs = comparisonLogs;
                comparisonLogs = new ArrayList<>();
                
                boolean matches = compareJsonObjects(expectedObj, actualObj, path + "[unordered-attempt]");
                
                comparisonLogs = tempLogs;
                
                if (matches) {
                    foundMatch = true;
                    unmatchedActual.remove(j);
                    logComparison(path + "[unordered-match-" + i + "]", "Found matching object", true);
                    break;
                }
            }
            
            if (!foundMatch) {
                logComparison(path + "[unordered-" + i + "]", "No match found for expected object", false);
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Compare primitive values
     */
    private boolean comparePrimitives(Object expected, Object actual, String path) {
        String expectedStr = String.valueOf(expected);
        String actualStr = String.valueOf(actual);
        
        // Try numeric comparison first
        if (isNumeric(expectedStr) && isNumeric(actualStr)) {
            try {
                double expectedNum = Double.parseDouble(expectedStr);
                double actualNum = Double.parseDouble(actualStr);
                
                boolean matches = Math.abs(expectedNum - actualNum) < 0.0001;
                logComparison(path, 
                    matches ? "Numeric match: " + expectedStr 
                            : "Numeric mismatch - Expected: " + expectedStr + ", Actual: " + actualStr, 
                    matches);
                return matches;
            } catch (NumberFormatException e) {
                // Fall through to string comparison
            }
        }
        
        // String comparison
        boolean matches = expectedStr.equals(actualStr);
        logComparison(path, 
            matches ? "Value match: " + expectedStr 
                    : "Value mismatch - Expected: '" + expectedStr + "', Actual: '" + actualStr + "'", 
            matches);
        return matches;
    }
    
    /**
     * Log comparison result
     */
    private void logComparison(String path, String message, boolean success) {
        String symbol = success ? "âœ“" : "âœ—";
        String level = success ? "INFO" : "ERROR";
        comparisonLogs.add(String.format("[%s] %s %s: %s", level, symbol, path, message));
    }
    
    /**
     * Check if string represents a number
     */
    private boolean isNumeric(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        try {
            Double.parseDouble(str);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
