Project.java
-----------------------

package com.cstestforge.model.project;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

/**
 * Represents a test project within the CSTestForge framework.
 * A project is the top-level container for test suites, test cases,
 * and project-specific configurations.
 */
public class Project implements Serializable {
    
    private static final long serialVersionUID = 1L;

    private String id;
    private String name;
    private String description;
    private ProjectConfig config;
    private List<TestSuite> testSuites;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private String createdBy;
    private String updatedBy;
    private boolean active;
    private String version;
    private String basePackage;
    private String repositoryUrl;
    private List<String> tags;
    
    /**
     * Creates a new project with default values and a randomly generated ID.
     */
    public Project() {
        this.id = UUID.randomUUID().toString();
        this.testSuites = new ArrayList<>();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.active = true;
        this.version = "1.0.0";
        this.tags = new ArrayList<>();
    }
    
    /**
     * Creates a new project with the specified name and a randomly generated ID.
     * 
     * @param name The name of the project
     */
    public Project(String name) {
        this();
        this.name = name;
    }
    
    /**
     * Creates a new project with the specified name, description, and a randomly generated ID.
     * 
     * @param name The name of the project
     * @param description The description of the project
     */
    public Project(String name, String description) {
        this(name);
        this.description = description;
    }
    
    /**
     * Gets the unique identifier of the project.
     * 
     * @return The project ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Sets the unique identifier of the project.
     * 
     * @param id The project ID
     */
    public void setId(String id) {
        this.id = id;
    }
    
    /**
     * Gets the name of the project.
     * 
     * @return The project name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Sets the name of the project.
     * 
     * @param name The project name
     */
    public void setName(String name) {
        this.name = name;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the description of the project.
     * 
     * @return The project description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the description of the project.
     * 
     * @param description The project description
     */
    public void setDescription(String description) {
        this.description = description;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the configuration of the project.
     * 
     * @return The project configuration
     */
    public ProjectConfig getConfig() {
        return config;
    }
    
    /**
     * Sets the configuration of the project.
     * 
     * @param config The project configuration
     */
    public void setConfig(ProjectConfig config) {
        this.config = config;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the test suites contained in the project.
     * 
     * @return An unmodifiable list of test suites
     */
    public List<TestSuite> getTestSuites() {
        return Collections.unmodifiableList(testSuites);
    }
    
    /**
     * Gets the mutable list of test suites for internal use.
     * 
     * @return The mutable list of test suites
     */
    private List<TestSuite> getMutableTestSuites() {
        return testSuites;
    }
    
    /**
     * Adds a test suite to the project.
     * 
     * @param testSuite The test suite to add
     * @return true if the test suite was added successfully, false otherwise
     */
    public boolean addTestSuite(TestSuite testSuite) {
        if (testSuite == null) {
            return false;
        }
        
        // Set the parent project reference
        testSuite.setParentProject(this);
        
        // Add to the test suites list
        boolean result = getMutableTestSuites().add(testSuite);
        if (result) {
            this.updatedAt = LocalDateTime.now();
        }
        return result;
    }
    
    /**
     * Removes a test suite from the project.
     * 
     * @param testSuite The test suite to remove
     * @return true if the test suite was removed successfully, false otherwise
     */
    public boolean removeTestSuite(TestSuite testSuite) {
        if (testSuite == null) {
            return false;
        }
        
        // Remove from the test suites list
        boolean result = getMutableTestSuites().remove(testSuite);
        if (result) {
            // Clear the parent project reference
            testSuite.setParentProject(null);
            this.updatedAt = LocalDateTime.now();
        }
        return result;
    }
    
    /**
     * Gets a test suite by its ID.
     * 
     * @param id The ID of the test suite to retrieve
     * @return The test suite with the specified ID, or null if not found
     */
    public TestSuite getTestSuiteById(String id) {
        if (id == null || id.isEmpty()) {
            return null;
        }
        
        for (TestSuite suite : getTestSuites()) {
            if (id.equals(suite.getId())) {
                return suite;
            }
        }
        
        return null;
    }
    
    /**
     * Gets a test suite by its name.
     * 
     * @param name The name of the test suite to retrieve
     * @return The test suite with the specified name, or null if not found
     */
    public TestSuite getTestSuiteByName(String name) {
        if (name == null || name.isEmpty()) {
            return null;
        }
        
        for (TestSuite suite : getTestSuites()) {
            if (name.equals(suite.getName())) {
                return suite;
            }
        }
        
        return null;
    }
    
    /**
     * Gets the date and time when the project was created.
     * 
     * @return The creation date and time
     */
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    /**
     * Sets the date and time when the project was created.
     * 
     * @param createdAt The creation date and time
     */
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    
    /**
     * Gets the date and time when the project was last updated.
     * 
     * @return The last update date and time
     */
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
    
    /**
     * Sets the date and time when the project was last updated.
     * 
     * @param updatedAt The last update date and time
     */
    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
    
    /**
     * Gets the username of the user who created the project.
     * 
     * @return The username of the creator
     */
    public String getCreatedBy() {
        return createdBy;
    }
    
    /**
     * Sets the username of the user who created the project.
     * 
     * @param createdBy The username of the creator
     */
    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
    
    /**
     * Gets the username of the user who last updated the project.
     * 
     * @return The username of the last updater
     */
    public String getUpdatedBy() {
        return updatedBy;
    }
    
    /**
     * Sets the username of the user who last updated the project.
     * 
     * @param updatedBy The username of the last updater
     */
    public void setUpdatedBy(String updatedBy) {
        this.updatedBy = updatedBy;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Checks if the project is active.
     * 
     * @return true if the project is active, false otherwise
     */
    public boolean isActive() {
        return active;
    }
    
    /**
     * Sets whether the project is active.
     * 
     * @param active true if the project is active, false otherwise
     */
    public void setActive(boolean active) {
        this.active = active;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the version of the project.
     * 
     * @return The project version
     */
    public String getVersion() {
        return version;
    }
    
    /**
     * Sets the version of the project.
     * 
     * @param version The project version
     */
    public void setVersion(String version) {
        this.version = version;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the base package for generated code.
     * 
     * @return The base package name
     */
    public String getBasePackage() {
        return basePackage;
    }
    
    /**
     * Sets the base package for generated code.
     * 
     * @param basePackage The base package name
     */
    public void setBasePackage(String basePackage) {
        this.basePackage = basePackage;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the repository URL for the project.
     * 
     * @return The repository URL
     */
    public String getRepositoryUrl() {
        return repositoryUrl;
    }
    
    /**
     * Sets the repository URL for the project.
     * 
     * @param repositoryUrl The repository URL
     */
    public void setRepositoryUrl(String repositoryUrl) {
        this.repositoryUrl = repositoryUrl;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the tags associated with the project.
     * 
     * @return An unmodifiable list of tags
     */
    public List<String> getTags() {
        return Collections.unmodifiableList(tags);
    }
    
    /**
     * Gets the mutable list of tags for internal use.
     * 
     * @return The mutable list of tags
     */
    private List<String> getMutableTags() {
        return tags;
    }
    
    /**
     * Adds a tag to the project.
     * 
     * @param tag The tag to add
     * @return true if the tag was added successfully, false otherwise
     */
    public boolean addTag(String tag) {
        if (tag == null || tag.isEmpty()) {
            return false;
        }
        
        boolean result = getMutableTags().add(tag);
        if (result) {
            this.updatedAt = LocalDateTime.now();
        }
        return result;
    }
    
    /**
     * Removes a tag from the project.
     * 
     * @param tag The tag to remove
     * @return true if the tag was removed successfully, false otherwise
     */
    public boolean removeTag(String tag) {
        if (tag == null || tag.isEmpty()) {
            return false;
        }
        
        boolean result = getMutableTags().remove(tag);
        if (result) {
            this.updatedAt = LocalDateTime.now();
        }
        return result;
    }
    
    /**
     * Checks if the project has a specific tag.
     * 
     * @param tag The tag to check
     * @return true if the project has the tag, false otherwise
     */
    public boolean hasTag(String tag) {
        if (tag == null || tag.isEmpty()) {
            return false;
        }
        
        return getTags().contains(tag);
    }
    
    /**
     * Creates a duplicate of this project with a new ID.
     * The duplicate will have the same properties but different test suites.
     * 
     * @param copyTestSuites If true, the test suites will also be duplicated
     * @return A duplicate of this project
     */
    public Project duplicate(boolean copyTestSuites) {
        Project duplicate = new Project();
        duplicate.setName(this.name + " (Copy)");
        duplicate.setDescription(this.description);
        duplicate.setConfig(this.config != null ? this.config.duplicate() : null);
        duplicate.setCreatedBy(this.createdBy);
        duplicate.setUpdatedBy(this.updatedBy);
        duplicate.setActive(this.active);
        duplicate.setVersion(this.version);
        duplicate.setBasePackage(this.basePackage);
        duplicate.setRepositoryUrl(this.repositoryUrl);
        
        // Copy tags
        for (String tag : this.getTags()) {
            duplicate.addTag(tag);
        }
        
        // Copy test suites if requested
        if (copyTestSuites) {
            for (TestSuite suite : this.getTestSuites()) {
                duplicate.addTestSuite(suite.duplicate(true));
            }
        }
        
        return duplicate;
    }
    
    /**
     * Gets the total number of test cases in the project.
     * 
     * @return The total number of test cases
     */
    public int getTestCaseCount() {
        int count = 0;
        for (TestSuite suite : getTestSuites()) {
            count += suite.getTestCases().size();
        }
        return count;
    }
    
    /**
     * Gets the total number of active test cases in the project.
     * 
     * @return The total number of active test cases
     */
    public int getActiveTestCaseCount() {
        int count = 0;
        for (TestSuite suite : getTestSuites()) {
            for (TestCase testCase : suite.getTestCases()) {
                if (testCase.isActive()) {
                    count++;
                }
            }
        }
        return count;
    }
    
    /**
     * Validates the project structure and returns a list of validation errors.
     * 
     * @return A list of validation error messages, or an empty list if the project is valid
     */
    public List<String> validate() {
        List<String> errors = new ArrayList<>();
        
        // Validate basic properties
        if (name == null || name.trim().isEmpty()) {
            errors.add("Project name is required");
        }
        
        if (config == null) {
            errors.add("Project configuration is required");
        } else {
            // Validate the configuration
            errors.addAll(config.validate());
        }
        
        // Validate test suites
        for (TestSuite suite : getTestSuites()) {
            errors.addAll(suite.validate());
        }
        
        return errors;
    }
    
    /**
     * Checks if the project has valid configuration and structure.
     * 
     * @return true if the project is valid, false otherwise
     */
    public boolean isValid() {
        return validate().isEmpty();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        Project other = (Project) obj;
        return Objects.equals(id, other.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "Project{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                ", description='" + description + '\'' +
                ", testSuites=" + testSuites.size() +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                ", active=" + active +
                ", version='" + version + '\'' +
                '}';
    }
}



TestSuite.java
------------------------

package com.cstestforge.model.project;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

/**
 * Represents a test suite within the CSTestForge framework.
 * A test suite is a container for multiple related test cases.
 */
public class TestSuite implements Serializable {
    
    private static final long serialVersionUID = 1L;

    private String id;
    private String name;
    private String description;
    private List<TestCase> testCases;
    private Project parentProject;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private String createdBy;
    private String updatedBy;
    private boolean active;
    private String[] tags;
    private int priority;
    private int executionOrder;
    private boolean parallel;
    private String beforeSuite;
    private String afterSuite;
    
    /**
     * Creates a new test suite with default values and a randomly generated ID.
     */
    public TestSuite() {
        this.id = UUID.randomUUID().toString();
        this.testCases = new ArrayList<>();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.active = true;
        this.priority = 1;
        this.executionOrder = 0;
        this.parallel = false;
        this.tags = new String[0];
    }
    
    /**
     * Creates a new test suite with the specified name and a randomly generated ID.
     * 
     * @param name The name of the test suite
     */
    public TestSuite(String name) {
        this();
        this.name = name;
    }
    
    /**
     * Creates a new test suite with the specified name, description, and a randomly generated ID.
     * 
     * @param name The name of the test suite
     * @param description The description of the test suite
     */
    public TestSuite(String name, String description) {
        this(name);
        this.description = description;
    }
    
    /**
     * Gets the unique identifier of the test suite.
     * 
     * @return The test suite ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Sets the unique identifier of the test suite.
     * 
     * @param id The test suite ID
     */
    public void setId(String id) {
        this.id = id;
    }
    
    /**
     * Gets the name of the test suite.
     * 
     * @return The test suite name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Sets the name of the test suite.
     * 
     * @param name The test suite name
     */
    public void setName(String name) {
        this.name = name;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the description of the test suite.
     * 
     * @return The test suite description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the description of the test suite.
     * 
     * @param description The test suite description
     */
    public void setDescription(String description) {
        this.description = description;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the test cases contained in the test suite.
     * 
     * @return An unmodifiable list of test cases
     */
    public List<TestCase> getTestCases() {
        return Collections.unmodifiableList(testCases);
    }
    
    /**
     * Gets the mutable list of test cases for internal use.
     * 
     * @return The mutable list of test cases
     */
    private List<TestCase> getMutableTestCases() {
        return testCases;
    }
    
    /**
     * Adds a test case to the test suite.
     * 
     * @param testCase The test case to add
     * @return true if the test case was added successfully, false otherwise
     */
    public boolean addTestCase(TestCase testCase) {
        if (testCase == null) {
            return false;
        }
        
        // Set the parent test suite reference
        testCase.setParentSuite(this);
        
        // Add to the test cases list
        boolean result = getMutableTestCases().add(testCase);
        if (result) {
            this.updatedAt = LocalDateTime.now();
        }
        return result;
    }
    
    /**
     * Removes a test case from the test suite.
     * 
     * @param testCase The test case to remove
     * @return true if the test case was removed successfully, false otherwise
     */
    public boolean removeTestCase(TestCase testCase) {
        if (testCase == null) {
            return false;
        }
        
        // Remove from the test cases list
        boolean result = getMutableTestCases().remove(testCase);
        if (result) {
            // Clear the parent test suite reference
            testCase.setParentSuite(null);
            this.updatedAt = LocalDateTime.now();
        }
        return result;
    }
    
    /**
     * Gets a test case by its ID.
     * 
     * @param id The ID of the test case to retrieve
     * @return The test case with the specified ID, or null if not found
     */
    public TestCase getTestCaseById(String id) {
        if (id == null || id.isEmpty()) {
            return null;
        }
        
        for (TestCase testCase : getTestCases()) {
            if (id.equals(testCase.getId())) {
                return testCase;
            }
        }
        
        return null;
    }
    
    /**
     * Gets a test case by its name.
     * 
     * @param name The name of the test case to retrieve
     * @return The test case with the specified name, or null if not found
     */
    public TestCase getTestCaseByName(String name) {
        if (name == null || name.isEmpty()) {
            return null;
        }
        
        for (TestCase testCase : getTestCases()) {
            if (name.equals(testCase.getName())) {
                return testCase;
            }
        }
        
        return null;
    }
    
    /**
     * Gets the parent project of the test suite.
     * 
     * @return The parent project
     */
    public Project getParentProject() {
        return parentProject;
    }
    
    /**
     * Sets the parent project of the test suite.
     * 
     * @param parentProject The parent project
     */
    public void setParentProject(Project parentProject) {
        this.parentProject = parentProject;
    }
    
    /**
     * Gets the date and time when the test suite was created.
     * 
     * @return The creation date and time
     */
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    /**
     * Sets the date and time when the test suite was created.
     * 
     * @param createdAt The creation date and time
     */
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    
    /**
     * Gets the date and time when the test suite was last updated.
     * 
     * @return The last update date and time
     */
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
    
    /**
     * Sets the date and time when the test suite was last updated.
     * 
     * @param updatedAt The last update date and time
     */
    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
    
    /**
     * Gets the username of the user who created the test suite.
     * 
     * @return The username of the creator
     */
    public String getCreatedBy() {
        return createdBy;
    }
    
    /**
     * Sets the username of the user who created the test suite.
     * 
     * @param createdBy The username of the creator
     */
    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
    
    /**
     * Gets the username of the user who last updated the test suite.
     * 
     * @return The username of the last updater
     */
    public String getUpdatedBy() {
        return updatedBy;
    }
    
    /**
     * Sets the username of the user who last updated the test suite.
     * 
     * @param updatedBy The username of the last updater
     */
    public void setUpdatedBy(String updatedBy) {
        this.updatedBy = updatedBy;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Checks if the test suite is active.
     * 
     * @return true if the test suite is active, false otherwise
     */
    public boolean isActive() {
        return active;
    }
    
    /**
     * Sets whether the test suite is active.
     * 
     * @param active true if the test suite is active, false otherwise
     */
    public void setActive(boolean active) {
        this.active = active;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the tags associated with the test suite.
     * 
     * @return The tags array
     */
    public String[] getTags() {
        return tags.clone();
    }
    
    /**
     * Sets the tags associated with the test suite.
     * 
     * @param tags The tags array
     */
    public void setTags(String[] tags) {
        this.tags = tags != null ? tags.clone() : new String[0];
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the priority of the test suite.
     * Higher priority test suites are executed first.
     * 
     * @return The priority value
     */
    public int getPriority() {
        return priority;
    }
    
    /**
     * Sets the priority of the test suite.
     * Higher priority test suites are executed first.
     * 
     * @param priority The priority value
     */
    public void setPriority(int priority) {
        this.priority = priority;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the execution order of the test suite.
     * Test suites with lower execution order values are executed first (within the same priority).
     * 
     * @return The execution order value
     */
    public int getExecutionOrder() {
        return executionOrder;
    }
    
    /**
     * Sets the execution order of the test suite.
     * Test suites with lower execution order values are executed first (within the same priority).
     * 
     * @param executionOrder The execution order value
     */
    public void setExecutionOrder(int executionOrder) {
        this.executionOrder = executionOrder;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Checks if the test suite should be executed in parallel.
     * 
     * @return true if the test suite should be executed in parallel, false otherwise
     */
    public boolean isParallel() {
        return parallel;
    }
    
    /**
     * Sets whether the test suite should be executed in parallel.
     * 
     * @param parallel true if the test suite should be executed in parallel, false otherwise
     */
    public void setParallel(boolean parallel) {
        this.parallel = parallel;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the "before suite" initialization code.
     * 
     * @return The "before suite" code
     */
    public String getBeforeSuite() {
        return beforeSuite;
    }
    
    /**
     * Sets the "before suite" initialization code.
     * 
     * @param beforeSuite The "before suite" code
     */
    public void setBeforeSuite(String beforeSuite) {
        this.beforeSuite = beforeSuite;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the "after suite" cleanup code.
     * 
     * @return The "after suite" code
     */
    public String getAfterSuite() {
        return afterSuite;
    }
    
    /**
     * Sets the "after suite" cleanup code.
     * 
     * @param afterSuite The "after suite" code
     */
    public void setAfterSuite(String afterSuite) {
        this.afterSuite = afterSuite;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Creates a duplicate of this test suite with a new ID.
     * The duplicate will have the same properties but different test cases.
     * 
     * @param copyTestCases If true, the test cases will also be duplicated
     * @return A duplicate of this test suite
     */
    public TestSuite duplicate(boolean copyTestCases) {
        TestSuite duplicate = new TestSuite();
        duplicate.setName(this.name + " (Copy)");
        duplicate.setDescription(this.description);
        duplicate.setCreatedBy(this.createdBy);
        duplicate.setUpdatedBy(this.updatedBy);
        duplicate.setActive(this.active);
        duplicate.setTags(this.tags);
        duplicate.setPriority(this.priority);
        duplicate.setExecutionOrder(this.executionOrder);
        duplicate.setParallel(this.parallel);
        duplicate.setBeforeSuite(this.beforeSuite);
        duplicate.setAfterSuite(this.afterSuite);
        
        // Don't copy parent project reference
        
        // Copy test cases if requested
        if (copyTestCases) {
            for (TestCase testCase : this.getTestCases()) {
                duplicate.addTestCase(testCase.duplicate());
            }
        }
        
        return duplicate;
    }
    
    /**
     * Gets the number of test cases in the test suite.
     * 
     * @return The number of test cases
     */
    public int getTestCaseCount() {
        return getTestCases().size();
    }
    
    /**
     * Gets the number of active test cases in the test suite.
     * 
     * @return The number of active test cases
     */
    public int getActiveTestCaseCount() {
        int count = 0;
        for (TestCase testCase : getTestCases()) {
            if (testCase.isActive()) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Validates the test suite structure and returns a list of validation errors.
     * 
     * @return A list of validation error messages, or an empty list if the test suite is valid
     */
    public List<String> validate() {
        List<String> errors = new ArrayList<>();
        
        // Validate basic properties
        if (name == null || name.trim().isEmpty()) {
            errors.add("Test suite name is required (Suite ID: " + id + ")");
        }
        
        // Validate test cases
        for (TestCase testCase : getTestCases()) {
            errors.addAll(testCase.validate());
        }
        
        return errors;
    }
    
    /**
     * Checks if the test suite has valid configuration and structure.
     * 
     * @return true if the test suite is valid, false otherwise
     */
    public boolean isValid() {
        return validate().isEmpty();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        TestSuite other = (TestSuite) obj;
        return Objects.equals(id, other.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "TestSuite{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                ", testCases=" + testCases.size() +
                ", active=" + active +
                ", priority=" + priority +
                ", parallel=" + parallel +
                '}';
    }
}


TestCase.java
---------------------------------
package com.cstestforge.model.project;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

/**
 * Represents a test case within the CSTestForge framework.
 * A test case is a specific test scenario that can be executed.
 */
public class TestCase implements Serializable {
    
    private static final long serialVersionUID = 1L;

    private String id;
    private String name;
    private String description;
    private TestSuite parentSuite;
    private String testCode;
    private String beforeTest;
    private String afterTest;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private String createdBy;
    private String updatedBy;
    private boolean active;
    private String[] tags;
    private int priority;
    private int executionOrder;
    private Map<String, String> testData;
    private String[] dependencies;
    private long timeout;
    private int retryCount;
    private String[] categories;
    private boolean skipOnFailure;
    private Map<String, Object> metadata;
    private String screenshotMode;
    private String recordVideo;
    private String authorNotes;
    private String testType;
    private boolean dataDriven;
    private String dataSource;
    
    /**
     * Creates a new test case with default values and a randomly generated ID.
     */
    public TestCase() {
        this.id = UUID.randomUUID().toString();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.active = true;
        this.priority = 1;
        this.executionOrder = 0;
        this.testData = new HashMap<>();
        this.dependencies = new String[0];
        this.timeout = 60000; // Default 60 seconds
        this.retryCount = 0;
        this.categories = new String[0];
        this.skipOnFailure = false;
        this.metadata = new HashMap<>();
        this.tags = new String[0];
        this.screenshotMode = "ON_FAILURE"; // Default screenshot on failure only
        this.recordVideo = "NO"; // Default no video recording
        this.dataDriven = false;
    }
    
    /**
     * Creates a new test case with the specified name and a randomly generated ID.
     * 
     * @param name The name of the test case
     */
    public TestCase(String name) {
        this();
        this.name = name;
    }
    
    /**
     * Creates a new test case with the specified name, description, and a randomly generated ID.
     * 
     * @param name The name of the test case
     * @param description The description of the test case
     */
    public TestCase(String name, String description) {
        this(name);
        this.description = description;
    }
    
    /**
     * Gets the unique identifier of the test case.
     * 
     * @return The test case ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Sets the unique identifier of the test case.
     * 
     * @param id The test case ID
     */
    public void setId(String id) {
        this.id = id;
    }
    
    /**
     * Gets the name of the test case.
     * 
     * @return The test case name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Sets the name of the test case.
     * 
     * @param name The test case name
     */
    public void setName(String name) {
        this.name = name;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the description of the test case.
     * 
     * @return The test case description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the description of the test case.
     * 
     * @param description The test case description
     */
    public void setDescription(String description) {
        this.description = description;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the parent test suite of the test case.
     * 
     * @return The parent test suite
     */
    public TestSuite getParentSuite() {
        return parentSuite;
    }
    
    /**
     * Sets the parent test suite of the test case.
     * 
     * @param parentSuite The parent test suite
     */
    public void setParentSuite(TestSuite parentSuite) {
        this.parentSuite = parentSuite;
    }
    
    /**
     * Gets the main test code.
     * 
     * @return The test code
     */
    public String getTestCode() {
        return testCode;
    }
    
    /**
     * Sets the main test code.
     * 
     * @param testCode The test code
     */
    public void setTestCode(String testCode) {
        this.testCode = testCode;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the "before test" initialization code.
     * 
     * @return The "before test" code
     */
    public String getBeforeTest() {
        return beforeTest;
    }
    
    /**
     * Sets the "before test" initialization code.
     * 
     * @param beforeTest The "before test" code
     */
    public void setBeforeTest(String beforeTest) {
        this.beforeTest = beforeTest;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the "after test" cleanup code.
     * 
     * @return The "after test" code
     */
    public String getAfterTest() {
        return afterTest;
    }
    
    /**
     * Sets the "after test" cleanup code.
     * 
     * @param afterTest The "after test" code
     */
    public void setAfterTest(String afterTest) {
        this.afterTest = afterTest;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the date and time when the test case was created.
     * 
     * @return The creation date and time
     */
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    /**
     * Sets the date and time when the test case was created.
     * 
     * @param createdAt The creation date and time
     */
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    
    /**
     * Gets the date and time when the test case was last updated.
     * 
     * @return The last update date and time
     */
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
    
    /**
     * Sets the date and time when the test case was last updated.
     * 
     * @param updatedAt The last update date and time
     */
    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
    
    /**
     * Gets the username of the user who created the test case.
     * 
     * @return The username of the creator
     */
    public String getCreatedBy() {
        return createdBy;
    }
    
    /**
     * Sets the username of the user who created the test case.
     * 
     * @param createdBy The username of the creator
     */
    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
    
    /**
     * Gets the username of the user who last updated the test case.
     * 
     * @return The username of the last updater
     */
    public String getUpdatedBy() {
        return updatedBy;
    }
    
    /**
     * Sets the username of the user who last updated the test case.
     * 
     * @param updatedBy The username of the last updater
     */
    public void setUpdatedBy(String updatedBy) {
        this.updatedBy = updatedBy;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Checks if the test case is active.
     * 
     * @return true if the test case is active, false otherwise
     */
    public boolean isActive() {
        return active;
    }
    
    /**
     * Sets whether the test case is active.
     * 
     * @param active true if the test case is active, false otherwise
     */
    public void setActive(boolean active) {
        this.active = active;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the tags associated with the test case.
     * 
     * @return The tags array
     */
    public String[] getTags() {
        return tags.clone();
    }
    
    /**
     * Sets the tags associated with the test case.
     * 
     * @param tags The tags array
     */
    public void setTags(String[] tags) {
        this.tags = tags != null ? tags.clone() : new String[0];
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the priority of the test case.
     * Higher priority test cases are executed first.
     * 
     * @return The priority value
     */
    public int getPriority() {
        return priority;
    }
    
    /**
     * Sets the priority of the test case.
     * Higher priority test cases are executed first.
     * 
     * @param priority The priority value
     */
    public void setPriority(int priority) {
        this.priority = priority;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the execution order of the test case.
     * Test cases with lower execution order values are executed first (within the same priority).
     * 
     * @return The execution order value
     */
    public int getExecutionOrder() {
        return executionOrder;
    }
    
    /**
     * Sets the execution order of the test case.
     * Test cases with lower execution order values are executed first (within the same priority).
     * 
     * @param executionOrder The execution order value
     */
    public void setExecutionOrder(int executionOrder) {
        this.executionOrder = executionOrder;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the test data associated with the test case.
     * 
     * @return A copy of the test data map
     */
    public Map<String, String> getTestData() {
        return new HashMap<>(testData);
    }
    
    /**
     * Sets the test data associated with the test case.
     * 
     * @param testData The test data map
     */
    public void setTestData(Map<String, String> testData) {
        this.testData = testData != null ? new HashMap<>(testData) : new HashMap<>();
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Adds or updates a test data entry.
     * 
     * @param key The test data key
     * @param value The test data value
     */
    public void addTestData(String key, String value) {
        if (key != null && !key.isEmpty()) {
            this.testData.put(key, value);
            this.updatedAt = LocalDateTime.now();
        }
    }
    
    /**
     * Removes a test data entry.
     * 
     * @param key The test data key to remove
     * @return true if the entry was removed, false otherwise
     */
    public boolean removeTestData(String key) {
        if (key != null && !key.isEmpty() && this.testData.containsKey(key)) {
            this.testData.remove(key);
            this.updatedAt = LocalDateTime.now();
            return true;
        }
        return false;
    }
    
    /**
     * Gets the dependencies of the test case.
     * These are IDs of other test cases that must be executed before this one.
     * 
     * @return The dependencies array
     */
    public String[] getDependencies() {
        return dependencies.clone();
    }
    
    /**
     * Sets the dependencies of the test case.
     * These are IDs of other test cases that must be executed before this one.
     * 
     * @param dependencies The dependencies array
     */
    public void setDependencies(String[] dependencies) {
        this.dependencies = dependencies != null ? dependencies.clone() : new String[0];
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the timeout for the test case execution in milliseconds.
     * 
     * @return The timeout value in milliseconds
     */
    public long getTimeout() {
        return timeout;
    }
    
    /**
     * Sets the timeout for the test case execution in milliseconds.
     * 
     * @param timeout The timeout value in milliseconds
     */
    public void setTimeout(long timeout) {
        this.timeout = timeout;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the number of times to retry the test case if it fails.
     * 
     * @return The retry count
     */
    public int getRetryCount() {
        return retryCount;
    }
    
    /**
     * Sets the number of times to retry the test case if it fails.
     * 
     * @param retryCount The retry count
     */
    public void setRetryCount(int retryCount) {
        this.retryCount = retryCount;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the categories of the test case.
     * 
     * @return The categories array
     */
    public String[] getCategories() {
        return categories.clone();
    }
    
    /**
     * Sets the categories of the test case.
     * 
     * @param categories The categories array
     */
    public void setCategories(String[] categories) {
        this.categories = categories != null ? categories.clone() : new String[0];
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Checks if subsequent test cases should be skipped if this one fails.
     * 
     * @return true if subsequent test cases should be skipped, false otherwise
     */
    public boolean isSkipOnFailure() {
        return skipOnFailure;
    }
    
    /**
     * Sets whether subsequent test cases should be skipped if this one fails.
     * 
     * @param skipOnFailure true if subsequent test cases should be skipped, false otherwise
     */
    public void setSkipOnFailure(boolean skipOnFailure) {
        this.skipOnFailure = skipOnFailure;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the metadata associated with the test case.
     * 
     * @return A copy of the metadata map
     */
    public Map<String, Object> getMetadata() {
        return new HashMap<>(metadata);
    }
    
    /**
     * Sets the metadata associated with the test case.
     * 
     * @param metadata The metadata map
     */
    public void setMetadata(Map<String, Object> metadata) {
        this.metadata = metadata != null ? new HashMap<>(metadata) : new HashMap<>();
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Adds or updates a metadata entry.
     * 
     * @param key The metadata key
     * @param value The metadata value
     */
    public void addMetadata(String key, Object value) {
        if (key != null && !key.isEmpty()) {
            this.metadata.put(key, value);
            this.updatedAt = LocalDateTime.now();
        }
    }
    
    /**
     * Removes a metadata entry.
     * 
     * @param key The metadata key to remove
     * @return true if the entry was removed, false otherwise
     */
    public boolean removeMetadata(String key) {
        if (key != null && !key.isEmpty() && this.metadata.containsKey(key)) {
            this.metadata.remove(key);
            this.updatedAt = LocalDateTime.now();
            return true;
        }
        return false;
    }
    
    /**
     * Gets the screenshot mode for the test case.
     * Valid values are "ALWAYS", "ON_FAILURE", "NEVER", or custom settings.
     * 
     * @return The screenshot mode
     */
    public String getScreenshotMode() {
        return screenshotMode;
    }
    
    /**
     * Sets the screenshot mode for the test case.
     * Valid values are "ALWAYS", "ON_FAILURE", "NEVER", or custom settings.
     * 
     * @param screenshotMode The screenshot mode
     */
    public void setScreenshotMode(String screenshotMode) {
        this.screenshotMode = screenshotMode;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the video recording mode for the test case.
     * Valid values are "YES", "NO", or custom settings.
     * 
     * @return The video recording mode
     */
    public String getRecordVideo() {
        return recordVideo;
    }
    
    /**
     * Sets the video recording mode for the test case.
     * Valid values are "YES", "NO", or custom settings.
     * 
     * @param recordVideo The video recording mode
     */
    public void setRecordVideo(String recordVideo) {
        this.recordVideo = recordVideo;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the author's notes for the test case.
     * 
     * @return The author's notes
     */
    public String getAuthorNotes() {
        return authorNotes;
    }
    
    /**
     * Sets the author's notes for the test case.
     * 
     * @param authorNotes The author's notes
     */
    public void setAuthorNotes(String authorNotes) {
        this.authorNotes = authorNotes;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the test type, which can be "UI", "API", "PERFORMANCE", etc.
     * 
     * @return The test type
     */
    public String getTestType() {
        return testType;
    }
    
    /**
     * Sets the test type, which can be "UI", "API", "PERFORMANCE", etc.
     * 
     * @param testType The test type
     */
    public void setTestType(String testType) {
        this.testType = testType;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Checks if the test case is data-driven.
     * 
     * @return true if the test case is data-driven, false otherwise
     */
    public boolean isDataDriven() {
        return dataDriven;
    }
    
    /**
     * Sets whether the test case is data-driven.
     * 
     * @param dataDriven true if the test case is data-driven, false otherwise
     */
    public void setDataDriven(boolean dataDriven) {
        this.dataDriven = dataDriven;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Gets the data source for a data-driven test case.
     * This can be a file path, database connection string, or other source identifier.
     * 
     * @return The data source
     */
    public String getDataSource() {
        return dataSource;
    }
    
    /**
     * Sets the data source for a data-driven test case.
     * This can be a file path, database connection string, or other source identifier.
     * 
     * @param dataSource The data source
     */
    public void setDataSource(String dataSource) {
        this.dataSource = dataSource;
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * Creates a duplicate of this test case with a new ID.
     * 
     * @return A duplicate of this test case
     */
    public TestCase duplicate() {
        TestCase duplicate = new TestCase();
        duplicate.setName(this.name + " (Copy)");
        duplicate.setDescription(this.description);
        duplicate.setTestCode(this.testCode);
        duplicate.setBeforeTest(this.beforeTest);
        duplicate.setAfterTest(this.afterTest);
        duplicate.setCreatedBy(this.createdBy);
        duplicate.setUpdatedBy(this.updatedBy);
        duplicate.setActive(this.active);
        duplicate.setTags(this.tags);
        duplicate.setPriority(this.priority);
        duplicate.setExecutionOrder(this.executionOrder);
        duplicate.setTestData(this.testData);
        duplicate.setDependencies(this.dependencies);
        duplicate.setTimeout(this.timeout);
        duplicate.setRetryCount(this.retryCount);
        duplicate.setCategories(this.categories);
        duplicate.setSkipOnFailure(this.skipOnFailure);
        duplicate.setMetadata(this.metadata);
        duplicate.setScreenshotMode(this.screenshotMode);
        duplicate.setRecordVideo(this.recordVideo);
        duplicate.setAuthorNotes(this.authorNotes);
        duplicate.setTestType(this.testType);
        duplicate.setDataDriven(this.dataDriven);
        duplicate.setDataSource(this.dataSource);
        
        // Don't copy parent test suite reference
        
        return duplicate;
    }
    
    /**
     * Validates the test case structure and returns a list of validation errors.
     * 
     * @return A list of validation error messages, or an empty list if the test case is valid
     */
    public List<String> validate() {
        List<String> errors = new ArrayList<>();
        
        // Validate basic properties
        if (name == null || name.trim().isEmpty()) {
            errors.add("Test case name is required (Case ID: " + id + ")");
        }
        
        // Validate test code
        if (testCode == null || testCode.trim().isEmpty()) {
            errors.add("Test code is required for test case '" + name + "' (Case ID: " + id + ")");
        }
        
        // Validate data-driven properties
        if (dataDriven && (dataSource == null || dataSource.trim().isEmpty())) {
            errors.add("Data source is required for data-driven test case '" + name + "' (Case ID: " + id + ")");
        }
        
        return errors;
    }
    
    /**
     * Checks if the test case has valid configuration and structure.
     * 
     * @return true if the test case is valid, false otherwise
     */
    public boolean isValid() {
        return validate().isEmpty();
    }
    
    /**
     * Gets the full path of the test case including the parent test suite name.
     * 
     * @return The full path of the test case
     */
    public String getFullPath() {
        if (parentSuite != null) {
            return parentSuite.getName() + " / " + name;
        }
        return name;
    }
    
    /**
     * Gets the full path of the test case including the parent project and test suite names.
     * 
     * @return The full path of the test case including the parent project
     */
    public String getFullProjectPath() {
        if (parentSuite != null && parentSuite.getParentProject() != null) {
            return parentSuite.getParentProject().getName() + " / " + parentSuite.getName() + " / " + name;
        } else if (parentSuite != null) {
            return parentSuite.getName() + " / " + name;
        }
        return name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        TestCase other = (TestCase) obj;
        return Objects.equals(id, other.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "TestCase{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                ", active=" + active +
                ", priority=" + priority +
                ", testType='" + testType + '\'' +
                ", dataDriven=" + dataDriven +
                '}';
    }
}

ProjectConfig.java
------------------------------

package com.cstestforge.model.project;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Represents the configuration for a CSTestForge project.
 * This includes framework selection, language settings, and execution options.
 */
public class ProjectConfig implements Serializable {
    
    private static final long serialVersionUID = 1L;

    private FrameworkType frameworkType;
    private LanguageType languageType;
    private TestType testType;
    private String baseUrl;
    private boolean headless;
    private String defaultBrowser;
    private String[] supportedBrowsers;
    private int defaultImplicitWaitSeconds;
    private int defaultExplicitWaitSeconds;
    private int defaultPageLoadTimeoutSeconds;
    private int defaultScriptTimeoutSeconds;
    private Map<String, String> environmentVariables;
    private Map<String, Map<String, String>> environments;
    private String currentEnvironment;
    private boolean screenshotsEnabled;
    private boolean videoRecordingEnabled;
    private boolean reportsEnabled;
    private String reportOutputDir;
    private boolean parallelExecution;
    private int maxThreads;
    private boolean remoteExecution;
    private String gridUrl;
    private Map<String, Object> capabilities;
    private boolean cicdIntegration;
    private String cicdType;
    private String retryMechanism;
    private boolean selfHealingEnabled;
    private String dataSourceType;
    private String defaultDataSource;
    private Map<String, String> customSettings;
    
    /**
     * Creates a new project configuration with default values.
     */
    public ProjectConfig() {
        this.frameworkType = FrameworkType.SELENIUM;
        this.languageType = LanguageType.JAVA;
        this.testType = TestType.TESTNG;
        this.headless = false;
        this.defaultBrowser = "chrome";
        this.supportedBrowsers = new String[]{"chrome", "firefox", "edge"};
        this.defaultImplicitWaitSeconds = 0;
        this.defaultExplicitWaitSeconds = 30;
        this.defaultPageLoadTimeoutSeconds = 60;
        this.defaultScriptTimeoutSeconds = 30;
        this.environmentVariables = new HashMap<>();
        this.environments = new HashMap<>();
        this.screenshotsEnabled = true;
        this.videoRecordingEnabled = false;
        this.reportsEnabled = true;
        this.reportOutputDir = "test-output";
        this.parallelExecution = false;
        this.maxThreads = 5;
        this.remoteExecution = false;
        this.capabilities = new HashMap<>();
        this.cicdIntegration = false;
        this.retryMechanism = "none";
        this.selfHealingEnabled = true;
        this.customSettings = new HashMap<>();
    }
    
    /**
     * Gets the testing framework type.
     * 
     * @return The framework type
     */
    public FrameworkType getFrameworkType() {
        return frameworkType;
    }
    
    /**
     * Sets the testing framework type.
     * 
     * @param frameworkType The framework type
     */
    public void setFrameworkType(FrameworkType frameworkType) {
        this.frameworkType = frameworkType;
    }
    
    /**
     * Gets the programming language type.
     * 
     * @return The language type
     */
    public LanguageType getLanguageType() {
        return languageType;
    }
    
    /**
     * Sets the programming language type.
     * 
     * @param languageType The language type
     */
    public void setLanguageType(LanguageType languageType) {
        this.languageType = languageType;
    }
    
    /**
     * Gets the test implementation type.
     * 
     * @return The test type
     */
    public TestType getTestType() {
        return testType;
    }
    
    /**
     * Sets the test implementation type.
     * 
     * @param testType The test type
     */
    public void setTestType(TestType testType) {
        this.testType = testType;
    }
    
    /**
     * Gets the base URL for the application under test.
     * 
     * @return The base URL
     */
    public String getBaseUrl() {
        return baseUrl;
    }
    
    /**
     * Sets the base URL for the application under test.
     * 
     * @param baseUrl The base URL
     */
    public void setBaseUrl(String baseUrl) {
        this.baseUrl = baseUrl;
    }
    
    /**
     * Checks if the browser should run in headless mode.
     * 
     * @return true if headless mode is enabled, false otherwise
     */
    public boolean isHeadless() {
        return headless;
    }
    
    /**
     * Sets whether the browser should run in headless mode.
     * 
     * @param headless true if headless mode is enabled, false otherwise
     */
    public void setHeadless(boolean headless) {
        this.headless = headless;
    }
    
    /**
     * Gets the default browser for test execution.
     * 
     * @return The default browser name
     */
    public String getDefaultBrowser() {
        return defaultBrowser;
    }
    
    /**
     * Sets the default browser for test execution.
     * 
     * @param defaultBrowser The default browser name
     */
    public void setDefaultBrowser(String defaultBrowser) {
        this.defaultBrowser = defaultBrowser;
    }
    
    /**
     * Gets the supported browsers for test execution.
     * 
     * @return The supported browsers array
     */
    public String[] getSupportedBrowsers() {
        return supportedBrowsers.clone();
    }
    
    /**
     * Sets the supported browsers for test execution.
     * 
     * @param supportedBrowsers The supported browsers array
     */
    public void setSupportedBrowsers(String[] supportedBrowsers) {
        this.supportedBrowsers = supportedBrowsers != null ? supportedBrowsers.clone() : new String[0];
    }
    
    /**
     * Gets the default implicit wait timeout in seconds.
     * 
     * @return The implicit wait timeout in seconds
     */
    public int getDefaultImplicitWaitSeconds() {
        return defaultImplicitWaitSeconds;
    }
    
    /**
     * Sets the default implicit wait timeout in seconds.
     * 
     * @param defaultImplicitWaitSeconds The implicit wait timeout in seconds
     */
    public void setDefaultImplicitWaitSeconds(int defaultImplicitWaitSeconds) {
        this.defaultImplicitWaitSeconds = defaultImplicitWaitSeconds;
    }
    
    /**
     * Gets the default explicit wait timeout in seconds.
     * 
     * @return The explicit wait timeout in seconds
     */
    public int getDefaultExplicitWaitSeconds() {
        return defaultExplicitWaitSeconds;
    }
    
    /**
     * Sets the default explicit wait timeout in seconds.
     * 
     * @param defaultExplicitWaitSeconds The explicit wait timeout in seconds
     */
    public void setDefaultExplicitWaitSeconds(int defaultExplicitWaitSeconds) {
        this.defaultExplicitWaitSeconds = defaultExplicitWaitSeconds;
    }
    
    /**
     * Gets the default page load timeout in seconds.
     * 
     * @return The page load timeout in seconds
     */
    public int getDefaultPageLoadTimeoutSeconds() {
        return defaultPageLoadTimeoutSeconds;
    }
    
    /**
     * Sets the default page load timeout in seconds.
     * 
     * @param defaultPageLoadTimeoutSeconds The page load timeout in seconds
     */
    public void setDefaultPageLoadTimeoutSeconds(int defaultPageLoadTimeoutSeconds) {
        this.defaultPageLoadTimeoutSeconds = defaultPageLoadTimeoutSeconds;
    }
    
    /**
     * Gets the default script execution timeout in seconds.
     * 
     * @return The script timeout in seconds
     */
    public int getDefaultScriptTimeoutSeconds() {
        return defaultScriptTimeoutSeconds;
    }
    
    /**
     * Sets the default script execution timeout in seconds.
     * 
     * @param defaultScriptTimeoutSeconds The script timeout in seconds
     */
    public void setDefaultScriptTimeoutSeconds(int defaultScriptTimeoutSeconds) {
        this.defaultScriptTimeoutSeconds = defaultScriptTimeoutSeconds;
    }
    
    /**
     * Gets the environment variables for test execution.
     * 
     * @return A copy of the environment variables map
     */
    public Map<String, String> getEnvironmentVariables() {
        return new HashMap<>(environmentVariables);
    }
    
    /**
     * Sets the environment variables for test execution.
     * 
     * @param environmentVariables The environment variables map
     */
    public void setEnvironmentVariables(Map<String, String> environmentVariables) {
        this.environmentVariables = environmentVariables != null ? new HashMap<>(environmentVariables) : new HashMap<>();
    }
    
    /**
     * Gets the value of a specific environment variable.
     * 
     * @param key The environment variable key
     * @return The environment variable value, or null if not found
     */
    public String getEnvironmentVariable(String key) {
        return environmentVariables.get(key);
    }
    
    /**
     * Sets a specific environment variable.
     * 
     * @param key The environment variable key
     * @param value The environment variable value
     */
    public void setEnvironmentVariable(String key, String value) {
        if (key != null && !key.isEmpty()) {
            environmentVariables.put(key, value);
        }
    }
    
    /**
     * Removes a specific environment variable.
     * 
     * @param key The environment variable key
     * @return true if the variable was removed, false otherwise
     */
    public boolean removeEnvironmentVariable(String key) {
        if (key != null && !key.isEmpty() && environmentVariables.containsKey(key)) {
            environmentVariables.remove(key);
            return true;
        }
        return false;
    }
    
    /**
     * Gets the configured test environments.
     * 
     * @return A copy of the environments map
     */
    public Map<String, Map<String, String>> getEnvironments() {
        Map<String, Map<String, String>> copy = new HashMap<>();
        for (Map.Entry<String, Map<String, String>> entry : environments.entrySet()) {
            copy.put(entry.getKey(), new HashMap<>(entry.getValue()));
        }
        return copy;
    }
    
    /**
     * Sets the configured test environments.
     * 
     * @param environments The environments map
     */
    public void setEnvironments(Map<String, Map<String, String>> environments) {
        this.environments = new HashMap<>();
        if (environments != null) {
            for (Map.Entry<String, Map<String, String>> entry : environments.entrySet()) {
                this.environments.put(entry.getKey(), new HashMap<>(entry.getValue()));
            }
        }
    }
    
    /**
     * Gets a specific environment configuration.
     * 
     * @param environmentName The environment name
     * @return A copy of the environment configuration map, or null if not found
     */
    public Map<String, String> getEnvironment(String environmentName) {
        Map<String, String> environment = environments.get(environmentName);
        return environment != null ? new HashMap<>(environment) : null;
    }
    
    /**
     * Sets a specific environment configuration.
     * 
     * @param environmentName The environment name
     * @param configuration The environment configuration map
     */
    public void setEnvironment(String environmentName, Map<String, String> configuration) {
        if (environmentName != null && !environmentName.isEmpty() && configuration != null) {
            environments.put(environmentName, new HashMap<>(configuration));
        }
    }
    
    /**
     * Removes a specific environment configuration.
     * 
     * @param environmentName The environment name
     * @return true if the environment was removed, false otherwise
     */
    public boolean removeEnvironment(String environmentName) {
        if (environmentName != null && !environmentName.isEmpty() && environments.containsKey(environmentName)) {
            environments.remove(environmentName);
            return true;
        }
        return false;
    }
    
    /**
     * Gets the current active environment name.
     * 
     * @return The current environment name
     */
    public String getCurrentEnvironment() {
        return currentEnvironment;
    }
    
    /**
     * Sets the current active environment name.
     * 
     * @param currentEnvironment The current environment name
     */
    public void setCurrentEnvironment(String currentEnvironment) {
        this.currentEnvironment = currentEnvironment;
    }
    
    /**
     * Checks if screenshot capture is enabled.
     * 
     * @return true if screenshots are enabled, false otherwise
     */
    public boolean isScreenshotsEnabled() {
        return screenshotsEnabled;
    }
    
    /**
     * Sets whether screenshot capture is enabled.
     * 
     * @param screenshotsEnabled true if screenshots are enabled, false otherwise
     */
    public void setScreenshotsEnabled(boolean screenshotsEnabled) {
        this.screenshotsEnabled = screenshotsEnabled;
    }
    
    /**
     * Checks if video recording is enabled.
     * 
     * @return true if video recording is enabled, false otherwise
     */
    public boolean isVideoRecordingEnabled() {
        return videoRecordingEnabled;
    }
    
    /**
     * Sets whether video recording is enabled.
     * 
     * @param videoRecordingEnabled true if video recording is enabled, false otherwise
     */
    public void setVideoRecordingEnabled(boolean videoRecordingEnabled) {
        this.videoRecordingEnabled = videoRecordingEnabled;
    }
    
    /**
     * Checks if test reporting is enabled.
     * 
     * @return true if reports are enabled, false otherwise
     */
    public boolean isReportsEnabled() {
        return reportsEnabled;
    }
    
    /**
     * Sets whether test reporting is enabled.
     * 
     * @param reportsEnabled true if reports are enabled, false otherwise
     */
    public void setReportsEnabled(boolean reportsEnabled) {
        this.reportsEnabled = reportsEnabled;
    }
    
    /**
     * Gets the output directory for test reports.
     * 
     * @return The report output directory
     */
    public String getReportOutputDir() {
        return reportOutputDir;
    }
    
    /**
     * Sets the output directory for test reports.
     * 
     * @param reportOutputDir The report output directory
     */
    public void setReportOutputDir(String reportOutputDir) {
        this.reportOutputDir = reportOutputDir;
    }
    
    /**
     * Checks if parallel test execution is enabled.
     * 
     * @return true if parallel execution is enabled, false otherwise
     */
    public boolean isParallelExecution() {
        return parallelExecution;
    }
    
    /**
     * Sets whether parallel test execution is enabled.
     * 
     * @param parallelExecution true if parallel execution is enabled, false otherwise
     */
    public void setParallelExecution(boolean parallelExecution) {
        this.parallelExecution = parallelExecution;
    }
    
    /**
     * Gets the maximum number of parallel threads for test execution.
     * 
     * @return The maximum number of threads
     */
    public int getMaxThreads() {
        return maxThreads;
    }
    
    /**
     * Sets the maximum number of parallel threads for test execution.
     * 
     * @param maxThreads The maximum number of threads
     */
    public void setMaxThreads(int maxThreads) {
        this.maxThreads = maxThreads;
    }
    
    /**
     * Checks if remote execution on a grid is enabled.
     * 
     * @return true if remote execution is enabled, false otherwise
     */
    public boolean isRemoteExecution() {
        return remoteExecution;
    }
    
    /**
     * Sets whether remote execution on a grid is enabled.
     * 
     * @param remoteExecution true if remote execution is enabled, false otherwise
     */
    public void setRemoteExecution(boolean remoteExecution) {
        this.remoteExecution = remoteExecution;
    }
    
    /**
     * Gets the URL of the Selenium/Playwright grid for remote execution.
     * 
     * @return The grid URL
     */
    public String getGridUrl() {
        return gridUrl;
    }
    
    /**
     * Sets the URL of the Selenium/Playwright grid for remote execution.
     * 
     * @param gridUrl The grid URL
     */
    public void setGridUrl(String gridUrl) {
        this.gridUrl = gridUrl;
    }
    
    /**
     * Gets the browser capabilities for remote execution.
     * 
     * @return A copy of the capabilities map
     */
    public Map<String, Object> getCapabilities() {
        return new HashMap<>(capabilities);
    }
    
    /**
     * Sets the browser capabilities for remote execution.
     * 
     * @param capabilities The capabilities map
     */
    public void setCapabilities(Map<String, Object> capabilities) {
        this.capabilities = capabilities != null ? new HashMap<>(capabilities) : new HashMap<>();
    }
    
    /**
     * Gets a specific capability value.
     * 
     * @param key The capability key
     * @return The capability value, or null if not found
     */
    public Object getCapability(String key) {
        return capabilities.get(key);
    }
    
    /**
     * Sets a specific capability value.
     * 
     * @param key The capability key
     * @param value The capability value
     */
    public void setCapability(String key, Object value) {
        if (key != null && !key.isEmpty()) {
            capabilities.put(key, value);
        }
    }
    
    /**
     * Removes a specific capability.
     * 
     * @param key The capability key
     * @return true if the capability was removed, false otherwise
     */
    public boolean removeCapability(String key) {
        if (key != null && !key.isEmpty() && capabilities.containsKey(key)) {
            capabilities.remove(key);
            return true;
        }
        return false;
    }
    
    /**
     * Checks if CI/CD integration is enabled.
     * 
     * @return true if CI/CD integration is enabled, false otherwise
     */
    public boolean isCicdIntegration() {
        return cicdIntegration;
    }
    
    /**
     * Sets whether CI/CD integration is enabled.
     * 
     * @param cicdIntegration true if CI/CD integration is enabled, false otherwise
     */
    public void setCicdIntegration(boolean cicdIntegration) {
        this.cicdIntegration = cicdIntegration;
    }
    
    /**
     * Gets the CI/CD system type (e.g., "jenkins", "azure_devops", "github_actions").
     * 
     * @return The CI/CD type
     */
    public String getCicdType() {
        return cicdType;
    }
    
    /**
     * Sets the CI/CD system type (e.g., "jenkins", "azure_devops", "github_actions").
     * 
     * @param cicdType The CI/CD type
     */
    public void setCicdType(String cicdType) {
        this.cicdType = cicdType;
    }
    
    /**
     * Gets the retry mechanism for failed tests (e.g., "none", "immediately", "at_end").
     * 
     * @return The retry mechanism
     */
    public String getRetryMechanism() {
        return retryMechanism;
    }
    
    /**
     * Sets the retry mechanism for failed tests (e.g., "none", "immediately", "at_end").
     * 
     * @param retryMechanism The retry mechanism
     */
    public void setRetryMechanism(String retryMechanism) {
        this.retryMechanism = retryMechanism;
    }
    
    /**
     * Checks if self-healing locators are enabled.
     * 
     * @return true if self-healing is enabled, false otherwise
     */
    public boolean isSelfHealingEnabled() {
        return selfHealingEnabled;
    }
    
    /**
     * Sets whether self-healing locators are enabled.
     * 
     * @param selfHealingEnabled true if self-healing is enabled, false otherwise
     */
    public void setSelfHealingEnabled(boolean selfHealingEnabled) {
        this.selfHealingEnabled = selfHealingEnabled;
    }
    
    /**
     * Gets the default data source type (e.g., "excel", "csv", "json", "database").
     * 
     * @return The data source type
     */
    public String getDataSourceType() {
        return dataSourceType;
    }
    
    /**
     * Sets the default data source type (e.g., "excel", "csv", "json", "database").
     * 
     * @param dataSourceType The data source type
     */
    public void setDataSourceType(String dataSourceType) {
        this.dataSourceType = dataSourceType;
    }
    
    /**
     * Gets the default data source path or connection string.
     * 
     * @return The default data source
     */
    public String getDefaultDataSource() {
        return defaultDataSource;
    }
    
    /**
     * Sets the default data source path or connection string.
     * 
     * @param defaultDataSource The default data source
     */
    public void setDefaultDataSource(String defaultDataSource) {
        this.defaultDataSource = defaultDataSource;
    }
    
    /**
     * Gets the custom settings for the project.
     * 
     * @return A copy of the custom settings map
     */
    public Map<String, String> getCustomSettings() {
        return new HashMap<>(customSettings);
    }
    
    /**
     * Sets the custom settings for the project.
     * 
     * @param customSettings The custom settings map
     */
    public void setCustomSettings(Map<String, String> customSettings) {
        this.customSettings = customSettings != null ? new HashMap<>(customSettings) : new HashMap<>();
    }
    
    /**
     * Gets a specific custom setting value.
     * 
     * @param key The custom setting key
     * @return The custom setting value, or null if not found
     */
    public String getCustomSetting(String key) {
        return customSettings.get(key);
    }
    
    /**
     * Sets a specific custom setting value.
     * 
     * @param key The custom setting key
     * @param value The custom setting value
     */
    public void setCustomSetting(String key, String value) {
        if (key != null && !key.isEmpty()) {
            customSettings.put(key, value);
        }
    }
    
    /**
     * Removes a specific custom setting.
     * 
     * @param key The custom setting key
     * @return true if the setting was removed, false otherwise
     */
    public boolean removeCustomSetting(String key) {
        if (key != null && !key.isEmpty() && customSettings.containsKey(key)) {
            customSettings.remove(key);
            return true;
        }
        return false;
    }
    
    /**
     * Creates a duplicate of this project configuration.
     * 
     * @return A duplicate of this project configuration
     */
    public ProjectConfig duplicate() {
        ProjectConfig duplicate = new ProjectConfig();
        duplicate.setFrameworkType(this.frameworkType);
        duplicate.setLanguageType(this.languageType);
        duplicate.setTestType(this.testType);
        duplicate.setBaseUrl(this.baseUrl);
        duplicate.setHeadless(this.headless);
        duplicate.setDefaultBrowser(this.defaultBrowser);
        duplicate.setSupportedBrowsers(this.supportedBrowsers);
        duplicate.setDefaultImplicitWaitSeconds(this.defaultImplicitWaitSeconds);
        duplicate.setDefaultExplicitWaitSeconds(this.defaultExplicitWaitSeconds);
        duplicate.setDefaultPageLoadTimeoutSeconds(this.defaultPageLoadTimeoutSeconds);
        duplicate.setDefaultScriptTimeoutSeconds(this.defaultScriptTimeoutSeconds);
        duplicate.setEnvironmentVariables(this.environmentVariables);
        duplicate.setEnvironments(this.environments);
        duplicate.setCurrentEnvironment(this.currentEnvironment);
        duplicate.setScreenshotsEnabled(this.screenshotsEnabled);
        duplicate.setVideoRecordingEnabled(this.videoRecordingEnabled);
        duplicate.setReportsEnabled(this.reportsEnabled);
        duplicate.setReportOutputDir(this.reportOutputDir);
        duplicate.setParallelExecution(this.parallelExecution);
        duplicate.setMaxThreads(this.maxThreads);
        duplicate.setRemoteExecution(this.remoteExecution);
        duplicate.setGridUrl(this.gridUrl);
        duplicate.setCapabilities(this.capabilities);
        duplicate.setCicdIntegration(this.cicdIntegration);
        duplicate.setCicdType(this.cicdType);
        duplicate.setRetryMechanism(this.retryMechanism);
        duplicate.setSelfHealingEnabled(this.selfHealingEnabled);
        duplicate.setDataSourceType(this.dataSourceType);
        duplicate.setDefaultDataSource(this.defaultDataSource);
        duplicate.setCustomSettings(this.customSettings);
        
        return duplicate;
    }
    
    /**
     * Validates the project configuration and returns a list of validation errors.
     * 
     * @return A list of validation error messages, or an empty list if the configuration is valid
     */
    public List<String> validate() {
        List<String> errors = new ArrayList<>();
        
        // Validate framework type
        if (frameworkType == null) {
            errors.add("Framework type is required");
        }
        
        // Validate language type
        if (languageType == null) {
            errors.add("Language type is required");
        }
        
        // Validate test type
        if (testType == null) {
            errors.add("Test type is required");
        }
        
        // Validate base URL if provided
        if (baseUrl != null && !baseUrl.isEmpty() && !isValidUrl(baseUrl)) {
            errors.add("Base URL is invalid: " + baseUrl);
        }
        
        // Validate default browser
        if (defaultBrowser == null || defaultBrowser.isEmpty()) {
            errors.add("Default browser is required");
        } else if (!isBrowserSupported(defaultBrowser)) {
            errors.add("Default browser '" + defaultBrowser + "' is not in the list of supported browsers");
        }
        
        // Validate supported browsers
        if (supportedBrowsers == null || supportedBrowsers.length == 0) {
            errors.add("At least one supported browser is required");
        }
        
        // Validate timeout values
        if (defaultExplicitWaitSeconds < 0) {
            errors.add("Default explicit wait seconds cannot be negative");
        }
        if (defaultImplicitWaitSeconds < 0) {
            errors.add("Default implicit wait seconds cannot be negative");
        }
        if (defaultPageLoadTimeoutSeconds <= 0) {
            errors.add("Default page load timeout seconds must be positive");
        }
        if (defaultScriptTimeoutSeconds <= 0) {
            errors.add("Default script timeout seconds must be positive");
        }
        
        // Validate parallel execution settings
        if (parallelExecution && maxThreads <= 0) {
            errors.add("Maximum threads must be positive for parallel execution");
        }
        
        // Validate remote execution settings
        if (remoteExecution && (gridUrl == null || gridUrl.isEmpty())) {
            errors.add("Grid URL is required for remote execution");
        }
        
        // Validate CI/CD settings
        if (cicdIntegration && (cicdType == null || cicdType.isEmpty())) {
            errors.add("CI/CD type is required when CI/CD integration is enabled");
        }
        
        // Validate data source settings
        if (dataSourceType != null && !dataSourceType.isEmpty() && 
                (defaultDataSource == null || defaultDataSource.isEmpty())) {
            errors.add("Default data source is required when data source type is specified");
        }
        
        // Validate current environment
        if (currentEnvironment != null && !currentEnvironment.isEmpty() && 
                !environments.containsKey(currentEnvironment)) {
            errors.add("Current environment '" + currentEnvironment + "' is not defined in the environments map");
        }
        
        return errors;
    }
    
    /**
     * Checks if the project configuration is valid.
     * 
     * @return true if the configuration is valid, false otherwise
     */
    public boolean isValid() {
        return validate().isEmpty();
    }
    
    /**
     * Checks if a specific browser is in the list of supported browsers.
     * 
     * @param browser The browser to check
     * @return true if the browser is supported, false otherwise
     */
    private boolean isBrowserSupported(String browser) {
        if (browser == null || browser.isEmpty() || supportedBrowsers == null) {
            return false;
        }
        
        for (String supportedBrowser : supportedBrowsers) {
            if (browser.equalsIgnoreCase(supportedBrowser)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Checks if a string is a valid URL.
     * 
     * @param url The URL to check
     * @return true if the URL is valid, false otherwise
     */
    private boolean isValidUrl(String url) {
        if (url == null || url.isEmpty()) {
            return false;
        }
        
        try {
            new java.net.URL(url).toURI();
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        ProjectConfig other = (ProjectConfig) obj;
        return Objects.equals(frameworkType, other.frameworkType) &&
               Objects.equals(languageType, other.languageType) &&
               Objects.equals(testType, other.testType) &&
               Objects.equals(baseUrl, other.baseUrl) &&
               headless == other.headless &&
               Objects.equals(defaultBrowser, other.defaultBrowser);
        // Note: Not including all fields in equals for brevity and performance
    }

    @Override
    public int hashCode() {
        return Objects.hash(frameworkType, languageType, testType, baseUrl, headless, defaultBrowser);
        // Note: Not including all fields in hashCode for brevity and performance
    }

    @Override
    public String toString() {
        return "ProjectConfig{" +
                "frameworkType=" + frameworkType +
                ", languageType=" + languageType +
                ", testType=" + testType +
                ", baseUrl='" + baseUrl + '\'' +
                ", defaultBrowser='" + defaultBrowser + '\'' +
                ", parallelExecution=" + parallelExecution +
                ", remoteExecution=" + remoteExecution +
                ", selfHealingEnabled=" + selfHealingEnabled +
                '}';
    }
}


FrameworkType.java
-------------------------

package com.cstestforge.model.project;

import java.io.Serializable;

/**
 * Enumeration of supported testing frameworks in the CSTestForge system.
 */
public enum FrameworkType implements Serializable {
    
    /**
     * Selenium WebDriver framework for browser automation
     */
    SELENIUM("Selenium WebDriver", "selenium"),
    
    /**
     * Playwright framework for browser automation
     */
    PLAYWRIGHT("Playwright", "playwright");
    
    private final String displayName;
    private final String code;
    
    /**
     * Creates a new framework type with the specified display name and code.
     * 
     * @param displayName The human-readable display name
     * @param code The machine-readable code
     */
    private FrameworkType(String displayName, String code) {
        this.displayName = displayName;
        this.code = code;
    }
    
    /**
     * Gets the human-readable display name of the framework type.
     * 
     * @return The display name
     */
    public String getDisplayName() {
        return displayName;
    }
    
    /**
     * Gets the machine-readable code of the framework type.
     * 
     * @return The code
     */
    public String getCode() {
        return code;
    }
    
    /**
     * Gets a framework type from its code.
     * 
     * @param code The code to look up
     * @return The corresponding framework type, or null if not found
     */
    public static FrameworkType fromCode(String code) {
        if (code == null || code.isEmpty()) {
            return null;
        }
        
        for (FrameworkType type : values()) {
            if (type.getCode().equalsIgnoreCase(code)) {
                return type;
            }
        }
        
        return null;
    }
    
    /**
     * Gets a framework type from its display name.
     * 
     * @param displayName The display name to look up
     * @return The corresponding framework type, or null if not found
     */
    public static FrameworkType fromDisplayName(String displayName) {
        if (displayName == null || displayName.isEmpty()) {
            return null;
        }
        
        for (FrameworkType type : values()) {
            if (type.getDisplayName().equalsIgnoreCase(displayName)) {
                return type;
            }
        }
        
        return null;
    }
    
    /**
     * Returns the human-readable display name of the framework type.
     * 
     * @return The display name
     */
    @Override
    public String toString() {
        return displayName;
    }
}


LanguageType.java
-------------------------

package com.cstestforge.model.project;

import java.io.Serializable;

/**
 * Enumeration of supported programming languages in the CSTestForge system.
 */
public enum LanguageType implements Serializable {
    
    /**
     * Java programming language
     */
    JAVA("Java", "java"),
    
    /**
     * TypeScript programming language
     */
    TYPESCRIPT("TypeScript", "typescript");
    
    private final String displayName;
    private final String code;
    
    /**
     * Creates a new language type with the specified display name and code.
     * 
     * @param displayName The human-readable display name
     * @param code The machine-readable code
     */
    private LanguageType(String displayName, String code) {
        this.displayName = displayName;
        this.code = code;
    }
    
    /**
     * Gets the human-readable display name of the language type.
     * 
     * @return The display name
     */
    public String getDisplayName() {
        return displayName;
    }
    
    /**
     * Gets the machine-readable code of the language type.
     * 
     * @return The code
     */
    public String getCode() {
        return code;
    }
    
    /**
     * Gets a language type from its code.
     * 
     * @param code The code to look up
     * @return The corresponding language type, or null if not found
     */
    public static LanguageType fromCode(String code) {
        if (code == null || code.isEmpty()) {
            return null;
        }
        
        for (LanguageType type : values()) {
            if (type.getCode().equalsIgnoreCase(code)) {
                return type;
            }
        }
        
        return null;
    }
    
    /**
     * Gets a language type from its display name.
     * 
     * @param displayName The display name to look up
     * @return The corresponding language type, or null if not found
     */
    public static LanguageType fromDisplayName(String displayName) {
        if (displayName == null || displayName.isEmpty()) {
            return null;
        }
        
        for (LanguageType type : values()) {
            if (type.getDisplayName().equalsIgnoreCase(displayName)) {
                return type;
            }
        }
        
        return null;
    }
    
    /**
     * Checks if the language supports native annotation processing.
     * 
     * @return true if the language supports annotations, false otherwise
     */
    public boolean supportsAnnotations() {
        return this == JAVA;
    }
    
    /**
     * Checks if the language uses decorators instead of annotations.
     * 
     * @return true if the language uses decorators, false otherwise
     */
    public boolean usesDecorators() {
        return this == TYPESCRIPT;
    }
    
    /**
     * Gets the file extension for source files in this language.
     * 
     * @return The file extension, including the dot
     */
    public String getFileExtension() {
        switch (this) {
            case JAVA:
                return ".java";
            case TYPESCRIPT:
                return ".ts";
            default:
                return "";
        }
    }
    
    /**
     * Returns the human-readable display name of the language type.
     * 
     * @return The display name
     */
    @Override
    public String toString() {
        return displayName;
    }
}


TestType.java
------------------------

package com.cstestforge.model.project;

import java.io.Serializable;

/**
 * Enumeration of supported test implementation types in the CSTestForge system.
 */
public enum TestType implements Serializable {
    
    /**
     * TestNG-based testing approach
     */
    TESTNG("TestNG", "testng"),
    
    /**
     * Behavior-Driven Development (BDD) approach using Cucumber
     */
    BDD("Cucumber BDD", "bdd");
    
    private final String displayName;
    private final String code;
    
    /**
     * Creates a new test type with the specified display name and code.
     * 
     * @param displayName The human-readable display name
     * @param code The machine-readable code
     */
    private TestType(String displayName, String code) {
        this.displayName = displayName;
        this.code = code;
    }
    
    /**
     * Gets the human-readable display name of the test type.
     * 
     * @return The display name
     */
    public String getDisplayName() {
        return displayName;
    }
    
    /**
     * Gets the machine-readable code of the test type.
     * 
     * @return The code
     */
    public String getCode() {
        return code;
    }
    
    /**
     * Gets a test type from its code.
     * 
     * @param code The code to look up
     * @return The corresponding test type, or null if not found
     */
    public static TestType fromCode(String code) {
        if (code == null || code.isEmpty()) {
            return null;
        }
        
        for (TestType type : values()) {
            if (type.getCode().equalsIgnoreCase(code)) {
                return type;
            }
        }
        
        return null;
    }
    
    /**
     * Gets a test type from its display name.
     * 
     * @param displayName The display name to look up
     * @return The corresponding test type, or null if not found
     */
    public static TestType fromDisplayName(String displayName) {
        if (displayName == null || displayName.isEmpty()) {
            return null;
        }
        
        for (TestType type : values()) {
            if (type.getDisplayName().equalsIgnoreCase(displayName)) {
                return type;
            }
        }
        
        return null;
    }
    
    /**
     * Checks if the test type uses feature files.
     * 
     * @return true if the test type uses feature files, false otherwise
     */
    public boolean usesFeatureFiles() {
        return this == BDD;
    }
    
    /**
     * Checks if the test type uses Java annotations or TypeScript decorators for test definition.
     * 
     * @return true if the test type uses annotations/decorators, false otherwise
     */
    public boolean usesAnnotations() {
        return this == TESTNG;
    }
    
    /**
     * Checks if the test type uses step definitions.
     * 
     * @return true if the test type uses step definitions, false otherwise
     */
    public boolean usesStepDefinitions() {
        return this == BDD;
    }
    
    /**
     * Gets the directory name for test resources specific to this test type.
     * 
     * @return The directory name for test resources
     */
    public String getResourcesDirectoryName() {
        switch (this) {
            case BDD:
                return "features";
            case TESTNG:
                return "testdata";
            default:
                return "resources";
        }
    }
    
    /**
     * Returns the human-readable display name of the test type.
     * 
     * @return The display name
     */
    @Override
    public String toString() {
        return displayName;
    }
}


ElementFingerPrint.java
-------------------------------
package com.cstestforge.framework.core.selfhealing;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Represents a fingerprint of an element's characteristics used for self-healing locator strategies.
 * An element fingerprint captures various properties of an element that can be used to identify
 * it reliably even when its primary locator changes.
 */
public class ElementFingerprint implements Serializable {

    private static final long serialVersionUID = 1L;
    
    private final String elementId;
    private final String tagName;
    private final Map<String, String> attributes;
    private final String textContent;
    private final String innerHtml;
    private final String xpath;
    private final String cssSelector;
    private final Position position;
    private final Map<String, String> styles;
    private final List<String> classes;
    private final Size size;
    private final Map<String, Double> accessibilityScore;
    private final List<Relationship> relationships;
    private final Map<String, Object> customProperties;
    
    /**
     * Builder class for creating ElementFingerprint instances.
     */
    public static class Builder {
        private String elementId = "";
        private String tagName = "";
        private final Map<String, String> attributes = new HashMap<>();
        private String textContent = "";
        private String innerHtml = "";
        private String xpath = "";
        private String cssSelector = "";
        private Position position = new Position(0, 0, 0);
        private final Map<String, String> styles = new HashMap<>();
        private final List<String> classes = new ArrayList<>();
        private Size size = new Size(0, 0);
        private final Map<String, Double> accessibilityScore = new HashMap<>();
        private final List<Relationship> relationships = new ArrayList<>();
        private final Map<String, Object> customProperties = new HashMap<>();
        
        /**
         * Default constructor for the builder.
         */
        public Builder() {
        }
        
        /**
         * Sets the element's HTML ID attribute.
         * 
         * @param elementId The element ID
         * @return This builder instance
         */
        public Builder withElementId(String elementId) {
            this.elementId = elementId != null ? elementId : "";
            return this;
        }
        
        /**
         * Sets the element's HTML tag name.
         * 
         * @param tagName The tag name
         * @return This builder instance
         */
        public Builder withTagName(String tagName) {
            this.tagName = tagName != null ? tagName.toLowerCase() : "";
            return this;
        }
        
        /**
         * Adds an HTML attribute to the element fingerprint.
         * 
         * @param name The attribute name
         * @param value The attribute value
         * @return This builder instance
         */
        public Builder withAttribute(String name, String value) {
            if (name != null && !name.isEmpty()) {
                this.attributes.put(name.toLowerCase(), value != null ? value : "");
            }
            return this;
        }
        
        /**
         * Sets multiple HTML attributes for the element fingerprint.
         * 
         * @param attributes Map of attribute names to values
         * @return This builder instance
         */
        public Builder withAttributes(Map<String, String> attributes) {
            if (attributes != null) {
                for (Map.Entry<String, String> entry : attributes.entrySet()) {
                    withAttribute(entry.getKey(), entry.getValue());
                }
            }
            return this;
        }
        
        /**
         * Sets the element's text content.
         * 
         * @param textContent The text content
         * @return This builder instance
         */
        public Builder withTextContent(String textContent) {
            this.textContent = textContent != null ? textContent : "";
            return this;
        }
        
        /**
         * Sets the element's inner HTML.
         * 
         * @param innerHtml The inner HTML
         * @return This builder instance
         */
        public Builder withInnerHtml(String innerHtml) {
            this.innerHtml = innerHtml != null ? innerHtml : "";
            return this;
        }
        
        /**
         * Sets the element's XPath.
         * 
         * @param xpath The XPath
         * @return This builder instance
         */
        public Builder withXpath(String xpath) {
            this.xpath = xpath != null ? xpath : "";
            return this;
        }
        
        /**
         * Sets the element's CSS selector.
         * 
         * @param cssSelector The CSS selector
         * @return This builder instance
         */
        public Builder withCssSelector(String cssSelector) {
            this.cssSelector = cssSelector != null ? cssSelector : "";
            return this;
        }
        
        /**
         * Sets the element's position on the page.
         * 
         * @param position The position object
         * @return This builder instance
         */
        public Builder withPosition(Position position) {
            this.position = position != null ? position : new Position(0, 0, 0);
            return this;
        }
        
        /**
         * Sets the element's position using coordinates and z-index.
         * 
         * @param x The x-coordinate
         * @param y The y-coordinate
         * @param zIndex The z-index
         * @return This builder instance
         */
        public Builder withPosition(int x, int y, int zIndex) {
            this.position = new Position(x, y, zIndex);
            return this;
        }
        
        /**
         * Adds a CSS style to the element fingerprint.
         * 
         * @param name The style name
         * @param value The style value
         * @return This builder instance
         */
        public Builder withStyle(String name, String value) {
            if (name != null && !name.isEmpty()) {
                this.styles.put(name.toLowerCase(), value != null ? value : "");
            }
            return this;
        }
        
        /**
         * Sets multiple CSS styles for the element fingerprint.
         * 
         * @param styles Map of style names to values
         * @return This builder instance
         */
        public Builder withStyles(Map<String, String> styles) {
            if (styles != null) {
                for (Map.Entry<String, String> entry : styles.entrySet()) {
                    withStyle(entry.getKey(), entry.getValue());
                }
            }
            return this;
        }
        
        /**
         * Adds a CSS class to the element fingerprint.
         * 
         * @param className The class name
         * @return This builder instance
         */
        public Builder withClass(String className) {
            if (className != null && !className.isEmpty()) {
                this.classes.add(className);
            }
            return this;
        }
        
        /**
         * Adds multiple CSS classes to the element fingerprint.
         * 
         * @param classNames List of class names
         * @return This builder instance
         */
        public Builder withClasses(List<String> classNames) {
            if (classNames != null) {
                for (String className : classNames) {
                    withClass(className);
                }
            }
            return this;
        }
        
        /**
         * Sets the element's size.
         * 
         * @param size The size object
         * @return This builder instance
         */
        public Builder withSize(Size size) {
            this.size = size != null ? size : new Size(0, 0);
            return this;
        }
        
        /**
         * Sets the element's size using width and height.
         * 
         * @param width The width
         * @param height The height
         * @return This builder instance
         */
        public Builder withSize(int width, int height) {
            this.size = new Size(width, height);
            return this;
        }
        
        /**
         * Adds an accessibility score to the element fingerprint.
         * 
         * @param category The accessibility category
         * @param score The score (0.0 to 1.0)
         * @return This builder instance
         */
        public Builder withAccessibilityScore(String category, Double score) {
            if (category != null && !category.isEmpty() && score != null) {
                this.accessibilityScore.put(category, score);
            }
            return this;
        }
        
        /**
         * Sets multiple accessibility scores for the element fingerprint.
         * 
         * @param scores Map of accessibility categories to scores
         * @return This builder instance
         */
        public Builder withAccessibilityScores(Map<String, Double> scores) {
            if (scores != null) {
                for (Map.Entry<String, Double> entry : scores.entrySet()) {
                    withAccessibilityScore(entry.getKey(), entry.getValue());
                }
            }
            return this;
        }
        
        /**
         * Adds a relationship with another element to the fingerprint.
         * 
         * @param relationship The relationship object
         * @return This builder instance
         */
        public Builder withRelationship(Relationship relationship) {
            if (relationship != null) {
                this.relationships.add(relationship);
            }
            return this;
        }
        
        /**
         * Adds multiple relationships to the element fingerprint.
         * 
         * @param relationships List of relationship objects
         * @return This builder instance
         */
        public Builder withRelationships(List<Relationship> relationships) {
            if (relationships != null) {
                for (Relationship relationship : relationships) {
                    withRelationship(relationship);
                }
            }
            return this;
        }
        
        /**
         * Adds a custom property to the element fingerprint.
         * 
         * @param name The property name
         * @param value The property value
         * @return This builder instance
         */
        public Builder withCustomProperty(String name, Object value) {
            if (name != null && !name.isEmpty()) {
                this.customProperties.put(name, value);
            }
            return this;
        }
        
        /**
         * Sets multiple custom properties for the element fingerprint.
         * 
         * @param properties Map of property names to values
         * @return This builder instance
         */
        public Builder withCustomProperties(Map<String, Object> properties) {
            if (properties != null) {
                for (Map.Entry<String, Object> entry : properties.entrySet()) {
                    withCustomProperty(entry.getKey(), entry.getValue());
                }
            }
            return this;
        }
        
        /**
         * Builds an ElementFingerprint from the current builder state.
         * 
         * @return The element fingerprint
         */
        public ElementFingerprint build() {
            return new ElementFingerprint(this);
        }
    }
    
    /**
     * Creates a new element fingerprint from a builder.
     * 
     * @param builder The builder with configuration
     */
    private ElementFingerprint(Builder builder) {
        this.elementId = builder.elementId;
        this.tagName = builder.tagName;
        this.attributes = new HashMap<>(builder.attributes);
        this.textContent = builder.textContent;
        this.innerHtml = builder.innerHtml;
        this.xpath = builder.xpath;
        this.cssSelector = builder.cssSelector;
        this.position = builder.position;
        this.styles = new HashMap<>(builder.styles);
        this.classes = new ArrayList<>(builder.classes);
        this.size = builder.size;
        this.accessibilityScore = new HashMap<>(builder.accessibilityScore);
        this.relationships = new ArrayList<>(builder.relationships);
        this.customProperties = new HashMap<>(builder.customProperties);
    }
    
    /**
     * Gets the element's HTML ID attribute.
     * 
     * @return The element ID
     */
    public String getElementId() {
        return elementId;
    }
    
    /**
     * Gets the element's HTML tag name.
     * 
     * @return The tag name
     */
    public String getTagName() {
        return tagName;
    }
    
    /**
     * Gets the element's HTML attributes.
     * 
     * @return An unmodifiable map of attribute names to values
     */
    public Map<String, String> getAttributes() {
        return Collections.unmodifiableMap(attributes);
    }
    
    /**
     * Gets a specific HTML attribute value.
     * 
     * @param name The attribute name
     * @return The attribute value, or null if not found
     */
    public String getAttribute(String name) {
        return name != null ? attributes.get(name.toLowerCase()) : null;
    }
    
    /**
     * Checks if the element has a specific HTML attribute.
     * 
     * @param name The attribute name
     * @return true if the attribute exists, false otherwise
     */
    public boolean hasAttribute(String name) {
        return name != null && attributes.containsKey(name.toLowerCase());
    }
    
    /**
     * Gets the element's text content.
     * 
     * @return The text content
     */
    public String getTextContent() {
        return textContent;
    }
    
    /**
     * Gets the element's inner HTML.
     * 
     * @return The inner HTML
     */
    public String getInnerHtml() {
        return innerHtml;
    }
    
    /**
     * Gets the element's XPath.
     * 
     * @return The XPath
     */
    public String getXpath() {
        return xpath;
    }
    
    /**
     * Gets the element's CSS selector.
     * 
     * @return The CSS selector
     */
    public String getCssSelector() {
        return cssSelector;
    }
    
    /**
     * Gets the element's position on the page.
     * 
     * @return The position object
     */
    public Position getPosition() {
        return position;
    }
    
    /**
     * Gets the element's CSS styles.
     * 
     * @return An unmodifiable map of style names to values
     */
    public Map<String, String> getStyles() {
        return Collections.unmodifiableMap(styles);
    }
    
    /**
     * Gets a specific CSS style value.
     * 
     * @param name The style name
     * @return The style value, or null if not found
     */
    public String getStyle(String name) {
        return name != null ? styles.get(name.toLowerCase()) : null;
    }
    
    /**
     * Checks if the element has a specific CSS style.
     * 
     * @param name The style name
     * @return true if the style exists, false otherwise
     */
    public boolean hasStyle(String name) {
        return name != null && styles.containsKey(name.toLowerCase());
    }
    
    /**
     * Gets the element's CSS classes.
     * 
     * @return An unmodifiable list of class names
     */
    public List<String> getClasses() {
        return Collections.unmodifiableList(classes);
    }
    
    /**
     * Checks if the element has a specific CSS class.
     * 
     * @param className The class name
     * @return true if the class exists, false otherwise
     */
    public boolean hasClass(String className) {
        return className != null && classes.contains(className);
    }
    
    /**
     * Gets the element's size.
     * 
     * @return The size object
     */
    public Size getSize() {
        return size;
    }
    
    /**
     * Gets the element's accessibility scores.
     * 
     * @return An unmodifiable map of accessibility categories to scores
     */
    public Map<String, Double> getAccessibilityScore() {
        return Collections.unmodifiableMap(accessibilityScore);
    }
    
    /**
     * Gets a specific accessibility score.
     * 
     * @param category The accessibility category
     * @return The score, or null if not found
     */
    public Double getAccessibilityScore(String category) {
        return category != null ? accessibilityScore.get(category) : null;
    }
    
    /**
     * Gets the element's relationships with other elements.
     * 
     * @return An unmodifiable list of relationship objects
     */
    public List<Relationship> getRelationships() {
        return Collections.unmodifiableList(relationships);
    }
    
    /**
     * Gets the relationships of a specific type.
     * 
     * @param type The relationship type
     * @return A list of relationships of the specified type
     */
    public List<Relationship> getRelationshipsByType(Relationship.Type type) {
        if (type == null) {
            return Collections.emptyList();
        }
        
        List<Relationship> result = new ArrayList<>();
        for (Relationship relationship : relationships) {
            if (type.equals(relationship.getType())) {
                result.add(relationship);
            }
        }
        return result;
    }
    
    /**
     * Gets the element's custom properties.
     * 
     * @return An unmodifiable map of property names to values
     */
    public Map<String, Object> getCustomProperties() {
        return Collections.unmodifiableMap(customProperties);
    }
    
    /**
     * Gets a specific custom property value.
     * 
     * @param name The property name
     * @return The property value, or null if not found
     */
    public Object getCustomProperty(String name) {
        return name != null ? customProperties.get(name) : null;
    }
    
    /**
     * Checks if the element has a specific custom property.
     * 
     * @param name The property name
     * @return true if the property exists, false otherwise
     */
    public boolean hasCustomProperty(String name) {
        return name != null && customProperties.containsKey(name);
    }
    
    /**
     * Creates a new builder based on this fingerprint.
     * 
     * @return A builder initialized with this fingerprint's values
     */
    public Builder toBuilder() {
        Builder builder = new Builder()
                .withElementId(elementId)
                .withTagName(tagName)
                .withAttributes(attributes)
                .withTextContent(textContent)
                .withInnerHtml(innerHtml)
                .withXpath(xpath)
                .withCssSelector(cssSelector)
                .withPosition(position)
                .withStyles(styles)
                .withClasses(classes)
                .withSize(size)
                .withAccessibilityScores(accessibilityScore)
                .withRelationships(relationships)
                .withCustomProperties(customProperties);
        
        return builder;
    }
    
    /**
     * Represents an element's position on the page.
     */
    public static class Position implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        private final int x;
        private final int y;
        private final int zIndex;
        
        /**
         * Creates a new position with the specified coordinates and z-index.
         * 
         * @param x The x-coordinate
         * @param y The y-coordinate
         * @param zIndex The z-index
         */
        public Position(int x, int y, int zIndex) {
            this.x = x;
            this.y = y;
            this.zIndex = zIndex;
        }
        
        /**
         * Gets the x-coordinate.
         * 
         * @return The x-coordinate
         */
        public int getX() {
            return x;
        }
        
        /**
         * Gets the y-coordinate.
         * 
         * @return The y-coordinate
         */
        public int getY() {
            return y;
        }
        
        /**
         * Gets the z-index.
         * 
         * @return The z-index
         */
        public int getZIndex() {
            return zIndex;
        }
        
        /**
         * Calculates the Euclidean distance to another position.
         * 
         * @param other The other position
         * @return The distance
         */
        public double distanceTo(Position other) {
            if (other == null) {
                return Double.MAX_VALUE;
            }
            
            return Math.sqrt(Math.pow(x - other.getX(), 2) + Math.pow(y - other.getY(), 2));
        }
        
        /**
         * Checks if this position is within a specified distance from another position.
         * 
         * @param other The other position
         * @param maxDistance The maximum distance
         * @return true if the positions are within the specified distance, false otherwise
         */
        public boolean isWithinDistance(Position other, double maxDistance) {
            return distanceTo(other) <= maxDistance;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null || getClass() != obj.getClass()) {
                return false;
            }
            Position other = (Position) obj;
            return x == other.x && y == other.y && zIndex == other.zIndex;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y, zIndex);
        }

        @Override
        public String toString() {
            return "Position{" +
                    "x=" + x +
                    ", y=" + y +
                    ", zIndex=" + zIndex +
                    '}';
        }
    }
    
    /**
     * Represents an element's size (width and height).
     */
    public static class Size implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        private final int width;
        private final int height;
        
        /**
         * Creates a new size with the specified width and height.
         * 
         * @param width The width
         * @param height The height
         */
        public Size(int width, int height) {
            this.width = width;
            this.height = height;
        }
        
        /**
         * Gets the width.
         * 
         * @return The width
         */
        public int getWidth() {
            return width;
        }
        
        /**
         * Gets the height.
         * 
         * @return The height
         */
        public int getHeight() {
            return height;
        }
        
        /**
         * Gets the area (width × height).
         * 
         * @return The area
         */
        public int getArea() {
            return width * height;
        }
        
        /**
         * Checks if this size is similar to another size within a specified tolerance.
         * 
         * @param other The other size
         * @param tolerancePercent The tolerance percentage (0-100)
         * @return true if the sizes are similar, false otherwise
         */
        public boolean isSimilarTo(Size other, double tolerancePercent) {
            if (other == null) {
                return false;
            }
            
            double tolerance = tolerancePercent / 100.0;
            double widthRatio = Math.min(width, other.width) / (double) Math.max(width, other.width);
            double heightRatio = Math.min(height, other.height) / (double) Math.max(height, other.height);
            
            return (width == 0 && other.width == 0) || widthRatio >= (1 - tolerance) &&
                   (height == 0 && other.height == 0) || heightRatio >= (1 - tolerance);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null || getClass() != obj.getClass()) {
                return false;
            }
            Size other = (Size) obj;
            return width == other.width && height == other.height;
        }

        @Override
        public int hashCode() {
            return Objects.hash(width, height);
        }

        @Override
        public String toString() {
            return "Size{" +
                    "width=" + width +
                    ", height=" + height +
                    '}';
        }
    }
    
    /**
     * Represents a relationship between the element and another element.
     */
    public static class Relationship implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        /**
         * Types of relationships between elements.
         */
        public enum Type {
            /**
             * The element is a parent of the related element.
             */
            PARENT,
            
            /**
             * The element is a child of the related element.
             */
            CHILD,
            
            /**
             * The element is a sibling of the related element.
             */
            SIBLING,
            
            /**
             * The element is an ancestor of the related element.
             */
            ANCESTOR,
            
            /**
             * The element is a descendant of the related element.
             */
            DESCENDANT,
            
            /**
             * The element precedes the related element in document order.
             */
            PRECEDING,
            
            /**
             * The element follows the related element in document order.
             */
            FOLLOWING,
            
            /**
             * The element is adjacent to the related element.
             */
            ADJACENT
        }
        
        private final Type type;
        private final String relatedElementIdentifier;
        private final Map<String, Object> properties;
        
        /**
         * Creates a new relationship with the specified type and related element identifier.
         * 
         * @param type The relationship type
         * @param relatedElementIdentifier The identifier of the related element
         */
        public Relationship(Type type, String relatedElementIdentifier) {
            this.type = type;
            this.relatedElementIdentifier = relatedElementIdentifier;
            this.properties = new HashMap<>();
        }
        
        /**
         * Creates a new relationship with the specified type, related element identifier, and properties.
         * 
         * @param type The relationship type
         * @param relatedElementIdentifier The identifier of the related element
         * @param properties Additional properties of the relationship
         */
        public Relationship(Type type, String relatedElementIdentifier, Map<String, Object> properties) {
            this.type = type;
            this.relatedElementIdentifier = relatedElementIdentifier;
            this.properties = properties != null ? new HashMap<>(properties) : new HashMap<>();
        }
        
        /**
         * Gets the relationship type.
         * 
         * @return The relationship type
         */
        public Type getType() {
            return type;
        }
        
        /**
         * Gets the identifier of the related element.
         * 
         * @return The related element identifier
         */
        public String getRelatedElementIdentifier() {
            return relatedElementIdentifier;
        }
        
        /**
         * Gets the additional properties of the relationship.
         * 
         * @return An unmodifiable map of property names to values
         */
        public Map<String, Object> getProperties() {
            return Collections.unmodifiableMap(properties);
        }
        
        /**
         * Gets a specific property value.
         * 
         * @param name The property name
         * @return The property value, or null if not found
         */
        public Object getProperty(String name) {
            return name != null ? properties.get(name) : null;
        }
        
        /**
         * Checks if the relationship has a specific property.
         * 
         * @param name The property name
         * @return true if the property exists, false otherwise
         */
        public boolean hasProperty(String name) {
            return name != null && properties.containsKey(name);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null || getClass() != obj.getClass()) {
                return false;
            }
            Relationship other = (Relationship) obj;
            return type == other.type && 
                   Objects.equals(relatedElementIdentifier, other.relatedElementIdentifier);
        }

        @Override
        public int hashCode() {
            return Objects.hash(type, relatedElementIdentifier);
        }

        @Override
        public String toString() {
            return "Relationship{" +
                    "type=" + type +
                    ", relatedElementIdentifier='" + relatedElementIdentifier + '\'' +
                    ", properties=" + properties +
                    '}';
        }
    }
    
    /**
     * Calculates the similarity score between this fingerprint and another fingerprint.
     * The score is a value between 0.0 (completely different) and 1.0 (identical).
     * 
     * @param other The other fingerprint
     * @return The similarity score
     */
    public double calculateSimilarityScore(ElementFingerprint other) {
        if (other == null) {
            return 0.0;
        }
        
        if (this.equals(other)) {
            return 1.0;
        }
        
        double score = 0.0;
        int factors = 0;
        
        // Compare tag name (high importance)
        if (Objects.equals(this.tagName, other.tagName)) {
            score += 0.15;
        }
        factors++;
        
        // Compare ID attribute (highest importance)
        if (!this.elementId.isEmpty() && !other.elementId.isEmpty()) {
            if (Objects.equals(this.elementId, other.elementId)) {
                score += 0.2;
            }
            factors++;
        }
        
        // Compare text content with normalization (high importance)
        if (!this.textContent.isEmpty() && !other.textContent.isEmpty()) {
            String normalizedThis = normalizeText(this.textContent);
            String normalizedOther = normalizeText(other.textContent);
            
            if (normalizedThis.equals(normalizedOther)) {
                score += 0.15;
            } else {
                // Partial match for text content
                double textSimilarity = calculateTextSimilarity(normalizedThis, normalizedOther);
                score += 0.15 * textSimilarity;
            }
            factors++;
        }
        
        // Compare attributes (medium importance)
        if (!this.attributes.isEmpty() && !other.attributes.isEmpty()) {
            double attrScore = calculateAttributesSimilarity(this.attributes, other.attributes);
            score += 0.1 * attrScore;
            factors++;
        }
        
        // Compare classes (medium importance)
        if (!this.classes.isEmpty() && !other.classes.isEmpty()) {
            double classScore = calculateClassesSimilarity(this.classes, other.classes);
            score += 0.1 * classScore;
            factors++;
        }
        
        // Compare position (low importance, as it can change with responsive design)
        if (this.position != null && other.position != null) {
            double positionScore = calculatePositionSimilarity(this.position, other.position);
            score += 0.05 * positionScore;
            factors++;
        }
        
        // Compare size (low importance, as it can change with responsive design)
        if (this.size != null && other.size != null) {
            double sizeScore = calculateSizeSimilarity(this.size, other.size);
            score += 0.05 * sizeScore;
            factors++;
        }
        
        // Compare relationships (medium-high importance)
        if (!this.relationships.isEmpty() && !other.relationships.isEmpty()) {
            double relationshipsScore = calculateRelationshipsSimilarity(this.relationships, other.relationships);
            score += 0.1 * relationshipsScore;
            factors++;
        }
        
        // Compare custom properties if present (variable importance)
        if (!this.customProperties.isEmpty() && !other.customProperties.isEmpty()) {
            double propertiesScore = calculateCustomPropertiesSimilarity(this.customProperties, other.customProperties);
            score += 0.05 * propertiesScore;
            factors++;
        }
        
        // Normalize the score based on the number of factors considered
        return factors > 0 ? score / factors * factors : 0.0;
    }
    
    /**
     * Normalizes text for comparison by removing extra whitespace and converting to lowercase.
     * 
     * @param text The text to normalize
     * @return The normalized text
     */
    private String normalizeText(String text) {
        if (text == null) {
            return "";
        }
        
        return text.trim().replaceAll("\\s+", " ").toLowerCase();
    }
    
    /**
     * Calculates the similarity between two texts using the Levenshtein distance algorithm.
     * 
     * @param text1 The first text
     * @param text2 The second text
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateTextSimilarity(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0.0;
        }
        
        if (text1.equals(text2)) {
            return 1.0;
        }
        
        int maxLength = Math.max(text1.length(), text2.length());
        if (maxLength == 0) {
            return 1.0;
        }
        
        int levenshteinDistance = computeLevenshteinDistance(text1, text2);
        return 1.0 - (double) levenshteinDistance / maxLength;
    }
    
    /**
     * Computes the Levenshtein distance between two strings.
     * 
     * @param s1 The first string
     * @param s2 The second string
     * @return The Levenshtein distance
     */
    private int computeLevenshteinDistance(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        
        for (int i = 0; i <= s1.length(); i++) {
            dp[i][0] = i;
        }
        
        for (int j = 0; j <= s2.length(); j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                int cost = (s1.charAt(i - 1) == s2.charAt(j - 1)) ? 0 : 1;
                dp[i][j] = Math.min(
                        Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),
                        dp[i - 1][j - 1] + cost
                );
            }
        }
        
        return dp[s1.length()][s2.length()];
    }
    
    /**
     * Calculates the similarity between two sets of attributes.
     * 
     * @param attrs1 The first set of attributes
     * @param attrs2 The second set of attributes
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateAttributesSimilarity(Map<String, String> attrs1, Map<String, String> attrs2) {
        if (attrs1 == null || attrs2 == null) {
            return 0.0;
        }
        
        if (attrs1.isEmpty() && attrs2.isEmpty()) {
            return 1.0;
        }
        
        int totalAttributes = Math.max(attrs1.size(), attrs2.size());
        int matchingAttributes = 0;
        double valuesSimilarity = 0.0;
        
        // Check attributes that exist in both maps
        for (Map.Entry<String, String> entry : attrs1.entrySet()) {
            String key = entry.getKey();
            if (attrs2.containsKey(key)) {
                matchingAttributes++;
                
                String value1 = entry.getValue();
                String value2 = attrs2.get(key);
                
                if (Objects.equals(value1, value2)) {
                    valuesSimilarity += 1.0;
                } else {
                    // For partial matches in attribute values
                    valuesSimilarity += calculateTextSimilarity(value1, value2);
                }
            }
        }
        
        // Calculate the attribute keys match ratio
        double keysMatchRatio = (double) matchingAttributes / totalAttributes;
        
        // Calculate the attribute values match ratio
        double valuesMatchRatio = matchingAttributes > 0 ? valuesSimilarity / matchingAttributes : 0.0;
        
        // Combine key and value similarity scores with weights
        return keysMatchRatio * 0.6 + valuesMatchRatio * 0.4;
    }
    
    /**
     * Calculates the similarity between two sets of CSS classes.
     * 
     * @param classes1 The first set of classes
     * @param classes2 The second set of classes
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateClassesSimilarity(List<String> classes1, List<String> classes2) {
        if (classes1 == null || classes2 == null) {
            return 0.0;
        }
        
        if (classes1.isEmpty() && classes2.isEmpty()) {
            return 1.0;
        }
        
        int totalClasses = Math.max(classes1.size(), classes2.size());
        int matchingClasses = 0;
        
        for (String cls : classes1) {
            if (classes2.contains(cls)) {
                matchingClasses++;
            }
        }
        
        return (double) matchingClasses / totalClasses;
    }
    
    /**
     * Calculates the similarity between two positions.
     * 
     * @param pos1 The first position
     * @param pos2 The second position
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculatePositionSimilarity(Position pos1, Position pos2) {
        if (pos1 == null || pos2 == null) {
            return 0.0;
        }
        
        // For responsive designs, exact position match is not required
        // Instead, we calculate a proximity score based on distance
        double maxDistance = 100.0; // Maximum distance in pixels to consider
        double distance = pos1.distanceTo(pos2);
        
        double proximityScore = Math.max(0.0, 1.0 - distance / maxDistance);
        
        // Z-index similarity
        double zIndexSimilarity = pos1.getZIndex() == pos2.getZIndex() ? 1.0 : 0.5;
        
        // Combine scores with weights
        return proximityScore * 0.7 + zIndexSimilarity * 0.3;
    }
    
    /**
     * Calculates the similarity between two sizes.
     * 
     * @param size1 The first size
     * @param size2 The second size
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateSizeSimilarity(Size size1, Size size2) {
        if (size1 == null || size2 == null) {
            return 0.0;
        }
        
        // For responsive designs, exact size match is not required
        // Instead, we use the isSimilarTo method with a tolerance
        if (size1.isSimilarTo(size2, 20.0)) {
            return 1.0;
        }
        
        // If not similar, calculate a partial similarity score
        double widthSimilarity = calculateDimensionSimilarity(size1.getWidth(), size2.getWidth());
        double heightSimilarity = calculateDimensionSimilarity(size1.getHeight(), size2.getHeight());
        
        return (widthSimilarity + heightSimilarity) / 2.0;
    }
    
    /**
     * Calculates the similarity between two dimension values.
     * 
     * @param dim1 The first dimension value
     * @param dim2 The second dimension value
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateDimensionSimilarity(int dim1, int dim2) {
        if (dim1 == 0 && dim2 == 0) {
            return 1.0;
        }
        
        int maxDim = Math.max(dim1, dim2);
        int minDim = Math.min(dim1, dim2);
        
        if (maxDim == 0) {
            return 0.0;
        }
        
        return (double) minDim / maxDim;
    }
    
    /**
     * Calculates the similarity between two sets of relationships.
     * 
     * @param rels1 The first set of relationships
     * @param rels2 The second set of relationships
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateRelationshipsSimilarity(List<Relationship> rels1, List<Relationship> rels2) {
        if (rels1 == null || rels2 == null) {
            return 0.0;
        }
        
        if (rels1.isEmpty() && rels2.isEmpty()) {
            return 1.0;
        }
        
        Map<Relationship.Type, List<Relationship>> relsByType1 = groupRelationshipsByType(rels1);
        Map<Relationship.Type, List<Relationship>> relsByType2 = groupRelationshipsByType(rels2);
        
        Set<Relationship.Type> allTypes = new HashSet<>();
        allTypes.addAll(relsByType1.keySet());
        allTypes.addAll(relsByType2.keySet());
        
        double totalScore = 0.0;
        
        for (Relationship.Type type : allTypes) {
            List<Relationship> typeRels1 = relsByType1.getOrDefault(type, Collections.emptyList());
            List<Relationship> typeRels2 = relsByType2.getOrDefault(type, Collections.emptyList());
            
            double typeScore = calculateRelationshipTypeSimilarity(typeRels1, typeRels2);
            
            // Different relationship types have different weights
            double typeWeight = getRelationshipTypeWeight(type);
            totalScore += typeScore * typeWeight;
        }
        
        // Normalize the score based on the total weight of all types
        double totalWeight = allTypes.stream().mapToDouble(this::getRelationshipTypeWeight).sum();
        
        return totalWeight > 0 ? totalScore / totalWeight : 0.0;
    }
    
    /**
     * Groups relationships by their type.
     * 
     * @param relationships The list of relationships
     * @return A map of relationship types to lists of relationships
     */
    private Map<Relationship.Type, List<Relationship>> groupRelationshipsByType(List<Relationship> relationships) {
        Map<Relationship.Type, List<Relationship>> result = new HashMap<>();
        
        for (Relationship rel : relationships) {
            result.computeIfAbsent(rel.getType(), k -> new ArrayList<>()).add(rel);
        }
        
        return result;
    }
    
    /**
     * Calculates the similarity between two sets of relationships of the same type.
     * 
     * @param rels1 The first set of relationships
     * @param rels2 The second set of relationships
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateRelationshipTypeSimilarity(List<Relationship> rels1, List<Relationship> rels2) {
        if (rels1.isEmpty() && rels2.isEmpty()) {
            return 1.0;
        }
        
        int totalRels = Math.max(rels1.size(), rels2.size());
        int matchingRels = 0;
        
        for (Relationship rel1 : rels1) {
            for (Relationship rel2 : rels2) {
                if (rel1.getRelatedElementIdentifier().equals(rel2.getRelatedElementIdentifier())) {
                    matchingRels++;
                    break;
                }
            }
        }
        
        return (double) matchingRels / totalRels;
    }
    
    /**
     * Gets the weight for a specific relationship type.
     * 
     * @param type The relationship type
     * @return The weight value
     */
    private double getRelationshipTypeWeight(Relationship.Type type) {
        switch (type) {
            case PARENT:
                return 1.0;
            case CHILD:
                return 0.9;
            case SIBLING:
                return 0.8;
            case ANCESTOR:
                return 0.7;
            case DESCENDANT:
                return 0.6;
            case ADJACENT:
                return 0.5;
            case PRECEDING:
            case FOLLOWING:
                return 0.4;
            default:
                return 0.5;
        }
    }
    
    /**
     * Calculates the similarity between two sets of custom properties.
     * 
     * @param props1 The first set of properties
     * @param props2 The second set of properties
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateCustomPropertiesSimilarity(Map<String, Object> props1, Map<String, Object> props2) {
        if (props1 == null || props2 == null) {
            return 0.0;
        }
        
        if (props1.isEmpty() && props2.isEmpty()) {
            return 1.0;
        }
        
        int totalProps = Math.max(props1.size(), props2.size());
        int matchingProps = 0;
        
        for (Map.Entry<String, Object> entry : props1.entrySet()) {
            String key = entry.getKey();
            if (props2.containsKey(key) && Objects.equals(entry.getValue(), props2.get(key))) {
                matchingProps++;
            }
        }
        
        return (double) matchingProps / totalProps;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        ElementFingerprint other = (ElementFingerprint) obj;
        return Objects.equals(elementId, other.elementId) &&
               Objects.equals(tagName, other.tagName) &&
               Objects.equals(xpath, other.xpath) &&
               Objects.equals(cssSelector, other.cssSelector);
    }

    @Override
    public int hashCode() {
        return Objects.hash(elementId, tagName, xpath, cssSelector);
    }

    @Override
    public String toString() {
        return "ElementFingerprint{" +
                "tagName='" + tagName + '\'' +
                ", id='" + elementId + '\'' +
                ", classes=" + classes +
                ", textLength=" + (textContent != null ? textContent.length() : 0) +
                ", position=" + position +
                ", size=" + size +
                '}';
    }
}



SimilarityScorer.java
------------------------------

package com.cstestforge.framework.core.selfhealing;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

/**
 * A sophisticated component for calculating similarity scores between elements.
 * Used by the self-healing locator system to find the most likely candidate
 * when an original locator fails to find an element.
 */
public class SimilarityScorer {

    // The minimum score that is considered a potential match
    private static final double DEFAULT_MINIMUM_MATCH_SCORE = 0.6;
    
    // Weights for different scoring strategies
    private final Map<ScoringStrategy, Double> strategyWeights;
    
    // The minimum score required for a potential match
    private final double minimumMatchScore;
    
    /**
     * Available scoring strategies for comparing elements
     */
    public enum ScoringStrategy {
        /**
         * Compare elements based on their attributes
         */
        ATTRIBUTES,
        
        /**
         * Compare elements based on their text content
         */
        TEXT_CONTENT,
        
        /**
         * Compare elements based on their position on the page
         */
        POSITION,
        
        /**
         * Compare elements based on their structure in the DOM
         */
        STRUCTURE,
        
        /**
         * Compare elements based on their visual characteristics
         */
        VISUAL,
        
        /**
         * Compare elements based on their accessibility features
         */
        ACCESSIBILITY
    }
    
    /**
     * Creates a similarity scorer with default strategy weights and minimum match score.
     */
    public SimilarityScorer() {
        this.strategyWeights = initializeDefaultWeights();
        this.minimumMatchScore = DEFAULT_MINIMUM_MATCH_SCORE;
    }
    
    /**
     * Creates a similarity scorer with custom strategy weights.
     * 
     * @param strategyWeights Map of strategies to their weights
     */
    public SimilarityScorer(Map<ScoringStrategy, Double> strategyWeights) {
        this(strategyWeights, DEFAULT_MINIMUM_MATCH_SCORE);
    }
    
    /**
     * Creates a similarity scorer with custom strategy weights and minimum match score.
     * 
     * @param strategyWeights Map of strategies to their weights
     * @param minimumMatchScore The minimum score for a potential match
     */
    public SimilarityScorer(Map<ScoringStrategy, Double> strategyWeights, double minimumMatchScore) {
        this.strategyWeights = new HashMap<>(strategyWeights);
        this.minimumMatchScore = minimumMatchScore;
    }
    
    /**
     * Initializes the default weights for the scoring strategies.
     * 
     * @return Map of strategies to their default weights
     */
    private Map<ScoringStrategy, Double> initializeDefaultWeights() {
        Map<ScoringStrategy, Double> weights = new HashMap<>();
        weights.put(ScoringStrategy.ATTRIBUTES, 0.35);
        weights.put(ScoringStrategy.TEXT_CONTENT, 0.25);
        weights.put(ScoringStrategy.POSITION, 0.15);
        weights.put(ScoringStrategy.STRUCTURE, 0.15);
        weights.put(ScoringStrategy.VISUAL, 0.05);
        weights.put(ScoringStrategy.ACCESSIBILITY, 0.05);
        return weights;
    }
    
    /**
     * Gets the weight for a specific scoring strategy.
     * 
     * @param strategy The scoring strategy
     * @return The weight value
     */
    public double getStrategyWeight(ScoringStrategy strategy) {
        return strategyWeights.getOrDefault(strategy, 0.0);
    }
    
    /**
     * Sets the weight for a specific scoring strategy.
     * 
     * @param strategy The scoring strategy
     * @param weight The weight value
     */
    public void setStrategyWeight(ScoringStrategy strategy, double weight) {
        if (strategy != null && weight >= 0.0) {
            strategyWeights.put(strategy, weight);
            normalizeWeights();
        }
    }
    
    /**
     * Normalizes the strategy weights so that they sum to 1.0.
     */
    private void normalizeWeights() {
        double sum = strategyWeights.values().stream().mapToDouble(Double::doubleValue).sum();
        if (sum > 0) {
            for (ScoringStrategy strategy : strategyWeights.keySet()) {
                strategyWeights.put(strategy, strategyWeights.get(strategy) / sum);
            }
        }
    }
    
    /**
     * Gets the minimum score required for a potential match.
     * 
     * @return The minimum match score
     */
    public double getMinimumMatchScore() {
        return minimumMatchScore;
    }
    
    /**
     * Finds the best matching element fingerprint from a collection of candidates,
     * based on similarity to the target fingerprint.
     * 
     * @param target The target element fingerprint
     * @param candidates The collection of candidate element fingerprints
     * @return The best matching candidate, or null if none meet the minimum match score
     */
    public ElementFingerprint findBestMatch(ElementFingerprint target, Collection<ElementFingerprint> candidates) {
        if (target == null || candidates == null || candidates.isEmpty()) {
            return null;
        }
        
        ScoredCandidate bestCandidate = findBestMatchWithScore(target, candidates);
        
        return bestCandidate != null ? bestCandidate.getCandidate() : null;
    }
    
    /**
     * Finds the best matching element fingerprint with its similarity score.
     * 
     * @param target The target element fingerprint
     * @param candidates The collection of candidate element fingerprints
     * @return The best matching candidate with its score, or null if none meet the minimum match score
     */
    public ScoredCandidate findBestMatchWithScore(ElementFingerprint target, Collection<ElementFingerprint> candidates) {
        if (target == null || candidates == null || candidates.isEmpty()) {
            return null;
        }
        
        List<ScoredCandidate> scoredCandidates = candidates.stream()
                .map(candidate -> new ScoredCandidate(candidate, calculateSimilarityScore(target, candidate)))
                .filter(scored -> scored.getScore() >= minimumMatchScore)
                .sorted(Comparator.comparing(ScoredCandidate::getScore).reversed())
                .collect(Collectors.toList());
        
        return scoredCandidates.isEmpty() ? null : scoredCandidates.get(0);
    }
    
    /**
     * Finds all matching element fingerprints that meet the minimum match score,
     * sorted by descending similarity.
     * 
     * @param target The target element fingerprint
     * @param candidates The collection of candidate element fingerprints
     * @return List of matching candidates with their scores, sorted by descending similarity
     */
    public List<ScoredCandidate> findAllMatches(ElementFingerprint target, Collection<ElementFingerprint> candidates) {
        if (target == null || candidates == null || candidates.isEmpty()) {
            return Collections.emptyList();
        }
        
        return candidates.stream()
                .map(candidate -> new ScoredCandidate(candidate, calculateSimilarityScore(target, candidate)))
                .filter(scored -> scored.getScore() >= minimumMatchScore)
                .sorted(Comparator.comparing(ScoredCandidate::getScore).reversed())
                .collect(Collectors.toList());
    }
    
    /**
     * Calculates the overall similarity score between a target and candidate element fingerprint.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return The similarity score (0.0 to 1.0)
     */
    public double calculateSimilarityScore(ElementFingerprint target, ElementFingerprint candidate) {
        if (target == null || candidate == null) {
            return 0.0;
        }
        
        if (target.equals(candidate)) {
            return 1.0;
        }
        
        double score = 0.0;
        
        // Apply each scoring strategy with its weight
        score += getStrategyWeight(ScoringStrategy.ATTRIBUTES) * calculateAttributesSimilarity(target, candidate);
        score += getStrategyWeight(ScoringStrategy.TEXT_CONTENT) * calculateTextContentSimilarity(target, candidate);
        score += getStrategyWeight(ScoringStrategy.POSITION) * calculatePositionSimilarity(target, candidate);
        score += getStrategyWeight(ScoringStrategy.STRUCTURE) * calculateStructureSimilarity(target, candidate);
        score += getStrategyWeight(ScoringStrategy.VISUAL) * calculateVisualSimilarity(target, candidate);
        score += getStrategyWeight(ScoringStrategy.ACCESSIBILITY) * calculateAccessibilitySimilarity(target, candidate);
        
        return score;
    }
    
    /**
     * Calculates the attribute similarity between two element fingerprints.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return The attribute similarity score (0.0 to 1.0)
     */
    public double calculateAttributesSimilarity(ElementFingerprint target, ElementFingerprint candidate) {
        // Start with tag name comparison (high importance)
        double score = 0.0;
        
        // Tag name is critical - if it doesn't match, severely reduce score
        if (!Objects.equals(target.getTagName(), candidate.getTagName())) {
            return 0.2; // Allow some match for different tags, but with low score
        }
        
        score += 0.3; // Tag name matches
        
        // ID comparison (highest importance)
        if (!target.getElementId().isEmpty() && !candidate.getElementId().isEmpty()) {
            if (Objects.equals(target.getElementId(), candidate.getElementId())) {
                score += 0.4;
            } else {
                // If IDs exist but don't match, this is a significant red flag
                score -= 0.3;
            }
        }
        
        // Compare other attributes
        Map<String, String> targetAttrs = target.getAttributes();
        Map<String, String> candidateAttrs = candidate.getAttributes();
        
        // Skip ID attribute as it was already compared
        targetAttrs = new HashMap<>(targetAttrs);
        targetAttrs.remove("id");
        candidateAttrs = new HashMap<>(candidateAttrs);
        candidateAttrs.remove("id");
        
        if (!targetAttrs.isEmpty() && !candidateAttrs.isEmpty()) {
            // Calculate attribute matching score using Jaccard similarity
            Set<String> allKeys = new HashSet<>(targetAttrs.keySet());
            allKeys.addAll(candidateAttrs.keySet());
            
            int matchingCount = 0;
            double valueMatchScore = 0.0;
            
            for (String key : allKeys) {
                if (targetAttrs.containsKey(key) && candidateAttrs.containsKey(key)) {
                    matchingCount++;
                    
                    String targetValue = targetAttrs.get(key);
                    String candidateValue = candidateAttrs.get(key);
                    
                    if (Objects.equals(targetValue, candidateValue)) {
                        valueMatchScore += 1.0;
                    } else {
                        // For values that don't match exactly, calculate string similarity
                        valueMatchScore += calculateStringSimilarity(targetValue, candidateValue);
                    }
                }
            }
            
            double keySetSimilarity = (double) matchingCount / allKeys.size();
            double valueSimilarity = matchingCount > 0 ? valueMatchScore / matchingCount : 0.0;
            
            // Combine key matching and value matching with weights
            score += 0.2 * (keySetSimilarity * 0.6 + valueSimilarity * 0.4);
        }
        
        // Compare CSS classes with special weight
        List<String> targetClasses = target.getClasses();
        List<String> candidateClasses = candidate.getClasses();
        
        if (!targetClasses.isEmpty() && !candidateClasses.isEmpty()) {
            // Use Jaccard similarity for class sets
            Set<String> allClasses = new HashSet<>(targetClasses);
            allClasses.addAll(candidateClasses);
            
            Set<String> intersection = new HashSet<>(targetClasses);
            intersection.retainAll(candidateClasses);
            
            double classSimilarity = (double) intersection.size() / allClasses.size();
            
            score += 0.1 * classSimilarity;
        }
        
        // Ensure final score is within bounds
        return Math.min(1.0, Math.max(0.0, score));
    }
    
    /**
     * Calculates the text content similarity between two element fingerprints.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return The text content similarity score (0.0 to 1.0)
     */
    public double calculateTextContentSimilarity(ElementFingerprint target, ElementFingerprint candidate) {
        String targetText = target.getTextContent();
        String candidateText = candidate.getTextContent();
        
        // If both are empty, consider it a perfect match
        if ((targetText == null || targetText.isEmpty()) && 
            (candidateText == null || candidateText.isEmpty())) {
            return 1.0;
        }
        
        // If one is empty but the other isn't, penalize
        if ((targetText == null || targetText.isEmpty()) || 
            (candidateText == null || candidateText.isEmpty())) {
            return 0.0;
        }
        
        // Normalize text by trimming whitespace and converting to lowercase
        String normalizedTargetText = normalizeText(targetText);
        String normalizedCandidateText = normalizeText(candidateText);
        
        // If normalized texts are equal, it's a perfect match
        if (normalizedTargetText.equals(normalizedCandidateText)) {
            return 1.0;
        }
        
        // Calculate string similarity using a combination of approaches
        double similarity = calculateStringSimilarity(normalizedTargetText, normalizedCandidateText);
        
        // If texts are long, also consider token-based similarity
        if (normalizedTargetText.length() > 20 || normalizedCandidateText.length() > 20) {
            double tokenSimilarity = calculateTokenBasedSimilarity(normalizedTargetText, normalizedCandidateText);
            
            // Use a weighted combination
            similarity = similarity * 0.6 + tokenSimilarity * 0.4;
        }
        
        return similarity;
    }
    
    /**
     * Normalizes text by trimming whitespace, normalizing whitespace, and converting to lowercase.
     * 
     * @param text The text to normalize
     * @return The normalized text
     */
    private String normalizeText(String text) {
        if (text == null) {
            return "";
        }
        
        // Trim leading/trailing whitespace, normalize internal whitespace, convert to lowercase
        return text.trim().replaceAll("\\s+", " ").toLowerCase();
    }
    
    /**
     * Calculates the similarity between two strings using a combination of
     * Levenshtein distance and longest common subsequence.
     * 
     * @param s1 The first string
     * @param s2 The second string
     * @return The string similarity score (0.0 to 1.0)
     */
    private double calculateStringSimilarity(String s1, String s2) {
        if (s1 == null || s2 == null) {
            return 0.0;
        }
        
        if (s1.equals(s2)) {
            return 1.0;
        }
        
        if (s1.isEmpty() || s2.isEmpty()) {
            return 0.0;
        }
        
        // Calculate Levenshtein distance similarity
        double levenshteinSimilarity = calculateLevenshteinSimilarity(s1, s2);
        
        // Calculate Longest Common Subsequence similarity
        double lcsSimilarity = calculateLCSSimilarity(s1, s2);
        
        // Combine the two metrics with weights
        return levenshteinSimilarity * 0.6 + lcsSimilarity * 0.4;
    }
    
    /**
     * Calculates string similarity based on Levenshtein distance.
     * 
     * @param s1 The first string
     * @param s2 The second string
     * @return The Levenshtein similarity score (0.0 to 1.0)
     */
    private double calculateLevenshteinSimilarity(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        
        for (int i = 0; i <= s1.length(); i++) {
            dp[i][0] = i;
        }
        
        for (int j = 0; j <= s2.length(); j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                int cost = (s1.charAt(i - 1) == s2.charAt(j - 1)) ? 0 : 1;
                dp[i][j] = Math.min(
                        Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),
                        dp[i - 1][j - 1] + cost
                );
            }
        }
        
        int distance = dp[s1.length()][s2.length()];
        int maxLength = Math.max(s1.length(), s2.length());
        
        // Convert distance to similarity score
        return maxLength > 0 ? 1.0 - (double) distance / maxLength : 1.0;
    }
    
    /**
     * Calculates string similarity based on Longest Common Subsequence.
     * 
     * @param s1 The first string
     * @param s2 The second string
     * @return The LCS similarity score (0.0 to 1.0)
     */
    private double calculateLCSSimilarity(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        int lcsLength = dp[s1.length()][s2.length()];
        int maxLength = Math.max(s1.length(), s2.length());
        
        // Convert LCS length to similarity score
        return maxLength > 0 ? (double) lcsLength / maxLength : 1.0;
    }
    
    /**
     * Calculates token-based similarity between two strings using Jaccard similarity of word sets.
     * 
     * @param s1 The first string
     * @param s2 The second string
     * @return The token-based similarity score (0.0 to 1.0)
     */
    private double calculateTokenBasedSimilarity(String s1, String s2) {
        if (s1 == null || s2 == null) {
            return 0.0;
        }
        
        if (s1.equals(s2)) {
            return 1.0;
        }
        
        if (s1.isEmpty() || s2.isEmpty()) {
            return 0.0;
        }
        
        // Split into tokens (words)
        Set<String> tokens1 = new HashSet<>(Arrays.asList(s1.split("\\s+")));
        Set<String> tokens2 = new HashSet<>(Arrays.asList(s2.split("\\s+")));
        
        // Calculate Jaccard similarity
        Set<String> union = new HashSet<>(tokens1);
        union.addAll(tokens2);
        
        Set<String> intersection = new HashSet<>(tokens1);
        intersection.retainAll(tokens2);
        
        return union.isEmpty() ? 1.0 : (double) intersection.size() / union.size();
    }
    
    /**
     * Calculates the position similarity between two element fingerprints.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return The position similarity score (0.0 to 1.0)
     */
    public double calculatePositionSimilarity(ElementFingerprint target, ElementFingerprint candidate) {
        ElementFingerprint.Position targetPos = target.getPosition();
        ElementFingerprint.Position candidatePos = candidate.getPosition();
        
        if (targetPos == null || candidatePos == null) {
            return 0.5; // Neutral score if position data is missing
        }
        
        // For responsive designs, we use a distance-based approach rather than exact matching
        double distance = targetPos.distanceTo(candidatePos);
        
        // Define the maximum distance beyond which elements are considered completely different
        // The value depends on the application and screen size, but 500 pixels is a reasonable default
        double maxDistance = 500.0;
        
        // Convert distance to similarity (inversely proportional)
        double distanceSimilarity = Math.max(0.0, 1.0 - distance / maxDistance);
        
        // Consider z-index as well
        double zIndexSimilarity = targetPos.getZIndex() == candidatePos.getZIndex() ? 1.0 : 0.5;
        
        // Consider size as well
        ElementFingerprint.Size targetSize = target.getSize();
        ElementFingerprint.Size candidateSize = candidate.getSize();
        double sizeSimilarity = 0.5; // Default if size data is missing
        
        if (targetSize != null && candidateSize != null) {
            sizeSimilarity = targetSize.isSimilarTo(candidateSize, 20.0) ? 1.0 : 0.5;
        }
        
        // Combine the factors with appropriate weights
        return distanceSimilarity * 0.6 + zIndexSimilarity * 0.2 + sizeSimilarity * 0.2;
    }
    
    /**
     * Calculates the structure similarity between two element fingerprints.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return The structure similarity score (0.0 to 1.0)
     */
    public double calculateStructureSimilarity(ElementFingerprint target, ElementFingerprint candidate) {
        // Focus on DOM relationships
        List<ElementFingerprint.Relationship> targetRels = target.getRelationships();
        List<ElementFingerprint.Relationship> candidateRels = candidate.getRelationships();
        
        // If both have no relationships, consider it neutral
        if (targetRels.isEmpty() && candidateRels.isEmpty()) {
            return 0.5;
        }
        
        // If one has relationships but the other doesn't, penalize
        if (targetRels.isEmpty() || candidateRels.isEmpty()) {
            return 0.25;
        }
        
        // Group relationships by type
        Map<ElementFingerprint.Relationship.Type, List<ElementFingerprint.Relationship>> targetRelsByType =
                groupRelationshipsByType(targetRels);
        Map<ElementFingerprint.Relationship.Type, List<ElementFingerprint.Relationship>> candidateRelsByType =
                groupRelationshipsByType(candidateRels);
        
        // Get all unique relationship types
        Set<ElementFingerprint.Relationship.Type> allTypes = new HashSet<>(targetRelsByType.keySet());
        allTypes.addAll(candidateRelsByType.keySet());
        
        // If they have different relationship types, that's a red flag
        double typesMatchRatio = 
                (double) intersection(targetRelsByType.keySet(), candidateRelsByType.keySet()).size() / allTypes.size();
        
        // Calculate similarity for each relationship type
        double totalSimilarity = 0.0;
        double totalWeight = 0.0;
        
        for (ElementFingerprint.Relationship.Type type : allTypes) {
            double typeWeight = getRelationshipTypeWeight(type);
            totalWeight += typeWeight;
            
            List<ElementFingerprint.Relationship> targetTypeRels = targetRelsByType.getOrDefault(type, Collections.emptyList());
            List<ElementFingerprint.Relationship> candidateTypeRels = candidateRelsByType.getOrDefault(type, Collections.emptyList());
            
            // Skip if either list is empty
            if (targetTypeRels.isEmpty() || candidateTypeRels.isEmpty()) {
                // Penalize but don't fully discard
                totalSimilarity += 0.25 * typeWeight;
                continue;
            }
            
            // Calculate similarity based on relationship identifiers
            Set<String> targetIds = targetTypeRels.stream()
                    .map(ElementFingerprint.Relationship::getRelatedElementIdentifier)
                    .collect(Collectors.toSet());
            Set<String> candidateIds = candidateTypeRels.stream()
                    .map(ElementFingerprint.Relationship::getRelatedElementIdentifier)
                    .collect(Collectors.toSet());
            
            // Use Jaccard similarity for the sets of element identifiers
            double idSimilarity = calculateJaccardSimilarity(targetIds, candidateIds);
            
            totalSimilarity += idSimilarity * typeWeight;
        }
        
        // Combine relationship type matching and content matching
        double structureSimilarity = totalWeight > 0 ? totalSimilarity / totalWeight : 0.5;
        
        return structureSimilarity * 0.7 + typesMatchRatio * 0.3;
    }
    
    /**
     * Groups relationships by their type.
     * 
     * @param relationships The list of relationships
     * @return A map of relationship types to lists of relationships
     */
    private Map<ElementFingerprint.Relationship.Type, List<ElementFingerprint.Relationship>> 
            groupRelationshipsByType(List<ElementFingerprint.Relationship> relationships) {
        Map<ElementFingerprint.Relationship.Type, List<ElementFingerprint.Relationship>> result = new HashMap<>();
        
        for (ElementFingerprint.Relationship rel : relationships) {
            result.computeIfAbsent(rel.getType(), k -> new ArrayList<>()).add(rel);
        }
        
        return result;
    }
    
    /**
     * Gets the weight for a specific relationship type.
     * 
     * @param type The relationship type
     * @return The weight value
     */
    private double getRelationshipTypeWeight(ElementFingerprint.Relationship.Type type) {
        switch (type) {
            case PARENT:
                return 1.0;
            case CHILD:
                return 0.9;
            case SIBLING:
                return 0.8;
            case ANCESTOR:
                return 0.7;
            case DESCENDANT:
                return 0.6;
            case ADJACENT:
                return 0.5;
            case PRECEDING:
            case FOLLOWING:
                return 0.4;
            default:
                return 0.5;
        }
    }
    
    /**
     * Calculates the visual similarity between two element fingerprints.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return The visual similarity score (0.0 to 1.0)
     */
    public double calculateVisualSimilarity(ElementFingerprint target, ElementFingerprint candidate) {
        // Compare styles
        Map<String, String> targetStyles = target.getStyles();
        Map<String, String> candidateStyles = candidate.getStyles();
        
        // If both have no styles, consider it neutral
        if (targetStyles.isEmpty() && candidateStyles.isEmpty()) {
            return 0.5;
        }
        
        // If one has styles but the other doesn't, penalize
        if (targetStyles.isEmpty() || candidateStyles.isEmpty()) {
            return 0.25;
        }
        
        // Focus on key visual styles
        String[] keyVisualStyles = {
                "color", "background-color", "font-size", "font-weight", "border", 
                "margin", "padding", "display", "visibility", "opacity"
        };
        
        double totalSimilarity = 0.0;
        int matchedStyles = 0;
        
        for (String style : keyVisualStyles) {
            if (targetStyles.containsKey(style) && candidateStyles.containsKey(style)) {
                matchedStyles++;
                String targetValue = targetStyles.get(style);
                String candidateValue = candidateStyles.get(style);
                
                if (Objects.equals(targetValue, candidateValue)) {
                    totalSimilarity += 1.0;
                } else {
                    // For certain styles like colors, we could calculate color distance
                    // For simplicity, we just use string similarity
                    totalSimilarity += calculateStringSimilarity(targetValue, candidateValue);
                }
            }
        }
        
        // Calculate style presence similarity using Jaccard similarity
        Set<String> targetStyleKeys = targetStyles.keySet();
        Set<String> candidateStyleKeys = candidateStyles.keySet();
        double stylePresenceSimilarity = calculateJaccardSimilarity(targetStyleKeys, candidateStyleKeys);
        
        // Combine key style matching and general style presence matching
        return matchedStyles > 0 
                ? (totalSimilarity / matchedStyles) * 0.7 + stylePresenceSimilarity * 0.3
                : stylePresenceSimilarity;
    }
    
    /**
     * Calculates the accessibility similarity between two element fingerprints.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return The accessibility similarity score (0.0 to 1.0)
     */
    public double calculateAccessibilitySimilarity(ElementFingerprint target, ElementFingerprint candidate) {
        // Compare accessibility scores
        Map<String, Double> targetScores = target.getAccessibilityScore();
        Map<String, Double> candidateScores = candidate.getAccessibilityScore();
        
        // If both have no accessibility information, consider it neutral
        if (targetScores.isEmpty() && candidateScores.isEmpty()) {
            return 0.5;
        }
        
        // If one has accessibility information but the other doesn't, penalize
        if (targetScores.isEmpty() || candidateScores.isEmpty()) {
            return 0.25;
        }
        
        // Compare the scores for shared categories
        Set<String> sharedCategories = intersection(targetScores.keySet(), candidateScores.keySet());
        
        if (sharedCategories.isEmpty()) {
            // No shared categories, use set similarity instead
            return calculateJaccardSimilarity(targetScores.keySet(), candidateScores.keySet()) * 0.5;
        }
        
        double totalDifference = 0.0;
        
        for (String category : sharedCategories) {
            double targetValue = targetScores.get(category);
            double candidateValue = candidateScores.get(category);
            
            // Calculate absolute difference, normalized to [0,1]
            totalDifference += Math.abs(targetValue - candidateValue);
        }
        
        // Convert average difference to similarity (1 - difference)
        double scoreSimilarity = 1.0 - (totalDifference / sharedCategories.size());
        
        // Also consider the set of categories
        double categorySimilarity = calculateJaccardSimilarity(targetScores.keySet(), candidateScores.keySet());
        
        // Combine score similarity and category similarity
        return scoreSimilarity * 0.7 + categorySimilarity * 0.3;
    }
    
    /**
     * Calculates the Jaccard similarity between two sets.
     * 
     * @param set1 The first set
     * @param set2 The second set
     * @param <T> The type of elements in the sets
     * @return The Jaccard similarity score (0.0 to 1.0)
     */
    private <T> double calculateJaccardSimilarity(Set<T> set1, Set<T> set2) {
        if (set1 == null || set2 == null) {
            return 0.0;
        }
        
        if (set1.isEmpty() && set2.isEmpty()) {
            return 1.0;
        }
        
        if (set1.isEmpty() || set2.isEmpty()) {
            return 0.0;
        }
        
        Set<T> union = new HashSet<>(set1);
        union.addAll(set2);
        
        Set<T> intersection = intersection(set1, set2);
        
        return (double) intersection.size() / union.size();
    }
    
    /**
     * Computes the intersection of two sets.
     * 
     * @param set1 The first set
     * @param set2 The second set
     * @param <T> The type of elements in the sets
     * @return The intersection set
     */
    private <T> Set<T> intersection(Set<T> set1, Set<T> set2) {
        Set<T> result = new HashSet<>(set1);
        result.retainAll(set2);
        return result;
    }
    
    /**
     * Represents a candidate element fingerprint with its similarity score.
     */
    public static class ScoredCandidate {
        private final ElementFingerprint candidate;
        private final double score;
        private final Map<ScoringStrategy, Double> strategyScores;
        
        /**
         * Creates a new scored candidate with the specified candidate and score.
         * 
         * @param candidate The candidate element fingerprint
         * @param score The similarity score
         */
        public ScoredCandidate(ElementFingerprint candidate, double score) {
            this(candidate, score, new HashMap<>());
        }
        
        /**
         * Creates a new scored candidate with the specified candidate, score, and per-strategy scores.
         * 
         * @param candidate The candidate element fingerprint
         * @param score The similarity score
         * @param strategyScores Map of scoring strategies to their individual scores
         */
        public ScoredCandidate(ElementFingerprint candidate, double score, Map<ScoringStrategy, Double> strategyScores) {
            this.candidate = candidate;
            this.score = score;
            this.strategyScores = new HashMap<>(strategyScores);
        }
        
        /**
         * Gets the candidate element fingerprint.
         * 
         * @return The candidate
         */
        public ElementFingerprint getCandidate() {
            return candidate;
        }
        
        /**
         * Gets the similarity score.
         * 
         * @return The score
         */
        public double getScore() {
            return score;
        }
        
        /**
         * Gets the individual scores for each scoring strategy.
         * 
         * @return An unmodifiable map of scoring strategies to their scores
         */
        public Map<ScoringStrategy, Double> getStrategyScores() {
            return Collections.unmodifiableMap(strategyScores);
        }
        
        /**
         * Gets the score for a specific scoring strategy.
         * 
         * @param strategy The scoring strategy
         * @return The strategy score, or 0.0 if not available
         */
        public double getStrategyScore(ScoringStrategy strategy) {
            return strategyScores.getOrDefault(strategy, 0.0);
        }
        
        @Override
        public String toString() {
            return String.format("ScoredCandidate{score=%.4f, candidate=%s}", score, candidate);
        }
    }
    
    /**
     * Builder class for creating customized SimilarityScorer instances.
     */
    public static class Builder {
        private final Map<ScoringStrategy, Double> strategyWeights = new HashMap<>();
        private double minimumMatchScore = DEFAULT_MINIMUM_MATCH_SCORE;
        private boolean normalized = true;
        
        /**
         * Default constructor for the builder.
         */
        public Builder() {
            // Initialize with default weights
            strategyWeights.put(ScoringStrategy.ATTRIBUTES, 0.35);
            strategyWeights.put(ScoringStrategy.TEXT_CONTENT, 0.25);
            strategyWeights.put(ScoringStrategy.POSITION, 0.15);
            strategyWeights.put(ScoringStrategy.STRUCTURE, 0.15);
            strategyWeights.put(ScoringStrategy.VISUAL, 0.05);
            strategyWeights.put(ScoringStrategy.ACCESSIBILITY, 0.05);
        }
        
        /**
         * Sets the weight for a specific scoring strategy.
         * 
         * @param strategy The scoring strategy
         * @param weight The weight value
         * @return This builder instance
         */
        public Builder withStrategyWeight(ScoringStrategy strategy, double weight) {
            if (strategy != null && weight >= 0.0) {
                strategyWeights.put(strategy, weight);
            }
            return this;
        }
        
        /**
         * Sets whether the strategy weights should be normalized to sum to 1.0.
         * 
         * @param normalized true if weights should be normalized, false otherwise
         * @return This builder instance
         */
        public Builder withNormalization(boolean normalized) {
            this.normalized = normalized;
            return this;
        }
        
        /**
         * Sets the minimum score required for a potential match.
         * 
         * @param minimumMatchScore The minimum match score
         * @return This builder instance
         */
        public Builder withMinimumMatchScore(double minimumMatchScore) {
            if (minimumMatchScore >= 0.0 && minimumMatchScore <= 1.0) {
                this.minimumMatchScore = minimumMatchScore;
            }
            return this;
        }
        
        /**
         * Disables a specific scoring strategy by setting its weight to 0.
         * 
         * @param strategy The scoring strategy to disable
         * @return This builder instance
         */
        public Builder disableStrategy(ScoringStrategy strategy) {
            if (strategy != null) {
                strategyWeights.put(strategy, 0.0);
            }
            return this;
        }
        
        /**
         * Builds a SimilarityScorer from the current builder state.
         * 
         * @return The similarity scorer
         */
        public SimilarityScorer build() {
            Map<ScoringStrategy, Double> finalWeights = new HashMap<>(strategyWeights);
            
            // Normalize weights if requested
            if (normalized) {
                double sum = finalWeights.values().stream().mapToDouble(Double::doubleValue).sum();
                if (sum > 0) {
                    for (ScoringStrategy strategy : finalWeights.keySet()) {
                        finalWeights.put(strategy, finalWeights.get(strategy) / sum);
                    }
                }
            }
            
            return new SimilarityScorer(finalWeights, minimumMatchScore);
        }
    }
    
    /**
     * Creates a builder for constructing a customized SimilarityScorer.
     * 
     * @return A new builder instance
     */
    public static Builder builder() {
        return new Builder();
    }
    
    /**
     * Creates a scorer optimized for attribute-based matching.
     * 
     * @return A similarity scorer optimized for attributes
     */
    public static SimilarityScorer createAttributeOptimizedScorer() {
        return builder()
                .withStrategyWeight(ScoringStrategy.ATTRIBUTES, 0.6)
                .withStrategyWeight(ScoringStrategy.TEXT_CONTENT, 0.2)
                .withStrategyWeight(ScoringStrategy.POSITION, 0.05)
                .withStrategyWeight(ScoringStrategy.STRUCTURE, 0.1)
                .withStrategyWeight(ScoringStrategy.VISUAL, 0.03)
                .withStrategyWeight(ScoringStrategy.ACCESSIBILITY, 0.02)
                .build();
    }
    
    /**
     * Creates a scorer optimized for text-based matching.
     * 
     * @return A similarity scorer optimized for text content
     */
    public static SimilarityScorer createTextOptimizedScorer() {
        return builder()
                .withStrategyWeight(ScoringStrategy.ATTRIBUTES, 0.2)
                .withStrategyWeight(ScoringStrategy.TEXT_CONTENT, 0.6)
                .withStrategyWeight(ScoringStrategy.POSITION, 0.05)
                .withStrategyWeight(ScoringStrategy.STRUCTURE, 0.1)
                .withStrategyWeight(ScoringStrategy.VISUAL, 0.03)
                .withStrategyWeight(ScoringStrategy.ACCESSIBILITY, 0.02)
                .build();
    }
    
    /**
     * Creates a scorer optimized for position-based matching.
     * 
     * @return A similarity scorer optimized for position
     */
    public static SimilarityScorer createPositionOptimizedScorer() {
        return builder()
                .withStrategyWeight(ScoringStrategy.ATTRIBUTES, 0.2)
                .withStrategyWeight(ScoringStrategy.TEXT_CONTENT, 0.1)
                .withStrategyWeight(ScoringStrategy.POSITION, 0.5)
                .withStrategyWeight(ScoringStrategy.STRUCTURE, 0.1)
                .withStrategyWeight(ScoringStrategy.VISUAL, 0.05)
                .withStrategyWeight(ScoringStrategy.ACCESSIBILITY, 0.05)
                .build();
    }
    
    /**
     * Creates a scorer optimized for structure-based matching.
     * 
     * @return A similarity scorer optimized for structure
     */
    public static SimilarityScorer createStructureOptimizedScorer() {
        return builder()
                .withStrategyWeight(ScoringStrategy.ATTRIBUTES, 0.2)
                .withStrategyWeight(ScoringStrategy.TEXT_CONTENT, 0.1)
                .withStrategyWeight(ScoringStrategy.POSITION, 0.1)
                .withStrategyWeight(ScoringStrategy.STRUCTURE, 0.5)
                .withStrategyWeight(ScoringStrategy.VISUAL, 0.05)
                .withStrategyWeight(ScoringStrategy.ACCESSIBILITY, 0.05)
                .build();
    }
    
    /**
     * Creates a balanced scorer with equal weights for all strategies.
     * 
     * @return A balanced similarity scorer
     */
    public static SimilarityScorer createBalancedScorer() {
        return builder()
                .withStrategyWeight(ScoringStrategy.ATTRIBUTES, 1.0)
                .withStrategyWeight(ScoringStrategy.TEXT_CONTENT, 1.0)
                .withStrategyWeight(ScoringStrategy.POSITION, 1.0)
                .withStrategyWeight(ScoringStrategy.STRUCTURE, 1.0)
                .withStrategyWeight(ScoringStrategy.VISUAL, 1.0)
                .withStrategyWeight(ScoringStrategy.ACCESSIBILITY, 1.0)
                .build();
    }
    
    /**
     * Creates an adaptive scorer that adjusts its strategy based on the available element properties.
     * 
     * @param target The target element fingerprint
     * @return A similarity scorer optimized for the available properties of the target
     */
    public static SimilarityScorer createAdaptiveScorer(ElementFingerprint target) {
        if (target == null) {
            return createBalancedScorer();
        }
        
        Builder builder = builder();
        
        // Base weights - will be adjusted based on available data
        double attributesWeight = 0.2;
        double textContentWeight = 0.2;
        double positionWeight = 0.2;
        double structureWeight = 0.2;
        double visualWeight = 0.1;
        double accessibilityWeight = 0.1;
        
        // Adjust based on available data in the target fingerprint
        
        // If target has rich attribute data, increase its weight
        if (!target.getAttributes().isEmpty() || !target.getElementId().isEmpty() || !target.getClasses().isEmpty()) {
            attributesWeight += 0.1;
        }
        
        // If target has text content, increase its weight
        if (target.getTextContent() != null && !target.getTextContent().isEmpty()) {
            textContentWeight += 0.1;
        }
        
        // If target has position data, increase its weight
        if (target.getPosition() != null && (target.getPosition().getX() != 0 || target.getPosition().getY() != 0)) {
            positionWeight += 0.1;
        }
        
        // If target has relationship data, increase structure weight
        if (!target.getRelationships().isEmpty()) {
            structureWeight += 0.1;
        }
        
        // If target has style data, increase visual weight
        if (!target.getStyles().isEmpty()) {
            visualWeight += 0.05;
        }
        
        // If target has accessibility data, increase accessibility weight
        if (!target.getAccessibilityScore().isEmpty()) {
            accessibilityWeight += 0.05;
        }
        
        // Apply the calculated weights
        builder.withStrategyWeight(ScoringStrategy.ATTRIBUTES, attributesWeight);
        builder.withStrategyWeight(ScoringStrategy.TEXT_CONTENT, textContentWeight);
        builder.withStrategyWeight(ScoringStrategy.POSITION, positionWeight);
        builder.withStrategyWeight(ScoringStrategy.STRUCTURE, structureWeight);
        builder.withStrategyWeight(ScoringStrategy.VISUAL, visualWeight);
        builder.withStrategyWeight(ScoringStrategy.ACCESSIBILITY, accessibilityWeight);
        
        return builder.build();
    }
    
    /**
     * Creates a detailed scoring report for a candidate element fingerprint.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return A map of scoring strategies to their individual scores
     */
    public Map<ScoringStrategy, Double> createDetailedScoringReport(ElementFingerprint target, ElementFingerprint candidate) {
        if (target == null || candidate == null) {
            return Collections.emptyMap();
        }
        
        Map<ScoringStrategy, Double> scores = new HashMap<>();
        
        scores.put(ScoringStrategy.ATTRIBUTES, calculateAttributesSimilarity(target, candidate));
        scores.put(ScoringStrategy.TEXT_CONTENT, calculateTextContentSimilarity(target, candidate));
        scores.put(ScoringStrategy.POSITION, calculatePositionSimilarity(target, candidate));
        scores.put(ScoringStrategy.STRUCTURE, calculateStructureSimilarity(target, candidate));
        scores.put(ScoringStrategy.VISUAL, calculateVisualSimilarity(target, candidate));
        scores.put(ScoringStrategy.ACCESSIBILITY, calculateAccessibilitySimilarity(target, candidate));
        
        return scores;
    }
    
    /**
     * Creates a scored candidate with detailed scoring information.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return A scored candidate with detailed per-strategy scores
     */
    public ScoredCandidate createDetailedScoredCandidate(ElementFingerprint target, ElementFingerprint candidate) {
        if (target == null || candidate == null) {
            return null;
        }
        
        Map<ScoringStrategy, Double> strategyScores = createDetailedScoringReport(target, candidate);
        double overallScore = calculateOverallScore(strategyScores);
        
        return new ScoredCandidate(candidate, overallScore, strategyScores);
    }
    
    /**
     * Calculates the overall score from individual strategy scores, applying the configured weights.
     * 
     * @param strategyScores Map of scoring strategies to their individual scores
     * @return The weighted overall score
     */
    private double calculateOverallScore(Map<ScoringStrategy, Double> strategyScores) {
        double score = 0.0;
        double totalWeight = 0.0;
        
        for (ScoringStrategy strategy : strategyScores.keySet()) {
            double weight = getStrategyWeight(strategy);
            double strategyScore = strategyScores.get(strategy);
            
            score += weight * strategyScore;
            totalWeight += weight;
        }
        
        return totalWeight > 0 ? score / totalWeight : 0.0;
    }
    
    /**
     * Finds the best matching element fingerprint from a collection of candidates,
     * applying a custom scoring function.
     * 
     * @param target The target element fingerprint
     * @param candidates The collection of candidate element fingerprints
     * @param scoringFunction The custom scoring function
     * @return The best matching candidate, or null if none meet the minimum match score
     */
    public ElementFingerprint findBestMatchWithCustomScoring(
            ElementFingerprint target, 
            Collection<ElementFingerprint> candidates,
            BiFunction<ElementFingerprint, ElementFingerprint, Double> scoringFunction) {
        if (target == null || candidates == null || candidates.isEmpty() || scoringFunction == null) {
            return null;
        }
        
        ScoredCandidate bestCandidate = findBestMatchWithScoreAndCustomScoring(target, candidates, scoringFunction);
        
        return bestCandidate != null ? bestCandidate.getCandidate() : null;
    }
    
    /**
     * Finds the best matching element fingerprint with its similarity score,
     * applying a custom scoring function.
     * 
     * @param target The target element fingerprint
     * @param candidates The collection of candidate element fingerprints
     * @param scoringFunction The custom scoring function
     * @return The best matching candidate with its score, or null if none meet the minimum match score
     */
    public ScoredCandidate findBestMatchWithScoreAndCustomScoring(
            ElementFingerprint target, 
            Collection<ElementFingerprint> candidates,
            BiFunction<ElementFingerprint, ElementFingerprint, Double> scoringFunction) {
        if (target == null || candidates == null || candidates.isEmpty() || scoringFunction == null) {
            return null;
        }
        
        List<ScoredCandidate> scoredCandidates = candidates.stream()
                .map(candidate -> new ScoredCandidate(candidate, scoringFunction.apply(target, candidate)))
                .filter(scored -> scored.getScore() >= minimumMatchScore)
                .sorted(Comparator.comparing(ScoredCandidate::getScore).reversed())
                .collect(Collectors.toList());
        
        return scoredCandidates.isEmpty() ? null : scoredCandidates.get(0);
    }
    
    /**
     * Finds all matching element fingerprints that meet the minimum match score,
     * applying a custom scoring function.
     * 
     * @param target The target element fingerprint
     * @param candidates The collection of candidate element fingerprints
     * @param scoringFunction The custom scoring function
     * @return List of matching candidates with their scores, sorted by descending similarity
     */
    public List<ScoredCandidate> findAllMatchesWithCustomScoring(
            ElementFingerprint target, 
            Collection<ElementFingerprint> candidates,
            BiFunction<ElementFingerprint, ElementFingerprint, Double> scoringFunction) {
        if (target == null || candidates == null || candidates.isEmpty() || scoringFunction == null) {
            return Collections.emptyList();
        }
        
        return candidates.stream()
                .map(candidate -> new ScoredCandidate(candidate, scoringFunction.apply(target, candidate)))
                .filter(scored -> scored.getScore() >= minimumMatchScore)
                .sorted(Comparator.comparing(ScoredCandidate::getScore).reversed())
                .collect(Collectors.toList());
    }
    
    /**
     * Groups candidates by similarity score ranges.
     * 
     * @param target The target element fingerprint
     * @param candidates The collection of candidate element fingerprints
     * @param rangeBoundaries The boundaries for the score ranges (must be in ascending order)
     * @return A map of range labels to lists of candidates in each range
     */
    public Map<String, List<ElementFingerprint>> groupCandidatesByScoreRanges(
            ElementFingerprint target, 
            Collection<ElementFingerprint> candidates,
            double... rangeBoundaries) {
        if (target == null || candidates == null || candidates.isEmpty() || rangeBoundaries == null || rangeBoundaries.length == 0) {
            return Collections.emptyMap();
        }
        
        // Ensure boundaries are in ascending order
        double[] sortedBoundaries = Arrays.copyOf(rangeBoundaries, rangeBoundaries.length);
        Arrays.sort(sortedBoundaries);
        
        Map<String, List<ElementFingerprint>> result = new HashMap<>();
        
        // Initialize result map with range labels
        for (int i = 0; i < sortedBoundaries.length; i++) {
            String rangeLabel;
            
            if (i == 0) {
                rangeLabel = "< " + sortedBoundaries[i];
            } else if (i == sortedBoundaries.length - 1) {
                rangeLabel = ">= " + sortedBoundaries[i - 1];
            } else {
                rangeLabel = sortedBoundaries[i - 1] + " - " + sortedBoundaries[i];
            }
            
            result.put(rangeLabel, new ArrayList<>());
        }
        
        // Group candidates by score ranges
        for (ElementFingerprint candidate : candidates) {
            double score = calculateSimilarityScore(target, candidate);
            String rangeLabel = null;
            
            for (int i = 0; i < sortedBoundaries.length; i++) {
                if (i == 0 && score < sortedBoundaries[i]) {
                    rangeLabel = "< " + sortedBoundaries[i];
                    break;
                } else if (i == sortedBoundaries.length - 1 && score >= sortedBoundaries[i - 1]) {
                    rangeLabel = ">= " + sortedBoundaries[i - 1];
                    break;
                } else if (i > 0 && score >= sortedBoundaries[i - 1] && score < sortedBoundaries[i]) {
                    rangeLabel = sortedBoundaries[i - 1] + " - " + sortedBoundaries[i];
                    break;
                }
            }
            
            if (rangeLabel != null) {
                result.get(rangeLabel).add(candidate);
            }
        }
        
        return result;
    }
    
    /**
     * Ranks candidates by similarity score and returns the top N candidates.
     * 
     * @param target The target element fingerprint
     * @param candidates The collection of candidate element fingerprints
     * @param limit The maximum number of candidates to return
     * @return List of the top N candidates with their scores
     */
    public List<ScoredCandidate> findTopMatches(
            ElementFingerprint target, 
            Collection<ElementFingerprint> candidates,
            int limit) {
        if (target == null || candidates == null || candidates.isEmpty() || limit <= 0) {
            return Collections.emptyList();
        }
        
        return candidates.stream()
                .map(candidate -> new ScoredCandidate(candidate, calculateSimilarityScore(target, candidate)))
                .sorted(Comparator.comparing(ScoredCandidate::getScore).reversed())
                .limit(limit)
                .collect(Collectors.toList());
    }
}



AttributeHealingStrategy.java
-------------------------------------

package com.cstestforge.framework.core.selfhealing;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * A healing strategy based on element attributes.
 * This strategy focuses on finding elements with similar attributes
 * when the original locator fails.
 */
public class AttributeHealingStrategy implements HealingStrategy {

    private static final long serialVersionUID = 1L;
    
    // The default minimum score threshold for candidate acceptance
    private static final double DEFAULT_MINIMUM_SCORE = 0.7;
    
    // The list of critical attributes that are given higher priority
    private static final Set<String> CRITICAL_ATTRIBUTES = new HashSet<>();
    
    static {
        CRITICAL_ATTRIBUTES.add("id");
        CRITICAL_ATTRIBUTES.add("name");
        CRITICAL_ATTRIBUTES.add("class");
        CRITICAL_ATTRIBUTES.add("type");
        CRITICAL_ATTRIBUTES.add("role");
        CRITICAL_ATTRIBUTES.add("aria-label");
        CRITICAL_ATTRIBUTES.add("title");
        CRITICAL_ATTRIBUTES.add("data-test-id");
        CRITICAL_ATTRIBUTES.add("data-testid");
        CRITICAL_ATTRIBUTES.add("data-cy");
        CRITICAL_ATTRIBUTES.add("data-qa");
        CRITICAL_ATTRIBUTES.add("data-automation-id");
    }
    
    // The similarity scorer used for comparing elements
    private final SimilarityScorer similarityScorer;
    
    // The minimum score required for a candidate to be considered
    private final double minimumScore;
    
    // The attribute weights to use for scoring
    private final Map<String, Double> attributeWeights;
    
    // Flag to prioritize exact attribute matches
    private final boolean prioritizeExactMatches;
    
    // Flag to ignore attribute case when comparing
    private final boolean ignoreAttributeCase;
    
    // Flag to consider partial class matches
    private final boolean considerPartialClasses;
    
    // Regular expression patterns to filter attributes
    private final List<Pattern> attributeFilterPatterns;
    
    /**
     * Creates a new attribute healing strategy with default settings.
     */
    public AttributeHealingStrategy() {
        this.similarityScorer = SimilarityScorer.createAttributeOptimizedScorer();
        this.minimumScore = DEFAULT_MINIMUM_SCORE;
        this.attributeWeights = initializeDefaultAttributeWeights();
        this.prioritizeExactMatches = true;
        this.ignoreAttributeCase = true;
        this.considerPartialClasses = true;
        this.attributeFilterPatterns = new ArrayList<>();
    }
    
    /**
     * Creates a new attribute healing strategy with the specified settings.
     * 
     * @param similarityScorer The similarity scorer to use
     * @param minimumScore The minimum score required for a candidate
     * @param attributeWeights The attribute weights to use for scoring
     * @param prioritizeExactMatches Whether to prioritize exact attribute matches
     * @param ignoreAttributeCase Whether to ignore attribute case when comparing
     * @param considerPartialClasses Whether to consider partial class matches
     * @param attributeFilterPatterns Regular expression patterns to filter attributes
     */
    public AttributeHealingStrategy(
            SimilarityScorer similarityScorer,
            double minimumScore,
            Map<String, Double> attributeWeights,
            boolean prioritizeExactMatches,
            boolean ignoreAttributeCase,
            boolean considerPartialClasses,
            List<Pattern> attributeFilterPatterns) {
        this.similarityScorer = similarityScorer != null ? similarityScorer : SimilarityScorer.createAttributeOptimizedScorer();
        this.minimumScore = minimumScore >= 0.0 && minimumScore <= 1.0 ? minimumScore : DEFAULT_MINIMUM_SCORE;
        this.attributeWeights = attributeWeights != null ? new HashMap<>(attributeWeights) : initializeDefaultAttributeWeights();
        this.prioritizeExactMatches = prioritizeExactMatches;
        this.ignoreAttributeCase = ignoreAttributeCase;
        this.considerPartialClasses = considerPartialClasses;
        this.attributeFilterPatterns = attributeFilterPatterns != null ? new ArrayList<>(attributeFilterPatterns) : new ArrayList<>();
    }
    
    /**
     * Initializes the default attribute weights.
     * 
     * @return Map of attribute names to weight values
     */
    private Map<String, Double> initializeDefaultAttributeWeights() {
        Map<String, Double> weights = new HashMap<>();
        weights.put("id", 10.0);
        weights.put("name", 8.0);
        weights.put("class", 7.0);
        weights.put("type", 6.0);
        weights.put("role", 6.0);
        weights.put("aria-label", 5.0);
        weights.put("title", 5.0);
        weights.put("data-test-id", 9.0);
        weights.put("data-testid", 9.0);
        weights.put("data-cy", 9.0);
        weights.put("data-qa", 9.0);
        weights.put("data-automation-id", 9.0);
        weights.put("href", 4.0);
        weights.put("src", 4.0);
        weights.put("alt", 4.0);
        weights.put("placeholder", 4.0);
        weights.put("value", 3.0);
        weights.put("for", 3.0);
        return weights;
    }
    
    @Override
    public String getName() {
        return "Attribute Healing Strategy";
    }
    
    @Override
    public String getDescription() {
        return "A healing strategy that focuses on finding elements with similar attributes " +
               "when the original locator fails. This strategy compares element attributes " +
               "such as ID, name, class, and data-* attributes to identify potential matches.";
    }
    
    @Override
    public HealingResult findAlternativeLocator(
            ElementFingerprint originalElement,
            List<ElementFingerprint> candidates,
            LocatorType locatorType,
            String originalLocator) {
        
        if (originalElement == null || candidates == null || candidates.isEmpty()) {
            return HealingResult.failed("No valid input provided");
        }
        
        // Filter candidates by tag name if available
        List<ElementFingerprint> filteredCandidates = candidates;
        if (originalElement.getTagName() != null && !originalElement.getTagName().isEmpty()) {
            filteredCandidates = candidates.stream()
                    .filter(candidate -> originalElement.getTagName().equalsIgnoreCase(candidate.getTagName()))
                    .collect(Collectors.toList());
            
            // If no candidates match the tag name, use all candidates as a fallback
            if (filteredCandidates.isEmpty()) {
                filteredCandidates = candidates;
            }
        }
        
        // Generate custom attribute-focused scoring function
        List<SimilarityScorer.ScoredCandidate> scoredCandidates = similarityScorer.findAllMatches(
                originalElement, 
                filteredCandidates
        );
        
        // Filter by minimum score
        scoredCandidates = scoredCandidates.stream()
                .filter(scored -> scored.getScore() >= minimumScore)
                .collect(Collectors.toList());
        
        if (scoredCandidates.isEmpty()) {
            return HealingResult.failed("No matching candidates found with score >= " + minimumScore);
        }
        
        // Sort by attribute similarity score
        scoredCandidates.sort(Comparator.comparing(SimilarityScorer.ScoredCandidate::getScore).reversed());
        
        // Get the best candidate
        SimilarityScorer.ScoredCandidate bestCandidate = scoredCandidates.get(0);
        
        // Generate a new locator based on the best candidate's attributes
        String healedLocator = generateLocatorFromCandidate(
                bestCandidate.getCandidate(), 
                locatorType != null ? locatorType : inferLocatorType(originalLocator)
        );
        
        if (healedLocator == null || healedLocator.isEmpty()) {
            return HealingResult.failed("Could not generate a valid locator from the best candidate");
        }
        
        return HealingResult.success(
                healedLocator,
                bestCandidate.getScore(),
                getName(),
                "Found alternative locator by attribute matching with score " + bestCandidate.getScore()
        );
    }
    
    /**
     * Generates a new locator based on the candidate's attributes and the specified locator type.
     * 
     * @param candidate The candidate element fingerprint
     * @param locatorType The type of locator to generate
     * @return The generated locator, or null if generation fails
     */
    private String generateLocatorFromCandidate(ElementFingerprint candidate, LocatorType locatorType) {
        if (candidate == null || locatorType == null) {
            return null;
        }
        
        switch (locatorType) {
            case ID:
                return generateIdLocator(candidate);
            case NAME:
                return generateNameLocator(candidate);
            case CLASS_NAME:
                return generateClassLocator(candidate);
            case TAG_NAME:
                return generateTagLocator(candidate);
            case XPATH:
                return generateXPathLocator(candidate);
            case CSS_SELECTOR:
                return generateCssLocator(candidate);
            case LINK_TEXT:
                return generateLinkTextLocator(candidate);
            case PARTIAL_LINK_TEXT:
                return generatePartialLinkTextLocator(candidate);
            default:
                // Default to a CSS selector as a fallback
                return generateCssLocator(candidate);
        }
    }
    
    /**
     * Generates an ID locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated ID locator, or null if generation fails
     */
    private String generateIdLocator(ElementFingerprint candidate) {
        String id = candidate.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            return id;
        }
        return null;
    }
    
    /**
     * Generates a name locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated name locator, or null if generation fails
     */
    private String generateNameLocator(ElementFingerprint candidate) {
        String name = candidate.getAttribute("name");
        if (name != null && !name.isEmpty()) {
            return name;
        }
        return null;
    }
    
    /**
     * Generates a class locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated class locator, or null if generation fails
     */
    private String generateClassLocator(ElementFingerprint candidate) {
        List<String> classes = candidate.getClasses();
        if (!classes.isEmpty()) {
            // Use the first class as the locator
            return classes.get(0);
        }
        return null;
    }
    
    /**
     * Generates a tag locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated tag locator, or null if generation fails
     */
    private String generateTagLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName != null && !tagName.isEmpty()) {
            return tagName;
        }
        return null;
    }
    
    /**
     * Generates an XPath locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated XPath locator, or null if generation fails
     */
    private String generateXPathLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName == null || tagName.isEmpty()) {
            tagName = "*";
        }
        
        // Try to generate an ID-based XPath
        String id = candidate.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            return "//" + tagName + "[@id='" + id + "']";
        }
        
        // Try to generate a name-based XPath
        String name = candidate.getAttribute("name");
        if (name != null && !name.isEmpty()) {
            return "//" + tagName + "[@name='" + name + "']";
        }
        
        // Try to generate a class-based XPath
        List<String> classes = candidate.getClasses();
        if (!classes.isEmpty()) {
            return "//" + tagName + "[contains(@class, '" + classes.get(0) + "')]";
        }
        
        // Try to generate a text-based XPath
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            // Trim and truncate the text to avoid excessively long XPaths
            String trimmedText = text.trim();
            if (trimmedText.length() > 20) {
                trimmedText = trimmedText.substring(0, 20);
            }
            return "//" + tagName + "[contains(text(), '" + escapeQuotes(trimmedText) + "')]";
        }
        
        // Try to find a unique attribute
        Map<String, String> attributes = candidate.getAttributes();
        for (Map.Entry<String, String> entry : attributes.entrySet()) {
            String attrName = entry.getKey();
            String attrValue = entry.getValue();
            
            // Skip certain attributes
            if (attrName.equals("id") || attrName.equals("name") || attrName.equals("class")) {
                continue;
            }
            
            if (attrValue != null && !attrValue.isEmpty()) {
                return "//" + tagName + "[@" + attrName + "='" + escapeQuotes(attrValue) + "']";
            }
        }
        
        // Fallback to the candidate's existing XPath if available
        String xpath = candidate.getXpath();
        if (xpath != null && !xpath.isEmpty()) {
            return xpath;
        }
        
        // Last resort: generic tag name
        return "//" + tagName;
    }
    
    /**
     * Generates a CSS selector from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated CSS selector, or null if generation fails
     */
    private String generateCssLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName == null || tagName.isEmpty()) {
            tagName = "*";
        }
        
        // Try to generate an ID-based selector
        String id = candidate.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            return tagName + "#" + cssEscape(id);
        }
        
        // Try to generate a class-based selector
        List<String> classes = candidate.getClasses();
        if (!classes.isEmpty()) {
            StringBuilder classSelector = new StringBuilder(tagName);
            for (String className : classes) {
                classSelector.append(".").append(cssEscape(className));
            }
            return classSelector.toString();
        }
        
        // Try to generate an attribute-based selector
        Map<String, String> attributes = candidate.getAttributes();
        for (Map.Entry<String, String> entry : attributes.entrySet()) {
            String attrName = entry.getKey();
            String attrValue = entry.getValue();
            
            // Skip certain attributes
            if (attrName.equals("id") || attrName.equals("class")) {
                continue;
            }
            
            if (attrValue != null && !attrValue.isEmpty()) {
                return tagName + "[" + attrName + "='" + escapeQuotes(attrValue) + "']";
            }
        }
        
        // Fallback to the candidate's existing CSS selector if available
        String cssSelector = candidate.getCssSelector();
        if (cssSelector != null && !cssSelector.isEmpty()) {
            return cssSelector;
        }
        
        // Last resort: generic tag name
        return tagName;
    }
    
    /**
     * Generates a link text locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated link text locator, or null if generation fails
     */
    private String generateLinkTextLocator(ElementFingerprint candidate) {
        // Only applicable for anchor tags
        if (!"a".equalsIgnoreCase(candidate.getTagName())) {
            return null;
        }
        
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            return text.trim();
        }
        
        return null;
    }
    
    /**
     * Generates a partial link text locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated partial link text locator, or null if generation fails
     */
    private String generatePartialLinkTextLocator(ElementFingerprint candidate) {
        // Only applicable for anchor tags
        if (!"a".equalsIgnoreCase(candidate.getTagName())) {
            return null;
        }
        
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            // Limit to first 20 characters to avoid excessively long locators
            text = text.trim();
            if (text.length() > 20) {
                text = text.substring(0, 20);
            }
            return text;
        }
        
        return null;
    }
    
    /**
     * Escapes single quotes in a string.
     * 
     * @param str The string to escape
     * @return The escaped string
     */
    private String escapeQuotes(String str) {
        return str.replace("'", "\\'");
    }
    
    /**
     * Escapes characters for CSS selectors.
     * 
     * @param str The string to escape
     * @return The escaped string
     */
    private String cssEscape(String str) {
        // Based on CSS.escape() polyfill
        StringBuilder result = new StringBuilder();
        
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            
            // Escape special characters
            if (ch == 0) {
                result.append("\\0");
            } else if ((ch >= 1 && ch <= 31) || ch == 127) {
                result.append("\\").append(Integer.toHexString(ch)).append(" ");
            } else if (i == 0 && ch >= '0' && ch <= '9') {
                result.append("\\").append(ch);
            } else if (ch == '#' || ch == '.' || ch == '[' || ch == ']' || ch == '(' || ch == ')' ||
                    ch == '{' || ch == '}' || ch == ':' || ch == ',' || ch == ';' || ch == '+' ||
                    ch == '>' || ch == '~' || ch == '|' || ch == '*' || ch == '=' || ch == '^' ||
                    ch == '$' || ch == '!' || ch == '"' || ch == '\'' || ch == '/' || ch == '\\') {
                result.append("\\").append(ch);
            } else {
                result.append(ch);
            }
        }
        
        return result.toString();
    }
    
    /**
     * Infers the locator type from the original locator string.
     * 
     * @param originalLocator The original locator string
     * @return The inferred locator type
     */
    private LocatorType inferLocatorType(String originalLocator) {
        if (originalLocator == null || originalLocator.isEmpty()) {
            return LocatorType.CSS_SELECTOR; // Default
        }
        
        // Check for XPath
        if (originalLocator.startsWith("/") || originalLocator.startsWith("(")) {
            return LocatorType.XPATH;
        }
        
        // Check for CSS selector
        if (originalLocator.contains("#") || originalLocator.contains(".") || originalLocator.contains("[") ||
                originalLocator.contains(">") || originalLocator.contains("+") || originalLocator.contains("~")) {
            return LocatorType.CSS_SELECTOR;
        }
        
        // Check for ID (simple word without spaces)
        if (originalLocator.matches("^\\w+$")) {
            return LocatorType.ID;
        }
        
        // Default to CSS selector
        return LocatorType.CSS_SELECTOR;
    }
    
    /**
     * Calculates the attribute similarity score between two element fingerprints.
     * 
     * @param target The target element fingerprint
     * @param candidate The candidate element fingerprint
     * @return The attribute similarity score (0.0 to 1.0)
     */
    public double calculateAttributeSimilarityScore(ElementFingerprint target, ElementFingerprint candidate) {
        if (target == null || candidate == null) {
            return 0.0;
        }
        
        // Compare tag names first (most basic attribute)
        if (!Objects.equals(target.getTagName(), candidate.getTagName())) {
            // Tag mismatch is a significant problem
            // Return a low but non-zero score to allow for some flexibility
            return 0.2;
        }
        
        // Get all attributes from both elements
        Map<String, String> targetAttrs = target.getAttributes();
        Map<String, String> candidateAttrs = candidate.getAttributes();
        
        if (targetAttrs.isEmpty() && candidateAttrs.isEmpty()) {
            // Both have no attributes, so they're similar in that regard
            // but it's not a strong signal
            return 0.5;
        }
        
        if (targetAttrs.isEmpty() || candidateAttrs.isEmpty()) {
            // One has attributes but the other doesn't
            // This is a significant mismatch
            return 0.3;
        }
        
        // Filter attributes based on patterns
        targetAttrs = filterAttributes(targetAttrs);
        candidateAttrs = filterAttributes(candidateAttrs);
        
        // Calculate weighted attribute similarity
        double totalScore = 0.0;
        double totalWeight = 0.0;
        
        // First, check critical attributes
        for (String attrName : CRITICAL_ATTRIBUTES) {
            if (targetAttrs.containsKey(attrName) && candidateAttrs.containsKey(attrName)) {
                String targetValue = targetAttrs.get(attrName);
                String candidateValue = candidateAttrs.get(attrName);
                
                double weight = getAttributeWeight(attrName);
                totalWeight += weight;
                
                double similarity = calculateAttributeValueSimilarity(attrName, targetValue, candidateValue);
                totalScore += similarity * weight;
            } else if (targetAttrs.containsKey(attrName) || candidateAttrs.containsKey(attrName)) {
                // One has the attribute but the other doesn't
                // This is a moderate mismatch for critical attributes
                double weight = getAttributeWeight(attrName) * 0.5; // Half weight for missing attributes
                totalWeight += weight;
                totalScore += 0.0; // Score of 0 for this attribute
            }
        }
        
        // Process remaining attributes
        Set<String> allAttrs = new HashSet<>(targetAttrs.keySet());
        allAttrs.addAll(candidateAttrs.keySet());
        allAttrs.removeAll(CRITICAL_ATTRIBUTES); // Already processed
        
        for (String attrName : allAttrs) {
            if (targetAttrs.containsKey(attrName) && candidateAttrs.containsKey(attrName)) {
                String targetValue = targetAttrs.get(attrName);
                String candidateValue = candidateAttrs.get(attrName);
                
                double weight = getAttributeWeight(attrName);
                totalWeight += weight;
                
                double similarity = calculateAttributeValueSimilarity(attrName, targetValue, candidateValue);
                totalScore += similarity * weight;
            } else {
                // One has the attribute but the other doesn't
                // Less significant for non-critical attributes
                double weight = getAttributeWeight(attrName) * 0.3; // Reduced weight for missing non-critical attrs
                totalWeight += weight;
                totalScore += 0.0; // Score of 0 for this attribute
            }
        }
        
        // Normalize the score
        return totalWeight > 0 ? totalScore / totalWeight : 0.5;
    }
    
    /**
     * Filters attributes based on the configured patterns.
     * 
     * @param attributes The attributes to filter
     * @return The filtered attributes
     */
    private Map<String, String> filterAttributes(Map<String, String> attributes) {
        if (attributes == null || attributeFilterPatterns.isEmpty()) {
            return attributes;
        }
        
        Map<String, String> result = new HashMap<>(attributes);
        
        // Filter out attributes that match any of the patterns
        for (Pattern pattern : attributeFilterPatterns) {
            result.keySet().removeIf(attrName -> pattern.matcher(attrName).matches());
        }
        
        return result;
    }
    
    /**
     * Gets the weight for a specific attribute.
     * 
     * @param attributeName The attribute name
     * @return The attribute weight
     */
    private double getAttributeWeight(String attributeName) {
        Double weight = attributeWeights.get(attributeName);
        
        if (weight != null) {
            return weight;
        }
        
        // Default weights for attribute patterns
        if (attributeName.startsWith("data-")) {
            return 4.0;
        }
        if (attributeName.startsWith("aria-")) {
            return 3.0;
        }
        
        // Default weight for unknown attributes
        return 1.0;
    }
    
    /**
     * Calculates the similarity between two attribute values.
     * 
     * @param attributeName The attribute name
     * @param value1 The first attribute value
     * @param value2 The second attribute value
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateAttributeValueSimilarity(String attributeName, String value1, String value2) {
        if (value1 == null || value2 == null) {
            return 0.0;
        }
        
        // For exact matches
        if (prioritizeExactMatches) {
            boolean exactMatch = ignoreAttributeCase ? 
                    value1.equalsIgnoreCase(value2) : 
                    value1.equals(value2);
            
            if (exactMatch) {
                return 1.0;
            }
        }
        
        // Special handling for class attribute
        if ("class".equals(attributeName) && considerPartialClasses) {
            return calculateClassSimilarity(value1, value2);
        }
        
        // Handle numeric attributes (try to parse as numbers and compare)
        if (isNumericAttribute(attributeName)) {
            try {
                double num1 = Double.parseDouble(value1);
                double num2 = Double.parseDouble(value2);
                
                // Calculate numeric similarity
                double maxVal = Math.max(Math.abs(num1), Math.abs(num2));
                if (maxVal > 0) {
                    return 1.0 - Math.min(1.0, Math.abs(num1 - num2) / maxVal);
                }
                
                return num1 == num2 ? 1.0 : 0.0;
            } catch (NumberFormatException e) {
                // Not numeric, continue with string comparison
            }
        }
        
        // For approximate string matches
        String normalizedValue1 = ignoreAttributeCase ? value1.toLowerCase() : value1;
        String normalizedValue2 = ignoreAttributeCase ? value2.toLowerCase() : value2;
        
        if (normalizedValue1.contains(normalizedValue2) || normalizedValue2.contains(normalizedValue1)) {
            // One is a substring of the other
            double ratio = (double) Math.min(normalizedValue1.length(), normalizedValue2.length()) / 
                    Math.max(normalizedValue1.length(), normalizedValue2.length());
            return 0.7 + 0.3 * ratio; // From 0.7 to 1.0 depending on relative lengths
        }
        
        // For unrelated strings, use Levenshtein similarity
        return calculateLevenshteinSimilarity(normalizedValue1, normalizedValue2);
    }
    
    /**
     * Calculates the similarity between two class attribute values.
     * 
     * @param classes1 The first class attribute value
     * @param classes2 The second class attribute value
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateClassSimilarity(String classes1, String classes2) {
        if (classes1 == null || classes2 == null) {
            return 0.0;
        }
        
        // Split into individual classes
        String[] classArray1 = classes1.trim().split("\\s+");
        String[] classArray2 = classes2.trim().split("\\s+");
        
        Set<String> classSet1 = new HashSet<>();
        Set<String> classSet2 = new HashSet<>();
        
        for (String cls : classArray1) {
            if (!cls.isEmpty()) {
                classSet1.add(ignoreAttributeCase ? cls.toLowerCase() : cls);
            }
        }
        
        for (String cls : classArray2) {
            if (!cls.isEmpty()) {
                classSet2.add(ignoreAttributeCase ? cls.toLowerCase() : cls);
            }
        }
        
        if (classSet1.isEmpty() && classSet2.isEmpty()) {
            return 1.0;
        }
        
        if (classSet1.isEmpty() || classSet2.isEmpty()) {
            return 0.0;
        }
        
        // Calculate Jaccard similarity (intersection / union)
        Set<String> intersection = new HashSet<>(classSet1);
        intersection.retainAll(classSet2);
        
        Set<String> union = new HashSet<>(classSet1);
        union.addAll(classSet2);
        
        return (double) intersection.size() / union.size();
    }
    
    /**
     * Checks if an attribute typically contains numeric values.
     * 
     * @param attributeName The attribute name
     * @return true if the attribute typically contains numeric values, false otherwise
     */
    private boolean isNumericAttribute(String attributeName) {
        String[] numericAttributes = {
            "width", "height", "size", "maxlength", "max", "min", "step", "rows", "cols", "tabindex",
            "colspan", "rowspan", "cellspacing", "cellpadding", "border", "marginwidth", "marginheight"
        };
        
        for (String attr : numericAttributes) {
            if (attr.equalsIgnoreCase(attributeName)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Calculates string similarity based on Levenshtein distance.
     * 
     * @param s1 The first string
     * @param s2 The second string
     * @return The Levenshtein similarity score (0.0 to 1.0)
     */
    private double calculateLevenshteinSimilarity(String s1, String s2) {
        if (s1 == null || s2 == null) {
            return 0.0;
        }
        
        if (s1.equals(s2)) {
            return 1.0;
        }
        
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        
        for (int i = 0; i <= s1.length(); i++) {
            dp[i][0] = i;
        }
        
        for (int j = 0; j <= s2.length(); j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                int cost = (s1.charAt(i - 1) == s2.charAt(j - 1)) ? 0 : 1;
                dp[i][j] = Math.min(
                        Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),
                        dp[i - 1][j - 1] + cost
                );
            }
        }
        
        int distance = dp[s1.length()][s2.length()];
        int maxLength = Math.max(s1.length(), s2.length());
        
        // Convert distance to similarity score
        return maxLength > 0 ? 1.0 - (double) distance / maxLength : 1.0;
    }
    
    /**
     * Builder class for creating attribute healing strategy instances.
     */
    public static class Builder {
        private SimilarityScorer similarityScorer;
        private double minimumScore = DEFAULT_MINIMUM_SCORE;
        private final Map<String, Double> attributeWeights = new HashMap<>();
        private boolean prioritizeExactMatches = true;
        private boolean ignoreAttributeCase = true;
        private boolean considerPartialClasses = true;
        private final List<Pattern> attributeFilterPatterns = new ArrayList<>();
        
        /**
         * Creates a new builder with default settings.
         */
        public Builder() {
            // Default attributes weights
            attributeWeights.put("id", 10.0);
            attributeWeights.put("name", 8.0);
            attributeWeights.put("class", 7.0);
            attributeWeights.put("type", 6.0);
            attributeWeights.put("role", 6.0);
            attributeWeights.put("aria-label", 5.0);
            attributeWeights.put("title", 5.0);
            attributeWeights.put("data-test-id", 9.0);
            attributeWeights.put("data-testid", 9.0);
            attributeWeights.put("data-cy", 9.0);
            attributeWeights.put("data-qa", 9.0);
            attributeWeights.put("data-automation-id", 9.0);
            attributeWeights.put("href", 4.0);
            attributeWeights.put("src", 4.0);
            attributeWeights.put("alt", 4.0);
            attributeWeights.put("placeholder", 4.0);
            attributeWeights.put("value", 3.0);
            attributeWeights.put("for", 3.0);
        }
        
        /**
         * Sets the similarity scorer to use.
         * 
         * @param similarityScorer The similarity scorer
         * @return This builder instance
         */
        public Builder withSimilarityScorer(SimilarityScorer similarityScorer) {
            this.similarityScorer = similarityScorer;
            return this;
        }
        
        /**
         * Sets the minimum score required for a candidate.
         * 
         * @param minimumScore The minimum score
         * @return This builder instance
         */
        public Builder withMinimumScore(double minimumScore) {
            if (minimumScore >= 0.0 && minimumScore <= 1.0) {
                this.minimumScore = minimumScore;
            }
            return this;
        }
        
        /**
         * Sets the weight for a specific attribute.
         * 
         * @param attributeName The attribute name
         * @param weight The attribute weight
         * @return This builder instance
         */
        public Builder withAttributeWeight(String attributeName, double weight) {
            if (attributeName != null && !attributeName.isEmpty() && weight >= 0.0) {
                attributeWeights.put(attributeName, weight);
            }
            return this;
        }
        
        /**
         * Sets whether to prioritize exact attribute matches.
         * 
         * @param prioritizeExactMatches true to prioritize exact matches, false otherwise
         * @return This builder instance
         */
        public Builder withPrioritizeExactMatches(boolean prioritizeExactMatches) {
            this.prioritizeExactMatches = prioritizeExactMatches;
            return this;
        }
        
        /**
         * Sets whether to ignore attribute case when comparing.
         * 
         * @param ignoreAttributeCase true to ignore case, false otherwise
         * @return This builder instance
         */
        public Builder withIgnoreAttributeCase(boolean ignoreAttributeCase) {
            this.ignoreAttributeCase = ignoreAttributeCase;
            return this;
        }
        
        /**
         * Sets whether to consider partial class matches.
         * 
         * @param considerPartialClasses true to consider partial matches, false otherwise
         * @return This builder instance
         */
        public Builder withConsiderPartialClasses(boolean considerPartialClasses) {
            this.considerPartialClasses = considerPartialClasses;
            return this;
        }
        
        /**
         * Adds a filter pattern for attributes.
         * 
         * @param pattern The regular expression pattern
         * @return This builder instance
         */
        public Builder withAttributeFilterPattern(String pattern) {
            if (pattern != null && !pattern.isEmpty()) {
                attributeFilterPatterns.add(Pattern.compile(pattern));
            }
            return this;
        }
        
        /**
         * Adds filter patterns for attributes.
         * 
         * @param patterns The regular expression patterns
         * @return This builder instance
         */
        public Builder withAttributeFilterPatterns(List<String> patterns) {
            if (patterns != null) {
                for (String pattern : patterns) {
                    withAttributeFilterPattern(pattern);
                }
            }
            return this;
        }
        
        /**
         * Builds an AttributeHealingStrategy from the current builder state.
         * 
         * @return The attribute healing strategy
         */
        public AttributeHealingStrategy build() {
            return new AttributeHealingStrategy(
                    similarityScorer,
                    minimumScore,
                    attributeWeights,
                    prioritizeExactMatches,
                    ignoreAttributeCase,
                    considerPartialClasses,
                    attributeFilterPatterns
            );
        }
    }
    
    /**
     * Creates a builder for constructing a customized AttributeHealingStrategy.
     * 
     * @return A new builder instance
     */
    public static Builder builder() {
        return new Builder();
    }
}


HealingStrategy.java
----------------------------------

package com.cstestforge.framework.core.selfhealing;

import java.io.Serializable;
import java.util.List;

/**
 * Interface for self-healing locator strategies.
 * A healing strategy is responsible for finding an alternative locator
 * when the original locator fails to locate an element.
 */
public interface HealingStrategy extends Serializable {
    
    /**
     * Gets the name of the healing strategy.
     * 
     * @return The strategy name
     */
    String getName();
    
    /**
     * Gets a detailed description of the healing strategy.
     * 
     * @return The strategy description
     */
    String getDescription();
    
    /**
     * Attempts to find an alternative locator for an element.
     * 
     * @param originalElement The fingerprint of the original element
     * @param candidates The list of candidate element fingerprints
     * @param locatorType The type of locator to generate
     * @param originalLocator The original locator that failed
     * @return The healing result containing the new locator and metadata
     */
    HealingResult findAlternativeLocator(
            ElementFingerprint originalElement,
            List<ElementFingerprint> candidates,
            LocatorType locatorType,
            String originalLocator);
    
    /**
     * Types of locators that can be generated.
     */
    enum LocatorType {
        /**
         * ID locator type.
         * Example: By.id("myElementId")
         */
        ID,
        
        /**
         * Name locator type.
         * Example: By.name("username")
         */
        NAME,
        
        /**
         * Class name locator type.
         * Example: By.className("button-primary")
         */
        CLASS_NAME,
        
        /**
         * Tag name locator type.
         * Example: By.tagName("input")
         */
        TAG_NAME,
        
        /**
         * XPath locator type.
         * Example: By.xpath("//div[@id='container']/input")
         */
        XPATH,
        
        /**
         * CSS selector locator type.
         * Example: By.cssSelector("div.container > input[type='text']")
         */
        CSS_SELECTOR,
        
        /**
         * Link text locator type.
         * Example: By.linkText("Click here")
         */
        LINK_TEXT,
        
        /**
         * Partial link text locator type.
         * Example: By.partialLinkText("Click")
         */
        PARTIAL_LINK_TEXT,
        
        /**
         * JavaScript execution locator type.
         * Example: By.js("return document.getElementById('myElement')")
         */
        JAVASCRIPT,
        
        /**
         * Playwright-specific text locator.
         * Example: page.locator("text=Click here")
         */
        PLAYWRIGHT_TEXT,
        
        /**
         * Playwright-specific has-text locator.
         * Example: page.locator("div").filter(hasText("Click here"))
         */
        PLAYWRIGHT_HAS_TEXT,
        
        /**
         * Playwright-specific role locator.
         * Example: page.getByRole("button")
         */
        PLAYWRIGHT_ROLE,
        
        /**
         * Playwright-specific test ID locator.
         * Example: page.getByTestId("my-test-id")
         */
        PLAYWRIGHT_TEST_ID,
        
        /**
         * Playwright-specific label locator.
         * Example: page.getByLabel("Username")
         */
        PLAYWRIGHT_LABEL,
        
        /**
         * Playwright-specific placeholder locator.
         * Example: page.getByPlaceholder("Enter username")
         */
        PLAYWRIGHT_PLACEHOLDER,
        
        /**
         * Playwright-specific alt text locator.
         * Example: page.getByAltText("Logo")
         */
        PLAYWRIGHT_ALT_TEXT,
        
        /**
         * Playwright-specific title locator.
         * Example: page.getByTitle("Information")
         */
        PLAYWRIGHT_TITLE,
        
        /**
         * Custom or dynamic locator type.
         * Used for strategy-specific locator formats.
         */
        CUSTOM
    }
    
    /**
     * Represents the result of a healing attempt.
     */
    class HealingResult implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        private final boolean successful;
        private final String healedLocator;
        private final double confidenceScore;
        private final String strategyName;
        private final String message;
        private final long timeMillis;
        
        /**
         * Creates a new healing result.
         * 
         * @param successful Whether the healing was successful
         * @param healedLocator The healed locator string, or null if healing failed
         * @param confidenceScore The confidence score (0.0 to 1.0)
         * @param strategyName The name of the healing strategy used
         * @param message Additional information about the healing attempt
         */
        private HealingResult(boolean successful, String healedLocator, double confidenceScore, 
                              String strategyName, String message) {
            this.successful = successful;
            this.healedLocator = healedLocator;
            this.confidenceScore = confidenceScore;
            this.strategyName = strategyName;
            this.message = message;
            this.timeMillis = System.currentTimeMillis();
        }
        
        /**
         * Creates a successful healing result.
         * 
         * @param healedLocator The healed locator string
         * @param confidenceScore The confidence score (0.0 to 1.0)
         * @param strategyName The name of the healing strategy used
         * @param message Additional information about the healing attempt
         * @return The healing result
         */
        public static HealingResult success(String healedLocator, double confidenceScore, 
                                           String strategyName, String message) {
            return new HealingResult(true, healedLocator, confidenceScore, strategyName, message);
        }
        
        /**
         * Creates a failed healing result.
         * 
         * @param message Information about why the healing failed
         * @return The healing result
         */
        public static HealingResult failed(String message) {
            return new HealingResult(false, null, 0.0, null, message);
        }
        
        /**
         * Creates a failed healing result with strategy information.
         * 
         * @param strategyName The name of the healing strategy used
         * @param message Information about why the healing failed
         * @return The healing result
         */
        public static HealingResult failed(String strategyName, String message) {
            return new HealingResult(false, null, 0.0, strategyName, message);
        }
        
        /**
         * Checks if the healing was successful.
         * 
         * @return true if the healing was successful, false otherwise
         */
        public boolean isSuccessful() {
            return successful;
        }
        
        /**
         * Gets the healed locator string.
         * 
         * @return The healed locator, or null if healing failed
         */
        public String getHealedLocator() {
            return healedLocator;
        }
        
        /**
         * Gets the confidence score.
         * 
         * @return The confidence score (0.0 to 1.0)
         */
        public double getConfidenceScore() {
            return confidenceScore;
        }
        
        /**
         * Gets the name of the healing strategy used.
         * 
         * @return The strategy name, or null if healing failed
         */
        public String getStrategyName() {
            return strategyName;
        }
        
        /**
         * Gets additional information about the healing attempt.
         * 
         * @return The message
         */
        public String getMessage() {
            return message;
        }
        
        /**
         * Gets the timestamp when the healing result was created.
         * 
         * @return The timestamp in milliseconds
         */
        public long getTimeMillis() {
            return timeMillis;
        }
        
        @Override
        public String toString() {
            if (successful) {
                return String.format("HealingResult{successful=%s, healedLocator='%s', confidenceScore=%.2f, " +
                                     "strategyName='%s', message='%s'}", 
                                     successful, healedLocator, confidenceScore, strategyName, message);
            } else {
                return String.format("HealingResult{successful=%s, message='%s'}", 
                                     successful, message);
            }
        }
    }
    
    /**
     * Creates a composite healing strategy that combines multiple healing strategies.
     * The composite strategy tries each sub-strategy in order until one succeeds.
     * 
     * @param strategies The healing strategies to combine
     * @return The composite healing strategy
     */
    static HealingStrategy composite(HealingStrategy... strategies) {
        return new CompositeHealingStrategy(strategies);
    }
    
    /**
     * A composite healing strategy that combines multiple healing strategies.
     * The composite strategy tries each sub-strategy in order until one succeeds.
     */
    class CompositeHealingStrategy implements HealingStrategy {
        
        private static final long serialVersionUID = 1L;
        
        private final HealingStrategy[] strategies;
        
        /**
         * Creates a new composite healing strategy.
         * 
         * @param strategies The healing strategies to combine
         */
        public CompositeHealingStrategy(HealingStrategy[] strategies) {
            this.strategies = strategies != null ? strategies.clone() : new HealingStrategy[0];
        }
        
        @Override
        public String getName() {
            return "Composite Healing Strategy";
        }
        
        @Override
        public String getDescription() {
            StringBuilder description = new StringBuilder(
                "A composite healing strategy that tries multiple sub-strategies in sequence " +
                "until one succeeds. The following strategies are included:\n"
            );
            
            for (int i = 0; i < strategies.length; i++) {
                HealingStrategy strategy = strategies[i];
                description.append(i + 1).append(". ").append(strategy.getName());
                if (i < strategies.length - 1) {
                    description.append("\n");
                }
            }
            
            return description.toString();
        }
        
        @Override
        public HealingResult findAlternativeLocator(
                ElementFingerprint originalElement,
                List<ElementFingerprint> candidates,
                LocatorType locatorType,
                String originalLocator) {
            
            if (originalElement == null || candidates == null || candidates.isEmpty()) {
                return HealingResult.failed("No valid input provided");
            }
            
            if (strategies.length == 0) {
                return HealingResult.failed("No healing strategies defined");
            }
            
            // Try each strategy in order
            for (HealingStrategy strategy : strategies) {
                HealingResult result = strategy.findAlternativeLocator(
                        originalElement, candidates, locatorType, originalLocator);
                
                if (result.isSuccessful()) {
                    return result;
                }
            }
            
            // All strategies failed
            return HealingResult.failed(
                    "All healing strategies failed. Tried " + strategies.length + " strategies."
            );
        }
    }
}



LocatorHealingService.java
-------------------------------------

package com.cstestforge.framework.core.selfhealing;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Core service for self-healing locators in the CSTestForge framework.
 * This service manages the process of healing broken locators by
 * finding alternative locators when the original ones fail.
 */
public class LocatorHealingService implements Serializable {

    private static final long serialVersionUID = 1L;
    private static final Logger LOGGER = Logger.getLogger(LocatorHealingService.class.getName());
    
    // Map of original locators to their fingerprints
    private final Map<LocatorKey, ElementFingerprint> fingerprintRegistry;
    
    // Map of broken locators to their healed alternatives
    private final Map<LocatorKey, HealedLocator> healedLocators;
    
    // Map of temporary element fingerprints used during healing attempts
    private final Map<String, ElementFingerprint> temporaryFingerprints;
    
    // Registry file path
    private final String registryFilePath;
    
    // Healing strategies
    private final List<HealingStrategy> healingStrategies;
    
    // Confidence threshold for accepting a healed locator
    private double minimumConfidenceThreshold;
    
    // Maximum number of healing attempts per locator
    private int maxHealingAttemptsPerLocator;
    
    // Flag to enable or disable the service
    private boolean enabled;
    
    // Flag to enable or disable logging of healing attempts
    private boolean loggingEnabled;
    
    // Flag to enable or disable automatic registry persistence
    private boolean autoPersistEnabled;
    
    // Flag to enable or disable automatic fingerprint updates
    private boolean autoUpdateEnabled;
    
    // Statistics
    private final AtomicInteger totalHealingAttempts;
    private final AtomicInteger successfulHealings;
    private final AtomicInteger failedHealings;
    
    /**
     * Creates a new locator healing service with default settings.
     */
    public LocatorHealingService() {
        this("./locator-registry.dat");
    }
    
    /**
     * Creates a new locator healing service with a custom registry file path.
     * 
     * @param registryFilePath The path to the registry file
     */
    public LocatorHealingService(String registryFilePath) {
        this.fingerprintRegistry = new ConcurrentHashMap<>();
        this.healedLocators = new ConcurrentHashMap<>();
        this.temporaryFingerprints = new ConcurrentHashMap<>();
        this.registryFilePath = registryFilePath;
        this.healingStrategies = new ArrayList<>();
        this.minimumConfidenceThreshold = 0.7;
        this.maxHealingAttemptsPerLocator = 5;
        this.enabled = true;
        this.loggingEnabled = true;
        this.autoPersistEnabled = true;
        this.autoUpdateEnabled = true;
        this.totalHealingAttempts = new AtomicInteger(0);
        this.successfulHealings = new AtomicInteger(0);
        this.failedHealings = new AtomicInteger(0);
        
        // Initialize with default healing strategies
        initializeDefaultStrategies();
        
        // Restore the registry from disk if available
        try {
            restoreRegistry();
        } catch (Exception e) {
            LOGGER.log(Level.WARNING, "Failed to restore locator registry: " + e.getMessage(), e);
            // Continue with an empty registry
        }
    }
    
    /**
     * Initializes the default healing strategies.
     */
    private void initializeDefaultStrategies() {
        // Add attribute healing strategy
        healingStrategies.add(new AttributeHealingStrategy());
        
        // Other strategies will be added as they are implemented
        // healingStrategies.add(new TextHealingStrategy());
        // healingStrategies.add(new PositionHealingStrategy());
        // healingStrategies.add(new StructureHealingStrategy());
    }
    
    /**
     * Registers an element fingerprint for a locator.
     * 
     * @param locatorType The locator type
     * @param locatorValue The locator value
     * @param elementFingerprint The element fingerprint
     * @return true if the registration was successful, false otherwise
     */
    public boolean registerFingerprint(
            HealingStrategy.LocatorType locatorType,
            String locatorValue,
            ElementFingerprint elementFingerprint) {
        
        if (!enabled) {
            return false;
        }
        
        if (locatorType == null || locatorValue == null || locatorValue.isEmpty() || elementFingerprint == null) {
            return false;
        }
        
        LocatorKey key = new LocatorKey(locatorType, locatorValue);
        fingerprintRegistry.put(key, elementFingerprint);
        
        if (autoPersistEnabled) {
            try {
                persistRegistry();
            } catch (IOException e) {
                LOGGER.log(Level.WARNING, "Failed to persist locator registry: " + e.getMessage(), e);
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Registers a temporary element fingerprint.
     * Temporary fingerprints are used during healing attempts and are not persisted.
     * 
     * @param elementId A unique ID for the element
     * @param elementFingerprint The element fingerprint
     * @return true if the registration was successful, false otherwise
     */
    public boolean registerTemporaryFingerprint(String elementId, ElementFingerprint elementFingerprint) {
        if (!enabled) {
            return false;
        }
        
        if (elementId == null || elementId.isEmpty() || elementFingerprint == null) {
            return false;
        }
        
        temporaryFingerprints.put(elementId, elementFingerprint);
        return true;
    }
    
    /**
     * Gets an element fingerprint for a locator.
     * 
     * @param locatorType The locator type
     * @param locatorValue The locator value
     * @return The element fingerprint, or null if not found
     */
    public ElementFingerprint getFingerprint(HealingStrategy.LocatorType locatorType, String locatorValue) {
        if (!enabled || locatorType == null || locatorValue == null || locatorValue.isEmpty()) {
            return null;
        }
        
        LocatorKey key = new LocatorKey(locatorType, locatorValue);
        return fingerprintRegistry.get(key);
    }
    
    /**
     * Gets a temporary element fingerprint.
     * 
     * @param elementId The element ID
     * @return The element fingerprint, or null if not found
     */
    public ElementFingerprint getTemporaryFingerprint(String elementId) {
        if (!enabled || elementId == null || elementId.isEmpty()) {
            return null;
        }
        
        return temporaryFingerprints.get(elementId);
    }
    
    /**
     * Removes a locator from the registry.
     * 
     * @param locatorType The locator type
     * @param locatorValue The locator value
     * @return true if the locator was removed, false otherwise
     */
    public boolean removeLocator(HealingStrategy.LocatorType locatorType, String locatorValue) {
        if (!enabled || locatorType == null || locatorValue == null || locatorValue.isEmpty()) {
            return false;
        }
        
        LocatorKey key = new LocatorKey(locatorType, locatorValue);
        boolean removed = fingerprintRegistry.remove(key) != null;
        
        if (removed && autoPersistEnabled) {
            try {
                persistRegistry();
            } catch (IOException e) {
                LOGGER.log(Level.WARNING, "Failed to persist locator registry: " + e.getMessage(), e);
                return false;
            }
        }
        
        return removed;
    }
    
    /**
     * Removes a temporary element fingerprint.
     * 
     * @param elementId The element ID
     * @return true if the fingerprint was removed, false otherwise
     */
    public boolean removeTemporaryFingerprint(String elementId) {
        if (!enabled || elementId == null || elementId.isEmpty()) {
            return false;
        }
        
        return temporaryFingerprints.remove(elementId) != null;
    }
    
    /**
     * Clears all temporary fingerprints.
     */
    public void clearTemporaryFingerprints() {
        temporaryFingerprints.clear();
    }
    
    /**
     * Updates an element fingerprint for a locator.
     * 
     * @param locatorType The locator type
     * @param locatorValue The locator value
     * @param elementFingerprint The updated element fingerprint
     * @return true if the update was successful, false otherwise
     */
    public boolean updateFingerprint(
            HealingStrategy.LocatorType locatorType,
            String locatorValue,
            ElementFingerprint elementFingerprint) {
        
        return registerFingerprint(locatorType, locatorValue, elementFingerprint);
    }
    
    /**
     * Attempts to heal a broken locator.
     * 
     * @param locatorType The locator type
     * @param locatorValue The locator value
     * @param candidateFingerprints The list of candidate element fingerprints
     * @return The healing result
     */
    public HealingStrategy.HealingResult healLocator(
            HealingStrategy.LocatorType locatorType,
            String locatorValue,
            List<ElementFingerprint> candidateFingerprints) {
        
        if (!enabled) {
            return HealingStrategy.HealingResult.failed("Locator healing is disabled");
        }
        
        if (locatorType == null || locatorValue == null || locatorValue.isEmpty()) {
            return HealingStrategy.HealingResult.failed("Invalid locator provided");
        }
        
        if (candidateFingerprints == null || candidateFingerprints.isEmpty()) {
            return HealingStrategy.HealingResult.failed("No candidate fingerprints provided");
        }
        
        LocatorKey key = new LocatorKey(locatorType, locatorValue);
        ElementFingerprint originalFingerprint = fingerprintRegistry.get(key);
        
        if (originalFingerprint == null) {
            return HealingStrategy.HealingResult.failed("No fingerprint registered for this locator");
        }
        
        // Check if we've already healed this locator and it's still valid
        HealedLocator existingHealed = healedLocators.get(key);
        if (existingHealed != null && !existingHealed.isExpired()) {
            if (loggingEnabled) {
                LOGGER.info("Using existing healed locator for " + key + ": " + existingHealed.getLocatorValue());
            }
            
            return HealingStrategy.HealingResult.success(
                    existingHealed.getLocatorValue(),
                    existingHealed.getConfidenceScore(),
                    existingHealed.getStrategyName(),
                    "Using cached healed locator"
            );
        }
        
        // Track the healing attempt
        totalHealingAttempts.incrementAndGet();
        
        // If we've exceeded the maximum number of healing attempts, give up
        if (existingHealed != null && existingHealed.getAttemptCount() >= maxHealingAttemptsPerLocator) {
            failedHealings.incrementAndGet();
            
            return HealingStrategy.HealingResult.failed(
                    "Maximum healing attempts (" + maxHealingAttemptsPerLocator + ") exceeded for this locator"
            );
        }
        
        // Try each healing strategy in order
        for (HealingStrategy strategy : healingStrategies) {
            HealingStrategy.HealingResult result = strategy.findAlternativeLocator(
                    originalFingerprint, candidateFingerprints, locatorType, locatorValue);
            
            if (result.isSuccessful() && result.getConfidenceScore() >= minimumConfidenceThreshold) {
                // We found a good match
                successfulHealings.incrementAndGet();
                
                // Cache the healed locator
                int attemptCount = existingHealed != null ? existingHealed.getAttemptCount() + 1 : 1;
                healedLocators.put(key, new HealedLocator(
                        result.getHealedLocator(),
                        result.getConfidenceScore(),
                        result.getStrategyName(),
                        attemptCount
                ));
                
                if (loggingEnabled) {
                    LOGGER.info("Successfully healed locator " + key + " to " + result.getHealedLocator() +
                            " with confidence " + result.getConfidenceScore() + " using " + result.getStrategyName());
                }
                
                return result;
            }
        }
        
        // No strategy succeeded
        failedHealings.incrementAndGet();
        
        // Update the attempt count in the cached healed locator
        int attemptCount = existingHealed != null ? existingHealed.getAttemptCount() + 1 : 1;
        if (existingHealed != null) {
            healedLocators.put(key, new HealedLocator(
                    existingHealed.getLocatorValue(),
                    existingHealed.getConfidenceScore(),
                    existingHealed.getStrategyName(),
                    attemptCount
            ));
        }
        
        if (loggingEnabled) {
            LOGGER.warning("Failed to heal locator " + key + " after trying " + healingStrategies.size() + " strategies");
        }
        
        return HealingStrategy.HealingResult.failed(
                "All healing strategies failed for this locator"
        );
    }
    
    /**
     * Gets a healed locator if available.
     * 
     * @param locatorType The locator type
     * @param locatorValue The locator value
     * @return The healed locator, or null if not available
     */
    public String getHealedLocator(HealingStrategy.LocatorType locatorType, String locatorValue) {
        if (!enabled || locatorType == null || locatorValue == null || locatorValue.isEmpty()) {
            return null;
        }
        
        LocatorKey key = new LocatorKey(locatorType, locatorValue);
        HealedLocator healedLocator = healedLocators.get(key);
        
        if (healedLocator != null && !healedLocator.isExpired()) {
            return healedLocator.getLocatorValue();
        }
        
        return null;
    }
    
    /**
     * Removes a healed locator.
     * 
     * @param locatorType The locator type
     * @param locatorValue The locator value
     * @return true if the healed locator was removed, false otherwise
     */
    public boolean removeHealedLocator(HealingStrategy.LocatorType locatorType, String locatorValue) {
        if (!enabled || locatorType == null || locatorValue == null || locatorValue.isEmpty()) {
            return false;
        }
        
        LocatorKey key = new LocatorKey(locatorType, locatorValue);
        return healedLocators.remove(key) != null;
    }
    
    /**
     * Clears all healed locators.
     */
    public void clearHealedLocators() {
        healedLocators.clear();
    }
    
    /**
     * Adds a healing strategy.
     * 
     * @param strategy The healing strategy to add
     * @return true if the strategy was added, false otherwise
     */
    public boolean addHealingStrategy(HealingStrategy strategy) {
        if (strategy == null) {
            return false;
        }
        
        return healingStrategies.add(strategy);
    }
    
    /**
     * Removes a healing strategy.
     * 
     * @param strategyName The name of the strategy to remove
     * @return true if the strategy was removed, false otherwise
     */
    public boolean removeHealingStrategy(String strategyName) {
        if (strategyName == null || strategyName.isEmpty()) {
            return false;
        }
        
        return healingStrategies.removeIf(strategy -> strategyName.equals(strategy.getName()));
    }
    
    /**
     * Sets the healing strategies to use.
     * 
     * @param strategies The list of healing strategies
     */
    public void setHealingStrategies(List<HealingStrategy> strategies) {
        healingStrategies.clear();
        
        if (strategies != null) {
            healingStrategies.addAll(strategies);
        } else {
            // Restore default strategies
            initializeDefaultStrategies();
        }
    }
    
    /**
     * Gets the list of healing strategies.
     * 
     * @return An unmodifiable list of healing strategies
     */
    public List<HealingStrategy> getHealingStrategies() {
        return Collections.unmodifiableList(healingStrategies);
    }
    
    /**
     * Gets the minimum confidence threshold for accepting a healed locator.
     * 
     * @return The minimum confidence threshold
     */
    public double getMinimumConfidenceThreshold() {
        return minimumConfidenceThreshold;
    }
    
    /**
     * Sets the minimum confidence threshold for accepting a healed locator.
     * 
     * @param minimumConfidenceThreshold The minimum confidence threshold (0.0 to 1.0)
     */
    public void setMinimumConfidenceThreshold(double minimumConfidenceThreshold) {
        if (minimumConfidenceThreshold >= 0.0 && minimumConfidenceThreshold <= 1.0) {
            this.minimumConfidenceThreshold = minimumConfidenceThreshold;
        }
    }
    
    /**
     * Gets the maximum number of healing attempts per locator.
     * 
     * @return The maximum number of healing attempts
     */
    public int getMaxHealingAttemptsPerLocator() {
        return maxHealingAttemptsPerLocator;
    }
    
    /**
     * Sets the maximum number of healing attempts per locator.
     * 
     * @param maxHealingAttemptsPerLocator The maximum number of healing attempts
     */
    public void setMaxHealingAttemptsPerLocator(int maxHealingAttemptsPerLocator) {
        if (maxHealingAttemptsPerLocator > 0) {
            this.maxHealingAttemptsPerLocator = maxHealingAttemptsPerLocator;
        }
    }
    
    /**
     * Checks if the service is enabled.
     * 
     * @return true if the service is enabled, false otherwise
     */
    public boolean isEnabled() {
        return enabled;
    }
    
    /**
     * Enables or disables the service.
     * 
     * @param enabled true to enable the service, false to disable it
     */
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
    
    /**
     * Checks if logging is enabled.
     * 
     * @return true if logging is enabled, false otherwise
     */
    public boolean isLoggingEnabled() {
        return loggingEnabled;
    }
    
    /**
     * Enables or disables logging.
     * 
     * @param loggingEnabled true to enable logging, false to disable it
     */
    public void setLoggingEnabled(boolean loggingEnabled) {
        this.loggingEnabled = loggingEnabled;
    }
    
    /**
     * Checks if automatic registry persistence is enabled.
     * 
     * @return true if automatic persistence is enabled, false otherwise
     */
    public boolean isAutoPersistEnabled() {
        return autoPersistEnabled;
    }
    
    /**
     * Enables or disables automatic registry persistence.
     * 
     * @param autoPersistEnabled true to enable automatic persistence, false to disable it
     */
    public void setAutoPersistEnabled(boolean autoPersistEnabled) {
        this.autoPersistEnabled = autoPersistEnabled;
    }
    
    /**
     * Checks if automatic fingerprint updates are enabled.
     * 
     * @return true if automatic updates are enabled, false otherwise
     */
    public boolean isAutoUpdateEnabled() {
        return autoUpdateEnabled;
    }
    
    /**
     * Enables or disables automatic fingerprint updates.
     * 
     * @param autoUpdateEnabled true to enable automatic updates, false to disable them
     */
    public void setAutoUpdateEnabled(boolean autoUpdateEnabled) {
        this.autoUpdateEnabled = autoUpdateEnabled;
    }
    
    /**
     * Gets the total number of healing attempts.
     * 
     * @return The total number of healing attempts
     */
    public int getTotalHealingAttempts() {
        return totalHealingAttempts.get();
    }
    
    /**
     * Gets the number of successful healings.
     * 
     * @return The number of successful healings
     */
    public int getSuccessfulHealings() {
        return successfulHealings.get();
    }
    
    /**
     * Gets the number of failed healings.
     * 
     * @return The number of failed healings
     */
    public int getFailedHealings() {
        return failedHealings.get();
    }
    
    /**
     * Gets the success rate of healing attempts.
     * 
     * @return The success rate (0.0 to 1.0)
     */
    public double getSuccessRate() {
        int total = totalHealingAttempts.get();
        if (total == 0) {
            return 0.0;
        }
        
        return (double) successfulHealings.get() / total;
    }
    
    /**
     * Gets the number of registered fingerprints.
     * 
     * @return The number of registered fingerprints
     */
    public int getRegisteredFingerprintCount() {
        return fingerprintRegistry.size();
    }
    
    /**
     * Gets the number of healed locators.
     * 
     * @return The number of healed locators
     */
    public int getHealedLocatorCount() {
        return healedLocators.size();
    }
    
    /**
     * Gets the number of active healed locators (not expired).
     * 
     * @return The number of active healed locators
     */
    public int getActiveHealedLocatorCount() {
        return (int) healedLocators.values().stream()
                .filter(healedLocator -> !healedLocator.isExpired())
                .count();
    }
    
    /**
     * Gets the number of temporary fingerprints.
     * 
     * @return The number of temporary fingerprints
     */
    public int getTemporaryFingerprintCount() {
        return temporaryFingerprints.size();
    }
    
    /**
     * Persists the registry to disk.
     * 
     * @throws IOException If an I/O error occurs
     */
    public void persistRegistry() throws IOException {
        Path registryFile = Paths.get(registryFilePath);
        Path registryDir = registryFile.getParent();
        
        if (registryDir != null && !Files.exists(registryDir)) {
            Files.createDirectories(registryDir);
        }
        
        // Create a backup of the existing registry file
        if (Files.exists(registryFile)) {
            Path backupFile = Paths.get(registryFilePath + ".bak");
            Files.copy(registryFile, backupFile, StandardCopyOption.REPLACE_EXISTING);
        }
        
        // Persist the registry
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(registryFilePath))) {
            oos.writeObject(fingerprintRegistry);
            oos.writeObject(healedLocators);
        }
    }
    
    /**
     * Restores the registry from disk.
     * 
     * @throws IOException If an I/O error occurs
     * @throws ClassNotFoundException If the registry classes cannot be found
     */
    @SuppressWarnings("unchecked")
    public void restoreRegistry() throws IOException, ClassNotFoundException {
        File registryFile = new File(registryFilePath);
        
        if (!registryFile.exists()) {
            return;
        }
        
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(registryFile))) {
            Map<LocatorKey, ElementFingerprint> restoredFingerprints = 
                    (Map<LocatorKey, ElementFingerprint>) ois.readObject();
            Map<LocatorKey, HealedLocator> restoredHealedLocators =
                    (Map<LocatorKey, HealedLocator>) ois.readObject();
            
            fingerprintRegistry.clear();
            fingerprintRegistry.putAll(restoredFingerprints);
            
            healedLocators.clear();
            healedLocators.putAll(restoredHealedLocators);
            
            if (loggingEnabled) {
                LOGGER.info("Restored " + fingerprintRegistry.size() + " fingerprints and " + 
                           healedLocators.size() + " healed locators from registry");
            }
        }
    }
    
    /**
     * Clears the registry.
     * 
     * @return true if the registry was cleared, false otherwise
     */
    public boolean clearRegistry() {
        fingerprintRegistry.clear();
        healedLocators.clear();
        temporaryFingerprints.clear();
        
        if (autoPersistEnabled) {
            try {
                persistRegistry();
            } catch (IOException e) {
                LOGGER.log(Level.WARNING, "Failed to persist empty registry: " + e.getMessage(), e);
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Gets a list of healed locators with their details.
     * 
     * @return A list of healed locator entries
     */
    public List<HealedLocatorEntry> getHealedLocatorEntries() {
        return healedLocators.entrySet().stream()
                .map(entry -> new HealedLocatorEntry(
                        entry.getKey().getLocatorType(),
                        entry.getKey().getLocatorValue(),
                        entry.getValue().getLocatorValue(),
                        entry.getValue().getConfidenceScore(),
                        entry.getValue().getStrategyName(),
                        entry.getValue().getTimestamp(),
                        entry.getValue().getAttemptCount(),
                        entry.getValue().isExpired()
                ))
                .sorted(Comparator.comparing(HealedLocatorEntry::getTimestamp).reversed())
                .collect(Collectors.toList());
    }
    
    /**
     * Gets a list of registered locators with their fingerprint details.
     * 
     * @return A list of registered locator entries
     */
    public List<RegisteredLocatorEntry> getRegisteredLocatorEntries() {
        return fingerprintRegistry.entrySet().stream()
                .map(entry -> new RegisteredLocatorEntry(
                        entry.getKey().getLocatorType(),
                        entry.getKey().getLocatorValue(),
                        entry.getValue().getTagName(),
                        entry.getValue().getElementId(),
                        entry.getValue().getTextContent(),
                        entry.getValue().getClasses(),
                        entry.getValue().getAttributes()
                ))
                .sorted(Comparator.comparing(RegisteredLocatorEntry::getLocatorValue))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets healing statistics for each healing strategy.
     * 
     * @return A map of strategy names to healing statistics
     */
    public Map<String, HealingStatistics> getStrategyStatistics() {
        Map<String, HealingStatistics> stats = new HashMap<>();
        
        // Initialize statistics for each strategy
        for (HealingStrategy strategy : healingStrategies) {
            stats.put(strategy.getName(), new HealingStatistics());
        }
        
        // Collect statistics from healed locators
        for (HealedLocator healedLocator : healedLocators.values()) {
            String strategyName = healedLocator.getStrategyName();
            if (strategyName != null && stats.containsKey(strategyName)) {
                HealingStatistics strategyStat = stats.get(strategyName);
                strategyStat.incrementTotalAttempts();
                strategyStat.incrementSuccessfulAttempts();
                strategyStat.addConfidenceScore(healedLocator.getConfidenceScore());
            }
        }
        
        return stats;
    }
    
    /**
     * Represents a key for locator lookups.
     */
    public static class LocatorKey implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        private final HealingStrategy.LocatorType locatorType;
        private final String locatorValue;
        
        /**
         * Creates a new locator key.
         * 
         * @param locatorType The locator type
         * @param locatorValue The locator value
         */
        public LocatorKey(HealingStrategy.LocatorType locatorType, String locatorValue) {
            this.locatorType = locatorType;
            this.locatorValue = locatorValue;
        }
        
        /**
         * Gets the locator type.
         * 
         * @return The locator type
         */
        public HealingStrategy.LocatorType getLocatorType() {
            return locatorType;
        }
        
        /**
         * Gets the locator value.
         * 
         * @return The locator value
         */
        public String getLocatorValue() {
            return locatorValue;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null || getClass() != obj.getClass()) {
                return false;
            }
            LocatorKey other = (LocatorKey) obj;
            return locatorType == other.locatorType && Objects.equals(locatorValue, other.locatorValue);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(locatorType, locatorValue);
        }
        
        @Override
        public String toString() {
            return locatorType + ":" + locatorValue;
        }
    }
    
    /**
     * Represents a healed locator with metadata.
     */
    public static class HealedLocator implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        // Expiration time in milliseconds (default: 24 hours)
        private static final long DEFAULT_EXPIRATION_TIME = 24 * 60 * 60 * 1000;
        
        private final String locatorValue;
        private final double confidenceScore;
        private final String strategyName;
        private final long timestamp;
        private final int attemptCount;
        private final long expirationTime;
        
        /**
         * Creates a new healed locator with default expiration time.
         * 
         * @param locatorValue The healed locator value
         * @param confidenceScore The confidence score
         * @param strategyName The name of the healing strategy used
         * @param attemptCount The number of healing attempts
         */
        public HealedLocator(String locatorValue, double confidenceScore, String strategyName, int attemptCount) {
            this(locatorValue, confidenceScore, strategyName, attemptCount, DEFAULT_EXPIRATION_TIME);
        }
        
        /**
         * Creates a new healed locator with custom expiration time.
         * 
         * @param locatorValue The healed locator value
         * @param confidenceScore The confidence score
         * @param strategyName The name of the healing strategy used
         * @param attemptCount The number of healing attempts
         * @param expirationTime The expiration time in milliseconds
         */
        public HealedLocator(String locatorValue, double confidenceScore, String strategyName, 
                             int attemptCount, long expirationTime) {
            this.locatorValue = locatorValue;
            this.confidenceScore = confidenceScore;
            this.strategyName = strategyName;
            this.timestamp = System.currentTimeMillis();
            this.attemptCount = attemptCount;
            this.expirationTime = expirationTime;
        }
        
        /**
         * Gets the healed locator value.
         * 
         * @return The locator value
         */
        public String getLocatorValue() {
            return locatorValue;
        }
        
        /**
         * Gets the confidence score.
         * 
         * @return The confidence score
         */
        public double getConfidenceScore() {
            return confidenceScore;
        }
        
        /**
         * Gets the name of the healing strategy used.
         * 
         * @return The strategy name
         */
        public String getStrategyName() {
            return strategyName;
        }
        
        /**
         * Gets the timestamp when the locator was healed.
         * 
         * @return The timestamp in milliseconds
         */
        public long getTimestamp() {
            return timestamp;
        }
        
        /**
         * Gets the number of healing attempts.
         * 
         * @return The attempt count
         */
        public int getAttemptCount() {
            return attemptCount;
        }
        
        /**
         * Gets the expiration time.
         * 
         * @return The expiration time in milliseconds
         */
        public long getExpirationTime() {
            return expirationTime;
        }
        
        /**
         * Checks if the healed locator has expired.
         * 
         * @return true if the locator has expired, false otherwise
         */
        public boolean isExpired() {
            return System.currentTimeMillis() > timestamp + expirationTime;
        }
        
        @Override
        public String toString() {
            return "HealedLocator{" +
                    "locatorValue='" + locatorValue + '\'' +
                    ", confidenceScore=" + confidenceScore +
                    ", strategyName='" + strategyName + '\'' +
                    ", timestamp=" + timestamp +
                    ", attemptCount=" + attemptCount +
                    ", expired=" + isExpired() +
                    '}';
        }
    }
    
    /**
     * Represents an entry in the healed locator registry.
     */
    public static class HealedLocatorEntry implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        private final HealingStrategy.LocatorType originalLocatorType;
        private final String originalLocatorValue;
        private final String healedLocatorValue;
        private final double confidenceScore;
        private final String strategyName;
        private final long timestamp;
        private final int attemptCount;
        private final boolean expired;
        
        /**
         * Creates a new healed locator entry.
         * 
         * @param originalLocatorType The original locator type
         * @param originalLocatorValue The original locator value
         * @param healedLocatorValue The healed locator value
         * @param confidenceScore The confidence score
         * @param strategyName The name of the healing strategy used
         * @param timestamp The timestamp when the locator was healed
         * @param attemptCount The number of healing attempts
         * @param expired Whether the healed locator has expired
         */
        public HealedLocatorEntry(
                HealingStrategy.LocatorType originalLocatorType,
                String originalLocatorValue,
                String healedLocatorValue,
                double confidenceScore,
                String strategyName,
                long timestamp,
                int attemptCount,
                boolean expired) {
            this.originalLocatorType = originalLocatorType;
            this.originalLocatorValue = originalLocatorValue;
            this.healedLocatorValue = healedLocatorValue;
            this.confidenceScore = confidenceScore;
            this.strategyName = strategyName;
            this.timestamp = timestamp;
            this.attemptCount = attemptCount;
            this.expired = expired;
        }
        
        /**
         * Gets the original locator type.
         * 
         * @return The original locator type
         */
        public HealingStrategy.LocatorType getOriginalLocatorType() {
            return originalLocatorType;
        }
        
        /**
         * Gets the original locator value.
         * 
         * @return The original locator value
         */
        public String getOriginalLocatorValue() {
            return originalLocatorValue;
        }
        
        /**
         * Gets the healed locator value.
         * 
         * @return The healed locator value
         */
        public String getHealedLocatorValue() {
            return healedLocatorValue;
        }
        
        /**
         * Gets the confidence score.
         * 
         * @return The confidence score
         */
        public double getConfidenceScore() {
            return confidenceScore;
        }
        
        /**
         * Gets the name of the healing strategy used.
         * 
         * @return The strategy name
         */
        public String getStrategyName() {
            return strategyName;
        }
        
        /**
         * Gets the timestamp when the locator was healed.
         * 
         * @return The timestamp in milliseconds
         */
        public long getTimestamp() {
            return timestamp;
        }
        
        /**
         * Gets the number of healing attempts.
         * 
         * @return The attempt count
         */
        public int getAttemptCount() {
            return attemptCount;
        }
        
        /**
         * Checks if the healed locator has expired.
         * 
         * @return true if the locator has expired, false otherwise
         */
        public boolean isExpired() {
            return expired;
        }
        
        @Override
        public String toString() {
            return "HealedLocatorEntry{" +
                    "originalLocatorType=" + originalLocatorType +
                    ", originalLocatorValue='" + originalLocatorValue + '\'' +
                    ", healedLocatorValue='" + healedLocatorValue + '\'' +
                    ", confidenceScore=" + confidenceScore +
                    ", strategyName='" + strategyName + '\'' +
                    ", timestamp=" + timestamp +
                    ", attemptCount=" + attemptCount +
                    ", expired=" + expired +
                    '}';
        }
    }
    
    /**
     * Represents an entry in the registered locator registry.
     */
    public static class RegisteredLocatorEntry implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        private final HealingStrategy.LocatorType locatorType;
        private final String locatorValue;
        private final String tagName;
        private final String elementId;
        private final String textContent;
        private final List<String> classes;
        private final Map<String, String> attributes;
        
        /**
         * Creates a new registered locator entry.
         * 
         * @param locatorType The locator type
         * @param locatorValue The locator value
         * @param tagName The tag name
         * @param elementId The element ID
         * @param textContent The text content
         * @param classes The CSS classes
         * @param attributes The element attributes
         */
        public RegisteredLocatorEntry(
                HealingStrategy.LocatorType locatorType,
                String locatorValue,
                String tagName,
                String elementId,
                String textContent,
                List<String> classes,
                Map<String, String> attributes) {
            this.locatorType = locatorType;
            this.locatorValue = locatorValue;
            this.tagName = tagName;
            this.elementId = elementId;
            this.textContent = textContent;
            this.classes = classes != null ? new ArrayList<>(classes) : Collections.emptyList();
            this.attributes = attributes != null ? new HashMap<>(attributes) : Collections.emptyMap();
        }
        
        /**
         * Gets the locator type.
         * 
         * @return The locator type
         */
        public HealingStrategy.LocatorType getLocatorType() {
            return locatorType;
        }
        
        /**
         * Gets the locator value.
         * 
         * @return The locator value
         */
        public String getLocatorValue() {
            return locatorValue;
        }
        
        /**
         * Gets the tag name.
         * 
         * @return The tag name
         */
        public String getTagName() {
            return tagName;
        }
        
        /**
         * Gets the element ID.
         * 
         * @return The element ID
         */
        public String getElementId() {
            return elementId;
        }
        
        /**
         * Gets the text content.
         * 
         * @return The text content
         */
        public String getTextContent() {
            return textContent;
        }
        
        /**
         * Gets the CSS classes.
         * 
         * @return An unmodifiable list of CSS classes
         */
        public List<String> getClasses() {
            return Collections.unmodifiableList(classes);
        }
        
        /**
         * Gets the element attributes.
         * 
         * @return An unmodifiable map of attribute names to values
         */
        public Map<String, String> getAttributes() {
            return Collections.unmodifiableMap(attributes);
        }
        
        @Override
        public String toString() {
            return "RegisteredLocatorEntry{" +
                    "locatorType=" + locatorType +
                    ", locatorValue='" + locatorValue + '\'' +
                    ", tagName='" + tagName + '\'' +
                    ", elementId='" + elementId + '\'' +
                    ", textContent='" + (textContent != null && textContent.length() > 20
                            ? textContent.substring(0, 20) + "..." : textContent) + '\'' +
                    ", classes=" + classes +
                    ", attributeCount=" + attributes.size() +
                    '}';
        }
    }
    
    /**
     * Statistics for healing strategies.
     */
    public static class HealingStatistics implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        private int totalAttempts;
        private int successfulAttempts;
        private double totalConfidenceScore;
        
        /**
         * Creates new healing statistics with zero values.
         */
        public HealingStatistics() {
            this.totalAttempts = 0;
            this.successfulAttempts = 0;
            this.totalConfidenceScore = 0.0;
        }
        
        /**
         * Increments the total attempt count.
         */
        public void incrementTotalAttempts() {
            totalAttempts++;
        }
        
        /**
         * Increments the successful attempt count.
         */
        public void incrementSuccessfulAttempts() {
            successfulAttempts++;
        }
        
        /**
         * Adds a confidence score to the total.
         * 
         * @param score The confidence score to add
         */
        public void addConfidenceScore(double score) {
            totalConfidenceScore += score;
        }
        
        /**
         * Gets the total number of healing attempts.
         * 
         * @return The total number of attempts
         */
        public int getTotalAttempts() {
            return totalAttempts;
        }
        
        /**
         * Gets the number of successful healing attempts.
         * 
         * @return The number of successful attempts
         */
        public int getSuccessfulAttempts() {
            return successfulAttempts;
        }
        
        /**
         * Gets the number of failed healing attempts.
         * 
         * @return The number of failed attempts
         */
        public int getFailedAttempts() {
            return totalAttempts - successfulAttempts;
        }
        
        /**
         * Gets the success rate of healing attempts.
         * 
         * @return The success rate (0.0 to 1.0)
         */
        public double getSuccessRate() {
            if (totalAttempts == 0) {
                return 0.0;
            }
            
            return (double) successfulAttempts / totalAttempts;
        }
        
        /**
         * Gets the average confidence score of successful healings.
         * 
         * @return The average confidence score
         */
        public double getAverageConfidenceScore() {
            if (successfulAttempts == 0) {
                return 0.0;
            }
            
            return totalConfidenceScore / successfulAttempts;
        }
        
        @Override
        public String toString() {
            return "HealingStatistics{" +
                    "totalAttempts=" + totalAttempts +
                    ", successfulAttempts=" + successfulAttempts +
                    ", successRate=" + String.format("%.2f", getSuccessRate()) +
                    ", averageConfidenceScore=" + String.format("%.2f", getAverageConfidenceScore()) +
                    '}';
        }
    }
    
    /**
     * Builder class for creating LocatorHealingService instances.
     */
    public static class Builder {
        private String registryFilePath = "./locator-registry.dat";
        private final List<HealingStrategy> healingStrategies = new ArrayList<>();
        private double minimumConfidenceThreshold = 0.7;
        private int maxHealingAttemptsPerLocator = 5;
        private boolean enabled = true;
        private boolean loggingEnabled = true;
        private boolean autoPersistEnabled = true;
        private boolean autoUpdateEnabled = true;
        
        /**
         * Creates a new builder with default settings.
         */
        public Builder() {
            // Add default healing strategies
            healingStrategies.add(new AttributeHealingStrategy());
            // Other strategies will be added as they are implemented
        }
        
        /**
         * Sets the registry file path.
         * 
         * @param registryFilePath The path to the registry file
         * @return This builder instance
         */
        public Builder withRegistryFilePath(String registryFilePath) {
            if (registryFilePath != null && !registryFilePath.isEmpty()) {
                this.registryFilePath = registryFilePath;
            }
            return this;
        }
        
        /**
         * Adds a healing strategy.
         * 
         * @param strategy The healing strategy to add
         * @return This builder instance
         */
        public Builder withHealingStrategy(HealingStrategy strategy) {
            if (strategy != null) {
                healingStrategies.add(strategy);
            }
            return this;
        }
        
        /**
         * Sets the healing strategies to use.
         * 
         * @param strategies The list of healing strategies
         * @return This builder instance
         */
        public Builder withHealingStrategies(List<HealingStrategy> strategies) {
            healingStrategies.clear();
            if (strategies != null) {
                healingStrategies.addAll(strategies);
            }
            return this;
        }
        
        /**
         * Sets the minimum confidence threshold for accepting a healed locator.
         * 
         * @param minimumConfidenceThreshold The minimum confidence threshold (0.0 to 1.0)
         * @return This builder instance
         */
        public Builder withMinimumConfidenceThreshold(double minimumConfidenceThreshold) {
            if (minimumConfidenceThreshold >= 0.0 && minimumConfidenceThreshold <= 1.0) {
                this.minimumConfidenceThreshold = minimumConfidenceThreshold;
            }
            return this;
        }
        
        /**
         * Sets the maximum number of healing attempts per locator.
         * 
         * @param maxHealingAttemptsPerLocator The maximum number of healing attempts
         * @return This builder instance
         */
        public Builder withMaxHealingAttemptsPerLocator(int maxHealingAttemptsPerLocator) {
            if (maxHealingAttemptsPerLocator > 0) {
                this.maxHealingAttemptsPerLocator = maxHealingAttemptsPerLocator;
            }
            return this;
        }
        
        /**
         * Enables or disables the service.
         * 
         * @param enabled true to enable the service, false to disable it
         * @return This builder instance
         */
        public Builder withEnabled(boolean enabled) {
            this.enabled = enabled;
            return this;
        }
        
        /**
         * Enables or disables logging.
         * 
         * @param loggingEnabled true to enable logging, false to disable it
         * @return This builder instance
         */
        public Builder withLoggingEnabled(boolean loggingEnabled) {
            this.loggingEnabled = loggingEnabled;
            return this;
        }
        
        /**
         * Enables or disables automatic registry persistence.
         * 
         * @param autoPersistEnabled true to enable automatic persistence, false to disable it
         * @return This builder instance
         */
        public Builder withAutoPersistEnabled(boolean autoPersistEnabled) {
            this.autoPersistEnabled = autoPersistEnabled;
            return this;
        }
        
        /**
         * Enables or disables automatic fingerprint updates.
         * 
         * @param autoUpdateEnabled true to enable automatic updates, false to disable them
         * @return This builder instance
         */
        public Builder withAutoUpdateEnabled(boolean autoUpdateEnabled) {
            this.autoUpdateEnabled = autoUpdateEnabled;
            return this;
        }
        
        /**
         * Builds a LocatorHealingService from the current builder state.
         * 
         * @return The locator healing service
         */
        public LocatorHealingService build() {
            LocatorHealingService service = new LocatorHealingService(registryFilePath);
            
            service.setHealingStrategies(healingStrategies);
            service.setMinimumConfidenceThreshold(minimumConfidenceThreshold);
            service.setMaxHealingAttemptsPerLocator(maxHealingAttemptsPerLocator);
            service.setEnabled(enabled);
            service.setLoggingEnabled(loggingEnabled);
            service.setAutoPersistEnabled(autoPersistEnabled);
            service.setAutoUpdateEnabled(autoUpdateEnabled);
            
            return service;
        }
    }
    
    /**
     * Creates a builder for constructing a customized LocatorHealingService.
     * 
     * @return A new builder instance
     */
    public static Builder builder() {
        return new Builder();
    }
}

TextHealingStrategy.java
-----------------------------------

package com.cstestforge.framework.core.selfhealing;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * A healing strategy based on element text content.
 * This strategy focuses on finding elements with similar text content
 * when the original locator fails.
 */
public class TextHealingStrategy implements HealingStrategy {

    private static final long serialVersionUID = 1L;
    
    // The default minimum score threshold for candidate acceptance
    private static final double DEFAULT_MINIMUM_SCORE = 0.75;
    
    // The similarity scorer used for comparing elements
    private final SimilarityScorer similarityScorer;
    
    // The minimum score required for a candidate to be considered
    private final double minimumScore;
    
    // Flag to enable fuzzy text matching
    private final boolean fuzzyMatching;
    
    // Flag to enable case-sensitive matching
    private final boolean caseSensitive;
    
    // Flag to normalize whitespace in text
    private final boolean normalizeWhitespace;
    
    // Flag to enable token-based matching (words rather than exact string)
    private final boolean tokenBasedMatching;
    
    // Flag to enable proximity-based boosting (elements closer to original)
    private final boolean proximityBoosting;
    
    // Flag to prioritize visible elements
    private final boolean prioritizeVisibleElements;
    
    // Flag to enable parent/child text context consideration
    private final boolean considerTextContext;
    
    // Maximum text length difference percentage allowed (0-100)
    private final int maxTextLengthDifferencePercent;
    
    // Minimum text length required for consideration
    private final int minTextLength;
    
    // List of regular expressions to filter/ignore text patterns
    private final List<Pattern> textFilterPatterns;
    
    /**
     * Creates a new text healing strategy with default settings.
     */
    public TextHealingStrategy() {
        this.similarityScorer = SimilarityScorer.createTextOptimizedScorer();
        this.minimumScore = DEFAULT_MINIMUM_SCORE;
        this.fuzzyMatching = true;
        this.caseSensitive = false;
        this.normalizeWhitespace = true;
        this.tokenBasedMatching = true;
        this.proximityBoosting = true;
        this.prioritizeVisibleElements = true;
        this.considerTextContext = true;
        this.maxTextLengthDifferencePercent = 30;
        this.minTextLength = 3;
        this.textFilterPatterns = new ArrayList<>();
    }
    
    /**
     * Creates a new text healing strategy with the specified settings.
     * 
     * @param similarityScorer The similarity scorer to use
     * @param minimumScore The minimum score required for a candidate
     * @param fuzzyMatching Whether to enable fuzzy text matching
     * @param caseSensitive Whether to enable case-sensitive matching
     * @param normalizeWhitespace Whether to normalize whitespace in text
     * @param tokenBasedMatching Whether to enable token-based matching
     * @param proximityBoosting Whether to enable proximity-based boosting
     * @param prioritizeVisibleElements Whether to prioritize visible elements
     * @param considerTextContext Whether to consider parent/child text context
     * @param maxTextLengthDifferencePercent The maximum text length difference percentage allowed
     * @param minTextLength The minimum text length required for consideration
     * @param textFilterPatterns List of patterns to filter/ignore
     */
    public TextHealingStrategy(
            SimilarityScorer similarityScorer,
            double minimumScore,
            boolean fuzzyMatching,
            boolean caseSensitive,
            boolean normalizeWhitespace,
            boolean tokenBasedMatching,
            boolean proximityBoosting,
            boolean prioritizeVisibleElements,
            boolean considerTextContext,
            int maxTextLengthDifferencePercent,
            int minTextLength,
            List<Pattern> textFilterPatterns) {
        this.similarityScorer = similarityScorer != null ? similarityScorer : SimilarityScorer.createTextOptimizedScorer();
        this.minimumScore = minimumScore >= 0.0 && minimumScore <= 1.0 ? minimumScore : DEFAULT_MINIMUM_SCORE;
        this.fuzzyMatching = fuzzyMatching;
        this.caseSensitive = caseSensitive;
        this.normalizeWhitespace = normalizeWhitespace;
        this.tokenBasedMatching = tokenBasedMatching;
        this.proximityBoosting = proximityBoosting;
        this.prioritizeVisibleElements = prioritizeVisibleElements;
        this.considerTextContext = considerTextContext;
        this.maxTextLengthDifferencePercent = Math.max(0, Math.min(100, maxTextLengthDifferencePercent));
        this.minTextLength = Math.max(0, minTextLength);
        this.textFilterPatterns = textFilterPatterns != null ? new ArrayList<>(textFilterPatterns) : new ArrayList<>();
    }
    
    @Override
    public String getName() {
        return "Text Healing Strategy";
    }
    
    @Override
    public String getDescription() {
        return "A healing strategy that focuses on finding elements with similar text content " +
               "when the original locator fails. This strategy compares element text content " +
               "and considers various text matching techniques to identify potential matches.";
    }
    
    @Override
    public HealingResult findAlternativeLocator(
            ElementFingerprint originalElement,
            List<ElementFingerprint> candidates,
            LocatorType locatorType,
            String originalLocator) {
        
        if (originalElement == null || candidates == null || candidates.isEmpty()) {
            return HealingResult.failed("No valid input provided");
        }
        
        String originalText = originalElement.getTextContent();
        if (originalText == null || originalText.isEmpty() || originalText.length() < minTextLength) {
            return HealingResult.failed("Original element has no valid text content or text is too short");
        }
        
        // Normalize the original text if configured
        String normalizedOriginalText = normalizeText(originalText);
        if (normalizedOriginalText.isEmpty() || normalizedOriginalText.length() < minTextLength) {
            return HealingResult.failed("Normalized original text is too short");
        }
        
        // Filter out candidates with invalid text
        List<ElementFingerprint> textCandidates = candidates.stream()
                .filter(candidate -> {
                    String candidateText = candidate.getTextContent();
                    if (candidateText == null || candidateText.isEmpty()) {
                        return false;
                    }
                    
                    String normalizedCandidateText = normalizeText(candidateText);
                    if (normalizedCandidateText.isEmpty()) {
                        return false;
                    }
                    
                    // Check text length difference if configured
                    if (maxTextLengthDifferencePercent < 100) {
                        int originalLen = normalizedOriginalText.length();
                        int candidateLen = normalizedCandidateText.length();
                        int maxLen = Math.max(originalLen, candidateLen);
                        int minLen = Math.min(originalLen, candidateLen);
                        
                        if (maxLen > 0) {
                            double difference = 100.0 - (minLen * 100.0 / maxLen);
                            if (difference > maxTextLengthDifferencePercent) {
                                return false;
                            }
                        }
                    }
                    
                    return true;
                })
                .collect(Collectors.toList());
        
        if (textCandidates.isEmpty()) {
            return HealingResult.failed("No candidates with valid text content found");
        }
        
        // Score candidates based on text similarity
        List<ScoredCandidate> scoredCandidates = textCandidates.stream()
                .map(candidate -> {
                    double score = calculateTextSimilarity(originalElement, candidate);
                    return new ScoredCandidate(candidate, score);
                })
                .filter(scoredCandidate -> scoredCandidate.getScore() >= minimumScore)
                .sorted(Comparator.comparing(ScoredCandidate::getScore).reversed())
                .collect(Collectors.toList());
        
        if (scoredCandidates.isEmpty()) {
            return HealingResult.failed("No candidates with sufficient text similarity found");
        }
        
        // Select the best candidate
        ScoredCandidate bestCandidate = scoredCandidates.get(0);
        
        // Generate a new locator based on the best candidate
        String healedLocator = generateLocatorFromCandidate(
                bestCandidate.getCandidate(),
                locatorType != null ? locatorType : inferLocatorType(originalLocator)
        );
        
        if (healedLocator == null || healedLocator.isEmpty()) {
            return HealingResult.failed("Could not generate a valid locator from the best candidate");
        }
        
        return HealingResult.success(
                healedLocator,
                bestCandidate.getScore(),
                getName(),
                "Found alternative locator by text matching with score " + bestCandidate.getScore()
        );
    }
    
    /**
     * Calculates the text similarity between two element fingerprints.
     * 
     * @param originalElement The original element fingerprint
     * @param candidateElement The candidate element fingerprint
     * @return The text similarity score (0.0 to 1.0)
     */
    private double calculateTextSimilarity(ElementFingerprint originalElement, ElementFingerprint candidateElement) {
        String originalText = originalElement.getTextContent();
        String candidateText = candidateElement.getTextContent();
        
        if (originalText == null || candidateText == null) {
            return 0.0;
        }
        
        // Normalize both texts
        String normalizedOriginalText = normalizeText(originalText);
        String normalizedCandidateText = normalizeText(candidateText);
        
        if (normalizedOriginalText.isEmpty() || normalizedCandidateText.isEmpty()) {
            return 0.0;
        }
        
        // Check for exact match (case-sensitive or insensitive)
        if (!fuzzyMatching) {
            if (caseSensitive) {
                return normalizedOriginalText.equals(normalizedCandidateText) ? 1.0 : 0.0;
            } else {
                return normalizedOriginalText.equalsIgnoreCase(normalizedCandidateText) ? 1.0 : 0.0;
            }
        }
        
        // Exact match still gets highest score
        if ((caseSensitive && normalizedOriginalText.equals(normalizedCandidateText)) ||
            (!caseSensitive && normalizedOriginalText.equalsIgnoreCase(normalizedCandidateText))) {
            return 1.0;
        }
        
        double similarityScore = 0.0;
        
        // Calculate string similarity
        double stringSimilarity = calculateStringSimilarity(normalizedOriginalText, normalizedCandidateText);
        
        // Calculate token-based similarity if enabled
        double tokenSimilarity = 0.0;
        if (tokenBasedMatching) {
            tokenSimilarity = calculateTokenSimilarity(normalizedOriginalText, normalizedCandidateText);
        }
        
        // Calculate context similarity if enabled
        double contextSimilarity = 0.0;
        if (considerTextContext) {
            contextSimilarity = calculateContextSimilarity(originalElement, candidateElement);
        }
        
        // Calculate position proximity boost if enabled
        double proximityBoost = 0.0;
        if (proximityBoosting) {
            proximityBoost = calculateProximityBoost(originalElement, candidateElement);
        }
        
        // Calculate visibility boost if enabled
        double visibilityBoost = 0.0;
        if (prioritizeVisibleElements) {
            visibilityBoost = calculateVisibilityBoost(candidateElement);
        }
        
        // Combine all factors with appropriate weights
        similarityScore = stringSimilarity * 0.5 +
                          (tokenBasedMatching ? tokenSimilarity * 0.3 : 0.0) +
                          (considerTextContext ? contextSimilarity * 0.1 : 0.0) +
                          (proximityBoosting ? proximityBoost * 0.05 : 0.0) +
                          (prioritizeVisibleElements ? visibilityBoost * 0.05 : 0.0);
        
        return similarityScore;
    }
    
    /**
     * Normalizes text for comparison.
     * 
     * @param text The text to normalize
     * @return The normalized text
     */
    private String normalizeText(String text) {
        if (text == null) {
            return "";
        }
        
        // Apply text filters
        String filteredText = text;
        for (Pattern pattern : textFilterPatterns) {
            filteredText = pattern.matcher(filteredText).replaceAll("");
        }
        
        if (normalizeWhitespace) {
            // Trim and normalize whitespace
            filteredText = filteredText.trim().replaceAll("\\s+", " ");
        }
        
        if (!caseSensitive) {
            // Convert to lowercase for case-insensitive comparison
            filteredText = filteredText.toLowerCase();
        }
        
        return filteredText;
    }
    
    /**
     * Calculates string similarity using Levenshtein distance.
     * 
     * @param text1 The first text
     * @param text2 The second text
     * @return The similarity score (0.0 to 1.0)
     */
    private double calculateStringSimilarity(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0.0;
        }
        
        if (text1.equals(text2)) {
            return 1.0;
        }
        
        if (text1.isEmpty() || text2.isEmpty()) {
            return 0.0;
        }
        
        // Calculate Levenshtein distance
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        
        for (int i = 0; i <= text1.length(); i++) {
            dp[i][0] = i;
        }
        
        for (int j = 0; j <= text2.length(); j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                int cost = (text1.charAt(i - 1) == text2.charAt(j - 1)) ? 0 : 1;
                dp[i][j] = Math.min(
                        Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1),
                        dp[i - 1][j - 1] + cost
                );
            }
        }
        
        int distance = dp[text1.length()][text2.length()];
        int maxLength = Math.max(text1.length(), text2.length());
        
        // Convert distance to similarity
        return 1.0 - (double) distance / maxLength;
    }
    
    /**
     * Calculates token-based similarity using Jaccard similarity.
     * 
     * @param text1 The first text
     * @param text2 The second text
     * @return The token similarity score (0.0 to 1.0)
     */
    private double calculateTokenSimilarity(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0.0;
        }
        
        if (text1.equals(text2)) {
            return 1.0;
        }
        
        if (text1.isEmpty() || text2.isEmpty()) {
            return 0.0;
        }
        
        // Split texts into tokens (words)
        String[] tokens1 = text1.split("\\s+");
        String[] tokens2 = text2.split("\\s+");
        
        // Count tokens
        Map<String, Integer> tokenCount1 = new HashMap<>();
        Map<String, Integer> tokenCount2 = new HashMap<>();
        
        for (String token : tokens1) {
            if (!token.isEmpty()) {
                tokenCount1.put(token, tokenCount1.getOrDefault(token, 0) + 1);
            }
        }
        
        for (String token : tokens2) {
            if (!token.isEmpty()) {
                tokenCount2.put(token, tokenCount2.getOrDefault(token, 0) + 1);
            }
        }
        
        // Calculate Jaccard similarity
        if (tokenCount1.isEmpty() && tokenCount2.isEmpty()) {
            return 1.0;
        }
        
        if (tokenCount1.isEmpty() || tokenCount2.isEmpty()) {
            return 0.0;
        }
        
        // Count intersection and union
        int intersection = 0;
        for (Map.Entry<String, Integer> entry : tokenCount1.entrySet()) {
            String token = entry.getKey();
            int count1 = entry.getValue();
            int count2 = tokenCount2.getOrDefault(token, 0);
            intersection += Math.min(count1, count2);
        }
        
        int union = 0;
        for (Map.Entry<String, Integer> entry : tokenCount1.entrySet()) {
            union += entry.getValue();
        }
        
        for (Map.Entry<String, Integer> entry : tokenCount2.entrySet()) {
            union += entry.getValue();
        }
        
        union -= intersection;
        
        return (double) intersection / union;
    }
    
    /**
     * Calculates context similarity based on parent and child elements.
     * 
     * @param originalElement The original element fingerprint
     * @param candidateElement The candidate element fingerprint
     * @return The context similarity score (0.0 to 1.0)
     */
    private double calculateContextSimilarity(ElementFingerprint originalElement, ElementFingerprint candidateElement) {
        // Get parent and child relationships
        List<ElementFingerprint.Relationship> originalParentRels = originalElement.getRelationshipsByType(ElementFingerprint.Relationship.Type.PARENT);
        List<ElementFingerprint.Relationship> candidateParentRels = candidateElement.getRelationshipsByType(ElementFingerprint.Relationship.Type.PARENT);
        
        List<ElementFingerprint.Relationship> originalChildRels = originalElement.getRelationshipsByType(ElementFingerprint.Relationship.Type.CHILD);
        List<ElementFingerprint.Relationship> candidateChildRels = candidateElement.getRelationshipsByType(ElementFingerprint.Relationship.Type.CHILD);
        
        // If no relationship data is available, return neutral score
        if ((originalParentRels.isEmpty() && candidateParentRels.isEmpty() && 
             originalChildRels.isEmpty() && candidateChildRels.isEmpty())) {
            return 0.5;
        }
        
        double parentSimilarity = 0.5;
        double childSimilarity = 0.5;
        
        // Calculate parent similarity if available
        if (!originalParentRels.isEmpty() && !candidateParentRels.isEmpty()) {
            // We'll just use the first parent for simplicity
            Object originalParentProp = originalParentRels.get(0).getProperty("text");
            Object candidateParentProp = candidateParentRels.get(0).getProperty("text");
            
            if (originalParentProp instanceof String && candidateParentProp instanceof String) {
                String originalParentText = (String) originalParentProp;
                String candidateParentText = (String) candidateParentProp;
                
                if (!originalParentText.isEmpty() && !candidateParentText.isEmpty()) {
                    parentSimilarity = calculateStringSimilarity(
                            normalizeText(originalParentText),
                            normalizeText(candidateParentText)
                    );
                }
            }
        }
        
        // Calculate child similarity if available
        if (!originalChildRels.isEmpty() && !candidateChildRels.isEmpty()) {
            // Calculate average text similarity of children
            double totalSimilarity = 0.0;
            int comparedChildren = 0;
            
            for (ElementFingerprint.Relationship originalChildRel : originalChildRels) {
                Object originalChildProp = originalChildRel.getProperty("text");
                if (!(originalChildProp instanceof String) || ((String) originalChildProp).isEmpty()) {
                    continue;
                }
                
                String originalChildText = (String) originalChildProp;
                
                for (ElementFingerprint.Relationship candidateChildRel : candidateChildRels) {
                    Object candidateChildProp = candidateChildRel.getProperty("text");
                    if (!(candidateChildProp instanceof String) || ((String) candidateChildProp).isEmpty()) {
                        continue;
                    }
                    
                    String candidateChildText = (String) candidateChildProp;
                    
                    double textSimilarity = calculateStringSimilarity(
                            normalizeText(originalChildText),
                            normalizeText(candidateChildText)
                    );
                    
                    totalSimilarity += textSimilarity;
                    comparedChildren++;
                    
                    // Only compare each original child with the best matching candidate child
                    break;
                }
            }
            
            if (comparedChildren > 0) {
                childSimilarity = totalSimilarity / comparedChildren;
            }
        }
        
        // Combine parent and child similarity with slightly higher weight for parent
        return parentSimilarity * 0.6 + childSimilarity * 0.4;
    }
    
    /**
     * Calculates a proximity boost based on position.
     * 
     * @param originalElement The original element fingerprint
     * @param candidateElement The candidate element fingerprint
     * @return The proximity boost (0.0 to 1.0)
     */
    private double calculateProximityBoost(ElementFingerprint originalElement, ElementFingerprint candidateElement) {
        ElementFingerprint.Position originalPos = originalElement.getPosition();
        ElementFingerprint.Position candidatePos = candidateElement.getPosition();
        
        if (originalPos == null || candidatePos == null) {
            return 0.5; // Neutral score if position data is missing
        }
        
        // Calculate distance
        double distance = originalPos.distanceTo(candidatePos);
        
        // Convert distance to proximity score (inversely proportional)
        // Define a maximum distance threshold beyond which proximity is 0
        double maxDistance = 500.0; // pixels
        
        return Math.max(0.0, 1.0 - distance / maxDistance);
    }
    
    /**
     * Calculates a visibility boost based on element properties.
     * 
     * @param candidateElement The candidate element fingerprint
     * @return The visibility boost (0.0 to 1.0)
     */
    private double calculateVisibilityBoost(ElementFingerprint candidateElement) {
        // Check for style indicators of visibility
        Map<String, String> styles = candidateElement.getStyles();
        
        // Default to visible if no style information is available
        if (styles.isEmpty()) {
            return 0.8;
        }
        
        // Check for explicit visibility: hidden or display: none
        String visibility = styles.get("visibility");
        if ("hidden".equals(visibility)) {
            return 0.2;
        }
        
        String display = styles.get("display");
        if ("none".equals(display)) {
            return 0.2;
        }
        
        // Check for opacity: 0
        String opacity = styles.get("opacity");
        if (opacity != null) {
            try {
                double opacityValue = Double.parseDouble(opacity);
                if (opacityValue < 0.1) {
                    return 0.3;
                }
            } catch (NumberFormatException ignored) {
                // Not a valid number, ignore
            }
        }
        
        // Check for zero width or height
        ElementFingerprint.Size size = candidateElement.getSize();
        if (size != null && (size.getWidth() <= 0 || size.getHeight() <= 0)) {
            return 0.4;
        }
        
        // Element appears to be visible
        return 1.0;
    }
    
    /**
     * Generates a new locator based on the candidate's attributes and the specified locator type.
     * 
     * @param candidate The candidate element fingerprint
     * @param locatorType The type of locator to generate
     * @return The generated locator, or null if generation fails
     */
    private String generateLocatorFromCandidate(ElementFingerprint candidate, LocatorType locatorType) {
        if (candidate == null || locatorType == null) {
            return null;
        }
        
        switch (locatorType) {
            case ID:
                return generateIdLocator(candidate);
            case NAME:
                return generateNameLocator(candidate);
            case CLASS_NAME:
                return generateClassLocator(candidate);
            case TAG_NAME:
                return generateTagLocator(candidate);
            case XPATH:
                return generateXPathLocator(candidate);
            case CSS_SELECTOR:
                return generateCssLocator(candidate);
            case LINK_TEXT:
                return generateLinkTextLocator(candidate);
            case PARTIAL_LINK_TEXT:
                return generatePartialLinkTextLocator(candidate);
            case PLAYWRIGHT_TEXT:
                return generatePlaywrightTextLocator(candidate);
            case PLAYWRIGHT_HAS_TEXT:
                return generatePlaywrightHasTextLocator(candidate);
            default:
                // Default to XPath with text as a fallback
                return generateXPathLocator(candidate);
        }
    }
    
    /**
     * Generates an ID locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated ID locator, or null if generation fails
     */
    private String generateIdLocator(ElementFingerprint candidate) {
        String id = candidate.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            return id;
        }
        return null;
    }
    
    /**
     * Generates a name locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated name locator, or null if generation fails
     */
    private String generateNameLocator(ElementFingerprint candidate) {
        String name = candidate.getAttribute("name");
        if (name != null && !name.isEmpty()) {
            return name;
        }
        return null;
    }
    
    /**
     * Generates a class locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated class locator, or null if generation fails
     */
    private String generateClassLocator(ElementFingerprint candidate) {
        List<String> classes = candidate.getClasses();
        if (!classes.isEmpty()) {
            // Use the first class as the locator
            return classes.get(0);
        }
        return null;
    }
    
    /**
     * Generates a tag locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated tag locator, or null if generation fails
     */
    private String generateTagLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName != null && !tagName.isEmpty()) {
            return tagName;
        }
        return null;
    }
    
    /**
     * Generates an XPath locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated XPath locator, or null if generation fails
     */
    private String generateXPathLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName == null || tagName.isEmpty()) {
            tagName = "*";
        }
        
        // Try to generate a text-based XPath
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            // Trim and truncate the text if necessary
            text = text.trim();
            if (text.length() > 100) {
                text = text.substring(0, 100);
            }
            
            // Escape quotes in the text
            text = escapeQuotes(text);
            
            if (text.length() < 20) {
                // For short text, use exact matching
                return "//" + tagName + "[text()='" + text + "']";
            } else {
                // For longer text, use contains() to be more robust
                return "//" + tagName + "[contains(text(), '" + text + "')]";
            }
        }
        
        // If no text, try ID locator
        String id = candidate.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            return "//" + tagName + "[@id='" + escapeQuotes(id) + "']";
        }
        
        // Try name attribute
        String name = candidate.getAttribute("name");
        if (name != null && !name.isEmpty()) {
            return "//" + tagName + "[@name='" + escapeQuotes(name) + "']";
        }
        
        // Try class attribute
        List<String> classes = candidate.getClasses();
        if (!classes.isEmpty()) {
            return "//" + tagName + "[contains(@class, '" + escapeQuotes(classes.get(0)) + "')]";
        }
        
        // Fallback to the candidate's existing XPath if available
        String xpath = candidate.getXpath();
        if (xpath != null && !xpath.isEmpty()) {
            return xpath;
        }
        
        // Last resort: just use the tag name
        return "//" + tagName;
    }
    
    /**
     * Generates a CSS selector from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated CSS selector, or null if generation fails
     */
    private String generateCssLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName == null || tagName.isEmpty()) {
            tagName = "*";
        }
        
        // Try ID locator
        String id = candidate.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            return tagName + "#" + cssEscape(id);
        }
        
        // Try class locator
        List<String> classes = candidate.getClasses();
        if (!classes.isEmpty()) {
            return tagName + "." + cssEscape(classes.get(0));
        }
        
        // For buttons and links, try using contains for text content
        if ("button".equals(tagName) || "a".equals(tagName)) {
            String text = candidate.getTextContent();
            if (text != null && !text.isEmpty()) {
                text = text.trim();
                if (text.length() > 30) {
                    text = text.substring(0, 30);
                }
                return tagName + ":contains('" + escapeQuotes(text) + "')";
            }
        }
        
        // Try other attributes
        Map<String, String> attributes = candidate.getAttributes();
        for (Map.Entry<String, String> entry : attributes.entrySet()) {
            if ("id".equals(entry.getKey()) || "class".equals(entry.getKey())) {
                continue; // Already handled
            }
            
            String attrName = entry.getKey();
            String attrValue = entry.getValue();
            
            if (attrName != null && !attrName.isEmpty() && attrValue != null && !attrValue.isEmpty()) {
                return tagName + "[" + attrName + "='" + escapeQuotes(attrValue) + "']";
            }
        }
        
        // Fallback to the candidate's existing CSS selector if available
        String cssSelector = candidate.getCssSelector();
        if (cssSelector != null && !cssSelector.isEmpty()) {
            return cssSelector;
        }
        
        // Last resort: just use the tag name
        return tagName;
    }
    
    /**
     * Generates a link text locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated link text locator, or null if generation fails
     */
    private String generateLinkTextLocator(ElementFingerprint candidate) {
        // Only applicable for anchor elements
        if (!"a".equalsIgnoreCase(candidate.getTagName())) {
            return null;
        }
        
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            return text.trim();
        }
        
        return null;
    }
    
    /**
     * Generates a partial link text locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated partial link text locator, or null if generation fails
     */
    private String generatePartialLinkTextLocator(ElementFingerprint candidate) {
        // Only applicable for anchor elements
        if (!"a".equalsIgnoreCase(candidate.getTagName())) {
            return null;
        }
        
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            text = text.trim();
            if (text.length() > 20) {
                text = text.substring(0, 20);
            }
            return text;
        }
        
        return null;
    }
    
    /**
     * Generates a Playwright text locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated Playwright text locator, or null if generation fails
     */
    private String generatePlaywrightTextLocator(ElementFingerprint candidate) {
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            text = text.trim();
            if (text.length() > 100) {
                text = text.substring(0, 100);
            }
            return "text=" + escapePlaywrightText(text);
        }
        
        return null;
    }
    
    /**
     * Generates a Playwright has-text locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated Playwright has-text locator, or null if generation fails
     */
    private String generatePlaywrightHasTextLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName == null || tagName.isEmpty()) {
            tagName = "*";
        }
        
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            text = text.trim();
            if (text.length() > 100) {
                text = text.substring(0, 100);
            }
            return tagName + " >> :has-text(" + escapePlaywrightText(text) + ")";
        }
        
        return null;
    }
    
    /**
     * Escapes single quotes in a string.
     * 
     * @param str The string to escape
     * @return The escaped string
     */
    private String escapeQuotes(String str) {
        if (str == null) {
            return "";
        }
        return str.replace("'", "\\'").replace("\"", "\\\"");
    }
    
    /**
     * Escapes characters for CSS selectors.
     * 
     * @param str The string to escape
     * @return The escaped string
     */
    private String cssEscape(String str) {
        if (str == null) {
            return "";
        }
        
        StringBuilder result = new StringBuilder();
        
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            
            // Escape special characters
            if (ch == 0) {
                result.append("\\0");
            } else if ((ch >= 1 && ch <= 31) || ch == 127) {
                result.append("\\").append(Integer.toHexString(ch)).append(" ");
            } else if (i == 0 && ch >= '0' && ch <= '9') {
                result.append("\\").append(ch);
            } else if (ch == '#' || ch == '.' || ch == '[' || ch == ']' || ch == '(' || ch == ')' ||
                    ch == '{' || ch == '}' || ch == ':' || ch == ',' || ch == ';' || ch == '+' ||
                    ch == '>' || ch == '~' || ch == '|' || ch == '*' || ch == '=' || ch == '^' ||
                    ch == '$' || ch == '!' || ch == '"' || ch == '\'' || ch == '/' || ch == '\\') {
                result.append("\\").append(ch);
            } else {
                result.append(ch);
            }
        }
        
        return result.toString();
    }
    
    /**
     * Escapes text for Playwright text selectors.
     * 
     * @param text The text to escape
     * @return The escaped text for Playwright
     */
    private String escapePlaywrightText(String text) {
        if (text == null) {
            return "";
        }
        
        // For Playwright, we need to decide whether to use single or double quotes
        // based on what's in the text
        boolean containsSingleQuote = text.contains("'");
        boolean containsDoubleQuote = text.contains("\"");
        
        if (containsSingleQuote && !containsDoubleQuote) {
            // Use double quotes
            return "\"" + text + "\"";
        } else if (!containsSingleQuote && containsDoubleQuote) {
            // Use single quotes
            return "'" + text + "'";
        } else if (!containsSingleQuote && !containsDoubleQuote) {
            // No quotes in text, prefer single quotes
            return "'" + text + "'";
        } else {
            // Both types of quotes, need to escape single quotes
            return "\"" + text.replace("\"", "\\\"") + "\"";
        }
    }
    
    /**
     * Infers the locator type from the original locator string.
     * 
     * @param originalLocator The original locator string
     * @return The inferred locator type
     */
    private LocatorType inferLocatorType(String originalLocator) {
        if (originalLocator == null || originalLocator.isEmpty()) {
            return LocatorType.XPATH; // Default to XPath for text-based matching
        }
        
        // Check for XPath
        if (originalLocator.startsWith("/") || originalLocator.startsWith("(")) {
            return LocatorType.XPATH;
        }
        
        // Check for Playwright text locator
        if (originalLocator.startsWith("text=")) {
            return LocatorType.PLAYWRIGHT_TEXT;
        }
        
        // Check for Playwright has-text locator
        if (originalLocator.contains(":has-text(")) {
            return LocatorType.PLAYWRIGHT_HAS_TEXT;
        }
        
        // Check for CSS selector
        if (originalLocator.contains("#") || originalLocator.contains(".") || originalLocator.contains("[") ||
                originalLocator.contains(">") || originalLocator.contains("+") || originalLocator.contains("~")) {
            return LocatorType.CSS_SELECTOR;
        }
        
        // Check for link text
        if (originalLocator.length() > 0 && !originalLocator.matches("^[a-zA-Z0-9_]+$")) {
            // Locator contains spaces or special characters, likely link text
            return LocatorType.LINK_TEXT;
        }
        
        // Default to XPath with text for text-based healing
        return LocatorType.XPATH;
    }
    
    /**
     * Represents a candidate element with its similarity score.
     */
    private static class ScoredCandidate {
        private final ElementFingerprint candidate;
        private final double score;
        
        /**
         * Creates a new scored candidate.
         * 
         * @param candidate The candidate element fingerprint
         * @param score The similarity score
         */
        public ScoredCandidate(ElementFingerprint candidate, double score) {
            this.candidate = candidate;
            this.score = score;
        }
        
        /**
         * Gets the candidate element fingerprint.
         * 
         * @return The candidate
         */
        public ElementFingerprint getCandidate() {
            return candidate;
        }
        
        /**
         * Gets the similarity score.
         * 
         * @return The score
         */
        public double getScore() {
            return score;
        }
    }
    
    /**
     * Builder class for creating TextHealingStrategy instances.
     */
    public static class Builder {
        private SimilarityScorer similarityScorer;
        private double minimumScore = DEFAULT_MINIMUM_SCORE;
        private boolean fuzzyMatching = true;
        private boolean caseSensitive = false;
        private boolean normalizeWhitespace = true;
        private boolean tokenBasedMatching = true;
        private boolean proximityBoosting = true;
        private boolean prioritizeVisibleElements = true;
        private boolean considerTextContext = true;
        private int maxTextLengthDifferencePercent = 30;
        private int minTextLength = 3;
        private final List<Pattern> textFilterPatterns = new ArrayList<>();
        
        /**
         * Creates a new builder with default settings.
         */
        public Builder() {
        }
        
        /**
         * Sets the similarity scorer to use.
         * 
         * @param similarityScorer The similarity scorer
         * @return This builder instance
         */
        public Builder withSimilarityScorer(SimilarityScorer similarityScorer) {
            this.similarityScorer = similarityScorer;
            return this;
        }
        
        /**
         * Sets the minimum score required for a candidate.
         * 
         * @param minimumScore The minimum score
         * @return This builder instance
         */
        public Builder withMinimumScore(double minimumScore) {
            if (minimumScore >= 0.0 && minimumScore <= 1.0) {
                this.minimumScore = minimumScore;
            }
            return this;
        }
        
        /**
         * Sets whether to enable fuzzy text matching.
         * 
         * @param fuzzyMatching true to enable fuzzy matching, false for exact matching only
         * @return This builder instance
         */
        public Builder withFuzzyMatching(boolean fuzzyMatching) {
            this.fuzzyMatching = fuzzyMatching;
            return this;
        }
        
        /**
         * Sets whether to enable case-sensitive matching.
         * 
         * @param caseSensitive true for case-sensitive matching, false for case-insensitive
         * @return This builder instance
         */
        public Builder withCaseSensitive(boolean caseSensitive) {
            this.caseSensitive = caseSensitive;
            return this;
        }
        
        /**
         * Sets whether to normalize whitespace in text.
         * 
         * @param normalizeWhitespace true to normalize whitespace, false to preserve it
         * @return This builder instance
         */
        public Builder withNormalizeWhitespace(boolean normalizeWhitespace) {
            this.normalizeWhitespace = normalizeWhitespace;
            return this;
        }
        
        /**
         * Sets whether to enable token-based matching.
         * 
         * @param tokenBasedMatching true to enable token-based matching, false to disable it
         * @return This builder instance
         */
        public Builder withTokenBasedMatching(boolean tokenBasedMatching) {
            this.tokenBasedMatching = tokenBasedMatching;
            return this;
        }
        
        /**
         * Sets whether to enable proximity-based boosting.
         * 
         * @param proximityBoosting true to enable proximity boosting, false to disable it
         * @return This builder instance
         */
        public Builder withProximityBoosting(boolean proximityBoosting) {
            this.proximityBoosting = proximityBoosting;
            return this;
        }
        
        /**
         * Sets whether to prioritize visible elements.
         * 
         * @param prioritizeVisibleElements true to prioritize visible elements, false to treat all equally
         * @return This builder instance
         */
        public Builder withPrioritizeVisibleElements(boolean prioritizeVisibleElements) {
            this.prioritizeVisibleElements = prioritizeVisibleElements;
            return this;
        }
        
        /**
         * Sets whether to consider parent/child text context.
         * 
         * @param considerTextContext true to consider text context, false to ignore it
         * @return This builder instance
         */
        public Builder withConsiderTextContext(boolean considerTextContext) {
            this.considerTextContext = considerTextContext;
            return this;
        }
        
        /**
         * Sets the maximum text length difference percentage allowed.
         * 
         * @param maxTextLengthDifferencePercent The maximum difference percentage (0-100)
         * @return This builder instance
         */
        public Builder withMaxTextLengthDifferencePercent(int maxTextLengthDifferencePercent) {
            this.maxTextLengthDifferencePercent = Math.max(0, Math.min(100, maxTextLengthDifferencePercent));
            return this;
        }
        
        /**
         * Sets the minimum text length required for consideration.
         * 
         * @param minTextLength The minimum text length
         * @return This builder instance
         */
        public Builder withMinTextLength(int minTextLength) {
            this.minTextLength = Math.max(0, minTextLength);
            return this;
        }
        
        /**
         * Adds a filter pattern for text.
         * 
         * @param pattern The regular expression pattern
         * @return This builder instance
         */
        public Builder withTextFilterPattern(String pattern) {
            if (pattern != null && !pattern.isEmpty()) {
                try {
                    this.textFilterPatterns.add(Pattern.compile(pattern));
                } catch (Exception e) {
                    // Ignore invalid pattern
                }
            }
            return this;
        }
        
        /**
         * Adds multiple filter patterns for text.
         * 
         * @param patterns The regular expression patterns
         * @return This builder instance
         */
        public Builder withTextFilterPatterns(List<String> patterns) {
            if (patterns != null) {
                for (String pattern : patterns) {
                    withTextFilterPattern(pattern);
                }
            }
            return this;
        }
        
        /**
         * Builds a TextHealingStrategy from the current builder state.
         * 
         * @return The text healing strategy
         */
        public TextHealingStrategy build() {
            return new TextHealingStrategy(
                    similarityScorer,
                    minimumScore,
                    fuzzyMatching,
                    caseSensitive,
                    normalizeWhitespace,
                    tokenBasedMatching,
                    proximityBoosting,
                    prioritizeVisibleElements,
                    considerTextContext,
                    maxTextLengthDifferencePercent,
                    minTextLength,
                    textFilterPatterns
            );
        }
    }
    
    /**
     * Creates a builder for constructing a customized TextHealingStrategy.
     * 
     * @return A new builder instance
     */
    public static Builder builder() {
        return new Builder();
    }
}


PositionHealingStrategy.java
----------------------------------------

package com.cstestforge.framework.core.selfhealing;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

/**
 * A healing strategy based on element position.
 * This strategy focuses on finding elements with similar positions
 * when the original locator fails.
 */
public class PositionHealingStrategy implements HealingStrategy {

    private static final long serialVersionUID = 1L;
    
    // The default minimum score threshold for candidate acceptance
    private static final double DEFAULT_MINIMUM_SCORE = 0.7;
    
    // Default maximum distance (in pixels) for position comparison
    private static final double DEFAULT_MAX_DISTANCE = 100.0;
    
    // Default Z-index tolerance for position comparison
    private static final int DEFAULT_Z_INDEX_TOLERANCE = 2;
    
    // Default size difference percentage tolerance
    private static final double DEFAULT_SIZE_TOLERANCE_PERCENT = 20.0;
    
    // The similarity scorer used for comparing elements
    private final SimilarityScorer similarityScorer;
    
    // The minimum score required for a candidate to be considered
    private final double minimumScore;
    
    // The maximum distance (in pixels) for position comparison
    private final double maxDistance;
    
    // The Z-index tolerance for position comparison
    private final int zIndexTolerance;
    
    // The size difference percentage tolerance
    private final double sizeTolerance;
    
    // Flag to prioritize elements in the same container
    private final boolean prioritizeSameContainer;
    
    // Flag to consider visibility in scoring
    private final boolean considerVisibility;
    
    // Flag to consider element size in scoring
    private final boolean considerSize;
    
    // Flag to consider Z-index in scoring
    private final boolean considerZIndex;
    
    // Flag to adjust for responsive design
    private final boolean adjustForResponsive;
    
    // Flag to prioritize elements with similar tag name
    private final boolean prioritizeSameTag;
    
    /**
     * Creates a new position healing strategy with default settings.
     */
    public PositionHealingStrategy() {
        this.similarityScorer = SimilarityScorer.createPositionOptimizedScorer();
        this.minimumScore = DEFAULT_MINIMUM_SCORE;
        this.maxDistance = DEFAULT_MAX_DISTANCE;
        this.zIndexTolerance = DEFAULT_Z_INDEX_TOLERANCE;
        this.sizeTolerance = DEFAULT_SIZE_TOLERANCE_PERCENT;
        this.prioritizeSameContainer = true;
        this.considerVisibility = true;
        this.considerSize = true;
        this.considerZIndex = true;
        this.adjustForResponsive = true;
        this.prioritizeSameTag = true;
    }
    
    /**
     * Creates a new position healing strategy with the specified settings.
     * 
     * @param similarityScorer The similarity scorer to use
     * @param minimumScore The minimum score required for a candidate
     * @param maxDistance The maximum distance (in pixels) for position comparison
     * @param zIndexTolerance The Z-index tolerance for position comparison
     * @param sizeTolerance The size difference percentage tolerance
     * @param prioritizeSameContainer Whether to prioritize elements in the same container
     * @param considerVisibility Whether to consider visibility in scoring
     * @param considerSize Whether to consider element size in scoring
     * @param considerZIndex Whether to consider Z-index in scoring
     * @param adjustForResponsive Whether to adjust for responsive design
     * @param prioritizeSameTag Whether to prioritize elements with similar tag name
     */
    public PositionHealingStrategy(
            SimilarityScorer similarityScorer,
            double minimumScore,
            double maxDistance,
            int zIndexTolerance,
            double sizeTolerance,
            boolean prioritizeSameContainer,
            boolean considerVisibility,
            boolean considerSize,
            boolean considerZIndex,
            boolean adjustForResponsive,
            boolean prioritizeSameTag) {
        this.similarityScorer = similarityScorer != null ? similarityScorer : SimilarityScorer.createPositionOptimizedScorer();
        this.minimumScore = minimumScore >= 0.0 && minimumScore <= 1.0 ? minimumScore : DEFAULT_MINIMUM_SCORE;
        this.maxDistance = maxDistance > 0.0 ? maxDistance : DEFAULT_MAX_DISTANCE;
        this.zIndexTolerance = zIndexTolerance >= 0 ? zIndexTolerance : DEFAULT_Z_INDEX_TOLERANCE;
        this.sizeTolerance = sizeTolerance >= 0.0 && sizeTolerance <= 100.0 ? sizeTolerance : DEFAULT_SIZE_TOLERANCE_PERCENT;
        this.prioritizeSameContainer = prioritizeSameContainer;
        this.considerVisibility = considerVisibility;
        this.considerSize = considerSize;
        this.considerZIndex = considerZIndex;
        this.adjustForResponsive = adjustForResponsive;
        this.prioritizeSameTag = prioritizeSameTag;
    }
    
    @Override
    public String getName() {
        return "Position Healing Strategy";
    }
    
    @Override
    public String getDescription() {
        return "A healing strategy that focuses on finding elements with similar positions " +
               "when the original locator fails. This strategy compares element positions " +
               "and sizes to identify potential matches, with adaptations for responsive design.";
    }
    
    @Override
    public HealingResult findAlternativeLocator(
            ElementFingerprint originalElement,
            List<ElementFingerprint> candidates,
            LocatorType locatorType,
            String originalLocator) {
        
        if (originalElement == null || candidates == null || candidates.isEmpty()) {
            return HealingResult.failed("No valid input provided");
        }
        
        ElementFingerprint.Position originalPosition = originalElement.getPosition();
        if (originalPosition == null) {
            return HealingResult.failed("Original element has no position information");
        }
        
        // Filter candidates with position information
        List<ElementFingerprint> positionCandidates = candidates.stream()
                .filter(candidate -> candidate.getPosition() != null)
                .collect(Collectors.toList());
        
        if (positionCandidates.isEmpty()) {
            return HealingResult.failed("No candidates with position information found");
        }
        
        // Score candidates based on position similarity
        List<ScoredCandidate> scoredCandidates = positionCandidates.stream()
                .map(candidate -> {
                    double score = calculatePositionSimilarity(originalElement, candidate);
                    return new ScoredCandidate(candidate, score);
                })
                .filter(scoredCandidate -> scoredCandidate.getScore() >= minimumScore)
                .sorted(Comparator.comparing(ScoredCandidate::getScore).reversed())
                .collect(Collectors.toList());
        
        if (scoredCandidates.isEmpty()) {
            return HealingResult.failed("No candidates with sufficient position similarity found");
        }
        
        // Select the best candidate
        ScoredCandidate bestCandidate = scoredCandidates.get(0);
        
        // Generate a new locator based on the best candidate
        String healedLocator = generateLocatorFromCandidate(
                bestCandidate.getCandidate(),
                locatorType != null ? locatorType : inferLocatorType(originalLocator)
        );
        
        if (healedLocator == null || healedLocator.isEmpty()) {
            return HealingResult.failed("Could not generate a valid locator from the best candidate");
        }
        
        return HealingResult.success(
                healedLocator,
                bestCandidate.getScore(),
                getName(),
                "Found alternative locator by position matching with score " + bestCandidate.getScore()
        );
    }
    
    /**
     * Calculates the position similarity between two element fingerprints.
     * 
     * @param originalElement The original element fingerprint
     * @param candidateElement The candidate element fingerprint
     * @return The position similarity score (0.0 to 1.0)
     */
    private double calculatePositionSimilarity(ElementFingerprint originalElement, ElementFingerprint candidateElement) {
        ElementFingerprint.Position originalPos = originalElement.getPosition();
        ElementFingerprint.Position candidatePos = candidateElement.getPosition();
        
        if (originalPos == null || candidatePos == null) {
            return 0.0;
        }
        
        double positionScore = 0.0;
        double weightSum = 0.0;
        
        // Calculate distance-based score (highest weight)
        double distanceWeight = 0.6;
        double distanceScore = calculateDistanceScore(originalPos, candidatePos);
        positionScore += distanceScore * distanceWeight;
        weightSum += distanceWeight;
        
        // Calculate z-index score if configured
        if (considerZIndex) {
            double zIndexWeight = 0.1;
            double zIndexScore = calculateZIndexScore(originalPos, candidatePos);
            positionScore += zIndexScore * zIndexWeight;
            weightSum += zIndexWeight;
        }
        
        // Calculate size score if configured
        if (considerSize) {
            double sizeWeight = 0.15;
            double sizeScore = calculateSizeScore(originalElement.getSize(), candidateElement.getSize());
            positionScore += sizeScore * sizeWeight;
            weightSum += sizeWeight;
        }
        
        // Calculate container score if configured
        if (prioritizeSameContainer) {
            double containerWeight = 0.1;
            double containerScore = calculateContainerScore(originalElement, candidateElement);
            positionScore += containerScore * containerWeight;
            weightSum += containerWeight;
        }
        
        // Calculate visibility score if configured
        if (considerVisibility) {
            double visibilityWeight = 0.05;
            double visibilityScore = calculateVisibilityScore(candidateElement);
            positionScore += visibilityScore * visibilityWeight;
            weightSum += visibilityWeight;
        }
        
        // Apply tag name bonus if configured
        if (prioritizeSameTag) {
            boolean sameTag = originalElement.getTagName() != null &&
                    originalElement.getTagName().equals(candidateElement.getTagName());
            
            if (sameTag) {
                // Apply a bonus to the score, but ensure it doesn't exceed 1.0
                positionScore = Math.min(1.0, positionScore * 1.2);
            }
        }
        
        // Normalize the final score
        return weightSum > 0 ? positionScore / weightSum : 0.0;
    }
    
    /**
     * Calculates a score based on the distance between two positions.
     * 
     * @param pos1 The first position
     * @param pos2 The second position
     * @return The distance score (0.0 to 1.0)
     */
    private double calculateDistanceScore(ElementFingerprint.Position pos1, ElementFingerprint.Position pos2) {
        double distance = pos1.distanceTo(pos2);
        
        // For responsive design, adjust based on screen dimensions
        if (adjustForResponsive) {
            // This is a simplification; in a real implementation, the adjustment
            // would be based on actual screen dimensions and viewport
            distance = adjustDistanceForResponsive(distance, pos1, pos2);
        }
        
        // Convert distance to similarity score (inversely proportional)
        return Math.max(0.0, 1.0 - distance / maxDistance);
    }
    
    /**
     * Adjusts distance calculations for responsive design.
     * 
     * @param distance The original distance
     * @param pos1 The first position
     * @param pos2 The second position
     * @return The adjusted distance
     */
    private double adjustDistanceForResponsive(
            double distance,
            ElementFingerprint.Position pos1,
            ElementFingerprint.Position pos2) {
        // In responsive design, vertical position changes are more likely than horizontal
        // Reduce the impact of vertical (y) differences
        int xDiff = Math.abs(pos1.getX() - pos2.getX());
        int yDiff = Math.abs(pos1.getY() - pos2.getY());
        
        // Apply less weight to vertical differences
        double adjustedYDiff = yDiff * 0.7; // 30% reduction in vertical difference weight
        
        // Recalculate adjusted distance
        return Math.sqrt(xDiff * xDiff + adjustedYDiff * adjustedYDiff);
    }
    
    /**
     * Calculates a score based on the Z-index comparison.
     * 
     * @param pos1 The first position
     * @param pos2 The second position
     * @return The Z-index score (0.0 to 1.0)
     */
    private double calculateZIndexScore(ElementFingerprint.Position pos1, ElementFingerprint.Position pos2) {
        int zIndex1 = pos1.getZIndex();
        int zIndex2 = pos2.getZIndex();
        
        int difference = Math.abs(zIndex1 - zIndex2);
        
        // Perfect match for identical z-index
        if (difference == 0) {
            return 1.0;
        }
        
        // Within tolerance gives high but not perfect score
        if (difference <= zIndexTolerance) {
            return 1.0 - ((double) difference / (zIndexTolerance + 1));
        }
        
        // Beyond tolerance, score decreases more rapidly
        return Math.max(0.0, 0.5 - ((difference - zIndexTolerance) * 0.1));
    }
    
    /**
     * Calculates a score based on the size comparison.
     * 
     * @param size1 The first size
     * @param size2 The second size
     * @return The size score (0.0 to 1.0)
     */
    private double calculateSizeScore(ElementFingerprint.Size size1, ElementFingerprint.Size size2) {
        if (size1 == null || size2 == null) {
            return 0.5; // Neutral score if size data is missing
        }
        
        // Check if sizes are similar within the configured tolerance
        if (size1.isSimilarTo(size2, sizeTolerance)) {
            return 1.0;
        }
        
        // Calculate width ratio
        double widthRatio = calculateRatio(size1.getWidth(), size2.getWidth());
        
        // Calculate height ratio
        double heightRatio = calculateRatio(size1.getHeight(), size2.getHeight());
        
        // Calculate area ratio
        double areaRatio = calculateRatio(size1.getArea(), size2.getArea());
        
        // Combine ratios with weights
        return widthRatio * 0.4 + heightRatio * 0.4 + areaRatio * 0.2;
    }
    
    /**
     * Calculates the ratio between two values.
     * 
     * @param val1 The first value
     * @param val2 The second value
     * @return The ratio (0.0 to 1.0)
     */
    private double calculateRatio(int val1, int val2) {
        if (val1 == 0 && val2 == 0) {
            return 1.0; // Both zero is a perfect match
        }
        
        if (val1 == 0 || val2 == 0) {
            return 0.0; // One zero and one non-zero is a complete mismatch
        }
        
        double max = Math.max(val1, val2);
        double min = Math.min(val1, val2);
        
        return min / max;
    }
    
    /**
     * Calculates a score based on containers.
     * 
     * @param originalElement The original element fingerprint
     * @param candidateElement The candidate element fingerprint
     * @return The container score (0.0 to 1.0)
     */
    private double calculateContainerScore(ElementFingerprint originalElement, ElementFingerprint candidateElement) {
        // Get parent relationships
        List<ElementFingerprint.Relationship> originalParents = originalElement.getRelationshipsByType(
                ElementFingerprint.Relationship.Type.PARENT);
        List<ElementFingerprint.Relationship> candidateParents = candidateElement.getRelationshipsByType(
                ElementFingerprint.Relationship.Type.PARENT);
        
        if (originalParents.isEmpty() || candidateParents.isEmpty()) {
            return 0.5; // Neutral score if parent information is missing
        }
        
        // Compare parent IDs if available
        boolean sameDirectParent = false;
        boolean sameAncestor = false;
        
        for (ElementFingerprint.Relationship originalParent : originalParents) {
            String originalParentId = originalParent.getRelatedElementIdentifier();
            
            for (ElementFingerprint.Relationship candidateParent : candidateParents) {
                String candidateParentId = candidateParent.getRelatedElementIdentifier();
                
                if (originalParentId.equals(candidateParentId)) {
                    sameDirectParent = true;
                    break;
                }
            }
            
            if (sameDirectParent) {
                break;
            }
        }
        
        // If direct parent doesn't match, check ancestors
        if (!sameDirectParent) {
            List<ElementFingerprint.Relationship> originalAncestors = originalElement.getRelationshipsByType(
                    ElementFingerprint.Relationship.Type.ANCESTOR);
            List<ElementFingerprint.Relationship> candidateAncestors = candidateElement.getRelationshipsByType(
                    ElementFingerprint.Relationship.Type.ANCESTOR);
            
            if (!originalAncestors.isEmpty() && !candidateAncestors.isEmpty()) {
                for (ElementFingerprint.Relationship originalAncestor : originalAncestors) {
                    String originalAncestorId = originalAncestor.getRelatedElementIdentifier();
                    
                    for (ElementFingerprint.Relationship candidateAncestor : candidateAncestors) {
                        String candidateAncestorId = candidateAncestor.getRelatedElementIdentifier();
                        
                        if (originalAncestorId.equals(candidateAncestorId)) {
                            sameAncestor = true;
                            break;
                        }
                    }
                    
                    if (sameAncestor) {
                        break;
                    }
                }
            }
        }
        
        // Score based on container matching
        if (sameDirectParent) {
            return 1.0; // Perfect score for same direct parent
        } else if (sameAncestor) {
            return 0.7; // Good score for same ancestor
        } else {
            return 0.3; // Low score for different containers
        }
    }
    
    /**
     * Calculates a score based on element visibility.
     * 
     * @param element The element fingerprint
     * @return The visibility score (0.0 to 1.0)
     */
    private double calculateVisibilityScore(ElementFingerprint element) {
        // Check for style indicators of visibility
        Map<String, String> styles = element.getStyles();
        
        // Default to visible if no style information is available
        if (styles.isEmpty()) {
            return 0.8;
        }
        
        // Check for explicit visibility: hidden or display: none
        String visibility = styles.get("visibility");
        if ("hidden".equals(visibility)) {
            return 0.2;
        }
        
        String display = styles.get("display");
        if ("none".equals(display)) {
            return 0.2;
        }
        
        // Check for opacity: 0
        String opacity = styles.get("opacity");
        if (opacity != null) {
            try {
                double opacityValue = Double.parseDouble(opacity);
                if (opacityValue < 0.1) {
                    return 0.3;
                }
            } catch (NumberFormatException ignored) {
                // Not a valid number, ignore
            }
        }
        
        // Check for zero width or height
        ElementFingerprint.Size size = element.getSize();
        if (size != null && (size.getWidth() <= 0 || size.getHeight() <= 0)) {
            return 0.4;
        }
        
        // Element appears to be visible
        return 1.0;
    }
    
    /**
     * Generates a new locator based on the candidate's attributes and the specified locator type.
     * 
     * @param candidate The candidate element fingerprint
     * @param locatorType The type of locator to generate
     * @return The generated locator, or null if generation fails
     */
    private String generateLocatorFromCandidate(ElementFingerprint candidate, LocatorType locatorType) {
        if (candidate == null || locatorType == null) {
            return null;
        }
        
        switch (locatorType) {
            case ID:
                return generateIdLocator(candidate);
            case NAME:
                return generateNameLocator(candidate);
            case CLASS_NAME:
                return generateClassLocator(candidate);
            case TAG_NAME:
                return generateTagLocator(candidate);
            case XPATH:
                return generateXPathLocator(candidate);
            case CSS_SELECTOR:
                return generateCssLocator(candidate);
            case LINK_TEXT:
                return generateLinkTextLocator(candidate);
            case PARTIAL_LINK_TEXT:
                return generatePartialLinkTextLocator(candidate);
            default:
                // Default to XPath with position as a fallback
                return generateXPathLocator(candidate);
        }
    }
    
    /**
     * Generates an ID locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated ID locator, or null if generation fails
     */
    private String generateIdLocator(ElementFingerprint candidate) {
        String id = candidate.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            return id;
        }
        return null;
    }
    
    /**
     * Generates a name locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated name locator, or null if generation fails
     */
    private String generateNameLocator(ElementFingerprint candidate) {
        String name = candidate.getAttribute("name");
        if (name != null && !name.isEmpty()) {
            return name;
        }
        return null;
    }
    
    /**
     * Generates a class locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated class locator, or null if generation fails
     */
    private String generateClassLocator(ElementFingerprint candidate) {
        List<String> classes = candidate.getClasses();
        if (!classes.isEmpty()) {
            // Use the first class as the locator
            return classes.get(0);
        }
        return null;
    }
    
    /**
     * Generates a tag locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated tag locator, or null if generation fails
     */
    private String generateTagLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName != null && !tagName.isEmpty()) {
            return tagName;
        }
        return null;
    }
    
    /**
     * Generates an XPath locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated XPath locator, or null if generation fails
     */
    private String generateXPathLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName == null || tagName.isEmpty()) {
            tagName = "*";
        }
        
        // Try to generate an ID-based XPath
        String id = candidate.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            return "//" + tagName + "[@id='" + escapeQuotes(id) + "']";
        }
        
        // Try to generate a name-based XPath
        String name = candidate.getAttribute("name");
        if (name != null && !name.isEmpty()) {
            return "//" + tagName + "[@name='" + escapeQuotes(name) + "']";
        }
        
        // Try to generate a class-based XPath
        List<String> classes = candidate.getClasses();
        if (!classes.isEmpty()) {
            return "//" + tagName + "[contains(@class, '" + escapeQuotes(classes.get(0)) + "')]";
        }
        
        // Try to generate a text-based XPath if text is available
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty() && text.length() < 50) {
            // For shorter text, use contains for more robustness
            return "//" + tagName + "[contains(text(), '" + escapeQuotes(text.trim()) + "')]";
        }
        
        // Try to generate a position-based XPath as a last resort
        ElementFingerprint.Position position = candidate.getPosition();
        if (position != null) {
            // Get parent relationships to locate the element by index within its parent
            List<ElementFingerprint.Relationship> parentRels = candidate.getRelationshipsByType(
                    ElementFingerprint.Relationship.Type.PARENT);
            
            if (!parentRels.isEmpty()) {
                // Get the first parent relationship
                ElementFingerprint.Relationship parentRel = parentRels.get(0);
                
                // If we have the parent info and know this element's index among siblings
                Object indexObj = parentRel.getProperty("childIndex");
                if (indexObj instanceof Integer) {
                    int index = (Integer) indexObj;
                    // XPath indices are 1-based
                    return "//" + tagName + "[" + (index + 1) + "]";
                }
            }
            
            // Resort to absolute position as a very last resort (not recommended but possible)
            // This will be very brittle and only works reliably in non-responsive layouts
            return "(//" + tagName + ")[" + position.getX() + "," + position.getY() + "]";
        }
        
        // Fallback to any element with this tag
        return "//" + tagName;
    }
    
    /**
     * Generates a CSS selector from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated CSS selector, or null if generation fails
     */
    private String generateCssLocator(ElementFingerprint candidate) {
        String tagName = candidate.getTagName();
        if (tagName == null || tagName.isEmpty()) {
            tagName = "*";
        }
        
        // Try to generate an ID-based selector
        String id = candidate.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            return tagName + "#" + cssEscape(id);
        }
        
        // Try to generate a class-based selector
        List<String> classes = candidate.getClasses();
        if (!classes.isEmpty()) {
            StringBuilder classSelector = new StringBuilder(tagName);
            for (String className : classes) {
                classSelector.append(".").append(cssEscape(className));
            }
            return classSelector.toString();
        }
        
        // Try to generate an attribute-based selector
        Map<String, String> attributes = candidate.getAttributes();
        for (Map.Entry<String, String> entry : attributes.entrySet()) {
            String attrName = entry.getKey();
            String attrValue = entry.getValue();
            
            // Skip certain attributes
            if (attrName.equals("id") || attrName.equals("class")) {
                continue;
            }
            
            if (attrValue != null && !attrValue.isEmpty()) {
                return tagName + "[" + attrName + "='" + escapeQuotes(attrValue) + "']";
            }
        }
        
        // For positional elements, try nth-child if we have parent relationship info
        List<ElementFingerprint.Relationship> parentRels = candidate.getRelationshipsByType(
                ElementFingerprint.Relationship.Type.PARENT);
            
        if (!parentRels.isEmpty()) {
            // Get the first parent relationship
            ElementFingerprint.Relationship parentRel = parentRels.get(0);
            
            // If we have the parent info and know this element's index among siblings
            Object indexObj = parentRel.getProperty("childIndex");
            if (indexObj instanceof Integer) {
                int index = (Integer) indexObj;
                // CSS nth-child is 1-based
                return tagName + ":nth-child(" + (index + 1) + ")";
            }
        }
        
        // Last resort: just the tag name
        return tagName;
    }
    
    /**
     * Generates a link text locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated link text locator, or null if generation fails
     */
    private String generateLinkTextLocator(ElementFingerprint candidate) {
        // Only applicable for anchor elements
        if (!"a".equalsIgnoreCase(candidate.getTagName())) {
            return null;
        }
        
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            return text.trim();
        }
        
        return null;
    }
    
    /**
     * Generates a partial link text locator from the candidate's attributes.
     * 
     * @param candidate The candidate element fingerprint
     * @return The generated partial link text locator, or null if generation fails
     */
    private String generatePartialLinkTextLocator(ElementFingerprint candidate) {
        // Only applicable for anchor elements
        if (!"a".equalsIgnoreCase(candidate.getTagName())) {
            return null;
        }
        
        String text = candidate.getTextContent();
        if (text != null && !text.isEmpty()) {
            text = text.trim();
            if (text.length() > 20) {
                text = text.substring(0, 20);
            }
            return text;
        }
        
        return null;
    }
    
    /**
     * Escapes single quotes in a string.
     * 
     * @param str The string to escape
     * @return The escaped string
     */
    private String escapeQuotes(String str) {
        return str.replace("'", "\\'");
    }
    
    /**
     * Escapes characters for CSS selectors.
     * 
     * @param str The string to escape
     * @return The escaped string
     */
    private String cssEscape(String str) {
        // Based on CSS.escape() polyfill
        StringBuilder result = new StringBuilder();
        
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            
            // Escape special characters
            if (ch == 0) {
                result.append("\\0");
            } else if ((ch >= 1 && ch <= 31) || ch == 127) {
                result.append("\\").append(Integer.toHexString(ch)).append(" ");
            } else if (i == 0 && ch >= '0' && ch <= '9') {
                result.append("\\").append(ch);
            } else if (ch == '#' || ch == '.' || ch == '[' || ch == ']' || ch == '(' || ch == ')' ||
                    ch == '{' || ch == '}' || ch == ':' || ch == ',' || ch == ';' || ch == '+' ||
                    ch == '>' || ch == '~' || ch == '|' || ch == '*' || ch == '=' || ch == '^' ||
                    ch == '$' || ch == '!' || ch == '"' || ch == '\'' || ch == '/' || ch == '\\') {
                result.append("\\").append(ch);
            } else {
                result.append(ch);
            }
        }
        
        return result.toString();
    }
    
    /**
     * Infers the locator type from the original locator string.
     * 
     * @param originalLocator The original locator string
     * @return The inferred locator type
     */
    private LocatorType inferLocatorType(String originalLocator) {
        if (originalLocator == null || originalLocator.isEmpty()) {
            return LocatorType.XPATH; // Default
        }
        
        // Check for XPath
        if (originalLocator.startsWith("/") || originalLocator.startsWith("(")) {
            return LocatorType.XPATH;
        }
        
        // Check for CSS selector
        if (originalLocator.contains("#") || originalLocator.contains(".") || originalLocator.contains("[") ||
                originalLocator.contains(">") || originalLocator.contains("+") || originalLocator.contains("~")) {
            return LocatorType.CSS_SELECTOR;
        }
        
        // Check for ID (simple word without spaces)
        if (originalLocator.matches("^\\w+$")) {
            return LocatorType.ID;
        }
        
        // Default to CSS selector
        return LocatorType.CSS_SELECTOR;
    }
    
    /**
     * Represents a candidate element with its similarity score.
     */
    private static class ScoredCandidate {
        private final ElementFingerprint candidate;
        private final double score;
        
        /**
         * Creates a new scored candidate.
         * 
         * @param candidate The candidate element fingerprint
         * @param score The similarity score
         */
        public ScoredCandidate(ElementFingerprint candidate, double score) {
            this.candidate = candidate;
            this.score = score;
        }
        
        /**
         * Gets the candidate element fingerprint.
         * 
         * @return The candidate
         */
        public ElementFingerprint getCandidate() {
            return candidate;
        }
        
        /**
         * Gets the similarity score.
         * 
         * @return The score
         */
        public double getScore() {
            return score;
        }
    }
    
    /**
     * Builder class for creating PositionHealingStrategy instances.
     */
    public static class Builder {
        private SimilarityScorer similarityScorer;
        private double minimumScore = DEFAULT_MINIMUM_SCORE;
        private double maxDistance = DEFAULT_MAX_DISTANCE;
        private int zIndexTolerance = DEFAULT_Z_INDEX_TOLERANCE;
        private double sizeTolerance = DEFAULT_SIZE_TOLERANCE_PERCENT;
        private boolean prioritizeSameContainer = true;
        private boolean considerVisibility = true;
        private boolean considerSize = true;
        private boolean considerZIndex = true;
        private boolean adjustForResponsive = true;
        private boolean prioritizeSameTag = true;
        
        /**
         * Creates a new builder with default settings.
         */
        public Builder() {
        }
        
        /**
         * Sets the similarity scorer to use.
         * 
         * @param similarityScorer The similarity scorer
         * @return This builder instance
         */
        public Builder withSimilarityScorer(SimilarityScorer similarityScorer) {
            this.similarityScorer = similarityScorer;
            return this;
        }
        
        /**
         * Sets the minimum score required for a candidate.
         * 
         * @param minimumScore The minimum score
         * @return This builder instance
         */
        public Builder withMinimumScore(double minimumScore) {
            if (minimumScore >= 0.0 && minimumScore <= 1.0) {
                this.minimumScore = minimumScore;
            }
            return this;
        }
        
        /**
         * Sets the maximum distance (in pixels) for position comparison.
         * 
         * @param maxDistance The maximum distance
         * @return This builder instance
         */
        public Builder withMaxDistance(double maxDistance) {
            if (maxDistance > 0.0) {
                this.maxDistance = maxDistance;
            }
            return this;
        }
        
        /**
         * Sets the Z-index tolerance for position comparison.
         * 
         * @param zIndexTolerance The Z-index tolerance
         * @return This builder instance
         */
        public Builder withZIndexTolerance(int zIndexTolerance) {
            if (zIndexTolerance >= 0) {
                this.zIndexTolerance = zIndexTolerance;
            }
            return this;
        }
        
        /**
         * Sets the size difference percentage tolerance.
         * 
         * @param sizeTolerance The size tolerance percentage
         * @return This builder instance
         */
        public Builder withSizeTolerance(double sizeTolerance) {
            if (sizeTolerance >= 0.0 && sizeTolerance <= 100.0) {
                this.sizeTolerance = sizeTolerance;
            }
            return this;
        }
        
        /**
         * Sets whether to prioritize elements in the same container.
         * 
         * @param prioritizeSameContainer true to prioritize elements in the same container
         * @return This builder instance
         */
        public Builder withPrioritizeSameContainer(boolean prioritizeSameContainer) {
            this.prioritizeSameContainer = prioritizeSameContainer;
            return this;
        }
        
        /**
         * Sets whether to consider visibility in scoring.
         * 
         * @param considerVisibility true to consider visibility
         * @return This builder instance
         */
        public Builder withConsiderVisibility(boolean considerVisibility) {
            this.considerVisibility = considerVisibility;
            return this;
        }
        
        /**
         * Sets whether to consider element size in scoring.
         * 
         * @param considerSize true to consider element size
         * @return This builder instance
         */
        public Builder withConsiderSize(boolean considerSize) {
            this.considerSize = considerSize;
            return this;
        }
        
        /**
         * Sets whether to consider Z-index in scoring.
         * 
         * @param considerZIndex true to consider Z-index
         * @return This builder instance
         */
        public Builder withConsiderZIndex(boolean considerZIndex) {
            this.considerZIndex = considerZIndex;
            return this;
        }
        
        /**
         * Sets whether to adjust for responsive design.
         * 
         * @param adjustForResponsive true to adjust for responsive design
         * @return This builder instance
         */
        public Builder withAdjustForResponsive(boolean adjustForResponsive) {
            this.adjustForResponsive = adjustForResponsive;
            return this;
        }
        
        /**
         * Sets whether to prioritize elements with similar tag name.
         * 
         * @param prioritizeSameTag true to prioritize elements with similar tag name
         * @return This builder instance
         */
        public Builder withPrioritizeSameTag(boolean prioritizeSameTag) {
            this.prioritizeSameTag = prioritizeSameTag;
            return this;
        }
        
        /**
         * Builds a PositionHealingStrategy from the current builder state.
         * 
         * @return The position healing strategy
         */
        public PositionHealingStrategy build() {
            return new PositionHealingStrategy(
                    similarityScorer,
                    minimumScore,
                    maxDistance,
                    zIndexTolerance,
                    sizeTolerance,
                    prioritizeSameContainer,
                    considerVisibility,
                    considerSize,
                    considerZIndex,
                    adjustForResponsive,
                    prioritizeSameTag
            );
        }
    }
    
    /**
     * Creates a builder for constructing a customized PositionHealingStrategy.
     * 
     * @return A new builder instance
     */
    public static Builder builder() {
        return new Builder();
    }
}


StructureHealingStrategy.java
-----------------------------------

package com.cstestforge.framework.core.selfhealing;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * A healing strategy that uses DOM structure information to identify elements when the
 * original locator fails. This strategy examines the hierarchy, sibling relationships, and
 * structural patterns to find similar elements in the current DOM.
 * 
 * This strategy is particularly effective for applications where the visual layout may change
 * but structural relationships between elements remain relatively stable.
 */
public class StructureHealingStrategy implements HealingStrategy {
    private static final Logger LOGGER = LoggerFactory.getLogger(StructureHealingStrategy.class);
    
    /** Maximum depth to traverse up the DOM tree for ancestor analysis */
    private final int maxAncestorLevel;
    
    /** Maximum number of siblings to consider in sibling analysis */
    private final int maxSiblings;
    
    /** Threshold for structural similarity to consider elements as matches */
    private final double similarityThreshold;
    
    /** Cache of structure fingerprints for performance optimization */
    private final Map<String, DomStructure> structureCache;
    
    /** Indicates whether to use child element structures in matching */
    private final boolean includeChildStructures;
    
    /** Maximum depth to traverse down for child element analysis */
    private final int maxChildDepth;
    
    /** Weight configuration for different structural aspects */
    private final StructureWeights weights;
    
    /**
     * Creates a new StructureHealingStrategy with default settings
     */
    public StructureHealingStrategy() {
        this(3, 5, 0.7, true, 2, new StructureWeights());
    }
    
    /**
     * Creates a new StructureHealingStrategy with specified settings
     *
     * @param maxAncestorLevel Maximum depth to traverse up the DOM tree
     * @param maxSiblings Maximum number of siblings to consider
     * @param similarityThreshold Threshold for structural similarity
     * @param includeChildStructures Whether to include child element structures in matching
     * @param maxChildDepth Maximum depth to traverse down for child analysis
     * @param weights Weight configuration for different structural aspects
     */
    public StructureHealingStrategy(int maxAncestorLevel, int maxSiblings, double similarityThreshold, 
                                    boolean includeChildStructures, int maxChildDepth, StructureWeights weights) {
        this.maxAncestorLevel = maxAncestorLevel;
        this.maxSiblings = maxSiblings;
        this.similarityThreshold = similarityThreshold;
        this.includeChildStructures = includeChildStructures;
        this.maxChildDepth = maxChildDepth;
        this.weights = weights;
        this.structureCache = new ConcurrentHashMap<>();
    }
    
    @Override
    public WebElement heal(WebDriver driver, By originalLocator, ElementFingerprint fingerprint) {
        LOGGER.debug("Attempting to heal element using StructureHealingStrategy: {}", originalLocator);
        
        if (fingerprint == null || fingerprint.getStructureAttributes() == null || 
            fingerprint.getStructureAttributes().isEmpty()) {
            LOGGER.warn("Cannot heal with structure strategy - fingerprint missing structure attributes");
            return null;
        }
        
        try {
            // Extract structure information from the fingerprint
            DomStructure originalStructure = extractDomStructure(fingerprint);
            
            // Find all potential candidates
            List<WebElement> candidates = findAllPotentialElements(driver);
            if (candidates.isEmpty()) {
                LOGGER.debug("No candidate elements found for structure healing");
                return null;
            }
            
            // Score each candidate based on structural similarity
            List<ScoredElement> scoredElements = scoreCandidates(driver, candidates, originalStructure);
            
            // Sort by score in descending order
            scoredElements.sort(Comparator.comparing(ScoredElement::getScore).reversed());
            
            // If the best match exceeds our threshold, return it
            if (!scoredElements.isEmpty() && scoredElements.get(0).getScore() >= similarityThreshold) {
                WebElement healedElement = scoredElements.get(0).getElement();
                LOGGER.info("Structure healing succeeded with score: {}", scoredElements.get(0).getScore());
                return healedElement;
            }
            
            LOGGER.debug("Structure healing failed - no candidates exceeded similarity threshold");
            return null;
        } catch (Exception e) {
            LOGGER.error("Error during structure-based healing", e);
            return null;
        }
    }
    
    /**
     * Extracts DOM structure information from the element fingerprint
     */
    private DomStructure extractDomStructure(ElementFingerprint fingerprint) {
        Map<String, String> structureAttrs = fingerprint.getStructureAttributes();
        
        DomStructure structure = new DomStructure();
        structure.setTagName(fingerprint.getTagName());
        structure.setXPath(structureAttrs.getOrDefault("xpath", ""));
        structure.setRelativeXPath(structureAttrs.getOrDefault("relativeXPath", ""));
        structure.setAncestorTagPath(structureAttrs.getOrDefault("ancestorTagPath", ""));
        structure.setSiblingIndex(Integer.parseInt(structureAttrs.getOrDefault("siblingIndex", "0")));
        structure.setSiblingCount(Integer.parseInt(structureAttrs.getOrDefault("siblingCount", "0")));
        
        // Parse ancestor information
        for (int i = 1; i <= maxAncestorLevel; i++) {
            String ancestorKey = "ancestor" + i;
            if (structureAttrs.containsKey(ancestorKey)) {
                structure.getAncestors().add(structureAttrs.get(ancestorKey));
            }
        }
        
        // Parse sibling information
        for (int i = 1; i <= maxSiblings; i++) {
            String siblingTagKey = "siblingTag" + i;
            String siblingClassKey = "siblingClass" + i;
            
            if (structureAttrs.containsKey(siblingTagKey)) {
                structure.getSiblingTags().add(structureAttrs.get(siblingTagKey));
                
                if (structureAttrs.containsKey(siblingClassKey)) {
                    structure.getSiblingClasses().add(structureAttrs.get(siblingClassKey));
                } else {
                    structure.getSiblingClasses().add("");
                }
            }
        }
        
        // Parse child information if available
        if (includeChildStructures) {
            for (int i = 1; i <= maxChildDepth; i++) {
                String childCountKey = "childCount" + i;
                if (structureAttrs.containsKey(childCountKey)) {
                    structure.getChildCounts().add(Integer.parseInt(structureAttrs.get(childCountKey)));
                }
                
                String childTagsKey = "childTags" + i;
                if (structureAttrs.containsKey(childTagsKey)) {
                    structure.getChildTagLists().add(structureAttrs.get(childTagsKey));
                }
            }
        }
        
        return structure;
    }
    
    /**
     * Finds all potential elements on the page to consider for healing
     */
    private List<WebElement> findAllPotentialElements(WebDriver driver) {
        try {
            return driver.findElements(By.xpath("//*"));
        } catch (Exception e) {
            LOGGER.error("Error finding potential elements", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Scores candidate elements based on structural similarity to the original element
     */
    private List<ScoredElement> scoreCandidates(WebDriver driver, List<WebElement> candidates, DomStructure originalStructure) {
        List<ScoredElement> scoredElements = new ArrayList<>();
        
        for (WebElement candidate : candidates) {
            try {
                // Get or create structure for this candidate
                String elementId = getCacheKey(candidate);
                DomStructure candidateStructure = structureCache.computeIfAbsent(elementId, 
                        k -> createStructureFromElement(driver, candidate));
                
                // Skip empty structures (failed to analyze)
                if (candidateStructure.isEmpty()) {
                    continue;
                }
                
                // Calculate similarity score
                double score = calculateStructuralSimilarity(originalStructure, candidateStructure);
                
                if (score > 0) {
                    scoredElements.add(new ScoredElement(candidate, score));
                }
            } catch (Exception e) {
                // Log and continue with next candidate
                LOGGER.debug("Error scoring candidate element", e);
            }
        }
        
        return scoredElements;
    }
    
    /**
     * Creates a unique key for caching structure information
     */
    private String getCacheKey(WebElement element) {
        try {
            return element.toString();
        } catch (Exception e) {
            // Fallback to hashcode if toString fails
            return "element-" + element.hashCode();
        }
    }
    
    /**
     * Creates a DOM structure representation from a web element
     */
    private DomStructure createStructureFromElement(WebDriver driver, WebElement element) {
        DomStructure structure = new DomStructure();
        
        try {
            // Basic element information
            structure.setTagName(element.getTagName().toLowerCase());
            
            // Get XPath information using JavaScript execution
            String xpath = (String) executeScript(driver, 
                    "function getPathTo(element) {" +
                    "    if (element.id !== '')" +
                    "        return '//*[@id=\"' + element.id + '\"]';" +
                    "    if (element === document.body)" +
                    "        return '/html/body';" +
                    "    var index = 0;" +
                    "    var siblings = element.parentNode.childNodes;" +
                    "    for (var i = 0; i < siblings.length; i++) {" +
                    "        var sibling = siblings[i];" +
                    "        if (sibling === element)" +
                    "            return getPathTo(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (index + 1) + ']';" +
                    "        if (sibling.nodeType === 1 && sibling.tagName.toLowerCase() === element.tagName.toLowerCase())" +
                    "            index++;" +
                    "    }" +
                    "}", element);
            
            structure.setXPath(xpath != null ? xpath : "");
            
            // Get relative XPath
            String relativeXPath = (String) executeScript(driver,
                    "function getRelativePath(element, maxDepth) {" +
                    "    var path = '';" +
                    "    var currentElement = element;" +
                    "    var depth = 0;" +
                    "    while (currentElement && currentElement.tagName && depth < maxDepth) {" +
                    "        var tag = currentElement.tagName.toLowerCase();" +
                    "        var classes = currentElement.className;" +
                    "        var classString = '';" +
                    "        if (classes && typeof classes === 'string') {" +
                    "            classString = classes.split(' ').filter(c => c).map(c => '.' + c).join('');" +
                    "        }" +
                    "        path = tag + classString + (path ? ' > ' + path : '');" +
                    "        currentElement = currentElement.parentElement;" +
                    "        depth++;" +
                    "    }" +
                    "    return path;" +
                    "}", element, maxAncestorLevel);
            
            structure.setRelativeXPath(relativeXPath != null ? relativeXPath : "");
            
            // Get ancestor tag path
            String ancestorTagPath = (String) executeScript(driver,
                    "function getAncestorTagPath(element, maxDepth) {" +
                    "    var path = [];" +
                    "    var currentElement = element.parentElement;" +
                    "    var depth = 0;" +
                    "    while (currentElement && currentElement.tagName && depth < maxDepth) {" +
                    "        path.push(currentElement.tagName.toLowerCase());" +
                    "        currentElement = currentElement.parentElement;" +
                    "        depth++;" +
                    "    }" +
                    "    return path.join('>');" +
                    "}", element, maxAncestorLevel);
            
            structure.setAncestorTagPath(ancestorTagPath != null ? ancestorTagPath : "");
            
            // Get ancestor information
            List<String> ancestors = new ArrayList<>();
            for (int i = 0; i < maxAncestorLevel; i++) {
                String ancestor = (String) executeScript(driver,
                        "function getAncestorInfo(element, level) {" +
                        "    var current = element;" +
                        "    for (var i = 0; i <= level; i++) {" +
                        "        current = current.parentElement;" +
                        "        if (!current) return '';" +
                        "    }" +
                        "    var tag = current.tagName.toLowerCase();" +
                        "    var id = current.id ? '#' + current.id : '';" +
                        "    var classes = Array.from(current.classList).map(c => '.' + c).join('');" +
                        "    return tag + id + classes;" +
                        "}", element, i);
                
                if (ancestor != null && !ancestor.isEmpty()) {
                    ancestors.add(ancestor);
                }
            }
            structure.setAncestors(ancestors);
            
            // Get sibling information
            Object[] siblingInfo = (Object[]) executeScript(driver,
                    "function getSiblingInfo(element, maxSiblings) {" +
                    "    if (!element.parentElement) return { index: 0, count: 0, tags: [], classes: [] };" +
                    "    var siblings = Array.from(element.parentElement.children);" +
                    "    var index = siblings.indexOf(element);" +
                    "    var siblingTags = [];" +
                    "    var siblingClasses = [];" +
                    "    " +
                    "    // Get siblings before and after, up to maxSiblings" +
                    "    var startIdx = Math.max(0, index - Math.floor(maxSiblings/2));" +
                    "    var endIdx = Math.min(siblings.length - 1, index + Math.floor(maxSiblings/2));" +
                    "    " +
                    "    for (var i = startIdx; i <= endIdx; i++) {" +
                    "        if (i === index) continue; // Skip the element itself" +
                    "        var sibling = siblings[i];" +
                    "        siblingTags.push(sibling.tagName.toLowerCase());" +
                    "        siblingClasses.push(Array.from(sibling.classList).join(' '));" +
                    "    }" +
                    "    " +
                    "    return [index, siblings.length, siblingTags, siblingClasses];" +
                    "}", element, maxSiblings);
            
            if (siblingInfo != null && siblingInfo.length >= 4) {
                structure.setSiblingIndex(((Number) siblingInfo[0]).intValue());
                structure.setSiblingCount(((Number) siblingInfo[1]).intValue());
                
                Object[] siblingTags = (Object[]) siblingInfo[2];
                Object[] siblingClasses = (Object[]) siblingInfo[3];
                
                for (int i = 0; i < siblingTags.length && i < maxSiblings; i++) {
                    structure.getSiblingTags().add(siblingTags[i].toString());
                    structure.getSiblingClasses().add(siblingClasses[i].toString());
                }
            }
            
            // Get child information if required
            if (includeChildStructures) {
                for (int depth = 1; depth <= maxChildDepth; depth++) {
                    Object[] childInfo = (Object[]) executeScript(driver,
                            "function getChildInfo(element, depth) {" +
                            "    function getChildrenAtDepth(el, d) {" +
                            "        if (d === 0) return [el];" +
                            "        var children = Array.from(el.children);" +
                            "        if (d === 1) return children;" +
                            "        var result = [];" +
                            "        for (var i = 0; i < children.length; i++) {" +
                            "            result = result.concat(getChildrenAtDepth(children[i], d - 1));" +
                            "        }" +
                            "        return result;" +
                            "    }" +
                            "    " +
                            "    var childrenAtDepth = getChildrenAtDepth(element, depth);" +
                            "    var childCount = childrenAtDepth.length;" +
                            "    var childTags = childrenAtDepth.map(c => c.tagName.toLowerCase()).join(',');" +
                            "    return [childCount, childTags];" +
                            "}", element, depth);
                    
                    if (childInfo != null && childInfo.length >= 2) {
                        structure.getChildCounts().add(((Number) childInfo[0]).intValue());
                        structure.getChildTagLists().add(childInfo[1].toString());
                    }
                }
            }
        } catch (Exception e) {
            LOGGER.debug("Error creating structure from element", e);
            // Return empty structure to indicate failure
            return new DomStructure();
        }
        
        return structure;
    }
    
    /**
     * Calculates the structural similarity between two DOM structures
     * 
     * @param original The original element's structure
     * @param candidate The candidate element's structure
     * @return A similarity score between 0.0 and 1.0
     */
    private double calculateStructuralSimilarity(DomStructure original, DomStructure candidate) {
        double score = 0.0;
        double totalWeight = 0.0;
        
        // Tag name exact match is a prerequisite
        if (!original.getTagName().equals(candidate.getTagName())) {
            return 0.0;
        }
        
        // Calculate tag name score (already confirmed to match)
        score += weights.getTagNameWeight();
        totalWeight += weights.getTagNameWeight();
        
        // Calculate ancestor path similarity
        if (!original.getAncestorTagPath().isEmpty() && !candidate.getAncestorTagPath().isEmpty()) {
            double ancestorPathScore = calculatePathSimilarity(
                    original.getAncestorTagPath(), 
                    candidate.getAncestorTagPath());
            score += ancestorPathScore * weights.getAncestorPathWeight();
            totalWeight += weights.getAncestorPathWeight();
        }
        
        // Calculate relative XPath similarity
        if (!original.getRelativeXPath().isEmpty() && !candidate.getRelativeXPath().isEmpty()) {
            double relativeXPathScore = calculatePathSimilarity(
                    original.getRelativeXPath(), 
                    candidate.getRelativeXPath());
            score += relativeXPathScore * weights.getRelativeXPathWeight();
            totalWeight += weights.getRelativeXPathWeight();
        }
        
        // Calculate sibling position similarity
        if (original.getSiblingCount() > 0 && candidate.getSiblingCount() > 0) {
            double siblingPositionScore = calculatePositionSimilarity(
                    original.getSiblingIndex(), original.getSiblingCount(),
                    candidate.getSiblingIndex(), candidate.getSiblingCount());
            score += siblingPositionScore * weights.getSiblingPositionWeight();
            totalWeight += weights.getSiblingPositionWeight();
        }
        
        // Calculate sibling tag similarity
        if (!original.getSiblingTags().isEmpty() && !candidate.getSiblingTags().isEmpty()) {
            double siblingTagScore = calculateListSimilarity(
                    original.getSiblingTags(), 
                    candidate.getSiblingTags());
            score += siblingTagScore * weights.getSiblingTagsWeight();
            totalWeight += weights.getSiblingTagsWeight();
        }
        
        // Calculate sibling class similarity
        if (!original.getSiblingClasses().isEmpty() && !candidate.getSiblingClasses().isEmpty()) {
            double siblingClassScore = calculateListSimilarity(
                    original.getSiblingClasses(), 
                    candidate.getSiblingClasses());
            score += siblingClassScore * weights.getSiblingClassesWeight();
            totalWeight += weights.getSiblingClassesWeight();
        }
        
        // Calculate ancestor similarity
        if (!original.getAncestors().isEmpty() && !candidate.getAncestors().isEmpty()) {
            double ancestorScore = calculateListSimilarity(
                    original.getAncestors(), 
                    candidate.getAncestors());
            score += ancestorScore * weights.getAncestorsWeight();
            totalWeight += weights.getAncestorsWeight();
        }
        
        // Calculate child structure similarity if enabled
        if (includeChildStructures && 
            !original.getChildCounts().isEmpty() && !candidate.getChildCounts().isEmpty() &&
            !original.getChildTagLists().isEmpty() && !candidate.getChildTagLists().isEmpty()) {
            
            // Child count similarity
            double childCountScore = calculateListSimilarity(
                    original.getChildCounts().stream().map(String::valueOf).collect(Collectors.toList()),
                    candidate.getChildCounts().stream().map(String::valueOf).collect(Collectors.toList()));
            score += childCountScore * weights.getChildCountsWeight();
            totalWeight += weights.getChildCountsWeight();
            
            // Child tags similarity
            double childTagsScore = calculateListSimilarity(
                    original.getChildTagLists(), 
                    candidate.getChildTagLists());
            score += childTagsScore * weights.getChildTagsWeight();
            totalWeight += weights.getChildTagsWeight();
        }
        
        // Normalize score by dividing by total weight
        return totalWeight > 0 ? score / totalWeight : 0.0;
    }
    
    /**
     * Calculates similarity between two paths based on their components
     */
    private double calculatePathSimilarity(String path1, String path2) {
        if (path1.equals(path2)) {
            return 1.0;
        }
        
        // Split the paths into components
        String[] components1 = path1.split("[>/]");
        String[] components2 = path2.split("[>/]");
        
        int maxLength = Math.max(components1.length, components2.length);
        if (maxLength == 0) {
            return 0.0;
        }
        
        // Use Levenshtein distance for component sequence
        int distance = calculateLevenshteinDistance(components1, components2);
        return 1.0 - ((double) distance / maxLength);
    }
    
    /**
     * Calculates similarity between sibling positions
     */
    private double calculatePositionSimilarity(int index1, int count1, int index2, int count2) {
        // If either count is 0, no valid comparison
        if (count1 == 0 || count2 == 0) {
            return 0.0;
        }
        
        // Calculate normalized positions (0.0 to 1.0)
        double normalizedPos1 = (double) index1 / count1;
        double normalizedPos2 = (double) index2 / count2;
        
        // Calculate absolute difference in normalized positions
        double positionDifference = Math.abs(normalizedPos1 - normalizedPos2);
        
        // Similarity = 1 - difference (difference ranges from 0.0 to 1.0)
        return 1.0 - positionDifference;
    }
    
    /**
     * Calculates similarity between two lists of strings
     */
    private double calculateListSimilarity(List<String> list1, List<String> list2) {
        if (list1.isEmpty() || list2.isEmpty()) {
            return 0.0;
        }
        
        // If lists are identical
        if (list1.equals(list2)) {
            return 1.0;
        }
        
        // Calculate Jaccard similarity
        Set<String> union = new HashSet<>(list1);
        union.addAll(list2);
        
        Set<String> intersection = new HashSet<>(list1);
        intersection.retainAll(list2);
        
        return (double) intersection.size() / union.size();
    }
    
    /**
     * Calculates Levenshtein distance between two string arrays
     */
    private int calculateLevenshteinDistance(String[] s1, String[] s2) {
        int m = s1.length;
        int n = s2.length;
        
        // Create a matrix of size (m+1) x (n+1)
        int[][] d = new int[m + 1][n + 1];
        
        // Initialize the first row and column
        for (int i = 0; i <= m; i++) {
            d[i][0] = i;
        }
        
        for (int j = 0; j <= n; j++) {
            d[0][j] = j;
        }
        
        // Fill the matrix
        for (int j = 1; j <= n; j++) {
            for (int i = 1; i <= m; i++) {
                int cost = s1[i - 1].equals(s2[j - 1]) ? 0 : 1;
                d[i][j] = Math.min(
                    Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1),
                    d[i - 1][j - 1] + cost
                );
            }
        }
        
        return d[m][n];
    }
    
    /**
     * Executes JavaScript in the browser
     */
    private Object executeScript(WebDriver driver, String script, Object... args) {
        try {
            if (driver instanceof org.openqa.selenium.JavascriptExecutor) {
                return ((org.openqa.selenium.JavascriptExecutor) driver).executeScript(script, args);
            }
        } catch (Exception e) {
            LOGGER.debug("JavaScript execution error", e);
        }
        return null;
    }
    
    @Override
    public String getName() {
        return "DOM Structure Healing Strategy";
    }
    
    @Override
    public boolean canHeal(ElementFingerprint fingerprint) {
        return fingerprint != null && 
               fingerprint.getStructureAttributes() != null && 
               !fingerprint.getStructureAttributes().isEmpty() &&
               fingerprint.getTagName() != null &&
               !fingerprint.getTagName().isEmpty();
    }
    
    /**
     * Class to hold DOM structure information for an element
     */
    private static class DomStructure {
        private String tagName = "";
        private String xPath = "";
        private String relativeXPath = "";
        private String ancestorTagPath = "";
        private int siblingIndex = 0;
        private int siblingCount = 0;
        private List<String> ancestors = new ArrayList<>();
        private List<String> siblingTags = new ArrayList<>();
        private List<String> siblingClasses = new ArrayList<>();
        private List<Integer> childCounts = new ArrayList<>();
        private List<String> childTagLists = new ArrayList<>();
        
        // Getters and setters
        public String getTagName() { return tagName; }
        public void setTagName(String tagName) { this.tagName = tagName; }
        
        public String getXPath() { return xPath; }
        public void setXPath(String xPath) { this.xPath = xPath; }
        
        public String getRelativeXPath() { return relativeXPath; }
        public void setRelativeXPath(String relativeXPath) { this.relativeXPath = relativeXPath; }
        
        public String getAncestorTagPath() { return ancestorTagPath; }
        public void setAncestorTagPath(String ancestorTagPath) { this.ancestorTagPath = ancestorTagPath; }
        
        public int getSiblingIndex() { return siblingIndex; }
        public void setSiblingIndex(int siblingIndex) { this.siblingIndex = siblingIndex; }
        
        public int getSiblingCount() { return siblingCount; }
        public void setSiblingCount(int siblingCount) { this.siblingCount = siblingCount; }
        
        public List<String> getAncestors() { return ancestors; }
        public void setAncestors(List<String> ancestors) { this.ancestors = ancestors; }
        
        public List<String> getSiblingTags() { return siblingTags; }
        public void setSiblingTags(List<String> siblingTags) { this.siblingTags = siblingTags; }
        
        public List<String> getSiblingClasses() { return siblingClasses; }
        public void setSiblingClasses(List<String> siblingClasses) { this.siblingClasses = siblingClasses; }
        
        public List<Integer> getChildCounts() { return childCounts; }
        public void setChildCounts(List<Integer> childCounts) { this.childCounts = childCounts; }
        
        public List<String> getChildTagLists() { return childTagLists; }
        public void setChildTagLists(List<String> childTagLists) { this.childTagLists = childTagLists; }
        
        /**
         * Checks if this structure is empty (failed to analyze)
         */
        public boolean isEmpty() {
            return tagName.isEmpty() && xPath.isEmpty() && relativeXPath.isEmpty() && ancestorTagPath.isEmpty();
        }
    }
    
    /**
     * Class to represent a weighted element with its similarity score
     */
    private static class ScoredElement {
        private final WebElement element;
        private final double score;
        
        public ScoredElement(WebElement element, double score) {
            this.element = element;
            this.score = score;
        }
        
        public WebElement getElement() { return element; }
        public double getScore() { return score; }
    }
    
    /**
     * Configuration class for structural aspect weights
     */
    public static class StructureWeights {
        private double tagNameWeight = 1.0;
        private double ancestorPathWeight = 0.8;
        private double relativeXPathWeight = 0.9;
        private double siblingPositionWeight = 0.6;
        private double siblingTagsWeight = 0.7;
        private double siblingClassesWeight = 0.6;
        private double ancestorsWeight = 0.8;
        private double childCountsWeight = 0.5;
        private double childTagsWeight = 0.7;
        
        // Default constructor with default weights
        public StructureWeights() {}
        
        // Constructor with custom weights
        public StructureWeights(double tagNameWeight, double ancestorPathWeight, 
                               double relativeXPathWeight, double siblingPositionWeight,
                               double siblingTagsWeight, double siblingClassesWeight,
                               double ancestorsWeight, double childCountsWeight,
                               double childTagsWeight) {
            this.tagNameWeight = tagNameWeight;
            this.ancestorPathWeight = ancestorPathWeight;
            this.relativeXPathWeight = relativeXPathWeight;
            this.siblingPositionWeight = siblingPositionWeight;
            this.siblingTagsWeight = siblingTagsWeight;
            this.siblingClassesWeight = siblingClassesWeight;
            this.ancestorsWeight = ancestorsWeight;
            this.childCountsWeight = childCountsWeight;
            this.childTagsWeight = childTagsWeight;
        }
        
        // Getters
        public double getTagNameWeight() { return tagNameWeight; }
        public double getAncestorPathWeight() { return ancestorPathWeight; }
        public double getRelativeXPathWeight() { return relativeXPathWeight; }
        public double getSiblingPositionWeight() { return siblingPositionWeight; }
        public double getSiblingTagsWeight() { return siblingTagsWeight; }
        public double getSiblingClassesWeight() { return siblingClassesWeight; }
        public double getAncestorsWeight() { return ancestorsWeight; }
        public double getChildCountsWeight() { return childCountsWeight; }
        public double getChildTagsWeight() { return childTagsWeight; }
        
        // Builder pattern for fluent API
        public static class Builder {
            private double tagNameWeight = 1.0;
            private double ancestorPathWeight = 0.8;
            private double relativeXPathWeight = 0.9;
            private double siblingPositionWeight = 0.6;
            private double siblingTagsWeight = 0.7;
            private double siblingClassesWeight = 0.6;
            private double ancestorsWeight = 0.8;
            private double childCountsWeight = 0.5;
            private double childTagsWeight = 0.7;
            
            public Builder tagNameWeight(double weight) {
                this.tagNameWeight = weight;
                return this;
            }
            
            public Builder ancestorPathWeight(double weight) {
                this.ancestorPathWeight = weight;
                return this;
            }
            
            public Builder relativeXPathWeight(double weight) {
                this.relativeXPathWeight = weight;
                return this;
            }
            
            public Builder siblingPositionWeight(double weight) {
                this.siblingPositionWeight = weight;
                return this;
            }
            
            public Builder siblingTagsWeight(double weight) {
                this.siblingTagsWeight = weight;
                return this;
            }
            
            public Builder siblingClassesWeight(double weight) {
                this.siblingClassesWeight = weight;
                return this;
            }
            
            public Builder ancestorsWeight(double weight) {
                this.ancestorsWeight = weight;
                return this;
            }
            
            public Builder childCountsWeight(double weight) {
                this.childCountsWeight = weight;
                return this;
            }
            
            public Builder childTagsWeight(double weight) {
                this.childTagsWeight = weight;
                return this;
            }
            
            public StructureWeights build() {
                return new StructureWeights(
                    tagNameWeight, ancestorPathWeight, relativeXPathWeight,
                    siblingPositionWeight, siblingTagsWeight, siblingClassesWeight,
                    ancestorsWeight, childCountsWeight, childTagsWeight
                );
            }
        }
    }
}
