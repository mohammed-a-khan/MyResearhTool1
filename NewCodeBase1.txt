// com/cstestforge/framework/selenium/java/browser/CSWebDriverManager.java
package com.cstestforge.framework.selenium.java.browser;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.safari.SafariDriver;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.remote.SessionId;
import org.openqa.selenium.support.events.EventFiringDecorator;
import org.openqa.selenium.support.events.WebDriverListener;
import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.selenium.java.listeners.CSWebDriverEventListener;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;
import java.util.stream.Collectors;

/**
 * Manages WebDriver instances for Selenium tests.
 * This class is thread-safe and supports parallel test execution.
 */
public class CSWebDriverManager {
    private static final CSWebDriverManager INSTANCE = new CSWebDriverManager();
    private final Map<Long, WebDriver> driverMap = new ConcurrentHashMap<>();
    private final Map<String, Supplier<WebDriver>> driverFactories = new HashMap<>();
    private final CSBrowserManager browserManager;
    private final CSCapabilityManager capabilityManager;
    private final ThreadLocal<WebDriver> threadLocalDriver = new ThreadLocal<>();
    private final CSLogger logger = new CSLogger(CSWebDriverManager.class);
    private CSWebDriverEventListener eventListener;
    
    private CSWebDriverManager() {
        this.browserManager = CSBrowserManager.getInstance();
        this.capabilityManager = CSCapabilityManager.getInstance();
        this.eventListener = new CSWebDriverEventListener();
        initializeDriverFactories();
    }
    
    public static CSWebDriverManager getInstance() {
        return INSTANCE;
    }
    
    /**
     * Initializes the driver factories for different browser types.
     */
    private void initializeDriverFactories() {
        driverFactories.put("chrome", () -> new ChromeDriver(capabilityManager.getChromeOptions()));
        driverFactories.put("firefox", () -> new FirefoxDriver(capabilityManager.getFirefoxOptions()));
        driverFactories.put("edge", () -> new EdgeDriver(capabilityManager.getEdgeOptions()));
        driverFactories.put("safari", () -> new SafariDriver(capabilityManager.getSafariOptions()));
    }
    
    /**
     * Gets or creates a WebDriver instance for the current thread.
     * 
     * @return The WebDriver instance for the current thread
     */
    public synchronized WebDriver getDriver() {
        WebDriver driver = threadLocalDriver.get();
        if (driver == null) {
            driver = createDriver();
            threadLocalDriver.set(driver);
            driverMap.put(Thread.currentThread().getId(), driver);
            logger.info("Created new WebDriver instance for thread: " + Thread.currentThread().getId());
        }
        return driver;
    }
    
    /**
     * Creates a new WebDriver instance based on configuration.
     * 
     * @return A new WebDriver instance
     */
    private WebDriver createDriver() {
        String browserType = ConfigurationManager.getInstance().getFrameworkConfig().getBrowserType().toLowerCase();
        boolean isRemote = ConfigurationManager.getInstance().getFrameworkConfig().isRemoteExecution();
        
        WebDriver driver;
        if (isRemote) {
            driver = new CSRemoteWebDriverFactory().createDriver(browserType, capabilityManager);
            logger.info("Created remote WebDriver instance for browser: " + browserType);
        } else {
            driver = createLocalDriver(browserType);
            logger.info("Created local WebDriver instance for browser: " + browserType);
        }
        
        configureDriver(driver);
        return wrapDriver(driver);
    }
    
    /**
     * Creates a local WebDriver instance for the specified browser type.
     * 
     * @param browserType The type of browser to create
     * @return A new WebDriver instance
     * @throws IllegalArgumentException if the browser type is not supported
     */
    private WebDriver createLocalDriver(String browserType) {
        Supplier<WebDriver> driverSupplier = driverFactories.get(browserType);
        if (driverSupplier == null) {
            throw new IllegalArgumentException("Unsupported browser type: " + browserType);
        }
        return new CSLocalWebDriverFactory().createDriver(browserType, capabilityManager);
    }
    
    /**
     * Configures a WebDriver instance with timeouts and window size.
     * 
     * @param driver The WebDriver instance to configure
     */
    private void configureDriver(WebDriver driver) {
        int implicitWaitSeconds = ConfigurationManager.getInstance().getFrameworkConfig().getImplicitWaitSeconds();
        int pageLoadTimeoutSeconds = ConfigurationManager.getInstance().getFrameworkConfig().getPageLoadTimeoutSeconds();
        int scriptTimeoutSeconds = ConfigurationManager.getInstance().getFrameworkConfig().getScriptTimeoutSeconds();
        boolean maximizeWindow = ConfigurationManager.getInstance().getFrameworkConfig().isMaximizeWindow();
        
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(implicitWaitSeconds));
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(pageLoadTimeoutSeconds));
        driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(scriptTimeoutSeconds));
        
        if (maximizeWindow) {
            driver.manage().window().maximize();
        } else {
            int windowWidth = ConfigurationManager.getInstance().getFrameworkConfig().getWindowWidth();
            int windowHeight = ConfigurationManager.getInstance().getFrameworkConfig().getWindowHeight();
            if (windowWidth > 0 && windowHeight > 0) {
                driver.manage().window().setSize(new org.openqa.selenium.Dimension(windowWidth, windowHeight));
            }
        }
        
        // Clear cookies if specified in configuration
        if (ConfigurationManager.getInstance().getFrameworkConfig().isClearCookies()) {
            driver.manage().deleteAllCookies();
        }
    }
    
    /**
     * Wraps a WebDriver instance with event listener for logging and monitoring.
     * 
     * @param driver The WebDriver instance to wrap
     * @return The wrapped WebDriver instance
     */
    private WebDriver wrapDriver(WebDriver driver) {
        if (ConfigurationManager.getInstance().getFrameworkConfig().isEnableEventListener()) {
            return new EventFiringDecorator(eventListener).decorate(driver);
        }
        return driver;
    }
    
    /**
     * Quits the WebDriver instance for the current thread.
     */
    public void quitDriver() {
        WebDriver driver = threadLocalDriver.get();
        if (driver != null) {
            try {
                driver.quit();
                logger.info("WebDriver instance quit for thread: " + Thread.currentThread().getId());
            } catch (Exception e) {
                logger.error("Error quitting WebDriver: " + e.getMessage(), e);
            } finally {
                threadLocalDriver.remove();
                driverMap.remove(Thread.currentThread().getId());
            }
        }
    }
    
    /**
     * Quits all WebDriver instances.
     */
    public void quitAllDrivers() {
        for (Map.Entry<Long, WebDriver> entry : driverMap.entrySet()) {
            try {
                WebDriver driver = entry.getValue();
                if (driver != null) {
                    driver.quit();
                    logger.info("WebDriver instance quit for thread: " + entry.getKey());
                }
            } catch (Exception e) {
                logger.error("Error quitting WebDriver for thread " + entry.getKey() + ": " + e.getMessage(), e);
            }
        }
        driverMap.clear();
        threadLocalDriver.remove();
    }
    
    /**
     * Gets the total number of active WebDriver instances.
     * 
     * @return The number of active WebDriver instances
     */
    public int getActiveDriverCount() {
        return driverMap.size();
    }
    
    /**
     * Gets all active session IDs.
     * 
     * @return A set of all active session IDs
     */
    public Set<String> getActiveSessionIds() {
        return driverMap.values().stream()
                .filter(driver -> driver instanceof RemoteWebDriver)
                .map(driver -> ((RemoteWebDriver) driver).getSessionId())
                .filter(Objects::nonNull)
                .map(SessionId::toString)
                .collect(Collectors.toSet());
    }
    
    /**
     * Checks if a WebDriver instance exists for the current thread.
     * 
     * @return true if a WebDriver instance exists, false otherwise
     */
    public boolean hasDriver() {
        return threadLocalDriver.get() != null;
    }
    
    /**
     * Sets a custom event listener for WebDriver events.
     * 
     * @param eventListener The event listener to set
     */
    public void setEventListener(CSWebDriverEventListener eventListener) {
        this.eventListener = eventListener;
    }
}



// com/cstestforge/framework/selenium/java/browser/CSBrowserManager.java
package com.cstestforge.framework.selenium.java.browser;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.StaleElementReferenceException;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.Cookie;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSScreenshotManager;

import java.io.File;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Provides a high-level browser interface for Selenium WebDriver.
 * This class encapsulates common browser operations and provides additional functionality.
 */
public class CSBrowserManager {
    private static final CSBrowserManager INSTANCE = new CSBrowserManager();
    private final CSWebDriverManager webDriverManager;
    private final CSLogger logger = new CSLogger(CSBrowserManager.class);
    private final CSScreenshotManager screenshotManager;
    
    private CSBrowserManager() {
        this.webDriverManager = CSWebDriverManager.getInstance();
        this.screenshotManager = new CSScreenshotManager();
    }
    
    public static CSBrowserManager getInstance() {
        return INSTANCE;
    }
    
    /**
     * Gets the WebDriver instance for the current thread.
     * 
     * @return The WebDriver instance for the current thread
     */
    public WebDriver getDriver() {
        return webDriverManager.getDriver();
    }
    
    /**
     * Navigates to the specified URL.
     * 
     * @param url The URL to navigate to
     */
    public void navigateTo(String url) {
        logger.info("Navigating to URL: " + url);
        getDriver().get(url);
    }
    
    /**
     * Refreshes the current page.
     */
    public void refresh() {
        logger.info("Refreshing current page");
        getDriver().navigate().refresh();
    }
    
    /**
     * Navigates back in the browser history.
     */
    public void back() {
        logger.info("Navigating back in browser history");
        getDriver().navigate().back();
    }
    
    /**
     * Navigates forward in the browser history.
     */
    public void forward() {
        logger.info("Navigating forward in browser history");
        getDriver().navigate().forward();
    }
    
    /**
     * Gets the current URL.
     * 
     * @return The current URL
     */
    public String getCurrentUrl() {
        return getDriver().getCurrentUrl();
    }
    
    /**
     * Gets the title of the current page.
     * 
     * @return The title of the current page
     */
    public String getTitle() {
        return getDriver().getTitle();
    }
    
    /**
     * Takes a screenshot of the current page.
     * 
     * @param fileName The name to give the screenshot file
     * @return The absolute path to the screenshot file
     */
    public String takeScreenshot(String fileName) {
        logger.info("Taking screenshot: " + fileName);
        File screenshotFile = ((TakesScreenshot) getDriver()).getScreenshotAs(OutputType.FILE);
        return screenshotManager.saveScreenshot(screenshotFile, fileName);
    }
    
    /**
     * Takes a screenshot of the current page and embeds it in the test report.
     * 
     * @param stepName The step name to associate with the screenshot
     */
    public void takeScreenshotForReport(String stepName) {
        String screenshotPath = takeScreenshot(stepName + "_" + System.currentTimeMillis());
        logger.info("Screenshot saved for reporting: " + screenshotPath);
        // Additional integration with reporting framework can be added here
    }
    
    /**
     * Executes JavaScript in the current page.
     * 
     * @param script The JavaScript to execute
     * @param args The arguments to pass to the script
     * @return The result of the script execution
     */
    public Object executeJavaScript(String script, Object... args) {
        logger.debug("Executing JavaScript: " + script);
        return ((JavascriptExecutor) getDriver()).executeScript(script, args);
    }
    
    /**
     * Executes JavaScript asynchronously in the current page.
     * 
     * @param script The JavaScript to execute
     * @param args The arguments to pass to the script
     * @return The result of the script execution
     */
    public Object executeAsyncJavaScript(String script, Object... args) {
        logger.debug("Executing async JavaScript: " + script);
        return ((JavascriptExecutor) getDriver()).executeAsyncScript(script, args);
    }
    
    /**
     * Scrolls to the specified element.
     * 
     * @param element The element to scroll to
     */
    public void scrollToElement(WebElement element) {
        logger.debug("Scrolling to element");
        executeJavaScript("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", element);
    }
    
    /**
     * Scrolls to the top of the page.
     */
    public void scrollToTop() {
        logger.debug("Scrolling to top of page");
        executeJavaScript("window.scrollTo({top: 0, behavior: 'smooth'});");
    }
    
    /**
     * Scrolls to the bottom of the page.
     */
    public void scrollToBottom() {
        logger.debug("Scrolling to bottom of page");
        executeJavaScript("window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'});");
    }
    
    /**
     * Creates a new WebDriverWait instance with the default timeout.
     * 
     * @return A new WebDriverWait instance
     */
    public WebDriverWait getWait() {
        int timeoutSeconds = ConfigurationManager.getInstance().getFrameworkConfig().getExplicitWaitSeconds();
        return new WebDriverWait(getDriver(), Duration.ofSeconds(timeoutSeconds));
    }
    
    /**
     * Creates a new WebDriverWait instance with the specified timeout.
     * 
     * @param timeoutSeconds The timeout in seconds
     * @return A new WebDriverWait instance
     */
    public WebDriverWait getWait(int timeoutSeconds) {
        return new WebDriverWait(getDriver(), Duration.ofSeconds(timeoutSeconds));
    }
    
    /**
     * Waits for a condition to be true.
     * 
     * @param <T> The type of the expected condition's return value
     * @param condition The condition to wait for
     * @return The value returned by the condition function
     */
    public <T> T waitFor(Function<WebDriver, T> condition) {
        return getWait().until(condition);
    }
    
    /**
     * Waits for a condition to be true with the specified timeout.
     * 
     * @param <T> The type of the expected condition's return value
     * @param condition The condition to wait for
     * @param timeoutSeconds The timeout in seconds
     * @return The value returned by the condition function
     */
    public <T> T waitFor(Function<WebDriver, T> condition, int timeoutSeconds) {
        return getWait(timeoutSeconds).until(condition);
    }
    
    /**
     * Waits for an element to be visible.
     * 
     * @param element The element to wait for
     * @return The element once it is visible
     */
    public WebElement waitForVisibility(WebElement element) {
        return getWait().until(ExpectedConditions.visibilityOf(element));
    }
    
    /**
     * Waits for an element to be clickable.
     * 
     * @param element The element to wait for
     * @return The element once it is clickable
     */
    public WebElement waitForClickable(WebElement element) {
        return getWait().until(ExpectedConditions.elementToBeClickable(element));
    }
    
    /**
     * Gets all cookies from the current session.
     * 
     * @return All cookies from the current session
     */
    public Set<Cookie> getAllCookies() {
        return getDriver().manage().getCookies();
    }
    
    /**
     * Gets a cookie by name.
     * 
     * @param cookieName The name of the cookie to get
     * @return The cookie, or null if it does not exist
     */
    public Cookie getCookieByName(String cookieName) {
        return getDriver().manage().getCookieNamed(cookieName);
    }
    
    /**
     * Adds a cookie to the current session.
     * 
     * @param cookie The cookie to add
     */
    public void addCookie(Cookie cookie) {
        getDriver().manage().addCookie(cookie);
        logger.debug("Added cookie: " + cookie.getName());
    }
    
    /**
     * Deletes a cookie by name.
     * 
     * @param cookieName The name of the cookie to delete
     */
    public void deleteCookie(String cookieName) {
        getDriver().manage().deleteCookieNamed(cookieName);
        logger.debug("Deleted cookie: " + cookieName);
    }
    
    /**
     * Deletes all cookies from the current session.
     */
    public void deleteAllCookies() {
        getDriver().manage().deleteAllCookies();
        logger.debug("Deleted all cookies");
    }
    
    /**
     * Switches to a frame by index.
     * 
     * @param frameIndex The index of the frame to switch to
     * @return The WebDriver instance after switching
     */
    public WebDriver switchToFrame(int frameIndex) {
        logger.debug("Switching to frame by index: " + frameIndex);
        return getDriver().switchTo().frame(frameIndex);
    }
    
    /**
     * Switches to a frame by name or ID.
     * 
     * @param nameOrId The name or ID of the frame to switch to
     * @return The WebDriver instance after switching
     */
    public WebDriver switchToFrame(String nameOrId) {
        logger.debug("Switching to frame by name or ID: " + nameOrId);
        return getDriver().switchTo().frame(nameOrId);
    }
    
    /**
     * Switches to a frame by WebElement.
     * 
     * @param frameElement The WebElement representing the frame to switch to
     * @return The WebDriver instance after switching
     */
    public WebDriver switchToFrame(WebElement frameElement) {
        logger.debug("Switching to frame by WebElement");
        return getDriver().switchTo().frame(frameElement);
    }
    
    /**
     * Switches to the parent frame.
     * 
     * @return The WebDriver instance after switching
     */
    public WebDriver switchToParentFrame() {
        logger.debug("Switching to parent frame");
        return getDriver().switchTo().parentFrame();
    }
    
    /**
     * Switches to the default content.
     * 
     * @return The WebDriver instance after switching
     */
    public WebDriver switchToDefaultContent() {
        logger.debug("Switching to default content");
        return getDriver().switchTo().defaultContent();
    }
    
    /**
     * Gets all window handles in the current session.
     * 
     * @return All window handles in the current session
     */
    public Set<String> getWindowHandles() {
        return getDriver().getWindowHandles();
    }
    
    /**
     * Gets the current window handle.
     * 
     * @return The current window handle
     */
    public String getWindowHandle() {
        return getDriver().getWindowHandle();
    }
    
    /**
     * Switches to a window by handle.
     * 
     * @param windowHandle The handle of the window to switch to
     * @return The WebDriver instance after switching
     */
    public WebDriver switchToWindow(String windowHandle) {
        logger.debug("Switching to window: " + windowHandle);
        return getDriver().switchTo().window(windowHandle);
    }
    
    /**
     * Switches to a new window.
     * 
     * @return The WebDriver instance after switching
     * @throws IllegalStateException if there is no new window
     */
    public WebDriver switchToNewWindow() {
        String currentHandle = getWindowHandle();
        Set<String> handles = getWindowHandles();
        
        for (String handle : handles) {
            if (!handle.equals(currentHandle)) {
                logger.debug("Switching to new window: " + handle);
                return switchToWindow(handle);
            }
        }
        
        throw new IllegalStateException("No new window found");
    }
    
    /**
     * Closes the current window and switches to another window if available.
     * 
     * @return The WebDriver instance after switching, or null if no more windows
     */
    public WebDriver closeCurrentWindowAndSwitchToAnother() {
        String currentHandle = getWindowHandle();
        Set<String> handles = getWindowHandles();
        
        getDriver().close();
        logger.debug("Closed current window: " + currentHandle);
        
        handles.remove(currentHandle);
        if (!handles.isEmpty()) {
            String newHandle = handles.iterator().next();
            logger.debug("Switching to window: " + newHandle);
            return switchToWindow(newHandle);
        }
        
        logger.debug("No more windows to switch to");
        return null;
    }
    
    /**
     * Maximizes the current window.
     */
    public void maximizeWindow() {
        logger.debug("Maximizing window");
        getDriver().manage().window().maximize();
    }
    
    /**
     * Sets the size of the current window.
     * 
     * @param width The width in pixels
     * @param height The height in pixels
     */
    public void setWindowSize(int width, int height) {
        logger.debug("Setting window size to " + width + "x" + height);
        getDriver().manage().window().setSize(new org.openqa.selenium.Dimension(width, height));
    }
    
    /**
     * Gets the page source of the current page.
     * 
     * @return The page source of the current page
     */
    public String getPageSource() {
        return getDriver().getPageSource();
    }
    
    /**
     * Creates a new Actions instance for the current WebDriver.
     * 
     * @return A new Actions instance
     */
    public Actions getActions() {
        return new Actions(getDriver());
    }
    
    /**
     * Hovers over an element.
     * 
     * @param element The element to hover over
     */
    public void hoverOverElement(WebElement element) {
        logger.debug("Hovering over element");
        getActions().moveToElement(element).perform();
    }
    
    /**
     * Performs a right-click on an element.
     * 
     * @param element The element to right-click
     */
    public void rightClickElement(WebElement element) {
        logger.debug("Right-clicking element");
        getActions().contextClick(element).perform();
    }
    
    /**
     * Performs a double-click on an element.
     * 
     * @param element The element to double-click
     */
    public void doubleClickElement(WebElement element) {
        logger.debug("Double-clicking element");
        getActions().doubleClick(element).perform();
    }
    
    /**
     * Performs a drag-and-drop operation.
     * 
     * @param source The source element
     * @param target The target element
     */
    public void dragAndDrop(WebElement source, WebElement target) {
        logger.debug("Performing drag and drop");
        getActions().dragAndDrop(source, target).perform();
    }
    
    /**
     * Quits the WebDriver instance for the current thread.
     */
    public void quit() {
        logger.info("Quitting WebDriver");
        webDriverManager.quitDriver();
    }
    
    /**
     * Quits all WebDriver instances.
     */
    public void quitAll() {
        logger.info("Quitting all WebDriver instances");
        webDriverManager.quitAllDrivers();
    }
}



// com/cstestforge/framework/selenium/java/browser/CSCapabilityManager.java
package com.cstestforge.framework.selenium.java.browser;

import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.edge.EdgeOptions;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.safari.SafariOptions;
import org.openqa.selenium.ie.InternetExplorerOptions;
import org.openqa.selenium.MutableCapabilities;
import org.openqa.selenium.PageLoadStrategy;
import org.openqa.selenium.UnexpectedAlertBehaviour;
import org.openqa.selenium.remote.CapabilityType;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Manages browser capabilities for Selenium WebDriver.
 * This class encapsulates browser-specific capabilities and options.
 */
public class CSCapabilityManager {
    private static final CSCapabilityManager INSTANCE = new CSCapabilityManager();
    private final CSLogger logger = new CSLogger(CSCapabilityManager.class);
    
    private CSCapabilityManager() {
        logger.debug("Initializing CSCapabilityManager");
    }
    
    public static CSCapabilityManager getInstance() {
        return INSTANCE;
    }
    
    /**
     * Gets Chrome options configured based on framework settings.
     * 
     * @return Chrome options
     */
    public ChromeOptions getChromeOptions() {
        logger.debug("Creating Chrome options");
        ChromeOptions options = new ChromeOptions();
        
        // Basic capabilities
        addBasicCapabilities(options);
        
        // Chrome-specific capabilities
        if (ConfigurationManager.getInstance().getFrameworkConfig().isHeadless()) {
            options.addArguments("--headless=new");
        }
        
        options.addArguments("--disable-dev-shm-usage");
        options.addArguments("--no-sandbox");
        options.addArguments("--disable-gpu");
        options.addArguments("--disable-extensions");
        options.addArguments("--disable-popup-blocking");
        
        if (ConfigurationManager.getInstance().getFrameworkConfig().isIncognito()) {
            options.addArguments("--incognito");
        }
        
        // Set download directory if configured
        String downloadDirectory = ConfigurationManager.getInstance().getFrameworkConfig().getDownloadDirectory();
        if (downloadDirectory != null && !downloadDirectory.isEmpty()) {
            Map<String, Object> prefs = new HashMap<>();
            prefs.put("download.default_directory", downloadDirectory);
            prefs.put("download.prompt_for_download", false);
            prefs.put("download.directory_upgrade", true);
            prefs.put("safebrowsing.enabled", true);
            options.setExperimentalOption("prefs", prefs);
        }
        
        // Set user agent if configured
        String userAgent = ConfigurationManager.getInstance().getFrameworkConfig().getUserAgent();
        if (userAgent != null && !userAgent.isEmpty()) {
            options.addArguments("--user-agent=" + userAgent);
        }
        
        // Set proxy if configured
        String proxyServer = ConfigurationManager.getInstance().getFrameworkConfig().getProxyServer();
        if (proxyServer != null && !proxyServer.isEmpty()) {
            options.addArguments("--proxy-server=" + proxyServer);
        }
        
        // Handle browser logging
        if (ConfigurationManager.getInstance().getFrameworkConfig().isEnableBrowserLogs()) {
            options.setCapability("goog:loggingPrefs", getLoggingPreferences());
        }
        
        // Add custom chrome arguments from configuration
        String[] chromeArgs = ConfigurationManager.getInstance().getFrameworkConfig().getChromeArguments();
        if (chromeArgs != null && chromeArgs.length > 0) {
            options.addArguments(chromeArgs);
        }
        
        // Add custom chrome extensions from configuration
        String[] chromeExtensions = ConfigurationManager.getInstance().getFrameworkConfig().getChromeExtensions();
        if (chromeExtensions != null && chromeExtensions.length > 0) {
            for (String extension : chromeExtensions) {
                options.addExtensions(new java.io.File(extension));
            }
        }
        
        // Add experimental options from configuration
        Map<String, Object> experimentalOptions = ConfigurationManager.getInstance().getFrameworkConfig().getChromeExperimentalOptions();
        if (experimentalOptions != null && !experimentalOptions.isEmpty()) {
            experimentalOptions.forEach(options::setExperimentalOption);
        }
        
        logger.debug("Chrome options created: " + options);
        return options;
    }
    
    /**
     * Gets Firefox options configured based on framework settings.
     * 
     * @return Firefox options
     */
    public FirefoxOptions getFirefoxOptions() {
        logger.debug("Creating Firefox options");
        FirefoxOptions options = new FirefoxOptions();
        
        // Basic capabilities
        addBasicCapabilities(options);
        
        // Firefox-specific capabilities
        if (ConfigurationManager.getInstance().getFrameworkConfig().isHeadless()) {
            options.addArguments("--headless");
        }
        
        // Set download directory if configured
        String downloadDirectory = ConfigurationManager.getInstance().getFrameworkConfig().getDownloadDirectory();
        if (downloadDirectory != null && !downloadDirectory.isEmpty()) {
            options.addPreference("browser.download.folderList", 2);
            options.addPreference("browser.download.dir", downloadDirectory);
            options.addPreference("browser.download.useDownloadDir", true);
            options.addPreference("browser.helperApps.neverAsk.saveToDisk", 
                    "application/octet-stream,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,"
                    + "application/pdf,text/csv,application/zip,application/x-zip,application/x-zip-compressed");
        }
        
        // Set user agent if configured
        String userAgent = ConfigurationManager.getInstance().getFrameworkConfig().getUserAgent();
        if (userAgent != null && !userAgent.isEmpty()) {
            options.addPreference("general.useragent.override", userAgent);
        }
        
        // Handle browser logging
        if (ConfigurationManager.getInstance().getFrameworkConfig().isEnableBrowserLogs()) {
            options.setCapability("moz:firefoxOptions", Map.of("log", Map.of("level", "trace")));
        }
        
        // Add custom firefox preferences from configuration
        Map<String, Object> firefoxPreferences = ConfigurationManager.getInstance().getFrameworkConfig().getFirefoxPreferences();
        if (firefoxPreferences != null && !firefoxPreferences.isEmpty()) {
            firefoxPreferences.forEach((key, value) -> {
                if (value instanceof Boolean) {
                    options.addPreference(key, (Boolean) value);
                } else if (value instanceof Integer) {
                    options.addPreference(key, (Integer) value);
                } else if (value instanceof String) {
                    options.addPreference(key, (String) value);
                }
            });
        }
        
        // Add custom firefox arguments from configuration
        String[] firefoxArgs = ConfigurationManager.getInstance().getFrameworkConfig().getFirefoxArguments();
        if (firefoxArgs != null && firefoxArgs.length > 0) {
            options.addArguments(firefoxArgs);
        }
        
        logger.debug("Firefox options created: " + options);
        return options;
    }
    
    /**
     * Gets Edge options configured based on framework settings.
     * 
     * @return Edge options
     */
    public EdgeOptions getEdgeOptions() {
        logger.debug("Creating Edge options");
        EdgeOptions options = new EdgeOptions();
        
        // Basic capabilities
        addBasicCapabilities(options);
        
        // Edge-specific capabilities
        if (ConfigurationManager.getInstance().getFrameworkConfig().isHeadless()) {
            options.addArguments("--headless=new");
        }
        
        options.addArguments("--disable-dev-shm-usage");
        options.addArguments("--no-sandbox");
        options.addArguments("--disable-gpu");
        options.addArguments("--disable-extensions");
        options.addArguments("--disable-popup-blocking");
        
        if (ConfigurationManager.getInstance().getFrameworkConfig().isIncognito()) {
            options.addArguments("--inprivate");
        }
        
        // Set download directory if configured
        String downloadDirectory = ConfigurationManager.getInstance().getFrameworkConfig().getDownloadDirectory();
        if (downloadDirectory != null && !downloadDirectory.isEmpty()) {
            Map<String, Object> prefs = new HashMap<>();
            prefs.put("download.default_directory", downloadDirectory);
            prefs.put("download.prompt_for_download", false);
            prefs.put("download.directory_upgrade", true);
            prefs.put("safebrowsing.enabled", true);
            options.setExperimentalOption("prefs", prefs);
        }
        
        // Set user agent if configured
        String userAgent = ConfigurationManager.getInstance().getFrameworkConfig().getUserAgent();
        if (userAgent != null && !userAgent.isEmpty()) {
            options.addArguments("--user-agent=" + userAgent);
        }
        
        // Add custom edge arguments from configuration
        String[] edgeArgs = ConfigurationManager.getInstance().getFrameworkConfig().getEdgeArguments();
        if (edgeArgs != null && edgeArgs.length > 0) {
            options.addArguments(edgeArgs);
        }
        
        // Handle browser logging
        if (ConfigurationManager.getInstance().getFrameworkConfig().isEnableBrowserLogs()) {
            options.setCapability("ms:loggingPrefs", getLoggingPreferences());
        }
        
        logger.debug("Edge options created: " + options);
        return options;
    }
    
    /**
     * Gets Safari options configured based on framework settings.
     * 
     * @return Safari options
     */
    public SafariOptions getSafariOptions() {
        logger.debug("Creating Safari options");
        SafariOptions options = new SafariOptions();
        
        // Basic capabilities
        addBasicCapabilities(options);
        
        // Safari-specific capabilities
        options.setAutomaticInspection(false);
        
        // Handle browser logging if supported
        if (ConfigurationManager.getInstance().getFrameworkConfig().isEnableBrowserLogs()) {
            options.setCapability("safari:diagnose", true);
        }
        
        logger.debug("Safari options created: " + options);
        return options;
    }
    
    /**
     * Gets Internet Explorer options configured based on framework settings.
     * 
     * @return Internet Explorer options
     */
    public InternetExplorerOptions getInternetExplorerOptions() {
        logger.debug("Creating Internet Explorer options");
        InternetExplorerOptions options = new InternetExplorerOptions();
        
        // Basic capabilities
        addBasicCapabilities(options);
        
        // IE-specific capabilities
        options.setCapability(InternetExplorerOptions.IGNORE_ZOOM_SETTING, true);
        options.setCapability(InternetExplorerOptions.INTRODUCE_FLAKINESS_BY_IGNORING_SECURITY_DOMAINS, true);
        options.setCapability(InternetExplorerOptions.FORCE_CREATE_PROCESS, true);
        options.setCapability(InternetExplorerOptions.ENABLE_PERSISTENT_HOVERING, false);
        
        logger.debug("Internet Explorer options created: " + options);
        return options;
    }
    
    /**
     * Adds basic capabilities to the provided options.
     * 
     * @param options The options to add capabilities to
     */
    private void addBasicCapabilities(MutableCapabilities options) {
        // Set accept insecure certificates
        boolean acceptInsecureCerts = ConfigurationManager.getInstance().getFrameworkConfig().isAcceptInsecureCertificates();
        options.setCapability(CapabilityType.ACCEPT_INSECURE_CERTS, acceptInsecureCerts);
        
        // Set page load strategy
        String pageLoadStrategy = ConfigurationManager.getInstance().getFrameworkConfig().getPageLoadStrategy();
        if (pageLoadStrategy != null && !pageLoadStrategy.isEmpty()) {
            try {
                options.setCapability(CapabilityType.PAGE_LOAD_STRATEGY, PageLoadStrategy.valueOf(pageLoadStrategy.toUpperCase()));
            } catch (IllegalArgumentException e) {
                logger.warn("Invalid page load strategy: " + pageLoadStrategy + ". Using default.", e);
            }
        }
        
        // Set unexpected alert behavior
        String unexpectedAlertBehavior = ConfigurationManager.getInstance().getFrameworkConfig().getUnexpectedAlertBehavior();
        if (unexpectedAlertBehavior != null && !unexpectedAlertBehavior.isEmpty()) {
            try {
                options.setCapability(CapabilityType.UNHANDLED_PROMPT_BEHAVIOUR, 
                        UnexpectedAlertBehaviour.valueOf(unexpectedAlertBehavior.toUpperCase()));
            } catch (IllegalArgumentException e) {
                logger.warn("Invalid unexpected alert behavior: " + unexpectedAlertBehavior + ". Using default.", e);
            }
        }
        
        // Set timeouts if configured
        Integer scriptTimeout = ConfigurationManager.getInstance().getFrameworkConfig().getScriptTimeoutSeconds();
        if (scriptTimeout != null) {
            options.setCapability("timeouts", Map.of("script", scriptTimeout * 1000));
        }
    }
    
    /**
     * Gets logging preferences based on framework settings.
     * 
     * @return Logging preferences as a map
     */
    private Map<String, Object> getLoggingPreferences() {
        java.util.logging.Level logLevel = java.util.logging.Level.parse(
                ConfigurationManager.getInstance().getFrameworkConfig().getBrowserLogLevel());
        
        org.openqa.selenium.logging.LoggingPreferences logPrefs = new org.openqa.selenium.logging.LoggingPreferences();
        logPrefs.enable(org.openqa.selenium.logging.LogType.BROWSER, org.openqa.selenium.logging.Level.fromJulLevel(logLevel));
        logPrefs.enable(org.openqa.selenium.logging.LogType.DRIVER, org.openqa.selenium.logging.Level.fromJulLevel(logLevel));
        logPrefs.enable(org.openqa.selenium.logging.LogType.PERFORMANCE, org.openqa.selenium.logging.Level.fromJulLevel(logLevel));
        
        return Map.of("goog:loggingPrefs", logPrefs);
    }
    
    /**
     * Merges custom capabilities with existing options.
     * 
     * @param <T> The type of options
     * @param options The existing options
     * @param customCapabilities The custom capabilities to merge
     * @return The merged options
     */
    public <T extends MutableCapabilities> T mergeCustomCapabilities(T options, Map<String, Object> customCapabilities) {
        if (customCapabilities != null && !customCapabilities.isEmpty()) {
            customCapabilities.forEach(options::setCapability);
        }
        return options;
    }
}



// com/cstestforge/framework/selenium/java/browser/CSRemoteWebDriverFactory.java
package com.cstestforge.framework.selenium.java.browser;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.edge.EdgeOptions;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.ie.InternetExplorerOptions;
import org.openqa.selenium.safari.SafariOptions;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.remote.LocalFileDetector;
import org.openqa.selenium.remote.HttpCommandExecutor;
import org.openqa.selenium.remote.http.ClientConfig;
import org.openqa.selenium.MutableCapabilities;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;

import java.net.URL;
import java.net.MalformedURLException;
import java.time.Duration;

/**
 * Factory for creating RemoteWebDriver instances.
 * This class encapsulates the creation of remote WebDriver instances.
 */
public class CSRemoteWebDriverFactory {
    private final CSLogger logger = new CSLogger(CSRemoteWebDriverFactory.class);
    
    /**
     * Creates a RemoteWebDriver instance for the specified browser type.
     * 
     * @param browserType The type of browser to create
     * @param capabilityManager The capability manager to use
     * @return A new RemoteWebDriver instance
     * @throws RuntimeException if the remote URL is invalid or the browser type is not supported
     */
    public WebDriver createDriver(String browserType, CSCapabilityManager capabilityManager) {
        logger.info("Creating remote WebDriver for browser type: " + browserType);
        
        MutableCapabilities capabilities;
        switch (browserType.toLowerCase()) {
            case "chrome":
                capabilities = capabilityManager.getChromeOptions();
                break;
            case "firefox":
                capabilities = capabilityManager.getFirefoxOptions();
                break;
            case "edge":
                capabilities = capabilityManager.getEdgeOptions();
                break;
            case "safari":
                capabilities = capabilityManager.getSafariOptions();
                break;
            case "ie":
            case "internetexplorer":
                capabilities = capabilityManager.getInternetExplorerOptions();
                break;
            default:
                throw new IllegalArgumentException("Unsupported browser type for remote WebDriver: " + browserType);
        }
        
        // Add custom capabilities for the remote environment
        addRemoteCapabilities(capabilities, browserType);
        
        return createRemoteDriver(capabilities);
    }
    
    /**
     * Adds remote-specific capabilities to the provided capabilities.
     * 
     * @param capabilities The capabilities to add to
     * @param browserType The type of browser
     */
    private void addRemoteCapabilities(MutableCapabilities capabilities, String browserType) {
        // Add build name if provided in configuration
        String buildName = ConfigurationManager.getInstance().getFrameworkConfig().getRemoteBuildName();
        if (buildName != null && !buildName.isEmpty()) {
            capabilities.setCapability("build", buildName);
        }
        
        // Add project name if provided in configuration
        String projectName = ConfigurationManager.getInstance().getFrameworkConfig().getRemoteProjectName();
        if (projectName != null && !projectName.isEmpty()) {
            capabilities.setCapability("project", projectName);
        }
        
        // Add test name if provided in configuration
        String testName = ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTestName();
        if (testName != null && !testName.isEmpty()) {
            capabilities.setCapability("name", testName);
        }
        
        // Add platform if provided in configuration
        String platform = ConfigurationManager.getInstance().getFrameworkConfig().getRemotePlatform();
        if (platform != null && !platform.isEmpty()) {
            capabilities.setCapability("platform", platform);
        }
        
        // Add browser version if provided in configuration
        String browserVersion = ConfigurationManager.getInstance().getFrameworkConfig().getRemoteBrowserVersion();
        if (browserVersion != null && !browserVersion.isEmpty()) {
            capabilities.setCapability("version", browserVersion);
        }
        
        // Add Selenium version if provided in configuration
        String seleniumVersion = ConfigurationManager.getInstance().getFrameworkConfig().getRemoteSeleniumVersion();
        if (seleniumVersion != null && !seleniumVersion.isEmpty()) {
            capabilities.setCapability("seleniumVersion", seleniumVersion);
        }
        
        // Add custom remote capabilities from configuration
        capabilities.setCapability("enableVNC", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableVnc());
        capabilities.setCapability("enableVideo", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableVideo());
        capabilities.setCapability("enableLog", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableLogs());
        capabilities.setCapability("idleTimeout", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteIdleTimeout());
        
        // Add screenResolution if provided in configuration
        String screenResolution = ConfigurationManager.getInstance().getFrameworkConfig().getRemoteScreenResolution();
        if (screenResolution != null && !screenResolution.isEmpty()) {
            capabilities.setCapability("screenResolution", screenResolution);
        }
        
        // Add timeZone if provided in configuration
        String timeZone = ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTimeZone();
        if (timeZone != null && !timeZone.isEmpty()) {
            capabilities.setCapability("timeZone", timeZone);
        }
        
        // Add console log if enabled
        capabilities.setCapability("enableLog", ConfigurationManager.getInstance().getFrameworkConfig().isEnableBrowserLogs());
        
        // Additional cloud provider specific capabilities
        addCloudProviderCapabilities(capabilities, browserType);
    }
    
    /**
     * Adds cloud provider specific capabilities based on the remote provider configured.
     * 
     * @param capabilities The capabilities to add to
     * @param browserType The type of browser
     */
    private void addCloudProviderCapabilities(MutableCapabilities capabilities, String browserType) {
        String remoteProvider = ConfigurationManager.getInstance().getFrameworkConfig().getRemoteProvider();
        
        if (remoteProvider == null || remoteProvider.isEmpty()) {
            return;
        }
        
        switch (remoteProvider.toLowerCase()) {
            case "saucelabs":
                addSauceLabsCapabilities(capabilities, browserType);
                break;
            case "browserstack":
                addBrowserStackCapabilities(capabilities, browserType);
                break;
            case "lambdatest":
                addLambdaTestCapabilities(capabilities, browserType);
                break;
            case "grid":
                // Standard Selenium Grid, no additional capabilities needed
                break;
            case "selenoid":
                addSelenoidCapabilities(capabilities, browserType);
                break;
            default:
                logger.warn("Unknown remote provider: " + remoteProvider + ". No additional capabilities added.");
                break;
        }
    }
    
    /**
     * Adds SauceLabs specific capabilities.
     * 
     * @param capabilities The capabilities to add to
     * @param browserType The type of browser
     */
    private void addSauceLabsCapabilities(MutableCapabilities capabilities, String browserType) {
        logger.debug("Adding SauceLabs capabilities");
        
        capabilities.setCapability("sauce:options", Map.of(
            "username", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteUsername(),
            "accessKey", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteAccessKey(),
            "build", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteBuildName(),
            "name", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTestName(),
            "maxDuration", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteMaxDuration(),
            "idleTimeout", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteIdleTimeout(),
            "recordVideo", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableVideo(),
            "recordScreenshots", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableScreenshots(),
            "timeZone", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTimeZone(),
            "screenResolution", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteScreenResolution()
        ));
    }
    
    /**
     * Adds BrowserStack specific capabilities.
     * 
     * @param capabilities The capabilities to add to
     * @param browserType The type of browser
     */
    private void addBrowserStackCapabilities(MutableCapabilities capabilities, String browserType) {
        logger.debug("Adding BrowserStack capabilities");
        
        capabilities.setCapability("bstack:options", Map.of(
            "userName", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteUsername(),
            "accessKey", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteAccessKey(),
            "projectName", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteProjectName(),
            "buildName", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteBuildName(),
            "sessionName", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTestName(),
            "local", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteLocal(),
            "debug", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteDebug(),
            "networkLogs", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteNetworkLogs(),
            "consoleLogs", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteConsoleLogs(),
            "video", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableVideo(),
            "timezone", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTimeZone(),
            "resolution", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteScreenResolution()
        ));
    }
    
    /**
     * Adds LambdaTest specific capabilities.
     * 
     * @param capabilities The capabilities to add to
     * @param browserType The type of browser
     */
    private void addLambdaTestCapabilities(MutableCapabilities capabilities, String browserType) {
        logger.debug("Adding LambdaTest capabilities");
        
        capabilities.setCapability("LT:Options", Map.of(
            "username", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteUsername(),
            "accessKey", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteAccessKey(),
            "project", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteProjectName(),
            "build", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteBuildName(),
            "name", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTestName(),
            "platformName", ConfigurationManager.getInstance().getFrameworkConfig().getRemotePlatform(),
            "tunnel", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteLocal(),
            "video", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableVideo(),
            "visual", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableScreenshots(),
            "network", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteNetworkLogs(),
            "console", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteConsoleLogs(),
            "timezone", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTimeZone(),
            "resolution", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteScreenResolution()
        ));
    }
    
    /**
     * Adds Selenoid specific capabilities.
     * 
     * @param capabilities The capabilities to add to
     * @param browserType The type of browser
     */
    private void addSelenoidCapabilities(MutableCapabilities capabilities, String browserType) {
        logger.debug("Adding Selenoid capabilities");
        
        // Additional Selenoid capabilities
        Map<String, Object> selenoidOptions = new HashMap<>();
        selenoidOptions.put("enableVNC", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableVnc());
        selenoidOptions.put("enableVideo", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableVideo());
        selenoidOptions.put("enableLog", ConfigurationManager.getInstance().getFrameworkConfig().isRemoteEnableLogs());
        selenoidOptions.put("name", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTestName());
        selenoidOptions.put("timeZone", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTimeZone());
        selenoidOptions.put("screenResolution", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteScreenResolution());
        
        // Labels for Selenoid
        Map<String, Object> labels = new HashMap<>();
        labels.put("build", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteBuildName());
        labels.put("project", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteProjectName());
        labels.put("test", ConfigurationManager.getInstance().getFrameworkConfig().getRemoteTestName());
        selenoidOptions.put("labels", labels);
        
        capabilities.setCapability("selenoid:options", selenoidOptions);
    }
    
    /**
     * Creates a RemoteWebDriver instance with the provided capabilities.
     * 
     * @param capabilities The capabilities to use
     * @return A new RemoteWebDriver instance
     * @throws RuntimeException if the remote URL is invalid
     */
    private WebDriver createRemoteDriver(MutableCapabilities capabilities) {
        String remoteUrl = ConfigurationManager.getInstance().getFrameworkConfig().getRemoteUrl();
        if (remoteUrl == null || remoteUrl.isEmpty()) {
            throw new IllegalStateException("Remote URL is not configured");
        }
        
        try {
            URL url = new URL(remoteUrl);
            
            // Configure HTTP client
            ClientConfig clientConfig = ClientConfig.defaultConfig()
                .baseUrl(url)
                .readTimeout(Duration.ofSeconds(ConfigurationManager.getInstance().getFrameworkConfig().getRemoteCommandTimeout()));
            
            // Create command executor with client config
            HttpCommandExecutor executor = new HttpCommandExecutor(clientConfig);
            
            // Create RemoteWebDriver with the configured executor
            RemoteWebDriver driver = new RemoteWebDriver(executor, capabilities);
            
            // Set file detector for uploading files in remote sessions
            driver.setFileDetector(new LocalFileDetector());
            
            return driver;
        } catch (MalformedURLException e) {
            throw new RuntimeException("Invalid remote WebDriver URL: " + remoteUrl, e);
        }
    }
}


// com/cstestforge/framework/selenium/java/browser/CSLocalWebDriverFactory.java
package com.cstestforge.framework.selenium.java.browser;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeDriverService;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.edge.EdgeDriverService;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxDriverService;
import org.openqa.selenium.firefox.GeckoDriverService;
import org.openqa.selenium.ie.InternetExplorerDriver;
import org.openqa.selenium.ie.InternetExplorerDriverService;
import org.openqa.selenium.safari.SafariDriver;
import org.openqa.selenium.safari.SafariDriverService;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

/**
 * Factory for creating local WebDriver instances.
 * This class encapsulates the creation of local WebDriver instances.
 */
public class CSLocalWebDriverFactory {
    private final CSLogger logger = new CSLogger(CSLocalWebDriverFactory.class);
    private final Map<String, ChromeDriverService> chromeServices = new HashMap<>();
    private final Map<String, GeckoDriverService> firefoxServices = new HashMap<>();
    private final Map<String, EdgeDriverService> edgeServices = new HashMap<>();
    private final Map<String, InternetExplorerDriverService> ieServices = new HashMap<>();
    private final Map<String, SafariDriverService> safariServices = new HashMap<>();
    
    /**
     * Creates a local WebDriver instance for the specified browser type.
     * 
     * @param browserType The type of browser to create
     * @param capabilityManager The capability manager to use
     * @return A new WebDriver instance
     * @throws IllegalArgumentException if the browser type is not supported
     */
    public WebDriver createDriver(String browserType, CSCapabilityManager capabilityManager) {
        logger.info("Creating local WebDriver for browser type: " + browserType);
        
        switch (browserType.toLowerCase()) {
            case "chrome":
                return createChromeDriver(capabilityManager);
            case "firefox":
                return createFirefoxDriver(capabilityManager);
            case "edge":
                return createEdgeDriver(capabilityManager);
            case "safari":
                return createSafariDriver(capabilityManager);
            case "ie":
            case "internetexplorer":
                return createInternetExplorerDriver(capabilityManager);
            default:
                throw new IllegalArgumentException("Unsupported browser type: " + browserType);
        }
    }
    
    /**
     * Creates a ChromeDriver instance.
     * 
     * @param capabilityManager The capability manager to use
     * @return A new ChromeDriver instance
     */
    private WebDriver createChromeDriver(CSCapabilityManager capabilityManager) {
        logger.debug("Creating ChromeDriver");
        
        String driverPath = ConfigurationManager.getInstance().getFrameworkConfig().getChromeDriverPath();
        boolean useDriverManager = ConfigurationManager.getInstance().getFrameworkConfig().isUseDriverManager();
        
        if (!useDriverManager && (driverPath == null || driverPath.isEmpty())) {
            throw new IllegalStateException("Chrome driver path is not configured and driver manager is disabled");
        }
        
        if (!useDriverManager) {
            System.setProperty("webdriver.chrome.driver", driverPath);
        }
        
        String threadId = String.valueOf(Thread.currentThread().getId());
        
        ChromeDriverService service = ChromeDriverService.Builder()
                .withSilent(ConfigurationManager.getInstance().getFrameworkConfig().isDriverServiceSilent())
                .withLogFile(getDriverLogFile("chromedriver", threadId))
                .build();
        
        chromeServices.put(threadId, service);
        
        return new ChromeDriver(service, capabilityManager.getChromeOptions());
    }
    
    /**
     * Creates a FirefoxDriver instance.
     * 
     * @param capabilityManager The capability manager to use
     * @return A new FirefoxDriver instance
     */
    private WebDriver createFirefoxDriver(CSCapabilityManager capabilityManager) {
        logger.debug("Creating FirefoxDriver");
        
        String driverPath = ConfigurationManager.getInstance().getFrameworkConfig().getGeckoDriverPath();
        boolean useDriverManager = ConfigurationManager.getInstance().getFrameworkConfig().isUseDriverManager();
        
        if (!useDriverManager && (driverPath == null || driverPath.isEmpty())) {
            throw new IllegalStateException("Gecko driver path is not configured and driver manager is disabled");
        }

        // Continuation of com/cstestforge/framework/selenium/java/browser/CSLocalWebDriverFactory.java
        
        if (!useDriverManager) {
            System.setProperty("webdriver.gecko.driver", driverPath);
        }
        
        String threadId = String.valueOf(Thread.currentThread().getId());
        
        GeckoDriverService service = GeckoDriverService.Builder()
                .withSilent(ConfigurationManager.getInstance().getFrameworkConfig().isDriverServiceSilent())
                .withLogFile(getDriverLogFile("geckodriver", threadId))
                .build();
        
        firefoxServices.put(threadId, service);
        
        return new FirefoxDriver(service, capabilityManager.getFirefoxOptions());
    }
    
    /**
     * Creates an EdgeDriver instance.
     * 
     * @param capabilityManager The capability manager to use
     * @return A new EdgeDriver instance
     */
    private WebDriver createEdgeDriver(CSCapabilityManager capabilityManager) {
        logger.debug("Creating EdgeDriver");
        
        String driverPath = ConfigurationManager.getInstance().getFrameworkConfig().getEdgeDriverPath();
        boolean useDriverManager = ConfigurationManager.getInstance().getFrameworkConfig().isUseDriverManager();
        
        if (!useDriverManager && (driverPath == null || driverPath.isEmpty())) {
            throw new IllegalStateException("Edge driver path is not configured and driver manager is disabled");
        }
        
        if (!useDriverManager) {
            System.setProperty("webdriver.edge.driver", driverPath);
        }
        
        String threadId = String.valueOf(Thread.currentThread().getId());
        
        EdgeDriverService service = EdgeDriverService.Builder()
                .withSilent(ConfigurationManager.getInstance().getFrameworkConfig().isDriverServiceSilent())
                .withLogFile(getDriverLogFile("msedgedriver", threadId))
                .build();
        
        edgeServices.put(threadId, service);
        
        return new EdgeDriver(service, capabilityManager.getEdgeOptions());
    }
    
    /**
     * Creates a SafariDriver instance.
     * 
     * @param capabilityManager The capability manager to use
     * @return A new SafariDriver instance
     */
    private WebDriver createSafariDriver(CSCapabilityManager capabilityManager) {
        logger.debug("Creating SafariDriver");
        
        String threadId = String.valueOf(Thread.currentThread().getId());
        
        SafariDriverService service = new SafariDriverService.Builder()
                .withLogFile(getDriverLogFile("safaridriver", threadId))
                .build();
        
        safariServices.put(threadId, service);
        
        return new SafariDriver(service, capabilityManager.getSafariOptions());
    }
    
    /**
     * Creates an InternetExplorerDriver instance.
     * 
     * @param capabilityManager The capability manager to use
     * @return A new InternetExplorerDriver instance
     */
    private WebDriver createInternetExplorerDriver(CSCapabilityManager capabilityManager) {
        logger.debug("Creating InternetExplorerDriver");
        
        String driverPath = ConfigurationManager.getInstance().getFrameworkConfig().getIeDriverPath();
        boolean useDriverManager = ConfigurationManager.getInstance().getFrameworkConfig().isUseDriverManager();
        
        if (!useDriverManager && (driverPath == null || driverPath.isEmpty())) {
            throw new IllegalStateException("IE driver path is not configured and driver manager is disabled");
        }
        
        if (!useDriverManager) {
            System.setProperty("webdriver.ie.driver", driverPath);
        }
        
        String threadId = String.valueOf(Thread.currentThread().getId());
        
        InternetExplorerDriverService service = new InternetExplorerDriverService.Builder()
                .withSilent(ConfigurationManager.getInstance().getFrameworkConfig().isDriverServiceSilent())
                .withLogFile(getDriverLogFile("iedriver", threadId))
                .build();
        
        ieServices.put(threadId, service);
        
        return new InternetExplorerDriver(service, capabilityManager.getInternetExplorerOptions());
    }
    
    /**
     * Gets the log file for a driver service.
     * 
     * @param driverName The name of the driver
     * @param threadId The thread ID
     * @return The log file
     */
    private File getDriverLogFile(String driverName, String threadId) {
        String logDir = ConfigurationManager.getInstance().getFrameworkConfig().getDriverLogsDirectory();
        if (logDir == null || logDir.isEmpty()) {
            logDir = CSPathUtils.getDefaultLogsDirectory();
        }
        
        File logDirFile = new File(logDir);
        if (!logDirFile.exists()) {
            logDirFile.mkdirs();
        }
        
        return new File(logDirFile, driverName + "_" + threadId + "_" + System.currentTimeMillis() + ".log");
    }
    
    /**
     * Stops all driver services for the current thread.
     */
    public void stopServices() {
        String threadId = String.valueOf(Thread.currentThread().getId());
        
        ChromeDriverService chromeService = chromeServices.remove(threadId);
        if (chromeService != null && chromeService.isRunning()) {
            chromeService.stop();
            logger.debug("Stopped ChromeDriverService for thread: " + threadId);
        }
        
        GeckoDriverService firefoxService = firefoxServices.remove(threadId);
        if (firefoxService != null && firefoxService.isRunning()) {
            firefoxService.stop();
            logger.debug("Stopped GeckoDriverService for thread: " + threadId);
        }
        
        EdgeDriverService edgeService = edgeServices.remove(threadId);
        if (edgeService != null && edgeService.isRunning()) {
            edgeService.stop();
            logger.debug("Stopped EdgeDriverService for thread: " + threadId);
        }
        
        SafariDriverService safariService = safariServices.remove(threadId);
        if (safariService != null && safariService.isRunning()) {
            safariService.stop();
            logger.debug("Stopped SafariDriverService for thread: " + threadId);
        }
        
        InternetExplorerDriverService ieService = ieServices.remove(threadId);
        if (ieService != null && ieService.isRunning()) {
            ieService.stop();
            logger.debug("Stopped InternetExplorerDriverService for thread: " + threadId);
        }
    }
    
    /**
     * Stops all driver services.
     */
    public void stopAllServices() {
        chromeServices.values().forEach(service -> {
            if (service.isRunning()) {
                service.stop();
            }
        });
        chromeServices.clear();
        
        firefoxServices.values().forEach(service -> {
            if (service.isRunning()) {
                service.stop();
            }
        });
        firefoxServices.clear();
        
        edgeServices.values().forEach(service -> {
            if (service.isRunning()) {
                service.stop();
            }
        });
        edgeServices.clear();
        
        safariServices.values().forEach(service -> {
            if (service.isRunning()) {
                service.stop();
            }
        });
        safariServices.clear();
        
        ieServices.values().forEach(service -> {
            if (service.isRunning()) {
                service.stop();
            }
        });
        ieServices.clear();
        
        logger.debug("Stopped all driver services");
    }
}



// com/cstestforge/framework/selenium/java/element/CSElementList.java
package com.cstestforge.framework.selenium.java.element;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import com.cstestforge.framework.core.utils.CSLogger;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Enhanced WebElement list wrapper for Selenium WebDriver.
 * This class provides additional methods and functionality for working with lists of WebElements.
 */
public class CSElementList implements List<CSElement> {
    private final CSLogger logger = new CSLogger(CSElementList.class);
    private final List<CSElement> elements;
    private final WebDriver driver;
    private final By locator;
    
    /**
     * Constructor for CSElementList.
     * 
     * @param elements The list of WebElements to wrap
     * @param driver The WebDriver instance
     * @param locator The locator used to find the elements
     */
    public CSElementList(List<WebElement> elements, WebDriver driver, By locator) {
        this.driver = driver;
        this.locator = locator;
        this.elements = new ArrayList<>();
        
        if (elements != null) {
            for (WebElement element : elements) {
                this.elements.add(new CSElement(element, driver, locator));
            }
        }
        
        logger.debug("Created CSElementList with " + this.elements.size() + " elements using locator: " + locator);
    }
    
    /**
     * Constructor for CSElementList.
     * 
     * @param elements The list of WebElements to wrap
     * @param driver The WebDriver instance
     */
    public CSElementList(List<WebElement> elements, WebDriver driver) {
        this(elements, driver, null);
    }
    
    /**
     * Gets the WebDriver instance.
     * 
     * @return The WebDriver instance
     */
    public WebDriver getWrappedDriver() {
        return driver;
    }
    
    /**
     * Gets the locator used to find the elements.
     * 
     * @return The locator used to find the elements
     */
    public By getLocator() {
        return locator;
    }
    
    /**
     * Gets the first element in the list.
     * 
     * @return The first element
     * @throws NoSuchElementException if the list is empty
     */
    public CSElement first() {
        if (elements.isEmpty()) {
            throw new NoSuchElementException("Element list is empty");
        }
        return elements.get(0);
    }
    
    /**
     * Gets the first element in the list, or null if the list is empty.
     * 
     * @return The first element or null
     */
    public CSElement firstOrNull() {
        if (elements.isEmpty()) {
            return null;
        }
        return elements.get(0);
    }
    
    /**
     * Gets the last element in the list.
     * 
     * @return The last element
     * @throws NoSuchElementException if the list is empty
     */
    public CSElement last() {
        if (elements.isEmpty()) {
            throw new NoSuchElementException("Element list is empty");
        }
        return elements.get(elements.size() - 1);
    }
    
    /**
     * Gets the last element in the list, or null if the list is empty.
     * 
     * @return The last element or null
     */
    public CSElement lastOrNull() {
        if (elements.isEmpty()) {
            return null;
        }
        return elements.get(elements.size() - 1);
    }
    
    /**
     * Gets a random element from the list.
     * 
     * @return A random element
     * @throws NoSuchElementException if the list is empty
     */
    public CSElement random() {
        if (elements.isEmpty()) {
            throw new NoSuchElementException("Element list is empty");
        }
        int randomIndex = (int) (Math.random() * elements.size());
        return elements.get(randomIndex);
    }
    
    /**
     * Gets the element at the specified index, or null if the index is out of bounds.
     * 
     * @param index The index of the element to get
     * @return The element at the specified index or null
     */
    public CSElement getOrNull(int index) {
        if (index < 0 || index >= elements.size()) {
            return null;
        }
        return elements.get(index);
    }
    
    /**
     * Gets all elements that are currently displayed.
     * 
     * @return A list of displayed elements
     */
    public CSElementList getDisplayed() {
        logger.debug("Getting displayed elements");
        return filterElements(CSElement::isDisplayed);
    }
    
    /**
     * Gets all elements that are currently enabled.
     * 
     * @return A list of enabled elements
     */
    public CSElementList getEnabled() {
        logger.debug("Getting enabled elements");
        return filterElements(CSElement::isEnabled);
    }
    
    /**
     * Gets all elements that are currently selected.
     * 
     * @return A list of selected elements
     */
    public CSElementList getSelected() {
        logger.debug("Getting selected elements");
        return filterElements(CSElement::isSelected);
    }
    
    /**
     * Gets all elements that have the specified text.
     * 
     * @param text The text to match
     * @return A list of elements with the specified text
     */
    public CSElementList withText(String text) {
        logger.debug("Getting elements with text: " + text);
        return filterElements(element -> {
            try {
                return text.equals(element.getText());
            } catch (Exception e) {
                return false;
            }
        });
    }
    
    /**
     * Gets all elements that contain the specified text.
     * 
     * @param text The text to search for
     * @return A list of elements containing the specified text
     */
    public CSElementList containingText(String text) {
        logger.debug("Getting elements containing text: " + text);
        return filterElements(element -> {
            try {
                String elementText = element.getText();
                return elementText != null && elementText.contains(text);
            } catch (Exception e) {
                return false;
            }
        });
    }
    
    /**
     * Gets all elements that have the specified attribute.
     * 
     * @param attributeName The attribute name
     * @return A list of elements with the specified attribute
     */
    public CSElementList withAttribute(String attributeName) {
        logger.debug("Getting elements with attribute: " + attributeName);
        return filterElements(element -> {
            try {
                return element.getAttribute(attributeName) != null;
            } catch (Exception e) {
                return false;
            }
        });
    }
    
    /**
     * Gets all elements that have the specified attribute with the specified value.
     * 
     * @param attributeName The attribute name
     * @param attributeValue The attribute value
     * @return A list of elements with the specified attribute and value
     */
    public CSElementList withAttribute(String attributeName, String attributeValue) {
        logger.debug("Getting elements with attribute: " + attributeName + " = " + attributeValue);
        return filterElements(element -> {
            try {
                String value = element.getAttribute(attributeName);
                return value != null && value.equals(attributeValue);
            } catch (Exception e) {
                return false;
            }
        });
    }
    
    /**
     * Gets all elements that have the specified CSS class.
     * 
     * @param className The CSS class name
     * @return A list of elements with the specified CSS class
     */
    public CSElementList withClass(String className) {
        logger.debug("Getting elements with class: " + className);
        return filterElements(element -> {
            try {
                String classAttribute = element.getAttribute("class");
                if (classAttribute == null) {
                    return false;
                }
                
                for (String cls : classAttribute.split("\\s+")) {
                    if (cls.equals(className)) {
                        return true;
                    }
                }
                
                return false;
            } catch (Exception e) {
                return false;
            }
        });
    }
    
    /**
     * Gets all elements with the specified tag name.
     * 
     * @param tagName The tag name
     * @return A list of elements with the specified tag name
     */
    public CSElementList withTagName(String tagName) {
        logger.debug("Getting elements with tag name: " + tagName);
        return filterElements(element -> {
            try {
                return element.getTagName().equalsIgnoreCase(tagName);
            } catch (Exception e) {
                return false;
            }
        });
    }
    
    /**
     * Gets all elements matching the predicate.
     * 
     * @param predicate The predicate to match
     * @return A list of elements matching the predicate
     */
    public CSElementList filter(Predicate<CSElement> predicate) {
        return filterElements(predicate);
    }
    
    /**
     * Maps the elements using the provided function.
     * 
     * @param <R> The result type
     * @param mapper The function to apply to each element
     * @return A list of results
     */
    public <R> List<R> map(Function<CSElement, R> mapper) {
        return elements.stream().map(mapper).collect(Collectors.toList());
    }
    
    /**
     * Gets all text values from the elements.
     * 
     * @return A list of text values
     */
    public List<String> getAllText() {
        logger.debug("Getting all text from elements");
        return map(CSElement::getText);
    }
    
    /**
     * Gets all text values from the elements, normalized.
     * 
     * @return A list of normalized text values
     */
    public List<String> getAllTextNormalized() {
        logger.debug("Getting all normalized text from elements");
        return map(CSElement::getTextNormalized);
    }
    
    /**
     * Gets all attribute values from the elements.
     * 
     * @param attributeName The attribute name
     * @return A list of attribute values
     */
    public List<String> getAllAttributes(String attributeName) {
        logger.debug("Getting all attributes: " + attributeName + " from elements");
        return map(element -> element.getAttribute(attributeName));
    }
    
    /**
     * Gets all CSS property values from the elements.
     * 
     * @param propertyName The CSS property name
     * @return A list of CSS property values
     */
    public List<String> getAllCssProperties(String propertyName) {
        logger.debug("Getting all CSS properties: " + propertyName + " from elements");
        return map(element -> element.getCssValue(propertyName));
    }
    
    /**
     * Performs an action on each element.
     * 
     * @param action The action to perform
     * @return The CSElementList for method chaining
     */
    public CSElementList forEach(java.util.function.Consumer<CSElement> action) {
        logger.debug("Performing action on all elements");
        elements.forEach(action);
        return this;
    }
    
    /**
     * Clicks all elements.
     * 
     * @return The CSElementList for method chaining
     */
    public CSElementList clickAll() {
        logger.debug("Clicking all elements");
        return forEach(CSElement::click);
    }
    
    /**
     * Clicks the first element in the list.
     * 
     * @return The CSElementList for method chaining
     * @throws NoSuchElementException if the list is empty
     */
    public CSElementList clickFirst() {
        logger.debug("Clicking first element");
        first().click();
        return this;
    }
    
    /**
     * Clicks the last element in the list.
     * 
     * @return The CSElementList for method chaining
     * @throws NoSuchElementException if the list is empty
     */
    public CSElementList clickLast() {
        logger.debug("Clicking last element");
        last().click();
        return this;
    }
    
    /**
     * Clicks a random element in the list.
     * 
     * @return The CSElementList for method chaining
     * @throws NoSuchElementException if the list is empty
     */
    public CSElementList clickRandom() {
        logger.debug("Clicking random element");
        random().click();
        return this;
    }
    
    /**
     * Highlights all elements in the list.
     * 
     * @return The CSElementList for method chaining
     */
    public CSElementList highlightAll() {
        logger.debug("Highlighting all elements");
        return forEach(CSElement::highlight);
    }
    
    /**
     * Scrolls to the first element in the list.
     * 
     * @return The CSElementList for method chaining
     * @throws NoSuchElementException if the list is empty
     */
    public CSElementList scrollToFirst() {
        logger.debug("Scrolling to first element");
        first().scrollIntoView();
        return this;
    }
    
    /**
     * Scrolls to the last element in the list.
     * 
     * @return The CSElementList for method chaining
     * @throws NoSuchElementException if the list is empty
     */
    public CSElementList scrollToLast() {
        logger.debug("Scrolling to last element");
        last().scrollIntoView();
        return this;
    }
    
    /**
     * Refreshes all elements in the list.
     * 
     * @return A new CSElementList with refreshed elements
     */
    public CSElementList refresh() {
        logger.debug("Refreshing all elements");
        
        if (locator == null) {
            throw new IllegalStateException("Cannot refresh elements: locator is null");
        }
        
        List<WebElement> refreshedElements = driver.findElements(locator);
        return new CSElementList(refreshedElements, driver, locator);
    }
    
    /**
     * Waits for all elements to be visible.
     * 
     * @return The CSElementList for method chaining
     */
    public CSElementList waitForAllVisible() {
        logger.debug("Waiting for all elements to be visible");
        return forEach(CSElement::waitForVisible);
    }
    
    /**
     * Waits for all elements to be clickable.
     * 
     * @return The CSElementList for method chaining
     */
    public CSElementList waitForAllClickable() {
        logger.debug("Waiting for all elements to be clickable");
        return forEach(CSElement::waitForClickable);
    }
    
    /**
     * Takes screenshots of all elements.
     * 
     * @param fileNamePrefix The prefix for the screenshot file names
     * @return A list of screenshot file paths
     */
    public List<String> takeScreenshotOfAll(String fileNamePrefix) {
        logger.debug("Taking screenshots of all elements");
        List<String> screenshotPaths = new ArrayList<>();
        
        for (int i = 0; i < elements.size(); i++) {
            CSElement element = elements.get(i);
            String fileName = fileNamePrefix + "_" + i;
            screenshotPaths.add(element.takeScreenshot(fileName));
        }
        
        return screenshotPaths;
    }
    
    /**
     * Filters elements based on a predicate.
     * 
     * @param predicate The predicate to use for filtering
     * @return A new CSElementList with filtered elements
     */
    private CSElementList filterElements(Predicate<CSElement> predicate) {
        List<CSElement> filteredElements = elements.stream()
                .filter(predicate)
                .collect(Collectors.toList());
        
        // Create WebElement list from CSElement list
        List<WebElement> webElements = filteredElements.stream()
                .map(CSElement::getWrappedElement)
                .collect(Collectors.toList());
        
        return new CSElementList(webElements, driver, locator);
    }
    
    // List interface methods
    
    @Override
    public int size() {
        return elements.size();
    }
    
    @Override
    public boolean isEmpty() {
        return elements.isEmpty();
    }
    
    @Override
    public boolean contains(Object o) {
        return elements.contains(o);
    }
    
    @Override
    public Iterator<CSElement> iterator() {
        return elements.iterator();
    }
    
    @Override
    public Object[] toArray() {
        return elements.toArray();
    }
    
    @Override
    public <T> T[] toArray(T[] a) {
        return elements.toArray(a);
    }
    
    @Override
    public boolean add(CSElement e) {
        return elements.add(e);
    }
    
    @Override
    public boolean remove(Object o) {
        return elements.remove(o);
    }
    
    @Override
    public boolean containsAll(Collection<?> c) {
        return elements.containsAll(c);
    }
    
    @Override
    public boolean addAll(Collection<? extends CSElement> c) {
        return elements.addAll(c);
    }
    
    @Override
    public boolean addAll(int index, Collection<? extends CSElement> c) {
        return elements.addAll(index, c);
    }
    
    @Override
    public boolean removeAll(Collection<?> c) {
        return elements.removeAll(c);
    }
    
    @Override
    public boolean retainAll(Collection<?> c) {
        return elements.retainAll(c);
    }
    
    @Override
    public void clear() {
        elements.clear();
    }
    
    @Override
    public CSElement get(int index) {
        return elements.get(index);
    }
    
    @Override
    public CSElement set(int index, CSElement element) {
        return elements.set(index, element);
    }
    
    @Override
    public void add(int index, CSElement element) {
        elements.add(index, element);
    }
    
    @Override
    public CSElement remove(int index) {
        return elements.remove(index);
    }
    
    @Override
    public int indexOf(Object o) {
        return elements.indexOf(o);
    }
    
    @Override
    public int lastIndexOf(Object o) {
        return elements.lastIndexOf(o);
    }
    
    @Override
    public ListIterator<CSElement> listIterator() {
        return elements.listIterator();
    }
    
    @Override
    public ListIterator<CSElement> listIterator(int index) {
        return elements.listIterator(index);
    }
    
    @Override
    public List<CSElement> subList(int fromIndex, int toIndex) {
        return elements.subList(fromIndex, toIndex);
    }
}



// com/cstestforge/framework/selenium/java/element/CSSelect.java
package com.cstestforge.framework.selenium.java.element;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.ui.Select;

import com.cstestforge.framework.core.utils.CSLogger;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Enhanced Select element wrapper for Selenium WebDriver.
 * This class provides additional methods and functionality for working with Select elements.
 */
public class CSSelect extends CSElement {
    private final CSLogger logger = new CSLogger(CSSelect.class);
    private final Select select;
    
    /**
     * Constructor for CSSelect.
     * 
     * @param element The WebElement to wrap
     * @param driver The WebDriver instance
     * @param locator The locator used to find the element
     */
    public CSSelect(WebElement element, WebDriver driver, By locator) {
        super(element, driver, locator);
        this.select = new Select(element);
        logger.debug("Created CSSelect with locator: " + locator);
    }
    
    /**
     * Constructor for CSSelect.
     * 
     * @param element The WebElement to wrap
     * @param driver The WebDriver instance
     */
    public CSSelect(WebElement element, WebDriver driver) {
        this(element, driver, null);
    }
    
    /**
     * Constructor for CSSelect.
     * 
     * @param csElement The CSElement to wrap
     */
    public CSSelect(CSElement csElement) {
        this(csElement.getWrappedElement(), csElement.getWrappedDriver(), csElement.getLocator());
    }
    
    /**
     * Gets the wrapped Select instance.
     * 
     * @return The wrapped Select instance
     */
    public Select getWrappedSelect() {
        return select;
    }
    
    /**
     * Checks if the select element supports multiple selections.
     * 
     * @return true if the select element supports multiple selections, false otherwise
     */
    public boolean isMultiple() {
        return select.isMultiple();
    }
    
    /**
     * Gets all options from the select element.
     * 
     * @return A list of CSElement objects for the options
     */
    public List<CSElement> getOptions() {
        logger.debug("Getting all options");
        List<WebElement> options = select.getOptions();
        return options.stream()
                .map(option -> new CSElement(option, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all option values from the select element.
     * 
     * @return A list of option values
     */
    public List<String> getOptionValues() {
        logger.debug("Getting all option values");
        return getOptions().stream()
                .map(option -> option.getAttribute("value"))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all option texts from the select element.
     * 
     * @return A list of option texts
     */
    public List<String> getOptionTexts() {
        logger.debug("Getting all option texts");
        return getOptions().stream()
                .map(CSElement::getText)
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all selected options from the select element.
     * 
     * @return A list of CSElement objects for the selected options
     */
    public List<CSElement> getAllSelectedOptions() {
        logger.debug("Getting all selected options");
        List<WebElement> selectedOptions = select.getAllSelectedOptions();
        return selectedOptions.stream()
                .map(option -> new CSElement(option, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets the first selected option from the select element.
     * 
     * @return A CSElement object for the first selected option
     */
    public CSElement getFirstSelectedOption() {
        logger.debug("Getting first selected option");
        WebElement selectedOption = select.getFirstSelectedOption();
        return new CSElement(selectedOption, getWrappedDriver());
    }
    
    /**
     * Gets the selected value from the select element.
     * 
     * @return The selected value
     */
    public String getSelectedValue() {
        logger.debug("Getting selected value");
        return getFirstSelectedOption().getAttribute("value");
    }
    
    /**
     * Gets the selected text from the select element.
     * 
     * @return The selected text
     */
    public String getSelectedText() {
        logger.debug("Getting selected text");
        return getFirstSelectedOption().getText();
    }
    
    /**
     * Gets all selected values from the select element.
     * 
     * @return A list of selected values
     */
    public List<String> getAllSelectedValues() {
        logger.debug("Getting all selected values");
        return getAllSelectedOptions().stream()
                .map(option -> option.getAttribute("value"))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all selected texts from the select element.
     * 
     * @return A list of selected texts
     */
    public List<String> getAllSelectedTexts() {
        logger.debug("Getting all selected texts");
        return getAllSelectedOptions().stream()
                .map(CSElement::getText)
                .collect(Collectors.toList());
    }
    
    /**
     * Selects an option by visible text.
     * 
     * @param text The visible text
     * @return The CSSelect for method chaining
     */
    public CSSelect selectByVisibleText(String text) {
        logger.debug("Selecting by visible text: " + text);
        select.selectByVisibleText(text);
        return this;
    }
    
    /**
     * Selects an option by value.
     * 
     * @param value The value
     * @return The CSSelect for method chaining
     */
    public CSSelect selectByValue(String value) {
        logger.debug("Selecting by value: " + value);
        select.selectByValue(value);
        return this;
    }
    
    /**
     * Selects an option by index.
     * 
     * @param index The index
     * @return The CSSelect for method chaining
     */
    public CSSelect selectByIndex(int index) {
        logger.debug("Selecting by index: " + index);
        select.selectByIndex(index);
        return this;
    }
    
    /**
     * Selects multiple options by visible text.
     * 
     * @param texts The visible texts
     * @return The CSSelect for method chaining
     */
    public CSSelect selectByVisibleTexts(List<String> texts) {
        logger.debug("Selecting by visible texts: " + texts);
        for (String text : texts) {
            select.selectByVisibleText(text);
        }
        return this;
    }
    
    /**
     * Selects multiple options by value.
     * 
     * @param values The values
     * @return The CSSelect for method chaining
     */
    public CSSelect selectByValues(List<String> values) {
        logger.debug("Selecting by values: " + values);
        for (String value : values) {
            select.selectByValue(value);
        }
        return this;
    }
    
    /**
     * Selects multiple options by index.
     * 
     * @param indexes The indexes
     * @return The CSSelect for method chaining
     */
    public CSSelect selectByIndexes(List<Integer> indexes) {
        logger.debug("Selecting by indexes: " + indexes);
        for (int index : indexes) {
            select.selectByIndex(index);
        }
        return this;
    }
    
    /**
     * Selects all options.
     * 
     * @return The CSSelect for method chaining
     */
    public CSSelect selectAll() {
        logger.debug("Selecting all options");
        if (!isMultiple()) {
            throw new UnsupportedOperationException("Cannot select all options: the select element does not support multiple selections");
        }
        
        List<WebElement> options = select.getOptions();
        for (int i = 0; i < options.size(); i++) {
            select.selectByIndex(i);
        }
        
        return this;
    }
    
    /**
     * Deselects an option by visible text.
     * 
     * @param text The visible text
     * @return The CSSelect for method chaining
     */
    public CSSelect deselectByVisibleText(String text) {
        logger.debug("Deselecting by visible text: " + text);
        select.deselectByVisibleText(text);
        return this;
    }
    
    /**
     * Deselects an option by value.
     * 
     * @param value The value
     * @return The CSSelect for method chaining
     */
    public CSSelect deselectByValue(String value) {
        logger.debug("Deselecting by value: " + value);
        select.deselectByValue(value);
        return this;
    }
    
    /**
     * Deselects an option by index.
     * 
     * @param index The index
     * @return The CSSelect for method chaining
     */
    public CSSelect deselectByIndex(int index) {
        logger.debug("Deselecting by index: " + index);
        select.deselectByIndex(index);
        return this;
    }
    
    /**
     * Deselects multiple options by visible text.
     * 
     * @param texts The visible texts
     * @return The CSSelect for method chaining
     */
    public CSSelect deselectByVisibleTexts(List<String> texts) {
        logger.debug("Deselecting by visible texts: " + texts);
        for (String text : texts) {
            select.deselectByVisibleText(text);
        }
        return this;
    }
    
    /**
     * Deselects multiple options by value.
     * 
     * @param values The values
     * @return The CSSelect for method chaining
     */
    public CSSelect deselectByValues(List<String> values) {
        logger.debug("Deselecting by values: " + values);
        for (String value : values) {
            select.deselectByValue(value);
        }
        return this;
    }
    
    /**
     * Deselects multiple options by index.
     * 
     * @param indexes The indexes
     * @return The CSSelect for method chaining
     */
    public CSSelect deselectByIndexes(List<Integer> indexes) {
        logger.debug("Deselecting by indexes: " + indexes);
        for (int index : indexes) {
            select.deselectByIndex(index);
        }
        return this;
    }
    
    /**
     * Deselects all options.
     * 
     * @return The CSSelect for method chaining
     */
    public CSSelect deselectAll() {
        logger.debug("Deselecting all options");
        select.deselectAll();
        return this;
    }
    
    /**
     * Checks if an option with the specified visible text exists.
     * 
     * @param text The visible text
     * @return true if an option with the specified visible text exists, false otherwise
     */
    public boolean hasOptionWithText(String text) {
        logger.debug("Checking if option with text exists: " + text);
        return getOptionTexts().contains(text);
    }
    
    /**
     * Checks if an option with the specified value exists.
     * 
     * @param value The value
     * @return true if an option with the specified value exists, false otherwise
     */
    public boolean hasOptionWithValue(String value) {
        logger.debug("Checking if option with value exists: " + value);
        return getOptionValues().contains(value);
    }
    
    /**
     * Gets the option with the specified visible text.
     * 
     * @param text The visible text
     * @return The option with the specified visible text, or null if not found
     */
    public CSElement getOptionWithText(String text) {
        logger.debug("Getting option with text: " + text);
        for (CSElement option : getOptions()) {
            if (text.equals(option.getText())) {
                return option;
            }
        }
        return null;
    }
    
    /**
     * Gets the option with the specified value.
     * 
     * @param value The value
     * @return The option with the specified value, or null if not found
     */
    public CSElement getOptionWithValue(String value) {
        logger.debug("Getting option with value: " + value);
        for (CSElement option : getOptions()) {
            if (value.equals(option.getAttribute("value"))) {
                return option;
            }
        }
        return null;
    }
    
    /**
     * Gets the option at the specified index.
     * 
     * @param index The index
     * @return The option at the specified index
     * @throws IndexOutOfBoundsException if the index is out of range
     */
    public CSElement getOptionAtIndex(int index) {
        logger.debug("Getting option at index: " + index);
        List<CSElement> options = getOptions();
        if (index < 0 || index >= options.size()) {
            throw new IndexOutOfBoundsException("Index out of range: " + index);
        }
        return options.get(index);
    }
    
    /**
     * Gets the number of options.
     * 
     * @return The number of options
     */
    public int getOptionCount() {
        return getOptions().size();
    }
    
    /**
     * Gets the index of the option with the specified visible text.
     * 
     * @param text The visible text
     * @return The index of the option with the specified visible text, or -1 if not found
     */
    public int getIndexOfOptionWithText(String text) {
        logger.debug("Getting index of option with text: " + text);
        List<String> texts = getOptionTexts();
        return texts.indexOf(text);
    }
    
    /**
     * Gets the index of the option with the specified value.
     * 
     * @param value The value
     * @return The index of the option with the specified value, or -1 if not found
     */
    public int getIndexOfOptionWithValue(String value) {
        logger.debug("Getting index of option with value: " + value);
        List<String> values = getOptionValues();
        return values.indexOf(value);
    }
    
    /**
     * Gets a map of option values to option texts.
     * 
     * @return A map of option values to option texts
     */
    public java.util.Map<String, String> getValueToTextMap() {
        logger.debug("Getting value to text map");
        java.util.Map<String, String> map = new java.util.HashMap<>();
        List<CSElement> options = getOptions();
        
        for (CSElement option : options) {
            String value = option.getAttribute("value");
            String text = option.getText();
            map.put(value, text);
        }
        
        return map;
    }
    
    /**
     * Gets a map of option texts to option values.
     * 
     * @return A map of option texts to option values
     */
    public java.util.Map<String, String> getTextToValueMap() {
        logger.debug("Getting text to value map");
        java.util.Map<String, String> map = new java.util.HashMap<>();
        List<CSElement> options = getOptions();
        
        for (CSElement option : options) {
            String value = option.getAttribute("value");
            String text = option.getText();
            map.put(text, value);
        }
        
        return map;
    }
    
    /**
     * Selects an option by partial visible text.
     * 
     * @param partialText The partial visible text
     * @return The CSSelect for method chaining
     */
    public CSSelect selectByPartialVisibleText(String partialText) {
        logger.debug("Selecting by partial visible text: " + partialText);
        List<CSElement> options = getOptions();
        
        for (CSElement option : options) {
            String text = option.getText();
            if (text != null && text.contains(partialText)) {
                selectByVisibleText(text);
                return this;
            }
        }
        
        throw new org.openqa.selenium.NoSuchElementException(
                "Cannot locate option with partial text: " + partialText);
    }
    
    /**
     * Gets the option groups in the select element.
     * 
     * @return A map of option group labels to lists of options
     */
    public java.util.Map<String, List<CSElement>> getOptionGroups() {
        logger.debug("Getting option groups");
        java.util.Map<String, List<CSElement>> groups = new java.util.HashMap<>();
        
        // Find all optgroup elements
        List<WebElement> optGroups = getWrappedElement().findElements(By.tagName("optgroup"));
        
        for (WebElement optGroup : optGroups) {
            String label = optGroup.getAttribute("label");
            List<WebElement> groupOptions = optGroup.findElements(By.tagName("option"));
            
            List<CSElement> csOptions = groupOptions.stream()
                    .map(option -> new CSElement(option, getWrappedDriver()))
                    .collect(Collectors.toList());
            
            groups.put(label, csOptions);
        }
        
        // Handle options not in groups
        List<WebElement> directOptions = getWrappedElement().findElements(
                By.xpath("./option[not(ancestor::optgroup)]"));
        
        if (!directOptions.isEmpty()) {
            List<CSElement> csOptions = directOptions.stream()
                    .map(option -> new CSElement(option, getWrappedDriver()))
                    .collect(Collectors.toList());
            
            groups.put("", csOptions);
        }
        
        return groups;
    }
    
    /**
     * Gets the option group for an option.
     * 
     * @param option The option
     * @return The option group label, or an empty string if not in a group
     */
    public String getOptionGroup(CSElement option) {
        logger.debug("Getting option group for option");
        WebElement optGroup = (WebElement) ((org.openqa.selenium.JavascriptExecutor) getWrappedDriver())
                .executeScript(
                        "return arguments[0].closest('optgroup');", 
                        option.getWrappedElement());
        
        if (optGroup == null) {
            return "";
        }
        
        return optGroup.getAttribute("label");
    }
    
    /**
     * Gets the option with the specified value and group.
     * 
     * @param value The value
     * @param groupLabel The group label
     * @return The option with the specified value and group, or null if not found
     */
    public CSElement getOptionWithValueAndGroup(String value, String groupLabel) {
        logger.debug("Getting option with value: " + value + " and group: " + groupLabel);
        java.util.Map<String, List<CSElement>> groups = getOptionGroups();
        
        List<CSElement> groupOptions = groups.get(groupLabel);
        if (groupOptions == null) {
            return null;
        }
        
        for (CSElement option : groupOptions) {
            if (value.equals(option.getAttribute("value"))) {
                return option;
            }
        }
        
        return null;
    }
    
    /**
     * Selects an option by visible text in a specific group.
     * 
     * @param text The visible text
     * @param groupLabel The group label
     * @return The CSSelect for method chaining
     */
    public CSSelect selectByVisibleTextInGroup(String text, String groupLabel) {
        logger.debug("Selecting by visible text: " + text + " in group: " + groupLabel);
        java.util.Map<String, List<CSElement>> groups = getOptionGroups();
        
        List<CSElement> groupOptions = groups.get(groupLabel);
        if (groupOptions == null) {
            throw new org.openqa.selenium.NoSuchElementException(
                    "Cannot locate option group with label: " + groupLabel);
        }
        
        for (CSElement option : groupOptions) {
            if (text.equals(option.getText())) {
                option.click();
                return this;
            }
        }
        
        throw new org.openqa.selenium.NoSuchElementException(
                "Cannot locate option with text: " + text + " in group: " + groupLabel);
    }
    
    /**
     * Gets the select element as a CSElement.
     * 
     * @return The select element as a CSElement
     */
    public CSElement asElement() {
        return this;
    }
}



// com/cstestforge/framework/selenium/java/element/CSTable.java
package com.cstestforge.framework.selenium.java.element;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import com.cstestforge.framework.core.utils.CSLogger;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Enhanced table element wrapper for Selenium WebDriver.
 * This class provides additional methods and functionality for working with HTML tables.
 */
public class CSTable extends CSElement {
    private final CSLogger logger = new CSLogger(CSTable.class);
    private final By rowLocator;
    private final By headerLocator;
    private final By cellLocator;
    private final By footerLocator;
    
    /**
     * Constructor for CSTable.
     * 
     * @param element The WebElement to wrap
     * @param driver The WebDriver instance
     * @param locator The locator used to find the element
     */
    public CSTable(WebElement element, WebDriver driver, By locator) {
        super(element, driver, locator);
        this.rowLocator = By.tagName("tr");
        this.headerLocator = By.tagName("th");
        this.cellLocator = By.tagName("td");
        this.footerLocator = By.xpath(".//tfoot/tr");
        logger.debug("Created CSTable with locator: " + locator);
    }
    
    /**
     * Constructor for CSTable.
     * 
     * @param element The WebElement to wrap
     * @param driver The WebDriver instance
     */
    public CSTable(WebElement element, WebDriver driver) {
        this(element, driver, null);
    }
    
    /**
     * Constructor for CSTable with custom locators.
     * 
     * @param element The WebElement to wrap
     * @param driver The WebDriver instance
     * @param locator The locator used to find the element
     * @param rowLocator The locator for table rows
     * @param headerLocator The locator for table headers
     * @param cellLocator The locator for table cells
     * @param footerLocator The locator for table footer rows
     */
    public CSTable(WebElement element, WebDriver driver, By locator, By rowLocator, By headerLocator, By cellLocator, By footerLocator) {
        super(element, driver, locator);
        this.rowLocator = rowLocator != null ? rowLocator : By.tagName("tr");
        this.headerLocator = headerLocator != null ? headerLocator : By.tagName("th");
        this.cellLocator = cellLocator != null ? cellLocator : By.tagName("td");
        this.footerLocator = footerLocator != null ? footerLocator : By.xpath(".//tfoot/tr");
        logger.debug("Created CSTable with custom locators");
    }
    
    /**
     * Constructor for CSTable.
     * 
     * @param csElement The CSElement to wrap
     */
    public CSTable(CSElement csElement) {
        this(csElement.getWrappedElement(), csElement.getWrappedDriver(), csElement.getLocator());
    }
    
    /**
     * Gets all rows from the table.
     * 
     * @return A list of CSElement objects for the rows
     */
    public List<CSElement> getRows() {
        logger.debug("Getting all rows");
        List<WebElement> rows = getWrappedElement().findElements(rowLocator);
        return rows.stream()
                .map(row -> new CSElement(row, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets the body rows from the table (excluding header and footer rows).
     * 
     * @return A list of CSElement objects for the body rows
     */
    public List<CSElement> getBodyRows() {
        logger.debug("Getting body rows");
        // Find rows in tbody or directly in the table if no tbody exists
        List<WebElement> bodyRows = getWrappedElement().findElements(By.xpath(".//tbody/tr | .//tr[not(parent::thead) and not(parent::tfoot)]"));
        return bodyRows.stream()
                .map(row -> new CSElement(row, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets the header rows from the table.
     * 
     * @return A list of CSElement objects for the header rows
     */
    public List<CSElement> getHeaderRows() {
        logger.debug("Getting header rows");
        List<WebElement> headerRows = getWrappedElement().findElements(By.xpath(".//thead/tr"));
        return headerRows.stream()
                .map(row -> new CSElement(row, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets the footer rows from the table.
     * 
     * @return A list of CSElement objects for the footer rows
     */
    public List<CSElement> getFooterRows() {
        logger.debug("Getting footer rows");
        List<WebElement> footerRows = getWrappedElement().findElements(footerLocator);
        return footerRows.stream()
                .map(row -> new CSElement(row, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets a specific row from the table.
     * 
     * @param rowIndex The index of the row (0-based)
     * @return A CSElement object for the row
     * @throws IndexOutOfBoundsException if the row index is out of range
     */
    public CSElement getRow(int rowIndex) {
        logger.debug("Getting row at index: " + rowIndex);
        List<CSElement> rows = getRows();
        if (rowIndex < 0 || rowIndex >= rows.size()) {
            throw new IndexOutOfBoundsException("Row index out of range: " + rowIndex);
        }
        return rows.get(rowIndex);
    }
    
    /**
     * Gets a specific body row from the table.
     * 
     * @param rowIndex The index of the body row (0-based)
     * @return A CSElement object for the body row
     * @throws IndexOutOfBoundsException if the row index is out of range
     */
    public CSElement getBodyRow(int rowIndex) {
        logger.debug("Getting body row at index: " + rowIndex);
        List<CSElement> bodyRows = getBodyRows();
        if (rowIndex < 0 || rowIndex >= bodyRows.size()) {
            throw new IndexOutOfBoundsException("Body row index out of range: " + rowIndex);
        }
        return bodyRows.get(rowIndex);
    }
    
    /**
     * Gets the header cells from the table.
     * 
     * @return A list of CSElement objects for the header cells
     */
    public List<CSElement> getHeaderCells() {
        logger.debug("Getting header cells");
        List<WebElement> headerCells = getWrappedElement().findElements(By.xpath(".//th"));
        return headerCells.stream()
                .map(cell -> new CSElement(cell, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets the header texts from the table.
     * 
     * @return A list of header texts
     */
    public List<String> getHeaderTexts() {
        logger.debug("Getting header texts");
        return getHeaderCells().stream()
                .map(CSElement::getText)
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all cells from a specific row.
     * 
     * @param rowElement The row element
     * @return A list of CSElement objects for the cells
     */
    public List<CSElement> getCellsFromRow(CSElement rowElement) {
        logger.debug("Getting cells from row");
        List<WebElement> cells = rowElement.getWrappedElement().findElements(By.xpath(".//td | .//th"));
        return cells.stream()
                .map(cell -> new CSElement(cell, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all cells from a specific row by index.
     * 
     * @param rowIndex The index of the row (0-based)
     * @return A list of CSElement objects for the cells
     * @throws IndexOutOfBoundsException if the row index is out of range
     */
    public List<CSElement> getCellsFromRow(int rowIndex) {
        logger.debug("Getting cells from row at index: " + rowIndex);
        CSElement rowElement = getRow(rowIndex);
        return getCellsFromRow(rowElement);
    }
    
    /**
     * Gets the texts from all cells in a specific row.
     * 
     * @param rowIndex The index of the row (0-based)
     * @return A list of cell texts
     * @throws IndexOutOfBoundsException if the row index is out of range
     */
    public List<String> getRowTexts(int rowIndex) {
        logger.debug("Getting texts from row at index: " + rowIndex);
        return getCellsFromRow(rowIndex).stream()
                .map(CSElement::getText)
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all cells from a specific column by index.
     * 
     * @param columnIndex The index of the column (0-based)
     * @return A list of CSElement objects for the cells
     * @throws IndexOutOfBoundsException if the column index is out of range
     */
    public List<CSElement> getColumn(int columnIndex) {
        logger.debug("Getting column at index: " + columnIndex);
        List<CSElement> cells = new ArrayList<>();
        
        for (CSElement row : getRows()) {
            List<CSElement> rowCells = getCellsFromRow(row);
            if (columnIndex < 0 || columnIndex >= rowCells.size()) {
                throw new IndexOutOfBoundsException("Column index out of range: " + columnIndex);
            }
            cells.add(rowCells.get(columnIndex));
        }
        
        return cells;
    }
    
    /**
     * Gets all cells from a specific column by header text.
     * 
     * @param headerText The header text
     * @return A list of CSElement objects for the cells
     * @throws IllegalArgumentException if the header text is not found
     */
    public List<CSElement> getColumnByHeader(String headerText) {
        logger.debug("Getting column by header text: " + headerText);
        List<String> headerTexts = getHeaderTexts();
        int columnIndex = headerTexts.indexOf(headerText);
        
        if (columnIndex == -1) {
            throw new IllegalArgumentException("Header text not found: " + headerText);
        }
        
        return getColumn(columnIndex);
    }
    
    /**
     * Gets the texts from all cells in a specific column.
     * 
     * @param columnIndex The index of the column (0-based)
     * @return A list of cell texts
     * @throws IndexOutOfBoundsException if the column index is out of range
     */
    public List<String> getColumnTexts(int columnIndex) {
        logger.debug("Getting texts from column at index: " + columnIndex);
        return getColumn(columnIndex).stream()
                .map(CSElement::getText)
                .collect(Collectors.toList());
    }
    
    /**
     * Gets the texts from all cells in a specific column by header text.
     * 
     * @param headerText The header text
     * @return A list of cell texts
     * @throws IllegalArgumentException if the header text is not found
     */
    public List<String> getColumnTextsByHeader(String headerText) {
        logger.debug("Getting texts from column by header text: " + headerText);
        return getColumnByHeader(headerText).stream()
                .map(CSElement::getText)
                .collect(Collectors.toList());
    }
    
    /**
     * Gets a specific cell from the table.
     * 
     * @param rowIndex The index of the row (0-based)
     * @param columnIndex The index of the column (0-based)
     * @return A CSElement object for the cell
     * @throws IndexOutOfBoundsException if the row or column index is out of range
     */
    public CSElement getCell(int rowIndex, int columnIndex) {
        logger.debug("Getting cell at row " + rowIndex + ", column " + columnIndex);
        List<CSElement> rowCells = getCellsFromRow(rowIndex);
        if (columnIndex < 0 || columnIndex >= rowCells.size()) {
            throw new IndexOutOfBoundsException("Column index out of range: " + columnIndex);
        }
        return rowCells.get(columnIndex);
    }
    
    /**
     * Gets a specific cell from the table by header text.
     * 
     * @param rowIndex The index of the row (0-based)
     * @param headerText The header text
     * @return A CSElement object for the cell
     * @throws IndexOutOfBoundsException if the row index is out of range
     * @throws IllegalArgumentException if the header text is not found
     */
    public CSElement getCellByHeader(int rowIndex, String headerText) {
        logger.debug("Getting cell at row " + rowIndex + ", header " + headerText);
        List<String> headerTexts = getHeaderTexts();
        int columnIndex = headerTexts.indexOf(headerText);
        
        if (columnIndex == -1) {
            throw new IllegalArgumentException("Header text not found: " + headerText);
        }
        
        return getCell(rowIndex, columnIndex);
    }
    
    /**
     * Gets the text from a specific cell.
     * 
     * @param rowIndex The index of the row (0-based)
     * @param columnIndex The index of the column (0-based)
     * @return The text from the cell
     * @throws IndexOutOfBoundsException if the row or column index is out of range
     */
    public String getCellText(int rowIndex, int columnIndex) {
        logger.debug("Getting text from cell at row " + rowIndex + ", column " + columnIndex);
        return getCell(rowIndex, columnIndex).getText();
    }
    
    /**
     * Gets the text from a specific cell by header text.
     * 
     * @param rowIndex The index of the row (0-based)
     * @param headerText The header text
     * @return The text from the cell
     * @throws IndexOutOfBoundsException if the row index is out of range
     * @throws IllegalArgumentException if the header text is not found
     */
    public String getCellTextByHeader(int rowIndex, String headerText) {
        logger.debug("Getting text from cell at row " + rowIndex + ", header " + headerText);
        return getCellByHeader(rowIndex, headerText).getText();
    }
    
    /**
     * Finds rows that match the specified predicate.
     * 
     * @param predicate The predicate to match
     * @return A list of CSElement objects for the matching rows
     */
    public List<CSElement> findRows(Predicate<CSElement> predicate) {
        logger.debug("Finding rows matching predicate");
        return getRows().stream()
                .filter(predicate)
                .collect(Collectors.toList());
    }
    
    /**
     * Finds rows where a cell in a specific column matches the specified text.
     * 
     * @param columnIndex The index of the column (0-based)
     * @param text The text to match
     * @return A list of CSElement objects for the matching rows
     */
    public List<CSElement> findRowsWhereColumnEquals(int columnIndex, String text) {
        logger.debug("Finding rows where column " + columnIndex + " equals " + text);
        return findRows(row -> {
            List<CSElement> cells = getCellsFromRow(row);
            if (columnIndex < 0 || columnIndex >= cells.size()) {
                return false;
            }
            return text.equals(cells.get(columnIndex).getText());
        });
    }
    
    /**
     * Finds rows where a cell in a specific column contains the specified text.
     * 
     * @param columnIndex The index of the column (0-based)
     * @param text The text to search for
     * @return A list of CSElement objects for the matching rows
     */
    public List<CSElement> findRowsWhereColumnContains(int columnIndex, String text) {
        logger.debug("Finding rows where column " + columnIndex + " contains " + text);
        return findRows(row -> {
            List<CSElement> cells = getCellsFromRow(row);
            if (columnIndex < 0 || columnIndex >= cells.size()) {
                return false;
            }
            String cellText = cells.get(columnIndex).getText();
            return cellText != null && cellText.contains(text);
        });
    }
    
    /**
     * Finds rows where a cell in a specific column by header text matches the specified text.
     * 
     * @param headerText The header text
     * @param text The text to match
     * @return A list of CSElement objects for the matching rows
     * @throws IllegalArgumentException if the header text is not found
     */
    public List<CSElement> findRowsWhereColumnEquals(String headerText, String text) {
        logger.debug("Finding rows where column " + headerText + " equals " + text);
        List<String> headerTexts = getHeaderTexts();
        int columnIndex = headerTexts.indexOf(headerText);
        
        if (columnIndex == -1) {
            throw new IllegalArgumentException("Header text not found: " + headerText);
        }
        
        return findRowsWhereColumnEquals(columnIndex, text);
    }
    
    /**
     * Finds rows where a cell in a specific column by header text contains the specified text.
     * 
     * @param headerText The header text
     * @param text The text to search for
     * @return A list of CSElement objects for the matching rows
     * @throws IllegalArgumentException if the header text is not found
     */
    public List<CSElement> findRowsWhereColumnContains(String headerText, String text) {
        logger.debug("Finding rows where column " + headerText + " contains " + text);
        List<String> headerTexts = getHeaderTexts();
        int columnIndex = headerTexts.indexOf(headerText);
        
        if (columnIndex == -1) {
            throw new IllegalArgumentException("Header text not found: " + headerText);
        }
        
        return findRowsWhereColumnContains(columnIndex, text);
    }
    
    /**
     * Gets the table data as a list of maps.
     * Each map represents a row, with keys from the header texts and values from the cell texts.
     * 
     * @return A list of maps representing the table data
     */
    public List<Map<String, String>> getTableDataAsMaps() {
        logger.debug("Getting table data as maps");
        List<String> headerTexts = getHeaderTexts();
        List<CSElement> bodyRows = getBodyRows();
        List<Map<String, String>> data = new ArrayList<>();
        
        for (CSElement row : bodyRows) {
            List<CSElement> cells = getCellsFromRow(row);
            Map<String, String> rowData = new HashMap<>();
            
            // Add cells to the map using header texts as keys
            for (int i = 0; i < Math.min(headerTexts.size(), cells.size()); i++) {
                // Continuation of com/cstestforge/framework/selenium/java/element/CSTable.java
                rowData.put(headerTexts.get(i), cells.get(i).getText());
            }
            
            data.add(rowData);
        }
        
        return data;
    }
    
    /**
     * Gets the index of a row that contains the specified text in any cell.
     * 
     * @param text The text to search for
     * @return The index of the first matching row, or -1 if not found
     */
    public int getRowIndexContainingText(String text) {
        logger.debug("Getting row index containing text: " + text);
        List<CSElement> rows = getBodyRows();
        
        for (int i = 0; i < rows.size(); i++) {
            CSElement row = rows.get(i);
            List<CSElement> cells = getCellsFromRow(row);
            
            for (CSElement cell : cells) {
                String cellText = cell.getText();
                if (cellText != null && cellText.contains(text)) {
                    return i;
                }
            }
        }
        
        return -1;
    }
    
    /**
     * Gets the index of a column by header text.
     * 
     * @param headerText The header text
     * @return The index of the column, or -1 if not found
     */
    public int getColumnIndexByHeader(String headerText) {
        logger.debug("Getting column index by header text: " + headerText);
        List<String> headerTexts = getHeaderTexts();
        return headerTexts.indexOf(headerText);
    }
    
    /**
     * Gets the number of rows in the table (including header and footer rows).
     * 
     * @return The number of rows
     */
    public int getRowCount() {
        return getRows().size();
    }
    
    /**
     * Gets the number of body rows in the table.
     * 
     * @return The number of body rows
     */
    public int getBodyRowCount() {
        return getBodyRows().size();
    }
    
    /**
     * Gets the number of columns in the table.
     * 
     * @return The number of columns
     */
    public int getColumnCount() {
        List<CSElement> headerCells = getHeaderCells();
        if (!headerCells.isEmpty()) {
            return headerCells.size();
        }
        
        List<CSElement> bodyRows = getBodyRows();
        if (!bodyRows.isEmpty()) {
            return getCellsFromRow(bodyRows.get(0)).size();
        }
        
        return 0;
    }
    
    /**
     * Sorts a column by clicking on its header.
     * 
     * @param columnIndex The index of the column to sort
     * @return The CSTable for method chaining
     * @throws IndexOutOfBoundsException if the column index is out of range
     */
    public CSTable sortColumn(int columnIndex) {
        logger.debug("Sorting column at index: " + columnIndex);
        List<CSElement> headerCells = getHeaderCells();
        if (columnIndex < 0 || columnIndex >= headerCells.size()) {
            throw new IndexOutOfBoundsException("Column index out of range: " + columnIndex);
        }
        
        CSElement headerCell = headerCells.get(columnIndex);
        headerCell.click();
        
        com.cstestforge.framework.core.reporting.CSReporter.getInstance().logInfo(
                "Sorted table by clicking on column header: " + headerCell.getText());
        
        return this;
    }
    
    /**
     * Sorts a column by clicking on its header.
     * 
     * @param headerText The header text of the column to sort
     * @return The CSTable for method chaining
     * @throws IllegalArgumentException if the header text is not found
     */
    public CSTable sortColumnByHeader(String headerText) {
        logger.debug("Sorting column by header text: " + headerText);
        int columnIndex = getColumnIndexByHeader(headerText);
        if (columnIndex == -1) {
            throw new IllegalArgumentException("Header text not found: " + headerText);
        }
        
        com.cstestforge.framework.core.reporting.CSReporter.getInstance().logInfo(
                "Sorting table by column: " + headerText);
        
        return sortColumn(columnIndex);
    }
    
    /**
     * Clicks a specific cell in the table.
     * 
     * @param rowIndex The index of the row (0-based)
     * @param columnIndex The index of the column (0-based)
     * @return The CSTable for method chaining
     * @throws IndexOutOfBoundsException if the row or column index is out of range
     */
    public CSTable clickCell(int rowIndex, int columnIndex) {
        logger.debug("Clicking cell at row " + rowIndex + ", column " + columnIndex);
        CSElement cell = getCell(rowIndex, columnIndex);
        cell.click();
        
        com.cstestforge.framework.core.reporting.CSReporter.getInstance().logInfo(
                "Clicked on table cell at row " + rowIndex + ", column " + columnIndex + 
                " (text: " + cell.getText() + ")");
        
        return this;
    }
    
    /**
     * Clicks a specific cell in the table by header text.
     * 
     * @param rowIndex The index of the row (0-based)
     * @param headerText The header text
     * @return The CSTable for method chaining
     * @throws IndexOutOfBoundsException if the row index is out of range
     * @throws IllegalArgumentException if the header text is not found
     */
    public CSTable clickCellByHeader(int rowIndex, String headerText) {
        logger.debug("Clicking cell at row " + rowIndex + ", header " + headerText);
        CSElement cell = getCellByHeader(rowIndex, headerText);
        cell.click();
        
        com.cstestforge.framework.core.reporting.CSReporter.getInstance().logInfo(
                "Clicked on table cell at row " + rowIndex + ", column '" + headerText + 
                "' (text: " + cell.getText() + ")");
        
        return this;
    }
    
    /**
     * Clicks a cell in the table that contains the specified text.
     * 
     * @param text The text to search for
     * @return The CSTable for method chaining
     * @throws IllegalArgumentException if no cell containing the text is found
     */
    public CSTable clickCellContainingText(String text) {
        logger.debug("Clicking cell containing text: " + text);
        List<CSElement> rows = getRows();
        
        for (CSElement row : rows) {
            List<CSElement> cells = getCellsFromRow(row);
            
            for (CSElement cell : cells) {
                String cellText = cell.getText();
                if (cellText != null && cellText.contains(text)) {
                    cell.click();
                    
                    com.cstestforge.framework.core.reporting.CSReporter.getInstance().logInfo(
                            "Clicked on table cell containing text: " + text);
                    
                    return this;
                }
            }
        }
        
        throw new IllegalArgumentException("No cell containing the text found: " + text);
    }
    
    /**
     * Gets a row by index and converts it to a map.
     * 
     * @param rowIndex The index of the row (0-based)
     * @return A map representing the row, with keys from the header texts and values from the cell texts
     * @throws IndexOutOfBoundsException if the row index is out of range
     */
    public Map<String, String> getRowAsMap(int rowIndex) {
        logger.debug("Getting row as map at index: " + rowIndex);
        List<String> headerTexts = getHeaderTexts();
        CSElement row = getBodyRow(rowIndex);
        List<CSElement> cells = getCellsFromRow(row);
        Map<String, String> rowData = new HashMap<>();
        
        // Add cells to the map using header texts as keys
        for (int i = 0; i < Math.min(headerTexts.size(), cells.size()); i++) {
            rowData.put(headerTexts.get(i), cells.get(i).getText());
        }
        
        return rowData;
    }
    
    /**
     * Checks if a row exists that matches the specified predicate.
     * 
     * @param predicate The predicate to match
     * @return true if a matching row exists, false otherwise
     */
    public boolean hasRowMatching(Predicate<CSElement> predicate) {
        logger.debug("Checking if row matching predicate exists");
        return getRows().stream().anyMatch(predicate);
    }
    
    /**
     * Checks if a row exists where a cell in a specific column matches the specified text.
     * 
     * @param columnIndex The index of the column (0-based)
     * @param text The text to match
     * @return true if a matching row exists, false otherwise
     */
    public boolean hasRowWhereColumnEquals(int columnIndex, String text) {
        logger.debug("Checking if row exists where column " + columnIndex + " equals " + text);
        return !findRowsWhereColumnEquals(columnIndex, text).isEmpty();
    }
    
    /**
     * Checks if a row exists where a cell in a specific column contains the specified text.
     * 
     * @param columnIndex The index of the column (0-based)
     * @param text The text to search for
     * @return true if a matching row exists, false otherwise
     */
    public boolean hasRowWhereColumnContains(int columnIndex, String text) {
        logger.debug("Checking if row exists where column " + columnIndex + " contains " + text);
        return !findRowsWhereColumnContains(columnIndex, text).isEmpty();
    }
    
    /**
     * Checks if a row exists where a cell in a specific column by header text matches the specified text.
     * 
     * @param headerText The header text
     * @param text The text to match
     * @return true if a matching row exists, false otherwise
     */
    public boolean hasRowWhereColumnEquals(String headerText, String text) {
        logger.debug("Checking if row exists where column " + headerText + " equals " + text);
        try {
            return !findRowsWhereColumnEquals(headerText, text).isEmpty();
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
    
    /**
     * Checks if a row exists where a cell in a specific column by header text contains the specified text.
     * 
     * @param headerText The header text
     * @param text The text to search for
     * @return true if a matching row exists, false otherwise
     */
    public boolean hasRowWhereColumnContains(String headerText, String text) {
        logger.debug("Checking if row exists where column " + headerText + " contains " + text);
        try {
            return !findRowsWhereColumnContains(headerText, text).isEmpty();
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
    
    /**
     * Checks if the table is empty (has no body rows).
     * 
     * @return true if the table is empty, false otherwise
     */
    public boolean isEmpty() {
        return getBodyRowCount() == 0;
    }
    
    /**
     * Gets the table as a CSV string.
     * 
     * @param delimiter The delimiter to use
     * @return The table as a CSV string
     */
    public String toCsv(String delimiter) {
        logger.debug("Converting table to CSV with delimiter: " + delimiter);
        StringBuilder csv = new StringBuilder();
        
        // Add header row
        List<String> headerTexts = getHeaderTexts();
        if (!headerTexts.isEmpty()) {
            csv.append(String.join(delimiter, headerTexts)).append("\n");
        }
        
        // Add data rows
        List<CSElement> bodyRows = getBodyRows();
        for (CSElement row : bodyRows) {
            List<CSElement> cells = getCellsFromRow(row);
            List<String> cellTexts = cells.stream()
                    .map(CSElement::getText)
                    .collect(Collectors.toList());
            csv.append(String.join(delimiter, cellTexts)).append("\n");
        }
        
        return csv.toString();
    }
    
    /**
     * Gets the table as a CSV string with comma as the delimiter.
     * 
     * @return The table as a CSV string
     */
    public String toCsv() {
        return toCsv(",");
    }
    
    /**
     * Gets the table as a formatted string.
     * 
     * @return The table as a formatted string
     */
    public String toFormattedString() {
        logger.debug("Converting table to formatted string");
        List<String> headerTexts = getHeaderTexts();
        List<List<String>> rowTexts = new ArrayList<>();
        
        // Add header row if present
        if (!headerTexts.isEmpty()) {
            rowTexts.add(headerTexts);
        }
        
        // Add data rows
        List<CSElement> bodyRows = getBodyRows();
        for (CSElement row : bodyRows) {
            List<CSElement> cells = getCellsFromRow(row);
            List<String> cellTexts = cells.stream()
                    .map(CSElement::getText)
                    .collect(Collectors.toList());
            rowTexts.add(cellTexts);
        }
        
        // Calculate column widths
        int[] columnWidths = new int[rowTexts.isEmpty() ? 0 : rowTexts.get(0).size()];
        for (List<String> row : rowTexts) {
            for (int i = 0; i < Math.min(row.size(), columnWidths.length); i++) {
                columnWidths[i] = Math.max(columnWidths[i], row.get(i).length());
            }
        }
        
        // Build the formatted string
        StringBuilder formatted = new StringBuilder();
        
        // Add header separator
        if (!headerTexts.isEmpty()) {
            formatted.append(formatRow(rowTexts.get(0), columnWidths)).append("\n");
            StringBuilder separator = new StringBuilder();
            for (int width : columnWidths) {
                separator.append("+").append("-".repeat(width + 2));
            }
            separator.append("+");
            formatted.append(separator).append("\n");
            
            // Add data rows
            for (int i = 1; i < rowTexts.size(); i++) {
                formatted.append(formatRow(rowTexts.get(i), columnWidths)).append("\n");
            }
        } else {
            // Add all rows if no header
            for (List<String> row : rowTexts) {
                formatted.append(formatRow(row, columnWidths)).append("\n");
            }
        }
        
        return formatted.toString();
    }
    
    /**
     * Formats a row for the formatted string output.
     * 
     * @param row The row texts
     * @param columnWidths The column widths
     * @return The formatted row
     */
    private String formatRow(List<String> row, int[] columnWidths) {
        StringBuilder formattedRow = new StringBuilder();
        for (int i = 0; i < Math.min(row.size(), columnWidths.length); i++) {
            String cell = row.get(i);
            formattedRow.append("| ").append(cell)
                    .append(" ".repeat(columnWidths[i] - cell.length())).append(" ");
        }
        formattedRow.append("|");
        return formattedRow.toString();
    }
    
    /**
     * Refreshes the table by re-finding it using the locator.
     * 
     * @return A new CSTable with the refreshed element
     * @throws IllegalStateException if the locator is null
     */
    public CSTable refresh() {
        logger.debug("Refreshing table");
        if (getLocator() == null) {
            throw new IllegalStateException("Cannot refresh table: locator is null");
        }
        
        WebElement refreshedElement = getWrappedDriver().findElement(getLocator());
        return new CSTable(refreshedElement, getWrappedDriver(), getLocator(), 
                rowLocator, headerLocator, cellLocator, footerLocator);
    }
    
    /**
     * Waits for the table to have a specific number of rows.
     * 
     * @param rowCount The expected row count
     * @param timeoutSeconds The timeout in seconds
     * @return The CSTable for method chaining
     */
    public CSTable waitForRowCount(int rowCount, int timeoutSeconds) {
        logger.debug("Waiting for row count: " + rowCount + " with timeout: " + timeoutSeconds);
        CSElement tableElement = asElement();
        
        tableElement.waitFor(element -> {
            CSTable refreshedTable = refresh();
            return refreshedTable.getBodyRowCount() == rowCount;
        }, timeoutSeconds);
        
        com.cstestforge.framework.core.reporting.CSReporter.getInstance().logInfo(
                "Table has expected row count: " + rowCount);
        
        return this;
    }
    
    /**
     * Waits for the table to contain a row where a cell in a specific column matches the specified text.
     * 
     * @param columnIndex The index of the column (0-based)
     * @param text The text to match
     * @param timeoutSeconds The timeout in seconds
     * @return The CSTable for method chaining
     */
    public CSTable waitForRowWhereColumnEquals(int columnIndex, String text, int timeoutSeconds) {
        logger.debug("Waiting for row where column " + columnIndex + " equals " + text + 
                " with timeout: " + timeoutSeconds);
        CSElement tableElement = asElement();
        
        tableElement.waitFor(element -> {
            CSTable refreshedTable = refresh();
            return refreshedTable.hasRowWhereColumnEquals(columnIndex, text);
        }, timeoutSeconds);
        
        com.cstestforge.framework.core.reporting.CSReporter.getInstance().logInfo(
                "Table contains row where column " + columnIndex + " equals '" + text + "'");
        
        return this;
    }
    
    /**
     * Waits for the table to contain a row where a cell in a specific column by header text matches the specified text.
     * 
     * @param headerText The header text
     * @param text The text to match
     * @param timeoutSeconds The timeout in seconds
     * @return The CSTable for method chaining
     */
    public CSTable waitForRowWhereColumnEquals(String headerText, String text, int timeoutSeconds) {
        logger.debug("Waiting for row where column " + headerText + " equals " + text + 
                " with timeout: " + timeoutSeconds);
        CSElement tableElement = asElement();
        
        tableElement.waitFor(element -> {
            CSTable refreshedTable = refresh();
            return refreshedTable.hasRowWhereColumnEquals(headerText, text);
        }, timeoutSeconds);
        
        com.cstestforge.framework.core.reporting.CSReporter.getInstance().logInfo(
                "Table contains row where column '" + headerText + "' equals '" + text + "'");
        
        return this;
    }
    
    /**
     * Gets the table element as a CSElement.
     * 
     * @return The table element as a CSElement
     */
    public CSElement asElement() {
        return this;
    }
}


// com/cstestforge/framework/selenium/java/element/CSForm.java
package com.cstestforge.framework.selenium.java.element;

import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.utils.CSLogger;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Enhanced form element wrapper for Selenium WebDriver.
 * This class provides additional methods and functionality for working with HTML forms.
 */
public class CSForm extends CSElement {
    private final CSLogger logger = new CSLogger(CSForm.class);
    private final CSReporter reporter = CSReporter.getInstance();
    
    /**
     * Constructor for CSForm.
     * 
     * @param element The WebElement to wrap
     * @param driver The WebDriver instance
     * @param locator The locator used to find the element
     */
    public CSForm(WebElement element, WebDriver driver, By locator) {
        super(element, driver, locator);
        logger.debug("Created CSForm with locator: " + locator);
    }
    
    /**
     * Constructor for CSForm.
     * 
     * @param element The WebElement to wrap
     * @param driver The WebDriver instance
     */
    public CSForm(WebElement element, WebDriver driver) {
        this(element, driver, null);
    }
    
    /**
     * Constructor for CSForm.
     * 
     * @param csElement The CSElement to wrap
     */
    public CSForm(CSElement csElement) {
        this(csElement.getWrappedElement(), csElement.getWrappedDriver(), csElement.getLocator());
    }
    
    /**
     * Gets all form fields in the form.
     * 
     * @return A list of CSElement objects for the form fields
     */
    public List<CSElement> getAllFields() {
        logger.debug("Getting all form fields");
        
        List<WebElement> fields = getWrappedElement().findElements(
                By.cssSelector("input, select, textarea"));
        
        return fields.stream()
                .map(field -> new CSElement(field, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all input fields in the form.
     * 
     * @return A list of CSElement objects for the input fields
     */
    public List<CSElement> getInputFields() {
        logger.debug("Getting input fields");
        
        List<WebElement> inputs = getWrappedElement().findElements(By.tagName("input"));
        
        return inputs.stream()
                .map(input -> new CSElement(input, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all select elements in the form.
     * 
     * @return A list of CSSelect objects for the select elements
     */
    public List<CSSelect> getSelectFields() {
        logger.debug("Getting select fields");
        
        List<WebElement> selects = getWrappedElement().findElements(By.tagName("select"));
        
        return selects.stream()
                .map(select -> new CSSelect(select, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all textarea elements in the form.
     * 
     * @return A list of CSElement objects for the textarea elements
     */
    public List<CSElement> getTextareaFields() {
        logger.debug("Getting textarea fields");
        
        List<WebElement> textareas = getWrappedElement().findElements(By.tagName("textarea"));
        
        return textareas.stream()
                .map(textarea -> new CSElement(textarea, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets a field by name.
     * 
     * @param name The name attribute value
     * @return A CSElement object for the field, or null if not found
     */
    public CSElement getFieldByName(String name) {
        logger.debug("Getting field by name: " + name);
        
        try {
            WebElement field = getWrappedElement().findElement(By.name(name));
            return new CSElement(field, getWrappedDriver(), By.name(name));
        } catch (org.openqa.selenium.NoSuchElementException e) {
            logger.warn("Field with name '" + name + "' not found", e);
            return null;
        }
    }
    
    /**
     * Gets a field by ID.
     * 
     * @param id The ID attribute value
     * @return A CSElement object for the field, or null if not found
     */
    public CSElement getFieldById(String id) {
        logger.debug("Getting field by ID: " + id);
        
        try {
            WebElement field = getWrappedElement().findElement(By.id(id));
            return new CSElement(field, getWrappedDriver(), By.id(id));
        } catch (org.openqa.selenium.NoSuchElementException e) {
            logger.warn("Field with ID '" + id + "' not found", e);
            return null;
        }
    }
    
    /**
     * Gets a select field by name.
     * 
     * @param name The name attribute value
     * @return A CSSelect object for the select field, or null if not found
     */
    public CSSelect getSelectByName(String name) {
        logger.debug("Getting select field by name: " + name);
        
        CSElement field = getFieldByName(name);
        if (field != null && field.getTagName().equals("select")) {
            return new CSSelect(field);
        }
        
        return null;
    }
    
    /**
     * Gets a select field by ID.
     * 
     * @param id The ID attribute value
     * @return A CSSelect object for the select field, or null if not found
     */
    public CSSelect getSelectById(String id) {
        logger.debug("Getting select field by ID: " + id);
        
        CSElement field = getFieldById(id);
        if (field != null && field.getTagName().equals("select")) {
            return new CSSelect(field);
        }
        
        return null;
    }
    
    /**
     * Submits the form.
     */
    @Override
    public void submit() {
        logger.debug("Submitting form");
        reporter.logInfo("Submitting form");
        
        super.submit();
    }
    
    /**
     * Fills a text field by name.
     * 
     * @param name The name attribute value
     * @param value The value to enter
     * @return The CSForm for method chaining
     * @throws IllegalArgumentException if the field is not found or is not a text field
     */
    public CSForm fillTextFieldByName(String name, String value) {
        logger.debug("Filling text field by name: " + name + " with value: " + value);
        
        CSElement field = getFieldByName(name);
        if (field == null) {
            throw new IllegalArgumentException("Field with name '" + name + "' not found");
        }
        
        String type = field.getAttribute("type");
        if (type != null && (type.equals("checkbox") || type.equals("radio"))) {
            throw new IllegalArgumentException("Field with name '" + name + "' is not a text field");
        }
        
        field.clear();
        field.sendKeys(value);
        
        // Redact if password field
        String logValue = type != null && type.equals("password") ? "********" : value;
        reporter.logInfo("Filled text field '" + name + "' with value: " + logValue);
        
        return this;
    }
    
    /**
     * Fills a text field by ID.
     * 
     * @param id The ID attribute value
     * @param value The value to enter
     * @return The CSForm for method chaining
     * @throws IllegalArgumentException if the field is not found or is not a text field
     */
    public CSForm fillTextFieldById(String id, String value) {
        logger.debug("Filling text field by ID: " + id + " with value: " + value);
        
        CSElement field = getFieldById(id);
        if (field == null) {
            throw new IllegalArgumentException("Field with ID '" + id + "' not found");
        }
        
        String type = field.getAttribute("type");
        if (type != null && (type.equals("checkbox") || type.equals("radio"))) {
            throw new IllegalArgumentException("Field with ID '" + id + "' is not a text field");
        }
        
        field.clear();
        field.sendKeys(value);
        
        // Redact if password field
        String logValue = type != null && type.equals("password") ? "********" : value;
        reporter.logInfo("Filled text field '" + id + "' with value: " + logValue);
        
        return this;
    }
    
    /**
     * Fills a text field by CSS selector.
     * 
     * @param cssSelector The CSS selector
     * @param value The value to enter
     * @return The CSForm for method chaining
     * @throws IllegalArgumentException if the field is not found or is not a text field
     */
    public CSForm fillTextFieldByCss(String cssSelector, String value) {
        logger.debug("Filling text field by CSS selector: " + cssSelector + " with value: " + value);
        
        try {
            WebElement field = getWrappedElement().findElement(By.cssSelector(cssSelector));
            CSElement csField = new CSElement(field, getWrappedDriver(), By.cssSelector(cssSelector));
            
            String type = csField.getAttribute("type");
            if (type != null && (type.equals("checkbox") || type.equals("radio"))) {
                throw new IllegalArgumentException("Field with selector '" + cssSelector + "' is not a text field");
            }
            
            csField.clear();
            csField.sendKeys(value);
            
            // Redact if password field
            String logValue = type != null && type.equals("password") ? "********" : value;
            reporter.logInfo("Filled text field matching '" + cssSelector + "' with value: " + logValue);
            
            return this;
        } catch (org.openqa.selenium.NoSuchElementException e) {
            throw new IllegalArgumentException("Field with selector '" + cssSelector + "' not found", e);
        }
    }
    
    /**
     * Checks a checkbox by name.
     * 
     * @param name The name attribute value
     * @param check Whether to check or uncheck the checkbox
     * @return The CSForm for method chaining
     * @throws IllegalArgumentException if the field is not found or is not a checkbox
     */
    public CSForm setCheckboxByName(String name, boolean check) {
        logger.debug("Setting checkbox by name: " + name + " to: " + check);
        
        CSElement field = getFieldByName(name);
        if (field == null) {
            throw new IllegalArgumentException("Field with name '" + name + "' not found");
        }
        
        String type = field.getAttribute("type");
        if (type == null || !type.equals("checkbox")) {
            throw new IllegalArgumentException("Field with name '" + name + "' is not a checkbox");
        }
        
        boolean isChecked = field.isSelected();
        if (check != isChecked) {
            field.click();
        }
        
        reporter.logInfo("Set checkbox '" + name + "' to: " + check);
        
        return this;
    }
    
    /**
     * Checks a checkbox by ID.
     * 
     * @param id The ID attribute value
     * @param check Whether to check or uncheck the checkbox
     * @return The CSForm for method chaining
     * @throws IllegalArgumentException if the field is not found or is not a checkbox
     */
    public CSForm setCheckboxById(String id, boolean check) {
        logger.debug("Setting checkbox by ID: " + id + " to: " + check);
        
        CSElement field = getFieldById(id);
        if (field == null) {
            throw new IllegalArgumentException("Field with ID '" + id + "' not found");
        }
        
        String type = field.getAttribute("type");
        if (type == null || !type.equals("checkbox")) {
            throw new IllegalArgumentException("Field with ID '" + id + "' is not a checkbox");
        }
        
        boolean isChecked = field.isSelected();
        if (check != isChecked) {
            field.click();
        }
        
        reporter.logInfo("Set checkbox '" + id + "' to: " + check);
        
        return this;
    }
    
    /**
     * Selects a radio button by name and value.
     * 
     * @param name The name attribute value
     * @param value The value attribute value
     * @return The CSForm for method chaining
     * @throws IllegalArgumentException if no matching radio button is found
     */
    public CSForm selectRadioByNameAndValue(String name, String value) {
        logger.debug("Selecting radio button by name: " + name + " and value: " + value);
        
        try {
            WebElement radio = getWrappedElement().findElement(
                    By.cssSelector("input[type='radio'][name='" + name + "'][value='" + value + "']"));
            CSElement csRadio = new CSElement(radio, getWrappedDriver());
            
            if (!csRadio.isSelected()) {
                csRadio.click();
            }
            
            reporter.logInfo("Selected radio button '" + name + "' with value: " + value);
            
            return this;
        } catch (org.openqa.selenium.NoSuchElementException e) {
            throw new IllegalArgumentException(
                    "Radio button with name '" + name + "' and value '" + value + "' not found", e);
        }
    }
    
    /**
     * Selects an option in a select element by name.
     * 
     * @param name The name attribute value of the select element
     * @param optionText The visible text of the option to select
     * @return The CSForm for method chaining
     * @throws IllegalArgumentException if the select element is not found
     */
    public CSForm selectOptionByName(String name, String optionText) {
        logger.debug("Selecting option by name: " + name + " and text: " + optionText);
        
        CSSelect select = getSelectByName(name);
        if (select == null) {
            throw new IllegalArgumentException("Select element with name '" + name + "' not found");
        }
        
        select.selectByVisibleText(optionText);
        
        reporter.logInfo("Selected option '" + optionText + "' in select field '" + name + "'");
        
        return this;
    }
    
    /**
     * Selects an option in a select element by ID.
     * 
     * @param id The ID attribute value of the select element
     * @param optionText The visible text of the option to select
     * @return The CSForm for method chaining
     * @throws IllegalArgumentException if the select element is not found
     */
    public CSForm selectOptionById(String id, String optionText) {
        logger.debug("Selecting option by ID: " + id + " and text: " + optionText);
        
        CSSelect select = getSelectById(id);
        if (select == null) {
            throw new IllegalArgumentException("Select element with ID '" + id + "' not found");
        }
        
        select.selectByVisibleText(optionText);
        
        reporter.logInfo("Selected option '" + optionText + "' in select field '" + id + "'");
        
        return this;
    }
    
    /**
     * Fills a form with data using a map of field names to values.
     * 
     * @param data Map of field names to values
     * @return The CSForm for method chaining
     */
    public CSForm fillByName(Map<String, String> data) {
        logger.debug("Filling form with data by name: " + data);
        reporter.logInfo("Filling form with " + data.size() + " fields");
        
        for (Map.Entry<String, String> entry : data.entrySet()) {
            String name = entry.getKey();
            String value = entry.getValue();
            
            CSElement field = getFieldByName(name);
            if (field == null) {
                logger.warn("Field with name '" + name + "' not found, skipping");
                reporter.logWarning("Field '" + name + "' not found, skipping");
                continue;
            }
            
            String tagName = field.getTagName();
            String type = field.getAttribute("type");
            
            if (tagName.equals("select")) {
                CSSelect select = new CSSelect(field);
                select.selectByVisibleText(value);
                reporter.logInfo("Selected option '" + value + "' in select field '" + name + "'");
            } else if (tagName.equals("textarea")) {
                field.clear();
                field.sendKeys(value);
                reporter.logInfo("Filled textarea '" + name + "' with text");
            } else if (type.equals("checkbox")) {
                boolean check = Boolean.parseBoolean(value);
                boolean isChecked = field.isSelected();
                if (check != isChecked) {
                    field.click();
                }
                reporter.logInfo("Set checkbox '" + name + "' to: " + check);
            } else if (type.equals("radio")) {
                selectRadioByNameAndValue(name, value);
            } else {
                field.clear();
                field.sendKeys(value);
                
                // Redact if password field
                String logValue = type != null && type.equals("password") ? "********" : value;
                reporter.logInfo("Filled field '" + name + "' with value: " + logValue);
            }
        }
        
        return this;
    }
    
    /**
     * Fills a form with data using a map of field IDs to values.
     * 
     * @param data Map of field IDs to values
     * @return The CSForm for method chaining
     */
    public CSForm fillById(Map<String, String> data) {
        logger.debug("Filling form with data by ID: " + data);
        reporter.logInfo("Filling form with " + data.size() + " fields");
        
        for (Map.Entry<String, String> entry : data.entrySet()) {
            String id = entry.getKey();
            String value = entry.getValue();
            
            CSElement field = getFieldById(id);
            if (field == null) {
                logger.warn("Field with ID '" + id + "' not found, skipping");
                reporter.logWarning("Field '" + id + "' not found, skipping");
                continue;
            }
            
            String tagName = field.getTagName();
            String type = field.getAttribute("type");
            
            if (tagName.equals("select")) {
                CSSelect select = new CSSelect(field);
                select.selectByVisibleText(value);
                reporter.logInfo("Selected option '" + value + "' in select field '" + id + "'");
            } else if (tagName.equals("textarea")) {
                field.clear();
                field.sendKeys(value);
                reporter.logInfo("Filled textarea '" + id + "' with text");
            } else if (type.equals("checkbox")) {
                boolean check = Boolean.parseBoolean(value);
                boolean isChecked = field.isSelected();
                if (check != isChecked) {
                    field.click();
                }
                reporter.logInfo("Set checkbox '" + id + "' to: " + check);
            } else if (type.equals("radio")) {
                field.click();
                reporter.logInfo("Selected radio button '" + id + "'");
            } else {
                field.clear();
                field.sendKeys(value);
                
                // Redact if password field
                String logValue = type != null && type.equals("password") ? "********" : value;
                reporter.logInfo("Filled field '" + id + "' with value: " + logValue);
            }
        }
        
        return this;
    }
    
    /**
     * Gets all field values from the form.
     * 
     * @return A map of field names to values
     */
    public Map<String, String> getFieldValues() {
        logger.debug("Getting all field values");
        
        Map<String, String> values = new HashMap<>();
        List<CSElement> fields = getAllFields();
        
        for (CSElement field : fields) {
            String name = field.getAttribute("name");
            if (name == null || name.isEmpty()) {
                continue;
            }
            
            String tagName = field.getTagName();
            String type = field.getAttribute("type");
            
            if (tagName.equals("select")) {
                CSSelect select = new CSSelect(field);
                values.put(name, select.getSelectedText());
            } else if (type != null && type.equals("checkbox")) {
                values.put(name, String.valueOf(field.isSelected()));
            } else if (type != null && type.equals("radio")) {
                if (field.isSelected()) {
                    values.put(name, field.getAttribute("value"));
                }
            } else {
                values.put(name, field.getAttribute("value"));
            }
        }
        
        return values;
    }
    
    /**
     * Clears all form fields.
     * 
     * @return The CSForm for method chaining
     */
    public CSForm clearAllFields() {
        logger.debug("Clearing all form fields");
        reporter.logInfo("Clearing all form fields");
        
        List<CSElement> fields = getAllFields();
        
        for (CSElement field : fields) {
            String tagName = field.getTagName();
            String type = field.getAttribute("type");
            
            if (tagName.equals("select")) {
                // For select elements, select the first option
                CSSelect select = new CSSelect(field);
                if (select.getOptionCount() > 0) {
                    select.selectByIndex(0);
                }
            } else if (type != null && type.equals("checkbox") && field.isSelected()) {
                // Uncheck selected checkboxes
                field.click();
            } else if (type != null && type.equals("radio")) {
                // Skip radio buttons
            } else {
                // Clear text fields
                field.clear();
            }
        }
        
        return this;
    }
    
    /**
     * Gets the number of fields in the form.
     * 
     * @return The number of fields
     */
    public int getFieldCount() {
        return getAllFields().size();
    }
    
    /**
     * Gets the number of required fields in the form.
     * 
     * @return The number of required fields
     */
    public int getRequiredFieldCount() {
        logger.debug("Getting required field count");
        
        List<WebElement> requiredFields = getWrappedElement().findElements(
                By.cssSelector("[required], [aria-required='true']"));
        
        return requiredFields.size();
    }
    
    /**
     * Gets all required fields in the form.
     * 
     * @return A list of CSElement objects for the required fields
     */
    public List<CSElement> getRequiredFields() {
        logger.debug("Getting required fields");
        
        List<WebElement> requiredFields = getWrappedElement().findElements(
                By.cssSelector("[required], [aria-required='true']"));
        
        return requiredFields.stream()
                .map(field -> new CSElement(field, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Checks if a field is required.
     * 
     * @param field The field to check
     * @return true if the field is required, false otherwise
     */
    public boolean isFieldRequired(CSElement field) {
        String required = field.getAttribute("required");
        String ariaRequired = field.getAttribute("aria-required");
        
        return (required != null && !required.isEmpty() && !required.equals("false")) ||
               (ariaRequired != null && ariaRequired.equals("true"));
    }
    
    /**
     * Gets the form element as a CSElement.
     * 
     * @return The form element as a CSElement
     */
    public CSElement asElement() {
        return this;
    }
    
    /**
     * Submits the form by clicking the submit button.
     * 
     * @return The CSForm for method chaining
     * @throws IllegalArgumentException if no submit button is found
     */
    public CSForm submitByClickingButton() {
        logger.debug("Submitting form by clicking submit button");
        
        // Try to find the submit button by type
        try {
            WebElement submitButton = getWrappedElement().findElement(
                    By.cssSelector("button[type='submit'], input[type='submit']"));
            CSElement csSubmitButton = new CSElement(submitButton, getWrappedDriver());
            csSubmitButton.click();
            
            reporter.logInfo("Submitted form by clicking submit button");
            
            return this;
        } catch (org.openqa.selenium.NoSuchElementException e) {
            // Try to find a button with "submit" or "save" text
            try {
                WebElement submitButton = getWrappedElement().findElement(
                        By.xpath(".//button[contains(translate(text(), 'SUBMIT', 'submit'), 'submit') or " +
                                "contains(translate(text(), 'SAVE', 'save'), 'save')]"));
                CSElement csSubmitButton = new CSElement(submitButton, getWrappedDriver());
                csSubmitButton.click();
                
                reporter.logInfo("Submitted form by clicking button with 'submit' or 'save' text");
                
                return this;
            } catch (org.openqa.selenium.NoSuchElementException ex) {
                // Use JavaScript to submit the form
                logger.debug("No submit button found, using JavaScript to submit form");
                
                JavascriptExecutor js = (JavascriptExecutor) getWrappedDriver();
                js.executeScript("arguments[0].submit();", getWrappedElement());
                
                reporter.logInfo("Submitted form using JavaScript");
                
                return this;
            }
        }
    }
    
    /**
     * Validates the form by checking if there are any validation messages.
     * 
     * @return true if the form is valid, false otherwise
     */
    public boolean isValid() {
        logger.debug("Checking if form is valid");
        
        // Check for HTML5 validation
        List<WebElement> invalidFields = getWrappedElement().findElements(
                By.cssSelector(":invalid"));
        
        if (!invalidFields.isEmpty()) {
            logger.debug("Form has " + invalidFields.size() + " invalid fields");
            return false;
        }
        
        // Check for validation messages
        List<WebElement> errorMessages = getWrappedElement().findElements(
                By.cssSelector(".error, .invalid, [aria-invalid='true']"));
        
        if (!errorMessages.isEmpty()) {
            logger.debug("Form has " + errorMessages.size() + " error messages");
            return false;
        }
        
        logger.debug("Form is valid");
        return true;
    }
    
    /**
     * Gets all validation messages from the form.
     * 
     * @return A list of CSElement objects for the validation messages
     */
    public List<CSElement> getValidationMessages() {
        logger.debug("Getting validation messages");
        
        List<WebElement> errorMessages = getWrappedElement().findElements(
                By.cssSelector(".error, .invalid, .help-block, .form-error"));
        
        return errorMessages.stream()
                .map(message -> new CSElement(message, getWrappedDriver()))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets the validation message for a specific field.
     * 
     * @param field The field to get the validation message for
     * @return The validation message as a CSElement, or null if not found
     */
    public CSElement getValidationMessageForField(CSElement field) {
        logger.debug("Getting validation message for field");
        
        // Check for HTML5 validation message
        String validationMessage = (String) ((JavascriptExecutor) getWrappedDriver())
                .executeScript("return arguments[0].validationMessage;", field.getWrappedElement());
        
        if (validationMessage != null && !validationMessage.isEmpty()) {
            logger.debug("Found HTML5 validation message: " + validationMessage);
            return field;
        }
        
        // Check for aria-describedby
        String describedBy = field.getAttribute("aria-describedby");
        if (describedBy != null && !describedBy.isEmpty()) {
            try {
                WebElement errorMessage = getWrappedDriver().findElement(By.id(describedBy));
                return new CSElement(errorMessage, getWrappedDriver());
            } catch (org.openqa.selenium.NoSuchElementException e) {
                // Ignore
            }
        }
        
        // Check for adjacent error message
        String id = field.getAttribute("id");
        if (id != null && !id.isEmpty()) {
            try {
                WebElement errorMessage = getWrappedDriver().findElement(
                        By.cssSelector("[for='" + id + "'] .error, #" + id + " + .error, #" + id + " ~ .error"));
                return new CSElement(errorMessage, getWrappedDriver());
            } catch (org.openqa.selenium.NoSuchElementException e) {
                // Ignore
            }
        }
        
        return null;
    }
    
    /**
     * Gets the form element as a CSForm.
     * 
     * @return The form element as a CSForm
     */
    public CSForm asForm() {
        return this;
    }
}


// com/cstestforge/framework/selenium/java/base/CSBaseTest.java
package com.cstestforge.framework.selenium.java.base;

import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.testng.ITestContext;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;
import org.testng.annotations.Listeners;
import org.testng.annotations.Optional;
import org.testng.annotations.Parameters;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSScreenshotManager;
import com.cstestforge.framework.selenium.java.browser.CSBrowserManager;
import com.cstestforge.framework.selenium.java.browser.CSWebDriverManager;
import com.cstestforge.framework.selenium.java.listeners.CSTestListener;

import java.io.File;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * Base test class for Selenium tests.
 * This class provides common functionality for all test classes.
 */
@Listeners(CSTestListener.class)
public class CSBaseTest {
    private static final CSLogger logger = new CSLogger(CSBaseTest.class);
    private static final CSReporter reporter = CSReporter.getInstance();
    private static final CSScreenshotManager screenshotManager = new CSScreenshotManager();
    private static final ConfigurationManager configManager = ConfigurationManager.getInstance();
    
    private static final ThreadLocal<Map<String, Object>> testData = new ThreadLocal<>();
    
    /**
     * Sets up the test suite.
     * 
     * @param context The test context
     */
    @BeforeSuite(alwaysRun = true)
    public void setupSuite(ITestContext context) {
        logger.info("Setting up test suite: " + context.getSuite().getName());
        reporter.startSuite(context.getSuite().getName());
        
        // Initialize any suite-level resources or configurations
        String configFile = context.getSuite().getParameter("configFile");
        if (configFile != null && !configFile.isEmpty()) {
            configManager.loadConfig(configFile);
            logger.info("Loaded configuration from: " + configFile);
        }
    }
    
    /**
     * Cleans up after the test suite.
     * 
     * @param context The test context
     */
    @AfterSuite(alwaysRun = true)
    public void tearDownSuite(ITestContext context) {
        logger.info("Tearing down test suite: " + context.getSuite().getName());
        
        // Clean up any suite-level resources
        CSWebDriverManager.getInstance().quitAllDrivers();
        
        reporter.endSuite();
    }
    
    /**
     * Sets up before each test method.
     * 
     * @param method The test method
     * @param context The test context
     * @param browser The browser to use (optional)
     */
    @BeforeMethod(alwaysRun = true)
    @Parameters({"browser"})
    public void setupTest(Method method, ITestContext context, @Optional String browser) {
        String testName = method.getName();
        String className = method.getDeclaringClass().getSimpleName();
        String fullTestName = className + "." + testName;
        
        logger.info("Setting up test: " + fullTestName);
        reporter.startTest(fullTestName);
        
        // Initialize test data
        testData.set(new HashMap<>());
        
        // Set browser if specified
        if (browser != null && !browser.isEmpty()) {
            configManager.getFrameworkConfig().setBrowserType(browser);
            logger.info("Using browser: " + browser);
        }
        
        // Initialize WebDriver if configured to do so
        if (configManager.getFrameworkConfig().isInitializeDriverBeforeTest()) {
            getDriver();
            logger.info("WebDriver initialized");
        }
    }
    
    /**
     * Cleans up after each test method.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void tearDownTest(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        String className = result.getMethod().getTestClass().getName();
        String fullTestName = className + "." + testName;
        
        logger.info("Tearing down test: " + fullTestName);
        
        // Take screenshot on failure if configured
        if (result.getStatus() == ITestResult.FAILURE) {
            takeScreenshot("failure_" + testName);
            logger.error("Test failed: " + fullTestName);
            
            // Log failure details
            if (result.getThrowable() != null) {
                logger.error("Failure reason: " + result.getThrowable().getMessage(), result.getThrowable());
                reporter.logError("Test failed: " + result.getThrowable().getMessage());
            }
        } else if (result.getStatus() == ITestResult.SUCCESS) {
            logger.info("Test passed: " + fullTestName);
            // Continuation of com/cstestforge/framework/selenium/java/base/CSBaseTest.java
            reporter.logInfo("Test passed successfully");
        } else if (result.getStatus() == ITestResult.SKIP) {
            logger.info("Test skipped: " + fullTestName);
            reporter.logWarning("Test skipped");
            
            // Log skip details
            if (result.getThrowable() != null) {
                logger.info("Skip reason: " + result.getThrowable().getMessage(), result.getThrowable());
                reporter.logWarning("Skip reason: " + result.getThrowable().getMessage());
            }
        }
        
        // Clean up test data
        testData.remove();
        
        // Quit the driver if configured to do so
        if (configManager.getFrameworkConfig().isQuitDriverAfterTest()) {
            quitDriver();
            logger.info("WebDriver quit after test");
        }
        
        reporter.endTest();
    }
    
    /**
     * Gets the WebDriver instance for the current thread.
     * 
     * @return The WebDriver instance
     */
    protected WebDriver getDriver() {
        return CSWebDriverManager.getInstance().getDriver();
    }
    
    /**
     * Gets the browser manager for the current thread.
     * 
     * @return The browser manager
     */
    protected CSBrowserManager getBrowser() {
        return CSBrowserManager.getInstance();
    }
    
    /**
     * Navigates to the specified URL.
     * 
     * @param url The URL to navigate to
     */
    protected void navigateTo(String url) {
        logger.info("Navigating to URL: " + url);
        reporter.logInfo("Navigating to: " + url);
        getBrowser().navigateTo(url);
    }
    
    /**
     * Takes a screenshot with the specified name.
     * 
     * @param screenshotName The name for the screenshot
     * @return The path to the screenshot file
     */
    protected String takeScreenshot(String screenshotName) {
        if (!CSWebDriverManager.getInstance().hasDriver()) {
            logger.warn("Cannot take screenshot: WebDriver not initialized");
            return null;
        }
        
        WebDriver driver = getDriver();
        if (driver instanceof TakesScreenshot) {
            try {
                File screenshotFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
                String screenshotPath = screenshotManager.saveScreenshot(screenshotFile, screenshotName);
                
                logger.info("Screenshot taken: " + screenshotPath);
                reporter.attachScreenshot(screenshotPath, screenshotName);
                
                return screenshotPath;
            } catch (Exception e) {
                logger.error("Error taking screenshot: " + e.getMessage(), e);
                reporter.logError("Failed to take screenshot: " + e.getMessage());
                return null;
            }
        } else {
            logger.warn("WebDriver does not support taking screenshots");
            return null;
        }
    }
    
    /**
     * Executes JavaScript in the browser.
     * 
     * @param script The JavaScript to execute
     * @param args The arguments to pass to the script
     * @return The result of the script execution
     */
    protected Object executeJavaScript(String script, Object... args) {
        if (!CSWebDriverManager.getInstance().hasDriver()) {
            logger.warn("Cannot execute JavaScript: WebDriver not initialized");
            return null;
        }
        
        WebDriver driver = getDriver();
        if (driver instanceof JavascriptExecutor) {
            try {
                logger.debug("Executing JavaScript: " + script);
                return ((JavascriptExecutor) driver).executeScript(script, args);
            } catch (Exception e) {
                logger.error("Error executing JavaScript: " + e.getMessage(), e);
                reporter.logError("JavaScript execution failed: " + e.getMessage());
                return null;
            }
        } else {
            logger.warn("WebDriver does not support JavaScript execution");
            return null;
        }
    }
    
    /**
     * Executes asynchronous JavaScript in the browser.
     * 
     * @param script The JavaScript to execute
     * @param args The arguments to pass to the script
     * @return The result of the script execution
     */
    protected Object executeAsyncJavaScript(String script, Object... args) {
        if (!CSWebDriverManager.getInstance().hasDriver()) {
            logger.warn("Cannot execute async JavaScript: WebDriver not initialized");
            return null;
        }
        
        WebDriver driver = getDriver();
        if (driver instanceof JavascriptExecutor) {
            try {
                logger.debug("Executing async JavaScript: " + script);
                return ((JavascriptExecutor) driver).executeAsyncScript(script, args);
            } catch (Exception e) {
                logger.error("Error executing async JavaScript: " + e.getMessage(), e);
                reporter.logError("Async JavaScript execution failed: " + e.getMessage());
                return null;
            }
        } else {
            logger.warn("WebDriver does not support JavaScript execution");
            return null;
        }
    }
    
    /**
     * Quits the WebDriver for the current thread.
     */
    protected void quitDriver() {
        logger.info("Quitting WebDriver");
        CSWebDriverManager.getInstance().quitDriver();
    }
    
    /**
     * Sets test data for the current thread.
     * 
     * @param key The key for the data
     * @param value The value to store
     */
    protected void setTestData(String key, Object value) {
        if (testData.get() == null) {
            testData.set(new HashMap<>());
        }
        testData.get().put(key, value);
    }
    
    /**
     * Gets test data for the current thread.
     * 
     * @param key The key for the data
     * @param <T> The type of the data
     * @return The stored value, or null if not found
     */
    @SuppressWarnings("unchecked")
    protected <T> T getTestData(String key) {
        if (testData.get() == null) {
            return null;
        }
        return (T) testData.get().get(key);
    }
    
    /**
     * Clears test data for the current thread.
     */
    protected void clearTestData() {
        if (testData.get() != null) {
            testData.get().clear();
        }
    }
    
    /**
     * Waits for the specified number of milliseconds.
     * <p>
     * Note: This method should be used sparingly and only when necessary.
     * Prefer using explicit waits instead.
     * 
     * @param millis The number of milliseconds to wait
     */
    protected void waitFor(long millis) {
        logger.debug("Waiting for " + millis + " ms");
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.warn("Wait interrupted", e);
        }
    }
    
    /**
     * Logs a step in the test execution.
     * 
     * @param stepDescription The description of the step
     */
    protected void logStep(String stepDescription) {
        logger.info("STEP: " + stepDescription);
        reporter.logInfo("STEP: " + stepDescription);
    }
    
    /**
     * Asserts a condition with a descriptive message.
     * 
     * @param condition The condition to assert
     * @param message The message to include in the assertion
     * @throws AssertionError if the condition is false
     */
    protected void assertThat(boolean condition, String message) {
        if (!condition) {
            logger.error("Assertion failed: " + message);
            reporter.logError("Assertion failed: " + message);
            org.testng.Assert.fail(message);
        } else {
            logger.info("Assertion passed: " + message);
            reporter.logInfo("Assertion passed: " + message);
        }
    }
    
    /**
     * Asserts that two objects are equal with a descriptive message.
     * 
     * @param actual The actual value
     * @param expected The expected value
     * @param message The message to include in the assertion
     * @throws AssertionError if the objects are not equal
     */
    protected void assertEquals(Object actual, Object expected, String message) {
        if ((actual == null && expected != null) || (actual != null && !actual.equals(expected))) {
            logger.error("Assertion failed: " + message + " - Expected: [" + expected + "], Actual: [" + actual + "]");
            reporter.logError("Assertion failed: " + message + " - Expected: [" + expected + "], Actual: [" + actual + "]");
            org.testng.Assert.assertEquals(actual, expected, message);
        } else {
            logger.info("Assertion passed: " + message);
            reporter.logInfo("Assertion passed: " + message);
        }
    }
    
    /**
     * Asserts that an object is not null with a descriptive message.
     * 
     * @param object The object to check
     * @param message The message to include in the assertion
     * @throws AssertionError if the object is null
     */
    protected void assertNotNull(Object object, String message) {
        if (object == null) {
            logger.error("Assertion failed: " + message + " - Object is null");
            reporter.logError("Assertion failed: " + message + " - Object is null");
            org.testng.Assert.assertNotNull(object, message);
        } else {
            logger.info("Assertion passed: " + message);
            reporter.logInfo("Assertion passed: " + message);
        }
    }
    
    /**
     * Asserts that a string contains a substring with a descriptive message.
     * 
     * @param actual The actual string
     * @param expectedSubstring The expected substring
     * @param message The message to include in the assertion
     * @throws AssertionError if the string does not contain the substring
     */
    protected void assertContains(String actual, String expectedSubstring, String message) {
        if (actual == null || !actual.contains(expectedSubstring)) {
            logger.error("Assertion failed: " + message + " - Expected substring: [" + expectedSubstring + "], Actual: [" + actual + "]");
            reporter.logError("Assertion failed: " + message + " - Expected substring: [" + expectedSubstring + "], Actual: [" + actual + "]");
            org.testng.Assert.assertTrue(actual != null && actual.contains(expectedSubstring), message);
        } else {
            logger.info("Assertion passed: " + message);
            reporter.logInfo("Assertion passed: " + message);
        }
    }
    
    /**
     * Gets a page object of the specified type.
     * 
     * @param pageClass The class of the page object
     * @param <T> The type of the page object
     * @return A new instance of the page object
     */
    protected <T extends CSBasePage> T getPage(Class<T> pageClass) {
        logger.debug("Creating page object: " + pageClass.getSimpleName());
        
        try {
            T page = pageClass.getDeclaredConstructor(WebDriver.class).newInstance(getDriver());
            logger.debug("Page object created: " + pageClass.getSimpleName());
            return page;
        } catch (Exception e) {
            logger.error("Error creating page object: " + e.getMessage(), e);
            reporter.logError("Failed to create page object: " + e.getMessage());
            throw new RuntimeException("Failed to create page object: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a new CSPageFactory for creating page objects with enhanced elements.
     * 
     * @return A new CSPageFactory instance
     */
    protected CSPageFactory createPageFactory() {
        return new CSPageFactory(getDriver());
    }
    
    /**
     * Initializes a page object using the CSPageFactory.
     * 
     * @param page The page object to initialize
     * @param <T> The type of the page object
     * @return The initialized page object
     */
    protected <T> T initPage(T page) {
        logger.debug("Initializing page object: " + page.getClass().getSimpleName());
        return createPageFactory().initElements(page);
    }
}



// com/cstestforge/framework/selenium/java/base/CSBasePage.java
package com.cstestforge.framework.selenium.java.base;

import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.selenium.java.annotations.CSFindBy;
import com.cstestforge.framework.selenium.java.annotations.CSPage;
import com.cstestforge.framework.selenium.java.element.CSElement;
import com.cstestforge.framework.selenium.java.element.CSElementList;
import com.cstestforge.framework.selenium.java.element.CSForm;
import com.cstestforge.framework.selenium.java.element.CSSelect;
import com.cstestforge.framework.selenium.java.element.CSTable;

import java.time.Duration;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Base page object class for Selenium page objects.
 * This class provides common functionality for all page object classes.
 */
public abstract class CSBasePage {
    protected final WebDriver driver;
    protected final CSLogger logger;
    protected final CSReporter reporter;
    protected final ConfigurationManager configManager;
    
    /**
     * Constructor for CSBasePage.
     * 
     * @param driver The WebDriver instance
     */
    public CSBasePage(WebDriver driver) {
        this.driver = driver;
        this.logger = new CSLogger(getClass());
        this.reporter = CSReporter.getInstance();
        this.configManager = ConfigurationManager.getInstance();
        
        // Check if the page is annotated with @CSPage
        CSPage pageAnnotation = getClass().getAnnotation(CSPage.class);
        if (pageAnnotation != null) {
            String url = pageAnnotation.url();
            if (!url.isEmpty() && pageAnnotation.autoLoad()) {
                // Auto-navigate to the page URL if configured
                navigateTo(url);
            }
        }
        
        // Initialize page elements
        initElements();
        
        // Verify page if enabled
        if (pageAnnotation != null && pageAnnotation.autoVerify()) {
            verifyPage();
        }
    }
    
    /**
     * Initializes page elements using CSPageFactory.
     */
    protected void initElements() {
        logger.debug("Initializing elements for page: " + getClass().getSimpleName());
        
        try {
            // Use CSPageFactory to initialize elements with CS* wrappers
            CSPageFactory pageFactory = new CSPageFactory(driver);
            pageFactory.initElements(this);
            
            logger.debug("Elements initialized successfully");
        } catch (Exception e) {
            logger.error("Error initializing elements: " + e.getMessage(), e);
            reporter.logError("Failed to initialize page elements: " + e.getMessage());
            throw new RuntimeException("Failed to initialize page elements", e);
        }
    }
    
    /**
     * Verifies that the page is loaded correctly.
     * 
     * @return true if the page is loaded correctly, false otherwise
     */
    public boolean verifyPage() {
        logger.debug("Verifying page: " + getClass().getSimpleName());
        
        // Check for @CSPage annotation
        CSPage pageAnnotation = getClass().getAnnotation(CSPage.class);
        
        if (pageAnnotation != null) {
            // Check page title if specified
            String expectedTitle = pageAnnotation.title();
            if (!expectedTitle.isEmpty()) {
                boolean titleMatches = driver.getTitle().matches(expectedTitle);
                if (!titleMatches) {
                    logger.warn("Page title verification failed. Expected: " + expectedTitle + ", Actual: " + driver.getTitle());
                    reporter.logWarning("Page title verification failed. Expected: " + expectedTitle + ", Actual: " + driver.getTitle());
                    return false;
                }
            }
            
            // Check URL if specified
            String expectedUrl = pageAnnotation.urlPattern();
            if (!expectedUrl.isEmpty()) {
                boolean urlMatches = driver.getCurrentUrl().matches(expectedUrl);
                if (!urlMatches) {
                    logger.warn("Page URL verification failed. Expected pattern: " + expectedUrl + ", Actual: " + driver.getCurrentUrl());
                    reporter.logWarning("Page URL verification failed. Expected pattern: " + expectedUrl + ", Actual: " + driver.getCurrentUrl());
                    return false;
                }
            }
            
            // Check readiness indicators if specified
            String[] readyIndicators = pageAnnotation.readyIndicators();
            if (readyIndicators.length > 0) {
                for (String indicator : readyIndicators) {
                    try {
                        By locator = By.cssSelector(indicator);
                        waitForElementVisible(locator, pageAnnotation.timeoutSeconds());
                    } catch (TimeoutException e) {
                        logger.warn("Page readiness indicator not found: " + indicator);
                        reporter.logWarning("Page readiness indicator not found: " + indicator);
                        return false;
                    }
                }
            }
        }
        
        // Default implementation - override in subclasses for more specific verification
        logger.info("Page verified successfully: " + getClass().getSimpleName());
        reporter.logInfo("Page verified: " + getClass().getSimpleName());
        return true;
    }
    
    /**
     * Waits for a condition to be true.
     * 
     * @param <T> The type of the condition result
     * @param condition The condition to wait for
     * @param timeoutSeconds The timeout in seconds
     * @return The condition result
     * @throws TimeoutException if the condition is not met within the timeout
     */
    protected <T> T waitFor(java.util.function.Function<WebDriver, T> condition, long timeoutSeconds) {
        logger.debug("Waiting for condition with timeout: " + timeoutSeconds + " seconds");
        return new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds)).until(condition);
    }
    
    /**
     * Waits for a condition to be true using the default timeout.
     * 
     * @param <T> The type of the condition result
     * @param condition The condition to wait for
     * @return The condition result
     * @throws TimeoutException if the condition is not met within the timeout
     */
    protected <T> T waitFor(java.util.function.Function<WebDriver, T> condition) {
        return waitFor(condition, configManager.getFrameworkConfig().getExplicitWaitSeconds());
    }
    
    /**
     * Waits for an element to be visible.
     * 
     * @param locator The locator for the element
     * @param timeoutSeconds The timeout in seconds
     * @return The WebElement once it is visible
     * @throws TimeoutException if the element is not visible within the timeout
     */
    protected WebElement waitForElementVisible(By locator, long timeoutSeconds) {
        logger.debug("Waiting for element to be visible: " + locator + " with timeout: " + timeoutSeconds + " seconds");
        return waitFor(ExpectedConditions.visibilityOfElementLocated(locator), timeoutSeconds);
    }
    
    /**
     * Waits for an element to be visible using the default timeout.
     * 
     * @param locator The locator for the element
     * @return The WebElement once it is visible
     * @throws TimeoutException if the element is not visible within the timeout
     */
    protected WebElement waitForElementVisible(By locator) {
        return waitForElementVisible(locator, configManager.getFrameworkConfig().getExplicitWaitSeconds());
    }
    
    /**
     * Waits for an element to be clickable.
     * 
     * @param locator The locator for the element
     * @param timeoutSeconds The timeout in seconds
     * @return The WebElement once it is clickable
     * @throws TimeoutException if the element is not clickable within the timeout
     */
    protected WebElement waitForElementClickable(By locator, long timeoutSeconds) {
        logger.debug("Waiting for element to be clickable: " + locator + " with timeout: " + timeoutSeconds + " seconds");
        return waitFor(ExpectedConditions.elementToBeClickable(locator), timeoutSeconds);
    }
    
    /**
     * Waits for an element to be clickable using the default timeout.
     * 
     * @param locator The locator for the element
     * @return The WebElement once it is clickable
     * @throws TimeoutException if the element is not clickable within the timeout
     */
    protected WebElement waitForElementClickable(By locator) {
        return waitForElementClickable(locator, configManager.getFrameworkConfig().getExplicitWaitSeconds());
    }
    
    /**
     * Waits for an element to be present in the DOM.
     * 
     * @param locator The locator for the element
     * @param timeoutSeconds The timeout in seconds
     * @return The WebElement once it is present
     * @throws TimeoutException if the element is not present within the timeout
     */
    protected WebElement waitForElementPresent(By locator, long timeoutSeconds) {
        logger.debug("Waiting for element to be present: " + locator + " with timeout: " + timeoutSeconds + " seconds");
        return waitFor(ExpectedConditions.presenceOfElementLocated(locator), timeoutSeconds);
    }
    
    /**
     * Waits for an element to be present in the DOM using the default timeout.
     * 
     * @param locator The locator for the element
     * @return The WebElement once it is present
     * @throws TimeoutException if the element is not present within the timeout
     */
    protected WebElement waitForElementPresent(By locator) {
        return waitForElementPresent(locator, configManager.getFrameworkConfig().getExplicitWaitSeconds());
    }
    
    /**
     * Waits for an element to have specific text.
     * 
     * @param locator The locator for the element
     * @param text The expected text
     * @param timeoutSeconds The timeout in seconds
     * @return true if the element has the specified text within the timeout
     * @throws TimeoutException if the element does not have the specified text within the timeout
     */
    protected boolean waitForElementText(By locator, String text, long timeoutSeconds) {
        logger.debug("Waiting for element to have text: " + text + " with timeout: " + timeoutSeconds + " seconds");
        return waitFor(ExpectedConditions.textToBePresentInElementLocated(locator, text), timeoutSeconds);
    }
    
    /**
     * Waits for an element to have specific text using the default timeout.
     * 
     * @param locator The locator for the element
     * @param text The expected text
     * @return true if the element has the specified text within the timeout
     * @throws TimeoutException if the element does not have the specified text within the timeout
     */
    protected boolean waitForElementText(By locator, String text) {
        return waitForElementText(locator, text, configManager.getFrameworkConfig().getExplicitWaitSeconds());
    }
    
    /**
     * Finds an element and wraps it in a CSElement.
     * 
     * @param locator The locator for the element
     * @return A CSElement wrapping the found element
     * @throws org.openqa.selenium.NoSuchElementException if the element is not found
     */
    protected CSElement findElement(By locator) {
        logger.debug("Finding element: " + locator);
        WebElement element = driver.findElement(locator);
        return new CSElement(element, driver, locator);
    }
    
    /**
     * Finds elements and wraps them in CSElement objects.
     * 
     * @param locator The locator for the elements
     * @return A list of CSElement objects wrapping the found elements
     */
    protected CSElementList findElements(By locator) {
        logger.debug("Finding elements: " + locator);
        List<WebElement> elements = driver.findElements(locator);
        return new CSElementList(elements, driver, locator);
    }
    
    /**
     * Finds a select element and wraps it in a CSSelect.
     * 
     * @param locator The locator for the select element
     * @return A CSSelect wrapping the found select element
     * @throws org.openqa.selenium.NoSuchElementException if the element is not found
     * @throws IllegalArgumentException if the element is not a select element
     */
    protected CSSelect findSelect(By locator) {
        logger.debug("Finding select element: " + locator);
        WebElement element = driver.findElement(locator);
        if (!element.getTagName().equalsIgnoreCase("select")) {
            throw new IllegalArgumentException("Element is not a select element: " + locator);
        }
        return new CSSelect(element, driver, locator);
    }
    
    /**
     * Finds a table element and wraps it in a CSTable.
     * 
     * @param locator The locator for the table element
     * @return A CSTable wrapping the found table element
     * @throws org.openqa.selenium.NoSuchElementException if the element is not found
     * @throws IllegalArgumentException if the element is not a table element
     */
    protected CSTable findTable(By locator) {
        logger.debug("Finding table element: " + locator);
        WebElement element = driver.findElement(locator);
        if (!element.getTagName().equalsIgnoreCase("table")) {
            throw new IllegalArgumentException("Element is not a table element: " + locator);
        }
        return new CSTable(element, driver, locator);
    }
    
    /**
     * Finds a form element and wraps it in a CSForm.
     * 
     * @param locator The locator for the form element
     * @return A CSForm wrapping the found form element
     * @throws org.openqa.selenium.NoSuchElementException if the element is not found
     * @throws IllegalArgumentException if the element is not a form element
     */
    protected CSForm findForm(By locator) {
        logger.debug("Finding form element: " + locator);
        WebElement element = driver.findElement(locator);
        if (!element.getTagName().equalsIgnoreCase("form")) {
            throw new IllegalArgumentException("Element is not a form element: " + locator);
        }
        return new CSForm(element, driver, locator);
    }
    
    /**
     * Executes JavaScript in the browser.
     * 
     * @param script The JavaScript to execute
     * @param args The arguments to pass to the script
     * @return The result of the script execution
     */
    protected Object executeJavaScript(String script, Object... args) {
        logger.debug("Executing JavaScript: " + script);
        return ((JavascriptExecutor) driver).executeScript(script, args);
    }
    
    /**
     * Navigates to the specified URL.
     * 
     * @param url The URL to navigate to
     */
    protected void navigateTo(String url) {
        logger.info("Navigating to URL: " + url);
        reporter.logInfo("Navigating to: " + url);
        driver.get(url);
    }
    
    /**
     * Gets the current page URL.
     * 
     * @return The current page URL
     */
    protected String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
    
    /**
     * Gets the current page title.
     * 
     * @return The current page title
     */
    protected String getTitle() {
        return driver.getTitle();
    }
    
    /**
     * Refreshes the current page.
     */
    protected void refresh() {
        logger.info("Refreshing page");
        reporter.logInfo("Refreshing page");
        driver.navigate().refresh();
    }
    
    /**
     * Navigates back in the browser history.
     */
    protected void back() {
        logger.info("Navigating back");
        reporter.logInfo("Navigating back");
        driver.navigate().back();
    }
    
    /**
     * Navigates forward in the browser history.
     */
    protected void forward() {
        logger.info("Navigating forward");
        reporter.logInfo("Navigating forward");
        driver.navigate().forward();
    }
    
    /**
     * Waits for the page to load completely.
     * 
     * @param timeoutSeconds The timeout in seconds
     * @return true if the page loaded successfully, false otherwise
     */
    protected boolean waitForPageLoad(long timeoutSeconds) {
        logger.debug("Waiting for page to load with timeout: " + timeoutSeconds + " seconds");
        
        try {
            // Wait for the document.readyState to be "complete"
            Object result = waitFor(driver -> {
                return ((JavascriptExecutor) driver).executeScript("return document.readyState");
            }, timeoutSeconds);
            
            if (!"complete".equals(result)) {
                logger.warn("Page did not reach 'complete' state within timeout. Current state: " + result);
                return false;
            }
            
            // Wait for jQuery to be inactive (if present)
            result = executeJavaScript(
                    "if (typeof jQuery !== 'undefined') { return jQuery.active === 0; } else { return true; }");
            
            if (Boolean.FALSE.equals(result)) {
                logger.warn("jQuery activity did not complete within timeout");
                return false;
            }
            
            // Wait for Angular to be stable (if present)
            result = executeJavaScript(
                    "if (typeof angular !== 'undefined' && angular.element(document).injector()) { " +
                    "   return angular.element(document).injector().get('$http').pendingRequests.length === 0; " +
                    "} else { " +
                    "   return true; " +
                    "}");
            
            if (Boolean.FALSE.equals(result)) {
                logger.warn("Angular activity did not complete within timeout");
                return false;
            }
            
            logger.debug("Page loaded successfully");
            return true;
        } catch (TimeoutException e) {
            logger.warn("Timeout waiting for page to load", e);
            return false;
        } catch (Exception e) {
            logger.error("Error waiting for page to load: " + e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Waits for the page to load completely using the default timeout.
     * 
     * @return true if the page loaded successfully, false otherwise
     */
    protected boolean waitForPageLoad() {
        return waitForPageLoad(configManager.getFrameworkConfig().getPageLoadTimeoutSeconds());
    }
    
    /**
     * Logs a step in the test execution.
     * 
     * @param stepDescription The description of the step
     */
    protected void logStep(String stepDescription) {
        logger.info("STEP: " + stepDescription);
        reporter.logInfo("STEP: " + stepDescription);
    }
}


// com/cstestforge/framework/selenium/java/base/CSPageFactory.java
package com.cstestforge.framework.selenium.java.base;

import org.openqa.selenium.By;
import org.openqa.selenium.SearchContext;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.CacheLookup;
import org.openqa.selenium.support.FindAll;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.FindBys;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.pagefactory.AjaxElementLocator;
import org.openqa.selenium.support.pagefactory.AjaxElementLocatorFactory;
import org.openqa.selenium.support.pagefactory.DefaultElementLocatorFactory;
import org.openqa.selenium.support.pagefactory.DefaultFieldDecorator;
import org.openqa.selenium.support.pagefactory.ElementLocator;
import org.openqa.selenium.support.pagefactory.ElementLocatorFactory;
import org.openqa.selenium.support.pagefactory.FieldDecorator;
import org.openqa.selenium.support.pagefactory.internal.LocatingElementHandler;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.selenium.java.annotations.CSFindBy;
import com.cstestforge.framework.selenium.java.element.CSElement;
import com.cstestforge.framework.selenium.java.element.CSElementList;
import com.cstestforge.framework.selenium.java.element.CSForm;
import com.cstestforge.framework.selenium.java.element.CSSelect;
import com.cstestforge.framework.selenium.java.element.CSTable;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.List;

/**
 * Enhanced page factory for initializing page elements with CS* wrappers.
 * This class extends the standard Selenium PageFactory to support CSFindBy annotation
 * and to wrap elements in CS* wrappers.
 */
public class CSPageFactory {
    private static final CSLogger logger = new CSLogger(CSPageFactory.class);
    private final WebDriver driver;
    private final ElementLocatorFactory elementLocatorFactory;
    private final CSFieldDecorator fieldDecorator;
    
    /**
     * Constructor for CSPageFactory.
     * 
     * @param driver The WebDriver instance
     */
    public CSPageFactory(WebDriver driver) {
        this.driver = driver;
        int timeoutInSeconds = ConfigurationManager.getInstance().getFrameworkConfig().getElementLocatorTimeoutSeconds();
        this.elementLocatorFactory = new AjaxElementLocatorFactory(driver, timeoutInSeconds);
        this.fieldDecorator = new CSFieldDecorator(elementLocatorFactory, driver);
    }
    
    /**
     * Constructor for CSPageFactory with custom element locator factory.
     * 
     * @param driver The WebDriver instance
     * @param elementLocatorFactory The element locator factory
     */
    public CSPageFactory(WebDriver driver, ElementLocatorFactory elementLocatorFactory) {
        this.driver = driver;
        this.elementLocatorFactory = elementLocatorFactory;
        this.fieldDecorator = new CSFieldDecorator(elementLocatorFactory, driver);
    }
    
    /**
     * Initializes the elements in a page object.
     * 
     * @param pageObject The page object to initialize
     * @param <T> The type of the page object
     * @return The initialized page object
     */
    public <T> T initElements(T pageObject) {
        logger.debug("Initializing elements in page object: " + pageObject.getClass().getSimpleName());
        
        Class<?> proxyIn = pageObject.getClass();
        while (proxyIn != Object.class) {
            proxyFields(pageObject, proxyIn);
            proxyIn = proxyIn.getSuperclass();
        }
        
        return pageObject;
    }
    
    /**
     * Initializes the elements in a page object class.
     * 
     * @param pageObjectClass The page object class
     * @param <T> The type of the page object
     * @return A new instance of the initialized page object
     */
    public <T> T initElements(Class<T> pageObjectClass) {
        logger.debug("Initializing elements in page object class: " + pageObjectClass.getSimpleName());
        
        try {
            Constructor<T> constructor = pageObjectClass.getConstructor(WebDriver.class);
            T page = constructor.newInstance(driver);
            return initElements(page);
        } catch (Exception e) {
            logger.error("Error creating page object: " + e.getMessage(), e);
            throw new RuntimeException("Error creating page object", e);
        }
    }
    
    /**
     * Processes fields in a class to proxy them.
     * 
     * @param instance The object instance
     * @param proxyIn The class to process
     */
    private void proxyFields(Object instance, Class<?> proxyIn) {
        Field[] fields = proxyIn.getDeclaredFields();
        for (Field field : fields) {
            Object value = fieldDecorator.decorate(instance.getClass().getClassLoader(), field);
            if (value != null) {
                try {
                    field.setAccessible(true);
                    field.set(instance, value);
                } catch (IllegalAccessException e) {
                    logger.error("Error setting field value: " + e.getMessage(), e);
                    throw new RuntimeException("Error setting field value", e);
                }
            }
        }
    }
    
    /**
     * Custom field decorator for handling CS* element wrappers.
     */
    private class CSFieldDecorator extends DefaultFieldDecorator {
        private final WebDriver driver;
        
        /**
         * Constructor for CSFieldDecorator.
         * 
         * @param factory The element locator factory
         * @param driver The WebDriver instance
         */
        public CSFieldDecorator(ElementLocatorFactory factory, WebDriver driver) {
            super(factory);
            this.driver = driver;
        }
        
        @Override
        public Object decorate(ClassLoader loader, Field field) {
            // Check for CSFindBy annotation
            CSFindBy csFindBy = field.getAnnotation(CSFindBy.class);
            if (csFindBy != null) {
                return decorateWithCSFindBy(loader, field, csFindBy);
            }
            
            // Use standard annotations if CSFindBy is not present
            if (field.getAnnotation(FindBy.class) != null ||
                    field.getAnnotation(FindBys.class) != null ||
                    field.getAnnotation(FindAll.class) != null) {
                
                return decorateWithStandardFindBy(loader, field);
            }
            
            // No annotations - use default processing
            return super.decorate(loader, field);
        }
        
        /**
         * Decorates a field with the CSFindBy annotation.
         * 
         * @param loader The class loader
         * @param field The field to decorate
         * @param csFindBy The CSFindBy annotation
         * @return The decorated field value
         */
        private Object decorateWithCSFindBy(ClassLoader loader, Field field, CSFindBy csFindBy) {
            ElementLocator locator = createCSLocator(field, csFindBy);
            if (locator == null) {
                return null;
            }
            
            return decorateWithLocator(loader, field, locator);
        }
        
        /**
         * Decorates a field with standard FindBy/FindBys/FindAll annotations.
         * 
         * @param loader The class loader
         * @param field The field to decorate
         * @return The decorated field value
         */
        private Object decorateWithStandardFindBy(ClassLoader loader, Field field) {
            ElementLocator locator = factory.createLocator(field);
            if (locator == null) {
                return null;
            }
            
            return decorateWithLocator(loader, field, locator);
        }
        
        /**
         * Decorates a field with the specified element locator.
         * 
         * @param loader The class loader
         * @param field The field to decorate
         * @param locator The element locator
         * @return The decorated field value
         */
        private Object decorateWithLocator(ClassLoader loader, Field field, ElementLocator locator) {
            Class<?> fieldType = field.getType();
            
            // Handle CSElement fields
            if (fieldType.equals(CSElement.class)) {
                return createCSElement(locator, field.getAnnotation(CacheLookup.class) != null);
            }
            
            // Handle CSElementList fields
            if (fieldType.equals(CSElementList.class) || 
                    (fieldType.equals(List.class) && isGenericCSElement(field))) {
                return createCSElementList(locator, field.getAnnotation(CacheLookup.class) != null);
            }
            
            // Handle CSSelect fields
            if (fieldType.equals(CSSelect.class)) {
                return createCSSelect(locator, field.getAnnotation(CacheLookup.class) != null);
            }
            
            // Handle CSTable fields
            if (fieldType.equals(CSTable.class)) {
                return createCSTable(locator, field.getAnnotation(CacheLookup.class) != null);
            }
            
            // Handle CSForm fields
            if (fieldType.equals(CSForm.class)) {
                return createCSForm(locator, field.getAnnotation(CacheLookup.class) != null);
            }
            
            // For standard WebElement fields, use our wrapper anyway
            if (WebElement.class.isAssignableFrom(fieldType)) {
                WebElement element = proxyForLocator(loader, locator);
                if (field.getAnnotation(CacheLookup.class) != null) {
                    element = wrapCacheLookupElement(element, locator);
                }
                return element;
            }
            
            // For standard List<WebElement> fields, use our wrapper anyway
            if (List.class.isAssignableFrom(fieldType) && isGenericWebElement(field)) {
                List<WebElement> elements = proxyForListLocator(loader, locator);
                if (field.getAnnotation(CacheLookup.class) != null) {
                    elements = wrapCacheLookupElements(elements, locator);
                }
                return elements;
            }
            
            // Not a supported type
            return null;
        }
        
        /**
         * Creates a CSElement for the specified locator.
         * 
         * @param locator The element locator
         * @param cacheLookup Whether to cache the element
         * @return A CSElement
         */
        private CSElement createCSElement(ElementLocator locator, boolean cacheLookup) {
            InvocationHandler handler = new CSElementHandler(locator, driver, cacheLookup);
            WebElement proxy = (WebElement) Proxy.newProxyInstance(
                    WebElement.class.getClassLoader(),
                    new Class[]{WebElement.class},
                    handler);
            
            return new CSElement(proxy, driver, toBy(locator));
        }
        
        /**
         * Creates a CSElementList for the specified locator.
         * 
         * @param locator The element locator
         * @param cacheLookup Whether to cache the elements
         * @return A CSElementList
         */
        private CSElementList createCSElementList(ElementLocator locator, boolean cacheLookup) {
            List<WebElement> elements = proxyForListLocator(WebElement.class.getClassLoader(), locator);
            if (cacheLookup) {
                elements = wrapCacheLookupElements(elements, locator);
            }
            
            return new CSElementList(elements, driver, toBy(locator));
        }
        
        /**
         * Creates a CSSelect for the specified locator.
         * 
         * @param locator The element locator
         * @param cacheLookup Whether to cache the element
         * @return A CSSelect
         */
        private CSSelect createCSSelect(ElementLocator locator, boolean cacheLookup) {
            InvocationHandler handler = new CSElementHandler(locator, driver, cacheLookup);
            WebElement proxy = (WebElement) Proxy.newProxyInstance(
                    WebElement.class.getClassLoader(),
                    new Class[]{WebElement.class},
                    handler);
            
            return new CSSelect(proxy, driver, toBy(locator));
        }
        
        /**
         * Creates a CSTable for the specified locator.
         * 
         * @param locator The element locator
         * @param cacheLookup Whether to cache the element
         * @return A CSTable
         */
        private CSTable createCSTable(ElementLocator locator, boolean cacheLookup) {
            InvocationHandler handler = new CSElementHandler(locator, driver, cacheLookup);
            WebElement proxy = (WebElement) Proxy.newProxyInstance(
                    WebElement.class.getClassLoader(),
                    new Class[]{WebElement.class},
                    handler);
            
            return new CSTable(proxy, driver, toBy(locator));
        }
        
        /**
         * Creates a CSForm for the specified locator.
         * 
         * @param locator The element locator
         * @param cacheLookup Whether to cache the element
         * @return A CSForm
         */
        private CSForm createCSForm(ElementLocator locator, boolean cacheLookup) {
            InvocationHandler handler = new CSElementHandler(locator, driver, cacheLookup);
            WebElement proxy = (WebElement) Proxy.newProxyInstance(
                    WebElement.class.getClassLoader(),
                    new Class[]{WebElement.class},
                    handler);
            
            return new CSForm(proxy, driver, toBy(locator));
        }
        
        /**
         * Creates a locator for a field with the CSFindBy annotation.
         * 
         * @param field The field
         * @param csFindBy The CSFindBy annotation
         * @return An ElementLocator
         */
        private ElementLocator createCSLocator(Field field, CSFindBy csFindBy) {
            By by = toBy(csFindBy);
            if (by == null) {
                return null;
            }
            
            return new CSAjaxElementLocator(driver, field, by, csFindBy.timeoutSeconds());
        }
        
        /**
         * Converts a CSFindBy annotation to a By locator.
         * 
         * @param annotation The CSFindBy annotation
         * @return A By locator
         */
        private By toBy(CSFindBy annotation) {
            if (annotation == null) {
                return null;
            }
            
            try {
                if (!annotation.id().isEmpty()) {
                    return By.id(annotation.id());
                }
                if (!annotation.name().isEmpty()) {
                    return By.name(annotation.name());
                }
                if (!annotation.className().isEmpty()) {
                    return By.className(annotation.className());
                }
                if (!annotation.css().isEmpty()) {
                    return By.cssSelector(annotation.css());
                }
                if (!annotation.tagName().isEmpty()) {
                    return By.tagName(annotation.tagName());
                }
                if (!annotation.linkText().isEmpty()) {
                    return By.linkText(annotation.linkText());
                }
                if (!annotation.partialLinkText().isEmpty()) {
                    return By.partialLinkText(annotation.partialLinkText());
                }
                if (!annotation.xpath().isEmpty()) {
                    return By.xpath(annotation.xpath());
                }
                if (!annotation.ai().isEmpty()) {
                    // Use AI-enhanced locator strategy
                    return createAILocator(annotation.ai());
                }
            } catch (Exception e) {
                logger.error("Error creating locator from CSFindBy annotation: " + e.getMessage(), e);
            }
            
            return null;
        }
        
        /**
         * Converts an ElementLocator to a By locator.
         * 
         * @param locator The ElementLocator
         * @return A By locator
         */
        private By toBy(ElementLocator locator) {
            if (locator instanceof CSAjaxElementLocator) {
                return ((CSAjaxElementLocator) locator).getBy();
            }
            
            // For standard locators, we can't get the By directly,
            // but we can use reflection to try to extract it
            try {
                Field byField = locator.getClass().getDeclaredField("by");
                byField.setAccessible(true);
                return (By) byField.get(locator);
            } catch (Exception e) {
                logger.warn("Could not extract By from ElementLocator: " + e.getMessage());
                return null;
            }
        }
        
        /**
         * Creates an AI-enhanced locator.
         * 
         * @param description The element description for AI locator
         * @return A By locator
         */
        private By createAILocator(String description) {
            // In a real implementation, this would use the AI service to generate a robust locator
            // For now, we'll return a basic locator based on the description
            logger.debug("Creating AI locator for description: " + description);
            
            // This is a placeholder - in production this would call the SmartLocatorService
            return By.xpath("//*[contains(text(), '" + description + "') or @title='" + description + 
                    "' or @alt='" + description + "' or @placeholder='" + description + "']");
        }
        
        /**
         * Checks if a field is a List of CSElement.
         * 
         * @param field The field to check
         * @return true if the field is a List of CSElement, false otherwise
         */
        private boolean isGenericCSElement(Field field) {
            try {
                java.lang.reflect.ParameterizedType genericType = (java.lang.reflect.ParameterizedType) field.getGenericType();
                Class<?> genericClass = (Class<?>) genericType.getActualTypeArguments()[0];
                return genericClass.equals(CSElement.class);
            } catch (Exception e) {
                return false;
            }
        }
        
        /**
         * Checks if a field is a List of WebElement.
         * 
         * @param field The field to check
         * @return true if the field is a List of WebElement, false otherwise
         */
        private boolean isGenericWebElement(Field field) {
            try {
                java.lang.reflect.ParameterizedType genericType = (java.lang.reflect.ParameterizedType) field.getGenericType();
                Class<?> genericClass = (Class<?>) genericType.getActualTypeArguments()[0];
                return WebElement.class.isAssignableFrom(genericClass);
            } catch (Exception e) {
                return false;
            }
        }
        
        /**
         * Wraps a WebElement with cache lookup.
         * 
         * @param element The WebElement to wrap
         * @param locator The element locator
         * @return The wrapped WebElement
         */
        private WebElement wrapCacheLookupElement(WebElement element, ElementLocator locator) {
            try {
                // Find the element immediately
                WebElement realElement = locator.findElement();
                
                // Create a proxy that always returns the cached element
                InvocationHandler handler = new CacheLookupElementHandler(realElement);
                return (WebElement) Proxy.newProxyInstance(
                        WebElement.class.getClassLoader(),
                        new Class[]{WebElement.class},
                        handler);
            } catch (Exception e) {
                logger.error("Error wrapping cache lookup element: " + e.getMessage(), e);
                return element;
            }
        }
        
        /**
         * Wraps a list of WebElements with cache lookup.
         * 
         * @param elements The list of WebElements to wrap
         * @param locator The element locator
         * @return The wrapped list of WebElements
         */
        private List<WebElement> wrapCacheLookupElements(List<WebElement> elements, ElementLocator locator) {
            try {
                // Find the elements immediately
                final List<WebElement> realElements = locator.findElements();
                
                // Create a proxy that always returns the cached elements
                InvocationHandler handler = new CacheLookupListHandler(realElements);
                return (List<WebElement>) Proxy.newProxyInstance(
                        List.class.getClassLoader(),
                        new Class[]{List.class},
                        handler);
            } catch (Exception e) {
                logger.error("Error wrapping cache lookup elements: " + e.getMessage(), e);
                return elements;
            }
        }
    }
    
    /**
     * Custom element locator that supports By locator and timeout.
     */
    private class CSAjaxElementLocator extends AjaxElementLocator {
        private final By by;
        
        /**
         * Constructor for CSAjaxElementLocator.
         * 
         * @param searchContext The search context
         * @param field The field to locate
         * @param by The By locator
         * @param timeOutInSeconds The timeout in seconds
         */
        public CSAjaxElementLocator(SearchContext searchContext, Field field, By by, int timeOutInSeconds) {
            super(searchContext, field, timeOutInSeconds > 0 ? timeOutInSeconds : 
                    ConfigurationManager.getInstance().getFrameworkConfig().getElementLocatorTimeoutSeconds());
            this.by = by;
        }
        
        /**
         * Gets the By locator.
         * 
         * @return The By locator
         */
        public By getBy() {
            return by;
        }
        
        @Override
        protected WebElement findElement() {
            return getSearchContext().findElement(by);
        }
        
        @Override
        protected List<WebElement> findElements() {
            return getSearchContext().findElements(by);
        }
    }
    
    /**
     * Invocation handler for CSElement proxies.
     */
    private class CSElementHandler implements InvocationHandler {
        private final ElementLocator locator;
        private final WebDriver driver;
        private final boolean cacheLookup;
        private WebElement cachedElement;
        
        /**
         * Constructor for CSElementHandler.
         * 
         * @param locator The element locator
         * @param driver The WebDriver instance
         * @param cacheLookup Whether to cache the element
         */
        public CSElementHandler(ElementLocator locator, WebDriver driver, boolean cacheLookup) {
            this.locator = locator;
            this.driver = driver;
            this.cacheLookup = cacheLookup;
        }
        
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            if ("getWrappedElement".equals(method.getName())) {
                return findElement();
            }
            
            if ("getWrappedDriver".equals(method.getName())) {
                return driver;
            }
            
            WebElement element = findElement();
            
            try {
                return method.invoke(element, args);
            } catch (InvocationTargetException e) {
                throw e.getCause();
            }
        }
        
        /**
         * Finds the element, using cache if enabled.
         * 
         * @return The WebElement
         */
        private WebElement findElement() {
            if (cacheLookup && cachedElement != null) {
                return cachedElement;
            }
            
            WebElement element = locator.findElement();
            
            if (cacheLookup) {
                cachedElement = element;
            }
            
            return element;
        }
    }
    
    /**
     * Invocation handler for cache lookup elements.
     */
    private class CacheLookupElementHandler implements InvocationHandler {
        private final WebElement element;
        
        /**
         * Constructor for CacheLookupElementHandler.
         * 
         * @param element The WebElement to cache
         */
        public CacheLookupElementHandler(WebElement element) {
            this.element = element;
        }
        
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            try {
                return method.invoke(element, args);
            } catch (InvocationTargetException e) {
                throw e.getCause();
            }
        }
    }
    
    /**
     * Invocation handler for cache lookup lists.
     */
    private class CacheLookupListHandler implements InvocationHandler {
        private final List<WebElement> elements;
        
        /**
         * Constructor for CacheLookupListHandler.
         * 
         * @param elements The list of WebElements to cache
         */
        public CacheLookupListHandler(List<WebElement> elements) {
            this.elements = elements;
        }
        
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            try {
                return method.invoke(elements, args);
            } catch (InvocationTargetException e) {
                throw e.getCause();
            }
        }
    }
}


// com/cstestforge/framework/selenium/java/base/CSBaseStepDef.java
package com.cstestforge.framework.selenium.java.base;

import io.cucumber.java.After;
import io.cucumber.java.AfterStep;
import io.cucumber.java.Before;
import io.cucumber.java.Scenario;
import io.cucumber.java.en.And;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;

import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebDriverException;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.selenium.java.browser.CSBrowserManager;
import com.cstestforge.framework.selenium.java.browser.CSWebDriverManager;

import java.util.HashMap;
import java.util.Map;

/**
 * Base step definition class for Cucumber BDD tests.
 * This class provides common functionality for all step definition classes.
 */
public class CSBaseStepDef {
    private static final CSLogger logger = new CSLogger(CSBaseStepDef.class);
    private static final CSReporter reporter = CSReporter.getInstance();
    private static final ConfigurationManager configManager = ConfigurationManager.getInstance();
    
    protected static Map<String, Object> scenarioContext = new HashMap<>();
    private static final ThreadLocal<Scenario> currentScenario = new ThreadLocal<>();
    
    /**
     * Setup method that runs before each scenario.
     * 
     * @param scenario The Cucumber scenario
     */
    @Before
    public void setUp(Scenario scenario) {
        logger.info("Setting up scenario: " + scenario.getName());
        reporter.startTest(scenario.getName());
        
        // Store the scenario for later use
        currentScenario.set(scenario);
        
        // Clear scenario context
        scenarioContext.clear();
        
        // Initialize WebDriver if configured to do so
        if (configManager.getFrameworkConfig().isInitializeDriverBeforeTest()) {
            getDriver();
            logger.info("WebDriver initialized");
        }
    }
    
    /**
     * Cleanup method that runs after each scenario.
     * 
     * @param scenario The Cucumber scenario
     */
    @After
    public void tearDown(Scenario scenario) {
        logger.info("Tearing down scenario: " + scenario.getName());
        
        try {
            // Take screenshot on failure if configured
            if (scenario.isFailed() && CSWebDriverManager.getInstance().hasDriver()) {
                takeScreenshot("failure");
                logger.error("Scenario failed: " + scenario.getName());
            }
        } catch (Exception e) {
            logger.error("Error in tearDown: " + e.getMessage(), e);
        } finally {
            // Quit the driver if configured to do so
            if (configManager.getFrameworkConfig().isQuitDriverAfterTest()) {
                quitDriver();
                logger.info("WebDriver quit after scenario");
            }
            
            // Remove the scenario from the thread local
            currentScenario.remove();
            
            reporter.endTest();
        }
    }
    
    /**
     * Method that runs after each step.
     * 
     * @param scenario The Cucumber scenario
     */
    @AfterStep
    public void afterStep(Scenario scenario) {
        if (configManager.getFrameworkConfig().isTakeScreenshotAfterEachStep() && 
                CSWebDriverManager.getInstance().hasDriver()) {
            takeScreenshot("step");
        }
        
        // Log any errors in the step
        if (scenario.isFailed()) {
            logger.error("Step failed in scenario: " + scenario.getName());
            reporter.logError("Step failed");
        }
    }
    
    /**
     * Gets the WebDriver instance for the current thread.
     * 
     * @return The WebDriver instance
     */
    protected WebDriver getDriver() {
        return CSWebDriverManager.getInstance().getDriver();
    }
    
    /**
     * Gets the browser manager for the current thread.
     * 
     * @return The browser manager
     */
    // Continuation of com/cstestforge/framework/selenium/java/base/CSBaseStepDef.java
    protected CSBrowserManager getBrowser() {
        return CSBrowserManager.getInstance();
    }
    
    /**
     * Navigates to the specified URL.
     * 
     * @param url The URL to navigate to
     */
    protected void navigateTo(String url) {
        logger.info("Navigating to URL: " + url);
        reporter.logInfo("Navigating to: " + url);
        getBrowser().navigateTo(url);
    }
    
    /**
     * Takes a screenshot and attaches it to the current scenario.
     * 
     * @param name The name for the screenshot
     */
    protected void takeScreenshot(String name) {
        if (!CSWebDriverManager.getInstance().hasDriver()) {
            logger.warn("Cannot take screenshot: WebDriver not initialized");
            return;
        }
        
        try {
            WebDriver driver = getDriver();
            if (driver instanceof TakesScreenshot) {
                Scenario scenario = currentScenario.get();
                if (scenario != null) {
                    byte[] screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
                    scenario.attach(screenshot, "image/png", name);
                    logger.info("Screenshot taken and attached to scenario: " + name);
                    reporter.logInfo("Screenshot taken: " + name);
                }
            } else {
                logger.warn("WebDriver does not support taking screenshots");
            }
        } catch (WebDriverException e) {
            logger.error("Error taking screenshot: " + e.getMessage(), e);
        }
    }
    
    /**
     * Executes JavaScript in the browser.
     * 
     * @param script The JavaScript to execute
     * @param args The arguments to pass to the script
     * @return The result of the script execution
     */
    protected Object executeJavaScript(String script, Object... args) {
        if (!CSWebDriverManager.getInstance().hasDriver()) {
            logger.warn("Cannot execute JavaScript: WebDriver not initialized");
            return null;
        }
        
        WebDriver driver = getDriver();
        if (driver instanceof JavascriptExecutor) {
            try {
                logger.debug("Executing JavaScript: " + script);
                return ((JavascriptExecutor) driver).executeScript(script, args);
            } catch (Exception e) {
                logger.error("Error executing JavaScript: " + e.getMessage(), e);
                reporter.logError("JavaScript execution failed: " + e.getMessage());
                return null;
            }
        } else {
            logger.warn("WebDriver does not support JavaScript execution");
            return null;
        }
    }
    
    /**
     * Quits the WebDriver for the current thread.
     */
    protected void quitDriver() {
        logger.info("Quitting WebDriver");
        CSWebDriverManager.getInstance().quitDriver();
    }
    
    /**
     * Sets a value in the scenario context.
     * 
     * @param key The key for the data
     * @param value The value to store
     */
    protected void setContext(String key, Object value) {
        scenarioContext.put(key, value);
    }
    
    /**
     * Gets a value from the scenario context.
     * 
     * @param key The key for the data
     * @param <T> The type of the data
     * @return The stored value, or null if not found
     */
    @SuppressWarnings("unchecked")
    protected <T> T getContext(String key) {
        return (T) scenarioContext.get(key);
    }
    
    /**
     * Clears the scenario context.
     */
    protected void clearContext() {
        scenarioContext.clear();
    }
    
    /**
     * Waits for the specified number of milliseconds.
     * <p>
     * Note: This method should be used sparingly and only when necessary.
     * Prefer using explicit waits instead.
     * 
     * @param millis The number of milliseconds to wait
     */
    protected void waitFor(long millis) {
        logger.debug("Waiting for " + millis + " ms");
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.warn("Wait interrupted", e);
        }
    }
    
    /**
     * Gets a page object of the specified type.
     * 
     * @param pageClass The class of the page object
     * @param <T> The type of the page object
     * @return A new instance of the page object
     */
    protected <T extends CSBasePage> T getPage(Class<T> pageClass) {
        logger.debug("Creating page object: " + pageClass.getSimpleName());
        
        try {
            T page = pageClass.getDeclaredConstructor(WebDriver.class).newInstance(getDriver());
            logger.debug("Page object created: " + pageClass.getSimpleName());
            return page;
        } catch (Exception e) {
            logger.error("Error creating page object: " + e.getMessage(), e);
            reporter.logError("Failed to create page object: " + e.getMessage());
            throw new RuntimeException("Failed to create page object: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a new CSPageFactory for creating page objects with enhanced elements.
     * 
     * @return A new CSPageFactory instance
     */
    protected CSPageFactory createPageFactory() {
        return new CSPageFactory(getDriver());
    }
    
    /**
     * Initializes a page object using the CSPageFactory.
     * 
     * @param page The page object to initialize
     * @param <T> The type of the page object
     * @return The initialized page object
     */
    protected <T> T initPage(T page) {
        logger.debug("Initializing page object: " + page.getClass().getSimpleName());
        return createPageFactory().initElements(page);
    }
    
    // Common step definitions that can be used across all step definition classes
    
    /**
     * Step definition for navigating to a URL.
     * 
     * @param url The URL to navigate to
     */
    @Given("I navigate to {string}")
    public void iNavigateTo(String url) {
        navigateTo(url);
    }
    
    /**
     * Step definition for waiting for a number of seconds.
     * 
     * @param seconds The number of seconds to wait
     */
    @When("I wait for {int} seconds")
    public void iWaitForSeconds(int seconds) {
        waitFor(seconds * 1000L);
    }
    
    /**
     * Step definition for checking if a specific page is loaded.
     * 
     * @param pageClassName The name of the page class
     */
    @Then("the {string} page should be loaded")
    public void thePageShouldBeLoaded(String pageClassName) {
        try {
            // Find the page class by name
            @SuppressWarnings("unchecked")
            Class<? extends CSBasePage> pageClass = (Class<? extends CSBasePage>) 
                    Class.forName(pageClassName);
            
            // Create the page object
            CSBasePage page = getPage(pageClass);
            
            // Verify that the page is loaded correctly
            boolean isLoaded = page.verifyPage();
            
            // Assert that the page is loaded
            if (!isLoaded) {
                reporter.logError("Page is not loaded correctly: " + pageClassName);
                throw new AssertionError("Page is not loaded correctly: " + pageClassName);
            }
            
            reporter.logInfo("Page is loaded correctly: " + pageClassName);
        } catch (ClassNotFoundException e) {
            logger.error("Page class not found: " + pageClassName, e);
            reporter.logError("Page class not found: " + pageClassName);
            throw new AssertionError("Page class not found: " + pageClassName);
        }
    }
    
    /**
     * Step definition for checking if the page title matches a specific value.
     * 
     * @param title The expected page title
     */
    @Then("the page title should be {string}")
    public void thePageTitleShouldBe(String title) {
        String actualTitle = getDriver().getTitle();
        
        if (!actualTitle.equals(title)) {
            reporter.logError("Page title mismatch. Expected: " + title + ", Actual: " + actualTitle);
            throw new AssertionError("Page title mismatch. Expected: " + title + ", Actual: " + actualTitle);
        }
        
        reporter.logInfo("Page title matches: " + title);
    }
    
    /**
     * Step definition for checking if the page URL contains a specific value.
     * 
     * @param urlPart The expected part of the URL
     */
    @Then("the page URL should contain {string}")
    public void thePageUrlShouldContain(String urlPart) {
        String actualUrl = getDriver().getCurrentUrl();
        
        if (!actualUrl.contains(urlPart)) {
            reporter.logError("Page URL does not contain: " + urlPart + ", Actual: " + actualUrl);
            throw new AssertionError("Page URL does not contain: " + urlPart + ", Actual: " + actualUrl);
        }
        
        reporter.logInfo("Page URL contains: " + urlPart);
    }
    
    /**
     * Step definition for taking a screenshot.
     * 
     * @param name The name for the screenshot
     */
    @And("I take a screenshot named {string}")
    public void iTakeAScreenshot(String name) {
        takeScreenshot(name);
    }
    
    /**
     * Step definition for executing JavaScript.
     * 
     * @param script The JavaScript to execute
     */
    @When("I execute JavaScript {string}")
    public void iExecuteJavaScript(String script) {
        executeJavaScript(script);
    }
    
    /**
     * Step definition for refreshing the page.
     */
    @When("I refresh the page")
    public void iRefreshThePage() {
        getDriver().navigate().refresh();
        reporter.logInfo("Page refreshed");
    }
    
    /**
     * Step definition for navigating back in the browser history.
     */
    @When("I navigate back")
    public void iNavigateBack() {
        getDriver().navigate().back();
        reporter.logInfo("Navigated back");
    }
    
    /**
     * Step definition for navigating forward in the browser history.
     */
    @When("I navigate forward")
    public void iNavigateForward() {
        getDriver().navigate().forward();
        reporter.logInfo("Navigated forward");
    }
    
    /**
     * Step definition for storing a value in the scenario context.
     * 
     * @param value The value to store
     * @param key The key for the data
     */
    @When("I store {string} as {string} in the context")
    public void iStoreValueInContext(String value, String key) {
        setContext(key, value);
        reporter.logInfo("Stored value '" + value + "' as '" + key + "' in context");
    }
    
    /**
     * Step definition for checking a value in the scenario context.
     * 
     * @param key The key for the data
     * @param value The expected value
     */
    @Then("the context value {string} should be {string}")
    public void theContextValueShouldBe(String key, String value) {
        String contextValue = getContext(key);
        
        if (!value.equals(contextValue)) {
            reporter.logError("Context value mismatch. Key: " + key + 
                    ", Expected: " + value + ", Actual: " + contextValue);
            throw new AssertionError("Context value mismatch. Key: " + key + 
                    ", Expected: " + value + ", Actual: " + contextValue);
        }
        
        reporter.logInfo("Context value matches: " + key + " = " + value);
    }
}



// com/cstestforge/framework/selenium/java/annotations/CSFindBy.java
package com.cstestforge.framework.selenium.java.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Enhanced version of the standard FindBy annotation.
 * This annotation adds additional capabilities for element location, including AI-based locators.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.TYPE})
public @interface CSFindBy {

    /**
     * Locates the element using the id attribute.
     * 
     * @return The id to search for
     */
    String id() default "";
    
    /**
     * Locates the element using the name attribute.
     * 
     * @return The name to search for
     */
    String name() default "";
    
    /**
     * Locates the element using the class name.
     * 
     * @return The class name to search for
     */
    String className() default "";
    
    /**
     * Locates the element using a CSS selector.
     * 
     * @return The CSS selector to search for
     */
    String css() default "";
    
    /**
     * Locates the element using the tag name.
     * 
     * @return The tag name to search for
     */
    String tagName() default "";
    
    /**
     * Locates the element using the link text.
     * 
     * @return The link text to search for
     */
    String linkText() default "";
    
    /**
     * Locates the element using the partial link text.
     * 
     * @return The partial link text to search for
     */
    String partialLinkText() default "";
    
    /**
     * Locates the element using an XPath expression.
     * 
     * @return The XPath expression to use
     */
    String xpath() default "";
    
    /**
     * Locates the element using a natural language description for AI-based location.
     * 
     * @return The natural language description of the element
     */
    String ai() default "";
    
    /**
     * Locates the element using a label text association.
     * This will find elements that are associated with a label containing the given text.
     * 
     * @return The label text to search for
     */
    String label() default "";
    
    /**
     * Locates the element using a data-testid attribute.
     * 
     * @return The data-testid to search for
     */
    String testId() default "";
    
    /**
     * Locates the element using text content.
     * This will find elements that contain the specified text.
     * 
     * @return The text content to search for
     */
    String text() default "";
    
    /**
     * Locates the element using the placeholder attribute.
     * 
     * @return The placeholder text to search for
     */
    String placeholder() default "";
    
    /**
     * Locates the element using the title attribute.
     * 
     * @return The title text to search for
     */
    String title() default "";
    
    /**
     * Provides a fallback list of locators to try in order.
     * If the primary locator fails, the system will try these in sequence.
     * 
     * @return An array of locator strings in the format "type:value" (e.g. "id:myId", "css:.myClass")
     */
    String[] fallback() default {};
    
    /**
     * Specifies the timeout for finding this element in seconds.
     * If not specified, the framework's default timeout will be used.
     * 
     * @return The timeout in seconds
     */
    int timeoutSeconds() default 0;
    
    /**
     * Indicates if a screenshot should be taken when this element is not found.
     * 
     * @return true to take a screenshot on element not found, false otherwise
     */
    boolean screenshotOnNotFound() default false;
    
    /**
     * Indicates if the element's state should be verified after location.
     * If true, additional checks will be performed to ensure the element is in a usable state.
     * 
     * @return true to verify the element's state, false otherwise
     */
    boolean verifyState() default false;
    
    /**
     * Provides a human-readable description of the element.
     * This is used for logging and reporting purposes.
     * 
     * @return The element description
     */
    String description() default "";
    
    /**
     * Indicates if the element location should use self-healing capabilities.
     * If true, the framework will attempt to find alternative locators if the primary one fails.
     * 
     * @return true to enable self-healing, false otherwise
     */
    boolean selfHealing() default true;
    
    /**
     * Specifies the priority of this element for performance optimization.
     * Higher priority elements will be located first during page initialization.
     * 
     * @return The element priority (higher values = higher priority)
     */
    int priority() default 0;
    
    /**
     * Indicates if the element should be highlighted when located.
     * Useful for debugging and visual validation.
     * 
     * @return true to highlight the element, false otherwise
     */
    boolean highlight() default false;
    
    /**
     * Indicates if the element's location should be logged.
     * 
     * @return true to log the element's location, false otherwise
     */
    boolean log() default true;
    
    /**
     * Specifies a custom JavaScript expression to find the element.
     * This will be executed in the browser context.
     * 
     * @return The JavaScript expression to use
     */
    String javascript() default "";
    
    /**
     * Specifies a regular expression to match against the element's text content.
     * 
     * @return The regular expression to use
     */
    String textPattern() default "";
    
    /**
     * Specifies a relative positioning to another element.
     * Format is "locator:relation" where relation is one of: above, below, leftOf, rightOf, near
     * 
     * @return The relative positioning specification
     */
    String relative() default "";
    
    /**
     * Specifies the position of the element in a group of matching elements (0-based).
     * 
     * @return The index of the element
     */
    int index() default 0;
    
    /**
     * Specifies if the element is considered a required part of the page.
     * If true, failure to find this element will result in a page verification failure.
     * 
     * @return true if the element is required, false otherwise
     */
    boolean required() default false;
}


// com/cstestforge/framework/selenium/java/annotations/CSPage.java
package com.cstestforge.framework.selenium.java.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for page objects to provide metadata about the page.
 * This annotation can be used to define page URLs, titles, and verification elements.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CSPage {

    /**
     * The URL of the page.
     * If specified and autoLoad is true, the page will be automatically navigated to.
     * 
     * @return The page URL
     */
    String url() default "";
    
    /**
     * A regular expression pattern that the page URL should match.
     * Used for page verification.
     * 
     * @return The URL pattern
     */
    String urlPattern() default "";
    
    /**
     * The expected title of the page.
     * Used for page verification.
     * 
     * @return The page title
     */
    String title() default "";
    
    /**
     * A regular expression pattern that the page title should match.
     * Used for page verification.
     * 
     * @return The title pattern
     */
    String titlePattern() default "";
    
    /**
     * CSS selectors for elements that should be present when the page is fully loaded.
     * Used for page verification.
     * 
     * @return Array of CSS selectors
     */
    String[] readyIndicators() default {};
    
    /**
     * Timeout in seconds for verifying page load.
     * 
     * @return The timeout in seconds
     */
    int timeoutSeconds() default 30;
    
    /**
     * Whether to automatically load the page using the URL when the page object is instantiated.
     * 
     * @return true to automatically load the page, false otherwise
     */
    boolean autoLoad() default false;
    
    /**
     * Whether to automatically verify the page when the page object is instantiated.
     * 
     * @return true to automatically verify the page, false otherwise
     */
    boolean autoVerify() default true;
    
    /**
     * A human-readable name for the page.
     * 
     * @return The page name
     */
    String name() default "";
    
    /**
     * A description of the page.
     * 
     * @return The page description
     */
    String description() default "";
    
    /**
     * JavaScript expression that should evaluate to true when the page is fully loaded.
     * 
     * @return The JavaScript expression
     */
    String readyScript() default "";
    
    /**
     * CSS selectors for elements that should NOT be present when the page is fully loaded.
     * Used for page verification (e.g., loading indicators that should disappear).
     * 
     * @return Array of CSS selectors
     */
    String[] loadingIndicators() default {};
    
    /**
     * CSS selectors for elements that indicate an error state of the page.
     * Used for page verification.
     * 
     * @return Array of CSS selectors
     */
    String[] errorIndicators() default {};
    
    /**
     * The HTTP status code that the page should return (for REST API testing).
     * 
     * @return The expected HTTP status code
     */
    int expectedStatusCode() default 200;
    
    /**
     * Indicates whether to take a screenshot when the page is loaded.
     * 
     * @return true to take a screenshot, false otherwise
     */
    boolean screenshotOnLoad() default false;
    
    /**
     * Path of the page within the application context.
     * 
     * @return The page path
     */
    String path() default "";
    
    /**
     * Base URL of the application, which will be combined with the path.
     * If empty, the framework's configured base URL will be used.
     * 
     * @return The base URL
     */
    String baseUrl() default "";
    
    /**
     * Query parameters for the URL.
     * Format: "param1=value1&param2=value2"
     * 
     * @return The query parameters
     */
    String queryParams() default "";
    
    /**
     * Path parameters for the URL.
     * Format: "param1:value1,param2:value2"
     * 
     * @return The path parameters
     */
    String pathParams() default "";
    
    /**
     * Indicates whether to clear cookies when navigating to this page.
     * 
     * @return true to clear cookies, false otherwise
     */
    boolean clearCookies() default false;
    
    /**
     * Indicates whether to clear local storage when navigating to this page.
     * 
     * @return true to clear local storage, false otherwise
     */
    boolean clearLocalStorage() default false;
    
    /**
     * Indicates whether to clear session storage when navigating to this page.
     * 
     * @return true to clear session storage, false otherwise
     */
    boolean clearSessionStorage() default false;
    
    /**
     * Indicates whether to maximize the browser window when navigating to this page.
     * 
     * @return true to maximize the window, false otherwise
     */
    boolean maximizeWindow() default false;
    
    /**
     * Specifies the browser window size when navigating to this page.
     * Format: "width,height" (e.g., "1024,768")
     * 
     * @return The window size specification
     */
    String windowSize() default "";
    
    /**
     * Specifies the user agent to use when navigating to this page.
     * 
     * @return The user agent string
     */
    String userAgent() default "";
    
    /**
     * Specifies whether the page has an iframe as the main content.
     * If true, the framework will switch to the iframe automatically.
     * 
     * @return true if the page has an iframe, false otherwise
     */
    boolean hasIframe() default false;
    
    /**
     * CSS selector for the main iframe in the page.
     * Used if hasIframe is true.
     * 
     * @return The iframe selector
     */
    String iframeSelector() default "";
}



// com/cstestforge/framework/selenium/java/annotations/CSLocatorProcessor.java
package com.cstestforge.framework.selenium.java.annotations;

import org.openqa.selenium.By;
import org.openqa.selenium.SearchContext;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.PageFactory;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.selenium.java.browser.CSWebDriverManager;
import com.cstestforge.framework.core.ai.SmartLocatorService;
import com.cstestforge.framework.core.ai.SelfHealingLocatorService;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Processor for CSFindBy annotations to convert them to By locators.
 * This class handles the conversion of CSFindBy annotations to Selenium By locators,
 * including advanced features like AI-based locators and self-healing.
 */
public class CSLocatorProcessor {
    private static final CSLogger logger = new CSLogger(CSLocatorProcessor.class);
    private static final SmartLocatorService smartLocatorService = new SmartLocatorService();
    private static final SelfHealingLocatorService selfHealingService = new SelfHealingLocatorService();
    
    /**
     * Converts a CSFindBy annotation to a By locator.
     * 
     * @param annotation The CSFindBy annotation
     * @return A By locator
     */
    public static By toBy(CSFindBy annotation) {
        if (annotation == null) {
            return null;
        }
        
        try {
            // Process standard locators
            if (!annotation.id().isEmpty()) {
                return By.id(annotation.id());
            }
            if (!annotation.name().isEmpty()) {
                return By.name(annotation.name());
            }
            if (!annotation.className().isEmpty()) {
                return By.className(annotation.className());
            }
            if (!annotation.css().isEmpty()) {
                return By.cssSelector(annotation.css());
            }
            if (!annotation.tagName().isEmpty()) {
                return By.tagName(annotation.tagName());
            }
            if (!annotation.linkText().isEmpty()) {
                return By.linkText(annotation.linkText());
            }
            if (!annotation.partialLinkText().isEmpty()) {
                return By.partialLinkText(annotation.partialLinkText());
            }
            if (!annotation.xpath().isEmpty()) {
                return By.xpath(annotation.xpath());
            }
            
            // Process advanced locators
            if (!annotation.ai().isEmpty()) {
                return processAILocator(annotation.ai());
            }
            if (!annotation.label().isEmpty()) {
                return processLabelLocator(annotation.label());
            }
            if (!annotation.testId().isEmpty()) {
                return By.cssSelector("[data-testid='" + annotation.testId() + "']");
            }
            if (!annotation.text().isEmpty()) {
                return processTextLocator(annotation.text());
            }
            if (!annotation.placeholder().isEmpty()) {
                return By.cssSelector("[placeholder='" + annotation.placeholder() + "']");
            }
            if (!annotation.title().isEmpty()) {
                return By.cssSelector("[title='" + annotation.title() + "']");
            }
            if (!annotation.textPattern().isEmpty()) {
                return processTextPatternLocator(annotation.textPattern());
            }
            if (!annotation.javascript().isEmpty()) {
                return new ByJavaScript(annotation.javascript());
            }
            if (!annotation.relative().isEmpty()) {
                return processRelativeLocator(annotation.relative());
            }
            
            // Check fallbacks if available
            if (annotation.fallback().length > 0) {
                return new ByFallback(annotation.fallback());
            }
        } catch (Exception e) {
            logger.error("Error creating locator from CSFindBy annotation: " + e.getMessage(), e);
        }
        
        logger.error("Invalid CSFindBy annotation: no valid locator specified");
        return null;
    }
    
    /**
     * Processes an AI-based locator.
     * 
     * @param description The element description for AI locator
     * @return A By locator
     */
    private static By processAILocator(String description) {
        logger.debug("Creating AI locator for description: " + description);
        return smartLocatorService.generateLocator(description);
    }
    
    /**
     * Processes a label-based locator.
     * 
     * @param labelText The label text
     * @return A By locator
     */
    private static By processLabelLocator(String labelText) {
        logger.debug("Creating label-based locator for: " + labelText);
        
        // First, try to find by label + for attribute
        String xpathForLabel = "//label[normalize-space(text())='" + labelText + "']/@for";
        
        return new ByChain(Arrays.asList(
            // Try label with 'for' attribute
            new ByFunction(driver -> {
                try {
                    WebElement labelElement = driver.findElement(By.xpath("//label[normalize-space(text())='" + labelText + "']"));
                    String forId = labelElement.getAttribute("for");
                    if (forId != null && !forId.isEmpty()) {
                        return driver.findElement(By.id(forId));
                    }
                } catch (Exception e) {
                    // Ignore, we'll try other methods
                }
                return null;
            }),
            // Try input after label without 'for'
            By.xpath("//label[normalize-space(text())='" + labelText + "']/following-sibling::input"),
            // Try input inside label
            By.xpath("//label[normalize-space(text())='" + labelText + "']//input"),
            // Try placeholder with same text
            By.cssSelector("input[placeholder='" + labelText + "']"),
            // Try aria-label with same text
            By.cssSelector("[aria-label='" + labelText + "']")
        ));
    }
    
    /**
     * Processes a text-based locator.
     * 
     * @param text The element text
     * @return A By locator
     */
    private static By processTextLocator(String text) {
        logger.debug("Creating text-based locator for: " + text);
        
        return new ByChain(Arrays.asList(
            // Try exact text match
            By.xpath("//*[normalize-space(text())='" + text + "']"),
            // Try partial text match
            By.xpath("//*[contains(normalize-space(text()),'" + text + "')]"),
            // Try button with text
            By.xpath("//button[normalize-space(text())='" + text + "']"),
            // Try link with text
            By.linkText(text)
        ));
    }
    
    /**
     * Processes a text pattern locator.
     * 
     * @param pattern The regex pattern for text matching
     * @return A By locator
     */
    private static By processTextPatternLocator(String pattern) {
        logger.debug("Creating text pattern locator for: " + pattern);
        
        // Compile the pattern
        final Pattern regexPattern = Pattern.compile(pattern);
        
        return new ByFunction(driver -> {
            // Find all elements with text
            List<WebElement> allElements = driver.findElements(By.xpath("//*[text()]"));
            
            // Find the first element that matches the pattern
            for (WebElement element : allElements) {
                String text = element.getText();
                if (text != null && regexPattern.matcher(text).matches()) {
                    return element;
                }
            }
            
            return null;
        });
    }
    
    /**
     * Processes a relative locator.
     * 
     * @param relativeSpec The relative positioning specification
     * @return A By locator
     */
    private static By processRelativeLocator(String relativeSpec) {
        logger.debug("Creating relative locator for: " + relativeSpec);
        
        String[] parts = relativeSpec.split(":");
        if (parts.length != 2) {
            logger.error("Invalid relative locator specification: " + relativeSpec);
            return null;
        }
        
        final String locatorString = parts[0];
        final String relation = parts[1];
        
        return new ByFunction(driver -> {
            // Find the reference element
            WebElement referenceElement;
            try {
                By referenceLocator = parseLocatorString(locatorString);
                referenceElement = driver.findElement(referenceLocator);
            } catch (Exception e) {
                logger.error("Error finding reference element: " + e.getMessage(), e);
                return null;
            }
            
            // Get the relative element
            switch (relation.toLowerCase()) {
                case "above":
                    return findElementAbove(driver, referenceElement);
                case "below":
                    return findElementBelow(driver, referenceElement);
                case "leftof":
                    return findElementLeftOf(driver, referenceElement);
                case "rightof":
                    return findElementRightOf(driver, referenceElement);
                case "near":
                    return findElementNear(driver, referenceElement);
                default:
                    logger.error("Unsupported relation: " + relation);
                    return null;
            }
        });
    }
    
    /**
     * Parses a locator string in the format "type:value".
     * 
     * @param locatorString The locator string
     * @return A By locator
     */
    private static By parseLocatorString(String locatorString) {
        String[] parts = locatorString.split(":", 2);
        if (parts.length != 2) {
            throw new IllegalArgumentException("Invalid locator string: " + locatorString);
        }
        
        String type = parts[0].toLowerCase();
        String value = parts[1];
        
        switch (type) {
            case "id":
                return By.id(value);
            case "name":
                return By.name(value);
            case "class":
            case "classname":
                return By.className(value);
            case "css":
                return By.cssSelector(value);
            case "tag":
            case "tagname":
                return By.tagName(value);
            case "link":
            case "linktext":
                return By.linkText(value);
            case "partiallink":
            case "partiallinktext":
                return By.partialLinkText(value);
            case "xpath":
                return By.xpath(value);
            default:
                throw new IllegalArgumentException("Unsupported locator type: " + type);
        }
    }
    
    /**
     * Finds an element above the reference element.
     * 
     * @param driver The WebDriver
     * @param referenceElement The reference element
     * @return The element above the reference element
     */
    private static WebElement findElementAbove(WebDriver driver, WebElement referenceElement) {
        int refY = referenceElement.getLocation().getY();
        
        // Find all elements
        List<WebElement> allElements = driver.findElements(By.xpath("//*"));
        WebElement closestElement = null;
        int closestDistance = Integer.MAX_VALUE;
        
        for (WebElement element : allElements) {
            int elemY = element.getLocation().getY();
            int distance = refY - elemY;
            
            if (distance > 0 && distance < closestDistance) {
                closestDistance = distance;
                closestElement = element;
            }
        }
        
        return closestElement;
    }
    
    /**
     * Finds an element below the reference element.
     * 
     * @param driver The WebDriver
     * @param referenceElement The reference element
     * @return The element below the reference element
     */
    private static WebElement findElementBelow(WebDriver driver, WebElement referenceElement) {
        int refY = referenceElement.getLocation().getY() + referenceElement.getSize().getHeight();
        
        // Find all elements
        List<WebElement> allElements = driver.findElements(By.xpath("//*"));
        WebElement closestElement = null;
        int closestDistance = Integer.MAX_VALUE;
        
        for (WebElement element : allElements) {
            int elemY = element.getLocation().getY();
            int distance = elemY - refY;
            
            if (distance > 0 && distance < closestDistance) {
                closestDistance = distance;
                closestElement = element;
            }
        }
        
        return closestElement;
    }
    
    /**
     * Finds an element to the left of the reference element.
     * 
     * @param driver The WebDriver
     * @param referenceElement The reference element
     * @return The element to the left of the reference element
     */
    private static WebElement findElementLeftOf(WebDriver driver, WebElement referenceElement) {
        int refX = referenceElement.getLocation().getX();
        
        // Find all elements
        List<WebElement> allElements = driver.findElements(By.xpath("//*"));
        WebElement closestElement = null;
        int closestDistance = Integer.MAX_VALUE;
        
        for (WebElement element : allElements) {
            int elemX = element.getLocation().getX() + element.getSize().getWidth();
            int distance = refX - elemX;
            
            if (distance > 0 && distance < closestDistance) {
                closestDistance = distance;
                closestElement = element;
            }
        }
        
        return closestElement;
    }
    
    /**
     * Finds an element to the right of the reference element.
     * 
     * @param driver The WebDriver
     * @param referenceElement The reference element
     * @return The element to the right of the reference element
     */
    private static WebElement findElementRightOf(WebDriver driver, WebElement referenceElement) {
        int refX = referenceElement.getLocation().getX() + referenceElement.getSize().getWidth();
        
        // Find all elements
        List<WebElement> allElements = driver.findElements(By.xpath("//*"));
        WebElement closestElement = null;
        int closestDistance = Integer.MAX_VALUE;
        
        for (WebElement element : allElements) {
            int elemX = element.getLocation().getX();
            int distance = elemX - refX;
            
            if (distance > 0 && distance < closestDistance) {
                closestDistance = distance;
                closestElement = element;
            }
        }
        
        return closestElement;
    }
    
    /**
     * Finds an element near the reference element.
     * 
     * @param driver The WebDriver
     * @param referenceElement The reference element
     * @return The element near the reference element
     */
    private static WebElement findElementNear(WebDriver driver, WebElement referenceElement) {
        int refX = referenceElement.getLocation().getX() + referenceElement.getSize().getWidth() / 2;
        int refY = referenceElement.getLocation().getY() + referenceElement.getSize().getHeight() / 2;
        
        // Find all elements
        List<WebElement> allElements = driver.findElements(By.xpath("//*"));
        WebElement closestElement = null;
        int closestDistance = Integer.MAX_VALUE;
        
        for (WebElement element : allElements) {
            if (element.equals(referenceElement)) {
                continue;
            }
            
            int elemX = element.getLocation().getX() + element.getSize().getWidth() / 2;
            int elemY = element.getLocation().getY() + element.getSize().getHeight() / 2;
            
            int distance = (int) Math.sqrt(Math.pow(elemX - refX, 2) + Math.pow(elemY - refY, 2));
            
            if (distance > 0 && distance < closestDistance) {
                closestDistance = distance;
                closestElement = element;
            }
        }
        
        return closestElement;
    }
    
    /**
     * Implementation of By that uses a JavaScript expression to find elements.
     */
    public static class ByJavaScript extends By {
        private final String script;
        
        /**
         * Constructor for ByJavaScript.
         * 
         * @param script The JavaScript expression to use
         */
        public ByJavaScript(String script) {
            this.script = script;
        }
        
        @Override
        public List<WebElement> findElements(SearchContext context) {
            if (context instanceof WebDriver) {
                WebDriver driver = (WebDriver) context;
                Object result = ((org.openqa.selenium.JavascriptExecutor) driver).executeScript(script);
                
                if (result instanceof WebElement) {
                    List<WebElement> elements = new ArrayList<>();
                    elements.add((WebElement) result);
                    return elements;
                } else if (result instanceof List) {
                    @SuppressWarnings("unchecked")
                    List<WebElement> elements = (List<WebElement>) result;
                    return elements;
                }
            }
            
            return new ArrayList<>();
        }
        
        @Override
        public WebElement findElement(SearchContext context) {
            List<WebElement> elements = findElements(context);
            if (elements.isEmpty()) {
                throw new org.openqa.selenium.NoSuchElementException("Cannot find element with JavaScript: " + script);
            }
            return elements.get(0);
        }
        
        @Override
        public String toString() {
            return "By.javascript: " + script;
        }
    }
    
    /**
     * Implementation of By that tries multiple locators in sequence.
     */
    public static class ByFallback extends By {
        private final String[] locators;
        
        /**
         * Constructor for ByFallback.
         * 
         * @param locators The locators to try in sequence
         */
        public ByFallback(String[] locators) {
            this.locators = locators;
        }
        
        @Override
        public List<WebElement> findElements(SearchContext context) {
            for (String locatorString : locators) {
                try {
                    By locator = parseLocatorString(locatorString);
                    List<WebElement> elements = locator.findElements(context);
                    if (!elements.isEmpty()) {
                        return elements;
                    }
                } catch (Exception e) {
                    logger.debug("Error with fallback locator " + locatorString + ": " + e.getMessage());
                    // Continue to the next locator
                }
            }
            
            return new ArrayList<>();
        }
        
        @Override
        public WebElement findElement(SearchContext context) {
            for (String locatorString : locators) {
                try {
                    By locator = parseLocatorString(locatorString);
                    return locator.findElement(context);
                } catch (Exception e) {
                    logger.debug("Error with fallback locator " + locatorString + ": " + e.getMessage());
                    // Continue to the next locator
                }
            }
            
            throw new org.openqa.selenium.NoSuchElementException("Cannot find element with any of the fallback locators");
        }
        
        @Override
        public String toString() {
            return "By.fallback: " + Arrays.toString(locators);
        }
    }
    
    /**
     * Implementation of By that tries multiple locators in sequence.
     */
    public static class ByChain extends By {
        private final List<By> locators;
        
        /**
         * Constructor for ByChain.
         * 
         * @param locators The locators to try in sequence
         */
        public ByChain(List<By> locators) {
            this.locators = locators;
        }
        
        @Override
        public List<WebElement> findElements(SearchContext context) {
            for (By locator : locators) {
                try {
                    List<WebElement> elements = locator.findElements(context);
                    if (!elements.isEmpty()) {
                        return elements;
                    }
                } catch (Exception e) {
                    logger.debug("Error with chain locator " + locator + ": " + e.getMessage());
                    // Continue to the next locator
                }
            }
            
            return new ArrayList<>();
        }
        
        @Override
        public WebElement findElement(SearchContext context) {
            for (By locator : locators) {
                try {
                    return locator.findElement(context);
                } catch (Exception e) {
                    logger.debug("Error with chain locator " + locator + ": " + e.getMessage());
                    // Continue to the next locator
                }
            }
            
            throw new org.openqa.selenium.NoSuchElementException("Cannot find element with any of the chain locators");
        }
        
        @Override
        public String toString() {
            return "By.chain: " + locators;
        }
    }
    
    /**
     * Implementation of By that uses a function to find elements.
     */
    public static class ByFunction extends By {
        private final java.util.function.Function<WebDriver, WebElement> function;
        
        /**
         * Constructor for ByFunction.
         * 
         * @param function The function to use
         */
        public ByFunction(java.util.function.Function<WebDriver, WebElement> function) {
            this.function = function;
        }
        
        @Override
        public List<WebElement> findElements(SearchContext context) {
            WebElement element = findElement(context);
            if (element != null) {
                List<WebElement> elements = new ArrayList<>();
                elements.add(element);
                return elements;
            }
            
            return new ArrayList<>();
        }
        
        @Override
        public WebElement findElement(SearchContext context) {
            WebDriver driver;
            if (context instanceof WebDriver) {
                driver = (WebDriver) context;
            } else {
                driver = CSWebDriverManager.getInstance().getDriver();
            }
            
            WebElement element = function.apply(driver);
            if (element == null) {
                throw new org.openqa.selenium.NoSuchElementException("Cannot find element with function");
            }
            
            return element;
        }
        
        @Override
        public String toString() {
            return "By.function";
        }
    }
}


// com/cstestforge/framework/selenium/java/annotations/CSTestStepDef.java
package com.cstestforge.framework.selenium.java.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for test step definitions in BDD tests.
 * This annotation provides metadata for test steps, including reporting information.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CSTestStepDef {

    /**
     * The description of the test step.
     * Used for reporting and documentation.
     * 
     * @return The step description
     */
    String description() default "";
    
    /**
     * The expected outcome of the test step.
     * Used for reporting and documentation.
     * 
     * @return The expected outcome
     */
    String expectedOutcome() default "";
    
    /**
     * The preconditions for the test step.
     * Used for reporting and documentation.
     * 
     * @return The preconditions
     */
    String[] preconditions() default {};
    
    /**
     * The test data required for the test step.
     * Used for reporting and documentation.
     * 
     * @return The test data
     */
    String[] testData() default {};
    
    /**
     * The category of the test step.
     * Used for reporting and organization.
     * 
     * @return The step category
     */
    String category() default "";
    
    /**
     * The priority of the test step.
     * Used for reporting and organization.
     * 
     * @return The step priority
     */
    String priority() default "Medium";
    
    /**
     * The criticality of the test step.
     * Used for reporting and organization.
     * 
     * @return The step criticality
     */
    String criticality() default "Medium";
    
    /**
     * The expected execution time of the test step in seconds.
     * Used for performance monitoring.
     * 
     * @return The expected execution time
     */
    int expectedExecutionTime() default 0;
    
    /**
     * Whether to take a screenshot after the test step.
     * 
     * @return true to take a screenshot, false otherwise
     */
    boolean takeScreenshot() default false;
    
    /**
     * Whether to fail the test if the step takes longer than the expected execution time.
     * 
     * @return true to fail on timeout, false otherwise
     */
    boolean failOnTimeout() default false;
    
    /**
     * Whether to retry the step if it fails.
     * 
     * @return true to retry on failure, false otherwise
     */
    boolean retryOnFailure() default false;
    
    /**
     * The maximum number of retries for the step.
     * Used if retryOnFailure is true.
     * 
     * @return The maximum number of retries
     */
    int maxRetries() default 3;
    
    /**
     * The delay between retries in milliseconds.
     * Used if retryOnFailure is true.
     * 
     * @return The delay between retries
     */
    int retryDelayMillis() default 1000;
    
    /**
     * The test group or feature this step belongs to.
     * Used for reporting and organization.
     * 
     * @return The test group or feature
     */
    String group() default "";
    
    /**
     * The test component or module this step interacts with.
     * Used for reporting and organization.
     * 
     * @return The test component or module
     */
    String component() default "";
    
    /**
     * Tags for the test step.
     * Used for filtering and organization.
     * 
     * @return The tags
     */
    String[] tags() default {};
    
    /**
     * The order of the step in a sequence of steps.
     * Used for reporting and documentation.
     * 
     * @return The step order
     */
    int order() default 0;
    
    /**
     * The test case ID associated with this step.
     * Used for traceability.
     * 
     * @return The test case ID
     */
    String testCaseId() default "";
    
    /**
     * The requirements associated with this step.
     * Used for traceability.
     * 
     * @return The requirements
     */
    String[] requirements() default {};
    
    /**
     * Whether to log the step in the report.
     * 
     * @return true to log the step, false otherwise
     */
    boolean logStep() default true;
    
    /**
     * Whether to highlight the associated UI elements during execution.
     * 
     * @return true to highlight UI elements, false otherwise
     */
    boolean highlightElements() default false;
    
    /**
     * The expected conditions that should be satisfied after executing this step.
     * Used for verification.
     * 
     * @return The post-conditions
     */
    String[] postConditions() default {};
    
    /**
     * Whether to verify the post-conditions automatically.
     * 
     * @return true to verify post-conditions, false otherwise
     */
    boolean verifyPostConditions() default false;
    
    /**
     * The timeout for verifying post-conditions in seconds.
     * 
     * @return The timeout for post-conditions
     */
    int postConditionTimeoutSeconds() default 30;
    
    /**
     * The author of the test step.
     * Used for documentation.
     * 
     * @return The author
     */
    String author() default "";
    
    /**
     * The date the test step was created or last modified.
     * Used for documentation.
     * 
     * @return The date
     */
    String date() default "";
    
    /**
     * The reviewer of the test step.
     * Used for documentation.
     * 
     * @return The reviewer
     */
    String reviewer() default "";
    
    /**
     * Whether to include this step in reports.
     * 
     * @return true to include in reports, false otherwise
     */
    boolean includeInReports() default true;
    
    /**
     * Custom data for the test step.
     * Format: "key1:value1, key2:value2"
     * 
     * @return The custom data
     */
    String customData() default "";
}


