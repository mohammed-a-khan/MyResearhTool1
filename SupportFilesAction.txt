ActionService.java
-----------------------


package com.cstestforge.service.action;

import com.cstestforge.model.action.ActionConfig;
import com.cstestforge.model.action.ActionType;
import com.cstestforge.model.action.DataProviderActionConfig;
import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;

import java.util.List;
import java.util.Map;

/**
 * Service interface for action operations.
 * This service provides functionality for action configuration, validation, and code generation.
 */
public interface ActionService {
    
    /**
     * Get supported action types for a specific framework, language, and test type combination.
     *
     * @param frameworkType Framework type (Selenium, Playwright)
     * @param languageType Language type (Java, TypeScript)
     * @param testType Test type (TestNG, BDD)
     * @return List of supported action types
     */
    List<ActionType> getSupportedActionTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Get action configuration schema for a specific action type.
     *
     * @param actionType Action type
     * @return Schema as a map of property names to property definitions
     */
    Map<String, Object> getActionConfigSchema(ActionType actionType);
    
    /**
     * Validate an action configuration.
     *
     * @param actionConfig Action configuration to validate
     * @return List of validation errors, empty if validation passed
     */
    List<String> validateActionConfig(ActionConfig actionConfig);
    
    /**
     * Generate code for an action configuration.
     *
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return Generated code as a string
     */
    String generateActionCode(ActionConfig actionConfig, FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Get action templates for a specific action type, framework, language, and test type.
     *
     * @param actionType Action type
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of action templates
     */
    List<ActionConfig> getActionTemplates(ActionType actionType, FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Create an action template.
     *
     * @param actionConfig Action configuration to create as a template
     * @return Created action template
     */
    ActionConfig createActionTemplate(ActionConfig actionConfig);
    
    /**
     * Delete an action template.
     *
     * @param templateId ID of the template to delete
     * @return true if template was deleted, false otherwise
     */
    boolean deleteActionTemplate(String templateId);
    
    /**
     * Get available assertion types for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of assertion types with their metadata
     */
    List<Map<String, Object>> getAssertionTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Get available wait strategies for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of wait strategies with their metadata
     */
    List<Map<String, Object>> getWaitStrategies(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Execute JavaScript in a test execution context.
     *
     * @param executionId ID of the test execution
     * @param script JavaScript code to execute
     * @return Result of the execution
     */
    Map<String, Object> executeJavaScript(String executionId, String script);
    
    /**
     * Get available data provider types for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of data provider types with their metadata
     */
    List<Map<String, Object>> getDataProviderTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Preview data from a data provider configuration.
     *
     * @param dataProviderConfig Data provider configuration
     * @return Preview of the data as a list of rows
     */
    List<Map<String, Object>> previewDataProvider(DataProviderActionConfig dataProviderConfig);
    
    /**
     * Get supported conditional operators for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of conditional operators with their metadata
     */
    List<Map<String, Object>> getConditionalOperators(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Get supported loop types for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of loop types with their metadata
     */
    List<Map<String, Object>> getLoopTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType);
}



ActionServiceImpl.java
--------------------------------

package com.cstestforge.service.action;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSTextUtils;
import com.cstestforge.model.action.ActionConfig;
import com.cstestforge.model.action.ActionType;
import com.cstestforge.model.action.AssertionActionConfig;
import com.cstestforge.model.action.ConditionalActionConfig;
import com.cstestforge.model.action.CustomActionConfig;
import com.cstestforge.model.action.DataProviderActionConfig;
import com.cstestforge.model.action.LoopActionConfig;
import com.cstestforge.model.action.WaitActionConfig;
import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;
import com.cstestforge.service.storage.FileSystemStorageService;

/**
 * Implementation of the ActionService interface.
 * This class provides functionality for action operations.
 */
@Service
public class ActionServiceImpl implements ActionService {

    private static final CSLogger LOGGER = CSLogger.getLogger(ActionServiceImpl.class);
    
    private final FileSystemStorageService storageService;
    private final Map<String, ActionConfig> templateCache = new HashMap<>();
    private final ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
    
    // Directory for storing action templates
    private final String templatesDirectory;
    
    @Autowired
    public ActionServiceImpl(FileSystemStorageService storageService) {
        this.storageService = storageService;
        
        // Get templates directory from configuration or use default
        ConfigurationManager configManager = ConfigurationManager.getInstance();
        this.templatesDirectory = configManager.getStringConfig("framework.templates.directory", 
                System.getProperty("user.dir") + File.separator + "templates" + File.separator + "actions");
        
        // Ensure templates directory exists
        createTemplatesDirectory();
        
        // Load templates into cache
        loadTemplates();
    }
    
    /**
     * Create templates directory if it doesn't exist.
     */
    private void createTemplatesDirectory() {
        try {
            Path templatesPath = Paths.get(templatesDirectory);
            if (!Files.exists(templatesPath)) {
                Files.createDirectories(templatesPath);
                LOGGER.info("Created templates directory: {}", templatesDirectory);
            }
        } catch (IOException e) {
            LOGGER.error("Failed to create templates directory: {}", templatesDirectory, e);
        }
    }
    
    /**
     * Load templates into cache.
     */
    private void loadTemplates() {
        try {
            Path templatesPath = Paths.get(templatesDirectory);
            if (!Files.exists(templatesPath)) {
                return;
            }
            
            Files.walk(templatesPath)
                    .filter(path -> path.toString().endsWith(".json"))
                    .forEach(path -> {
                        try {
                            ActionConfig template = storageService.loadObject(path.toString(), ActionConfig.class);
                            if (template != null) {
                                templateCache.put(template.getId(), template);
                                LOGGER.debug("Loaded template: {}", template.getTemplateName());
                            }
                        } catch (Exception e) {
                            LOGGER.error("Failed to load template from {}: {}", path, e.getMessage());
                        }
                    });
            
            LOGGER.info("Loaded {} templates", templateCache.size());
        } catch (IOException e) {
            LOGGER.error("Failed to load templates", e);
        }
    }
    
    @Override
    public List<ActionType> getSupportedActionTypes(
            FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        
        LOGGER.debug("Getting supported action types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        // All action types are supported by default
        List<ActionType> actionTypes = new ArrayList<>(Arrays.asList(ActionType.values()));
        
        // Filter action types based on framework, language, and test type
        if (frameworkType != null) {
            if (frameworkType == FrameworkType.SELENIUM) {
                // Remove Playwright-specific action types
                // Currently, all action types are supported by both frameworks
            } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                // Remove Selenium-specific action types
                // Currently, all action types are supported by both frameworks
            }
        }
        
        if (languageType != null) {
            if (languageType == LanguageType.JAVA) {
                // Remove TypeScript-specific action types
                // Currently, all action types are supported by both languages
            } else if (languageType == LanguageType.TYPESCRIPT) {
                // Remove Java-specific action types
                // Currently, all action types are supported by both languages
            }
        }
        
        if (testType != null) {
            if (testType == TestType.TESTNG) {
                // Remove BDD-specific action types
                // Currently, all action types are supported by both test types
            } else if (testType == TestType.BDD) {
                // Remove TestNG-specific action types
                // Currently, all action types are supported by both test types
            }
        }
        
        return actionTypes;
    }
    
    @Override
    public Map<String, Object> getActionConfigSchema(ActionType actionType) {
        LOGGER.debug("Getting action schema for action type: {}", actionType);
        
        Map<String, Object> schema = new LinkedHashMap<>();
        
        // Common properties for all action types
        schema.put("id", Map.of("type", "string", "description", "Unique identifier for the action"));
        schema.put("actionType", Map.of("type", "enum", "enum", Arrays.stream(ActionType.values()).map(Enum::name).toArray(), "description", "Type of action"));
        schema.put("name", Map.of("type", "string", "description", "Display name for the action"));
        schema.put("description", Map.of("type", "string", "description", "Description of the action"));
        schema.put("enabled", Map.of("type", "boolean", "default", true, "description", "Whether the action is enabled"));
        
        // Action type specific properties
        switch (actionType) {
            case CLICK:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before clicking"));
                break;
                
            case TYPE:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("text", Map.of("type", "string", "description", "Text to type"));
                schema.put("clearBefore", Map.of("type", "boolean", "default", true, "description", "Whether to clear the field before typing"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before typing"));
                break;
                
            case SELECT:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("option", Map.of("type", "string", "description", "Option to select"));
                schema.put("selectBy", Map.of("type", "enum", "enum", new String[]{"TEXT", "VALUE", "INDEX"}, "description", "How to select the option"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before selecting"));
                break;
                
            case ASSERT:
                schema.put("assertionType", Map.of("type", "string", "description", "Type of assertion"));
                schema.put("locator", Map.of("type", "string", "description", "Element locator (if applicable)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (if applicable)"));
                schema.put("expectedValue", Map.of("type", "string", "description", "Expected value for the assertion"));
                schema.put("actualValue", Map.of("type", "string", "description", "Actual value for the assertion (variable or expression)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("failOnAssertionError", Map.of("type", "boolean", "default", true, "description", "Whether to fail the test on assertion error"));
                break;
                
            case WAIT:
                schema.put("waitType", Map.of("type", "string", "description", "Type of wait"));
                schema.put("locator", Map.of("type", "string", "description", "Element locator (if applicable)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (if applicable)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("condition", Map.of("type", "string", "description", "Condition to wait for (if applicable)"));
                schema.put("pollingInterval", Map.of("type", "integer", "default", 500, "description", "Polling interval in milliseconds"));
                break;
                
            case NAVIGATE:
                schema.put("url", Map.of("type", "string", "description", "URL to navigate to"));
                schema.put("waitForLoad", Map.of("type", "boolean", "default", true, "description", "Whether to wait for page load"));
                schema.put("timeout", Map.of("type", "integer", "default", 60, "description", "Timeout in seconds"));
                break;
                
            case CONDITIONAL:
                schema.put("condition", Map.of("type", "string", "description", "Condition expression"));
                schema.put("operator", Map.of("type", "string", "description", "Conditional operator"));
                schema.put("leftOperand", Map.of("type", "string", "description", "Left operand (variable, expression, or literal)"));
                schema.put("rightOperand", Map.of("type", "string", "description", "Right operand (variable, expression, or literal)"));
                schema.put("nestedActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute if condition is true"));
                schema.put("elseActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute if condition is false"));
                break;
                
            case LOOP:
                schema.put("loopType", Map.of("type", "string", "description", "Type of loop"));
                schema.put("times", Map.of("type", "integer", "description", "Number of times to loop (for 'times' loop type)"));
                schema.put("collection", Map.of("type", "string", "description", "Collection to iterate over (for 'foreach' loop type)"));
                schema.put("variableName", Map.of("type", "string", "description", "Variable name for loop item (for 'foreach' loop type)"));
                schema.put("initExpression", Map.of("type", "string", "description", "Initialization expression (for 'for' loop type)"));
                schema.put("conditionExpression", Map.of("type", "string", "description", "Condition expression (for 'for' and 'while' loop types)"));
                schema.put("incrementExpression", Map.of("type", "string", "description", "Increment expression (for 'for' loop type)"));
                schema.put("nestedActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute in the loop"));
                break;
                
            case DATA_PROVIDER:
                schema.put("dataSourceType", Map.of("type", "string", "description", "Type of data source"));
                schema.put("dataSourcePath", Map.of("type", "string", "description", "Path to the data source"));
                schema.put("sheetName", Map.of("type", "string", "description", "Sheet name (for Excel data source)"));
                schema.put("delimiter", Map.of("type", "string", "default", ",", "description", "Delimiter (for CSV data source)"));
                schema.put("headers", Map.of("type", "boolean", "default", true, "description", "Whether the data has headers"));
                schema.put("parameters", Map.of("type", "array", "items", Map.of("type", "string", "description", "Parameter name"), "description", "Parameter names for the data provider"));
                schema.put("iterationActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute for each data iteration"));
                break;
                
            case CUSTOM:
                schema.put("scriptType", Map.of("type", "string", "description", "Type of script"));
                schema.put("script", Map.of("type", "string", "description", "Script content"));
                schema.put("parameters", Map.of("type", "array", "items", Map.of("type", "object", "properties", Map.of(
                        "name", Map.of("type", "string", "description", "Parameter name"),
                        "value", Map.of("type", "string", "description", "Parameter value")
                )), "description", "Script parameters"));
                break;
                
            case VARIABLE:
                schema.put("variableName", Map.of("type", "string", "description", "Name of the variable"));
                schema.put("variableType", Map.of("type", "string", "description", "Type of the variable"));
                schema.put("value", Map.of("type", "string", "description", "Value of the variable"));
                schema.put("scope", Map.of("type", "string", "description", "Scope of the variable"));
                break;
                
            case SCREENSHOT:
                schema.put("fileName", Map.of("type", "string", "description", "Name of the screenshot file"));
                schema.put("element", Map.of("type", "string", "description", "Element locator (for element screenshot, optional)"));
                schema.put("fullPage", Map.of("type", "boolean", "default", false, "description", "Whether to capture full page"));
                schema.put("directory", Map.of("type", "string", "description", "Directory to save the screenshot (optional)"));
                break;
                
            case HOVER:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before hovering"));
                break;
                
            case DRAG_DROP:
                schema.put("sourceLocator", Map.of("type", "string", "description", "Source element locator"));
                schema.put("sourceLocatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of source locator"));
                schema.put("targetLocator", Map.of("type", "string", "description", "Target element locator"));
                schema.put("targetLocatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of target locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElements", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the elements before drag and drop"));
                break;
                
            case SWITCH_FRAME:
                schema.put("frameLocator", Map.of("type", "string", "description", "Frame locator"));
                schema.put("frameLocatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT", "INDEX"}, "description", "Type of frame locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("switchToDefault", Map.of("type", "boolean", "default", false, "description", "Whether to switch to default content instead of a specific frame"));
                schema.put("switchToParent", Map.of("type", "boolean", "default", false, "description", "Whether to switch to parent frame instead of a specific frame"));
                break;
                
            case SWITCH_WINDOW:
                schema.put("windowHandle", Map.of("type", "string", "description", "Window handle (optional)"));
                schema.put("windowIndex", Map.of("type", "integer", "description", "Window index (optional)"));
                schema.put("windowTitle", Map.of("type", "string", "description", "Window title (optional)"));
                schema.put("windowUrl", Map.of("type", "string", "description", "Window URL (optional)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                break;
                
            case EXECUTE_SCRIPT:
                schema.put("script", Map.of("type", "string", "description", "JavaScript code to execute"));
                schema.put("arguments", Map.of("type", "array", "items", Map.of("type", "string", "description", "Argument value"), "description", "Script arguments"));
                schema.put("resultVariable", Map.of("type", "string", "description", "Variable to store the result (optional)"));
                break;
                
            case FILE_UPLOAD:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("filePath", Map.of("type", "string", "description", "Path to the file to upload"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before uploading"));
                break;
                
            case KEY_PRESS:
                schema.put("locator", Map.of("type", "string", "description", "Element locator (optional)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (optional)"));
                schema.put("key", Map.of("type", "string", "description", "Key to press"));
                schema.put("modifiers", Map.of("type", "array", "items", Map.of("type", "string", "description", "Modifier key"), "description", "Modifier keys (optional)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                break;
                
            case SCROLL:
                schema.put("locator", Map.of("type", "string", "description", "Element locator (optional)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (optional)"));
                schema.put("x", Map.of("type", "integer", "description", "X coordinate (optional)"));
                schema.put("y", Map.of("type", "integer", "description", "Y coordinate (optional)"));
                schema.put("scrollType", Map.of("type", "enum", "enum", new String[]{"PIXEL", "ELEMENT", "TOP", "BOTTOM", "CENTER"}, "description", "Type of scroll"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                break;
                
            default:
                // Default schema with no additional properties
                break;
        }
        
        return schema;
    }
    
    @Override
    public List<String> validateActionConfig(ActionConfig actionConfig) {
        if (actionConfig == null) {
            return List.of("Action configuration is null");
        }
        
        List<String> errors = new ArrayList<>();
        
        // Validate common properties
        if (actionConfig.getActionType() == null) {
            errors.add("Action type is required");
        }
        
        // Validate action type specific properties
        switch (actionConfig.getActionType()) {
            case CLICK:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for click action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for click action");
                }
                break;
                
            case TYPE:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for type action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for type action");
                }
                if (actionConfig.getProperty("text") == null) {
                    errors.add("Text is required for type action");
                }
                break;
                
            case SELECT:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for select action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for select action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("option"))) {
                    errors.add("Option is required for select action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("selectBy"))) {
                    errors.add("Select by is required for select action");
                }
                break;
                
            case ASSERT:
                AssertionActionConfig assertionConfig = (AssertionActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(assertionConfig.getAssertionType())) {
                    errors.add("Assertion type is required for assert action");
                }
                
                // Validate based on assertion type
                String assertionType = assertionConfig.getAssertionType();
                if (assertionType != null) {
                    if (assertionType.contains("ELEMENT")) {
                        if (CSTextUtils.isNullOrEmpty(assertionConfig.getLocator())) {
                            errors.add("Locator is required for element assertion");
                        }
                        if (CSTextUtils.isNullOrEmpty(assertionConfig.getLocatorType())) {
                            errors.add("Locator type is required for element assertion");
                        }
                    }
                    
                    if (assertionType.contains("EQUALS") || assertionType.contains("CONTAINS") || 
                            assertionType.contains("MATCHES")) {
                        if (assertionConfig.getExpectedValue() == null) {
                            errors.add("Expected value is required for comparison assertion");
                        }
                    }
                }
                break;
                
            case WAIT:
                WaitActionConfig waitConfig = (WaitActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(waitConfig.getWaitType())) {
                    errors.add("Wait type is required for wait action");
                }
                
                // Validate based on wait type
                String waitType = waitConfig.getWaitType();
                if (waitType != null) {
                    if (waitType.contains("ELEMENT")) {
                        if (CSTextUtils.isNullOrEmpty(waitConfig.getLocator())) {
                            errors.add("Locator is required for element wait");
                        }
                        if (CSTextUtils.isNullOrEmpty(waitConfig.getLocatorType())) {
                            errors.add("Locator type is required for element wait");
                        }
                    }
                }
                break;
                
            case NAVIGATE:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("url"))) {
                    errors.add("URL is required for navigate action");
                }
                break;
                
            case CONDITIONAL:
                ConditionalActionConfig conditionalConfig = (ConditionalActionConfig) actionConfig;
                
                if (CSTextUtils.isNullOrEmpty(conditionalConfig.getCondition()) && 
                        (CSTextUtils.isNullOrEmpty(conditionalConfig.getOperator()) || 
                         conditionalConfig.getLeftOperand() == null || 
                         conditionalConfig.getRightOperand() == null)) {
                    errors.add("Either condition or operator with operands is required for conditional action");
                }
                
                if (conditionalConfig.getNestedActions() == null || conditionalConfig.getNestedActions().isEmpty()) {
                    errors.add("Nested actions are required for conditional action");
                }
                break;
                
            case LOOP:
                LoopActionConfig loopConfig = (LoopActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(loopConfig.getLoopType())) {
                    errors.add("Loop type is required for loop action");
                }
                
                // Validate based on loop type
                String loopType = loopConfig.getLoopType();
                if (loopType != null) {
                    if (loopType.equals("TIMES")) {
                        if (loopConfig.getTimes() <= 0) {
                            errors.add("Times must be greater than 0 for times loop");
                        }
                    } else if (loopType.equals("FOREACH")) {
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getCollection())) {
                            errors.add("Collection is required for foreach loop");
                        }
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getVariableName())) {
                            errors.add("Variable name is required for foreach loop");
                        }
                    } else if (loopType.equals("FOR")) {
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getInitExpression())) {
                            errors.add("Init expression is required for for loop");
                        }
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getConditionExpression())) {
                            errors.add("Condition expression is required for for loop");
                        }
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getIncrementExpression())) {
                            errors.add("Increment expression is required for for loop");
                        }
                    } else if (loopType.equals("WHILE")) {
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getConditionExpression())) {
                            errors.add("Condition expression is required for while loop");
                        }
                    }
                }
                
                if (loopConfig.getNestedActions() == null || loopConfig.getNestedActions().isEmpty()) {
                    errors.add("Nested actions are required for loop action");
                }
                break;
                
            case DATA_PROVIDER:
                DataProviderActionConfig dataProviderConfig = (DataProviderActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(dataProviderConfig.getDataSourceType())) {
                    errors.add("Data source type is required for data provider action");
                }
                if (CSTextUtils.isNullOrEmpty(dataProviderConfig.getDataSourcePath())) {
                    errors.add("Data source path is required for data provider action");
                }
                
                // Validate based on data source type
                String dataSourceType = dataProviderConfig.getDataSourceType();
                if (dataSourceType != null) {
                    if (dataSourceType.equals("EXCEL")) {
                        if (CSTextUtils.isNullOrEmpty(dataProviderConfig.getSheetName())) {
                            errors.add("Sheet name is required for Excel data source");
                        }
                    }
                }
                
                if (dataProviderConfig.getParameters() == null || dataProviderConfig.getParameters().isEmpty()) {
                    errors.add("Parameters are required for data provider action");
                }
                
                if (dataProviderConfig.getIterationActions() == null || dataProviderConfig.getIterationActions().isEmpty()) {
                    errors.add("Iteration actions are required for data provider action");
                }
                break;
                
            case CUSTOM:
                CustomActionConfig customConfig = (CustomActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(customConfig.getScriptType())) {
                    errors.add("Script type is required for custom action");
                }
                if (CSTextUtils.isNullOrEmpty(customConfig.getScript())) {
                    errors.add("Script is required for custom action");
                }
                break;
                
            case VARIABLE:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("variableName"))) {
                    errors.add("Variable name is required for variable action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("variableType"))) {
                    errors.add("Variable type is required for variable action");
                }
                break;
                
            case HOVER:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for hover action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for hover action");
                }
                break;
                
            case DRAG_DROP:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("sourceLocator"))) {
                    errors.add("Source locator is required for drag and drop action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("sourceLocatorType"))) {
                    errors.add("Source locator type is required for drag and drop action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("targetLocator"))) {
                    errors.add("Target locator is required for drag and drop action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("targetLocatorType"))) {
                    errors.add("Target locator type is required for drag and drop action");
                }
                break;
                
            case SWITCH_FRAME:
                if (!Boolean.TRUE.equals(actionConfig.getProperty("switchToDefault")) && 
                        !Boolean.TRUE.equals(actionConfig.getProperty("switchToParent"))) {
                    if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("frameLocator"))) {
                        errors.add("Frame locator is required for switch frame action");
                    }
                    if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("frameLocatorType"))) {
                        errors.add("Frame locator type is required for switch frame action");
                    }
                }
                break;
                
            case SWITCH_WINDOW:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("windowHandle")) && 
                        actionConfig.getProperty("windowIndex") == null && 
                        CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("windowTitle")) && 
                        CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("windowUrl"))) {
                    errors.add("Window handle, index, title, or URL is required for switch window action");
                }
                break;
                
            case EXECUTE_SCRIPT:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("script"))) {
                    errors.add("Script is required for execute script action");
                }
                break;
                
            case FILE_UPLOAD:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for file upload action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for file upload action");
                }
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("filePath"))) {
                    errors.add("File path is required for file upload action");
                }
                break;
                
            case KEY_PRESS:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("key"))) {
                    errors.add("Key is required for key press action");
                }
                break;
                
            case SCROLL:
                if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("scrollType"))) {
                    errors.add("Scroll type is required for scroll action");
                }
                
                // Validate based on scroll type
                String scrollType = (String) actionConfig.getProperty("scrollType");
                if (scrollType != null) {
                    if (scrollType.equals("PIXEL")) {
                        if (actionConfig.getProperty("x") == null || actionConfig.getProperty("y") == null) {
                            errors.add("X and Y coordinates are required for pixel scroll");
                        }
                    } else if (scrollType.equals("ELEMENT")) {
                        if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locator"))) {
                            errors.add("Locator is required for element scroll");
                        }
                        if (CSTextUtils.isNullOrEmpty((String) actionConfig.getProperty("locatorType"))) {
                            errors.add("Locator type is required for element scroll");
                        }
                    }
                }
                break;
                
            default:
                // No additional validation
                break;
        }
        
        return errors;
    }
    
    @Override
    public String generateActionCode(ActionConfig actionConfig, FrameworkType frameworkType, 
            LanguageType languageType, TestType testType) {
        
        if (actionConfig == null) {
            return "// Action configuration is null";
        }
        
        StringBuilder code = new StringBuilder();
        
        // Generate code based on framework, language, and test type
        if (languageType == LanguageType.JAVA) {
            generateJavaCode(code, actionConfig, frameworkType, testType);
        } else if (languageType == LanguageType.TYPESCRIPT) {
            generateTypeScriptCode(code, actionConfig, frameworkType, testType);
        } else {
            code.append("// Unsupported language type: ").append(languageType);
        }
        
        return code.toString();
    }
    
    /**
     * Generate Java code for an action configuration.
     *
     * @param code StringBuilder to append code to
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void generateJavaCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        ActionType actionType = actionConfig.getActionType();
        
        switch (actionType) {
            case CLICK:
                generateJavaClickCode(code, actionConfig, frameworkType, testType);
                break;
                
            case TYPE:
                generateJavaTypeCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SELECT:
                generateJavaSelectCode(code, actionConfig, frameworkType, testType);
                break;
                
            case ASSERT:
                generateJavaAssertCode(code, (AssertionActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case WAIT:
                generateJavaWaitCode(code, (WaitActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case NAVIGATE:
                generateJavaNavigateCode(code, actionConfig, frameworkType, testType);
                break;
                
            case CONDITIONAL:
                generateJavaConditionalCode(code, (ConditionalActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case LOOP:
                generateJavaLoopCode(code, (LoopActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case DATA_PROVIDER:
                generateJavaDataProviderCode(code, (DataProviderActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case CUSTOM:
                generateJavaCustomCode(code, (CustomActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case VARIABLE:
                generateJavaVariableCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCREENSHOT:
                generateJavaScreenshotCode(code, actionConfig, frameworkType, testType);
                break;
                
            case HOVER:
                generateJavaHoverCode(code, actionConfig, frameworkType, testType);
                break;
                
            case DRAG_DROP:
                generateJavaDragDropCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_FRAME:
                generateJavaSwitchFrameCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_WINDOW:
                generateJavaSwitchWindowCode(code, actionConfig, frameworkType, testType);
                break;
                
            case EXECUTE_SCRIPT:
                generateJavaExecuteScriptCode(code, actionConfig, frameworkType, testType);
                break;
                
            case FILE_UPLOAD:
                generateJavaFileUploadCode(code, actionConfig, frameworkType, testType);
                break;
                
            case KEY_PRESS:
                generateJavaKeyPressCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCROLL:
                generateJavaScrollCode(code, actionConfig, frameworkType, testType);
                break;
                
            default:
                code.append("// Unsupported action type: ").append(actionType);
                break;
        }
    }
    
    /**
     * Generate TypeScript code for an action configuration.
     *
     * @param code StringBuilder to append code to
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void generateTypeScriptCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        ActionType actionType = actionConfig.getActionType();
        
        switch (actionType) {
            case CLICK:
                generateTypeScriptClickCode(code, actionConfig, frameworkType, testType);
                break;
                
            case TYPE:
                generateTypeScriptTypeCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SELECT:
                generateTypeScriptSelectCode(code, actionConfig, frameworkType, testType);
                break;
                
            case ASSERT:
                generateTypeScriptAssertCode(code, (AssertionActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case WAIT:
                generateTypeScriptWaitCode(code, (WaitActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case NAVIGATE:
                generateTypeScriptNavigateCode(code, actionConfig, frameworkType, testType);
                break;
                
            case CONDITIONAL:
                generateTypeScriptConditionalCode(code, (ConditionalActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case LOOP:
                generateTypeScriptLoopCode(code, (LoopActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case DATA_PROVIDER:
                generateTypeScriptDataProviderCode(code, (DataProviderActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case CUSTOM:
                generateTypeScriptCustomCode(code, (CustomActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case VARIABLE:
                generateTypeScriptVariableCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCREENSHOT:
                generateTypeScriptScreenshotCode(code, actionConfig, frameworkType, testType);
                break;
                
            case HOVER:
                generateTypeScriptHoverCode(code, actionConfig, frameworkType, testType);
                break;
                
            case DRAG_DROP:
                generateTypeScriptDragDropCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_FRAME:
                generateTypeScriptSwitchFrameCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_WINDOW:
                generateTypeScriptSwitchWindowCode(code, actionConfig, frameworkType, testType);
                break;
                
            case EXECUTE_SCRIPT:
                generateTypeScriptExecuteScriptCode(code, actionConfig, frameworkType, testType);
                break;
                
            case FILE_UPLOAD:
                generateTypeScriptFileUploadCode(code, actionConfig, frameworkType, testType);
                break;
                
            case KEY_PRESS:
                generateTypeScriptKeyPressCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCROLL:
                generateTypeScriptScrollCode(code, actionConfig, frameworkType, testType);
                break;
                
            default:
                code.append("// Unsupported action type: ").append(actionType);
                break;
        }
    }
    
    /**
     * Generate Java code for a click action.
     */
    private void generateJavaClickCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Click on element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.CLICKABLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.click();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.click();");
        }
    }
    
    /**
     * Generate TypeScript code for a click action.
     */
    private void generateTypeScriptClickCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Click on element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.CLICKABLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.click();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.click();");
        }
    }
    
    /**
     * Generate Java code for a type action.
     */
    private void generateJavaTypeCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String text = (String) actionConfig.getProperty("text");
        Boolean clearBefore = (Boolean) actionConfig.getProperty("clearBefore", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Type text into element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("element.clear();\n");
            }
            
            code.append("element.sendKeys(\"").append(escapeJavaString(text)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("element.clear();\n");
            }
            
            code.append("element.fill(\"").append(escapeJavaString(text)).append("\");");
        }
    }
    
    /**
     * Generate TypeScript code for a type action.
     */
    private void generateTypeScriptTypeCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String text = (String) actionConfig.getProperty("text");
        Boolean clearBefore = (Boolean) actionConfig.getProperty("clearBefore", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Type text into element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("await element.clear();\n");
            }
            
            code.append("await element.sendKeys(\"").append(escapeTypeScriptString(text)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("await element.clear();\n");
            }
            
            code.append("await element.fill(\"").append(escapeTypeScriptString(text)).append("\");");
        }
    }
    
    /**
     * Generate Java code for a select action.
     */
    private void generateJavaSelectCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String option = (String) actionConfig.getProperty("option");
        String selectBy = (String) actionConfig.getProperty("selectBy");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Select option from dropdown\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("CSSelect select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("select.selectByVisibleText(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("select.selectByValue(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("select.selectByIndex(").append(option).append(");");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("CSSelect select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("select.selectByVisibleText(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("select.selectByValue(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("select.selectByIndex(").append(option).append(");");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a select action.
     */
    private void generateTypeScriptSelectCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String option = (String) actionConfig.getProperty("option");
        String selectBy = (String) actionConfig.getProperty("selectBy");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Select option from dropdown\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("const select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("await select.selectByVisibleText(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("await select.selectByValue(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("await select.selectByIndex(").append(option).append(");");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("const select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("await select.selectByVisibleText(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("await select.selectByValue(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("await select.selectByIndex(").append(option).append(");");
            }
        }
    }
    
    // Remaining method implementations would follow the same pattern of fixing inconsistencies...
    // For brevity, I'm only showing the first few methods as examples of the fixes applied

    /**
     * Get locator code for a specific locator type and value.
     *
     * @param locatorType Locator type
     * @param locator Locator value
     * @param languageType Language type
     * @return Locator code
     */
    private String getLocatorCode(String locatorType, String locator, LanguageType languageType) {
        if (locatorType == null || locator == null) {
            return null;
        }
        
        StringBuilder code = new StringBuilder();
        
        if (languageType == LanguageType.JAVA) {
            code.append("By.");
            
            if (locatorType.equals("CSS")) {
                code.append("cssSelector(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("XPATH")) {
                code.append("xpath(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("ID")) {
                code.append("id(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("NAME")) {
                code.append("name(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("CLASS_NAME")) {
                code.append("className(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("TAG_NAME")) {
                code.append("tagName(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("LINK_TEXT")) {
                code.append("linkText(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("PARTIAL_LINK_TEXT")) {
                code.append("partialLinkText(\"").append(escapeJavaString(locator)).append("\")");
            } else {
                code.append("cssSelector(\"").append(escapeJavaString(locator)).append("\")");
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            code.append("By.");
            
            if (locatorType.equals("CSS")) {
                code.append("css(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("XPATH")) {
                code.append("xpath(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("ID")) {
                code.append("id(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("NAME")) {
                code.append("name(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("CLASS_NAME")) {
                code.append("className(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("TAG_NAME")) {
                code.append("tagName(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("LINK_TEXT")) {
                code.append("linkText(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("PARTIAL_LINK_TEXT")) {
                code.append("partialLinkText(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else {
                code.append("css(\"").append(escapeTypeScriptString(locator)).append("\")");
            }
        }
        
        return code.toString();
    }
    
    /**
     * Escape a string for Java code.
     *
     * @param str String to escape
     * @return Escaped string
     */
    private String escapeJavaString(String str) {
        if (str == null) {
            return "";
        }
        
        return str.replace("\\", "\\\\")
                 .replace("\"", "\\\"")
                 .replace("\n", "\\n")
                 .replace("\r", "\\r")
                 .replace("\t", "\\t");
    }
    
    /**
     * Escape a string for TypeScript code.
     *
     * @param str String to escape
     * @return Escaped string
     */
    private String escapeTypeScriptString(String str) {
        if (str == null) {
            return "";
        }
        
        return str.replace("\\", "\\\\")
                 .replace("\"", "\\\"")
                 .replace("\n", "\\n")
                 .replace("\r", "\\r")
                 .replace("\t", "\\t")
                 .replace("`", "\\`")
                 .replace("${", "\\${");
    }
    
    @Override
    public List<ActionConfig> getActionTemplates(ActionType actionType, FrameworkType frameworkType,
            LanguageType languageType, TestType testType) {
        
        LOGGER.debug("Getting action templates for action type: {}, framework: {}, language: {}, test type: {}", 
                actionType, frameworkType, languageType, testType);
        
        // Filter templates by type, framework, language, and test type
        return templateCache.values().stream()
                .filter(template -> template.getActionType() == actionType)
                .filter(template -> template.getFrameworkType() == null || template.getFrameworkType() == frameworkType)
                .filter(template -> template.getLanguageType() == null || template.getLanguageType() == languageType)
                .filter(template -> template.getTestType() == null || template.getTestType() == testType)
                .collect(Collectors.toList());
    }
    
    @Override
    public ActionConfig createActionTemplate(ActionConfig actionConfig) {
        LOGGER.info("Creating action template: {}", actionConfig.getTemplateName());
        
        // Validate template
        if (actionConfig.getTemplateName() == null || actionConfig.getTemplateName().isEmpty()) {
            LOGGER.error("Template name is required");
            return null;
        }
        
        // Generate template ID if not set
        if (actionConfig.getId() == null || actionConfig.getId().isEmpty()) {
            actionConfig.setId(UUID.randomUUID().toString());
        }
        
        // Set creation timestamp
        actionConfig.setTemplateCreationTime(LocalDateTime.now());
        
        try {
            // Determine file path based on template metadata
            String fileName = actionConfig.getActionType().name().toLowerCase() + "_" 
                    + actionConfig.getTemplateName().replaceAll("[^a-zA-Z0-9]", "_") + ".json";
            
            // Create subdirectories if needed
            StringBuilder subDirPath = new StringBuilder();
            if (actionConfig.getFrameworkType() != null) {
                subDirPath.append(actionConfig.getFrameworkType().name().toLowerCase()).append(File.separator);
            }
            if (actionConfig.getLanguageType() != null) {
                subDirPath.append(actionConfig.getLanguageType().name().toLowerCase()).append(File.separator);
            }
            if (actionConfig.getTestType() != null) {
                subDirPath.append(actionConfig.getTestType().name().toLowerCase()).append(File.separator);
            }
            
            Path dirPath = Paths.get(templatesDirectory, subDirPath.toString());
            if (!Files.exists(dirPath)) {
                Files.createDirectories(dirPath);
            }
            
            // Save template
            String fullPath = new File(dirPath.toFile(), fileName).getPath();
            storageService.storeObject(actionConfig, fullPath);
            
            // Add to cache
            templateCache.put(actionConfig.getId(), actionConfig);
            
            LOGGER.info("Template saved to: {}", fullPath);
            return actionConfig;
        } catch (Exception e) {
            LOGGER.error("Failed to create template: {}", e.getMessage(), e);
            return null;
        }
    }
    
    @Override
    public boolean deleteActionTemplate(String templateId) {
        if (templateId == null || templateId.isEmpty()) {
            LOGGER.error("Template ID is required");
            return false;
        }
        
        // Get template from cache
        ActionConfig template = templateCache.get(templateId);
        if (template == null) {
            LOGGER.warn("Template not found: {}", templateId);
            return false;
        }
        
        try {
            // Determine file path based on template metadata
            String fileName = template.getActionType().name().toLowerCase() + "_" 
                    + template.getTemplateName().replaceAll("[^a-zA-Z0-9]", "_") + ".json";
            
            StringBuilder subDirPath = new StringBuilder();
            if (template.getFrameworkType() != null) {
                subDirPath.append(template.getFrameworkType().name().toLowerCase()).append(File.separator);
            }
            if (template.getLanguageType() != null) {
                subDirPath.append(template.getLanguageType().name().toLowerCase()).append(File.separator);
            }
            if (template.getTestType() != null) {
                subDirPath.append(template.getTestType().name().toLowerCase()).append(File.separator);
            }
            
            Path fullPath = Paths.get(templatesDirectory, subDirPath.toString(), fileName);
            
            // Delete file if it exists
            boolean deleted = storageService.delete(fullPath.toString());
            if (!deleted) {
                LOGGER.warn("Failed to delete template file: {}", fullPath);
            }
            
            // Remove from cache
            templateCache.remove(templateId);
            
            LOGGER.info("Template deleted: {}", templateId);
            return true;
        } catch (Exception e) {
            LOGGER.error("Failed to delete template: {}", e.getMessage(), e);
            return false;
        }
    }
    
    @Override
    public List<Map<String, Object>> getAssertionTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting assertion types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> assertionTypes = new ArrayList<>();
        
        // Element assertions
        Map<String, Object> elementPresent = new HashMap<>();
        elementPresent.put("id", "ELEMENT_PRESENT");
        elementPresent.put("name", "Element Present");
        elementPresent.put("description", "Assert that element is present in the DOM");
        elementPresent.put("category", "Element");
        assertionTypes.add(elementPresent);
        
        Map<String, Object> elementVisible = new HashMap<>();
        elementVisible.put("id", "ELEMENT_VISIBLE");
        elementVisible.put("name", "Element Visible");
        elementVisible.put("description", "Assert that element is visible");
        elementVisible.put("category", "Element");
        assertionTypes.add(elementVisible);
        
        Map<String, Object> elementEnabled = new HashMap<>();
        elementEnabled.put("id", "ELEMENT_ENABLED");
        elementEnabled.put("name", "Element Enabled");
        elementEnabled.put("description", "Assert that element is enabled");
        elementEnabled.put("category", "Element");
        assertionTypes.add(elementEnabled);
        
        Map<String, Object> elementSelected = new HashMap<>();
        elementSelected.put("id", "ELEMENT_SELECTED");
        elementSelected.put("name", "Element Selected");
        elementSelected.put("description", "Assert that element is selected");
        elementSelected.put("category", "Element");
        assertionTypes.add(elementSelected);
        
        Map<String, Object> elementTextEquals = new HashMap<>();
        elementTextEquals.put("id", "ELEMENT_TEXT_EQUALS");
        elementTextEquals.put("name", "Element Text Equals");
        elementTextEquals.put("description", "Assert that element text equals expected value");
        elementTextEquals.put("category", "Element");
        assertionTypes.add(elementTextEquals);
        
        Map<String, Object> elementTextContains = new HashMap<>();
        elementTextContains.put("id", "ELEMENT_TEXT_CONTAINS");
        elementTextContains.put("name", "Element Text Contains");
        elementTextContains.put("description", "Assert that element text contains expected value");
        elementTextContains.put("category", "Element");
        assertionTypes.add(elementTextContains);
        
        Map<String, Object> elementValueEquals = new HashMap<>();
        elementValueEquals.put("id", "ELEMENT_VALUE_EQUALS");
        elementValueEquals.put("name", "Element Value Equals");
        elementValueEquals.put("description", "Assert that element value equals expected value");
        elementValueEquals.put("category", "Element");
        assertionTypes.add(elementValueEquals);
        
        Map<String, Object> elementAttributeEquals = new HashMap<>();
        elementAttributeEquals.put("id", "ELEMENT_ATTRIBUTE_EQUALS");
        elementAttributeEquals.put("name", "Element Attribute Equals");
        elementAttributeEquals.put("description", "Assert that element attribute equals expected value");
        elementAttributeEquals.put("category", "Element");
        assertionTypes.add(elementAttributeEquals);
        
        Map<String, Object> elementCountEquals = new HashMap<>();
        elementCountEquals.put("id", "ELEMENT_COUNT_EQUALS");
        elementCountEquals.put("name", "Element Count Equals");
        elementCountEquals.put("description", "Assert that number of elements equals expected value");
        elementCountEquals.put("category", "Element");
        assertionTypes.add(elementCountEquals);
        
        // Value assertions
        Map<String, Object> valueEquals = new HashMap<>();
        valueEquals.put("id", "VALUE_EQUALS");
        valueEquals.put("name", "Value Equals");
        valueEquals.put("description", "Assert that value equals expected value");
        valueEquals.put("category", "Value");
        assertionTypes.add(valueEquals);
        
        Map<String, Object> valueNotEquals = new HashMap<>();
        valueNotEquals.put("id", "VALUE_NOT_EQUALS");
        valueNotEquals.put("name", "Value Not Equals");
        valueNotEquals.put("description", "Assert that value does not equal expected value");
        valueNotEquals.put("category", "Value");
        assertionTypes.add(valueNotEquals);
        
        Map<String, Object> valueGreaterThan = new HashMap<>();
        valueGreaterThan.put("id", "VALUE_GREATER_THAN");
        valueGreaterThan.put("name", "Value Greater Than");
        valueGreaterThan.put("description", "Assert that value is greater than expected value");
        valueGreaterThan.put("category", "Value");
        assertionTypes.add(valueGreaterThan);
        
        Map<String, Object> valueLessThan = new HashMap<>();
        valueLessThan.put("id", "VALUE_LESS_THAN");
        valueLessThan.put("name", "Value Less Than");
        valueLessThan.put("description", "Assert that value is less than expected value");
        valueLessThan.put("category", "Value");
        assertionTypes.add(valueLessThan);
        
        Map<String, Object> valueContains = new HashMap<>();
        valueContains.put("id", "VALUE_CONTAINS");
        valueContains.put("name", "Value Contains");
        valueContains.put("description", "Assert that value contains expected value");
        valueContains.put("category", "Value");
        assertionTypes.add(valueContains);
        
        Map<String, Object> valueMatches = new HashMap<>();
        valueMatches.put("id", "VALUE_MATCHES");
        valueMatches.put("name", "Value Matches");
        valueMatches.put("description", "Assert that value matches regular expression");
        valueMatches.put("category", "Value");
        assertionTypes.add(valueMatches);
        
        Map<String, Object> valueEmpty = new HashMap<>();
        valueEmpty.put("id", "VALUE_EMPTY");
        valueEmpty.put("name", "Value Empty");
        valueEmpty.put("description", "Assert that value is empty");
        valueEmpty.put("category", "Value");
        assertionTypes.add(valueEmpty);
        
        Map<String, Object> valueNotEmpty = new HashMap<>();
        valueNotEmpty.put("id", "VALUE_NOT_EMPTY");
        valueNotEmpty.put("name", "Value Not Empty");
        valueNotEmpty.put("description", "Assert that value is not empty");
        valueNotEmpty.put("category", "Value");
        assertionTypes.add(valueNotEmpty);
        
        Map<String, Object> valueNull = new HashMap<>();
        valueNull.put("id", "VALUE_NULL");
        valueNull.put("name", "Value Null");
        valueNull.put("description", "Assert that value is null");
        valueNull.put("category", "Value");
        assertionTypes.add(valueNull);
        
        Map<String, Object> valueNotNull = new HashMap<>();
        valueNotNull.put("id", "VALUE_NOT_NULL");
        valueNotNull.put("name", "Value Not Null");
        valueNotNull.put("description", "Assert that value is not null");
        valueNotNull.put("category", "Value");
        assertionTypes.add(valueNotNull);
        
        // Boolean assertions
        Map<String, Object> booleanTrue = new HashMap<>();
        booleanTrue.put("id", "BOOLEAN_TRUE");
        booleanTrue.put("name", "Boolean True");
        booleanTrue.put("description", "Assert that boolean value is true");
        booleanTrue.put("category", "Boolean");
        assertionTypes.add(booleanTrue);
        
        Map<String, Object> booleanFalse = new HashMap<>();
        booleanFalse.put("id", "BOOLEAN_FALSE");
        booleanFalse.put("name", "Boolean False");
        booleanFalse.put("description", "Assert that boolean value is false");
        booleanFalse.put("category", "Boolean");
        assertionTypes.add(booleanFalse);
        
        // Page assertions
        Map<String, Object> pageTitleEquals = new HashMap<>();
        pageTitleEquals.put("id", "PAGE_TITLE_EQUALS");
        pageTitleEquals.put("name", "Page Title Equals");
        pageTitleEquals.put("description", "Assert that page title equals expected value");
        pageTitleEquals.put("category", "Page");
        assertionTypes.add(pageTitleEquals);
        
        Map<String, Object> pageTitleContains = new HashMap<>();
        pageTitleContains.put("id", "PAGE_TITLE_CONTAINS");
        pageTitleContains.put("name", "Page Title Contains");
        pageTitleContains.put("description", "Assert that page title contains expected value");
        pageTitleContains.put("category", "Page");
        assertionTypes.add(pageTitleContains);
        
        Map<String, Object> pageUrlEquals = new HashMap<>();
        pageUrlEquals.put("id", "PAGE_URL_EQUALS");
        pageUrlEquals.put("name", "Page URL Equals");
        pageUrlEquals.put("description", "Assert that page URL equals expected value");
        pageUrlEquals.put("category", "Page");
        assertionTypes.add(pageUrlEquals);
        
        Map<String, Object> pageUrlContains = new HashMap<>();
        pageUrlContains.put("id", "PAGE_URL_CONTAINS");
        pageUrlContains.put("name", "Page URL Contains");
        pageUrlContains.put("description", "Assert that page URL contains expected value");
        pageUrlContains.put("category", "Page");
        assertionTypes.add(pageUrlContains);
        
        // Custom assertions
        Map<String, Object> custom = new HashMap<>();
        custom.put("id", "CUSTOM");
        custom.put("name", "Custom Assertion");
        custom.put("description", "Custom assertion with user-defined code");
        custom.put("category", "Custom");
        assertionTypes.add(custom);
        
        return assertionTypes;
    }
    
    @Override
    public List<Map<String, Object>> getWaitStrategies(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting wait strategies for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> waitStrategies = new ArrayList<>();
        
        // Element wait strategies
        Map<String, Object> elementVisible = new HashMap<>();
        elementVisible.put("id", "ELEMENT_VISIBLE");
        elementVisible.put("name", "Element Visible");
        elementVisible.put("description", "Wait for element to be visible");
        elementVisible.put("category", "Element");
        waitStrategies.add(elementVisible);
        
        Map<String, Object> elementClickable = new HashMap<>();
        elementClickable.put("id", "ELEMENT_CLICKABLE");
        elementClickable.put("name", "Element Clickable");
        elementClickable.put("description", "Wait for element to be clickable");
        elementClickable.put("category", "Element");
        waitStrategies.add(elementClickable);
        
        Map<String, Object> elementPresent = new HashMap<>();
        elementPresent.put("id", "ELEMENT_PRESENT");
        elementPresent.put("name", "Element Present");
        elementPresent.put("description", "Wait for element to be present in the DOM");
        elementPresent.put("category", "Element");
        waitStrategies.add(elementPresent);
        
        Map<String, Object> elementInvisible = new HashMap<>();
        elementInvisible.put("id", "ELEMENT_INVISIBLE");
        elementInvisible.put("name", "Element Invisible");
        elementInvisible.put("description", "Wait for element to be invisible");
        elementInvisible.put("category", "Element");
        waitStrategies.add(elementInvisible);
        
        Map<String, Object> elementSelected = new HashMap<>();
        elementSelected.put("id", "ELEMENT_SELECTED");
        elementSelected.put("name", "Element Selected");
        elementSelected.put("description", "Wait for element to be selected");
        elementSelected.put("category", "Element");
        waitStrategies.add(elementSelected);
        
        Map<String, Object> elementAttribute = new HashMap<>();
        elementAttribute.put("id", "ELEMENT_ATTRIBUTE");
        elementAttribute.put("name", "Element Attribute");
        elementAttribute.put("description", "Wait for element attribute to have a specific value");
        elementAttribute.put("category", "Element");
        waitStrategies.add(elementAttribute);
        
        Map<String, Object> elementText = new HashMap<>();
        elementText.put("id", "ELEMENT_TEXT");
        elementText.put("name", "Element Text");
        elementText.put("description", "Wait for element to have specific text");
        elementText.put("category", "Element");
        waitStrategies.add(elementText);
        
        // Time wait strategies
        Map<String, Object> fixedTime = new HashMap<>();
        fixedTime.put("id", "FIXED_TIME");
        fixedTime.put("name", "Fixed Time");
        fixedTime.put("description", "Wait for a fixed amount of time");
        fixedTime.put("category", "Time");
        waitStrategies.add(fixedTime);
        
        // Page wait strategies
        Map<String, Object> pageLoad = new HashMap<>();
        pageLoad.put("id", "PAGE_LOAD");
        pageLoad.put("name", "Page Load");
        pageLoad.put("description", "Wait for page to load");
        pageLoad.put("category", "Page");
        waitStrategies.add(pageLoad);
        
        // Script wait strategies
        Map<String, Object> script = new HashMap<>();
        script.put("id", "SCRIPT");
        script.put("name", "Script");
        script.put("description", "Wait for a script to complete");
        script.put("category", "Script");
        waitStrategies.add(script);
        
        // Custom wait strategies
        Map<String, Object> custom = new HashMap<>();
        custom.put("id", "CUSTOM");
        custom.put("name", "Custom");
        custom.put("description", "Custom wait condition");
        custom.put("category", "Custom");
        waitStrategies.add(custom);
        
        return waitStrategies;
    }
    
    @Override
    public Map<String, Object> executeJavaScript(String executionId, String script) {
        LOGGER.info("Executing JavaScript in test execution: {}", executionId);
        
        Map<String, Object> result = new HashMap<>();
        result.put("executionId", executionId);
        
        if (script == null || script.isEmpty()) {
            result.put("success", false);
            result.put("error", "Script is empty");
            return result;
        }
        
        try {
            ScriptEngine engine = scriptEngineManager.getEngineByName("JavaScript");
            if (engine == null) {
                result.put("success", false);
                result.put("error", "JavaScript engine not available");
                return result;
            }
            
            Object scriptResult = engine.eval(script);
            result.put("success", true);
            result.put("result", scriptResult);
            return result;
        } catch (ScriptException e) {
            LOGGER.error("Script execution error: {}", e.getMessage(), e);
            result.put("success", false);
            result.put("error", e.getMessage());
            result.put("lineNumber", e.getLineNumber());
            result.put("columnNumber", e.getColumnNumber());
            return result;
        } catch (Exception e) {
            LOGGER.error("Script execution error: {}", e.getMessage(), e);
            result.put("success", false);
            result.put("error", e.getMessage());
            return result;
        }
    }
    
    @Override
    public List<Map<String, Object>> getDataProviderTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting data provider types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> dataProviderTypes = new ArrayList<>();
        
        // Excel data provider
        Map<String, Object> excel = new HashMap<>();
        excel.put("id", "EXCEL");
        excel.put("name", "Excel");
        excel.put("description", "Excel data provider");
        excel.put("fileExtensions", Arrays.asList("xlsx", "xls"));
        dataProviderTypes.add(excel);
        
        // CSV data provider
        Map<String, Object> csv = new HashMap<>();
        csv.put("id", "CSV");
        csv.put("name", "CSV");
        csv.put("description", "CSV data provider");
        csv.put("fileExtensions", Arrays.asList("csv"));
        dataProviderTypes.add(csv);
        
        // JSON data provider
        Map<String, Object> json = new HashMap<>();
        json.put("id", "JSON");
        json.put("name", "JSON");
        json.put("description", "JSON data provider");
        json.put("fileExtensions", Arrays.asList("json"));
        dataProviderTypes.add(json);
        
        // Database data provider
        Map<String, Object> database = new HashMap<>();
        database.put("id", "DATABASE");
        database.put("name", "Database");
        database.put("description", "Database data provider");
        database.put("fileExtensions", Collections.emptyList());
        dataProviderTypes.add(database);
        
        return dataProviderTypes;
    }
    
    @Override
    public List<Map<String, Object>> previewDataProvider(DataProviderActionConfig dataProviderConfig) {
        LOGGER.info("Previewing data provider: {}", dataProviderConfig.getDataSourceType());
        
        if (dataProviderConfig == null || dataProviderConfig.getDataSourceType() == null) {
            LOGGER.error("Data provider configuration is null or invalid");
            return Collections.emptyList();
        }
        
        String dataSourceType = dataProviderConfig.getDataSourceType();
        String dataSourcePath = dataProviderConfig.getDataSourcePath();
        
        if (dataSourcePath == null || dataSourcePath.isEmpty()) {
            LOGGER.error("Data source path is empty");
            return Collections.emptyList();
        }
        
        try {
            // Use appropriate data source based on type
            if (dataSourceType.equals("EXCEL")) {
                String sheetName = dataProviderConfig.getSheetName();
                Boolean headers = dataProviderConfig.getHeaders();
                
                if (sheetName == null || sheetName.isEmpty()) {
                    LOGGER.error("Sheet name is required for Excel data source");
                    return Collections.emptyList();
                }
                
                // Create data source using the framework's data source factory
                return loadExcelData(dataSourcePath, sheetName, headers != null ? headers : true);
            } else if (dataSourceType.equals("CSV")) {
                String delimiter = dataProviderConfig.getDelimiter();
                Boolean headers = dataProviderConfig.getHeaders();
                
                // Create data source using the framework's data source factory
                return loadCsvData(dataSourcePath, delimiter, headers != null ? headers : true);
            } else if (dataSourceType.equals("JSON")) {
                // Create data source using the framework's data source factory
                return loadJsonData(dataSourcePath);
            } else if (dataSourceType.equals("DATABASE")) {
                String query = dataProviderConfig.getProperty("query") != null ? 
                        (String) dataProviderConfig.getProperty("query") : "";
                String connectionString = dataProviderConfig.getProperty("connectionString") != null ? 
                        (String) dataProviderConfig.getProperty("connectionString") : "";
                
                if (query == null || query.isEmpty()) {
                    LOGGER.error("Query is required for database data source");
                    return Collections.emptyList();
                }
                
                if (connectionString == null || connectionString.isEmpty()) {
                    LOGGER.error("Connection string is required for database data source");
                    return Collections.emptyList();
                }
                
                // Create data source using the framework's data source factory
                return loadDatabaseData(connectionString, query);
            } else {
                LOGGER.error("Unsupported data source type: {}", dataSourceType);
                return Collections.emptyList();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to preview data provider: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Load Excel data.
     */
    private List<Map<String, Object>> loadExcelData(String filePath, String sheetName, boolean hasHeaders) {
        List<Map<String, Object>> data = new ArrayList<>();
        
        try {
            Path path = Paths.get(filePath);
            if (!Files.exists(path)) {
                LOGGER.error("Excel file not found: {}", filePath);
                return Collections.emptyList();
            }
            
            // Use Apache POI to read Excel file
            try (FileInputStream file = new FileInputStream(filePath)) {
                org.apache.poi.ss.usermodel.Workbook workbook;
                if (filePath.toLowerCase().endsWith(".xlsx")) {
                    workbook = new org.apache.poi.xssf.usermodel.XSSFWorkbook(file);
                } else {
                    workbook = new org.apache.poi.hssf.usermodel.HSSFWorkbook(file);
                }
                
                org.apache.poi.ss.usermodel.Sheet sheet = workbook.getSheet(sheetName);
                if (sheet == null) {
                    LOGGER.error("Sheet not found: {}", sheetName);
                    workbook.close();
                    return Collections.emptyList();
                }
                
                List<String> headers = new ArrayList<>();
                org.apache.poi.ss.usermodel.Row headerRow = sheet.getRow(0);
                
                if (hasHeaders && headerRow != null) {
                    for (int i = 0; i < headerRow.getLastCellNum(); i++) {
                        org.apache.poi.ss.usermodel.Cell cell = headerRow.getCell(i);
                        if (cell != null) {
                            headers.add(cell.toString().trim());
                        } else {
                            headers.add("Column" + (i + 1));
                        }
                    }
                } else {
                    // Create column names if no headers
                    for (int i = 0; i < (headerRow != null ? headerRow.getLastCellNum() : 10); i++) {
                        headers.add("Column" + (i + 1));
                    }
                }
                
                int startRow = hasHeaders ? 1 : 0;
                for (int i = startRow; i <= sheet.getLastRowNum(); i++) {
                    org.apache.poi.ss.usermodel.Row row = sheet.getRow(i);
                    if (row == null) {
                        continue;
                    }
                    
                    Map<String, Object> rowData = new HashMap<>();
                    boolean hasData = false;
                    
                    for (int j = 0; j < Math.min(headers.size(), row.getLastCellNum()); j++) {
                        org.apache.poi.ss.usermodel.Cell cell = row.getCell(j);
                        String header = headers.get(j);
                        Object value = null;
                        
                        if (cell != null) {
                            switch (cell.getCellType()) {
                                case org.apache.poi.ss.usermodel.CellType.STRING:
                                    value = cell.getStringCellValue();
                                    break;
                                case org.apache.poi.ss.usermodel.CellType.NUMERIC:
                                    if (org.apache.poi.ss.usermodel.DateUtil.isCellDateFormatted(cell)) {
                                        value = cell.getDateCellValue();
                                    } else {
                                        value = cell.getNumericCellValue();
                                    }
                                    break;
                                case org.apache.poi.ss.usermodel.CellType.BOOLEAN:
                                    value = cell.getBooleanCellValue();
                                    break;
                                case org.apache.poi.ss.usermodel.CellType.FORMULA:
                                    value = cell.getCellFormula();
                                    break;
                                default:
                                    value = "";
                            }
                            
                            if (value != null && !value.toString().isEmpty()) {
                                hasData = true;
                            }
                        }
                        
                        rowData.put(header, value);
                    }
                    
                    if (hasData) {
                        data.add(rowData);
                    }
                }
                
                workbook.close();
            }
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error loading Excel data: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Load CSV data.
     */
    private List<Map<String, Object>> loadCsvData(String filePath, String delimiter, boolean hasHeaders) {
        List<Map<String, Object>> data = new ArrayList<>();
        
        try {
            Path path = Paths.get(filePath);
            if (!Files.exists(path)) {
                LOGGER.error("CSV file not found: {}", filePath);
                return Collections.emptyList();
            }
            
            if (delimiter == null || delimiter.isEmpty()) {
                delimiter = ",";
            }
            
            List<String> lines = Files.readAllLines(path);
            if (lines.isEmpty()) {
                return data;
            }
            
            String[] headerArray;
            int startRow = 0;
            
            if (hasHeaders) {
                headerArray = lines.get(0).split(delimiter, -1);
                startRow = 1;
            } else {
                // Create column names if no headers
                String[] firstRow = lines.get(0).split(delimiter, -1);
                headerArray = new String[firstRow.length];
                for (int i = 0; i < firstRow.length; i++) {
                    headerArray[i] = "Column" + (i + 1);
                }
            }
            
            for (int i = startRow; i < lines.size(); i++) {
                String line = lines.get(i);
                if (line.trim().isEmpty()) {
                    continue;
                }
                
                String[] values = line.split(delimiter, -1);
                Map<String, Object> rowData = new HashMap<>();
                boolean hasData = false;
                
                for (int j = 0; j < Math.min(headerArray.length, values.length); j++) {
                    String header = headerArray[j];
                    String value = values[j].trim();
                    
                    // Try to convert to appropriate data type
                    Object convertedValue;
                    if (value.isEmpty()) {
                        convertedValue = "";
                    } else if (value.matches("^-?\\d+$")) {
                        convertedValue = Integer.parseInt(value);
                    } else if (value.matches("^-?\\d+\\.\\d+$")) {
                        convertedValue = Double.parseDouble(value);
                    } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) {
                        convertedValue = Boolean.parseBoolean(value);
                    } else {
                        convertedValue = value;
                    }
                    
                    rowData.put(header, convertedValue);
                    
                    if (!value.isEmpty()) {
                        hasData = true;
                    }
                }
                
                if (hasData) {
                    data.add(rowData);
                }
            }
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error loading CSV data: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Load JSON data.
     */
    private List<Map<String, Object>> loadJsonData(String filePath) {
        List<Map<String, Object>> data = new ArrayList<>();
        
        try {
            Path path = Paths.get(filePath);
            if (!Files.exists(path)) {
                LOGGER.error("JSON file not found: {}", filePath);
                return Collections.emptyList();
            }
            
            String content = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);
            
            // Parse JSON using Jackson
            com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
            
            // Check if the JSON is an array or object
            com.fasterxml.jackson.databind.JsonNode rootNode = mapper.readTree(content);
            
            if (rootNode.isArray()) {
                // If it's an array, process each element
                for (com.fasterxml.jackson.databind.JsonNode node : rootNode) {
                    if (node.isObject()) {
                        Map<String, Object> rowData = mapper.convertValue(node, Map.class);
                        data.add(rowData);
                    }
                }
            } else if (rootNode.isObject()) {
                // If it's a single object, add it as one row
                Map<String, Object> rowData = mapper.convertValue(rootNode, Map.class);
                data.add(rowData);
            }
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error loading JSON data: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Load database data.
     */
    private List<Map<String, Object>> loadDatabaseData(String connectionString, String query) {
        List<Map<String, Object>> data = new ArrayList<>();
        
        try {
            // Use database connection to execute query
            Class.forName("org.postgresql.Driver");
            
            try (java.sql.Connection conn = java.sql.DriverManager.getConnection(connectionString);
                 java.sql.Statement stmt = conn.createStatement();
                 java.sql.ResultSet rs = stmt.executeQuery(query)) {
                
                java.sql.ResultSetMetaData metaData = rs.getMetaData();
                int columnCount = metaData.getColumnCount();
                
                // Get column names
                List<String> columnNames = new ArrayList<>();
                for (int i = 1; i <= columnCount; i++) {
                    columnNames.add(metaData.getColumnName(i));
                }
                
                // Process results
                while (rs.next()) {
                    Map<String, Object> row = new HashMap<>();
                    for (int i = 1; i <= columnCount; i++) {
                        String columnName = metaData.getColumnName(i);
                        Object value = rs.getObject(i);
                        row.put(columnName, value);
                    }
                    data.add(row);
                }
            }
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error loading database data: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    @Override
    public List<Map<String, Object>> getConditionalOperators(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting conditional operators for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> operators = new ArrayList<>();
        
        // Equality operators
        Map<String, Object> equals = new HashMap<>();
        equals.put("id", "EQUALS");
        equals.put("name", "Equals");
        equals.put("description", "Equality comparison");
        equals.put("symbol", "==");
        equals.put("category", "Equality");
        operators.add(equals);
        
        Map<String, Object> notEquals = new HashMap<>();
        notEquals.put("id", "NOT_EQUALS");
        notEquals.put("name", "Not Equals");
        notEquals.put("description", "Inequality comparison");
        notEquals.put("symbol", "!=");
        notEquals.put("category", "Equality");
        operators.add(notEquals);
        
        // Comparison operators
        Map<String, Object> greaterThan = new HashMap<>();
        greaterThan.put("id", "GREATER_THAN");
        greaterThan.put("name", "Greater Than");
        greaterThan.put("description", "Greater than comparison");
        greaterThan.put("symbol", ">");
        greaterThan.put("category", "Comparison");
        operators.add(greaterThan);
        
        Map<String, Object> lessThan = new HashMap<>();
        lessThan.put("id", "LESS_THAN");
        lessThan.put("name", "Less Than");
        lessThan.put("description", "Less than comparison");
        lessThan.put("symbol", "<");
        lessThan.put("category", "Comparison");
        operators.add(lessThan);
        
        Map<String, Object> greaterThanOrEquals = new HashMap<>();
        greaterThanOrEquals.put("id", "GREATER_THAN_OR_EQUALS");
        greaterThanOrEquals.put("name", "Greater Than or Equals");
        greaterThanOrEquals.put("description", "Greater than or equals comparison");
        greaterThanOrEquals.put("symbol", ">=");
        greaterThanOrEquals.put("category", "Comparison");
        operators.add(greaterThanOrEquals);
        
        Map<String, Object> lessThanOrEquals = new HashMap<>();
        lessThanOrEquals.put("id", "LESS_THAN_OR_EQUALS");
        lessThanOrEquals.put("name", "Less Than or Equals");
        lessThanOrEquals.put("description", "Less than or equals comparison");
        lessThanOrEquals.put("symbol", "<=");
        lessThanOrEquals.put("category", "Comparison");
        operators.add(lessThanOrEquals);
        
        // String operators
        Map<String, Object> contains = new HashMap<>();
        contains.put("id", "CONTAINS");
        contains.put("name", "Contains");
        contains.put("description", "String contains substring");
        contains.put("symbol", "contains");
        contains.put("category", "String");
        operators.add(contains);
        
        Map<String, Object> startsWith = new HashMap<>();
        startsWith.put("id", "STARTS_WITH");
        startsWith.put("name", "Starts With");
        startsWith.put("description", "String starts with substring");
        startsWith.put("symbol", "startsWith");
        startsWith.put("category", "String");
        operators.add(startsWith);
        
        Map<String, Object> endsWith = new HashMap<>();
        endsWith.put("id", "ENDS_WITH");
        endsWith.put("name", "Ends With");
        endsWith.put("description", "String ends with substring");
        endsWith.put("symbol", "endsWith");
        endsWith.put("category", "String");
        operators.add(endsWith);
        
        Map<String, Object> matches = new HashMap<>();
        matches.put("id", "MATCHES");
        matches.put("name", "Matches");
        matches.put("description", "String matches regular expression");
        matches.put("symbol", "matches");
        matches.put("category", "String");
        operators.add(matches);
        
        // Logical operators
        Map<String, Object> and = new HashMap<>();
        and.put("id", "AND");
        and.put("name", "And");
        and.put("description", "Logical AND");
        and.put("symbol", "&&");
        and.put("category", "Logical");
        operators.add(and);
        
        Map<String, Object> or = new HashMap<>();
        or.put("id", "OR");
        or.put("name", "Or");
        or.put("description", "Logical OR");
        or.put("symbol", "||");
        or.put("category", "Logical");
        operators.add(or);
        
        Map<String, Object> not = new HashMap<>();
        not.put("id", "NOT");
        not.put("name", "Not");
        not.put("description", "Logical NOT");
        not.put("symbol", "!");
        not.put("category", "Logical");
        operators.add(not);
        
        return operators;
    }
    
    @Override
    public List<Map<String, Object>> getLoopTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting loop types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> loopTypes = new ArrayList<>();
        
        // Times loop
        Map<String, Object> times = new HashMap<>();
        times.put("id", "TIMES");
        times.put("name", "Times");
        times.put("description", "Repeat a specific number of times");
        times.put("category", "Basic");
        loopTypes.add(times);
        
        // ForEach loop
        Map<String, Object> forEach = new HashMap<>();
        forEach.put("id", "FOREACH");
        forEach.put("name", "ForEach");
        forEach.put("description", "Iterate over a collection of items");
        forEach.put("category", "Collection");
        loopTypes.add(forEach);
        
        // For loop
        Map<String, Object> forLoop = new HashMap<>();
        forLoop.put("id", "FOR");
        forLoop.put("name", "For");
        forLoop.put("description", "Traditional for loop with initialization, condition, and increment");
        forLoop.put("category", "Advanced");
        loopTypes.add(forLoop);
        
        // While loop
        Map<String, Object> whileLoop = new HashMap<>();
        whileLoop.put("id", "WHILE");
        whileLoop.put("name", "While");
        whileLoop.put("description", "Repeat as long as a condition is true");
        whileLoop.put("category", "Conditional");
        loopTypes.add(whileLoop);
        
        return loopTypes;
    }
}


ActionConfig.java
------------------------------

package com.cstestforge.model.action;

import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Base class for action configurations.
 * This class provides common properties and methods for all action types.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "configType")
@JsonSubTypes({
    @JsonSubTypes.Type(value = AssertionActionConfig.class, name = "ASSERTION"),
    @JsonSubTypes.Type(value = ConditionalActionConfig.class, name = "CONDITIONAL"),
    @JsonSubTypes.Type(value = CustomActionConfig.class, name = "CUSTOM"),
    @JsonSubTypes.Type(value = DataProviderActionConfig.class, name = "DATA_PROVIDER"),
    @JsonSubTypes.Type(value = LoopActionConfig.class, name = "LOOP"),
    @JsonSubTypes.Type(value = WaitActionConfig.class, name = "WAIT")
})
public class ActionConfig {
    
    private String id;
    private ActionType actionType;
    private String name;
    private String description;
    private Boolean enabled;
    private Map<String, Object> properties;
    
    // Template metadata
    private String templateName;
    private String templateDescription;
    private FrameworkType frameworkType;
    private LanguageType languageType;
    private TestType testType;
    private LocalDateTime templateCreationTime;
    
    /**
     * Default constructor.
     */
    public ActionConfig() {
        this.properties = new HashMap<>();
        this.enabled = true;
    }
    
    /**
     * Constructor with action type.
     *
     * @param actionType Action type
     */
    public ActionConfig(ActionType actionType) {
        this();
        this.actionType = actionType;
    }
    
    /**
     * Get ID.
     *
     * @return ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Set ID.
     *
     * @param id ID
     */
    public void setId(String id) {
        this.id = id;
    }
    
    /**
     * Get action type.
     *
     * @return Action type
     */
    public ActionType getActionType() {
        return actionType;
    }
    
    /**
     * Set action type.
     *
     * @param actionType Action type
     */
    public void setActionType(ActionType actionType) {
        this.actionType = actionType;
    }
    
    /**
     * Get name.
     *
     * @return Name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Set name.
     *
     * @param name Name
     */
    public void setName(String name) {
        this.name = name;
    }
    
    /**
     * Get description.
     *
     * @return Description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Set description.
     *
     * @param description Description
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * Get enabled flag.
     *
     * @return Enabled flag
     */
    public Boolean isEnabled() {
        return enabled;
    }
    
    /**
     * Set enabled flag.
     *
     * @param enabled Enabled flag
     */
    public void setEnabled(Boolean enabled) {
        this.enabled = enabled;
    }
    
    /**
     * Get properties.
     *
     * @return Properties
     */
    public Map<String, Object> getProperties() {
        return properties;
    }
    
    /**
     * Set properties.
     *
     * @param properties Properties
     */
    public void setProperties(Map<String, Object> properties) {
        this.properties = properties;
    }
    
    /**
     * Get a property value.
     *
     * @param key Property key
     * @return Property value
     */
    public Object getProperty(String key) {
        return properties.get(key);
    }
    
    /**
     * Get a property value with a default value.
     *
     * @param key Property key
     * @param defaultValue Default value
     * @return Property value or default value if not found
     */
    public Object getProperty(String key, Object defaultValue) {
        return properties.getOrDefault(key, defaultValue);
    }
    
    /**
     * Set a property value.
     *
     * @param key Property key
     * @param value Property value
     */
    public void setProperty(String key, Object value) {
        properties.put(key, value);
    }
    
    /**
     * Remove a property.
     *
     * @param key Property key
     * @return The removed property value, or null if the key doesn't exist
     */
    public Object removeProperty(String key) {
        return properties.remove(key);
    }
    
    /**
     * Check if a property exists.
     *
     * @param key Property key
     * @return true if the property exists, false otherwise
     */
    public boolean hasProperty(String key) {
        return properties.containsKey(key);
    }
    
    /**
     * Get template name.
     *
     * @return Template name
     */
    public String getTemplateName() {
        return templateName;
    }
    
    /**
     * Set template name.
     *
     * @param templateName Template name
     */
    public void setTemplateName(String templateName) {
        this.templateName = templateName;
    }
    
    /**
     * Get template description.
     *
     * @return Template description
     */
    public String getTemplateDescription() {
        return templateDescription;
    }
    
    /**
     * Set template description.
     *
     * @param templateDescription Template description
     */
    public void setTemplateDescription(String templateDescription) {
        this.templateDescription = templateDescription;
    }
    
    /**
     * Get framework type.
     *
     * @return Framework type
     */
    public FrameworkType getFrameworkType() {
        return frameworkType;
    }
    
    /**
     * Set framework type.
     *
     * @param frameworkType Framework type
     */
    public void setFrameworkType(FrameworkType frameworkType) {
        this.frameworkType = frameworkType;
    }
    
    /**
     * Get language type.
     *
     * @return Language type
     */
    public LanguageType getLanguageType() {
        return languageType;
    }
    
    /**
     * Set language type.
     *
     * @param languageType Language type
     */
    public void setLanguageType(LanguageType languageType) {
        this.languageType = languageType;
    }
    
    /**
     * Get test type.
     *
     * @return Test type
     */
    public TestType getTestType() {
        return testType;
    }
    
    /**
     * Set test type.
     *
     * @param testType Test type
     */
    public void setTestType(TestType testType) {
        this.testType = testType;
    }
    
    /**
     * Get template creation time.
     *
     * @return Template creation time
     */
    public LocalDateTime getTemplateCreationTime() {
        return templateCreationTime;
    }
    
    /**
     * Set template creation time.
     *
     * @param templateCreationTime Template creation time
     */
    public void setTemplateCreationTime(LocalDateTime templateCreationTime) {
        this.templateCreationTime = templateCreationTime;
    }
}


AssertionActionConfig.java
------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

/**
 * Configuration for assertion actions.
 * This class provides specific properties for assertion actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class AssertionActionConfig extends ActionConfig {
    
    private String assertionType;
    private String locator;
    private String locatorType;
    private String expectedValue;
    private String actualValue;
    private Integer timeout;
    private Boolean failOnAssertionError;
    
    /**
     * Default constructor.
     */
    public AssertionActionConfig() {
        super(ActionType.ASSERT);
    }
    
    /**
     * Get assertion type.
     *
     * @return Assertion type
     */
    public String getAssertionType() {
        return assertionType;
    }
    
    /**
     * Set assertion type.
     *
     * @param assertionType Assertion type
     */
    public void setAssertionType(String assertionType) {
        this.assertionType = assertionType;
    }
    
    /**
     * Get locator.
     *
     * @return Locator
     */
    public String getLocator() {
        return locator;
    }
    
    /**
     * Set locator.
     *
     * @param locator Locator
     */
    public void setLocator(String locator) {
        this.locator = locator;
    }
    
    /**
     * Get locator type.
     *
     * @return Locator type
     */
    public String getLocatorType() {
        return locatorType;
    }
    
    /**
     * Set locator type.
     *
     * @param locatorType Locator type
     */
    public void setLocatorType(String locatorType) {
        this.locatorType = locatorType;
    }
    
    /**
     * Get expected value.
     *
     * @return Expected value
     */
    public String getExpectedValue() {
        return expectedValue;
    }
    
    /**
     * Set expected value.
     *
     * @param expectedValue Expected value
     */
    public void setExpectedValue(String expectedValue) {
        this.expectedValue = expectedValue;
    }
    
    /**
     * Get actual value.
     *
     * @return Actual value
     */
    public String getActualValue() {
        return actualValue;
    }
    
    /**
     * Set actual value.
     *
     * @param actualValue Actual value
     */
    public void setActualValue(String actualValue) {
        this.actualValue = actualValue;
    }
    
    /**
     * Get timeout.
     *
     * @return Timeout
     */
    public Integer getTimeout() {
        return timeout;
    }
    
    /**
     * Set timeout.
     *
     * @param timeout Timeout
     */
    public void setTimeout(Integer timeout) {
        this.timeout = timeout;
    }
    
    /**
     * Get fail on assertion error flag.
     *
     * @return Fail on assertion error flag
     */
    public Boolean isFailOnAssertionError() {
        return failOnAssertionError;
    }
    
    /**
     * Set fail on assertion error flag.
     *
     * @param failOnAssertionError Fail on assertion error flag
     */
    public void setFailOnAssertionError(Boolean failOnAssertionError) {
        this.failOnAssertionError = failOnAssertionError;
    }
}


ConditionalActionConfig.java
----------------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for conditional actions.
 * This class provides specific properties for conditional actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class ConditionalActionConfig extends ActionConfig {
    
    private String condition;
    private String operator;
    private String leftOperand;
    private String rightOperand;
    private List<ActionConfig> nestedActions;
    private List<ActionConfig> elseActions;
    
    /**
     * Default constructor.
     */
    public ConditionalActionConfig() {
        super(ActionType.CONDITIONAL);
        this.nestedActions = new ArrayList<>();
        this.elseActions = new ArrayList<>();
    }
    
    /**
     * Get condition.
     *
     * @return Condition
     */
    public String getCondition() {
        return condition;
    }
    
    /**
     * Set condition.
     *
     * @param condition Condition
     */
    public void setCondition(String condition) {
        this.condition = condition;
    }
    
    /**
     * Get operator.
     *
     * @return Operator
     */
    public String getOperator() {
        return operator;
    }
    
    /**
     * Set operator.
     *
     * @param operator Operator
     */
    public void setOperator(String operator) {
        this.operator = operator;
    }
    
    /**
     * Get left operand.
     *
     * @return Left operand
     */
    public String getLeftOperand() {
        return leftOperand;
    }
    
    /**
     * Set left operand.
     *
     * @param leftOperand Left operand
     */
    public void setLeftOperand(String leftOperand) {
        this.leftOperand = leftOperand;
    }
    
    /**
     * Get right operand.
     *
     * @return Right operand
     */
    public String getRightOperand() {
        return rightOperand;
    }
    
    /**
     * Set right operand.
     *
     * @param rightOperand Right operand
     */
    public void setRightOperand(String rightOperand) {
        this.rightOperand = rightOperand;
    }
    
    /**
     * Get nested actions.
     *
     * @return Nested actions
     */
    public List<ActionConfig> getNestedActions() {
        return nestedActions;
    }
    
    /**
     * Set nested actions.
     *
     * @param nestedActions Nested actions
     */
    public void setNestedActions(List<ActionConfig> nestedActions) {
        this.nestedActions = nestedActions;
    }
    
    /**
     * Add a nested action.
     *
     * @param nestedAction Nested action
     */
    public void addNestedAction(ActionConfig nestedAction) {
        if (this.nestedActions == null) {
            this.nestedActions = new ArrayList<>();
        }
        this.nestedActions.add(nestedAction);
    }
    
    /**
     * Get else actions.
     *
     * @return Else actions
     */
    public List<ActionConfig> getElseActions() {
        return elseActions;
    }
    
    /**
     * Set else actions.
     *
     * @param elseActions Else actions
     */
    public void setElseActions(List<ActionConfig> elseActions) {
        this.elseActions = elseActions;
    }
    
    /**
     * Add an else action.
     *
     * @param elseAction Else action
     */
    public void addElseAction(ActionConfig elseAction) {
        if (this.elseActions == null) {
            this.elseActions = new ArrayList<>();
        }
        this.elseActions.add(elseAction);
    }
}


CustomActionConfig.java
-------------------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Configuration for custom actions.
 * This class provides specific properties for custom actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class CustomActionConfig extends ActionConfig {
    
    private String scriptType;
    private String script;
    private List<Map<String, String>> parameters;
    
    /**
     * Default constructor.
     */
    public CustomActionConfig() {
        super(ActionType.CUSTOM);
        this.parameters = new ArrayList<>();
    }
    
    /**
     * Get script type.
     *
     * @return Script type
     */
    public String getScriptType() {
        return scriptType;
    }
    
    /**
     * Set script type.
     *
     * @param scriptType Script type
     */
    public void setScriptType(String scriptType) {
        this.scriptType = scriptType;
    }
    
    /**
     * Get script.
     *
     * @return Script
     */
    public String getScript() {
        return script;
    }
    
    /**
     * Set script.
     *
     * @param script Script
     */
    public void setScript(String script) {
        this.script = script;
    }
    
    /**
     * Get parameters.
     *
     * @return Parameters
     */
    public List<Map<String, String>> getParameters() {
        return parameters;
    }
    
    /**
     * Set parameters.
     *
     * @param parameters Parameters
     */
    public void setParameters(List<Map<String, String>> parameters) {
        this.parameters = parameters;
    }
    
    /**
     * Add a parameter.
     *
     * @param name Parameter name
     * @param value Parameter value
     */
    public void addParameter(String name, String value) {
        if (this.parameters == null) {
            this.parameters = new ArrayList<>();
        }
        Map<String, String> parameter = new HashMap<>();
        parameter.put("name", name);
        parameter.put("value", value);
        this.parameters.add(parameter);
    }
}


DataProviderActionConfig.java
--------------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for data provider actions.
 * This class provides specific properties for data provider actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class DataProviderActionConfig extends ActionConfig {
    
    private String dataSourceType;
    private String dataSourcePath;
    private String sheetName;
    private String delimiter;
    private Boolean headers;
    private List<String> parameters;
    private List<ActionConfig> iterationActions;
    
    /**
     * Default constructor.
     */
    public DataProviderActionConfig() {
        super(ActionType.DATA_PROVIDER);
        this.parameters = new ArrayList<>();
        this.iterationActions = new ArrayList<>();
    }
    
    /**
     * Get data source type.
     *
     * @return Data source type
     */
    public String getDataSourceType() {
        return dataSourceType;
    }
    
    /**
     * Set data source type.
     *
     * @param dataSourceType Data source type
     */
    public void setDataSourceType(String dataSourceType) {
        this.dataSourceType = dataSourceType;
    }
    
    /**
     * Get data source path.
     *
     * @return Data source path
     */
    public String getDataSourcePath() {
        return dataSourcePath;
    }
    
    /**
     * Set data source path.
     *
     * @param dataSourcePath Data source path
     */
    public void setDataSourcePath(String dataSourcePath) {
        this.dataSourcePath = dataSourcePath;
    }
    
    /**
     * Get sheet name.
     *
     * @return Sheet name
     */
    public String getSheetName() {
        return sheetName;
    }
    
    /**
     * Set sheet name.
     *
     * @param sheetName Sheet name
     */
    public void setSheetName(String sheetName) {
        this.sheetName = sheetName;
    }
    
    /**
     * Get delimiter.
     *
     * @return Delimiter
     */
    public String getDelimiter() {
        return delimiter;
    }
    
    /**
     * Set delimiter.
     *
     * @param delimiter Delimiter
     */
    public void setDelimiter(String delimiter) {
        this.delimiter = delimiter;
    }
    
    /**
     * Get headers flag.
     *
     * @return Headers flag
     */
    public Boolean getHeaders() {
        return headers;
    }
    
    /**
     * Set headers flag.
     *
     * @param headers Headers flag
     */
    public void setHeaders(Boolean headers) {
        this.headers = headers;
    }
    
    /**
     * Get parameters.
     *
     * @return Parameters
     */
    public List<String> getParameters() {
        return parameters;
    }
    
    /**
     * Set parameters.
     *
     * @param parameters Parameters
     */
    public void setParameters(List<String> parameters) {
        this.parameters = parameters;
    }
    
    /**
     * Add a parameter.
     *
     * @param parameter Parameter
     */
    public void addParameter(String parameter) {
        if (this.parameters == null) {
            this.parameters = new ArrayList<>();
        }
        this.parameters.add(parameter);
    }
    
    /**
     * Get iteration actions.
     *
     * @return Iteration actions
     */
    public List<ActionConfig> getIterationActions() {
        return iterationActions;
    }
    
    /**
     * Set iteration actions.
     *
     * @param iterationActions Iteration actions
     */
    public void setIterationActions(List<ActionConfig> iterationActions) {
        this.iterationActions = iterationActions;
    }
    
    /**
     * Add an iteration action.
     *
     * @param iterationAction Iteration action
     */
    public void addIterationAction(ActionConfig iterationAction) {
        if (this.iterationActions == null) {
            this.iterationActions = new ArrayList<>();
        }
        this.iterationActions.add(iterationAction);
    }
}


LoopActionConfig.java
----------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for loop actions.
 * This class provides specific properties for loop actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class LoopActionConfig extends ActionConfig {
    
    private String loopType;
    private Integer times;
    private String collection;
    private String variableName;
    private String initExpression;
    private String conditionExpression;
    private String incrementExpression;
    private List<ActionConfig> nestedActions;
    
    /**
     * Default constructor.
     */
    public LoopActionConfig() {
        super(ActionType.LOOP);
        this.nestedActions = new ArrayList<>();
    }
    
    /**
     * Get loop type.
     *
     * @return Loop type
     */
    public String getLoopType() {
        return loopType;
    }
    
    /**
     * Set loop type.
     *
     * @param loopType Loop type
     */
    public void setLoopType(String loopType) {
        this.loopType = loopType;
    }
    
    /**
     * Get times.
     *
     * @return Times
     */
    public Integer getTimes() {
        return times;
    }
    
    /**
     * Set times.
     *
     * @param times Times
     */
    public void setTimes(Integer times) {
        this.times = times;
    }
    
    /**
     * Get collection.
     *
     * @return Collection
     */
    public String getCollection() {
        return collection;
    }
    
    /**
     * Set collection.
     *
     * @param collection Collection
     */
    public void setCollection(String collection) {
        this.collection = collection;
    }
    
    /**
     * Get variable name.
     *
     * @return Variable name
     */
    public String getVariableName() {
        return variableName;
    }
    
    /**
     * Set variable name.
     *
     * @param variableName Variable name
     */
    public void setVariableName(String variableName) {
        this.variableName = variableName;
    }
    
    /**
     * Get initialization expression.
     *
     * @return Initialization expression
     */
    public String getInitExpression() {
        return initExpression;
    }
    
    /**
     * Set initialization expression.
     *
     * @param initExpression Initialization expression
     */
    public void setInitExpression(String initExpression) {
        this.initExpression = initExpression;
    }
    
    /**
     * Get condition expression.
     *
     * @return Condition expression
     */
    public String getConditionExpression() {
        return conditionExpression;
    }
    
    /**
     * Set condition expression.
     *
     * @param conditionExpression Condition expression
     */
    public void setConditionExpression(String conditionExpression) {
        this.conditionExpression = conditionExpression;
    }
    
    /**
     * Get increment expression.
     *
     * @return Increment expression
     */
    public String getIncrementExpression() {
        return incrementExpression;
    }
    
    /**
     * Set increment expression.
     *
     * @param incrementExpression Increment expression
     */
    public void setIncrementExpression(String incrementExpression) {
        this.incrementExpression = incrementExpression;
    }
    
    /**
     * Get nested actions.
     *
     * @return Nested actions
     */
    public List<ActionConfig> getNestedActions() {
        return nestedActions;
    }
    
    /**
     * Set nested actions.
     *
     * @param nestedActions Nested actions
     */
    public void setNestedActions(List<ActionConfig> nestedActions) {
        this.nestedActions = nestedActions;
    }
    
    /**
     * Add a nested action.
     *
     * @param nestedAction Nested action
     */
    public void addNestedAction(ActionConfig nestedAction) {
        if (this.nestedActions == null) {
            this.nestedActions = new ArrayList<>();
        }
        this.nestedActions.add(nestedAction);
    }
}


WaitActionConfig.java
----------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

/**
 * Configuration for wait actions.
 * This class provides specific properties for wait actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class WaitActionConfig extends ActionConfig {
    
    private String waitType;
    private String locator;
    private String locatorType;
    private Integer timeout;
    
    /**
     * Default constructor.
     */
    public WaitActionConfig() {
        super(ActionType.WAIT);
    }
    
    /**
     * Get wait type.
     *
     * @return Wait type
     */
    public String getWaitType() {
        return waitType;
    }
    
    /**
     * Set wait type.
     *
     * @param waitType Wait type
     */
    public void setWaitType(String waitType) {
        this.waitType = waitType;
    }
    
    /**
     * Get locator.
     *
     * @return Locator
     */
    public String getLocator() {
        return locator;
    }
    
    /**
     * Set locator.
     *
     * @param locator Locator
     */
    public void setLocator(String locator) {
        this.locator = locator;
    }
    
    /**
     * Get locator type.
     *
     * @return Locator type
     */
    public String getLocatorType() {
        return locatorType;
    }
    
    /**
     * Set locator type.
     *
     * @param locatorType Locator type
     */
    public void setLocatorType(String locatorType) {
        this.locatorType = locatorType;
    }
    
    /**
     * Get timeout.
     *
     * @return Timeout
     */
    public Integer getTimeout() {
        return timeout;
    }
    
    /**
     * Set timeout.
     *
     * @param timeout Timeout
     */
    public void setTimeout(Integer timeout) {
        this.timeout = timeout;
    }
}


FrameworkType.java
----------------------------------

package com.cstestforge.model.project;

/**
 * Enumeration of supported testing frameworks.
 */
public enum FrameworkType {
    /**
     * Selenium WebDriver framework.
     */
    SELENIUM,
    
    /**
     * Playwright framework.
     */
    PLAYWRIGHT
}


LanguageType.java
-------------------------------

package com.cstestforge.model.project;

/**
 * Enumeration of supported programming languages.
 */
public enum LanguageType {
    /**
     * Java programming language.
     */
    JAVA,
    
    /**
     * TypeScript programming language.
     */
    TYPESCRIPT
}


TestType.java
----------------------------

package com.cstestforge.model.project;

/**
 * Enumeration of supported testing approaches.
 */
public enum TestType {
    /**
     * TestNG-based testing approach.
     */
    TESTNG,
    
    /**
     * Behavior-Driven Development testing approach.
     */
    BDD
}



ActionType.java
----------------------

package com.cstestforge.model.action;

/**
 * Enumeration of supported action types in the CSTestForge framework.
 * Each action type represents a specific testing operation that can be performed.
 */
public enum ActionType {
    /**
     * Click on an element.
     */
    CLICK,
    
    /**
     * Type text into an input field.
     */
    TYPE,
    
    /**
     * Select an option from a dropdown.
     */
    SELECT,
    
    /**
     * Verify conditions or element states.
     */
    ASSERT,
    
    /**
     * Wait for a condition to be met.
     */
    WAIT,
    
    /**
     * Navigate to a URL.
     */
    NAVIGATE,
    
    /**
     * Execute actions conditionally.
     */
    CONDITIONAL,
    
    /**
     * Repeat actions multiple times.
     */
    LOOP,
    
    /**
     * Supply test data from external sources.
     */
    DATA_PROVIDER,
    
    /**
     * Execute custom code.
     */
    CUSTOM,
    
    /**
     * Define and manipulate variables.
     */
    VARIABLE,
    
    /**
     * Capture screenshot.
     */
    SCREENSHOT,
    
    /**
     * Mouse over an element.
     */
    HOVER,
    
    /**
     * Drag and drop elements.
     */
    DRAG_DROP,
    
    /**
     * Switch to a different frame or iframe.
     */
    SWITCH_FRAME,
    
    /**
     * Switch to a different window or tab.
     */
    SWITCH_WINDOW,
    
    /**
     * Execute JavaScript code.
     */
    EXECUTE_SCRIPT,
    
    /**
     * Upload a file.
     */
    FILE_UPLOAD,
    
    /**
     * Press keyboard keys.
     */
    KEY_PRESS,
    
    /**
     * Scroll the page or within an element.
     */
    SCROLL
}
