ActionService.java
-----------------------


package com.cstestforge.service.action;

import com.cstestforge.model.action.ActionConfig;
import com.cstestforge.model.action.ActionType;
import com.cstestforge.model.action.DataProviderActionConfig;
import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;

import java.util.List;
import java.util.Map;

/**
 * Service interface for action operations.
 * This service provides functionality for action configuration, validation, and code generation.
 */
public interface ActionService {
    
    /**
     * Get supported action types for a specific framework, language, and test type combination.
     *
     * @param frameworkType Framework type (Selenium, Playwright)
     * @param languageType Language type (Java, TypeScript)
     * @param testType Test type (TestNG, BDD)
     * @return List of supported action types
     */
    List<ActionType> getSupportedActionTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Get action configuration schema for a specific action type.
     *
     * @param actionType Action type
     * @return Schema as a map of property names to property definitions
     */
    Map<String, Object> getActionConfigSchema(ActionType actionType);
    
    /**
     * Validate an action configuration.
     *
     * @param actionConfig Action configuration to validate
     * @return List of validation errors, empty if validation passed
     */
    List<String> validateActionConfig(ActionConfig actionConfig);
    
    /**
     * Generate code for an action configuration.
     *
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return Generated code as a string
     */
    String generateActionCode(ActionConfig actionConfig, FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Get action templates for a specific action type, framework, language, and test type.
     *
     * @param actionType Action type
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of action templates
     */
    List<ActionConfig> getActionTemplates(ActionType actionType, FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Create an action template.
     *
     * @param actionConfig Action configuration to create as a template
     * @return Created action template
     */
    ActionConfig createActionTemplate(ActionConfig actionConfig);
    
    /**
     * Delete an action template.
     *
     * @param templateId ID of the template to delete
     * @return true if template was deleted, false otherwise
     */
    boolean deleteActionTemplate(String templateId);
    
    /**
     * Get available assertion types for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of assertion types with their metadata
     */
    List<Map<String, Object>> getAssertionTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Get available wait strategies for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of wait strategies with their metadata
     */
    List<Map<String, Object>> getWaitStrategies(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Execute JavaScript in a test execution context.
     *
     * @param executionId ID of the test execution
     * @param script JavaScript code to execute
     * @return Result of the execution
     */
    Map<String, Object> executeJavaScript(String executionId, String script);
    
    /**
     * Get available data provider types for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of data provider types with their metadata
     */
    List<Map<String, Object>> getDataProviderTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Preview data from a data provider configuration.
     *
     * @param dataProviderConfig Data provider configuration
     * @return Preview of the data as a list of rows
     */
    List<Map<String, Object>> previewDataProvider(DataProviderActionConfig dataProviderConfig);
    
    /**
     * Get supported conditional operators for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of conditional operators with their metadata
     */
    List<Map<String, Object>> getConditionalOperators(FrameworkType frameworkType, LanguageType languageType, TestType testType);
    
    /**
     * Get supported loop types for a specific framework, language, and test type.
     *
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return List of loop types with their metadata
     */
    List<Map<String, Object>> getLoopTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType);
}



ActionServiceImpl.java
--------------------------------

package com.cstestforge.service.action;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSTextUtils;
import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.model.action.ActionConfig;
import com.cstestforge.model.action.ActionType;
import com.cstestforge.model.action.AssertionActionConfig;
import com.cstestforge.model.action.ConditionalActionConfig;
import com.cstestforge.model.action.CustomActionConfig;
import com.cstestforge.model.action.DataProviderActionConfig;
import com.cstestforge.model.action.LoopActionConfig;
import com.cstestforge.model.action.WaitActionConfig;
import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;
import com.cstestforge.service.storage.FileSystemStorageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Implementation of the ActionService interface.
 * This class provides functionality for action operations.
 */
@Service
public class ActionServiceImpl implements ActionService {

    private static final CSLogger LOGGER = CSLogger.getLogger("com.cstestforge.service.action.ActionServiceImpl");
    
    private final FileSystemStorageService storageService;
    private final Map<String, ActionConfig> templateCache = new HashMap<>();
    private final ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
    
    // Directory for storing action templates
    private final String templatesDirectory;
    
    @Autowired
    public ActionServiceImpl(FileSystemStorageService storageService) {
        this.storageService = storageService;
        
        // Get templates directory from configuration or use default
        ConfigurationManager configManager = ConfigurationManager.getInstance();
        this.templatesDirectory = configManager.getStringConfig("framework.templates.directory", 
                System.getProperty("user.dir") + File.separator + "templates" + File.separator + "actions");
        
        // Ensure templates directory exists
        createTemplatesDirectory();
        
        // Load templates into cache
        loadTemplates();
    }
    
    /**
     * Create templates directory if it doesn't exist.
     */
    private void createTemplatesDirectory() {
        try {
            Path templatesPath = Paths.get(templatesDirectory);
            if (!Files.exists(templatesPath)) {
                Files.createDirectories(templatesPath);
                LOGGER.info("Created templates directory: {}", templatesDirectory);
            }
        } catch (IOException e) {
            LOGGER.error("Failed to create templates directory: {}", templatesDirectory, e);
        }
    }
    
    /**
     * Load templates into cache.
     */
    private void loadTemplates() {
        try {
            Path templatesPath = Paths.get(templatesDirectory);
            if (!Files.exists(templatesPath)) {
                return;
            }
            
            Files.walk(templatesPath)
                    .filter(path -> path.toString().endsWith(".json"))
                    .forEach(path -> {
                        try {
                            ActionConfig template = storageService.readObject(path.toFile(), ActionConfig.class);
                            if (template != null) {
                                templateCache.put(template.getId(), template);
                                LOGGER.debug("Loaded template: {}", template.getTemplateName());
                            }
                        } catch (Exception e) {
                            LOGGER.error("Failed to load template from {}: {}", path, e.getMessage());
                        }
                    });
            
            LOGGER.info("Loaded {} templates", templateCache.size());
        } catch (IOException e) {
            LOGGER.error("Failed to load templates", e);
        }
    }
    
    @Override
    public List<ActionType> getSupportedActionTypes(
            FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        
        LOGGER.debug("Getting supported action types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        // All action types are supported by default
        List<ActionType> actionTypes = new ArrayList<>(Arrays.asList(ActionType.values()));
        
        // Filter action types based on framework, language, and test type
        if (frameworkType != null) {
            if (frameworkType == FrameworkType.SELENIUM) {
                // Remove Playwright-specific action types
                // Currently, all action types are supported by both frameworks
            } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                // Remove Selenium-specific action types
                // Currently, all action types are supported by both frameworks
            }
        }
        
        if (languageType != null) {
            if (languageType == LanguageType.JAVA) {
                // Remove TypeScript-specific action types
                // Currently, all action types are supported by both languages
            } else if (languageType == LanguageType.TYPESCRIPT) {
                // Remove Java-specific action types
                // Currently, all action types are supported by both languages
            }
        }
        
        if (testType != null) {
            if (testType == TestType.TESTNG) {
                // Remove BDD-specific action types
                // Currently, all action types are supported by both test types
            } else if (testType == TestType.BDD) {
                // Remove TestNG-specific action types
                // Currently, all action types are supported by both test types
            }
        }
        
        return actionTypes;
    }
    
    @Override
    public Map<String, Object> getActionConfigSchema(ActionType actionType) {
        LOGGER.debug("Getting action schema for action type: {}", actionType);
        
        Map<String, Object> schema = new LinkedHashMap<>();
        
        // Common properties for all action types
        schema.put("id", Map.of("type", "string", "description", "Unique identifier for the action"));
        schema.put("actionType", Map.of("type", "enum", "enum", Arrays.stream(ActionType.values()).map(Enum::name).toArray(), "description", "Type of action"));
        schema.put("name", Map.of("type", "string", "description", "Display name for the action"));
        schema.put("description", Map.of("type", "string", "description", "Description of the action"));
        schema.put("enabled", Map.of("type", "boolean", "default", true, "description", "Whether the action is enabled"));
        
        // Action type specific properties
        switch (actionType) {
            case CLICK:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before clicking"));
                break;
                
            case TYPE:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("text", Map.of("type", "string", "description", "Text to type"));
                schema.put("clearBefore", Map.of("type", "boolean", "default", true, "description", "Whether to clear the field before typing"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before typing"));
                break;
                
            case SELECT:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("option", Map.of("type", "string", "description", "Option to select"));
                schema.put("selectBy", Map.of("type", "enum", "enum", new String[]{"TEXT", "VALUE", "INDEX"}, "description", "How to select the option"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before selecting"));
                break;
                
            case ASSERT:
                schema.put("assertionType", Map.of("type", "string", "description", "Type of assertion"));
                schema.put("locator", Map.of("type", "string", "description", "Element locator (if applicable)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (if applicable)"));
                schema.put("expectedValue", Map.of("type", "string", "description", "Expected value for the assertion"));
                schema.put("actualValue", Map.of("type", "string", "description", "Actual value for the assertion (variable or expression)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("failOnAssertionError", Map.of("type", "boolean", "default", true, "description", "Whether to fail the test on assertion error"));
                break;
                
            case WAIT:
                schema.put("waitType", Map.of("type", "string", "description", "Type of wait"));
                schema.put("locator", Map.of("type", "string", "description", "Element locator (if applicable)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (if applicable)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("condition", Map.of("type", "string", "description", "Condition to wait for (if applicable)"));
                schema.put("pollingInterval", Map.of("type", "integer", "default", 500, "description", "Polling interval in milliseconds"));
                break;
                
            case NAVIGATE:
                schema.put("url", Map.of("type", "string", "description", "URL to navigate to"));
                schema.put("waitForLoad", Map.of("type", "boolean", "default", true, "description", "Whether to wait for page load"));
                schema.put("timeout", Map.of("type", "integer", "default", 60, "description", "Timeout in seconds"));
                break;
                
            case CONDITIONAL:
                schema.put("condition", Map.of("type", "string", "description", "Condition expression"));
                schema.put("operator", Map.of("type", "string", "description", "Conditional operator"));
                schema.put("leftOperand", Map.of("type", "string", "description", "Left operand (variable, expression, or literal)"));
                schema.put("rightOperand", Map.of("type", "string", "description", "Right operand (variable, expression, or literal)"));
                schema.put("nestedActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute if condition is true"));
                schema.put("elseActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute if condition is false"));
                break;
                
            case LOOP:
                schema.put("loopType", Map.of("type", "string", "description", "Type of loop"));
                schema.put("times", Map.of("type", "integer", "description", "Number of times to loop (for 'times' loop type)"));
                schema.put("collection", Map.of("type", "string", "description", "Collection to iterate over (for 'foreach' loop type)"));
                schema.put("variableName", Map.of("type", "string", "description", "Variable name for loop item (for 'foreach' loop type)"));
                schema.put("initExpression", Map.of("type", "string", "description", "Initialization expression (for 'for' loop type)"));
                schema.put("conditionExpression", Map.of("type", "string", "description", "Condition expression (for 'for' and 'while' loop types)"));
                schema.put("incrementExpression", Map.of("type", "string", "description", "Increment expression (for 'for' loop type)"));
                schema.put("nestedActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute in the loop"));
                break;
                
            case DATA_PROVIDER:
                schema.put("dataSourceType", Map.of("type", "string", "description", "Type of data source"));
                schema.put("dataSourcePath", Map.of("type", "string", "description", "Path to the data source"));
                schema.put("sheetName", Map.of("type", "string", "description", "Sheet name (for Excel data source)"));
                schema.put("delimiter", Map.of("type", "string", "default", ",", "description", "Delimiter (for CSV data source)"));
                schema.put("headers", Map.of("type", "boolean", "default", true, "description", "Whether the data has headers"));
                schema.put("parameters", Map.of("type", "array", "items", Map.of("type", "string", "description", "Parameter name"), "description", "Parameter names for the data provider"));
                schema.put("iterationActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute for each data iteration"));
                break;
                
            case CUSTOM:
                schema.put("scriptType", Map.of("type", "string", "description", "Type of script"));
                schema.put("script", Map.of("type", "string", "description", "Script content"));
                schema.put("parameters", Map.of("type", "array", "items", Map.of("type", "object", "properties", Map.of(
                        "name", Map.of("type", "string", "description", "Parameter name"),
                        "value", Map.of("type", "string", "description", "Parameter value")
                )), "description", "Script parameters"));
                break;
                
            case VARIABLE:
                schema.put("variableName", Map.of("type", "string", "description", "Name of the variable"));
                schema.put("variableType", Map.of("type", "string", "description", "Type of the variable"));
                schema.put("value", Map.of("type", "string", "description", "Value of the variable"));
                schema.put("scope", Map.of("type", "string", "description", "Scope of the variable"));
                break;
                
            case SCREENSHOT:
                schema.put("fileName", Map.of("type", "string", "description", "Name of the screenshot file"));
                schema.put("element", Map.of("type", "string", "description", "Element locator (for element screenshot, optional)"));
                schema.put("fullPage", Map.of("type", "boolean", "default", false, "description", "Whether to capture full page"));
                schema.put("directory", Map.of("type", "string", "description", "Directory to save the screenshot (optional)"));
                break;
                
            case HOVER:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before hovering"));
                break;
                
            case DRAG_DROP:
                schema.put("sourceLocator", Map.of("type", "string", "description", "Source element locator"));
                schema.put("sourceLocatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of source locator"));
                schema.put("targetLocator", Map.of("type", "string", "description", "Target element locator"));
                schema.put("targetLocatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of target locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElements", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the elements before drag and drop"));
                break;
                
            case SWITCH_FRAME:
                schema.put("frameLocator", Map.of("type", "string", "description", "Frame locator"));
                schema.put("frameLocatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT", "INDEX"}, "description", "Type of frame locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("switchToDefault", Map.of("type", "boolean", "default", false, "description", "Whether to switch to default content instead of a specific frame"));
                schema.put("switchToParent", Map.of("type", "boolean", "default", false, "description", "Whether to switch to parent frame instead of a specific frame"));
                break;
                
            case SWITCH_WINDOW:
                schema.put("windowHandle", Map.of("type", "string", "description", "Window handle (optional)"));
                schema.put("windowIndex", Map.of("type", "integer", "description", "Window index (optional)"));
                schema.put("windowTitle", Map.of("type", "string", "description", "Window title (optional)"));
                schema.put("windowUrl", Map.of("type", "string", "description", "Window URL (optional)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                break;
                
            case EXECUTE_SCRIPT:
                schema.put("script", Map.of("type", "string", "description", "JavaScript code to execute"));
                schema.put("arguments", Map.of("type", "array", "items", Map.of("type", "string", "description", "Argument value"), "description", "Script arguments"));
                schema.put("resultVariable", Map.of("type", "string", "description", "Variable to store the result (optional)"));
                break;
                
            case FILE_UPLOAD:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("filePath", Map.of("type", "string", "description", "Path to the file to upload"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before uploading"));
                break;
                
            case KEY_PRESS:
                schema.put("locator", Map.of("type", "string", "description", "Element locator (optional)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (optional)"));
                schema.put("key", Map.of("type", "string", "description", "Key to press"));
                schema.put("modifiers", Map.of("type", "array", "items", Map.of("type", "string", "description", "Modifier key"), "description", "Modifier keys (optional)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                break;
                
            case SCROLL:
                schema.put("locator", Map.of("type", "string", "description", "Element locator (optional)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (optional)"));
                schema.put("x", Map.of("type", "integer", "description", "X coordinate (optional)"));
                schema.put("y", Map.of("type", "integer", "description", "Y coordinate (optional)"));
                schema.put("scrollType", Map.of("type", "enum", "enum", new String[]{"PIXEL", "ELEMENT", "TOP", "BOTTOM", "CENTER"}, "description", "Type of scroll"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                break;
                
            default:
                // Default schema with no additional properties
                break;
        }
        
        return schema;
    }
    
    @Override
    public List<String> validateActionConfig(ActionConfig actionConfig) {
        if (actionConfig == null) {
            return List.of("Action configuration is null");
        }
        
        List<String> errors = new ArrayList<>();
        
        // Validate common properties
        if (actionConfig.getActionType() == null) {
            errors.add("Action type is required");
        }
        
        // Validate action type specific properties
        switch (actionConfig.getActionType()) {
            case CLICK:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for click action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for click action");
                }
                break;
                
            case TYPE:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for type action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for type action");
                }
                if (actionConfig.getProperty("text") == null) {
                    errors.add("Text is required for type action");
                }
                break;
                
            case SELECT:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for select action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for select action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("option"))) {
                    errors.add("Option is required for select action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("selectBy"))) {
                    errors.add("Select by is required for select action");
                }
                break;
                
            case ASSERT:
                AssertionActionConfig assertionConfig = (AssertionActionConfig) actionConfig;
                if (CSTextUtils.isEmpty(assertionConfig.getAssertionType())) {
                    errors.add("Assertion type is required for assert action");
                }
                
                // Validate based on assertion type
                String assertionType = assertionConfig.getAssertionType();
                if (assertionType != null) {
                    if (assertionType.contains("ELEMENT")) {
                        if (CSTextUtils.isEmpty(assertionConfig.getLocator())) {
                            errors.add("Locator is required for element assertion");
                        }
                        if (CSTextUtils.isEmpty(assertionConfig.getLocatorType())) {
                            errors.add("Locator type is required for element assertion");
                        }
                    }
                    
                    if (assertionType.contains("EQUALS") || assertionType.contains("CONTAINS") || 
                            assertionType.contains("MATCHES")) {
                        if (assertionConfig.getExpectedValue() == null) {
                            errors.add("Expected value is required for comparison assertion");
                        }
                    }
                }
                break;
                
            case WAIT:
                WaitActionConfig waitConfig = (WaitActionConfig) actionConfig;
                if (CSTextUtils.isEmpty(waitConfig.getWaitType())) {
                    errors.add("Wait type is required for wait action");
                }
                
                // Validate based on wait type
                String waitType = waitConfig.getWaitType();
                if (waitType != null) {
                    if (waitType.contains("ELEMENT")) {
                        if (CSTextUtils.isEmpty(waitConfig.getLocator())) {
                            errors.add("Locator is required for element wait");
                        }
                        if (CSTextUtils.isEmpty(waitConfig.getLocatorType())) {
                            errors.add("Locator type is required for element wait");
                        }
                    }
                }
                break;
                
            case NAVIGATE:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("url"))) {
                    errors.add("URL is required for navigate action");
                }
                break;
                
            case CONDITIONAL:
                ConditionalActionConfig conditionalConfig = (ConditionalActionConfig) actionConfig;
                
                if (CSTextUtils.isEmpty(conditionalConfig.getCondition()) && 
                        (CSTextUtils.isEmpty(conditionalConfig.getOperator()) || 
                         conditionalConfig.getLeftOperand() == null || 
                         conditionalConfig.getRightOperand() == null)) {
                    errors.add("Either condition or operator with operands is required for conditional action");
                }
                
                if (conditionalConfig.getNestedActions() == null || conditionalConfig.getNestedActions().isEmpty()) {
                    errors.add("Nested actions are required for conditional action");
                }
                break;
                
            case LOOP:
                LoopActionConfig loopConfig = (LoopActionConfig) actionConfig;
                if (CSTextUtils.isEmpty(loopConfig.getLoopType())) {
                    errors.add("Loop type is required for loop action");
                }
                
                // Validate based on loop type
                String loopType = loopConfig.getLoopType();
                if (loopType != null) {
                    if (loopType.equals("TIMES")) {
                        if (loopConfig.getTimes() <= 0) {
                            errors.add("Times must be greater than 0 for times loop");
                        }
                    } else if (loopType.equals("FOREACH")) {
                        if (CSTextUtils.isEmpty(loopConfig.getCollection())) {
                            errors.add("Collection is required for foreach loop");
                        }
                        if (CSTextUtils.isEmpty(loopConfig.getVariableName())) {
                            errors.add("Variable name is required for foreach loop");
                        }
                    } else if (loopType.equals("FOR")) {
                        if (CSTextUtils.isEmpty(loopConfig.getInitExpression())) {
                            errors.add("Init expression is required for for loop");
                        }
                        if (CSTextUtils.isEmpty(loopConfig.getConditionExpression())) {
                            errors.add("Condition expression is required for for loop");
                        }
                        if (CSTextUtils.isEmpty(loopConfig.getIncrementExpression())) {
                            errors.add("Increment expression is required for for loop");
                        }
                    } else if (loopType.equals("WHILE")) {
                        if (CSTextUtils.isEmpty(loopConfig.getConditionExpression())) {
                            errors.add("Condition expression is required for while loop");
                        }
                    }
                }
                
                if (loopConfig.getNestedActions() == null || loopConfig.getNestedActions().isEmpty()) {
                    errors.add("Nested actions are required for loop action");
                }
                break;
                
            case DATA_PROVIDER:
                DataProviderActionConfig dataProviderConfig = (DataProviderActionConfig) actionConfig;
                if (CSTextUtils.isEmpty(dataProviderConfig.getDataSourceType())) {
                    errors.add("Data source type is required for data provider action");
                }
                if (CSTextUtils.isEmpty(dataProviderConfig.getDataSourcePath())) {
                    errors.add("Data source path is required for data provider action");
                }
                
                // Validate based on data source type
                String dataSourceType = dataProviderConfig.getDataSourceType();
                if (dataSourceType != null) {
                    if (dataSourceType.equals("EXCEL")) {
                        if (CSTextUtils.isEmpty(dataProviderConfig.getSheetName())) {
                            errors.add("Sheet name is required for Excel data source");
                        }
                    }
                }
                
                if (dataProviderConfig.getParameters() == null || dataProviderConfig.getParameters().isEmpty()) {
                    errors.add("Parameters are required for data provider action");
                }
                
                if (dataProviderConfig.getIterationActions() == null || dataProviderConfig.getIterationActions().isEmpty()) {
                    errors.add("Iteration actions are required for data provider action");
                }
                break;
                
            case CUSTOM:
                CustomActionConfig customConfig = (CustomActionConfig) actionConfig;
                if (CSTextUtils.isEmpty(customConfig.getScriptType())) {
                    errors.add("Script type is required for custom action");
                }
                if (CSTextUtils.isEmpty(customConfig.getScript())) {
                    errors.add("Script is required for custom action");
                }
                break;
                
            case VARIABLE:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("variableName"))) {
                    errors.add("Variable name is required for variable action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("variableType"))) {
                    errors.add("Variable type is required for variable action");
                }
                break;
                
            case HOVER:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for hover action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for hover action");
                }
                break;
                
            case DRAG_DROP:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("sourceLocator"))) {
                    errors.add("Source locator is required for drag and drop action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("sourceLocatorType"))) {
                    errors.add("Source locator type is required for drag and drop action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("targetLocator"))) {
                    errors.add("Target locator is required for drag and drop action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("targetLocatorType"))) {
                    errors.add("Target locator type is required for drag and drop action");
                }
                break;
                
            case SWITCH_FRAME:
                if (!Boolean.TRUE.equals(actionConfig.getProperty("switchToDefault")) && 
                        !Boolean.TRUE.equals(actionConfig.getProperty("switchToParent"))) {
                    if (CSTextUtils.isEmpty(actionConfig.getProperty("frameLocator"))) {
                        errors.add("Frame locator is required for switch frame action");
                    }
                    if (CSTextUtils.isEmpty(actionConfig.getProperty("frameLocatorType"))) {
                        errors.add("Frame locator type is required for switch frame action");
                    }
                }
                break;
                
            case SWITCH_WINDOW:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("windowHandle")) && 
                        actionConfig.getProperty("windowIndex") == null && 
                        CSTextUtils.isEmpty(actionConfig.getProperty("windowTitle")) && 
                        CSTextUtils.isEmpty(actionConfig.getProperty("windowUrl"))) {
                    errors.add("Window handle, index, title, or URL is required for switch window action");
                }
                break;
                
            case EXECUTE_SCRIPT:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("script"))) {
                    errors.add("Script is required for execute script action");
                }
                break;
                
            case FILE_UPLOAD:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for file upload action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for file upload action");
                }
                if (CSTextUtils.isEmpty(actionConfig.getProperty("filePath"))) {
                    errors.add("File path is required for file upload action");
                }
                break;
                
            case KEY_PRESS:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("key"))) {
                    errors.add("Key is required for key press action");
                }
                break;
                
            case SCROLL:
                if (CSTextUtils.isEmpty(actionConfig.getProperty("scrollType"))) {
                    errors.add("Scroll type is required for scroll action");
                }
                
                // Validate based on scroll type
                String scrollType = (String) actionConfig.getProperty("scrollType");
                if (scrollType != null) {
                    if (scrollType.equals("PIXEL")) {
                        if (actionConfig.getProperty("x") == null || actionConfig.getProperty("y") == null) {
                            errors.add("X and Y coordinates are required for pixel scroll");
                        }
                    } else if (scrollType.equals("ELEMENT")) {
                        if (CSTextUtils.isEmpty(actionConfig.getProperty("locator"))) {
                            errors.add("Locator is required for element scroll");
                        }
                        if (CSTextUtils.isEmpty(actionConfig.getProperty("locatorType"))) {
                            errors.add("Locator type is required for element scroll");
                        }
                    }
                }
                break;
                
            default:
                // No additional validation
                break;
        }
        
        return errors;
    }
    
    @Override
    public String generateActionCode(ActionConfig actionConfig, FrameworkType frameworkType, 
            LanguageType languageType, TestType testType) {
        
        if (actionConfig == null) {
            return "// Action configuration is null";
        }
        
        StringBuilder code = new StringBuilder();
        
        // Generate code based on framework, language, and test type
        if (languageType == LanguageType.JAVA) {
            generateJavaCode(code, actionConfig, frameworkType, testType);
        } else if (languageType == LanguageType.TYPESCRIPT) {
            generateTypeScriptCode(code, actionConfig, frameworkType, testType);
        } else {
            code.append("// Unsupported language type: ").append(languageType);
        }
        
        return code.toString();
    }
    
    /**
     * Generate Java code for an action configuration.
     *
     * @param code StringBuilder to append code to
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void generateJavaCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        ActionType actionType = actionConfig.getActionType();
        
        switch (actionType) {
            case CLICK:
                generateJavaClickCode(code, actionConfig, frameworkType, testType);
                break;
                
            case TYPE:
                generateJavaTypeCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SELECT:
                generateJavaSelectCode(code, actionConfig, frameworkType, testType);
                break;
                
            case ASSERT:
                generateJavaAssertCode(code, (AssertionActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case WAIT:
                generateJavaWaitCode(code, (WaitActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case NAVIGATE:
                generateJavaNavigateCode(code, actionConfig, frameworkType, testType);
                break;
                
            case CONDITIONAL:
                generateJavaConditionalCode(code, (ConditionalActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case LOOP:
                generateJavaLoopCode(code, (LoopActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case DATA_PROVIDER:
                generateJavaDataProviderCode(code, (DataProviderActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case CUSTOM:
                generateJavaCustomCode(code, (CustomActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case VARIABLE:
                generateJavaVariableCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCREENSHOT:
                generateJavaScreenshotCode(code, actionConfig, frameworkType, testType);
                break;
                
            case HOVER:
                generateJavaHoverCode(code, actionConfig, frameworkType, testType);
                break;
                
            case DRAG_DROP:
                generateJavaDragDropCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_FRAME:
                generateJavaSwitchFrameCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_WINDOW:
                generateJavaSwitchWindowCode(code, actionConfig, frameworkType, testType);
                break;
                
            case EXECUTE_SCRIPT:
                generateJavaExecuteScriptCode(code, actionConfig, frameworkType, testType);
                break;
                
            case FILE_UPLOAD:
                generateJavaFileUploadCode(code, actionConfig, frameworkType, testType);
                break;
                
            case KEY_PRESS:
                generateJavaKeyPressCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCROLL:
                generateJavaScrollCode(code, actionConfig, frameworkType, testType);
                break;
                
            default:
                code.append("// Unsupported action type: ").append(actionType);
                break;
        }
    }
    
    /**
     * Generate TypeScript code for an action configuration.
     *
     * @param code StringBuilder to append code to
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void generateTypeScriptCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        ActionType actionType = actionConfig.getActionType();
        
        switch (actionType) {
            case CLICK:
                generateTypeScriptClickCode(code, actionConfig, frameworkType, testType);
                break;
                
            case TYPE:
                generateTypeScriptTypeCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SELECT:
                generateTypeScriptSelectCode(code, actionConfig, frameworkType, testType);
                break;
                
            case ASSERT:
                generateTypeScriptAssertCode(code, (AssertionActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case WAIT:
                generateTypeScriptWaitCode(code, (WaitActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case NAVIGATE:
                generateTypeScriptNavigateCode(code, actionConfig, frameworkType, testType);
                break;
                
            case CONDITIONAL:
                generateTypeScriptConditionalCode(code, (ConditionalActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case LOOP:
                generateTypeScriptLoopCode(code, (LoopActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case DATA_PROVIDER:
                generateTypeScriptDataProviderCode(code, (DataProviderActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case CUSTOM:
                generateTypeScriptCustomCode(code, (CustomActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case VARIABLE:
                generateTypeScriptVariableCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCREENSHOT:
                generateTypeScriptScreenshotCode(code, actionConfig, frameworkType, testType);
                break;
                
            case HOVER:
                generateTypeScriptHoverCode(code, actionConfig, frameworkType, testType);
                break;
                
            case DRAG_DROP:
                generateTypeScriptDragDropCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_FRAME:
                generateTypeScriptSwitchFrameCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_WINDOW:
                generateTypeScriptSwitchWindowCode(code, actionConfig, frameworkType, testType);
                break;
                
            case EXECUTE_SCRIPT:
                generateTypeScriptExecuteScriptCode(code, actionConfig, frameworkType, testType);
                break;
                
            case FILE_UPLOAD:
                generateTypeScriptFileUploadCode(code, actionConfig, frameworkType, testType);
                break;
                
            case KEY_PRESS:
                generateTypeScriptKeyPressCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCROLL:
                generateTypeScriptScrollCode(code, actionConfig, frameworkType, testType);
                break;
                
            default:
                code.append("// Unsupported action type: ").append(actionType);
                break;
        }
    }
    
    /**
     * Generate Java code for a click action.
     */
    private void generateJavaClickCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Click on element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.CLICKABLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.click();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.click();");
        }
    }
    
    /**
     * Generate TypeScript code for a click action.
     */
    private void generateTypeScriptClickCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Click on element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.CLICKABLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.click();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.click();");
        }
    }
    
    /**
     * Generate Java code for a type action.
     */
    private void generateJavaTypeCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String text = (String) actionConfig.getProperty("text");
        Boolean clearBefore = (Boolean) actionConfig.getProperty("clearBefore", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Type text into element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("element.clear();\n");
            }
            
            code.append("element.sendKeys(\"").append(escapeJavaString(text)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("element.clear();\n");
            }
            
            code.append("element.fill(\"").append(escapeJavaString(text)).append("\");");
        }
    }
    
    /**
     * Generate TypeScript code for a type action.
     */
    private void generateTypeScriptTypeCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String text = (String) actionConfig.getProperty("text");
        Boolean clearBefore = (Boolean) actionConfig.getProperty("clearBefore", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Type text into element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("await element.clear();\n");
            }
            
            code.append("await element.sendKeys(\"").append(escapeTypeScriptString(text)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("await element.clear();\n");
            }
            
            code.append("await element.fill(\"").append(escapeTypeScriptString(text)).append("\");");
        }
    }
    
    /**
     * Generate Java code for a select action.
     */
    private void generateJavaSelectCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String option = (String) actionConfig.getProperty("option");
        String selectBy = (String) actionConfig.getProperty("selectBy");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Select option from dropdown\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("CSSelect select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("select.selectByVisibleText(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("select.selectByValue(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("select.selectByIndex(").append(option).append(");");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("CSSelect select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("select.selectByVisibleText(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("select.selectByValue(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("select.selectByIndex(").append(option).append(");");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a select action.
     */
    private void generateTypeScriptSelectCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String option = (String) actionConfig.getProperty("option");
        String selectBy = (String) actionConfig.getProperty("selectBy");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Select option from dropdown\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("const select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("await select.selectByVisibleText(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("await select.selectByValue(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("await select.selectByIndex(").append(option).append(");");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("const select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("await select.selectByVisibleText(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("await select.selectByValue(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("await select.selectByIndex(").append(option).append(");");
            }
        }
    }
    
    /**
     * Generate Java code for an assert action.
     */
    private void generateJavaAssertCode(StringBuilder code, AssertionActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String assertionType = actionConfig.getAssertionType();
        String locator = actionConfig.getLocator();
        String locatorType = actionConfig.getLocatorType();
        String expectedValue = actionConfig.getExpectedValue();
        String actualValue = actionConfig.getActualValue();
        Integer timeout = actionConfig.getTimeout() != null ? actionConfig.getTimeout() : 30;
        Boolean failOnAssertionError = actionConfig.isFailOnAssertionError() != null ? actionConfig.isFailOnAssertionError() : true;
        
        code.append("// Assert condition\n");
        
        // Import statements for assertions based on test type
        if (testType == TestType.TESTNG) {
            code.append("import org.testng.Assert;\n\n");
        } else if (testType == TestType.BDD) {
            code.append("import org.junit.Assert;\n\n");
        }
        
        // Element-based assertions
        if (assertionType.contains("ELEMENT")) {
            if (frameworkType == FrameworkType.SELENIUM) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n\n");
            } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n\n");
            }
            
            if (assertionType.equals("ELEMENT_PRESENT")) {
                code.append("boolean isPresent = element.isPresent();\n");
                code.append("Assert.assertTrue(\"Element should be present\", isPresent);");
            } else if (assertionType.equals("ELEMENT_VISIBLE")) {
                code.append("boolean isVisible = element.isVisible();\n");
                code.append("Assert.assertTrue(\"Element should be visible\", isVisible);");
            } else if (assertionType.equals("ELEMENT_ENABLED")) {
                code.append("boolean isEnabled = element.isEnabled();\n");
                code.append("Assert.assertTrue(\"Element should be enabled\", isEnabled);");
            } else if (assertionType.equals("ELEMENT_SELECTED")) {
                code.append("boolean isSelected = element.isSelected();\n");
                code.append("Assert.assertTrue(\"Element should be selected\", isSelected);");
            } else if (assertionType.equals("ELEMENT_TEXT_EQUALS")) {
                code.append("String actualText = element.getText();\n");
                code.append("Assert.assertEquals(\"Element text should match\", \"").append(escapeJavaString(expectedValue)).append("\", actualText);");
            } else if (assertionType.equals("ELEMENT_TEXT_CONTAINS")) {
                code.append("String actualText = element.getText();\n");
                code.append("Assert.assertTrue(\"Element text should contain expected value\", actualText.contains(\"").append(escapeJavaString(expectedValue)).append("\"));");
            } else if (assertionType.equals("ELEMENT_VALUE_EQUALS")) {
                code.append("String actualValue = element.getAttribute(\"value\");\n");
                code.append("Assert.assertEquals(\"Element value should match\", \"").append(escapeJavaString(expectedValue)).append("\", actualValue);");
            } else if (assertionType.equals("ELEMENT_ATTRIBUTE_EQUALS")) {
                String attributeName = actionConfig.getProperty("attributeName") != null ? 
                        (String) actionConfig.getProperty("attributeName") : "value";
                code.append("String actualAttrValue = element.getAttribute(\"").append(escapeJavaString(attributeName)).append("\");\n");
                code.append("Assert.assertEquals(\"Element attribute should match\", \"").append(escapeJavaString(expectedValue)).append("\", actualAttrValue);");
            } else if (assertionType.equals("ELEMENT_COUNT_EQUALS")) {
                // For elements list count assertion
                code.append("CSElementList elements = getCSElementList(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("int count = elements.size();\n");
                code.append("Assert.assertEquals(\"Element count should match\", ").append(expectedValue).append(", count);");
            }
        }
        // Value-based assertions
        else if (assertionType.contains("VALUE")) {
            if (assertionType.equals("VALUE_EQUALS")) {
                code.append("Assert.assertEquals(\"Value should match\", ").append(expectedValue).append(", ").append(actualValue).append(");");
            } else if (assertionType.equals("VALUE_NOT_EQUALS")) {
                code.append("Assert.assertNotEquals(\"Value should not match\", ").append(expectedValue).append(", ").append(actualValue).append(");");
            } else if (assertionType.equals("VALUE_GREATER_THAN")) {
                code.append("Assert.assertTrue(\"Value should be greater than expected\", (").append(actualValue).append(") > (").append(expectedValue).append("));");
            } else if (assertionType.equals("VALUE_LESS_THAN")) {
                code.append("Assert.assertTrue(\"Value should be less than expected\", (").append(actualValue).append(") < (").append(expectedValue).append("));");
            } else if (assertionType.equals("VALUE_CONTAINS")) {
                code.append("Assert.assertTrue(\"Value should contain expected value\", ((String) ").append(actualValue).append(").contains((String) ").append(expectedValue).append("));");
            } else if (assertionType.equals("VALUE_MATCHES")) {
                code.append("Assert.assertTrue(\"Value should match regex pattern\", ((String) ").append(actualValue).append(").matches((String) ").append(expectedValue).append("));");
            } else if (assertionType.equals("VALUE_EMPTY")) {
                code.append("Assert.assertTrue(\"Value should be empty\", ((String) ").append(actualValue).append(").isEmpty());");
            } else if (assertionType.equals("VALUE_NOT_EMPTY")) {
                code.append("Assert.assertFalse(\"Value should not be empty\", ((String) ").append(actualValue).append(").isEmpty());");
            } else if (assertionType.equals("VALUE_NULL")) {
                code.append("Assert.assertNull(\"Value should be null\", ").append(actualValue).append(");");
            } else if (assertionType.equals("VALUE_NOT_NULL")) {
                code.append("Assert.assertNotNull(\"Value should not be null\", ").append(actualValue).append(");");
            }
        }
        // Boolean assertions
        else if (assertionType.contains("BOOLEAN")) {
            if (assertionType.equals("BOOLEAN_TRUE")) {
                code.append("Assert.assertTrue(\"Condition should be true\", ").append(actualValue).append(");");
            } else if (assertionType.equals("BOOLEAN_FALSE")) {
                code.append("Assert.assertFalse(\"Condition should be false\", ").append(actualValue).append(");");
            }
        }
        // Page assertions
        else if (assertionType.contains("PAGE")) {
            if (assertionType.equals("PAGE_TITLE_EQUALS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("String title = getDriver().getTitle();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("String title = getPage().title();\n");
                }
                code.append("Assert.assertEquals(\"Page title should match\", \"").append(escapeJavaString(expectedValue)).append("\", title);");
            } else if (assertionType.equals("PAGE_TITLE_CONTAINS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("String title = getDriver().getTitle();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("String title = getPage().title();\n");
                }
                code.append("Assert.assertTrue(\"Page title should contain expected value\", title.contains(\"").append(escapeJavaString(expectedValue)).append("\"));");
            } else if (assertionType.equals("PAGE_URL_EQUALS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("String url = getDriver().getCurrentUrl();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("String url = getPage().url();\n");
                }
                code.append("Assert.assertEquals(\"Page URL should match\", \"").append(escapeJavaString(expectedValue)).append("\", url);");
            } else if (assertionType.equals("PAGE_URL_CONTAINS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("String url = getDriver().getCurrentUrl();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("String url = getPage().url();\n");
                }
                code.append("Assert.assertTrue(\"Page URL should contain expected value\", url.contains(\"").append(escapeJavaString(expectedValue)).append("\"));");
            }
        }
        // Custom assertions
        else if (assertionType.equals("CUSTOM")) {
            String customAssertion = (String) actionConfig.getProperty("customAssertion");
            if (customAssertion != null && !customAssertion.isEmpty()) {
                code.append(customAssertion);
            } else {
                code.append("// Custom assertion - implementation required");
            }
        }
    }
    
    /**
     * Generate TypeScript code for an assert action.
     */
    private void generateTypeScriptAssertCode(StringBuilder code, AssertionActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String assertionType = actionConfig.getAssertionType();
        String locator = actionConfig.getLocator();
        String locatorType = actionConfig.getLocatorType();
        String expectedValue = actionConfig.getExpectedValue();
        String actualValue = actionConfig.getActualValue();
        Integer timeout = actionConfig.getTimeout() != null ? actionConfig.getTimeout() : 30;
        Boolean failOnAssertionError = actionConfig.isFailOnAssertionError() != null ? actionConfig.isFailOnAssertionError() : true;
        
        code.append("// Assert condition\n");
        
        // Import statements for assertions based on test type
        if (testType == TestType.TESTNG) {
            code.append("import { expect } from 'chai';\n\n");
        } else if (testType == TestType.BDD) {
            code.append("import { expect } from 'chai';\n\n");
        }
        
        // Element-based assertions
        if (assertionType.contains("ELEMENT")) {
            if (frameworkType == FrameworkType.SELENIUM) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n\n");
            } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n\n");
            }
            
            if (assertionType.equals("ELEMENT_PRESENT")) {
                code.append("const isPresent = await element.isPresent();\n");
                code.append("expect(isPresent).to.be.true;");
            } else if (assertionType.equals("ELEMENT_VISIBLE")) {
                code.append("const isVisible = await element.isVisible();\n");
                code.append("expect(isVisible).to.be.true;");
            } else if (assertionType.equals("ELEMENT_ENABLED")) {
                code.append("const isEnabled = await element.isEnabled();\n");
                code.append("expect(isEnabled).to.be.true;");
            } else if (assertionType.equals("ELEMENT_SELECTED")) {
                code.append("const isSelected = await element.isSelected();\n");
                code.append("expect(isSelected).to.be.true;");
            } else if (assertionType.equals("ELEMENT_TEXT_EQUALS")) {
                code.append("const actualText = await element.getText();\n");
                code.append("expect(actualText).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("ELEMENT_TEXT_CONTAINS")) {
                code.append("const actualText = await element.getText();\n");
                code.append("expect(actualText).to.contain(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("ELEMENT_VALUE_EQUALS")) {
                code.append("const actualValue = await element.getAttribute(\"value\");\n");
                code.append("expect(actualValue).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("ELEMENT_ATTRIBUTE_EQUALS")) {
                String attributeName = actionConfig.getProperty("attributeName") != null ? 
                        (String) actionConfig.getProperty("attributeName") : "value";
                code.append("const actualAttrValue = await element.getAttribute(\"").append(escapeTypeScriptString(attributeName)).append("\");\n");
                code.append("expect(actualAttrValue).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("ELEMENT_COUNT_EQUALS")) {
                // For elements list count assertion
                code.append("const elements = getCSElementList(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("const count = await elements.size();\n");
                code.append("expect(count).to.equal(").append(expectedValue).append(");");
            }
        }
        // Value-based assertions
        else if (assertionType.contains("VALUE")) {
            if (assertionType.equals("VALUE_EQUALS")) {
                code.append("expect(").append(actualValue).append(").to.equal(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_NOT_EQUALS")) {
                code.append("expect(").append(actualValue).append(").to.not.equal(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_GREATER_THAN")) {
                code.append("expect(").append(actualValue).append(").to.be.greaterThan(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_LESS_THAN")) {
                code.append("expect(").append(actualValue).append(").to.be.lessThan(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_CONTAINS")) {
                code.append("expect(").append(actualValue).append(").to.contain(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_MATCHES")) {
                code.append("expect(").append(actualValue).append(").to.match(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_EMPTY")) {
                code.append("expect(").append(actualValue).append(").to.be.empty;");
            } else if (assertionType.equals("VALUE_NOT_EMPTY")) {
                code.append("expect(").append(actualValue).append(").to.not.be.empty;");
            } else if (assertionType.equals("VALUE_NULL")) {
                code.append("expect(").append(actualValue).append(").to.be.null;");
            } else if (assertionType.equals("VALUE_NOT_NULL")) {
                code.append("expect(").append(actualValue).append(").to.not.be.null;");
            }
        }
        // Boolean assertions
        else if (assertionType.contains("BOOLEAN")) {
            if (assertionType.equals("BOOLEAN_TRUE")) {
                code.append("expect(").append(actualValue).append(").to.be.true;");
            } else if (assertionType.equals("BOOLEAN_FALSE")) {
                code.append("expect(").append(actualValue).append(").to.be.false;");
            }
        }
        // Page assertions
        else if (assertionType.contains("PAGE")) {
            if (assertionType.equals("PAGE_TITLE_EQUALS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("const title = await getDriver().getTitle();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("const title = await getPage().title();\n");
                }
                code.append("expect(title).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("PAGE_TITLE_CONTAINS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("const title = await getDriver().getTitle();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("const title = await getPage().title();\n");
                }
                code.append("expect(title).to.contain(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("PAGE_URL_EQUALS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("const url = await getDriver().getCurrentUrl();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("const url = await getPage().url();\n");
                }
                code.append("expect(url).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("PAGE_URL_CONTAINS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("const url = await getDriver().getCurrentUrl();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("const url = await getPage().url();\n");
                }
                code.append("expect(url).to.contain(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            }
        }
        // Custom assertions
        else if (assertionType.equals("CUSTOM")) {
            String customAssertion = (String) actionConfig.getProperty("customAssertion");
            if (customAssertion != null && !customAssertion.isEmpty()) {
                code.append(customAssertion);
            } else {
                code.append("// Custom assertion - implementation required");
            }
        }
    }
    
    /**
     * Generate Java code for a wait action.
     */
    private void generateJavaWaitCode(StringBuilder code, WaitActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String waitType = actionConfig.getWaitType();
        String locator = actionConfig.getLocator();
        String locatorType = actionConfig.getLocatorType();
        Integer timeout = actionConfig.getTimeout() != null ? actionConfig.getTimeout() : 30;
        Integer pollingInterval = actionConfig.getProperty("pollingInterval") != null ? 
                (Integer) actionConfig.getProperty("pollingInterval") : 500;
        String condition = actionConfig.getProperty("condition") != null ? 
                (String) actionConfig.getProperty("condition") : null;
        
        code.append("// Wait for condition\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitType.contains("ELEMENT")) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(");
                
                if (waitType.equals("ELEMENT_VISIBLE")) {
                    code.append("CSWaitStrategyType.VISIBLE");
                } else if (waitType.equals("ELEMENT_CLICKABLE")) {
                    code.append("CSWaitStrategyType.CLICKABLE");
                } else if (waitType.equals("ELEMENT_PRESENT")) {
                    code.append("CSWaitStrategyType.PRESENT");
                } else if (waitType.equals("ELEMENT_INVISIBLE")) {
                    code.append("CSWaitStrategyType.INVISIBLE");
                } else if (waitType.equals("ELEMENT_SELECTED")) {
                    code.append("CSWaitStrategyType.SELECTED");
                } else if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    code.append("CSWaitStrategyType.ATTRIBUTE");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    code.append("CSWaitStrategyType.TEXT");
                }
                
                code.append(");\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("waitStrategy.setPollingInterval(").append(pollingInterval).append(");\n");
                
                if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    String attributeName = actionConfig.getProperty("attributeName") != null ? 
                            (String) actionConfig.getProperty("attributeName") : "value";
                    String attributeValue = actionConfig.getProperty("attributeValue") != null ? 
                            (String) actionConfig.getProperty("attributeValue") : "";
                    
                    code.append("((CSAttributeWait) waitStrategy).setAttribute(\"")
                            .append(escapeJavaString(attributeName)).append("\", \"")
                            .append(escapeJavaString(attributeValue)).append("\");\n");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    String text = actionConfig.getProperty("text") != null ? 
                            (String) actionConfig.getProperty("text") : "";
                    
                    code.append("((CSTextWait) waitStrategy).setText(\"")
                            .append(escapeJavaString(text)).append("\");\n");
                }
                
                code.append("getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);");
            } else if (waitType.equals("FIXED_TIME")) {
                code.append("CSWaitFactory.sleepInMilliseconds(").append(timeout * 1000).append(");");
            } else if (waitType.equals("PAGE_LOAD")) {
                code.append("getDriver().manage().timeouts().pageLoadTimeout(").append(timeout).append(", TimeUnit.SECONDS);");
            } else if (waitType.equals("SCRIPT")) {
                code.append("getDriver().manage().timeouts().setScriptTimeout(").append(timeout).append(", TimeUnit.SECONDS);");
            } else if (waitType.equals("CUSTOM")) {
                if (condition != null && !condition.isEmpty()) {
                    code.append("CSWaitFactory.waitUntil(driver -> {\n    return ").append(condition).append(";\n}, ")
                            .append(timeout).append(", ").append(pollingInterval).append(");");
                } else {
                    code.append("// Custom wait condition not specified");
                }
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitType.contains("ELEMENT")) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                
                if (waitType.equals("ELEMENT_VISIBLE")) {
                    code.append("element.waitForElementToBeVisible(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_CLICKABLE")) {
                    code.append("element.waitForElementToBeEnabled(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_PRESENT")) {
                    code.append("element.waitForElementToBePresent(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_INVISIBLE")) {
                    code.append("element.waitForElementToBeHidden(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    String attributeName = actionConfig.getProperty("attributeName") != null ? 
                            (String) actionConfig.getProperty("attributeName") : "value";
                    String attributeValue = actionConfig.getProperty("attributeValue") != null ? 
                            (String) actionConfig.getProperty("attributeValue") : "";
                    
                    code.append("element.waitForElementToHaveAttribute(\"").append(escapeJavaString(attributeName))
                            .append("\", \"").append(escapeJavaString(attributeValue)).append("\", ")
                            .append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    String text = actionConfig.getProperty("text") != null ? 
                            (String) actionConfig.getProperty("text") : "";
                    
                    code.append("element.waitForElementToHaveText(\"").append(escapeJavaString(text))
                            .append("\", ").append(timeout * 1000).append(");");
                }
            } else if (waitType.equals("FIXED_TIME")) {
                code.append("getPage().waitForTimeout(").append(timeout * 1000).append(");");
            } else if (waitType.equals("PAGE_LOAD")) {
                code.append("getPage().waitForLoadState(LoadState.LOAD, new PageWaitForLoadStateOptions().setTimeout(")
                        .append(timeout * 1000).append("));");
            } else if (waitType.equals("CUSTOM")) {
                if (condition != null && !condition.isEmpty()) {
                    code.append("getPage().waitForFunction(\"").append(escapeJavaString(condition))
                            .append("\", new PageWaitForFunctionOptions().setTimeout(")
                            .append(timeout * 1000).append(").setPredicate(true));");
                } else {
                    code.append("// Custom wait condition not specified");
                }
            }
        }
    }
    
    /**
     * Generate TypeScript code for a wait action.
     */
    private void generateTypeScriptWaitCode(StringBuilder code, WaitActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String waitType = actionConfig.getWaitType();
        String locator = actionConfig.getLocator();
        String locatorType = actionConfig.getLocatorType();
        Integer timeout = actionConfig.getTimeout() != null ? actionConfig.getTimeout() : 30;
        Integer pollingInterval = actionConfig.getProperty("pollingInterval") != null ? 
                (Integer) actionConfig.getProperty("pollingInterval") : 500;
        String condition = actionConfig.getProperty("condition") != null ? 
                (String) actionConfig.getProperty("condition") : null;
        
        code.append("// Wait for condition\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitType.contains("ELEMENT")) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(");
                
                if (waitType.equals("ELEMENT_VISIBLE")) {
                    code.append("CSWaitStrategyType.VISIBLE");
                } else if (waitType.equals("ELEMENT_CLICKABLE")) {
                    code.append("CSWaitStrategyType.CLICKABLE");
                } else if (waitType.equals("ELEMENT_PRESENT")) {
                    code.append("CSWaitStrategyType.PRESENT");
                } else if (waitType.equals("ELEMENT_INVISIBLE")) {
                    code.append("CSWaitStrategyType.INVISIBLE");
                } else if (waitType.equals("ELEMENT_SELECTED")) {
                    code.append("CSWaitStrategyType.SELECTED");
                } else if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    code.append("CSWaitStrategyType.ATTRIBUTE");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    code.append("CSWaitStrategyType.TEXT");
                }
                
                code.append(");\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("waitStrategy.setPollingInterval(").append(pollingInterval).append(");\n");
                
                if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    String attributeName = actionConfig.getProperty("attributeName") != null ? 
                            (String) actionConfig.getProperty("attributeName") : "value";
                    String attributeValue = actionConfig.getProperty("attributeValue") != null ? 
                            (String) actionConfig.getProperty("attributeValue") : "";
                    
                    code.append("(waitStrategy as CSAttributeWait).setAttribute(\"")
                            .append(escapeTypeScriptString(attributeName)).append("\", \"")
                            .append(escapeTypeScriptString(attributeValue)).append("\");\n");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    String text = actionConfig.getProperty("text") != null ? 
                            (String) actionConfig.getProperty("text") : "";
                    
                    code.append("(waitStrategy as CSTextWait).setText(\"")
                            .append(escapeTypeScriptString(text)).append("\");\n");
                }
                
                code.append("await getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);");
            } else if (waitType.equals("FIXED_TIME")) {
                code.append("await CSWaitFactory.sleep(").append(timeout * 1000).append(");");
            } else if (waitType.equals("PAGE_LOAD")) {
                code.append("await getDriver().manage().timeouts().pageLoadTimeout(").append(timeout).append(", TimeUnit.SECONDS);");
            } else if (waitType.equals("SCRIPT")) {
                code.append("await getDriver().manage().timeouts().setScriptTimeout(").append(timeout).append(", TimeUnit.SECONDS);");
            } else if (waitType.equals("CUSTOM")) {
                if (condition != null && !condition.isEmpty()) {
                    code.append("await CSWaitFactory.waitUntil(async (driver) => {\n    return ").append(condition).append(";\n}, ")
                            .append(timeout).append(", ").append(pollingInterval).append(");");
                } else {
                    code.append("// Custom wait condition not specified");
                }
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitType.contains("ELEMENT")) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                
                if (waitType.equals("ELEMENT_VISIBLE")) {
                    code.append("await element.waitForElementToBeVisible(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_CLICKABLE")) {
                    code.append("await element.waitForElementToBeEnabled(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_PRESENT")) {
                    code.append("await element.waitForElementToBePresent(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_INVISIBLE")) {
                    code.append("await element.waitForElementToBeHidden(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    String attributeName = actionConfig.getProperty("attributeName") != null ? 
                            (String) actionConfig.getProperty("attributeName") : "value";
                    String attributeValue = actionConfig.getProperty("attributeValue") != null ? 
                            (String) actionConfig.getProperty("attributeValue") : "";
                    
                    code.append("await element.waitForElementToHaveAttribute(\"").append(escapeTypeScriptString(attributeName))
                            .append("\", \"").append(escapeTypeScriptString(attributeValue)).append("\", ")
                            .append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    String text = actionConfig.getProperty("text") != null ? 
                            (String) actionConfig.getProperty("text") : "";
                    
                    code.append("await element.waitForElementToHaveText(\"").append(escapeTypeScriptString(text))
                            .append("\", ").append(timeout * 1000).append(");");
                }
            } else if (waitType.equals("FIXED_TIME")) {
                code.append("await getPage().waitForTimeout(").append(timeout * 1000).append(");");
            } else if (waitType.equals("PAGE_LOAD")) {
                code.append("await getPage().waitForLoadState('load', { timeout: ")
                        .append(timeout * 1000).append(" });");
            } else if (waitType.equals("CUSTOM")) {
                if (condition != null && !condition.isEmpty()) {
                    code.append("await getPage().waitForFunction(`").append(escapeTypeScriptString(condition))
                            .append("`, { timeout: ").append(timeout * 1000).append(" });");
                } else {
                    code.append("// Custom wait condition not specified");
                }
            }
        }
    }
    
    /**
     * Generate Java code for a navigate action.
     */
    private void generateJavaNavigateCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String url = (String) actionConfig.getProperty("url");
        Boolean waitForLoad = (Boolean) actionConfig.getProperty("waitForLoad", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 60);
        
        code.append("// Navigate to URL\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForLoad) {
                code.append("getDriver().manage().timeouts().pageLoadTimeout(").append(timeout).append(", TimeUnit.SECONDS);\n");
            }
            code.append("getDriver().get(\"").append(escapeJavaString(url)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForLoad) {
                code.append("getPage().navigate(\"").append(escapeJavaString(url)).append("\", ")
                        .append("new NavigateOptions().setWaitUntil(LoadState.LOAD).setTimeout(")
                        .append(timeout * 1000).append("));");
            } else {
                code.append("getPage().navigate(\"").append(escapeJavaString(url)).append("\", ")
                        .append("new NavigateOptions().setWaitUntil(LoadState.DOMCONTENTLOADED).setTimeout(")
                        .append(timeout * 1000).append("));");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a navigate action.
     */
    private void generateTypeScriptNavigateCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String url = (String) actionConfig.getProperty("url");
        Boolean waitForLoad = (Boolean) actionConfig.getProperty("waitForLoad", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 60);
        
        code.append("// Navigate to URL\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForLoad) {
                code.append("await getDriver().manage().timeouts().pageLoadTimeout(").append(timeout).append(", TimeUnit.SECONDS);\n");
            }
            code.append("await getDriver().get(\"").append(escapeTypeScriptString(url)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForLoad) {
                code.append("await getPage().goto(\"").append(escapeTypeScriptString(url)).append("\", { ")
                        .append("waitUntil: 'load', timeout: ").append(timeout * 1000).append(" });");
            } else {
                code.append("await getPage().goto(\"").append(escapeTypeScriptString(url)).append("\", { ")
                        .append("waitUntil: 'domcontentloaded', timeout: ").append(timeout * 1000).append(" });");
            }
        }
    }
    
    /**
     * Generate Java code for a conditional action.
     */
    private void generateJavaConditionalCode(StringBuilder code, ConditionalActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String condition = actionConfig.getCondition();
        String operator = actionConfig.getOperator();
        String leftOperand = actionConfig.getLeftOperand();
        String rightOperand = actionConfig.getRightOperand();
        List<ActionConfig> nestedActions = actionConfig.getNestedActions();
        List<ActionConfig> elseActions = actionConfig.getElseActions();
        
        code.append("// Conditional execution\n");
        
        // Build condition
        StringBuilder conditionCode = new StringBuilder();
        if (condition != null && !condition.isEmpty()) {
            conditionCode.append(condition);
        } else if (operator != null && !operator.isEmpty() && leftOperand != null && rightOperand != null) {
            conditionCode.append(leftOperand);
            
            switch (operator) {
                case "EQUALS":
                    conditionCode.append(" == ");
                    break;
                case "NOT_EQUALS":
                    conditionCode.append(" != ");
                    break;
                case "GREATER_THAN":
                    conditionCode.append(" > ");
                    break;
                case "LESS_THAN":
                    conditionCode.append(" < ");
                    break;
                case "GREATER_THAN_OR_EQUALS":
                    conditionCode.append(" >= ");
                    break;
                case "LESS_THAN_OR_EQUALS":
                    conditionCode.append(" <= ");
                    break;
                case "CONTAINS":
                    conditionCode.append(".contains(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "STARTS_WITH":
                    conditionCode.append(".startsWith(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "ENDS_WITH":
                    conditionCode.append(".endsWith(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "MATCHES":
                    conditionCode.append(".matches(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                default:
                    conditionCode.append(" ").append(operator).append(" ");
                    break;
            }
            
            if (rightOperand != null) {
                conditionCode.append(rightOperand);
            }
        } else {
            conditionCode.append("true");
        }
        
        // Generate code
        code.append("if (").append(conditionCode).append(") {\n");
        
        if (nestedActions != null && !nestedActions.isEmpty()) {
            for (ActionConfig nestedAction : nestedActions) {
                StringBuilder nestedCode = new StringBuilder();
                generateJavaCode(nestedCode, nestedAction, frameworkType, testType);
                
                String[] lines = nestedCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        if (elseActions != null && !elseActions.isEmpty()) {
            code.append("} else {\n");
            
            for (ActionConfig elseAction : elseActions) {
                StringBuilder elseCode = new StringBuilder();
                generateJavaCode(elseCode, elseAction, frameworkType, testType);
                
                String[] lines = elseCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate TypeScript code for a conditional action.
     */
    private void generateTypeScriptConditionalCode(StringBuilder code, ConditionalActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String condition = actionConfig.getCondition();
        String operator = actionConfig.getOperator();
        String leftOperand = actionConfig.getLeftOperand();
        String rightOperand = actionConfig.getRightOperand();
        List<ActionConfig> nestedActions = actionConfig.getNestedActions();
        List<ActionConfig> elseActions = actionConfig.getElseActions();
        
        code.append("// Conditional execution\n");
        
        // Build condition
        StringBuilder conditionCode = new StringBuilder();
        if (condition != null && !condition.isEmpty()) {
            conditionCode.append(condition);
        } else if (operator != null && !operator.isEmpty() && leftOperand != null && rightOperand != null) {
            conditionCode.append(leftOperand);
            
            switch (operator) {
                case "EQUALS":
                    conditionCode.append(" === ");
                    break;
                case "NOT_EQUALS":
                    conditionCode.append(" !== ");
                    break;
                case "GREATER_THAN":
                    conditionCode.append(" > ");
                    break;
                case "LESS_THAN":
                    conditionCode.append(" < ");
                    break;
                case "GREATER_THAN_OR_EQUALS":
                    conditionCode.append(" >= ");
                    break;
                case "LESS_THAN_OR_EQUALS":
                    conditionCode.append(" <= ");
                    break;
                case "CONTAINS":
                    conditionCode.append(".includes(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "STARTS_WITH":
                    conditionCode.append(".startsWith(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "ENDS_WITH":
                    conditionCode.append(".endsWith(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "MATCHES":
                    conditionCode.append(".match(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(") !== null");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                default:
                    conditionCode.append(" ").append(operator).append(" ");
                    break;
            }
            
            if (rightOperand != null) {
                conditionCode.append(rightOperand);
            }
        } else {
            conditionCode.append("true");
        }
        
        // Generate code
        code.append("if (").append(conditionCode).append(") {\n");
        
        if (nestedActions != null && !nestedActions.isEmpty()) {
            for (ActionConfig nestedAction : nestedActions) {
                StringBuilder nestedCode = new StringBuilder();
                generateTypeScriptCode(nestedCode, nestedAction, frameworkType, testType);
                
                String[] lines = nestedCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        if (elseActions != null && !elseActions.isEmpty()) {
            code.append("} else {\n");
            
            for (ActionConfig elseAction : elseActions) {
                StringBuilder elseCode = new StringBuilder();
                generateTypeScriptCode(elseCode, elseAction, frameworkType, testType);
                
                String[] lines = elseCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }

/**
     * Generate Java code for a loop action.
     */
    private void generateJavaLoopCode(StringBuilder code, LoopActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String loopType = actionConfig.getLoopType();
        Integer times = actionConfig.getTimes();
        String collection = actionConfig.getCollection();
        String variableName = actionConfig.getVariableName();
        String initExpression = actionConfig.getInitExpression();
        String conditionExpression = actionConfig.getConditionExpression();
        String incrementExpression = actionConfig.getIncrementExpression();
        List<ActionConfig> nestedActions = actionConfig.getNestedActions();
        
        code.append("// Loop execution\n");
        
        if (loopType.equals("TIMES")) {
            code.append("for (int i = 0; i < ").append(times).append("; i++) {\n");
        } else if (loopType.equals("FOREACH")) {
            code.append("for (Object ").append(variableName).append(" : ").append(collection).append(") {\n");
        } else if (loopType.equals("FOR")) {
            code.append("for (").append(initExpression).append("; ")
                    .append(conditionExpression).append("; ")
                    .append(incrementExpression).append(") {\n");
        } else if (loopType.equals("WHILE")) {
            code.append("while (").append(conditionExpression).append(") {\n");
        } else {
            code.append("// Unsupported loop type: ").append(loopType).append("\n");
        }
        
        if (nestedActions != null && !nestedActions.isEmpty()) {
            for (ActionConfig nestedAction : nestedActions) {
                StringBuilder nestedCode = new StringBuilder();
                generateJavaCode(nestedCode, nestedAction, frameworkType, testType);
                
                String[] lines = nestedCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate TypeScript code for a loop action.
     */
    private void generateTypeScriptLoopCode(StringBuilder code, LoopActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String loopType = actionConfig.getLoopType();
        Integer times = actionConfig.getTimes();
        String collection = actionConfig.getCollection();
        String variableName = actionConfig.getVariableName();
        String initExpression = actionConfig.getInitExpression();
        String conditionExpression = actionConfig.getConditionExpression();
        String incrementExpression = actionConfig.getIncrementExpression();
        List<ActionConfig> nestedActions = actionConfig.getNestedActions();
        
        code.append("// Loop execution\n");
        
        if (loopType.equals("TIMES")) {
            code.append("for (let i = 0; i < ").append(times).append("; i++) {\n");
        } else if (loopType.equals("FOREACH")) {
            code.append("for (const ").append(variableName).append(" of ").append(collection).append(") {\n");
        } else if (loopType.equals("FOR")) {
            code.append("for (").append(initExpression).append("; ")
                    .append(conditionExpression).append("; ")
                    .append(incrementExpression).append(") {\n");
        } else if (loopType.equals("WHILE")) {
            code.append("while (").append(conditionExpression).append(") {\n");
        } else {
            code.append("// Unsupported loop type: ").append(loopType).append("\n");
        }
        
        if (nestedActions != null && !nestedActions.isEmpty()) {
            for (ActionConfig nestedAction : nestedActions) {
                StringBuilder nestedCode = new StringBuilder();
                generateTypeScriptCode(nestedCode, nestedAction, frameworkType, testType);
                
                String[] lines = nestedCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate Java code for a data provider action.
     */
    private void generateJavaDataProviderCode(StringBuilder code, DataProviderActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String dataSourceType = actionConfig.getDataSourceType();
        String dataSourcePath = actionConfig.getDataSourcePath();
        String sheetName = actionConfig.getSheetName();
        String delimiter = actionConfig.getDelimiter();
        Boolean headers = actionConfig.getHeaders();
        List<String> parameters = actionConfig.getParameters();
        List<ActionConfig> iterationActions = actionConfig.getIterationActions();
        
        code.append("// Data-driven execution\n");
        
        // Generate data source
        if (dataSourceType.equals("EXCEL")) {
            code.append("CSDataSource dataSource = CSDataSourceFactory.createExcelDataSource(\"")
                    .append(escapeJavaString(dataSourcePath)).append("\", \"")
                    .append(escapeJavaString(sheetName)).append("\", ")
                    .append(headers).append(");\n");
        } else if (dataSourceType.equals("CSV")) {
            code.append("CSDataSource dataSource = CSDataSourceFactory.createCsvDataSource(\"")
                    .append(escapeJavaString(dataSourcePath)).append("\", \"")
                    .append(escapeJavaString(delimiter)).append("\", ")
                    .append(headers).append(");\n");
        } else if (dataSourceType.equals("JSON")) {
            code.append("CSDataSource dataSource = CSDataSourceFactory.createJsonDataSource(\"")
                    .append(escapeJavaString(dataSourcePath)).append("\");\n");
        } else if (dataSourceType.equals("DATABASE")) {
            String query = actionConfig.getProperty("query") != null ? 
                    (String) actionConfig.getProperty("query") : "";
            String connectionString = actionConfig.getProperty("connectionString") != null ? 
                    (String) actionConfig.getProperty("connectionString") : "";
            
            code.append("CSDataSource dataSource = CSDataSourceFactory.createDatabaseDataSource(\"")
                    .append(escapeJavaString(connectionString)).append("\", \"")
                    .append(escapeJavaString(query)).append("\");\n");
        } else {
            code.append("// Unsupported data source type: ").append(dataSourceType).append("\n");
            return;
        }
        
        // Generate parameters
        if (parameters != null && !parameters.isEmpty()) {
            code.append("String[] parameterNames = new String[] {");
            for (int i = 0; i < parameters.size(); i++) {
                if (i > 0) {
                    code.append(", ");
                }
                code.append("\"").append(escapeJavaString(parameters.get(i))).append("\"");
            }
            code.append("};\n");
        }
        
        // Generate iterations
        code.append("for (Map<String, Object> data : dataSource.getData()) {\n");
        
        if (iterationActions != null && !iterationActions.isEmpty()) {
            code.append("    // Add data to test context\n");
            code.append("    TestContext.getInstance().addData(data);\n");
            code.append("\n");
            
            for (ActionConfig iterationAction : iterationActions) {
                StringBuilder iterationCode = new StringBuilder();
                generateJavaCode(iterationCode, iterationAction, frameworkType, testType);
                
                String[] lines = iterationCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate TypeScript code for a data provider action.
     */
    private void generateTypeScriptDataProviderCode(StringBuilder code, DataProviderActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String dataSourceType = actionConfig.getDataSourceType();
        String dataSourcePath = actionConfig.getDataSourcePath();
        String sheetName = actionConfig.getSheetName();
        String delimiter = actionConfig.getDelimiter();
        Boolean headers = actionConfig.getHeaders();
        List<String> parameters = actionConfig.getParameters();
        List<ActionConfig> iterationActions = actionConfig.getIterationActions();
        
        code.append("// Data-driven execution\n");
        
        // Generate data source
        if (dataSourceType.equals("EXCEL")) {
            code.append("const dataSource = CSDataSourceFactory.createExcelDataSource(\"")
                    .append(escapeTypeScriptString(dataSourcePath)).append("\", \"")
                    .append(escapeTypeScriptString(sheetName)).append("\", ")
                    .append(headers).append(");\n");
        } else if (dataSourceType.equals("CSV")) {
            code.append("const dataSource = CSDataSourceFactory.createCsvDataSource(\"")
                    .append(escapeTypeScriptString(dataSourcePath)).append("\", \"")
                    .append(escapeTypeScriptString(delimiter)).append("\", ")
                    .append(headers).append(");\n");
        } else if (dataSourceType.equals("JSON")) {
            code.append("const dataSource = CSDataSourceFactory.createJsonDataSource(\"")
                    .append(escapeTypeScriptString(dataSourcePath)).append("\");\n");
        } else if (dataSourceType.equals("DATABASE")) {
            String query = actionConfig.getProperty("query") != null ? 
                    (String) actionConfig.getProperty("query") : "";
            String connectionString = actionConfig.getProperty("connectionString") != null ? 
                    (String) actionConfig.getProperty("connectionString") : "";
            
            code.append("const dataSource = CSDataSourceFactory.createDatabaseDataSource(\"")
                    .append(escapeTypeScriptString(connectionString)).append("\", \"")
                    .append(escapeTypeScriptString(query)).append("\");\n");
        } else {
            code.append("// Unsupported data source type: ").append(dataSourceType).append("\n");
            return;
        }
        
        // Generate parameters
        if (parameters != null && !parameters.isEmpty()) {
            code.append("const parameterNames = [");
            for (int i = 0; i < parameters.size(); i++) {
                if (i > 0) {
                    code.append(", ");
                }
                code.append("\"").append(escapeTypeScriptString(parameters.get(i))).append("\"");
            }
            code.append("];\n");
        }
        
        // Generate iterations
        code.append("for (const data of await dataSource.getData()) {\n");
        
        if (iterationActions != null && !iterationActions.isEmpty()) {
            code.append("    // Add data to test context\n");
            code.append("    TestContext.getInstance().addData(data);\n");
            code.append("\n");
            
            for (ActionConfig iterationAction : iterationActions) {
                StringBuilder iterationCode = new StringBuilder();
                generateTypeScriptCode(iterationCode, iterationAction, frameworkType, testType);
                
                String[] lines = iterationCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate Java code for a custom action.
     */
    private void generateJavaCustomCode(StringBuilder code, CustomActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String scriptType = actionConfig.getScriptType();
        String script = actionConfig.getScript();
        List<Map<String, String>> parameters = actionConfig.getParameters();
        
        code.append("// Custom action execution\n");
        
        if (scriptType.equals("JAVASCRIPT")) {
            code.append("// JavaScript execution\n");
            
            // Generate parameters
            if (parameters != null && !parameters.isEmpty()) {
                code.append("Map<String, Object> scriptParams = new HashMap<>();\n");
                for (Map<String, String> parameter : parameters) {
                    String name = parameter.get("name");
                    String value = parameter.get("value");
                    if (name != null && value != null) {
                        code.append("scriptParams.put(\"").append(escapeJavaString(name)).append("\", \"")
                                .append(escapeJavaString(value)).append("\");\n");
                    }
                }
                code.append("\n");
            }
            
            // Generate script execution
            code.append("JavaScriptExecutor jsExecutor = (JavaScriptExecutor) getDriver();\n");
            
            if (parameters != null && !parameters.isEmpty()) {
                code.append("Object result = jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\", scriptParams);\n");
            } else {
                code.append("Object result = jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\");\n");
            }
            
            // Store result if required
            String resultVariable = actionConfig.getProperty("resultVariable") != null ? 
                    (String) actionConfig.getProperty("resultVariable") : null;
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("// Store result in variable\n");
                code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(resultVariable)).append("\", result);");
            }
        } else if (scriptType.equals("JAVA")) {
            code.append("// Java code execution\n");
            code.append(script);
        } else {
            code.append("// Unsupported script type: ").append(scriptType);
        }
    }
    
    /**
     * Generate TypeScript code for a custom action.
     */
    private void generateTypeScriptCustomCode(StringBuilder code, CustomActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String scriptType = actionConfig.getScriptType();
        String script = actionConfig.getScript();
        List<Map<String, String>> parameters = actionConfig.getParameters();
        
        code.append("// Custom action execution\n");
        
        if (scriptType.equals("JAVASCRIPT")) {
            code.append("// JavaScript execution\n");
            
            // Generate parameters
            if (parameters != null && !parameters.isEmpty()) {
                code.append("const scriptParams: Record<string, any> = {};\n");
                for (Map<String, String> parameter : parameters) {
                    String name = parameter.get("name");
                    String value = parameter.get("value");
                    if (name != null && value != null) {
                        code.append("scriptParams[\"").append(escapeTypeScriptString(name)).append("\"] = \"")
                                .append(escapeTypeScriptString(value)).append("\";\n");
                    }
                }
                code.append("\n");
            }
            
            // Generate script execution
            if (frameworkType == FrameworkType.SELENIUM) {
                code.append("const jsExecutor = getDriver() as unknown as IJavaScriptExecutor;\n");
                
                if (parameters != null && !parameters.isEmpty()) {
                    code.append("const result = await jsExecutor.executeScript(`").append(escapeTypeScriptString(script)).append("`, scriptParams);\n");
                } else {
                    code.append("const result = await jsExecutor.executeScript(`").append(escapeTypeScriptString(script)).append("`);\n");
                }
            } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                code.append("const result = await getPage().evaluate(`").append(escapeTypeScriptString(script)).append("`);\n");
            }
            
            // Store result if required
            String resultVariable = actionConfig.getProperty("resultVariable") != null ? 
                    (String) actionConfig.getProperty("resultVariable") : null;
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("// Store result in variable\n");
                code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(resultVariable)).append("\", result);");
            }
        } else if (scriptType.equals("TYPESCRIPT")) {
            code.append("// TypeScript code execution\n");
            code.append(script);
        } else {
            code.append("// Unsupported script type: ").append(scriptType);
        }
    }
    
    /**
     * Generate Java code for a variable action.
     */
    private void generateJavaVariableCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String variableName = (String) actionConfig.getProperty("variableName");
        String variableType = (String) actionConfig.getProperty("variableType");
        String value = (String) actionConfig.getProperty("value");
        String scope = (String) actionConfig.getProperty("scope");
        
        code.append("// Variable declaration\n");
        
        if (scope != null && scope.equals("GLOBAL")) {
            code.append("TestContext.getInstance().setGlobalVariable(\"").append(escapeJavaString(variableName)).append("\", ");
        } else {
            code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(variableName)).append("\", ");
        }
        
        if (variableType != null) {
            if (variableType.equals("STRING")) {
                code.append("\"").append(escapeJavaString(value)).append("\"");
            } else if (variableType.equals("INTEGER")) {
                code.append("Integer.valueOf(").append(value).append(")");
            } else if (variableType.equals("DOUBLE")) {
                code.append("Double.valueOf(").append(value).append(")");
            } else if (variableType.equals("BOOLEAN")) {
                code.append("Boolean.valueOf(").append(value).append(")");
            } else if (variableType.equals("ELEMENT")) {
                String locator = (String) actionConfig.getProperty("locator");
                String locatorType = (String) actionConfig.getProperty("locatorType");
                
                if (locator != null && locatorType != null) {
                    code.append("getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(")");
                } else {
                    code.append("null");
                }
            } else {
                code.append(value);
            }
        } else {
            code.append(value);
        }
        
        code.append(");");
    }
    
    /**
     * Generate TypeScript code for a variable action.
     */
    private void generateTypeScriptVariableCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String variableName = (String) actionConfig.getProperty("variableName");
        String variableType = (String) actionConfig.getProperty("variableType");
        String value = (String) actionConfig.getProperty("value");
        String scope = (String) actionConfig.getProperty("scope");
        
        code.append("// Variable declaration\n");
        
        if (scope != null && scope.equals("GLOBAL")) {
            code.append("TestContext.getInstance().setGlobalVariable(\"").append(escapeTypeScriptString(variableName)).append("\", ");
        } else {
            code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(variableName)).append("\", ");
        }
        
        if (variableType != null) {
            if (variableType.equals("STRING")) {
                code.append("\"").append(escapeTypeScriptString(value)).append("\"");
            } else if (variableType.equals("INTEGER")) {
                code.append("parseInt(").append(value).append(")");
            } else if (variableType.equals("DOUBLE")) {
                code.append("parseFloat(").append(value).append(")");
            } else if (variableType.equals("BOOLEAN")) {
                code.append(value);
            } else if (variableType.equals("ELEMENT")) {
                String locator = (String) actionConfig.getProperty("locator");
                String locatorType = (String) actionConfig.getProperty("locatorType");
                
                if (locator != null && locatorType != null) {
                    code.append("getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(")");
                } else {
                    code.append("null");
                }
            } else {
                code.append(value);
            }
        } else {
            code.append(value);
        }
        
        code.append(");");
    }
    
    /**
     * Generate Java code for a screenshot action.
     */
    private void generateJavaScreenshotCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String fileName = (String) actionConfig.getProperty("fileName");
        String element = (String) actionConfig.getProperty("element");
        Boolean fullPage = (Boolean) actionConfig.getProperty("fullPage", false);
        String directory = (String) actionConfig.getProperty("directory");
        
        code.append("// Capture screenshot\n");
        
        // Generate file path
        if (fileName != null && !fileName.isEmpty()) {
            code.append("String screenshotFileName = \"").append(escapeJavaString(fileName)).append("\";\n");
        } else {
            code.append("String screenshotFileName = \"screenshot_\" + System.currentTimeMillis() + \".png\";\n");
        }
        
        if (directory != null && !directory.isEmpty()) {
            code.append("String screenshotDirectory = \"").append(escapeJavaString(directory)).append("\";\n");
        } else {
            code.append("String screenshotDirectory = CSScreenshotManager.getDefaultScreenshotDirectory();\n");
        }
        
        code.append("String screenshotPath = screenshotDirectory + File.separator + screenshotFileName;\n\n");
        
        // Generate screenshot capture
        if (frameworkType == FrameworkType.SELENIUM) {
            if (element != null && !element.isEmpty()) {
                String locatorType = (String) actionConfig.getProperty("locatorType");
                
                if (locatorType != null && !locatorType.isEmpty()) {
                    code.append("CSElement elementToCapture = getCSElement(").append(getLocatorCode(locatorType, element, LanguageType.JAVA)).append(");\n");
                    code.append("CSScreenshotManager.captureElementScreenshot(elementToCapture, screenshotPath);");
                } else {
                    code.append("CSScreenshotManager.captureScreenshot(screenshotPath);");
                }
            } else if (fullPage) {
                code.append("CSScreenshotManager.captureFullPageScreenshot(screenshotPath);");
            } else {
                code.append("CSScreenshotManager.captureScreenshot(screenshotPath);");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (element != null && !element.isEmpty()) {
                String locatorType = (String) actionConfig.getProperty("locatorType");
                
                if (locatorType != null && !locatorType.isEmpty()) {
                    code.append("CSElement elementToCapture = getCSElement(").append(getLocatorCode(locatorType, element, LanguageType.JAVA)).append(");\n");
                    code.append("CSScreenshotManager.captureElementScreenshot(elementToCapture, screenshotPath);");
                } else {
                    code.append("CSScreenshotManager.captureScreenshot(screenshotPath);");
                }
            } else if (fullPage) {
                code.append("CSScreenshotManager.captureFullPageScreenshot(screenshotPath);");
            } else {
                code.append("CSScreenshotManager.captureScreenshot(screenshotPath);");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a screenshot action.
     */
    private void generateTypeScriptScreenshotCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String fileName = (String) actionConfig.getProperty("fileName");
        String element = (String) actionConfig.getProperty("element");
        Boolean fullPage = (Boolean) actionConfig.getProperty("fullPage", false);
        String directory = (String) actionConfig.getProperty("directory");
        
        code.append("// Capture screenshot\n");
        
        // Generate file path
        if (fileName != null && !fileName.isEmpty()) {
            code.append("const screenshotFileName = \"").append(escapeTypeScriptString(fileName)).append("\";\n");
        } else {
            code.append("const screenshotFileName = `screenshot_${Date.now()}.png`;\n");
        }
        
        if (directory != null && !directory.isEmpty()) {
            code.append("const screenshotDirectory = \"").append(escapeTypeScriptString(directory)).append("\";\n");
        } else {
            code.append("const screenshotDirectory = CSScreenshotManager.getDefaultScreenshotDirectory();\n");
        }
        
        code.append("const screenshotPath = `${screenshotDirectory}${path.sep}${screenshotFileName}`;\n\n");
        
        // Generate screenshot capture
        if (frameworkType == FrameworkType.SELENIUM) {
            if (element != null && !element.isEmpty()) {
                String locatorType = (String) actionConfig.getProperty("locatorType");
                
                if (locatorType != null && !locatorType.isEmpty()) {
                    code.append("const elementToCapture = getCSElement(").append(getLocatorCode(locatorType, element, LanguageType.TYPESCRIPT)).append(");\n");
                    code.append("await CSScreenshotManager.captureElementScreenshot(elementToCapture, screenshotPath);");
                } else {
                    code.append("await CSScreenshotManager.captureScreenshot(screenshotPath);");
                }
            } else if (fullPage) {
                code.append("await CSScreenshotManager.captureFullPageScreenshot(screenshotPath);");
            } else {
                code.append("await CSScreenshotManager.captureScreenshot(screenshotPath);");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (element != null && !element.isEmpty()) {
                String locatorType = (String) actionConfig.getProperty("locatorType");
                
                if (locatorType != null && !locatorType.isEmpty()) {
                    code.append("const elementToCapture = getCSElement(").append(getLocatorCode(locatorType, element, LanguageType.TYPESCRIPT)).append(");\n");
                    code.append("await CSScreenshotManager.captureElementScreenshot(elementToCapture, screenshotPath);");
                } else {
                    code.append("await CSScreenshotManager.captureScreenshot(screenshotPath);");
                }
            } else if (fullPage) {
                code.append("await CSScreenshotManager.captureFullPageScreenshot(screenshotPath, { fullPage: true });");
            } else {
                code.append("await CSScreenshotManager.captureScreenshot(screenshotPath);");
            }
        }
    }
    
    /**
     * Generate Java code for a hover action.
     */
    private void generateJavaHoverCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Hover over element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("element.hover();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("element.hover();");
        }
    }
    
    /**
     * Generate TypeScript code for a hover action.
     */
    private void generateTypeScriptHoverCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Hover over element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("await element.hover();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("await element.hover();");
        }
    }
    
    /**
     * Generate Java code for a drag and drop action.
     */
    private void generateJavaDragDropCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String sourceLocator = (String) actionConfig.getProperty("sourceLocator");
        String sourceLocatorType = (String) actionConfig.getProperty("sourceLocatorType");
        String targetLocator = (String) actionConfig.getProperty("targetLocator");
        String targetLocatorType = (String) actionConfig.getProperty("targetLocatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElements = (Boolean) actionConfig.getProperty("waitForElements", true);
        
        code.append("// Drag and drop element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElements) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.JAVA)).append(", waitStrategy);\n");
                code.append("CSElement targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.JAVA)).append(");\n");
                code.append("CSElement targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("sourceElement.dragAndDropTo(targetElement);");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElements) {
                code.append("CSElement sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.JAVA)).append(");\n");
                code.append("CSElement targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.JAVA)).append(");\n");
                code.append("sourceElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("targetElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.JAVA)).append(");\n");
                code.append("CSElement targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("sourceElement.dragAndDropTo(targetElement);");
        }
    }
    
    /**
     * Generate TypeScript code for a drag and drop action.
     */
    private void generateTypeScriptDragDropCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String sourceLocator = (String) actionConfig.getProperty("sourceLocator");
        String sourceLocatorType = (String) actionConfig.getProperty("sourceLocatorType");
        String targetLocator = (String) actionConfig.getProperty("targetLocator");
        String targetLocatorType = (String) actionConfig.getProperty("targetLocatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElements = (Boolean) actionConfig.getProperty("waitForElements", true);
        
        code.append("// Drag and drop element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElements) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                code.append("const targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("const targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("await sourceElement.dragAndDropTo(targetElement);");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElements) {
                code.append("const sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("const targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await sourceElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("await targetElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("const targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("await sourceElement.dragAndDropTo(targetElement);");
        }
    }

/**
     * Generate Java code for a switch frame action.
     */
    private void generateJavaSwitchFrameCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String frameLocator = (String) actionConfig.getProperty("frameLocator");
        String frameLocatorType = (String) actionConfig.getProperty("frameLocatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean switchToDefault = (Boolean) actionConfig.getProperty("switchToDefault", false);
        Boolean switchToParent = (Boolean) actionConfig.getProperty("switchToParent", false);
        
        code.append("// Switch frame\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (switchToDefault) {
                code.append("getDriver().switchTo().defaultContent();");
            } else if (switchToParent) {
                code.append("getDriver().switchTo().parentFrame();");
            } else if (frameLocatorType != null && frameLocatorType.equals("INDEX")) {
                try {
                    int index = Integer.parseInt(frameLocator);
                    code.append("getDriver().switchTo().frame(").append(index).append(");");
                } catch (NumberFormatException e) {
                    code.append("// Invalid frame index: ").append(frameLocator);
                }
            } else {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement frameElement = getCSElement(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.JAVA)).append(", waitStrategy);\n");
                code.append("getDriver().switchTo().frame(frameElement.getWebElement());");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (switchToDefault) {
                code.append("getPage().setFrameByUrl(\"\");");
            } else if (switchToParent) {
                code.append("getPage().setParentFrame();");
            } else if (frameLocatorType != null && frameLocatorType.equals("INDEX")) {
                try {
                    int index = Integer.parseInt(frameLocator);
                    code.append("getPage().setFrameByIndex(").append(index).append(");");
                } catch (NumberFormatException e) {
                    code.append("// Invalid frame index: ").append(frameLocator);
                }
            } else {
                code.append("CSElement frameElement = getCSElement(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.JAVA)).append(");\n");
                code.append("frameElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("getPage().setFrameByElement(frameElement.getPlaywrightElement());");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a switch frame action.
     */
    private void generateTypeScriptSwitchFrameCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String frameLocator = (String) actionConfig.getProperty("frameLocator");
        String frameLocatorType = (String) actionConfig.getProperty("frameLocatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean switchToDefault = (Boolean) actionConfig.getProperty("switchToDefault", false);
        Boolean switchToParent = (Boolean) actionConfig.getProperty("switchToParent", false);
        
        code.append("// Switch frame\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (switchToDefault) {
                code.append("await getDriver().switchTo().defaultContent();");
            } else if (switchToParent) {
                code.append("await getDriver().switchTo().parentFrame();");
            } else if (frameLocatorType != null && frameLocatorType.equals("INDEX")) {
                try {
                    int index = Integer.parseInt(frameLocator);
                    code.append("await getDriver().switchTo().frame(").append(index).append(");");
                } catch (NumberFormatException e) {
                    code.append("// Invalid frame index: ").append(frameLocator);
                }
            } else {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const frameElement = getCSElement(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                code.append("await getDriver().switchTo().frame(await frameElement.getWebElement());");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (switchToDefault) {
                code.append("await getPage().setFrameByUrl(\"\");");
            } else if (switchToParent) {
                code.append("await getPage().setParentFrame();");
            } else if (frameLocatorType != null && frameLocatorType.equals("INDEX")) {
                try {
                    int index = Integer.parseInt(frameLocator);
                    code.append("await getPage().setFrameByIndex(").append(index).append(");");
                } catch (NumberFormatException e) {
                    code.append("// Invalid frame index: ").append(frameLocator);
                }
            } else {
                code.append("const frameElement = getCSElement(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await frameElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("await getPage().setFrameByElement(await frameElement.getPlaywrightElement());");
            }
        }
    }
    
    /**
     * Generate Java code for a switch window action.
     */
    private void generateJavaSwitchWindowCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String windowHandle = (String) actionConfig.getProperty("windowHandle");
        Integer windowIndex = (Integer) actionConfig.getProperty("windowIndex");
        String windowTitle = (String) actionConfig.getProperty("windowTitle");
        String windowUrl = (String) actionConfig.getProperty("windowUrl");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Switch window\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (windowHandle != null && !windowHandle.isEmpty()) {
                code.append("getDriver().switchTo().window(\"").append(escapeJavaString(windowHandle)).append("\");");
            } else if (windowIndex != null) {
                code.append("List<String> windowHandles = new ArrayList<>(getDriver().getWindowHandles());\n");
                code.append("if (windowHandles.size() > ").append(windowIndex).append(") {\n");
                code.append("    getDriver().switchTo().window(windowHandles.get(").append(windowIndex).append("));\n");
                code.append("} else {\n");
                code.append("    throw new IllegalArgumentException(\"Window index out of bounds: \" + ").append(windowIndex).append(");\n");
                code.append("}");
            } else if (windowTitle != null && !windowTitle.isEmpty()) {
                code.append("// Switch to window by title\n");
                code.append("String targetTitle = \"").append(escapeJavaString(windowTitle)).append("\";\n");
                code.append("String currentHandle = getDriver().getWindowHandle();\n");
                code.append("boolean found = false;\n");
                code.append("for (String handle : getDriver().getWindowHandles()) {\n");
                code.append("    getDriver().switchTo().window(handle);\n");
                code.append("    if (getDriver().getTitle().equals(targetTitle)) {\n");
                code.append("        found = true;\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
                code.append("if (!found) {\n");
                code.append("    getDriver().switchTo().window(currentHandle);\n");
                code.append("    throw new IllegalArgumentException(\"Window with title '\" + targetTitle + \"' not found\");\n");
                code.append("}");
            } else if (windowUrl != null && !windowUrl.isEmpty()) {
                code.append("// Switch to window by URL\n");
                code.append("String targetUrl = \"").append(escapeJavaString(windowUrl)).append("\";\n");
                code.append("String currentHandle = getDriver().getWindowHandle();\n");
                code.append("boolean found = false;\n");
                code.append("for (String handle : getDriver().getWindowHandles()) {\n");
                code.append("    getDriver().switchTo().window(handle);\n");
                code.append("    if (getDriver().getCurrentUrl().equals(targetUrl)) {\n");
                code.append("        found = true;\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
                code.append("if (!found) {\n");
                code.append("    getDriver().switchTo().window(currentHandle);\n");
                code.append("    throw new IllegalArgumentException(\"Window with URL '\" + targetUrl + \"' not found\");\n");
                code.append("}");
            } else {
                code.append("// No window identifier specified");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (windowIndex != null) {
                code.append("List<Page> pages = getContext().pages();\n");
                code.append("if (pages.size() > ").append(windowIndex).append(") {\n");
                code.append("    setPage(pages.get(").append(windowIndex).append("));\n");
                code.append("} else {\n");
                code.append("    throw new IllegalArgumentException(\"Page index out of bounds: \" + ").append(windowIndex).append(");\n");
                code.append("}");
            } else if (windowTitle != null && !windowTitle.isEmpty()) {
                code.append("// Switch to page by title\n");
                code.append("String targetTitle = \"").append(escapeJavaString(windowTitle)).append("\";\n");
                code.append("boolean found = false;\n");
                code.append("for (Page page : getContext().pages()) {\n");
                code.append("    if (page.title().equals(targetTitle)) {\n");
                code.append("        setPage(page);\n");
                code.append("        found = true;\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
                code.append("if (!found) {\n");
                code.append("    throw new IllegalArgumentException(\"Page with title '\" + targetTitle + \"' not found\");\n");
                code.append("}");
            } else if (windowUrl != null && !windowUrl.isEmpty()) {
                code.append("// Switch to page by URL\n");
                code.append("String targetUrl = \"").append(escapeJavaString(windowUrl)).append("\";\n");
                code.append("boolean found = false;\n");
                code.append("for (Page page : getContext().pages()) {\n");
                code.append("    if (page.url().equals(targetUrl)) {\n");
                code.append("        setPage(page);\n");
                code.append("        found = true;\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
                code.append("if (!found) {\n");
                code.append("    throw new IllegalArgumentException(\"Page with URL '\" + targetUrl + \"' not found\");\n");
                code.append("}");
            } else {
                code.append("// No page identifier specified");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a switch window action.
     */
    private void generateTypeScriptSwitchWindowCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String windowHandle = (String) actionConfig.getProperty("windowHandle");
        Integer windowIndex = (Integer) actionConfig.getProperty("windowIndex");
        String windowTitle = (String) actionConfig.getProperty("windowTitle");
        String windowUrl = (String) actionConfig.getProperty("windowUrl");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Switch window\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (windowHandle != null && !windowHandle.isEmpty()) {
                code.append("await getDriver().switchTo().window(\"").append(escapeTypeScriptString(windowHandle)).append("\");");
            } else if (windowIndex != null) {
                code.append("const windowHandles = await getDriver().getAllWindowHandles();\n");
                code.append("if (windowHandles.length > ").append(windowIndex).append(") {\n");
                code.append("    await getDriver().switchTo().window(windowHandles[").append(windowIndex).append("]);\n");
                code.append("} else {\n");
                code.append("    throw new Error(`Window index out of bounds: ${").append(windowIndex).append("}`);\n");
                code.append("}");
            } else if (windowTitle != null && !windowTitle.isEmpty()) {
                code.append("// Switch to window by title\n");
                code.append("const targetTitle = \"").append(escapeTypeScriptString(windowTitle)).append("\";\n");
                code.append("const currentHandle = await getDriver().getWindowHandle();\n");
                code.append("let found = false;\n");
                code.append("const windowHandles = await getDriver().getAllWindowHandles();\n");
                code.append("for (const handle of windowHandles) {\n");
                code.append("    await getDriver().switchTo().window(handle);\n");
                code.append("    const title = await getDriver().getTitle();\n");
                code.append("    if (title === targetTitle) {\n");
                code.append("        found = true;\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
                code.append("if (!found) {\n");
                code.append("    await getDriver().switchTo().window(currentHandle);\n");
                code.append("    throw new Error(`Window with title '${targetTitle}' not found`);\n");
                code.append("}");
            } else if (windowUrl != null && !windowUrl.isEmpty()) {
                code.append("// Switch to window by URL\n");
                code.append("const targetUrl = \"").append(escapeTypeScriptString(windowUrl)).append("\";\n");
                code.append("const currentHandle = await getDriver().getWindowHandle();\n");
                code.append("let found = false;\n");
                code.append("const windowHandles = await getDriver().getAllWindowHandles();\n");
                code.append("for (const handle of windowHandles) {\n");
                code.append("    await getDriver().switchTo().window(handle);\n");
                code.append("    const url = await getDriver().getCurrentUrl();\n");
                code.append("    if (url === targetUrl) {\n");
                code.append("        found = true;\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
                code.append("if (!found) {\n");
                code.append("    await getDriver().switchTo().window(currentHandle);\n");
                code.append("    throw new Error(`Window with URL '${targetUrl}' not found`);\n");
                code.append("}");
            } else {
                code.append("// No window identifier specified");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (windowIndex != null) {
                code.append("const pages = getContext().pages();\n");
                code.append("if (pages.length > ").append(windowIndex).append(") {\n");
                code.append("    await setPage(pages[").append(windowIndex).append("]);\n");
                code.append("} else {\n");
                code.append("    throw new Error(`Page index out of bounds: ${").append(windowIndex).append("}`);\n");
                code.append("}");
            } else if (windowTitle != null && !windowTitle.isEmpty()) {
                code.append("// Switch to page by title\n");
                code.append("const targetTitle = \"").append(escapeTypeScriptString(windowTitle)).append("\";\n");
                code.append("let found = false;\n");
                code.append("const pages = getContext().pages();\n");
                code.append("for (const page of pages) {\n");
                code.append("    const title = await page.title();\n");
                code.append("    if (title === targetTitle) {\n");
                code.append("        await setPage(page);\n");
                code.append("        found = true;\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
                code.append("if (!found) {\n");
                code.append("    throw new Error(`Page with title '${targetTitle}' not found`);\n");
                code.append("}");
            } else if (windowUrl != null && !windowUrl.isEmpty()) {
                code.append("// Switch to page by URL\n");
                code.append("const targetUrl = \"").append(escapeTypeScriptString(windowUrl)).append("\";\n");
                code.append("let found = false;\n");
                code.append("const pages = getContext().pages();\n");
                code.append("for (const page of pages) {\n");
                code.append("    const url = page.url();\n");
                code.append("    if (url === targetUrl) {\n");
                code.append("        await setPage(page);\n");
                code.append("        found = true;\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
                code.append("if (!found) {\n");
                code.append("    throw new Error(`Page with URL '${targetUrl}' not found`);\n");
                code.append("}");
            } else {
                code.append("// No page identifier specified");
            }
        }
    }
    
    /**
     * Generate Java code for an execute script action.
     */
    private void generateJavaExecuteScriptCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String script = (String) actionConfig.getProperty("script");
        List<String> arguments = (List<String>) actionConfig.getProperty("arguments");
        String resultVariable = (String) actionConfig.getProperty("resultVariable");
        
        code.append("// Execute JavaScript\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            code.append("JavaScriptExecutor jsExecutor = (JavaScriptExecutor) getDriver();\n");
            
            if (arguments != null && !arguments.isEmpty()) {
                code.append("Object[] scriptArgs = new Object[] {");
                for (int i = 0; i < arguments.size(); i++) {
                    if (i > 0) {
                        code.append(", ");
                    }
                    String arg = arguments.get(i);
                    if (arg.startsWith("element:")) {
                        String[] parts = arg.split(":", 2);
                        if (parts.length == 2) {
                            String[] locatorParts = parts[1].split("=", 2);
                            if (locatorParts.length == 2) {
                                String locatorType = locatorParts[0];
                                String locator = locatorParts[1];
                                code.append("getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(").getWebElement()");
                            } else {
                                code.append("null");
                            }
                        } else {
                            code.append("null");
                        }
                    } else if (arg.equals("true") || arg.equals("false")) {
                        code.append(arg);
                    } else if (arg.matches("-?\\d+")) {
                        code.append(arg);
                    } else if (arg.matches("-?\\d+\\.\\d+")) {
                        code.append(arg);
                    } else {
                        code.append("\"").append(escapeJavaString(arg)).append("\"");
                    }
                }
                code.append("};\n");
                
                if (resultVariable != null && !resultVariable.isEmpty()) {
                    code.append("Object result = jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\", scriptArgs);\n");
                    code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(resultVariable)).append("\", result);");
                } else {
                    code.append("jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\", scriptArgs);");
                }
            } else {
                if (resultVariable != null && !resultVariable.isEmpty()) {
                    code.append("Object result = jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\");\n");
                    code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(resultVariable)).append("\", result);");
                } else {
                    code.append("jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\");");
                }
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (arguments != null && !arguments.isEmpty()) {
                code.append("Map<String, Object> scriptArgs = new HashMap<>();\n");
                for (int i = 0; i < arguments.size(); i++) {
                    String arg = arguments.get(i);
                    String argName = "arg" + i;
                    if (arg.startsWith("element:")) {
                        String[] parts = arg.split(":", 2);
                        if (parts.length == 2) {
                            String[] locatorParts = parts[1].split("=", 2);
                            if (locatorParts.length == 2) {
                                String locatorType = locatorParts[0];
                                String locator = locatorParts[1];
                                code.append("scriptArgs.put(\"").append(argName).append("\", getCSElement(")
                                        .append(getLocatorCode(locatorType, locator, LanguageType.JAVA))
                                        .append(").getPlaywrightElement());\n");
                            } else {
                                code.append("scriptArgs.put(\"").append(argName).append("\", null);\n");
                            }
                        } else {
                            code.append("scriptArgs.put(\"").append(argName).append("\", null);\n");
                        }
                    } else if (arg.equals("true") || arg.equals("false")) {
                        code.append("scriptArgs.put(\"").append(argName).append("\", ").append(arg).append(");\n");
                    } else if (arg.matches("-?\\d+")) {
                        code.append("scriptArgs.put(\"").append(argName).append("\", ").append(arg).append(");\n");
                    } else if (arg.matches("-?\\d+\\.\\d+")) {
                        code.append("scriptArgs.put(\"").append(argName).append("\", ").append(arg).append(");\n");
                    } else {
                        code.append("scriptArgs.put(\"").append(argName).append("\", \"").append(escapeJavaString(arg)).append("\");\n");
                    }
                }
                
                // Modify script to use named arguments
                StringBuilder scriptWithArgs = new StringBuilder("(args) => {\n");
                for (int i = 0; i < arguments.size(); i++) {
                    String argName = "arg" + i;
                    scriptWithArgs.append("    const ").append(argName).append(" = args.").append(argName).append(";\n");
                }
                scriptWithArgs.append("    return (function() {\n        ").append(script.replace("\n", "\n        ")).append("\n    })();\n");
                scriptWithArgs.append("}");
                
                if (resultVariable != null && !resultVariable.isEmpty()) {
                    code.append("Object result = getPage().evaluate(\"").append(escapeJavaString(scriptWithArgs.toString())).append("\", scriptArgs);\n");
                    code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(resultVariable)).append("\", result);");
                } else {
                    code.append("getPage().evaluate(\"").append(escapeJavaString(scriptWithArgs.toString())).append("\", scriptArgs);");
                }
            } else {
                if (resultVariable != null && !resultVariable.isEmpty()) {
                    code.append("Object result = getPage().evaluate(\"").append(escapeJavaString(script)).append("\");\n");
                    code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(resultVariable)).append("\", result);");
                } else {
                    code.append("getPage().evaluate(\"").append(escapeJavaString(script)).append("\");");
                }
            }
        }
    }
    
    /**
     * Generate TypeScript code for an execute script action.
     */
    private void generateTypeScriptExecuteScriptCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String script = (String) actionConfig.getProperty("script");
        List<String> arguments = (List<String>) actionConfig.getProperty("arguments");
        String resultVariable = (String) actionConfig.getProperty("resultVariable");
        
        code.append("// Execute JavaScript\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            code.append("const jsExecutor = getDriver() as unknown as IJavaScriptExecutor;\n");
            
            if (arguments != null && !arguments.isEmpty()) {
                code.append("const scriptArgs = [");
                for (int i = 0; i < arguments.size(); i++) {
                    if (i > 0) {
                        code.append(", ");
                    }
                    String arg = arguments.get(i);
                    if (arg.startsWith("element:")) {
                        String[] parts = arg.split(":", 2);
                        if (parts.length == 2) {
                            String[] locatorParts = parts[1].split("=", 2);
                            if (locatorParts.length == 2) {
                                String locatorType = locatorParts[0];
                                String locator = locatorParts[1];
                                code.append("await getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(").getWebElement()");
                            } else {
                                code.append("null");
                            }
                        } else {
                            code.append("null");
                        }
                    } else if (arg.equals("true") || arg.equals("false")) {
                        code.append(arg);
                    } else if (arg.matches("-?\\d+")) {
                        code.append(arg);
                    } else if (arg.matches("-?\\d+\\.\\d+")) {
                        code.append(arg);
                    } else {
                        code.append("\"").append(escapeTypeScriptString(arg)).append("\"");
                    }
                }
                code.append("];\n");
                
                if (resultVariable != null && !resultVariable.isEmpty()) {
                    code.append("const result = await jsExecutor.executeScript(`").append(escapeTypeScriptString(script)).append("`, ...scriptArgs);\n");
                    code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(resultVariable)).append("\", result);");
                } else {
                    code.append("await jsExecutor.executeScript(`").append(escapeTypeScriptString(script)).append("`, ...scriptArgs);");
                }
            } else {
                if (resultVariable != null && !resultVariable.isEmpty()) {
                    code.append("const result = await jsExecutor.executeScript(`").append(escapeTypeScriptString(script)).append("`);\n");
                    code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(resultVariable)).append("\", result);");
                } else {
                    code.append("await jsExecutor.executeScript(`").append(escapeTypeScriptString(script)).append("`);");
                }
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (arguments != null && !arguments.isEmpty()) {
                code.append("const scriptArgs: Record<string, any> = {};\n");
                for (int i = 0; i < arguments.size(); i++) {
                    String arg = arguments.get(i);
                    String argName = "arg" + i;
                    if (arg.startsWith("element:")) {
                        String[] parts = arg.split(":", 2);
                        if (parts.length == 2) {
                            String[] locatorParts = parts[1].split("=", 2);
                            if (locatorParts.length == 2) {
                                String locatorType = locatorParts[0];
                                String locator = locatorParts[1];
                                code.append("scriptArgs[\"").append(argName).append("\"] = await getCSElement(")
                                        .append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT))
                                        .append(").getPlaywrightElement();\n");
                            } else {
                                code.append("scriptArgs[\"").append(argName).append("\"] = null;\n");
                            }
                        } else {
                            code.append("scriptArgs[\"").append(argName).append("\"] = null;\n");
                        }
                    } else if (arg.equals("true") || arg.equals("false")) {
                        code.append("scriptArgs[\"").append(argName).append("\"] = ").append(arg).append(";\n");
                    } else if (arg.matches("-?\\d+")) {
                        code.append("scriptArgs[\"").append(argName).append("\"] = ").append(arg).append(";\n");
                    } else if (arg.matches("-?\\d+\\.\\d+")) {
                        code.append("scriptArgs[\"").append(argName).append("\"] = ").append(arg).append(";\n");
                    } else {
                        code.append("scriptArgs[\"").append(argName).append("\"] = \"").append(escapeTypeScriptString(arg)).append("\";\n");
                    }
                }
                
                // Modify script to use named arguments
                StringBuilder scriptWithArgs = new StringBuilder("(args) => {\n");
                for (int i = 0; i < arguments.size(); i++) {
                    String argName = "arg" + i;
                    scriptWithArgs.append("    const ").append(argName).append(" = args.").append(argName).append(";\n");
                }
                scriptWithArgs.append("    return (function() {\n        ").append(script.replace("\n", "\n        ")).append("\n    })();\n");
                scriptWithArgs.append("}");
                
                if (resultVariable != null && !resultVariable.isEmpty()) {
                    code.append("const result = await getPage().evaluate(`").append(escapeTypeScriptString(scriptWithArgs.toString())).append("`, scriptArgs);\n");
                    code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(resultVariable)).append("\", result);");
                } else {
                    code.append("await getPage().evaluate(`").append(escapeTypeScriptString(scriptWithArgs.toString())).append("`, scriptArgs);");
                }
            } else {
                if (resultVariable != null && !resultVariable.isEmpty()) {
                    code.append("const result = await getPage().evaluate(`").append(escapeTypeScriptString(script)).append("`);\n");
                    code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(resultVariable)).append("\", result);");
                } else {
                    code.append("await getPage().evaluate(`").append(escapeTypeScriptString(script)).append("`);");
                }
            }
        }
    }


/**
     * Generate Java code for a file upload action.
     */
    private void generateJavaFileUploadCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String filePath = (String) actionConfig.getProperty("filePath");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Upload file\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.PRESENT);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("element.uploadFile(\"").append(escapeJavaString(filePath)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("element.uploadFile(\"").append(escapeJavaString(filePath)).append("\");");
        }
    }
    
    /**
     * Generate TypeScript code for a file upload action.
     */
    private void generateTypeScriptFileUploadCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String filePath = (String) actionConfig.getProperty("filePath");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Upload file\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.PRESENT);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("await element.uploadFile(\"").append(escapeTypeScriptString(filePath)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("await element.uploadFile(\"").append(escapeTypeScriptString(filePath)).append("\");");
        }
    }
    
    /**
     * Generate Java code for a key press action.
     */
    private void generateJavaKeyPressCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String key = (String) actionConfig.getProperty("key");
        List<String> modifiers = (List<String>) actionConfig.getProperty("modifiers");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Press key\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            // Import Keys
            code.append("import org.openqa.selenium.Keys;\n\n");
            
            // Generate modifier keys
            StringBuilder keysToSend = new StringBuilder();
            if (modifiers != null && !modifiers.isEmpty()) {
                for (String modifier : modifiers) {
                    keysToSend.append("Keys.").append(modifier.toUpperCase()).append(" + ");
                }
            }
            
            // Add main key
            if (key.length() == 1) {
                keysToSend.append("\"").append(escapeJavaString(key)).append("\"");
            } else {
                keysToSend.append("Keys.").append(key.toUpperCase());
            }
            
            // Generate key press action
            if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
                code.append("element.sendKeys(").append(keysToSend).append(");");
            } else {
                code.append("Actions actions = new Actions(getDriver());\n");
                code.append("actions.sendKeys(").append(keysToSend).append(").perform();");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            // Map key names to Playwright key names if needed
            String playwrightKey = key;
            if (key.equalsIgnoreCase("ENTER")) {
                playwrightKey = "Enter";
            } else if (key.equalsIgnoreCase("TAB")) {
                playwrightKey = "Tab";
            } else if (key.equalsIgnoreCase("ESCAPE")) {
                playwrightKey = "Escape";
            } else if (key.equalsIgnoreCase("BACKSPACE")) {
                playwrightKey = "Backspace";
            } else if (key.equalsIgnoreCase("DELETE")) {
                playwrightKey = "Delete";
            } else if (key.equalsIgnoreCase("ARROW_DOWN")) {
                playwrightKey = "ArrowDown";
            } else if (key.equalsIgnoreCase("ARROW_UP")) {
                playwrightKey = "ArrowUp";
            } else if (key.equalsIgnoreCase("ARROW_LEFT")) {
                playwrightKey = "ArrowLeft";
            } else if (key.equalsIgnoreCase("ARROW_RIGHT")) {
                playwrightKey = "ArrowRight";
            }
            
            // Generate modifier options
            if (modifiers != null && !modifiers.isEmpty()) {
                code.append("KeyboardModifiers modifiers = new KeyboardModifiers();\n");
                for (String modifier : modifiers) {
                    if (modifier.equalsIgnoreCase("SHIFT")) {
                        code.append("modifiers.setShift(true);\n");
                    } else if (modifier.equalsIgnoreCase("CONTROL")) {
                        code.append("modifiers.setControl(true);\n");
                    } else if (modifier.equalsIgnoreCase("ALT")) {
                        code.append("modifiers.setAlt(true);\n");
                    } else if (modifier.equalsIgnoreCase("META")) {
                        code.append("modifiers.setMeta(true);\n");
                    }
                }
            }
            
            // Generate key press action
            if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("element.press(\"").append(escapeJavaString(playwrightKey)).append("\", modifiers);");
                } else {
                    code.append("element.press(\"").append(escapeJavaString(playwrightKey)).append("\");");
                }
            } else {
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("getPage().keyboard().press(\"").append(escapeJavaString(playwrightKey)).append("\", modifiers);");
                } else {
                    code.append("getPage().keyboard().press(\"").append(escapeJavaString(playwrightKey)).append("\");");
                }
            }
        }
    }
    
    /**
     * Generate TypeScript code for a key press action.
     */
    private void generateTypeScriptKeyPressCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String key = (String) actionConfig.getProperty("key");
        List<String> modifiers = (List<String>) actionConfig.getProperty("modifiers");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Press key\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            // Import Keys
            code.append("import { Key } from 'selenium-webdriver';\n\n");
            
            // Generate modifier keys
            StringBuilder keysToSend = new StringBuilder();
            if (modifiers != null && !modifiers.isEmpty()) {
                for (String modifier : modifiers) {
                    keysToSend.append("Key.").append(modifier.toUpperCase()).append(" + ");
                }
            }
            
            // Add main key
            if (key.length() == 1) {
                keysToSend.append("\"").append(escapeTypeScriptString(key)).append("\"");
            } else {
                keysToSend.append("Key.").append(key.toUpperCase());
            }
            
            // Generate key press action
            if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                code.append("await element.sendKeys(").append(keysToSend).append(");");
            } else {
                code.append("const actions = getDriver().actions();\n");
                code.append("await actions.sendKeys(").append(keysToSend).append(").perform();");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            // Map key names to Playwright key names if needed
            String playwrightKey = key;
            if (key.equalsIgnoreCase("ENTER")) {
                playwrightKey = "Enter";
            } else if (key.equalsIgnoreCase("TAB")) {
                playwrightKey = "Tab";
            } else if (key.equalsIgnoreCase("ESCAPE")) {
                playwrightKey = "Escape";
            } else if (key.equalsIgnoreCase("BACKSPACE")) {
                playwrightKey = "Backspace";
            } else if (key.equalsIgnoreCase("DELETE")) {
                playwrightKey = "Delete";
            } else if (key.equalsIgnoreCase("ARROW_DOWN")) {
                playwrightKey = "ArrowDown";
            } else if (key.equalsIgnoreCase("ARROW_UP")) {
                playwrightKey = "ArrowUp";
            } else if (key.equalsIgnoreCase("ARROW_LEFT")) {
                playwrightKey = "ArrowLeft";
            } else if (key.equalsIgnoreCase("ARROW_RIGHT")) {
                playwrightKey = "ArrowRight";
            }
            
            // Generate modifier options
            if (modifiers != null && !modifiers.isEmpty()) {
                code.append("const modifiers: KeyboardModifiers = {};\n");
                for (String modifier : modifiers) {
                    if (modifier.equalsIgnoreCase("SHIFT")) {
                        code.append("modifiers.shift = true;\n");
                    } else if (modifier.equalsIgnoreCase("CONTROL")) {
                        code.append("modifiers.control = true;\n");
                    } else if (modifier.equalsIgnoreCase("ALT")) {
                        code.append("modifiers.alt = true;\n");
                    } else if (modifier.equalsIgnoreCase("META")) {
                        code.append("modifiers.meta = true;\n");
                    }
                }
            }
            
            // Generate key press action
            if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("await element.press(\"").append(escapeTypeScriptString(playwrightKey)).append("\", modifiers);");
                } else {
                    code.append("await element.press(\"").append(escapeTypeScriptString(playwrightKey)).append("\");");
                }
            } else {
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("await getPage().keyboard.press(\"").append(escapeTypeScriptString(playwrightKey)).append("\", modifiers);");
                } else {
                    code.append("await getPage().keyboard.press(\"").append(escapeTypeScriptString(playwrightKey)).append("\");");
                }
            }
        }
    }
    
    /**
     * Generate Java code for a scroll action.
     */
    private void generateJavaScrollCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer x = (Integer) actionConfig.getProperty("x");
        Integer y = (Integer) actionConfig.getProperty("y");
        String scrollType = (String) actionConfig.getProperty("scrollType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Scroll page or element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            code.append("JavaScriptExecutor jsExecutor = (JavaScriptExecutor) getDriver();\n");
            
            if (scrollType.equals("PIXEL")) {
                if (x != null && y != null) {
                    code.append("jsExecutor.executeScript(\"window.scrollBy(").append(x).append(", ").append(y).append(")\");");
                } else {
                    code.append("// Invalid pixel scroll - missing coordinates");
                }
            } else if (scrollType.equals("ELEMENT")) {
                if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                    code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.PRESENT);\n");
                    code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                    code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
                    code.append("jsExecutor.executeScript(\"arguments[0].scrollIntoView(true);\", element.getWebElement());");
                } else {
                    code.append("// Invalid element scroll - missing element locator");
                }
            } else if (scrollType.equals("TOP")) {
                code.append("jsExecutor.executeScript(\"window.scrollTo(0, 0)\");");
            } else if (scrollType.equals("BOTTOM")) {
                code.append("jsExecutor.executeScript(\"window.scrollTo(0, document.body.scrollHeight)\");");
            } else if (scrollType.equals("CENTER")) {
                if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                    code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.PRESENT);\n");
                    code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                    code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
                    code.append("jsExecutor.executeScript(\"\"\"\n");
                    code.append("    const element = arguments[0];\n");
                    code.append("    const elementRect = element.getBoundingClientRect();\n");
                    code.append("    const absoluteElementTop = elementRect.top + window.pageYOffset;\n");
                    code.append("    const middle = absoluteElementTop - (window.innerHeight / 2);\n");
                    code.append("    window.scrollTo(0, middle);\n");
                    code.append("    \"\"\", element.getWebElement());");
                } else {
                    code.append("// Invalid center scroll - missing element locator");
                }
            } else {
                code.append("// Unsupported scroll type: ").append(scrollType);
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (scrollType.equals("PIXEL")) {
                if (x != null && y != null) {
                    code.append("getPage().evaluate(\"window.scrollBy(").append(x).append(", ").append(y).append(")\");");
                } else {
                    code.append("// Invalid pixel scroll - missing coordinates");
                }
            } else if (scrollType.equals("ELEMENT")) {
                if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                    code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                    code.append("element.scrollIntoView();");
                } else {
                    code.append("// Invalid element scroll - missing element locator");
                }
            } else if (scrollType.equals("TOP")) {
                code.append("getPage().evaluate(\"window.scrollTo(0, 0)\");");
            } else if (scrollType.equals("BOTTOM")) {
                code.append("getPage().evaluate(\"window.scrollTo(0, document.body.scrollHeight)\");");
            } else if (scrollType.equals("CENTER")) {
                if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                    code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                    code.append("element.scrollIntoViewIfNeeded();");
                } else {
                    code.append("// Invalid center scroll - missing element locator");
                }
            } else {
                code.append("// Unsupported scroll type: ").append(scrollType);
            }
        }
    }
    
    /**
     * Generate TypeScript code for a scroll action.
     */
    private void generateTypeScriptScrollCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer x = (Integer) actionConfig.getProperty("x");
        Integer y = (Integer) actionConfig.getProperty("y");
        String scrollType = (String) actionConfig.getProperty("scrollType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Scroll page or element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            code.append("const jsExecutor = getDriver() as unknown as IJavaScriptExecutor;\n");
            
            if (scrollType.equals("PIXEL")) {
                if (x != null && y != null) {
                    code.append("await jsExecutor.executeScript(`window.scrollBy(").append(x).append(", ").append(y).append(")`)");
                } else {
                    code.append("// Invalid pixel scroll - missing coordinates");
                }
            } else if (scrollType.equals("ELEMENT")) {
                if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                    code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.PRESENT);\n");
                    code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                    code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                    code.append("await jsExecutor.executeScript('arguments[0].scrollIntoView(true);', await element.getWebElement());");
                } else {
                    code.append("// Invalid element scroll - missing element locator");
                }
            } else if (scrollType.equals("TOP")) {
                code.append("await jsExecutor.executeScript('window.scrollTo(0, 0)');");
            } else if (scrollType.equals("BOTTOM")) {
                code.append("await jsExecutor.executeScript('window.scrollTo(0, document.body.scrollHeight)');");
            } else if (scrollType.equals("CENTER")) {
                if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                    code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.PRESENT);\n");
                    code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                    code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                    code.append("await jsExecutor.executeScript(`\n");
                    code.append("    const element = arguments[0];\n");
                    code.append("    const elementRect = element.getBoundingClientRect();\n");
                    code.append("    const absoluteElementTop = elementRect.top + window.pageYOffset;\n");
                    code.append("    const middle = absoluteElementTop - (window.innerHeight / 2);\n");
                    code.append("    window.scrollTo(0, middle);\n");
                    code.append("`, await element.getWebElement());");
                } else {
                    code.append("// Invalid center scroll - missing element locator");
                }
            } else {
                code.append("// Unsupported scroll type: ").append(scrollType);
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (scrollType.equals("PIXEL")) {
                if (x != null && y != null) {
                    code.append("await getPage().evaluate(`window.scrollBy(").append(x).append(", ").append(y).append(")`);");
                } else {
                    code.append("// Invalid pixel scroll - missing coordinates");
                }
            } else if (scrollType.equals("ELEMENT")) {
                if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                    code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                    code.append("await element.scrollIntoView();");
                } else {
                    code.append("// Invalid element scroll - missing element locator");
                }
            } else if (scrollType.equals("TOP")) {
                code.append("await getPage().evaluate('window.scrollTo(0, 0)');");
            } else if (scrollType.equals("BOTTOM")) {
                code.append("await getPage().evaluate('window.scrollTo(0, document.body.scrollHeight)');");
            } else if (scrollType.equals("CENTER")) {
                if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                    code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                    code.append("await element.scrollIntoViewIfNeeded();");
                } else {
                    code.append("// Invalid center scroll - missing element locator");
                }
            } else {
                code.append("// Unsupported scroll type: ").append(scrollType);
            }
        }
    }
    
    /**
     * Get locator code for a specific locator type and value.
     *
     * @param locatorType Locator type
     * @param locator Locator value
     * @param languageType Language type
     * @return Locator code
     */
    private String getLocatorCode(String locatorType, String locator, LanguageType languageType) {
        if (locatorType == null || locator == null) {
            return null;
        }
        
        StringBuilder code = new StringBuilder();
        
        if (languageType == LanguageType.JAVA) {
            code.append("By.");
            
            if (locatorType.equals("CSS")) {
                code.append("cssSelector(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("XPATH")) {
                code.append("xpath(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("ID")) {
                code.append("id(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("NAME")) {
                code.append("name(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("CLASS_NAME")) {
                code.append("className(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("TAG_NAME")) {
                code.append("tagName(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("LINK_TEXT")) {
                code.append("linkText(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("PARTIAL_LINK_TEXT")) {
                code.append("partialLinkText(\"").append(escapeJavaString(locator)).append("\")");
            } else {
                code.append("cssSelector(\"").append(escapeJavaString(locator)).append("\")");
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            code.append("By.");
            
            if (locatorType.equals("CSS")) {
                code.append("css(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("XPATH")) {
                code.append("xpath(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("ID")) {
                code.append("id(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("NAME")) {
                code.append("name(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("CLASS_NAME")) {
                code.append("className(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("TAG_NAME")) {
                code.append("tagName(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("LINK_TEXT")) {
                code.append("linkText(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("PARTIAL_LINK_TEXT")) {
                code.append("partialLinkText(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else {
                code.append("css(\"").append(escapeTypeScriptString(locator)).append("\")");
            }
        }
        
        return code.toString();
    }
    
    /**
     * Escape a string for Java code.
     *
     * @param str String to escape
     * @return Escaped string
     */
    private String escapeJavaString(String str) {
        if (str == null) {
            return "";
        }
        
        return str.replace("\\", "\\\\")
                 .replace("\"", "\\\"")
                 .replace("\n", "\\n")
                 .replace("\r", "\\r")
                 .replace("\t", "\\t");
    }
    
    /**
     * Escape a string for TypeScript code.
     *
     * @param str String to escape
     * @return Escaped string
     */
    private String escapeTypeScriptString(String str) {
        if (str == null) {
            return "";
        }
        
        return str.replace("\\", "\\\\")
                 .replace("\"", "\\\"")
                 .replace("\n", "\\n")
                 .replace("\r", "\\r")
                 .replace("\t", "\\t")
                 .replace("`", "\\`")
                 .replace("${", "\\${");
    }
    
    @Override
    public List<ActionConfig> getActionTemplates(ActionType actionType, FrameworkType frameworkType,
            LanguageType languageType, TestType testType) {
        
        LOGGER.debug("Getting action templates for action type: {}, framework: {}, language: {}, test type: {}", 
                actionType, frameworkType, languageType, testType);
        
        // Filter templates by type, framework, language, and test type
        return templateCache.values().stream()
                .filter(template -> template.getActionType() == actionType)
                .filter(template -> template.getFrameworkType() == null || template.getFrameworkType() == frameworkType)
                .filter(template -> template.getLanguageType() == null || template.getLanguageType() == languageType)
                .filter(template -> template.getTestType() == null || template.getTestType() == testType)
                .collect(Collectors.toList());
    }
    
    @Override
    public ActionConfig createActionTemplate(ActionConfig actionConfig) {
        LOGGER.info("Creating action template: {}", actionConfig.getTemplateName());
        
        // Validate template
        if (actionConfig.getTemplateName() == null || actionConfig.getTemplateName().isEmpty()) {
            LOGGER.error("Template name is required");
            return null;
        }
        
        // Generate template ID if not set
        if (actionConfig.getId() == null || actionConfig.getId().isEmpty()) {
            actionConfig.setId(UUID.randomUUID().toString());
        }
        
        // Set creation timestamp
        actionConfig.setTemplateCreationTime(LocalDateTime.now());
        
        try {
            // Determine file path based on template metadata
            String fileName = actionConfig.getActionType().name().toLowerCase() + "_" 
                    + actionConfig.getTemplateName().replaceAll("[^a-zA-Z0-9]", "_") + ".json";
            
            // Create subdirectories if needed
            StringBuilder subDirPath = new StringBuilder();
            if (actionConfig.getFrameworkType() != null) {
                subDirPath.append(actionConfig.getFrameworkType().name().toLowerCase()).append(File.separator);
            }
            if (actionConfig.getLanguageType() != null) {
                subDirPath.append(actionConfig.getLanguageType().name().toLowerCase()).append(File.separator);
            }
            if (actionConfig.getTestType() != null) {
                subDirPath.append(actionConfig.getTestType().name().toLowerCase()).append(File.separator);
            }
            
            Path dirPath = Paths.get(templatesDirectory, subDirPath.toString());
            if (!Files.exists(dirPath)) {
                Files.createDirectories(dirPath);
            }
            
            // Save template
            File templateFile = new File(dirPath.toFile(), fileName);
            storageService.writeObject(templateFile, actionConfig);
            
            // Add to cache
            templateCache.put(actionConfig.getId(), actionConfig);
            
            LOGGER.info("Template saved to: {}", templateFile.getAbsolutePath());
            return actionConfig;
        } catch (Exception e) {
            LOGGER.error("Failed to create template: {}", e.getMessage(), e);
            return null;
        }
    }
    
    @Override
    public boolean deleteActionTemplate(String templateId) {
        if (templateId == null || templateId.isEmpty()) {
            LOGGER.error("Template ID is required");
            return false;
        }
        
        // Get template from cache
        ActionConfig template = templateCache.get(templateId);
        if (template == null) {
            LOGGER.warn("Template not found: {}", templateId);
            return false;
        }
        
        try {
            // Determine file path based on template metadata
            String fileName = template.getActionType().name().toLowerCase() + "_" 
                    + template.getTemplateName().replaceAll("[^a-zA-Z0-9]", "_") + ".json";
            
            StringBuilder subDirPath = new StringBuilder();
            if (template.getFrameworkType() != null) {
                subDirPath.append(template.getFrameworkType().name().toLowerCase()).append(File.separator);
            }
            if (template.getLanguageType() != null) {
                subDirPath.append(template.getLanguageType().name().toLowerCase()).append(File.separator);
            }
            if (template.getTestType() != null) {
                subDirPath.append(template.getTestType().name().toLowerCase()).append(File.separator);
            }
            
            File templateFile = new File(templatesDirectory, subDirPath.toString() + fileName);
            
            // Delete file if it exists
            if (templateFile.exists()) {
                boolean deleted = templateFile.delete();
                if (!deleted) {
                    LOGGER.warn("Failed to delete template file: {}", templateFile.getAbsolutePath());
                }
            }
            
            // Remove from cache
            templateCache.remove(templateId);
            
            LOGGER.info("Template deleted: {}", templateId);
            return true;
        } catch (Exception e) {
            LOGGER.error("Failed to delete template: {}", e.getMessage(), e);
            return false;
        }
    }
    
    @Override
    public List<Map<String, Object>> getAssertionTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting assertion types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> assertionTypes = new ArrayList<>();
        
        // Element assertions
        Map<String, Object> elementPresent = new HashMap<>();
        elementPresent.put("id", "ELEMENT_PRESENT");
        elementPresent.put("name", "Element Present");
        elementPresent.put("description", "Assert that element is present in the DOM");
        elementPresent.put("category", "Element");
        assertionTypes.add(elementPresent);
        
        Map<String, Object> elementVisible = new HashMap<>();
        elementVisible.put("id", "ELEMENT_VISIBLE");
        elementVisible.put("name", "Element Visible");
        elementVisible.put("description", "Assert that element is visible");
        elementVisible.put("category", "Element");
        assertionTypes.add(elementVisible);
        
        Map<String, Object> elementEnabled = new HashMap<>();
        elementEnabled.put("id", "ELEMENT_ENABLED");
        elementEnabled.put("name", "Element Enabled");
        elementEnabled.put("description", "Assert that element is enabled");
        elementEnabled.put("category", "Element");
        assertionTypes.add(elementEnabled);
        
        Map<String, Object> elementSelected = new HashMap<>();
        elementSelected.put("id", "ELEMENT_SELECTED");
        elementSelected.put("name", "Element Selected");
        elementSelected.put("description", "Assert that element is selected");
        elementSelected.put("category", "Element");
        assertionTypes.add(elementSelected);
        
        Map<String, Object> elementTextEquals = new HashMap<>();
        elementTextEquals.put("id", "ELEMENT_TEXT_EQUALS");
        elementTextEquals.put("name", "Element Text Equals");
        elementTextEquals.put("description", "Assert that element text equals expected value");
        elementTextEquals.put("category", "Element");
        assertionTypes.add(elementTextEquals);
        
        Map<String, Object> elementTextContains = new HashMap<>();
        elementTextContains.put("id", "ELEMENT_TEXT_CONTAINS");
        elementTextContains.put("name", "Element Text Contains");
        elementTextContains.put("description", "Assert that element text contains expected value");
        elementTextContains.put("category", "Element");
        assertionTypes.add(elementTextContains);
        
        Map<String, Object> elementValueEquals = new HashMap<>();
        elementValueEquals.put("id", "ELEMENT_VALUE_EQUALS");
        elementValueEquals.put("name", "Element Value Equals");
        elementValueEquals.put("description", "Assert that element value equals expected value");
        elementValueEquals.put("category", "Element");
        assertionTypes.add(elementValueEquals);
        
        Map<String, Object> elementAttributeEquals = new HashMap<>();
        elementAttributeEquals.put("id", "ELEMENT_ATTRIBUTE_EQUALS");
        elementAttributeEquals.put("name", "Element Attribute Equals");
        elementAttributeEquals.put("description", "Assert that element attribute equals expected value");
        elementAttributeEquals.put("category", "Element");
        assertionTypes.add(elementAttributeEquals);
        
        Map<String, Object> elementCountEquals = new HashMap<>();
        elementCountEquals.put("id", "ELEMENT_COUNT_EQUALS");
        elementCountEquals.put("name", "Element Count Equals");
        elementCountEquals.put("description", "Assert that number of elements equals expected value");
        elementCountEquals.put("category", "Element");
        assertionTypes.add(elementCountEquals);
        
        // Value assertions
        Map<String, Object> valueEquals = new HashMap<>();
        valueEquals.put("id", "VALUE_EQUALS");
        valueEquals.put("name", "Value Equals");
        valueEquals.put("description", "Assert that value equals expected value");
        valueEquals.put("category", "Value");
        assertionTypes.add(valueEquals);
        
        Map<String, Object> valueNotEquals = new HashMap<>();
        valueNotEquals.put("id", "VALUE_NOT_EQUALS");
        valueNotEquals.put("name", "Value Not Equals");
        valueNotEquals.put("description", "Assert that value does not equal expected value");
        valueNotEquals.put("category", "Value");
        assertionTypes.add(valueNotEquals);
        
        Map<String, Object> valueGreaterThan = new HashMap<>();
        valueGreaterThan.put("id", "VALUE_GREATER_THAN");
        valueGreaterThan.put("name", "Value Greater Than");
        valueGreaterThan.put("description", "Assert that value is greater than expected value");
        valueGreaterThan.put("category", "Value");
        assertionTypes.add(valueGreaterThan);
        
        Map<String, Object> valueLessThan = new HashMap<>();
        valueLessThan.put("id", "VALUE_LESS_THAN");
        valueLessThan.put("name", "Value Less Than");
        valueLessThan.put("description", "Assert that value is less than expected value");
        valueLessThan.put("category", "Value");
        assertionTypes.add(valueLessThan);
        
        Map<String, Object> valueContains = new HashMap<>();
        valueContains.put("id", "VALUE_CONTAINS");
        valueContains.put("name", "Value Contains");
        valueContains.put("description", "Assert that value contains expected value");
        valueContains.put("category", "Value");
        assertionTypes.add(valueContains);
        
        Map<String, Object> valueMatches = new HashMap<>();
        valueMatches.put("id", "VALUE_MATCHES");
        valueMatches.put("name", "Value Matches");
        valueMatches.put("description", "Assert that value matches regular expression");
        valueMatches.put("category", "Value");
        assertionTypes.add(valueMatches);
        
        Map<String, Object> valueEmpty = new HashMap<>();
        valueEmpty.put("id", "VALUE_EMPTY");
        valueEmpty.put("name", "Value Empty");
        valueEmpty.put("description", "Assert that value is empty");
        valueEmpty.put("category", "Value");
        assertionTypes.add(valueEmpty);
        
        Map<String, Object> valueNotEmpty = new HashMap<>();
        valueNotEmpty.put("id", "VALUE_NOT_EMPTY");
        valueNotEmpty.put("name", "Value Not Empty");
        valueNotEmpty.put("description", "Assert that value is not empty");
        valueNotEmpty.put("category", "Value");
        assertionTypes.add(valueNotEmpty);
        
        Map<String, Object> valueNull = new HashMap<>();
        valueNull.put("id", "VALUE_NULL");
        valueNull.put("name", "Value Null");
        valueNull.put("description", "Assert that value is null");
        valueNull.put("category", "Value");
        assertionTypes.add(valueNull);
        
        Map<String, Object> valueNotNull = new HashMap<>();
        valueNotNull.put("id", "VALUE_NOT_NULL");
        valueNotNull.put("name", "Value Not Null");
        valueNotNull.put("description", "Assert that value is not null");
        valueNotNull.put("category", "Value");
        assertionTypes.add(valueNotNull);
        
        // Boolean assertions
        Map<String, Object> booleanTrue = new HashMap<>();
        booleanTrue.put("id", "BOOLEAN_TRUE");
        booleanTrue.put("name", "Boolean True");
        booleanTrue.put("description", "Assert that boolean value is true");
        booleanTrue.put("category", "Boolean");
        assertionTypes.add(booleanTrue);
        
        Map<String, Object> booleanFalse = new HashMap<>();
        booleanFalse.put("id", "BOOLEAN_FALSE");
        booleanFalse.put("name", "Boolean False");
        booleanFalse.put("description", "Assert that boolean value is false");
        booleanFalse.put("category", "Boolean");
        assertionTypes.add(booleanFalse);
        
        // Page assertions
        Map<String, Object> pageTitleEquals = new HashMap<>();
        pageTitleEquals.put("id", "PAGE_TITLE_EQUALS");
        pageTitleEquals.put("name", "Page Title Equals");
        pageTitleEquals.put("description", "Assert that page title equals expected value");
        pageTitleEquals.put("category", "Page");
        assertionTypes.add(pageTitleEquals);
        
        Map<String, Object> pageTitleContains = new HashMap<>();
        pageTitleContains.put("id", "PAGE_TITLE_CONTAINS");
        pageTitleContains.put("name", "Page Title Contains");
        pageTitleContains.put("description", "Assert that page title contains expected value");
        pageTitleContains.put("category", "Page");
        assertionTypes.add(pageTitleContains);
        
        Map<String, Object> pageUrlEquals = new HashMap<>();
        pageUrlEquals.put("id", "PAGE_URL_EQUALS");
        pageUrlEquals.put("name", "Page URL Equals");
        pageUrlEquals.put("description", "Assert that page URL equals expected value");
        pageUrlEquals.put("category", "Page");
        assertionTypes.add(pageUrlEquals);
        
        Map<String, Object> pageUrlContains = new HashMap<>();
        pageUrlContains.put("id", "PAGE_URL_CONTAINS");
        pageUrlContains.put("name", "Page URL Contains");
        pageUrlContains.put("description", "Assert that page URL contains expected value");
        pageUrlContains.put("category", "Page");
        assertionTypes.add(pageUrlContains);
        
        // Custom assertions
        Map<String, Object> custom = new HashMap<>();
        custom.put("id", "CUSTOM");
        custom.put("name", "Custom Assertion");
        custom.put("description", "Custom assertion with user-defined code");
        custom.put("category", "Custom");
        assertionTypes.add(custom);
        
        return assertionTypes;
    }
    
    @Override
    public List<Map<String, Object>> getWaitStrategies(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting wait strategies for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> waitStrategies = new ArrayList<>();
        
        // Element wait strategies
        Map<String, Object> elementVisible = new HashMap<>();
        elementVisible.put("id", "ELEMENT_VISIBLE");
        elementVisible.put("name", "Element Visible");
        elementVisible.put("description", "Wait for element to be visible");
        elementVisible.put("category", "Element");
        waitStrategies.add(elementVisible);
        
        Map<String, Object> elementClickable = new HashMap<>();
        elementClickable.put("id", "ELEMENT_CLICKABLE");
        elementClickable.put("name", "Element Clickable");
        elementClickable.put("description", "Wait for element to be clickable");
        elementClickable.put("category", "Element");
        waitStrategies.add(elementClickable);
        
        Map<String, Object> elementPresent = new HashMap<>();
        elementPresent.put("id", "ELEMENT_PRESENT");
        elementPresent.put("name", "Element Present");
        elementPresent.put("description", "Wait for element to be present in the DOM");
        elementPresent.put("category", "Element");
        waitStrategies.add(elementPresent);
        
        Map<String, Object> elementInvisible = new HashMap<>();
        elementInvisible.put("id", "ELEMENT_INVISIBLE");
        elementInvisible.put("name", "Element Invisible");
        elementInvisible.put("description", "Wait for element to be invisible");
        elementInvisible.put("category", "Element");
        waitStrategies.add(elementInvisible);
        
        Map<String, Object> elementSelected = new HashMap<>();
        elementSelected.put("id", "ELEMENT_SELECTED");
        elementSelected.put("name", "Element Selected");
        elementSelected.put("description", "Wait for element to be selected");
        elementSelected.put("category", "Element");
        waitStrategies.add(elementSelected);
        
        Map<String, Object> elementAttribute = new HashMap<>();
        elementAttribute.put("id", "ELEMENT_ATTRIBUTE");
        elementAttribute.put("name", "Element Attribute");
        elementAttribute.put("description", "Wait for element attribute to have a specific value");
        elementAttribute.put("category", "Element");
        waitStrategies.add(elementAttribute);
        
        Map<String, Object> elementText = new HashMap<>();
        elementText.put("id", "ELEMENT_TEXT");
        elementText.put("name", "Element Text");
        elementText.put("description", "Wait for element to have specific text");
        elementText.put("category", "Element");
        waitStrategies.add(elementText);
        
        // Time wait strategies
        Map<String, Object> fixedTime = new HashMap<>();
        fixedTime.put("id", "FIXED_TIME");
        fixedTime.put("name", "Fixed Time");
        fixedTime.put("description", "Wait for a fixed amount of time");
        fixedTime.put("category", "Time");
        waitStrategies.add(fixedTime);
        
        // Page wait strategies
        Map<String, Object> pageLoad = new HashMap<>();
        pageLoad.put("id", "PAGE_LOAD");
        pageLoad.put("name", "Page Load");
        pageLoad.put("description", "Wait for page to load");
        pageLoad.put("category", "Page");
        waitStrategies.add(pageLoad);
        
        // Script wait strategies
        Map<String, Object> script = new HashMap<>();
        script.put("id", "SCRIPT");
        script.put("name", "Script");
        script.put("description", "Wait for a script to complete");
        script.put("category", "Script");
        waitStrategies.add(script);
        
        // Custom wait strategies
        Map<String, Object> custom = new HashMap<>();
        custom.put("id", "CUSTOM");
        custom.put("name", "Custom");
        custom.put("description", "Custom wait condition");
        custom.put("category", "Custom");
        waitStrategies.add(custom);
        
        return waitStrategies;
    }
    
    @Override
    public Map<String, Object> executeJavaScript(String executionId, String script) {
        LOGGER.info("Executing JavaScript in test execution: {}", executionId);
        
        Map<String, Object> result = new HashMap<>();
        result.put("executionId", executionId);
        
        if (script == null || script.isEmpty()) {
            result.put("success", false);
            result.put("error", "Script is empty");
            return result;
        }
        
        try {
            ScriptEngine engine = scriptEngineManager.getEngineByName("JavaScript");
            if (engine == null) {
                result.put("success", false);
                result.put("error", "JavaScript engine not available");
                return result;
            }
            
            Object scriptResult = engine.eval(script);
            result.put("success", true);
            result.put("result", scriptResult);
            return result;
        } catch (ScriptException e) {
            LOGGER.error("Script execution error: {}", e.getMessage(), e);
            result.put("success", false);
            result.put("error", e.getMessage());
            result.put("lineNumber", e.getLineNumber());
            result.put("columnNumber", e.getColumnNumber());
            return result;
        } catch (Exception e) {
            LOGGER.error("Script execution error: {}", e.getMessage(), e);
            result.put("success", false);
            result.put("error", e.getMessage());
            return result;
        }
    }
    
    @Override
    public List<Map<String, Object>> getDataProviderTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting data provider types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> dataProviderTypes = new ArrayList<>();
        
        // Excel data provider
        Map<String, Object> excel = new HashMap<>();
        excel.put("id", "EXCEL");
        excel.put("name", "Excel");
        excel.put("description", "Excel data provider");
        excel.put("fileExtensions", Arrays.asList("xlsx", "xls"));
        dataProviderTypes.add(excel);
        
        // CSV data provider
        Map<String, Object> csv = new HashMap<>();
        csv.put("id", "CSV");
        csv.put("name", "CSV");
        csv.put("description", "CSV data provider");
        csv.put("fileExtensions", Arrays.asList("csv"));
        dataProviderTypes.add(csv);
        
        // JSON data provider
        Map<String, Object> json = new HashMap<>();
        json.put("id", "JSON");
        json.put("name", "JSON");
        json.put("description", "JSON data provider");
        json.put("fileExtensions", Arrays.asList("json"));
        dataProviderTypes.add(json);
        
        // Database data provider
        Map<String, Object> database = new HashMap<>();
        database.put("id", "DATABASE");
        database.put("name", "Database");
        database.put("description", "Database data provider");
        database.put("fileExtensions", Collections.emptyList());
        dataProviderTypes.add(database);
        
        return dataProviderTypes;
    }
    
    @Override
    public List<Map<String, Object>> previewDataProvider(DataProviderActionConfig dataProviderConfig) {
        LOGGER.info("Previewing data provider: {}", dataProviderConfig.getDataSourceType());
        
        if (dataProviderConfig == null || dataProviderConfig.getDataSourceType() == null) {
            LOGGER.error("Data provider configuration is null or invalid");
            return Collections.emptyList();
        }
        
        String dataSourceType = dataProviderConfig.getDataSourceType();
        String dataSourcePath = dataProviderConfig.getDataSourcePath();
        
        if (dataSourcePath == null || dataSourcePath.isEmpty()) {
            LOGGER.error("Data source path is empty");
            return Collections.emptyList();
        }
        
        List<Map<String, Object>> previewData = new ArrayList<>();
        
        try {
            // Use appropriate data source based on type
            if (dataSourceType.equals("EXCEL")) {
                String sheetName = dataProviderConfig.getSheetName();
                Boolean headers = dataProviderConfig.getHeaders();
                
                if (sheetName == null || sheetName.isEmpty()) {
                    LOGGER.error("Sheet name is required for Excel data source");
                    return Collections.emptyList();
                }
                
                // Create Excel data source
                // Normally, this would use the real CSDataSourceFactory, but for preview we use a direct approach
                previewData = previewExcelData(dataSourcePath, sheetName, headers != null ? headers : true);
            } else if (dataSourceType.equals("CSV")) {
                String delimiter = dataProviderConfig.getDelimiter();
                Boolean headers = dataProviderConfig.getHeaders();
                
                // Create CSV data source
                previewData = previewCsvData(dataSourcePath, delimiter, headers != null ? headers : true);
            } else if (dataSourceType.equals("JSON")) {
                // Create JSON data source
                previewData = previewJsonData(dataSourcePath);
            } else if (dataSourceType.equals("DATABASE")) {
                String query = dataProviderConfig.getProperty("query") != null ? 
                        (String) dataProviderConfig.getProperty("query") : "";
                String connectionString = dataProviderConfig.getProperty("connectionString") != null ? 
                        (String) dataProviderConfig.getProperty("connectionString") : "";
                
                if (query == null || query.isEmpty()) {
                    LOGGER.error("Query is required for database data source");
                    return Collections.emptyList();
                }
                
                if (connectionString == null || connectionString.isEmpty()) {
                    LOGGER.error("Connection string is required for database data source");
                    return Collections.emptyList();
                }
                
                // Create database data source
                previewData = previewDatabaseData(connectionString, query);
            } else {
                LOGGER.error("Unsupported data source type: {}", dataSourceType);
                return Collections.emptyList();
            }
            
            // Limit preview data to first 10 rows
            if (previewData.size() > 10) {
                previewData = previewData.subList(0, 10);
            }
            
            return previewData;
        } catch (Exception e) {
            LOGGER.error("Failed to preview data provider: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Preview Excel data.
     */
    private List<Map<String, Object>> previewExcelData(String filePath, String sheetName, boolean hasHeaders) {
        // Note: In a real implementation, this would use your custom Excel parsing logic
        // For now, we'll create a simplified version that reads Excel using Apache POI
        List<Map<String, Object>> data = new ArrayList<>();
        
        try {
            // Simplified example - in real code you would use Apache POI to read Excel
            // This is just a placeholder to show how it would be structured
            File file = new File(filePath);
            if (!file.exists()) {
                LOGGER.error("Excel file not found: {}", filePath);
                return Collections.emptyList();
            }
            
            // In a real implementation, this would use the framework's Excel reader component
            // For this example, we'll create some sample data
            Map<String, Object> row1 = new HashMap<>();
            row1.put("Column1", "Value1");
            row1.put("Column2", "Value2");
            row1.put("Column3", 123);
            
            Map<String, Object> row2 = new HashMap<>();
            row2.put("Column1", "Value3");
            row2.put("Column2", "Value4");
            row2.put("Column3", 456);
            
            data.add(row1);
            data.add(row2);
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error previewing Excel data: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Preview CSV data.
     */
    private List<Map<String, Object>> previewCsvData(String filePath, String delimiter, boolean hasHeaders) {
        // Note: In a real implementation, this would use your custom CSV parsing logic
        List<Map<String, Object>> data = new ArrayList<>();
        
        try {
            File file = new File(filePath);
            if (!file.exists()) {
                LOGGER.error("CSV file not found: {}", filePath);
                return Collections.emptyList();
            }
            
            // In a real implementation, this would use the framework's CSV reader component
            // For this example, we'll create some sample data
            Map<String, Object> row1 = new HashMap<>();
            row1.put("Column1", "Value1");
            row1.put("Column2", "Value2");
            row1.put("Column3", "123");
            
            Map<String, Object> row2 = new HashMap<>();
            row2.put("Column1", "Value3");
            row2.put("Column2", "Value4");
            row2.put("Column3", "456");
            
            data.add(row1);
            data.add(row2);
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error previewing CSV data: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Preview JSON data.
     */
    private List<Map<String, Object>> previewJsonData(String filePath) {
        // Note: In a real implementation, this would use your custom JSON parsing logic
        List<Map<String, Object>> data = new ArrayList<>();
        
        try {
            File file = new File(filePath);
            if (!file.exists()) {
                LOGGER.error("JSON file not found: {}", filePath);
                return Collections.emptyList();
            }
            
            // In a real implementation, this would use the framework's JSON reader component
            // For this example, we'll create some sample data
            Map<String, Object> row1 = new HashMap<>();
            row1.put("id", 1);
            row1.put("name", "John Doe");
            row1.put("age", 30);
            
            Map<String, Object> row2 = new HashMap<>();
            row2.put("id", 2);
            row2.put("name", "Jane Smith");
            row2.put("age", 25);
            
            data.add(row1);
            data.add(row2);
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error previewing JSON data: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Preview database data.
     */
    private List<Map<String, Object>> previewDatabaseData(String connectionString, String query) {
        // Note: In a real implementation, this would use your custom database access logic
        List<Map<String, Object>> data = new ArrayList<>();
        
        try {
            // In a real implementation, this would use the framework's database access component
            // For this example, we'll create some sample data
            Map<String, Object> row1 = new HashMap<>();
            row1.put("id", 1);
            row1.put("name", "John Doe");
            row1.put("email", "john.doe@example.com");
            
            Map<String, Object> row2 = new HashMap<>();
            row2.put("id", 2);
            row2.put("name", "Jane Smith");
            row2.put("email", "jane.smith@example.com");
            
            data.add(row1);
            data.add(row2);
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error previewing database data: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    @Override
    public List<Map<String, Object>> getConditionalOperators(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting conditional operators for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> operators = new ArrayList<>();
        
        // Equality operators
        Map<String, Object> equals = new HashMap<>();
        equals.put("id", "EQUALS");
        equals.put("name", "Equals");
        equals.put("description", "Equality comparison");
        equals.put("symbol", "==");
        equals.put("category", "Equality");
        operators.add(equals);
        
        Map<String, Object> notEquals = new HashMap<>();
        notEquals.put("id", "NOT_EQUALS");
        notEquals.put("name", "Not Equals");
        notEquals.put("description", "Inequality comparison");
        notEquals.put("symbol", "!=");
        notEquals.put("category", "Equality");
        operators.add(notEquals);
        
        // Comparison operators
        Map<String, Object> greaterThan = new HashMap<>();
        greaterThan.put("id", "GREATER_THAN");
        greaterThan.put("name", "Greater Than");
        greaterThan.put("description", "Greater than comparison");
        greaterThan.put("symbol", ">");
        greaterThan.put("category", "Comparison");
        operators.add(greaterThan);
        
        Map<String, Object> lessThan = new HashMap<>();
        lessThan.put("id", "LESS_THAN");
        lessThan.put("name", "Less Than");
        lessThan.put("description", "Less than comparison");
        lessThan.put("symbol", "<");
        lessThan.put("category", "Comparison");
        operators.add(lessThan);
        
        Map<String, Object> greaterThanOrEquals = new HashMap<>();
        greaterThanOrEquals.put("id", "GREATER_THAN_OR_EQUALS");
        greaterThanOrEquals.put("name", "Greater Than or Equals");
        greaterThanOrEquals.put("description", "Greater than or equals comparison");
        greaterThanOrEquals.put("symbol", ">=");
        greaterThanOrEquals.put("category", "Comparison");
        operators.add(greaterThanOrEquals);
        
        Map<String, Object> lessThanOrEquals = new HashMap<>();
        lessThanOrEquals.put("id", "LESS_THAN_OR_EQUALS");
        lessThanOrEquals.put("name", "Less Than or Equals");
        lessThanOrEquals.put("description", "Less than or equals comparison");
        lessThanOrEquals.put("symbol", "<=");
        lessThanOrEquals.put("category", "Comparison");
        operators.add(lessThanOrEquals);
        
        // String operators
        Map<String, Object> contains = new HashMap<>();
        contains.put("id", "CONTAINS");
        contains.put("name", "Contains");
        contains.put("description", "String contains substring");
        contains.put("symbol", "contains");
        contains.put("category", "String");
        operators.add(contains);
        
        Map<String, Object> startsWith = new HashMap<>();
        startsWith.put("id", "STARTS_WITH");
        startsWith.put("name", "Starts With");
        startsWith.put("description", "String starts with substring");
        startsWith.put("symbol", "startsWith");
        startsWith.put("category", "String");
        operators.add(startsWith);
        
        Map<String, Object> endsWith = new HashMap<>();
        endsWith.put("id", "ENDS_WITH");
        endsWith.put("name", "Ends With");
        endsWith.put("description", "String ends with substring");
        endsWith.put("symbol", "endsWith");
        endsWith.put("category", "String");
        operators.add(endsWith);
        
        Map<String, Object> matches = new HashMap<>();
        matches.put("id", "MATCHES");
        matches.put("name", "Matches");
        matches.put("description", "String matches regular expression");
        matches.put("symbol", "matches");
        matches.put("category", "String");
        operators.add(matches);
        
        // Logical operators
        Map<String, Object> and = new HashMap<>();
        and.put("id", "AND");
        and.put("name", "And");
        and.put("description", "Logical AND");
        and.put("symbol", "&&");
        and.put("category", "Logical");
        operators.add(and);
        
        Map<String, Object> or = new HashMap<>();
        or.put("id", "OR");
        or.put("name", "Or");
        or.put("description", "Logical OR");
        or.put("symbol", "||");
        or.put("category", "Logical");
        operators.add(or);
        
        Map<String, Object> not = new HashMap<>();
        not.put("id", "NOT");
        not.put("name", "Not");
        not.put("description", "Logical NOT");
        not.put("symbol", "!");
        not.put("category", "Logical");
        operators.add(not);
        
        return operators;
    }
    
    @Override
    public List<Map<String, Object>> getLoopTypes(FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        LOGGER.debug("Getting loop types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        List<Map<String, Object>> loopTypes = new ArrayList<>();
        
        // Times loop
        Map<String, Object> times = new HashMap<>();
        times.put("id", "TIMES");
        times.put("name", "Times");
        times.put("description", "Repeat a specific number of times");
        times.put("category", "Basic");
        loopTypes.add(times);
        
        // ForEach loop
        Map<String, Object> forEach = new HashMap<>();
        forEach.put("id", "FOREACH");
        forEach.put("name", "ForEach");
        forEach.put("description", "Iterate over a collection of items");
        forEach.put("category", "Collection");
        loopTypes.add(forEach);
        
        // For loop
        Map<String, Object> forLoop = new HashMap<>();
        forLoop.put("id", "FOR");
        forLoop.put("name", "For");
        forLoop.put("description", "Traditional for loop with initialization, condition, and increment");
        forLoop.put("category", "Advanced");
        loopTypes.add(forLoop);
        
        // While loop
        Map<String, Object> whileLoop = new HashMap<>();
        whileLoop.put("id", "WHILE");
        whileLoop.put("name", "While");
        whileLoop.put("description", "Repeat as long as a condition is true");
        whileLoop.put("category", "Conditional");
        loopTypes.add(whileLoop);
        
        return loopTypes;
    }
}


ActionConfig.java
------------------------------

package com.cstestforge.model.action;

import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Base class for action configurations.
 * This class provides common properties and methods for all action types.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "configType")
@JsonSubTypes({
    @JsonSubTypes.Type(value = AssertionActionConfig.class, name = "ASSERTION"),
    @JsonSubTypes.Type(value = ConditionalActionConfig.class, name = "CONDITIONAL"),
    @JsonSubTypes.Type(value = CustomActionConfig.class, name = "CUSTOM"),
    @JsonSubTypes.Type(value = DataProviderActionConfig.class, name = "DATA_PROVIDER"),
    @JsonSubTypes.Type(value = LoopActionConfig.class, name = "LOOP"),
    @JsonSubTypes.Type(value = WaitActionConfig.class, name = "WAIT")
})
public class ActionConfig {
    
    private String id;
    private ActionType actionType;
    private String name;
    private String description;
    private Boolean enabled;
    private Map<String, Object> properties;
    
    // Template metadata
    private String templateName;
    private String templateDescription;
    private FrameworkType frameworkType;
    private LanguageType languageType;
    private TestType testType;
    private LocalDateTime templateCreationTime;
    
    /**
     * Default constructor.
     */
    public ActionConfig() {
        this.properties = new HashMap<>();
        this.enabled = true;
    }
    
    /**
     * Constructor with action type.
     *
     * @param actionType Action type
     */
    public ActionConfig(ActionType actionType) {
        this();
        this.actionType = actionType;
    }
    
    /**
     * Get ID.
     *
     * @return ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Set ID.
     *
     * @param id ID
     */
    public void setId(String id) {
        this.id = id;
    }
    
    /**
     * Get action type.
     *
     * @return Action type
     */
    public ActionType getActionType() {
        return actionType;
    }
    
    /**
     * Set action type.
     *
     * @param actionType Action type
     */
    public void setActionType(ActionType actionType) {
        this.actionType = actionType;
    }
    
    /**
     * Get name.
     *
     * @return Name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Set name.
     *
     * @param name Name
     */
    public void setName(String name) {
        this.name = name;
    }
    
    /**
     * Get description.
     *
     * @return Description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Set description.
     *
     * @param description Description
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * Get enabled flag.
     *
     * @return Enabled flag
     */
    public Boolean isEnabled() {
        return enabled;
    }
    
    /**
     * Set enabled flag.
     *
     * @param enabled Enabled flag
     */
    public void setEnabled(Boolean enabled) {
        this.enabled = enabled;
    }
    
    /**
     * Get properties.
     *
     * @return Properties
     */
    public Map<String, Object> getProperties() {
        return properties;
    }
    
    /**
     * Set properties.
     *
     * @param properties Properties
     */
    public void setProperties(Map<String, Object> properties) {
        this.properties = properties;
    }
    
    /**
     * Get a property value.
     *
     * @param key Property key
     * @return Property value
     */
    public Object getProperty(String key) {
        return properties.get(key);
    }
    
    /**
     * Get a property value with a default value.
     *
     * @param key Property key
     * @param defaultValue Default value
     * @return Property value or default value if not found
     */
    public Object getProperty(String key, Object defaultValue) {
        return properties.getOrDefault(key, defaultValue);
    }
    
    /**
     * Set a property value.
     *
     * @param key Property key
     * @param value Property value
     */
    public void setProperty(String key, Object value) {
        properties.put(key, value);
    }
    
    /**
     * Remove a property.
     *
     * @param key Property key
     * @return The removed property value, or null if the key doesn't exist
     */
    public Object removeProperty(String key) {
        return properties.remove(key);
    }
    
    /**
     * Check if a property exists.
     *
     * @param key Property key
     * @return true if the property exists, false otherwise
     */
    public boolean hasProperty(String key) {
        return properties.containsKey(key);
    }
    
    /**
     * Get template name.
     *
     * @return Template name
     */
    public String getTemplateName() {
        return templateName;
    }
    
    /**
     * Set template name.
     *
     * @param templateName Template name
     */
    public void setTemplateName(String templateName) {
        this.templateName = templateName;
    }
    
    /**
     * Get template description.
     *
     * @return Template description
     */
    public String getTemplateDescription() {
        return templateDescription;
    }
    
    /**
     * Set template description.
     *
     * @param templateDescription Template description
     */
    public void setTemplateDescription(String templateDescription) {
        this.templateDescription = templateDescription;
    }
    
    /**
     * Get framework type.
     *
     * @return Framework type
     */
    public FrameworkType getFrameworkType() {
        return frameworkType;
    }
    
    /**
     * Set framework type.
     *
     * @param frameworkType Framework type
     */
    public void setFrameworkType(FrameworkType frameworkType) {
        this.frameworkType = frameworkType;
    }
    
    /**
     * Get language type.
     *
     * @return Language type
     */
    public LanguageType getLanguageType() {
        return languageType;
    }
    
    /**
     * Set language type.
     *
     * @param languageType Language type
     */
    public void setLanguageType(LanguageType languageType) {
        this.languageType = languageType;
    }
    
    /**
     * Get test type.
     *
     * @return Test type
     */
    public TestType getTestType() {
        return testType;
    }
    
    /**
     * Set test type.
     *
     * @param testType Test type
     */
    public void setTestType(TestType testType) {
        this.testType = testType;
    }
    
    /**
     * Get template creation time.
     *
     * @return Template creation time
     */
    public LocalDateTime getTemplateCreationTime() {
        return templateCreationTime;
    }
    
    /**
     * Set template creation time.
     *
     * @param templateCreationTime Template creation time
     */
    public void setTemplateCreationTime(LocalDateTime templateCreationTime) {
        this.templateCreationTime = templateCreationTime;
    }
}


AssertionActionConfig.java
------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

/**
 * Configuration for assertion actions.
 * This class provides specific properties for assertion actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class AssertionActionConfig extends ActionConfig {
    
    private String assertionType;
    private String locator;
    private String locatorType;
    private String expectedValue;
    private String actualValue;
    private Integer timeout;
    private Boolean failOnAssertionError;
    
    /**
     * Default constructor.
     */
    public AssertionActionConfig() {
        super(ActionType.ASSERT);
    }
    
    /**
     * Get assertion type.
     *
     * @return Assertion type
     */
    public String getAssertionType() {
        return assertionType;
    }
    
    /**
     * Set assertion type.
     *
     * @param assertionType Assertion type
     */
    public void setAssertionType(String assertionType) {
        this.assertionType = assertionType;
    }
    
    /**
     * Get locator.
     *
     * @return Locator
     */
    public String getLocator() {
        return locator;
    }
    
    /**
     * Set locator.
     *
     * @param locator Locator
     */
    public void setLocator(String locator) {
        this.locator = locator;
    }
    
    /**
     * Get locator type.
     *
     * @return Locator type
     */
    public String getLocatorType() {
        return locatorType;
    }
    
    /**
     * Set locator type.
     *
     * @param locatorType Locator type
     */
    public void setLocatorType(String locatorType) {
        this.locatorType = locatorType;
    }
    
    /**
     * Get expected value.
     *
     * @return Expected value
     */
    public String getExpectedValue() {
        return expectedValue;
    }
    
    /**
     * Set expected value.
     *
     * @param expectedValue Expected value
     */
    public void setExpectedValue(String expectedValue) {
        this.expectedValue = expectedValue;
    }
    
    /**
     * Get actual value.
     *
     * @return Actual value
     */
    public String getActualValue() {
        return actualValue;
    }
    
    /**
     * Set actual value.
     *
     * @param actualValue Actual value
     */
    public void setActualValue(String actualValue) {
        this.actualValue = actualValue;
    }
    
    /**
     * Get timeout.
     *
     * @return Timeout
     */
    public Integer getTimeout() {
        return timeout;
    }
    
    /**
     * Set timeout.
     *
     * @param timeout Timeout
     */
    public void setTimeout(Integer timeout) {
        this.timeout = timeout;
    }
    
    /**
     * Get fail on assertion error flag.
     *
     * @return Fail on assertion error flag
     */
    public Boolean isFailOnAssertionError() {
        return failOnAssertionError;
    }
    
    /**
     * Set fail on assertion error flag.
     *
     * @param failOnAssertionError Fail on assertion error flag
     */
    public void setFailOnAssertionError(Boolean failOnAssertionError) {
        this.failOnAssertionError = failOnAssertionError;
    }
}


ConditionalActionConfig.java
----------------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for conditional actions.
 * This class provides specific properties for conditional actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class ConditionalActionConfig extends ActionConfig {
    
    private String condition;
    private String operator;
    private String leftOperand;
    private String rightOperand;
    private List<ActionConfig> nestedActions;
    private List<ActionConfig> elseActions;
    
    /**
     * Default constructor.
     */
    public ConditionalActionConfig() {
        super(ActionType.CONDITIONAL);
        this.nestedActions = new ArrayList<>();
        this.elseActions = new ArrayList<>();
    }
    
    /**
     * Get condition.
     *
     * @return Condition
     */
    public String getCondition() {
        return condition;
    }
    
    /**
     * Set condition.
     *
     * @param condition Condition
     */
    public void setCondition(String condition) {
        this.condition = condition;
    }
    
    /**
     * Get operator.
     *
     * @return Operator
     */
    public String getOperator() {
        return operator;
    }
    
    /**
     * Set operator.
     *
     * @param operator Operator
     */
    public void setOperator(String operator) {
        this.operator = operator;
    }
    
    /**
     * Get left operand.
     *
     * @return Left operand
     */
    public String getLeftOperand() {
        return leftOperand;
    }
    
    /**
     * Set left operand.
     *
     * @param leftOperand Left operand
     */
    public void setLeftOperand(String leftOperand) {
        this.leftOperand = leftOperand;
    }
    
    /**
     * Get right operand.
     *
     * @return Right operand
     */
    public String getRightOperand() {
        return rightOperand;
    }
    
    /**
     * Set right operand.
     *
     * @param rightOperand Right operand
     */
    public void setRightOperand(String rightOperand) {
        this.rightOperand = rightOperand;
    }
    
    /**
     * Get nested actions.
     *
     * @return Nested actions
     */
    public List<ActionConfig> getNestedActions() {
        return nestedActions;
    }
    
    /**
     * Set nested actions.
     *
     * @param nestedActions Nested actions
     */
    public void setNestedActions(List<ActionConfig> nestedActions) {
        this.nestedActions = nestedActions;
    }
    
    /**
     * Add a nested action.
     *
     * @param nestedAction Nested action
     */
    public void addNestedAction(ActionConfig nestedAction) {
        if (this.nestedActions == null) {
            this.nestedActions = new ArrayList<>();
        }
        this.nestedActions.add(nestedAction);
    }
    
    /**
     * Get else actions.
     *
     * @return Else actions
     */
    public List<ActionConfig> getElseActions() {
        return elseActions;
    }
    
    /**
     * Set else actions.
     *
     * @param elseActions Else actions
     */
    public void setElseActions(List<ActionConfig> elseActions) {
        this.elseActions = elseActions;
    }
    
    /**
     * Add an else action.
     *
     * @param elseAction Else action
     */
    public void addElseAction(ActionConfig elseAction) {
        if (this.elseActions == null) {
            this.elseActions = new ArrayList<>();
        }
        this.elseActions.add(elseAction);
    }
}


CustomActionConfig.java
-------------------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Configuration for custom actions.
 * This class provides specific properties for custom actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class CustomActionConfig extends ActionConfig {
    
    private String scriptType;
    private String script;
    private List<Map<String, String>> parameters;
    
    /**
     * Default constructor.
     */
    public CustomActionConfig() {
        super(ActionType.CUSTOM);
        this.parameters = new ArrayList<>();
    }
    
    /**
     * Get script type.
     *
     * @return Script type
     */
    public String getScriptType() {
        return scriptType;
    }
    
    /**
     * Set script type.
     *
     * @param scriptType Script type
     */
    public void setScriptType(String scriptType) {
        this.scriptType = scriptType;
    }
    
    /**
     * Get script.
     *
     * @return Script
     */
    public String getScript() {
        return script;
    }
    
    /**
     * Set script.
     *
     * @param script Script
     */
    public void setScript(String script) {
        this.script = script;
    }
    
    /**
     * Get parameters.
     *
     * @return Parameters
     */
    public List<Map<String, String>> getParameters() {
        return parameters;
    }
    
    /**
     * Set parameters.
     *
     * @param parameters Parameters
     */
    public void setParameters(List<Map<String, String>> parameters) {
        this.parameters = parameters;
    }
    
    /**
     * Add a parameter.
     *
     * @param name Parameter name
     * @param value Parameter value
     */
    public void addParameter(String name, String value) {
        if (this.parameters == null) {
            this.parameters = new ArrayList<>();
        }
        Map<String, String> parameter = new HashMap<>();
        parameter.put("name", name);
        parameter.put("value", value);
        this.parameters.add(parameter);
    }
}


DataProviderActionConfig.java
--------------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for data provider actions.
 * This class provides specific properties for data provider actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class DataProviderActionConfig extends ActionConfig {
    
    private String dataSourceType;
    private String dataSourcePath;
    private String sheetName;
    private String delimiter;
    private Boolean headers;
    private List<String> parameters;
    private List<ActionConfig> iterationActions;
    
    /**
     * Default constructor.
     */
    public DataProviderActionConfig() {
        super(ActionType.DATA_PROVIDER);
        this.parameters = new ArrayList<>();
        this.iterationActions = new ArrayList<>();
    }
    
    /**
     * Get data source type.
     *
     * @return Data source type
     */
    public String getDataSourceType() {
        return dataSourceType;
    }
    
    /**
     * Set data source type.
     *
     * @param dataSourceType Data source type
     */
    public void setDataSourceType(String dataSourceType) {
        this.dataSourceType = dataSourceType;
    }
    
    /**
     * Get data source path.
     *
     * @return Data source path
     */
    public String getDataSourcePath() {
        return dataSourcePath;
    }
    
    /**
     * Set data source path.
     *
     * @param dataSourcePath Data source path
     */
    public void setDataSourcePath(String dataSourcePath) {
        this.dataSourcePath = dataSourcePath;
    }
    
    /**
     * Get sheet name.
     *
     * @return Sheet name
     */
    public String getSheetName() {
        return sheetName;
    }
    
    /**
     * Set sheet name.
     *
     * @param sheetName Sheet name
     */
    public void setSheetName(String sheetName) {
        this.sheetName = sheetName;
    }
    
    /**
     * Get delimiter.
     *
     * @return Delimiter
     */
    public String getDelimiter() {
        return delimiter;
    }
    
    /**
     * Set delimiter.
     *
     * @param delimiter Delimiter
     */
    public void setDelimiter(String delimiter) {
        this.delimiter = delimiter;
    }
    
    /**
     * Get headers flag.
     *
     * @return Headers flag
     */
    public Boolean getHeaders() {
        return headers;
    }
    
    /**
     * Set headers flag.
     *
     * @param headers Headers flag
     */
    public void setHeaders(Boolean headers) {
        this.headers = headers;
    }
    
    /**
     * Get parameters.
     *
     * @return Parameters
     */
    public List<String> getParameters() {
        return parameters;
    }
    
    /**
     * Set parameters.
     *
     * @param parameters Parameters
     */
    public void setParameters(List<String> parameters) {
        this.parameters = parameters;
    }
    
    /**
     * Add a parameter.
     *
     * @param parameter Parameter
     */
    public void addParameter(String parameter) {
        if (this.parameters == null) {
            this.parameters = new ArrayList<>();
        }
        this.parameters.add(parameter);
    }
    
    /**
     * Get iteration actions.
     *
     * @return Iteration actions
     */
    public List<ActionConfig> getIterationActions() {
        return iterationActions;
    }
    
    /**
     * Set iteration actions.
     *
     * @param iterationActions Iteration actions
     */
    public void setIterationActions(List<ActionConfig> iterationActions) {
        this.iterationActions = iterationActions;
    }
    
    /**
     * Add an iteration action.
     *
     * @param iterationAction Iteration action
     */
    public void addIterationAction(ActionConfig iterationAction) {
        if (this.iterationActions == null) {
            this.iterationActions = new ArrayList<>();
        }
        this.iterationActions.add(iterationAction);
    }
}


LoopActionConfig.java
----------------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.ArrayList;
import java.util.List;

/**
 * Configuration for loop actions.
 * This class provides specific properties for loop actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class LoopActionConfig extends ActionConfig {
    
    private String loopType;
    private Integer times;
    private String collection;
    private String variableName;
    private String initExpression;
    private String conditionExpression;
    private String incrementExpression;
    private List<ActionConfig> nestedActions;
    
    /**
     * Default constructor.
     */
    public LoopActionConfig() {
        super(ActionType.LOOP);
        this.nestedActions = new ArrayList<>();
    }
    
    /**
     * Get loop type.
     *
     * @return Loop type
     */
    public String getLoopType() {
        return loopType;
    }
    
    /**
     * Set loop type.
     *
     * @param loopType Loop type
     */
    public void setLoopType(String loopType) {
        this.loopType = loopType;
    }
    
    /**
     * Get times.
     *
     * @return Times
     */
    public Integer getTimes() {
        return times;
    }
    
    /**
     * Set times.
     *
     * @param times Times
     */
    public void setTimes(Integer times) {
        this.times = times;
    }
    
    /**
     * Get collection.
     *
     * @return Collection
     */
    public String getCollection() {
        return collection;
    }
    
    /**
     * Set collection.
     *
     * @param collection Collection
     */
    public void setCollection(String collection) {
        this.collection = collection;
    }
    
    /**
     * Get variable name.
     *
     * @return Variable name
     */
    public String getVariableName() {
        return variableName;
    }
    
    /**
     * Set variable name.
     *
     * @param variableName Variable name
     */
    public void setVariableName(String variableName) {
        this.variableName = variableName;
    }
    
    /**
     * Get initialization expression.
     *
     * @return Initialization expression
     */
    public String getInitExpression() {
        return initExpression;
    }
    
    /**
     * Set initialization expression.
     *
     * @param initExpression Initialization expression
     */
    public void setInitExpression(String initExpression) {
        this.initExpression = initExpression;
    }
    
    /**
     * Get condition expression.
     *
     * @return Condition expression
     */
    public String getConditionExpression() {
        return conditionExpression;
    }
    
    /**
     * Set condition expression.
     *
     * @param conditionExpression Condition expression
     */
    public void setConditionExpression(String conditionExpression) {
        this.conditionExpression = conditionExpression;
    }
    
    /**
     * Get increment expression.
     *
     * @return Increment expression
     */
    public String getIncrementExpression() {
        return incrementExpression;
    }
    
    /**
     * Set increment expression.
     *
     * @param incrementExpression Increment expression
     */
    public void setIncrementExpression(String incrementExpression) {
        this.incrementExpression = incrementExpression;
    }
    
    /**
     * Get nested actions.
     *
     * @return Nested actions
     */
    public List<ActionConfig> getNestedActions() {
        return nestedActions;
    }
    
    /**
     * Set nested actions.
     *
     * @param nestedActions Nested actions
     */
    public void setNestedActions(List<ActionConfig> nestedActions) {
        this.nestedActions = nestedActions;
    }
    
    /**
     * Add a nested action.
     *
     * @param nestedAction Nested action
     */
    public void addNestedAction(ActionConfig nestedAction) {
        if (this.nestedActions == null) {
            this.nestedActions = new ArrayList<>();
        }
        this.nestedActions.add(nestedAction);
    }
}


WaitActionConfig.java
----------------------------------

package com.cstestforge.model.action;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

/**
 * Configuration for wait actions.
 * This class provides specific properties for wait actions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class WaitActionConfig extends ActionConfig {
    
    private String waitType;
    private String locator;
    private String locatorType;
    private Integer timeout;
    
    /**
     * Default constructor.
     */
    public WaitActionConfig() {
        super(ActionType.WAIT);
    }
    
    /**
     * Get wait type.
     *
     * @return Wait type
     */
    public String getWaitType() {
        return waitType;
    }
    
    /**
     * Set wait type.
     *
     * @param waitType Wait type
     */
    public void setWaitType(String waitType) {
        this.waitType = waitType;
    }
    
    /**
     * Get locator.
     *
     * @return Locator
     */
    public String getLocator() {
        return locator;
    }
    
    /**
     * Set locator.
     *
     * @param locator Locator
     */
    public void setLocator(String locator) {
        this.locator = locator;
    }
    
    /**
     * Get locator type.
     *
     * @return Locator type
     */
    public String getLocatorType() {
        return locatorType;
    }
    
    /**
     * Set locator type.
     *
     * @param locatorType Locator type
     */
    public void setLocatorType(String locatorType) {
        this.locatorType = locatorType;
    }
    
    /**
     * Get timeout.
     *
     * @return Timeout
     */
    public Integer getTimeout() {
        return timeout;
    }
    
    /**
     * Set timeout.
     *
     * @param timeout Timeout
     */
    public void setTimeout(Integer timeout) {
        this.timeout = timeout;
    }
}


FrameworkType.java
----------------------------------

package com.cstestforge.model.project;

/**
 * Enumeration of supported testing frameworks.
 */
public enum FrameworkType {
    /**
     * Selenium WebDriver framework.
     */
    SELENIUM,
    
    /**
     * Playwright framework.
     */
    PLAYWRIGHT
}


LanguageType.java
-------------------------------

package com.cstestforge.model.project;

/**
 * Enumeration of supported programming languages.
 */
public enum LanguageType {
    /**
     * Java programming language.
     */
    JAVA,
    
    /**
     * TypeScript programming language.
     */
    TYPESCRIPT
}


TestType.java
----------------------------

package com.cstestforge.model.project;

/**
 * Enumeration of supported testing approaches.
 */
public enum TestType {
    /**
     * TestNG-based testing approach.
     */
    TESTNG,
    
    /**
     * Behavior-Driven Development testing approach.
     */
    BDD
}



ActionType.java
----------------------

package com.cstestforge.model.action;

/**
 * Enumeration of supported action types in the CSTestForge framework.
 * Each action type represents a specific testing operation that can be performed.
 */
public enum ActionType {
    /**
     * Click on an element.
     */
    CLICK,
    
    /**
     * Type text into an input field.
     */
    TYPE,
    
    /**
     * Select an option from a dropdown.
     */
    SELECT,
    
    /**
     * Verify conditions or element states.
     */
    ASSERT,
    
    /**
     * Wait for a condition to be met.
     */
    WAIT,
    
    /**
     * Navigate to a URL.
     */
    NAVIGATE,
    
    /**
     * Execute actions conditionally.
     */
    CONDITIONAL,
    
    /**
     * Repeat actions multiple times.
     */
    LOOP,
    
    /**
     * Supply test data from external sources.
     */
    DATA_PROVIDER,
    
    /**
     * Execute custom code.
     */
    CUSTOM,
    
    /**
     * Define and manipulate variables.
     */
    VARIABLE,
    
    /**
     * Capture screenshot.
     */
    SCREENSHOT,
    
    /**
     * Mouse over an element.
     */
    HOVER,
    
    /**
     * Drag and drop elements.
     */
    DRAG_DROP,
    
    /**
     * Switch to a different frame or iframe.
     */
    SWITCH_FRAME,
    
    /**
     * Switch to a different window or tab.
     */
    SWITCH_WINDOW,
    
    /**
     * Execute JavaScript code.
     */
    EXECUTE_SCRIPT,
    
    /**
     * Upload a file.
     */
    FILE_UPLOAD,
    
    /**
     * Press keyboard keys.
     */
    KEY_PRESS,
    
    /**
     * Scroll the page or within an element.
     */
    SCROLL
}
