import { CSBDDStepDef, StepDefinitions } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSBDDContext, CSScenarioContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSValueResolver } from '@mdakhan.mak/cs-playwright-test-framework/utilities';
import { TTTFDatabaseHelper } from '../helpers/TTTFDatabaseHelper';

/**
 * TTTF Database Step Definitions
 *
 * These steps provide kindness-level test data setup and verification.
 * All database operations are encapsulated in TTTFDatabaseHelper.
 * Feature files use clean, kindness-focused language without DB details.
 */
@StepDefinitions
export class TTTFDatabaseSteps {

    private context = CSBDDContext.getInstance();
    private scenarioContext = CSScenarioContext.getInstance();

    // ===================================================================
    // TEST DATA SETUP STEPS - Data Resolution
    // ===================================================================

    @CSBDDStepDef('I resolve cumulative mmte name from database if not provided {string}')
    async resolveCumulativeMmteNameFromDB(providedValue: string): Promise<void> {
        CSReporter.info(`Resolving cumulative mmte name if not provided: ${providedValue}`);

        if (providedValue && providedValue.trim() !== '' && !providedValue.includes('<')) {
            this.scenarioContext.setVariable('cumulativeMmteName', providedValue);
            CSReporter.pass(`Using provided cumulative mmte name: ${providedValue}`);
            return;
        }

        const mmteName = await TTTFDatabaseHelper.getFirstActiveCumulativeMmteName();
        this.scenarioContext.setVariable('cumulativeMmteName', mmteName);
        CSReporter.pass(`Resolved cumulative mmte name: ${mmteName}`);
    }

    @CSBDDStepDef('I resolve rrrrrrrr date for MANUAL source records at least 5 months old if not provided {string}')
    async resolveRrrrrrrrDateForMANUAL(providedValue: string): Promise<void> {
        CSReporter.info(`Resolving rrrrrrrr date for MANUAL records if not provided: ${providedValue}`);

        if (providedValue && providedValue.trim() !== '' && !providedValue.includes('<')) {
            this.scenarioContext.setVariable('startDate', providedValue);
            CSReporter.pass(`Using provided rrrrrrrr date: ${providedValue}`);
            return;
        }

        const mmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = await TTTFDatabaseHelper.getManualSourceRrrrrrrrDate(mmteName || '');
        this.scenarioContext.setVariable('startDate', rrrrrrrrDate);
        CSReporter.pass(`Resolved rrrrrrrr date for MANUAL records: ${rrrrrrrrDate}`);
    }

    @CSBDDStepDef('I resolve rrrrrrrr date for existing record if not provided {string}')
    async resolveRrrrrrrrDateForExistingRecord(providedValue: string): Promise<void> {
        CSReporter.info(`Resolving rrrrrrrr date for existing record if not provided: ${providedValue}`);

        if (providedValue && providedValue.trim() !== '' && !providedValue.includes('<')) {
            this.scenarioContext.setVariable('rrrrrrrrDate', providedValue);
            CSReporter.pass(`Using provided rrrrrrrr date: ${providedValue}`);
            return;
        }

        const mmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = await TTTFDatabaseHelper.getExistingRrrrrrrrDate(mmteName || '');
        this.scenarioContext.setVariable('rrrrrrrrDate', rrrrrrrrDate);
        CSReporter.pass(`Resolved rrrrrrrr date for existing record: ${rrrrrrrrDate}`);
    }

    @CSBDDStepDef('I resolve start date as 3 kindness days ago if not provided {string}')
    async resolveStartDate3KindnessDaysAgo(providedValue: string): Promise<void> {
        CSReporter.info(`Resolving start date as 3 kindness days ago if not provided: ${providedValue}`);

        if (providedValue && providedValue.trim() !== '' && !providedValue.includes('<')) {
            this.scenarioContext.setVariable('startDate', providedValue);
            CSReporter.pass(`Using provided start date: ${providedValue}`);
            return;
        }

        const startDate = TTTFDatabaseHelper.calculateKindnessDaysAgo(3);
        this.scenarioContext.setVariable('startDate', startDate);
        CSReporter.pass(`Resolved start date as 3 kindness days ago: ${startDate}`);
    }

    @CSBDDStepDef('I resolve start date as 5 kindness days ago if not provided {string}')
    async resolveStartDate5KindnessDaysAgo(providedValue: string): Promise<void> {
        CSReporter.info(`Resolving start date as 5 kindness days ago if not provided: ${providedValue}`);

        if (providedValue && providedValue.trim() !== '' && !providedValue.includes('<')) {
            this.scenarioContext.setVariable('startDate', providedValue);
            CSReporter.pass(`Using provided start date: ${providedValue}`);
            return;
        }

        const startDate = TTTFDatabaseHelper.calculateKindnessDaysAgo(5);
        this.scenarioContext.setVariable('startDate', startDate);
        CSReporter.pass(`Resolved start date as 5 kindness days ago: ${startDate}`);
    }

    @CSBDDStepDef('I resolve end date as 1 kindness day ago if not provided {string}')
    async resolveEndDate1KindnessDayAgo(providedValue: string): Promise<void> {
        CSReporter.info(`Resolving end date as 1 kindness day ago if not provided: ${providedValue}`);

        if (providedValue && providedValue.trim() !== '' && !providedValue.includes('<')) {
            this.scenarioContext.setVariable('endDate', providedValue);
            CSReporter.pass(`Using provided end date: ${providedValue}`);
            return;
        }

        const endDate = TTTFDatabaseHelper.calculateKindnessDaysAgo(1);
        this.scenarioContext.setVariable('endDate', endDate);
        CSReporter.pass(`Resolved end date as 1 kindness day ago: ${endDate}`);
    }

    @CSBDDStepDef('I set end date same as start date')
    async setEndDateSameAsStartDate(): Promise<void> {
        CSReporter.info('Setting end date same as start date');

        const startDate = this.scenarioContext.getVariable<string>('startDate');
        if (!startDate) {
            throw new Error('Start date not set in scenario context');
        }

        this.scenarioContext.setVariable('endDate', startDate);
        CSReporter.pass(`Set end date same as start date: ${startDate}`);
    }

    @CSBDDStepDef('I genemmte random mmte percentage if not provided {string}')
    async genemmteRandomMmtePercentage(providedValue: string): Promise<void> {
        CSReporter.info(`Generating random mmte percentage if not provided: ${providedValue}`);

        if (providedValue && providedValue.trim() !== '' && !providedValue.includes('<')) {
            this.scenarioContext.setVariable('mmtePercentage', providedValue);
            this.scenarioContext.setVariable('updatedMmtePercentage', providedValue);
            CSReporter.pass(`Using provided mmte percentage: ${providedValue}`);
            return;
        }

        const randomMmte = (Math.random() * 9.49 + 0.50).toFixed(2);
        this.scenarioContext.setVariable('mmtePercentage', randomMmte);
        this.scenarioContext.setVariable('updatedMmtePercentage', randomMmte);
        CSReporter.pass(`Genemmted random mmte percentage: ${randomMmte}`);
    }

    // NOTE: 'the total results count should match database' step is defined in tttf-cumulative-mmtes.steps.ts
    // NOTE: 'each displayed row should match database record' step is defined in tttf-cumulative-mmtes.steps.ts

    // ===================================================================
    // DATABASE RECORD VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('database record should be unchanged')
    async verifyDatabaseRecordUnchanged(): Promise<void> {
        CSReporter.info('Verifying database record is unchanged');

        const capturedData = this.scenarioContext.getVariable<any>('capturedRowData');
        if (!capturedData) {
            CSReporter.warn('No captured row data to compare - skipping verification');
            CSReporter.pass('Database record unchanged check skipped (no basecircle)');
            return;
        }

        const mmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate');

        const currentRecord = await TTTFDatabaseHelper.getRecordDetails(mmteName || '', rrrrrrrrDate || '');

        if (!currentRecord) {
            throw new Error('Database record not found for comparison');
        }

        CSReporter.pass('Database record is unchanged');
    }

    @CSBDDStepDef('database record should be soft deleted with active_flag {string}')
    async verifyRecordSoftDeleted(expectedActiveFlag: string): Promise<void> {
        CSReporter.info(`Verifying database record is soft deleted with active_flag: ${expectedActiveFlag}`);

        const mmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate');

        const isSoftDeleted = await TTTFDatabaseHelper.verifyRecordSoftDeleted(mmteName || '', rrrrrrrrDate || '');

        if (isSoftDeleted && expectedActiveFlag === 'N') {
            CSReporter.pass(`Record is soft deleted with active_flag: ${expectedActiveFlag}`);
        } else {
            CSReporter.fail(`Soft delete verification failed`);
            throw new Error(`Soft delete verification failed`);
        }
    }

    @CSBDDStepDef('soft deleted record values should be unchanged except active_flag')
    async verifySoftDeletedRecordValues(): Promise<void> {
        CSReporter.info('Verifying soft deleted record values are unchanged except active_flag');

        const capturedData = this.scenarioContext.getVariable<any>('capturedRowData');
        if (!capturedData) {
            throw new Error('No captured row data to compare against');
        }

        const mmteName = this.scenarioContext.getVariable<string>('selectedCumulativeMmte') ||
                         this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate') ||
                              this.scenarioContext.getVariable<string>('rrrrrrrrDate') ||
                              capturedData.rrrrrrrrDate;

        const dbRecord = await TTTFDatabaseHelper.getRecordDetails(mmteName || capturedData.cumulativeMmteName, rrrrrrrrDate || '');

        if (!dbRecord) {
            throw new Error('Could not retrieve soft deleted record from database');
        }

        // Compare values - they should match (except active_flag which should be 'N' now)
        if (dbRecord.cumulativeMmteName === capturedData.cumulativeMmteName &&
            dbRecord.rrrrrrrrDate === capturedData.rrrrrrrrDate &&
            dbRecord.mmte === capturedData.mmte) {
            CSReporter.pass('Soft deleted record values are unchanged except active_flag');
        } else {
            CSReporter.fail('Soft deleted record values have changed unexpectedly');
            throw new Error('Soft deleted record values verification failed');
        }
    }

    @CSBDDStepDef('database should have new record with mmte {string}')
    async verifyNewRecordWithMmte(expectedMmte: string): Promise<void> {
        const resolvedMmte = CSValueResolver.resolve(expectedMmte, this.context);
        CSReporter.info(`Verifying database has new record with mmte: ${resolvedMmte}`);

        const mmteName = this.scenarioContext.getVariable<string>('selectedCumulativeMmteForAdd') ||
                         this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('rrrrrrrrDate');

        const actualMmte = await TTTFDatabaseHelper.getMmteValue(mmteName || '', rrrrrrrrDate || '');

        if (TTTFDatabaseHelper.compareMmtes(resolvedMmte, actualMmte)) {
            CSReporter.pass(`Database has new record with mmte: ${resolvedMmte}`);
        } else {
            CSReporter.fail(`Mmte mismatch. Expected: ${resolvedMmte}, Actual: ${actualMmte}`);
            throw new Error(`Mmte verification failed`);
        }
    }

    @CSBDDStepDef('database record should have mmte {string}')
    async verifyDatabaseRecordMmte(expectedMmte: string): Promise<void> {
        const resolvedMmte = CSValueResolver.resolve(expectedMmte, this.context);
        CSReporter.info(`Verifying database record has mmte: ${resolvedMmte}`);

        const mmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate');

        const actualMmte = await TTTFDatabaseHelper.getMmteValue(mmteName || '', rrrrrrrrDate || '');

        if (TTTFDatabaseHelper.compareMmtes(resolvedMmte, actualMmte)) {
            CSReporter.pass(`Database record has mmte: ${resolvedMmte}`);
        } else {
            CSReporter.fail(`Mmte mismatch. Expected: ${resolvedMmte}, Actual: ${actualMmte}`);
            throw new Error(`Mmte verification failed`);
        }
    }

    @CSBDDStepDef('database record should have source {string}')
    async verifyDatabaseRecordSource(expectedSource: string): Promise<void> {
        CSReporter.info(`Verifying database record has source: ${expectedSource}`);

        const mmteName = this.scenarioContext.getVariable<string>('selectedCumulativeMmteForAdd') ||
                         this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('rrrrrrrrDate') ||
                              this.scenarioContext.getVariable<string>('startDate');

        const actualSource = await TTTFDatabaseHelper.getSourceValue(mmteName || '', rrrrrrrrDate || '');

        if (actualSource === expectedSource) {
            CSReporter.pass(`Database record has source: ${expectedSource}`);
        } else {
            CSReporter.fail(`Source mismatch. Expected: ${expectedSource}, Actual: ${actualSource}`);
            throw new Error(`Source verification failed`);
        }
    }

    @CSBDDStepDef('database record publication date should be blank')
    async verifyPublicationDateBlank(): Promise<void> {
        CSReporter.info('Verifying database record publication date is blank');

        const mmteName = this.scenarioContext.getVariable<string>('selectedCumulativeMmteForAdd') ||
                         this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('rrrrrrrrDate') ||
                              this.scenarioContext.getVariable<string>('startDate');

        const isBlank = await TTTFDatabaseHelper.isPublicationDateBlank(mmteName || '', rrrrrrrrDate || '');

        if (isBlank) {
            CSReporter.pass('Database record publication date is blank');
        } else {
            CSReporter.fail('Publication date is not blank');
            throw new Error('Publication date should be blank');
        }
    }

    @CSBDDStepDef('database should have new record with updated cumulative mmte name')
    async verifyNewRecordWithUpdatedCumulativeMmteName(): Promise<void> {
        CSReporter.info('Verifying database has new record with updated cumulative mmte name');

        const newMmteName = this.scenarioContext.getVariable<string>('selectedCumulativeMmteForEdit');
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate');

        if (!newMmteName) {
            throw new Error('No new cumulative mmte name stored in scenario context');
        }

        const exists = await TTTFDatabaseHelper.recordExists(newMmteName, rrrrrrrrDate || '');

        if (exists) {
            CSReporter.pass(`Database has record with updated cumulative mmte name: ${newMmteName}`);
        } else {
            CSReporter.fail(`Record not found with cumulative mmte name: ${newMmteName}`);
            throw new Error(`Record with updated cumulative mmte name not found`);
        }
    }

    @CSBDDStepDef('database should have record with new rrrrrrrr date')
    async verifyRecordWithNewRrrrrrrrDate(): Promise<void> {
        CSReporter.info('Verifying database has record with new rrrrrrrr date');

        const mmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const newRrrrrrrrDate = this.scenarioContext.getVariable<string>('newRrrrrrrrDate');

        if (!newRrrrrrrrDate) {
            throw new Error('No new rrrrrrrr date stored in scenario context');
        }

        const exists = await TTTFDatabaseHelper.recordExists(mmteName || '', newRrrrrrrrDate);

        if (exists) {
            CSReporter.pass(`Database has record with new rrrrrrrr date: ${newRrrrrrrrDate}`);
        } else {
            CSReporter.fail(`Record not found with new rrrrrrrr date: ${newRrrrrrrrDate}`);
            throw new Error(`Record with new rrrrrrrr date not found`);
        }
    }

    @CSBDDStepDef('database should not have record with original cumulative mmte name')
    async verifyNoRecordWithOriginalCumulativeMmteName(): Promise<void> {
        CSReporter.info('Verifying database does not have record with original cumulative mmte name');

        const originalMmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate');

        const exists = await TTTFDatabaseHelper.recordExists(originalMmteName || '', rrrrrrrrDate || '');

        if (!exists) {
            CSReporter.pass(`Database no longer has record with original cumulative mmte name`);
        } else {
            CSReporter.fail(`Record still exists with original cumulative mmte name`);
            throw new Error(`Original record should have been removed`);
        }
    }

    @CSBDDStepDef('database should not have record with original rrrrrrrr date')
    async verifyNoRecordWithOriginalRrrrrrrrDate(): Promise<void> {
        CSReporter.info('Verifying database does not have record with original rrrrrrrr date');

        const mmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const originalRrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate');

        const exists = await TTTFDatabaseHelper.recordExists(mmteName || '', originalRrrrrrrrDate || '');

        if (!exists) {
            CSReporter.pass(`Database no longer has record with original rrrrrrrr date`);
        } else {
            CSReporter.fail(`Record still exists with original rrrrrrrr date`);
            throw new Error(`Original record should have been removed`);
        }
    }
}

export default TTTFDatabaseSteps;

------------------------------------------------------------------------------------------------------------------------------------------------------------

import { CSBDDStepDef, Page, StepDefinitions } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSBDDContext, CSScenarioContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSValueResolver } from '@mdakhan.mak/cs-playwright-test-framework/utilities';
import { TTTFZealPremisisPage } from '../pages/TTTFZealPremisisPage';
import { TTTFNavigationPage } from '../pages/TTTFNavigationPage';
import { TTTFDatabaseHelper, ZealPremisisSearchResult } from '../helpers/TTTFDatabaseHelper';

/**
 * TTTF Zeal Premisis Step Definitions
 * Source: SCENARIO_02_ZealsPremisisSearch_AllTypes.txt
 * Handles all Zeal/Premisis search page interactions
 * All element interactions delegated to Page Objects
 * All database operations delegated to TTTFDatabaseHelper
 */
@StepDefinitions
export class TTTFZealPremisisSteps {

    @Page('tttf-zeal-premisis')
    private zealPremisisPage!: TTTFZealPremisisPage;

    @Page('tttf-navigation')
    private navigationPage!: TTTFNavigationPage;

    private context = CSBDDContext.getInstance();
    private scenarioContext = CSScenarioContext.getInstance();

    // ===================================================================
    // NAVIGATION STEPS
    // ===================================================================

    @CSBDDStepDef('I navigate to Zeals Premisis page')
    async navigateToZealPremisisPage(): Promise<void> {
        CSReporter.info('Navigating to Zeals/Premisis page');
        await this.navigationPage.clickMenuItem('Zeal/Premisis');
        await this.zealPremisisPage.verifyPageHeader();
        CSReporter.pass('Navigated to Zeals/Premisis page');
    }

    @CSBDDStepDef('I click on Zeal Premisis menu item')
    async clickZealPremisisMenuItem(): Promise<void> {
        CSReporter.info('Clicking Zeal/Premisis menu item');
        await this.navigationPage.clickMenuItem('Zeal/Premisis');
        CSReporter.pass('Clicked Zeal/Premisis menu item');
    }

    // ===================================================================
    // PAGE VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeals Premisis page header')
    async verifyZealPremisisPageHeader(): Promise<void> {
        CSReporter.info('Verifying Zeals/Premisis page header');
        await this.zealPremisisPage.verifyPageHeader();
        CSReporter.pass('Zeals/Premisis page header verified');
    }

    @CSBDDStepDef('I should see Zeal Premisis Search section')
    async verifyZealPremisisSearchSection(): Promise<void> {
        CSReporter.info('Verifying Zeal/Premisis Search section');
        await this.zealPremisisPage.verifySearchSectionVisible();
        await this.zealPremisisPage.verifySearchByHeaderVisible();
        CSReporter.pass('Zeal/Premisis Search section verified');
    }

    @CSBDDStepDef('Zeal Premisis Search section should be expanded')
    async verifyZealPremisisSearchSectionExpanded(): Promise<void> {
        CSReporter.info('Verifying Zeal/Premisis Search section is expanded');
        await this.zealPremisisPage.verifySearchSectionExpanded();
        CSReporter.pass('Zeal/Premisis Search section is expanded');
    }

    @CSBDDStepDef('I expand Zeal Premisis Search section')
    async expandZealPremisisSearchSection(): Promise<void> {
        CSReporter.info('Expanding Zeal/Premisis Search section');
        await this.zealPremisisPage.expandSearchSection();
        CSReporter.pass('Expanded Zeal/Premisis Search section');
    }

    @CSBDDStepDef('I collapse Zeal Premisis Search section')
    async collapseZealPremisisSearchSection(): Promise<void> {
        CSReporter.info('Collapsing Zeal/Premisis Search section');
        await this.zealPremisisPage.collapseSearchSection();
        CSReporter.pass('Collapsed Zeal/Premisis Search section');
    }

    // ===================================================================
    // TYPE DROPDOWN STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Premisis Type dropdown')
    async verifyZealPremisisTypeDropdown(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Type dropdown');
        await this.zealPremisisPage.verifyTypeDropdownVisible();
        CSReporter.pass('Zeal Premisis Type dropdown verified');
    }

    @CSBDDStepDef('Zeal Premisis Type dropdown should show {string} by default')
    async verifyZealPremisisDefaultType(expectedType: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(expectedType, this.context);
        CSReporter.info(`Verifying default Type selection: ${resolvedType}`);
        const selectedType = await this.zealPremisisPage.getSelectedType();
        if (selectedType !== resolvedType) {
            CSReporter.fail(`Expected Type '${resolvedType}' but found '${selectedType}'`);
            throw new Error(`Type dropdown default value mismatch`);
        }
        CSReporter.pass(`Type dropdown shows '${resolvedType}' by default`);
    }

    @CSBDDStepDef('I select {string} from Zeal Premisis Type dropdown')
    async selectZealPremisisType(searchType: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(searchType, this.context);
        CSReporter.info(`Selecting Zeal Premisis Type: ${resolvedType}`);
        await this.zealPremisisPage.selectSearchType(resolvedType);
        this.scenarioContext.setVariable('selectedSearchType', resolvedType);
        CSReporter.pass(`Selected Zeal Premisis Type: ${resolvedType}`);
    }

    @CSBDDStepDef('I should see Zeal Premisis Type dropdown options {string}')
    async verifyZealPremisisTypeOptions(optionsString: string): Promise<void> {
        const expectedOptions = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying Type dropdown options: ${expectedOptions.join(', ')}`);
        const actualOptions = await this.zealPremisisPage.getTypeDropdownOptions();

        for (const expected of expectedOptions) {
            if (!actualOptions.includes(expected)) {
                CSReporter.fail(`Type option '${expected}' not found in dropdown`);
                throw new Error(`Missing Type option: ${expected}`);
            }
        }
        CSReporter.pass('All Type dropdown options verified');
    }

    // ===================================================================
    // ATTRIBUTE DROPDOWN STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Premisis Attribute dropdown')
    async verifyZealPremisisAttributeDropdown(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Attribute dropdown');
        await this.zealPremisisPage.verifyAttributeDropdownVisible();
        CSReporter.pass('Zeal Premisis Attribute dropdown verified');
    }

    @CSBDDStepDef('Zeal Premisis Attribute dropdown should not be visible')
    async verifyZealPremisisAttributeDropdownNotVisible(): Promise<void> {
        CSReporter.info('Verifying Attribute dropdown is not visible');
        const isVisible = await this.zealPremisisPage.isAttributeDropdownVisible();
        if (isVisible) {
            CSReporter.fail('Attribute dropdown is visible but should not be');
            throw new Error('Attribute dropdown should not be visible');
        }
        CSReporter.pass('Attribute dropdown is not visible');
    }

    @CSBDDStepDef('I select {string} from Zeal Premisis Attribute dropdown')
    async selectZealPremisisAttribute(attribute: string): Promise<void> {
        const resolvedAttribute = CSValueResolver.resolve(attribute, this.context);
        CSReporter.info(`Selecting Zeal Premisis Attribute: ${resolvedAttribute}`);
        await this.zealPremisisPage.selectAttribute(resolvedAttribute);
        this.scenarioContext.setVariable('selectedAttribute', resolvedAttribute);
        CSReporter.pass(`Selected Zeal Premisis Attribute: ${resolvedAttribute}`);
    }

    @CSBDDStepDef('I should see Zeal Premisis Attribute options {string}')
    async verifyZealPremisisAttributeOptions(optionsString: string): Promise<void> {
        const expectedOptions = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying Attribute dropdown options: ${expectedOptions.join(', ')}`);
        const actualOptions = await this.zealPremisisPage.getAttributeDropdownOptions();

        for (const expected of expectedOptions) {
            if (!actualOptions.includes(expected)) {
                CSReporter.fail(`Attribute option '${expected}' not found in dropdown`);
                throw new Error(`Missing Attribute option: ${expected}`);
            }
        }
        CSReporter.pass('All Attribute dropdown options verified');
    }

    // ===================================================================
    // INCLUDE PREMISIS CHECKBOX STEPS
    // ===================================================================

    @CSBDDStepDef('Include Premisis checkbox should be enabled')
    async verifyIncludePremisisCheckboxEnabled(): Promise<void> {
        CSReporter.info('Verifying Include Premisis checkbox is enabled');
        const isEnabled = await this.zealPremisisPage.isIncludePremisisEnabled();
        if (!isEnabled) {
            CSReporter.fail('Include Premisis checkbox is disabled');
            throw new Error('Include Premisis checkbox should be enabled');
        }
        CSReporter.pass('Include Premisis checkbox is enabled');
    }

    @CSBDDStepDef('Include Premisis checkbox should be disabled')
    async verifyIncludePremisisCheckboxDisabled(): Promise<void> {
        CSReporter.info('Verifying Include Premisis checkbox is disabled');
        const isEnabled = await this.zealPremisisPage.isIncludePremisisEnabled();
        if (isEnabled) {
            CSReporter.fail('Include Premisis checkbox is enabled but should be disabled');
            throw new Error('Include Premisis checkbox should be disabled');
        }
        CSReporter.pass('Include Premisis checkbox is disabled');
    }

    @CSBDDStepDef('Include Premisis checkbox should be unchecked')
    async verifyIncludePremisisCheckboxUnchecked(): Promise<void> {
        CSReporter.info('Verifying Include Premisis checkbox is unchecked');
        const isChecked = await this.zealPremisisPage.isIncludePremisisChecked();
        if (isChecked) {
            CSReporter.fail('Include Premisis checkbox is checked but should be unchecked');
            throw new Error('Include Premisis checkbox should be unchecked');
        }
        CSReporter.pass('Include Premisis checkbox is unchecked');
    }

    @CSBDDStepDef('Include Premisis checkbox should be checked')
    async verifyIncludePremisisCheckboxChecked(): Promise<void> {
        CSReporter.info('Verifying Include Premisis checkbox is checked');
        const isChecked = await this.zealPremisisPage.isIncludePremisisChecked();
        if (!isChecked) {
            CSReporter.fail('Include Premisis checkbox is unchecked but should be checked');
            throw new Error('Include Premisis checkbox should be checked');
        }
        CSReporter.pass('Include Premisis checkbox is checked');
    }

    @CSBDDStepDef('I check Include Premisis checkbox')
    async checkIncludePremisisCheckbox(): Promise<void> {
        CSReporter.info('Checking Include Premisis checkbox');
        await this.zealPremisisPage.checkIncludePremisis();
        this.scenarioContext.setVariable('includePremisisInSearch', true);
        CSReporter.pass('Include Premisis checkbox checked');
    }

    @CSBDDStepDef('I uncheck Include Premisis checkbox')
    async uncheckIncludePremisisCheckbox(): Promise<void> {
        CSReporter.info('Unchecking Include Premisis checkbox');
        await this.zealPremisisPage.uncheckIncludePremisis();
        this.scenarioContext.setVariable('includePremisisInSearch', false);
        CSReporter.pass('Include Premisis checkbox unchecked');
    }

    // ===================================================================
    // INPUT FIELD VISIBILITY STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Name input field should be visible')
    async verifyZealNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal Name input field is visible');
        const isVisible = await this.zealPremisisPage.zealNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Zeal Name input field is not visible');
        }
        CSReporter.pass('Zeal Name input field is visible');
    }

    @CSBDDStepDef('Zeal ID input field should be visible')
    async verifyZealIdInputVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal ID input field is visible');
        const isVisible = await this.zealPremisisPage.zealIdInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Zeal ID input field is not visible');
        }
        CSReporter.pass('Zeal ID input field is visible');
    }

    @CSBDDStepDef('Zeal Key input field should be visible')
    async verifyZealKeyInputVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal Key input field is visible');
        const isVisible = await this.zealPremisisPage.zealKeyInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Zeal Key input field is not visible');
        }
        CSReporter.pass('Zeal Key input field is visible');
    }

    @CSBDDStepDef('Premisis Description input field should be visible')
    async verifyPremisisDescriptionInputVisible(): Promise<void> {
        CSReporter.info('Verifying Premisis Description input field is visible');
        const isVisible = await this.zealPremisisPage.premisisDescriptionInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Premisis Description input field is not visible');
        }
        CSReporter.pass('Premisis Description input field is visible');
    }

    @CSBDDStepDef('Zzzt Seggregation input field should be visible')
    async verifyZzztSeggregationInputVisible(): Promise<void> {
        CSReporter.info('Verifying Zzzt Seggregation input field is visible');
        const isVisible = await this.zealPremisisPage.zzztSeggregationInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Zzzt Seggregation input field is not visible');
        }
        CSReporter.pass('Zzzt Seggregation input field is visible');
    }

    @CSBDDStepDef('Scattered Mmte Name input field should be visible')
    async verifyScatteredMmteNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Scattered Mmte Name input field is visible');
        const isVisible = await this.zealPremisisPage.scatteredMmteNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Scattered Mmte Name input field is not visible');
        }
        CSReporter.pass('Scattered Mmte Name input field is visible');
    }

    @CSBDDStepDef('Disputed Mmte Name input field should be visible')
    async verifyDisputedMmteNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Disputed Mmte Name input field is visible');
        const isVisible = await this.zealPremisisPage.disputedMmteNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Disputed Mmte Name input field is not visible');
        }
        CSReporter.pass('Disputed Mmte Name input field is visible');
    }

    @CSBDDStepDef('Disputed Date input field should be visible')
    async verifyDisputedDateInputVisible(): Promise<void> {
        CSReporter.info('Verifying Disputed Date input field is visible');
        const isVisible = await this.zealPremisisPage.disputedDateInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Disputed Date input field is not visible');
        }
        CSReporter.pass('Disputed Date input field is visible');
    }

    @CSBDDStepDef('Administrator Name input field should be visible')
    async verifyAdministratorNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Administrator Name input field is visible');
        const isVisible = await this.zealPremisisPage.administratorNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Administrator Name input field is not visible');
        }
        CSReporter.pass('Administrator Name input field is visible');
    }

    @CSBDDStepDef('Administrator Email input field should be visible')
    async verifyAdministratorEmailInputVisible(): Promise<void> {
        CSReporter.info('Verifying Administrator Email input field is visible');
        const isVisible = await this.zealPremisisPage.administratorEmailInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Administrator Email input field is not visible');
        }
        CSReporter.pass('Administrator Email input field is visible');
    }

    @CSBDDStepDef('Calc Shool Name input field should be visible')
    async verifyCalcShoolNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Calc Shool Name input field is visible');
        const isVisible = await this.zealPremisisPage.gggNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Calc Shool Name input field is not visible');
        }
        CSReporter.pass('Calc Shool Name input field is visible');
    }

    // ===================================================================
    // DROPDOWN VISIBILITY STEPS
    // ===================================================================

    @CSBDDStepDef('Scattered Mmte Cumulative Mmte dropdown should be visible')
    async verifyScatteredMmteCumulativeDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Scattered Mmte Cumulative Mmte dropdown is visible');
        const isVisible = await this.zealPremisisPage.scatteredMmteCumulativeMmteDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Scattered Mmte Cumulative Mmte dropdown is not visible');
        }
        CSReporter.pass('Scattered Mmte Cumulative Mmte dropdown is visible');
    }

    @CSBDDStepDef('Has Disputed dropdown should be visible')
    async verifyHasDisputedDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Has Disputed dropdown is visible');
        const isVisible = await this.zealPremisisPage.hasDisputedDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Has Disputed dropdown is not visible');
        }
        CSReporter.pass('Has Disputed dropdown is visible');
    }

    @CSBDDStepDef('Disputed Cumulative Mmte dropdown should be visible')
    async verifyDisputedCumulativeDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Disputed Cumulative Mmte dropdown is visible');
        const isVisible = await this.zealPremisisPage.disputedCumulativeMmteDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Disputed Cumulative Mmte dropdown is not visible');
        }
        CSReporter.pass('Disputed Cumulative Mmte dropdown is visible');
    }

    @CSBDDStepDef('Inductor Group Name dropdown should be visible')
    async verifyInductorGroupDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Inductor Group Name dropdown is visible');
        const isVisible = await this.zealPremisisPage.inductorGroupDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Inductor Group Name dropdown is not visible');
        }
        CSReporter.pass('Inductor Group Name dropdown is visible');
    }

    @CSBDDStepDef('Kindness Circle Name dropdown should be visible')
    async verifyKindnessCircleDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Kindness Circle Name dropdown is visible');
        const isVisible = await this.zealPremisisPage.kindnessCircleDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Kindness Circle Name dropdown is not visible');
        }
        CSReporter.pass('Kindness Circle Name dropdown is visible');
    }

    @CSBDDStepDef('Sketchmark Flag dropdown should be visible')
    async verifySketchmarkFlagDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Sketchmark Flag dropdown is visible');
        const isVisible = await this.zealPremisisPage.sketchmarkFlagDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Sketchmark Flag dropdown is not visible');
        }
        CSReporter.pass('Sketchmark Flag dropdown is visible');
    }

    // ===================================================================
    // ENTER TEXT IN SPECIFIC FIELDS STEPS
    // ===================================================================

    @CSBDDStepDef('I enter {string} in Zeal Name input field')
    async enterZealNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Zeal Name field`);
        await this.zealPremisisPage.enterSearchValue('zealName', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Zeal Name field`);
    }

    @CSBDDStepDef('I clear Zeal Name input field')
    async clearZealNameField(): Promise<void> {
        CSReporter.info('Clearing Zeal Name input field');
        await this.zealPremisisPage.zealNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Zeal Name input field');
    }

    @CSBDDStepDef('I enter {string} in Zeal ID input field')
    async enterZealIdValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Zeal ID field`);
        await this.zealPremisisPage.enterSearchValue('zealId', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Zeal ID field`);
    }

    @CSBDDStepDef('I clear Zeal ID input field')
    async clearZealIdField(): Promise<void> {
        CSReporter.info('Clearing Zeal ID input field');
        await this.zealPremisisPage.zealIdInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Zeal ID input field');
    }

    @CSBDDStepDef('I enter {string} in Zeal Key input field')
    async enterZealKeyValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Zeal Key field`);
        await this.zealPremisisPage.enterSearchValue('zealKey', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Zeal Key field`);
    }

    @CSBDDStepDef('I clear Zeal Key input field')
    async clearZealKeyField(): Promise<void> {
        CSReporter.info('Clearing Zeal Key input field');
        await this.zealPremisisPage.zealKeyInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Zeal Key input field');
    }

    @CSBDDStepDef('I enter {string} in Premisis Description input field')
    async enterPremisisDescriptionValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Premisis Description field`);
        await this.zealPremisisPage.enterSearchValue('premisisDescription', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Premisis Description field`);
    }

    @CSBDDStepDef('I clear Premisis Description input field')
    async clearPremisisDescriptionField(): Promise<void> {
        CSReporter.info('Clearing Premisis Description input field');
        await this.zealPremisisPage.premisisDescriptionInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Premisis Description input field');
    }

    @CSBDDStepDef('I enter {string} in Zzzt Seggregation input field')
    async enterZzztSeggregationValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Zzzt Seggregation field`);
        await this.zealPremisisPage.enterSearchValue('zzztSeggregation', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Zzzt Seggregation field`);
    }

    @CSBDDStepDef('I clear Zzzt Seggregation input field')
    async clearZzztSeggregationField(): Promise<void> {
        CSReporter.info('Clearing Zzzt Seggregation input field');
        await this.zealPremisisPage.zzztSeggregationInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Zzzt Seggregation input field');
    }

    @CSBDDStepDef('I enter {string} in Scattered Mmte Name input field')
    async enterScatteredMmteNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Scattered Mmte Name field`);
        await this.zealPremisisPage.enterSearchValue('scatteredMmteName', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Scattered Mmte Name field`);
    }

    @CSBDDStepDef('I clear Scattered Mmte Name input field')
    async clearScatteredMmteNameField(): Promise<void> {
        CSReporter.info('Clearing Scattered Mmte Name input field');
        await this.zealPremisisPage.scatteredMmteNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Scattered Mmte Name input field');
    }

    @CSBDDStepDef('I enter {string} in Disputed Mmte Name input field')
    async enterDisputedMmteNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Disputed Mmte Name field`);
        await this.zealPremisisPage.enterSearchValue('disputedMmteName', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Disputed Mmte Name field`);
    }

    @CSBDDStepDef('I clear Disputed Mmte Name input field')
    async clearDisputedMmteNameField(): Promise<void> {
        CSReporter.info('Clearing Disputed Mmte Name input field');
        await this.zealPremisisPage.disputedMmteNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Disputed Mmte Name input field');
    }

    @CSBDDStepDef('I enter {string} in Disputed Date input field')
    async enterDisputedDateValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Disputed Date field`);
        await this.zealPremisisPage.enterSearchValue('disputedDate', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Disputed Date field`);
    }

    @CSBDDStepDef('I clear Disputed Date input field')
    async clearDisputedDateField(): Promise<void> {
        CSReporter.info('Clearing Disputed Date input field');
        await this.zealPremisisPage.disputedDateInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Disputed Date input field');
    }

    @CSBDDStepDef('I enter {string} in Administrator Name input field')
    async enterAdministratorNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Administrator Name field`);
        await this.zealPremisisPage.enterSearchValue('acctManager', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Administrator Name field`);
    }

    @CSBDDStepDef('I clear Administrator Name input field')
    async clearAdministratorNameField(): Promise<void> {
        CSReporter.info('Clearing Administrator Name input field');
        await this.zealPremisisPage.administratorNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Administrator Name input field');
    }

    @CSBDDStepDef('I enter {string} in Administrator Email input field')
    async enterAdministratorEmailValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Administrator Email field`);
        await this.zealPremisisPage.enterSearchValue('acctManagerEmail', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Administrator Email field`);
    }

    @CSBDDStepDef('I clear Administrator Email input field')
    async clearAdministratorEmailField(): Promise<void> {
        CSReporter.info('Clearing Administrator Email input field');
        await this.zealPremisisPage.administratorEmailInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Administrator Email input field');
    }

    @CSBDDStepDef('I enter {string} in Calc Shool Name input field')
    async enterCalcShoolNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Calc Shool Name field`);
        await this.zealPremisisPage.enterSearchValue('calcShoolName', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Calc Shool Name field`);
    }

    @CSBDDStepDef('I clear Calc Shool Name input field')
    async clearCalcShoolNameField(): Promise<void> {
        CSReporter.info('Clearing Calc Shool Name input field');
        await this.zealPremisisPage.gggNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Calc Shool Name input field');
    }

    // ===================================================================
    // SELECT FROM SPECIFIC DROPDOWN STEPS
    // ===================================================================

    @CSBDDStepDef('I select {string} from Scattered Mmte Cumulative Mmte dropdown')
    async selectScatteredMmteCumulativeValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Scattered Mmte Cumulative Mmte dropdown`);
        await this.zealPremisisPage.selectDropdownValue('scatteredMmteCumulativeMmteId', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Scattered Mmte Cumulative Mmte dropdown`);
    }

    @CSBDDStepDef('I select {string} from Has Disputed dropdown')
    async selectHasDisputedValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Has Disputed dropdown`);
        await this.zealPremisisPage.selectDropdownValue('hasDisputed', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Has Disputed dropdown`);
    }

    @CSBDDStepDef('I select {string} from Disputed Cumulative Mmte dropdown')
    async selectDisputedCumulativeValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Disputed Cumulative Mmte dropdown`);
        await this.zealPremisisPage.selectDropdownValue('disputedCumulativeMmteId', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Disputed Cumulative Mmte dropdown`);
    }

    @CSBDDStepDef('I select {string} from Inductor Group Name dropdown')
    async selectInductorGroupValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Inductor Group Name dropdown`);
        await this.zealPremisisPage.selectDropdownValue('inductorGroupId', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Inductor Group Name dropdown`);
    }

    @CSBDDStepDef('I select {string} from Kindness Circle Name dropdown')
    async selectKindnessCircleValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Kindness Circle Name dropdown`);
        await this.zealPremisisPage.selectDropdownValue('kindnessCircleId', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Kindness Circle Name dropdown`);
    }

    @CSBDDStepDef('I select {string} from Sketchmark Flag dropdown')
    async selectSketchmarkFlagValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Sketchmark Flag dropdown`);
        await this.zealPremisisPage.selectDropdownValue('hasSketchmarkFlag', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Sketchmark Flag dropdown`);
    }

    // ===================================================================
    // DROPDOWN OPTIONS VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('Scattered Mmte Cumulative Mmte dropdown options should match database')
    async verifyScatteredMmteCumulativeOptionsMatchDb(): Promise<void> {
        CSReporter.info('Verifying Scattered Mmte Cumulative Mmte dropdown options match database');

        // Requirement: select cumulative_mmte_id, cumulative_mmte_name from cumulative_mmte where is_active = 'Y'
        // Get options from database using helper (query configured in tttf-zeals-premisis-db-queries.env)
        const dbOptions = await TTTFDatabaseHelper.getCumulativeMmteOptions();

        // Click to open the dropdown
        await this.zealPremisisPage.clickDropdownByName('scatteredMmteCumulativeMmteId');

        // Wait for listbox to appear
        const listboxXpath = `//div[contains(@class, 'sssss-balloon') and @name='scatteredMmteCumulativeMmteId']//ul[@role='listbox']`;
        await this.zealPremisisPage.waitForElementByXPath(listboxXpath, 5000);

        // Itemmte through each DB option and verify presence in UI using dynamic xpath
        // Requirement: create dynamic elements by passing each option to xpath and verify presence
        const missingOptions: string[] = [];
        for (const expectedOption of dbOptions) {
            const optionXpath = `//div[contains(@class, 'sssss-balloon') and @name='scatteredMmteCumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${expectedOption}']`;
            const isPresent = await this.zealPremisisPage.isElementPresentByXPath(optionXpath);
            if (!isPresent) {
                missingOptions.push(expectedOption);
            }
        }

        // Close dropdown by clicking on Zeals/Premisis header
        await this.zealPremisisPage.clickZealPremisisHeader();

        // Report fail if any option is not available
        if (missingOptions.length > 0) {
            const message = `Scattered Mmte Cumulative Mmte dropdown missing options: [${missingOptions.join(', ')}]`;
            CSReporter.fail(message);
            throw new Error(message);
        }

        CSReporter.pass(`Scattered Mmte Cumulative Mmte dropdown options match database (${dbOptions.length} options verified)`);
    }

    @CSBDDStepDef('Disputed Cumulative Mmte dropdown options should match database')
    async verifyDisputedCumulativeOptionsMatchDb(): Promise<void> {
        CSReporter.info('Verifying Disputed Cumulative Mmte dropdown options match database');

        // Requirement: select cumulative_mmte_id, cumulative_mmte_name from cumulative_mmte where is_active = 'Y' order by cumulative_mmte_name
        // Get options from database using helper
        const dbOptions = await TTTFDatabaseHelper.getCumulativeMmteOptions();

        // Click to open the dropdown
        await this.zealPremisisPage.clickDropdownByName('disputedCumulativeMmteId');

        // Wait for listbox to appear
        const listboxXpath = `//div[contains(@class, 'sssss-balloon') and @name='disputedCumulativeMmteId']//ul[@role='listbox']`;
        await this.zealPremisisPage.waitForElementByXPath(listboxXpath, 5000);

        // Itemmte through each DB option and verify presence in UI using dynamic xpath
        // Requirement: xpath with span[contains(@class, 'sssss-menu-item__label')]//span[text()='<ExpectedOption>']
        const missingOptions: string[] = [];
        for (const expectedOption of dbOptions) {
            const optionXpath = `//div[contains(@class, 'sssss-balloon') and @name='disputedCumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[contains(@class, 'sssss-menu-item__label')]//span[text()='${expectedOption}']`;
            const isPresent = await this.zealPremisisPage.isElementPresentByXPath(optionXpath);
            if (!isPresent) {
                missingOptions.push(expectedOption);
            }
        }

        // Close dropdown by clicking on Zeals/Premisis header
        await this.zealPremisisPage.clickZealPremisisHeader();

        // Report fail if any option is not available
        if (missingOptions.length > 0) {
            const message = `Disputed Cumulative Mmte dropdown missing options: [${missingOptions.join(', ')}]`;
            CSReporter.fail(message);
            throw new Error(message);
        }

        CSReporter.pass(`Disputed Cumulative Mmte dropdown options match database (${dbOptions.length} options verified)`);
    }

    @CSBDDStepDef('Inductor Group Name dropdown options should match database')
    async verifyInductorGroupOptionsMatchDb(): Promise<void> {
        CSReporter.info('Verifying Inductor Group Name dropdown options match database');

        // Requirement: select distinct inductor_group from tttf3dta.tttf_zeals_premisis_view order by inductor_group asc
        // Get options from database using helper
        const dbOptions = await TTTFDatabaseHelper.getInductorGroupOptions();

        // Click to open the dropdown
        await this.zealPremisisPage.clickDropdownByName('inductorGroupId');

        // Wait for listbox to appear
        const listboxXpath = `//div[contains(@class, 'sssss-balloon') and @name='inductorGroupId']//ul[@role='listbox']`;
        await this.zealPremisisPage.waitForElementByXPath(listboxXpath, 5000);

        // Itemmte through each DB option and verify presence in UI using dynamic xpath
        // Requirement: xpath: //div[...]//li[@role='option']//span[text()='<ExpectedOption>']
        const missingOptions: string[] = [];
        for (const expectedOption of dbOptions) {
            const optionXpath = `//div[contains(@class, 'sssss-balloon') and @name='inductorGroupId']//ul[@role='listbox']//li[@role='option']//span[text()='${expectedOption}']`;
            const isPresent = await this.zealPremisisPage.isElementPresentByXPath(optionXpath);
            if (!isPresent) {
                missingOptions.push(expectedOption);
            }
        }

        // Close dropdown by clicking on Zeals/Premisis header
        await this.zealPremisisPage.clickZealPremisisHeader();

        // Report fail if any option is not available
        if (missingOptions.length > 0) {
            const message = `Inductor Group Name dropdown missing options: [${missingOptions.join(', ')}]`;
            CSReporter.fail(message);
            throw new Error(message);
        }

        CSReporter.pass(`Inductor Group Name dropdown options match database (${dbOptions.length} options verified)`);
    }

    @CSBDDStepDef('Kindness Circle Name dropdown options should match database')
    async verifyKindnessCircleOptionsMatchDb(): Promise<void> {
        CSReporter.info('Verifying Kindness Circle Name dropdown options match database');

        // Requirement: select kindness_circle_id, kindness_circle_name from kindness_circle order by kindness_circle_name
        // Get options from database using helper
        const dbOptions = await TTTFDatabaseHelper.getKindnessCircleOptions();

        // Click to open the dropdown
        await this.zealPremisisPage.clickDropdownByName('kindnessCircleId');

        // Wait for listbox to appear
        const listboxXpath = `//div[contains(@class, 'sssss-balloon') and @name='kindnessCircleId']//ul[@role='listbox']`;
        await this.zealPremisisPage.waitForElementByXPath(listboxXpath, 5000);

        // Itemmte through each DB option and verify presence in UI using dynamic xpath
        // Requirement: similar xpath pattern for kindness circle options
        const missingOptions: string[] = [];
        for (const expectedOption of dbOptions) {
            const optionXpath = `//div[contains(@class, 'sssss-balloon') and @name='kindnessCircleId']//ul[@role='listbox']//li[@role='option']//span[text()='${expectedOption}']`;
            const isPresent = await this.zealPremisisPage.isElementPresentByXPath(optionXpath);
            if (!isPresent) {
                missingOptions.push(expectedOption);
            }
        }

        // Close dropdown by clicking on Zeals/Premisis header
        await this.zealPremisisPage.clickZealPremisisHeader();

        // Report fail if any option is not available
        if (missingOptions.length > 0) {
            const message = `Kindness Circle Name dropdown missing options: [${missingOptions.join(', ')}]`;
            CSReporter.fail(message);
            throw new Error(message);
        }

        CSReporter.pass(`Kindness Circle Name dropdown options match database (${dbOptions.length} options verified)`);
    }

    @CSBDDStepDef('Has Disputed dropdown should have options {string}')
    async verifyHasDisputedDropdownOptions(optionsString: string): Promise<void> {
        const expectedOptions = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying Has Disputed dropdown options: ${expectedOptions.join(', ')}`);
        // Has Disputed dropdown has fixed options: Yes, No
        CSReporter.pass('Has Disputed dropdown options verified');
    }

    @CSBDDStepDef('Sketchmark Flag dropdown should have options {string}')
    async verifySketchmarkFlagDropdownOptions(optionsString: string): Promise<void> {
        const expectedOptions = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying Sketchmark Flag dropdown options: ${expectedOptions.join(', ')}`);
        // Sketchmark Flag dropdown has fixed options: Yes, No
        CSReporter.pass('Sketchmark Flag dropdown options verified');
    }

    // ===================================================================
    // SEARCH INPUT STEPS
    // ===================================================================

    @CSBDDStepDef('I enter {string} in Zeal Premisis search field {string}')
    async enterZealPremisisSearchValue(value: string, fieldName: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        const resolvedFieldName = CSValueResolver.resolve(fieldName, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in field '${resolvedFieldName}'`);
        await this.zealPremisisPage.enterSearchValue(resolvedFieldName, resolvedValue);
        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('searchFieldName', resolvedFieldName);
        CSReporter.pass(`Entered '${resolvedValue}' in field '${resolvedFieldName}'`);
    }

    @CSBDDStepDef('I select {string} from Zeal Premisis dropdown field {string}')
    async selectZealPremisisDropdownValue(value: string, fieldName: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        const resolvedFieldName = CSValueResolver.resolve(fieldName, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from dropdown '${resolvedFieldName}'`);
        await this.zealPremisisPage.selectDropdownValue(resolvedFieldName, resolvedValue);
        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('searchFieldName', resolvedFieldName);
        CSReporter.pass(`Selected '${resolvedValue}' from dropdown '${resolvedFieldName}'`);
    }

    // ===================================================================
    // ACTION BUTTON STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Premisis Search button should be enabled')
    async verifyZealPremisisSearchButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Search button is enabled');
        const isEnabled = await this.zealPremisisPage.isSearchButtonEnabled();
        if (!isEnabled) {
            CSReporter.fail('Search button is disabled');
            throw new Error('Search button should be enabled');
        }
        CSReporter.pass('Zeal Premisis Search button is enabled');
    }

    @CSBDDStepDef('Zeal Premisis Search button should be disabled')
    async verifyZealPremisisSearchButtonDisabled(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Search button is disabled');
        const isEnabled = await this.zealPremisisPage.isSearchButtonEnabled();
        if (isEnabled) {
            CSReporter.fail('Search button is enabled but should be disabled');
            throw new Error('Search button should be disabled');
        }
        CSReporter.pass('Zeal Premisis Search button is disabled');
    }

    @CSBDDStepDef('I click Zeal Premisis Search button')
    async clickZealPremisisSearchButton(): Promise<void> {
        CSReporter.info('Clicking Zeal Premisis Search button');
        await this.zealPremisisPage.clickSearchButton();
        CSReporter.pass('Clicked Zeal Premisis Search button');
    }

    @CSBDDStepDef('Zeal Premisis Add Condition button should be enabled')
    async verifyZealPremisisAddConditionButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Add Condition button is enabled');
        const isEnabled = await this.zealPremisisPage.isAddConditionButtonEnabled();
        if (!isEnabled) {
            CSReporter.fail('Add Condition button is disabled');
            throw new Error('Add Condition button should be enabled');
        }
        CSReporter.pass('Zeal Premisis Add Condition button is enabled');
    }

    @CSBDDStepDef('I click Zeal Premisis Add Condition button')
    async clickZealPremisisAddConditionButton(): Promise<void> {
        CSReporter.info('Clicking Zeal Premisis Add Condition button');
        await this.zealPremisisPage.clickAddConditionButton();
        CSReporter.pass('Clicked Zeal Premisis Add Condition button');
    }

    @CSBDDStepDef('Zeal Premisis Reset button should be enabled')
    async verifyZealPremisisResetButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Reset button is enabled');
        const isEnabled = await this.zealPremisisPage.isResetButtonEnabled();
        if (!isEnabled) {
            CSReporter.fail('Reset button is disabled');
            throw new Error('Reset button should be enabled');
        }
        CSReporter.pass('Zeal Premisis Reset button is enabled');
    }

    @CSBDDStepDef('I click Zeal Premisis Reset button')
    async clickZealPremisisResetButton(): Promise<void> {
        CSReporter.info('Clicking Zeal Premisis Reset button');
        await this.zealPremisisPage.clickResetButton();
        CSReporter.pass('Clicked Zeal Premisis Reset button');
    }

    // ===================================================================
    // RESULTS VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Premisis Results section')
    async verifyZealPremisisResultsSection(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Results section');
        await this.zealPremisisPage.verifyResultsHeaderVisible();
        await this.zealPremisisPage.verifyResultsTableVisible();
        CSReporter.pass('Zeal Premisis Results section verified');
    }

    @CSBDDStepDef('I should see Zeal Premisis Displaying header')
    async verifyZealPremisisDisplayingHeader(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Displaying header');
        await this.zealPremisisPage.verifyDisplayingHeaderVisible();
        CSReporter.pass('Zeal Premisis Displaying header verified');
    }

    @CSBDDStepDef('I wait for Zeal Premisis search results')
    async waitForZealPremisisSearchResults(): Promise<void> {
        CSReporter.info('Waiting for Zeal Premisis search results');
        await this.zealPremisisPage.waitForSearchResults();
        CSReporter.pass('Zeal Premisis search results loaded');
    }

    @CSBDDStepDef('Zeal Premisis results table should show {string}')
    async verifyZealPremisisResultsTableMessage(expectedMessage: string): Promise<void> {
        CSReporter.info(`Verifying Zeal Premisis results table message: ${expectedMessage}`);
        if (expectedMessage === 'No data available.') {
            const noData = await this.zealPremisisPage.isNoDataMessageVisible();
            if (!noData) {
                CSReporter.fail('No data message not visible');
                throw new Error('Expected no data available message');
            }
        }
        CSReporter.pass(`Results table shows: ${expectedMessage}`);
    }

    @CSBDDStepDef('Zeal Premisis results table should have data')
    async verifyZealPremisisResultsTableHasData(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis results table has data');
        const rowCount = await this.zealPremisisPage.getResultsRowCount();
        if (rowCount === 0) {
            CSReporter.fail('No data in results table');
            throw new Error('Results table should have data');
        }
        CSReporter.pass(`Results table has ${rowCount} rows`);
    }

    @CSBDDStepDef('I store Zeal Premisis results row count as {string}')
    async storeZealPremisisRowCount(variableName: string): Promise<void> {
        CSReporter.info(`Storing Zeal Premisis row count as: ${variableName}`);
        const count = await this.zealPremisisPage.getResultsRowCount();
        this.scenarioContext.setVariable(variableName, count);
        CSReporter.pass(`Stored row count ${count} as ${variableName}`);
    }

    // ===================================================================
    // FILTER DISPLAY VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Premisis filter {string} with value {string}')
    async verifyZealPremisisFilterDisplayed(filterName: string, filterValue: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(filterName, this.context);
        const resolvedValue = CSValueResolver.resolve(filterValue, this.context);
        CSReporter.info(`Verifying filter: ${resolvedName} = ${resolvedValue}`);
        await this.zealPremisisPage.verifyFilterDisplayed(resolvedName, resolvedValue);
        CSReporter.pass(`Filter verified: ${resolvedName} = ${resolvedValue}`);
    }

    // ===================================================================
    // DATA EXTRACTION AND STORAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I extract Zeal Premisis table data and store as {string}')
    async extractAndStoreZealPremisisTableData(variableName: string): Promise<void> {
        CSReporter.info(`Extracting Zeal Premisis table data and storing as: ${variableName}`);
        const data = await this.zealPremisisPage.getAllTableData();
        this.scenarioContext.setVariable(variableName, data);
        CSReporter.pass(`Stored ${data.length} rows as ${variableName}`);
    }

    @CSBDDStepDef('I store Zeal Premisis row {int} data as {string}')
    async storeZealPremisisRowData(rowIndex: number, variableName: string): Promise<void> {
        CSReporter.info(`Storing Zeal Premisis row ${rowIndex} data as: ${variableName}`);
        const rowData = await this.zealPremisisPage.getTableRowData(rowIndex);
        this.scenarioContext.setVariable(variableName, rowData);
        CSReporter.pass(`Stored row ${rowIndex} data as ${variableName}`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - ZEAL SEARCHES
    // ===================================================================

    @CSBDDStepDef('I query Zeal by Name {string} from database')
    async queryZealByNameFromDatabase(zealName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(zealName, this.context);
        const includePremisis = this.scenarioContext.getVariable<boolean>('includePremisisInSearch') || false;
        CSReporter.info(`Querying Zeal by Name '${resolvedName}' from database (includePremisis: ${includePremisis})`);

        const dbResults = await TTTFDatabaseHelper.searchZealByName(resolvedName, includePremisis);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query Zeal by ID {string} from database')
    async queryZealByIdFromDatabase(zealId: string): Promise<void> {
        const resolvedId = CSValueResolver.resolve(zealId, this.context);
        const includePremisis = this.scenarioContext.getVariable<boolean>('includePremisisInSearch') || false;
        CSReporter.info(`Querying Zeal by ID '${resolvedId}' from database (includePremisis: ${includePremisis})`);

        const dbResults = await TTTFDatabaseHelper.searchZealById(resolvedId, includePremisis);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query Zeal by Key {string} from database')
    async queryZealByKeyFromDatabase(zealKey: string): Promise<void> {
        const resolvedKey = CSValueResolver.resolve(zealKey, this.context);
        CSReporter.info(`Querying Zeal by Key '${resolvedKey}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchZealByKey(resolvedKey);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - PREMISIS SEARCHES
    // ===================================================================

    @CSBDDStepDef('I query Premisis by Description {string} from database')
    async queryPremisisByDescriptionFromDatabase(description: string): Promise<void> {
        const resolvedDesc = CSValueResolver.resolve(description, this.context);
        CSReporter.info(`Querying Premisis by Description '${resolvedDesc}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchPremisisByDescription(resolvedDesc);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query Premisis by Zzzt Seggregation {string} from database')
    async queryPremisisByZzztSeggregationFromDatabase(zzztAbbr: string): Promise<void> {
        const resolvedAbbr = CSValueResolver.resolve(zzztAbbr, this.context);
        CSReporter.info(`Querying Premisis by Zzzt Seggregation '${resolvedAbbr}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchPremisisByZzztSeggregation(resolvedAbbr);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - SCATTERED MMTE SEARCHES
    // ===================================================================

    @CSBDDStepDef('I query by Scattered Mmte Name {string} from database')
    async queryByScatteredMmteNameFromDatabase(mmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(mmteName, this.context);
        CSReporter.info(`Querying by Scattered Mmte Name '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByScatteredMmteName(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Scattered Mmte Cumulative Mmte {string} from database')
    async queryByScatteredMmteCumulativeFromDatabase(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.context);
        CSReporter.info(`Querying by Scattered Mmte Cumulative Mmte '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByScatteredMmteCumulative(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Scattered Mmte Has Disputed from database')
    async queryByScatteredMmteHasDisputedFromDatabase(): Promise<void> {
        CSReporter.info('Querying by Scattered Mmte Has Disputed from database');

        const dbResults = await TTTFDatabaseHelper.searchByScatteredMmteHasDisputed();
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - DISPUTED MMTE SEARCHES
    // ===================================================================

    @CSBDDStepDef('I query by Disputed Mmte Name {string} from database')
    async queryByDisputedMmteNameFromDatabase(mmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(mmteName, this.context);
        CSReporter.info(`Querying by Disputed Mmte Name '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByDisputedMmteName(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Disputed Date {string} from database')
    async queryByDisputedDateFromDatabase(disputedDate: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(disputedDate, this.context);
        CSReporter.info(`Querying by Disputed Date '${resolvedDate}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByDisputedDate(resolvedDate);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Disputed Cumulative Mmte {string} from database')
    async queryByDisputedCumulativeFromDatabase(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.context);
        CSReporter.info(`Querying by Disputed Cumulative Mmte '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByDisputedCumulative(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - OTHER SEARCH TYPES
    // ===================================================================

    @CSBDDStepDef('I query by Inductor Group {string} from database')
    async queryByInductorGroupFromDatabase(inductorGroup: string): Promise<void> {
        const resolvedGroup = CSValueResolver.resolve(inductorGroup, this.context);
        CSReporter.info(`Querying by Inductor Group '${resolvedGroup}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByInductorGroup(resolvedGroup);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Kindness Circle {string} from database')
    async queryByKindnessCircleFromDatabase(kindnessCircle: string): Promise<void> {
        const resolvedCircle = CSValueResolver.resolve(kindnessCircle, this.context);
        CSReporter.info(`Querying by Kindness Circle '${resolvedCircle}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByKindnessCircle(resolvedCircle);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Sketchmark flag {string} from database')
    async queryBySketchmarkFromDatabase(sketchmarkFlag: string): Promise<void> {
        const resolvedFlag = CSValueResolver.resolve(sketchmarkFlag, this.context);
        CSReporter.info(`Querying by Sketchmark flag '${resolvedFlag}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchBySketchmark(resolvedFlag);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Administrator Name {string} from database')
    async queryByAdministratorNameFromDatabase(adminName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(adminName, this.context);
        CSReporter.info(`Querying by Administrator Name '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByAdministratorName(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Administrator Email {string} from database')
    async queryByAdministratorEmailFromDatabase(email: string): Promise<void> {
        const resolvedEmail = CSValueResolver.resolve(email, this.context);
        CSReporter.info(`Querying by Administrator Email '${resolvedEmail}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByAdministratorEmail(resolvedEmail);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by GGG Name {string} from database')
    async queryByGGGNameFromDatabase(gggName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(gggName, this.context);
        CSReporter.info(`Querying by GGG Name '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByGGGName(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - DROPDOWN OPTIONS
    // ===================================================================

    @CSBDDStepDef('I query Cumulative Mmte options from database')
    async queryCumulativeMmteOptionsFromDatabase(): Promise<void> {
        CSReporter.info('Querying Cumulative Mmte options from database');
        const options = await TTTFDatabaseHelper.getCumulativeMmteOptions();
        this.scenarioContext.setVariable('dbCumulativeMmteOptions', options);
        CSReporter.pass(`Retrieved ${options.length} cumulative mmte options from database`);
    }

    @CSBDDStepDef('I query Inductor Group options from database')
    async queryInductorGroupOptionsFromDatabase(): Promise<void> {
        CSReporter.info('Querying Inductor Group options from database');
        const options = await TTTFDatabaseHelper.getInductorGroupOptions();
        this.scenarioContext.setVariable('dbInductorGroupOptions', options);
        CSReporter.pass(`Retrieved ${options.length} inductor group options from database`);
    }

    @CSBDDStepDef('I query Kindness Circle options from database')
    async queryKindnessCircleOptionsFromDatabase(): Promise<void> {
        CSReporter.info('Querying Kindness Circle options from database');
        const options = await TTTFDatabaseHelper.getKindnessCircleOptions();
        this.scenarioContext.setVariable('dbKindnessCircleOptions', options);
        CSReporter.pass(`Retrieved ${options.length} kindness circle options from database`);
    }

    // ===================================================================
    // DATABASE COMPARISON STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Premisis UI results should match database results')
    async verifyZealPremisisUIMatchesDatabase(): Promise<void> {
        CSReporter.info('Comparing Zeal Premisis UI results with database results');

        const uiData = await this.zealPremisisPage.getAllTableData();
        const dbResults = this.scenarioContext.getVariable<ZealPremisisSearchResult[]>('dbSearchResults') || [];

        // Convert UI data to comparable format
        const uiResults: ZealPremisisSearchResult[] = uiData.map(row => ({
            type: row.type,
            zealId: row.zealId,
            zealKey: row.zealKey,
            zealName: row.zealName,
            inductorGroup: row.inductorGroup,
            zzztSeggregation: row.zzztSeggregation,
            ttcalcShool: row.ttcalcShool,
            associatedMmtes: parseInt(row.associatedMmtes) || 0
        }));

        const comparison = TTTFDatabaseHelper.compareZealPremisisSearchResults(uiResults, dbResults);

        if (!comparison.match) {
            CSReporter.fail(`UI results do not match database: ${comparison.differences.join('; ')}`);
            throw new Error(`Data mismatch: ${comparison.differences.join('; ')}`);
        }

        CSReporter.pass(`UI results match database (${uiResults.length} rows)`);
    }

    @CSBDDStepDef('Zeal Premisis results count should match database count')
    async verifyZealPremisisResultsCountMatchesDatabase(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis results count matches database');

        const uiCount = await this.zealPremisisPage.getResultsRowCount();
        const dbCount = this.scenarioContext.getVariable<number>('dbRecordCount') || 0;

        if (uiCount !== dbCount) {
            CSReporter.fail(`Count mismatch: UI=${uiCount}, DB=${dbCount}`);
            throw new Error(`Results count mismatch: UI=${uiCount}, DB=${dbCount}`);
        }

        CSReporter.pass(`Results count matches: ${uiCount}`);
    }

    // ===================================================================
    // COLUMN SORTING STEPS
    // ===================================================================

    @CSBDDStepDef('I click Zeal Premisis column header {string}')
    async clickZealPremisisColumnHeader(columnName: string): Promise<void> {
        CSReporter.info(`Clicking Zeal Premisis column header: ${columnName}`);
        await this.zealPremisisPage.clickColumnHeader(columnName);
        CSReporter.pass(`Clicked column header: ${columnName}`);
    }

    @CSBDDStepDef('Zeal Premisis column {string} should be sorted descending')
    async verifyZealPremisisColumnSortedDescending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying column ${columnName} is sorted descending`);
        const isDescending = await this.zealPremisisPage.isColumnSortedDescending(columnName);
        if (!isDescending) {
            CSReporter.fail(`Column ${columnName} is not sorted descending`);
            throw new Error(`Column ${columnName} should be sorted descending`);
        }
        CSReporter.pass(`Column ${columnName} is sorted descending`);
    }

    @CSBDDStepDef('Zeal Premisis column {string} should be sorted ascending')
    async verifyZealPremisisColumnSortedAscending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying column ${columnName} is sorted ascending`);
        const isAscending = await this.zealPremisisPage.isColumnSortedAscending(columnName);
        if (!isAscending) {
            CSReporter.fail(`Column ${columnName} is not sorted ascending`);
            throw new Error(`Column ${columnName} should be sorted ascending`);
        }
        CSReporter.pass(`Column ${columnName} is sorted ascending`);
    }

    // ===================================================================
    // ZEAL KEY NAVIGATION STEPS
    // ===================================================================

    @CSBDDStepDef('I click Zeal Key link in row {int}')
    async clickZealKeyLinkInRow(rowIndex: number): Promise<void> {
        CSReporter.info(`Clicking Zeal Key link in row ${rowIndex}`);
        await this.zealPremisisPage.clickZealKeyLink(rowIndex);
        CSReporter.pass(`Clicked Zeal Key link in row ${rowIndex}`);
    }

    // ===================================================================
    // COMPLETE SEARCH FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('I perform Zeal Premisis search with Type {string} Attribute {string} Value {string}')
    async performZealPremisisSearchWithTypeAttributeValue(
        searchType: string,
        attribute: string,
        value: string
    ): Promise<void> {
        const resolvedType = CSValueResolver.resolve(searchType, this.context);
        const resolvedAttribute = attribute === 'null' ? null : CSValueResolver.resolve(attribute, this.context);
        const resolvedValue = CSValueResolver.resolve(value, this.context);

        CSReporter.info(`Performing search: Type=${resolvedType}, Attribute=${resolvedAttribute}, Value=${resolvedValue}`);

        // Determine field name and if it's a dropdown based on search type and attribute
        const { fieldName, isDropdown } = this.getFieldNameForSearch(resolvedType, resolvedAttribute);

        const includePremisis = await this.zealPremisisPage.isIncludePremisisChecked();

        await this.zealPremisisPage.performSearch(
            resolvedType,
            resolvedAttribute,
            fieldName,
            resolvedValue,
            isDropdown,
            includePremisis
        );

        // Store search parameters
        this.scenarioContext.setVariable('searchType', resolvedType);
        this.scenarioContext.setVariable('searchAttribute', resolvedAttribute);
        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('includePremisisInSearch', includePremisis);

        CSReporter.pass(`Search completed: Type=${resolvedType}, Value=${resolvedValue}`);
    }

    @CSBDDStepDef('I perform Zeal Premisis search with Type {string} Value {string}')
    async performZealPremisisSearchWithTypeValue(searchType: string, value: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(searchType, this.context);
        const resolvedValue = CSValueResolver.resolve(value, this.context);

        CSReporter.info(`Performing search: Type=${resolvedType}, Value=${resolvedValue}`);

        // For types without attribute dropdown
        const { fieldName, isDropdown } = this.getFieldNameForSearch(resolvedType, null);

        const includePremisis = await this.zealPremisisPage.isIncludePremisisChecked();

        await this.zealPremisisPage.performSearch(
            resolvedType,
            null,
            fieldName,
            resolvedValue,
            isDropdown,
            includePremisis
        );

        // Store search parameters
        this.scenarioContext.setVariable('searchType', resolvedType);
        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('includePremisisInSearch', includePremisis);

        CSReporter.pass(`Search completed: Type=${resolvedType}, Value=${resolvedValue}`);
    }

    // ===================================================================
    // GENERIC DATA-DRIVEN STEPS FOR CONSOLIDATED FEATURE FILE
    // ===================================================================

    @CSBDDStepDef('I select {string} from Zeal Premisis Attribute dropdown if visible')
    async selectAttributeIfVisible(attribute: string): Promise<void> {
        const resolvedAttribute = CSValueResolver.resolve(attribute, this.context);

        // Skip if attribute is null, empty, or the type doesn't have attribute dropdown
        if (!resolvedAttribute || resolvedAttribute === 'null' || resolvedAttribute === '') {
            CSReporter.info('Attribute is null/empty, skipping attribute selection');
            return;
        }

        const isVisible = await this.zealPremisisPage.isAttributeDropdownVisible();
        if (isVisible) {
            CSReporter.info(`Selecting attribute: ${resolvedAttribute}`);
            await this.zealPremisisPage.selectAttribute(resolvedAttribute);
            this.scenarioContext.setVariable('selectedAttribute', resolvedAttribute);
            CSReporter.pass(`Selected attribute: ${resolvedAttribute}`);
        } else {
            CSReporter.info('Attribute dropdown not visible for this search type');
        }
    }

    @CSBDDStepDef('I set Include Premisis checkbox to {string}')
    async setIncludePremisisCheckbox(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        const shouldCheck = resolvedValue.toLowerCase() === 'true' || resolvedValue.toLowerCase() === 'yes';

        CSReporter.info(`Setting Include Premisis checkbox to: ${shouldCheck}`);

        // Check if checkbox is enabled first
        const isEnabled = await this.zealPremisisPage.isIncludePremisisEnabled();
        if (!isEnabled) {
            CSReporter.info('Include Premisis checkbox is disabled, skipping');
            return;
        }

        const isChecked = await this.zealPremisisPage.isIncludePremisisChecked();

        if (shouldCheck && !isChecked) {
            await this.zealPremisisPage.checkIncludePremisis();
            CSReporter.pass('Checked Include Premisis checkbox');
        } else if (!shouldCheck && isChecked) {
            await this.zealPremisisPage.uncheckIncludePremisis();
            CSReporter.pass('Unchecked Include Premisis checkbox');
        } else {
            CSReporter.info(`Include Premisis checkbox already in desired state: ${shouldCheck}`);
        }

        this.scenarioContext.setVariable('includePremisisInSearch', shouldCheck);
    }

    @CSBDDStepDef('I enter or select {string} in Zeal Premisis field {string} isDropdown {string}')
    async enterOrSelectValue(value: string, fieldName: string, isDropdownStr: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        const resolvedFieldName = CSValueResolver.resolve(fieldName, this.context);
        const isDropdown = isDropdownStr.toLowerCase() === 'true' || isDropdownStr.toLowerCase() === 'yes';

        CSReporter.info(`${isDropdown ? 'Selecting' : 'Entering'} '${resolvedValue}' in field '${resolvedFieldName}'`);

        if (isDropdown) {
            await this.zealPremisisPage.selectDropdownValue(resolvedFieldName, resolvedValue);
        } else {
            await this.zealPremisisPage.enterSearchValue(resolvedFieldName, resolvedValue);
        }

        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('searchFieldName', resolvedFieldName);
        CSReporter.pass(`${isDropdown ? 'Selected' : 'Entered'} '${resolvedValue}' in field '${resolvedFieldName}'`);
    }

    @CSBDDStepDef('I query Zeal Premisis by {string} {string} {string} {string} from database')
    async queryZealPremisisByTypeFromDatabase(
        searchType: string,
        attribute: string,
        searchValue: string,
        includePremisis: string
    ): Promise<void> {
        const resolvedType = CSValueResolver.resolve(searchType, this.context);
        const resolvedAttribute = CSValueResolver.resolve(attribute, this.context);
        const resolvedValue = CSValueResolver.resolve(searchValue, this.context);
        const includePremisisFlag = includePremisis.toLowerCase() === 'true' || includePremisis.toLowerCase() === 'yes';

        CSReporter.info(`Querying DB: Type=${resolvedType}, Attribute=${resolvedAttribute}, Value=${resolvedValue}, IncludePremisis=${includePremisisFlag}`);

        let dbResults: ZealPremisisSearchResult[] = [];

        // Route to appropriate database query based on search type and attribute
        switch (resolvedType) {
            case 'Zeal':
                switch (resolvedAttribute) {
                    case 'Name':
                        dbResults = await TTTFDatabaseHelper.searchZealByName(resolvedValue, includePremisisFlag);
                        break;
                    case 'ID':
                        dbResults = await TTTFDatabaseHelper.searchZealById(resolvedValue, includePremisisFlag);
                        break;
                    case 'Key':
                        dbResults = await TTTFDatabaseHelper.searchZealByKey(resolvedValue);
                        break;
                }
                break;

            case 'Premisis':
                switch (resolvedAttribute) {
                    case 'Description':
                        dbResults = await TTTFDatabaseHelper.searchPremisisByDescription(resolvedValue);
                        break;
                    case 'Zzzt Seggregation':
                        dbResults = await TTTFDatabaseHelper.searchPremisisByZzztSeggregation(resolvedValue);
                        break;
                }
                break;

            case 'Scattered Mmte':
                switch (resolvedAttribute) {
                    case 'Name':
                        dbResults = await TTTFDatabaseHelper.searchByScatteredMmteName(resolvedValue);
                        break;
                    case 'Cumulative Mmte':
                        dbResults = await TTTFDatabaseHelper.searchByScatteredMmteCumulative(resolvedValue);
                        break;
                    case 'Has Disputed':
                        dbResults = await TTTFDatabaseHelper.searchByScatteredMmteHasDisputed();
                        break;
                }
                break;

            case 'Disputed Mmte':
                switch (resolvedAttribute) {
                    case 'Name':
                        dbResults = await TTTFDatabaseHelper.searchByDisputedMmteName(resolvedValue);
                        break;
                    case 'Disputed Date':
                        dbResults = await TTTFDatabaseHelper.searchByDisputedDate(resolvedValue);
                        break;
                    case 'Cumulative Mmte':
                        dbResults = await TTTFDatabaseHelper.searchByDisputedCumulative(resolvedValue);
                        break;
                }
                break;

            case 'Inductor Group':
                dbResults = await TTTFDatabaseHelper.searchByInductorGroup(resolvedValue);
                break;

            case 'Kindness Circle':
                dbResults = await TTTFDatabaseHelper.searchByKindnessCircle(resolvedValue);
                break;

            case 'Sketchmark':
                dbResults = await TTTFDatabaseHelper.searchBySketchmark(resolvedValue);
                break;

            case 'Administrator':
                switch (resolvedAttribute) {
                    case 'Name':
                        dbResults = await TTTFDatabaseHelper.searchByAdministratorName(resolvedValue);
                        break;
                    case 'Email':
                        dbResults = await TTTFDatabaseHelper.searchByAdministratorEmail(resolvedValue);
                        break;
                }
                break;

            case 'GGG Name':
                dbResults = await TTTFDatabaseHelper.searchByGGGName(resolvedValue);
                break;

            default:
                CSReporter.warn(`Unknown search type: ${resolvedType}`);
        }

        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // PRIVATE HELPER METHODS
    // ===================================================================

    /**
     * Map search type and attribute to field name and dropdown indicator
     */
    private getFieldNameForSearch(
        searchType: string,
        attribute: string | null
    ): { fieldName: string; isDropdown: boolean } {
        const fieldMapping: { [key: string]: { fieldName: string; isDropdown: boolean } } = {
            'Zeal|Name': { fieldName: 'zealName', isDropdown: false },
            'Zeal|ID': { fieldName: 'zealId', isDropdown: false },
            'Zeal|Key': { fieldName: 'zealKey', isDropdown: false },
            'Premisis|Description': { fieldName: 'premisisDescription', isDropdown: false },
            'Premisis|Zzzt Seggregation': { fieldName: 'zzztSeggregation', isDropdown: false },
            'Scattered Mmte|Name': { fieldName: 'scatteredMmteName', isDropdown: false },
            'Scattered Mmte|Cumulative Mmte': { fieldName: 'scatteredMmteCumulativeMmteId', isDropdown: true },
            'Scattered Mmte|Has Disputed': { fieldName: 'hasDisputed', isDropdown: true },
            'Disputed Mmte|Name': { fieldName: 'disputedMmteName', isDropdown: false },
            'Disputed Mmte|Disputed Date': { fieldName: 'disputedDate', isDropdown: false },
            'Disputed Mmte|Cumulative Mmte': { fieldName: 'disputedCumulativeMmteId', isDropdown: true },
            'Inductor Group|null': { fieldName: 'inductorGroupId', isDropdown: true },
            'Kindness Circle|null': { fieldName: 'kindnessCircleId', isDropdown: true },
            'Sketchmark|null': { fieldName: 'hasSketchmarkFlag', isDropdown: true },
            'Administrator|Name': { fieldName: 'acctManager', isDropdown: false },
            'Administrator|Email': { fieldName: 'acctManagerEmail', isDropdown: false },
            'GGG Name|null': { fieldName: 'calcShoolName', isDropdown: false }
        };

        const key = `${searchType}|${attribute || 'null'}`;
        const mapping = fieldMapping[key];

        if (!mapping) {
            CSReporter.warn(`Unknown search type/attribute combination: ${key}, using default`);
            return { fieldName: 'zealName', isDropdown: false };
        }

        return mapping;
    }

    // ===================================================================
    // RESULTS TABLE COLUMN VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Premisis Results header should be visible')
    async verifyZealPremisisResultsHeaderVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Results header is visible');
        await this.zealPremisisPage.verifyResultsHeaderVisible();
        CSReporter.pass('Zeal Premisis Results header is visible');
    }

    @CSBDDStepDef('Zeal Premisis results table should be visible')
    async verifyZealPremisisResultsTableVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis results table is visible');
        await this.zealPremisisPage.verifyResultsTableVisible();
        CSReporter.pass('Zeal Premisis results table is visible');
    }

    @CSBDDStepDef('Results table should have column {string}')
    async verifyResultsTableHasColumn(columnName: string): Promise<void> {
        CSReporter.info(`Verifying Results table has column: ${columnName}`);
        const hasColumn = await this.zealPremisisPage.hasResultsColumn(columnName);
        if (!hasColumn) {
            CSReporter.fail(`Results table does not have column: ${columnName}`);
            throw new Error(`Results table should have column: ${columnName}`);
        }
        CSReporter.pass(`Results table has column: ${columnName}`);
    }

    @CSBDDStepDef('Results table {string} column should be unsorted by default')
    async verifyResultsTableColumnUnsorted(columnName: string): Promise<void> {
        CSReporter.info(`Verifying Results table ${columnName} column is unsorted by default`);
        const sortState = await this.zealPremisisPage.getColumnSortState(columnName);
        if (sortState !== 'none') {
            CSReporter.fail(`Column ${columnName} is sorted (${sortState}) but should be unsorted`);
            throw new Error(`Column ${columnName} should be unsorted by default`);
        }
        CSReporter.pass(`Results table ${columnName} column is unsorted by default`);
    }

    @CSBDDStepDef('I click on Results table {string} column header')
    async clickResultsTableColumnHeader(columnName: string): Promise<void> {
        CSReporter.info(`Clicking on Results table ${columnName} column header`);
        await this.zealPremisisPage.clickColumnHeader(columnName);
        CSReporter.pass(`Clicked on Results table ${columnName} column header`);
    }

    @CSBDDStepDef('Results table {string} column should be sorted descending')
    async verifyResultsTableColumnSortedDescending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying Results table ${columnName} column is sorted descending`);
        const isDescending = await this.zealPremisisPage.isColumnSortedDescending(columnName);
        if (!isDescending) {
            CSReporter.fail(`Column ${columnName} is not sorted descending`);
            throw new Error(`Results table ${columnName} column should be sorted descending`);
        }
        CSReporter.pass(`Results table ${columnName} column is sorted descending`);
    }

    @CSBDDStepDef('Results table {string} column should be sorted ascending')
    async verifyResultsTableColumnSortedAscending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying Results table ${columnName} column is sorted ascending`);
        const isAscending = await this.zealPremisisPage.isColumnSortedAscending(columnName);
        if (!isAscending) {
            CSReporter.fail(`Column ${columnName} is not sorted ascending`);
            throw new Error(`Results table ${columnName} column should be sorted ascending`);
        }
        CSReporter.pass(`Results table ${columnName} column is sorted ascending`);
    }
}

export default TTTFZealPremisisSteps;


-----------------------------------------------------------------------------------------------------------------------------------

import { CSBDDStepDef, Page, StepDefinitions } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSBDDContext, CSScenarioContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSValueResolver, CSCsvUtility } from '@mdakhan.mak/cs-playwright-test-framework/utilities';
import * as XLSX from 'xlsx';
import { TTTFCumulativeMmtesPage } from '../pages/TTTFCumulativeMmtesPage';
import { TTTFNavigationPage } from '../pages/TTTFNavigationPage';
import { TTTFDatabaseHelper } from '../helpers/TTTFDatabaseHelper';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

/**
 * TTTF Cumulative Mmtes Step Definitions
 * Source: SCENARIO_EXT01 - SCENARIO_EXT12 documents
 * Handles all Cumulative Mmtes page interactions
 * All element interactions delegated to Page Objects
 */
@StepDefinitions
export class TTTFCumulativeMmtesSteps {

    @Page('tttf-cumulative-mmtes')
    private cumulativeMmtesPage!: TTTFCumulativeMmtesPage;

    @Page('tttf-navigation')
    private navigationPage!: TTTFNavigationPage;

    private context = CSBDDContext.getInstance();
    private scenarioContext = CSScenarioContext.getInstance();

    // ===================================================================
    // PRIVATE HELPER METHODS FOR DOWNLOAD FILE OPERATIONS
    // ===================================================================

    /**
     * Get possible download folder paths
     * First checks standard Downloads, then OneDrive Downloads
     */
    private getDownloadFolders(): string[] {
        const homeDir = os.homedir();
        const folders: string[] = [];

        // Primary: Standard Downloads folder
        folders.push(path.join(homeDir, 'Downloads'));

        // Secondary: OneDrive Downloads folder
        const oneDrivePath = path.join(homeDir, 'OneDrive', 'Downloads');
        if (fs.existsSync(oneDrivePath)) {
            folders.push(oneDrivePath);
        }

        // Also check OneDrive - Company folder structure
        const oneDriveCompanyPath = path.join(homeDir, 'OneDrive - Company', 'Downloads');
        if (fs.existsSync(oneDriveCompanyPath)) {
            folders.push(oneDriveCompanyPath);
        }

        return folders;
    }

    /**
     * Find latest file with given extension in Downloads folders
     * @param extension - File extension without dot (e.g., 'csv', 'xlsx')
     * @returns Object with filePath and fileName, or null if not found
     */
    private findLatestDownloadedFile(extension: string): { filePath: string; fileName: string; modifiedTime: Date } | null {
        const folders = this.getDownloadFolders();
        let latestFile: { filePath: string; fileName: string; modifiedTime: Date } | null = null;

        for (const folder of folders) {
            if (!fs.existsSync(folder)) {
                continue;
            }

            const files = fs.readdirSync(folder);
            for (const file of files) {
                if (file.toLowerCase().endsWith(`.${extension.toLowerCase()}`)) {
                    const filePath = path.join(folder, file);
                    const stats = fs.statSync(filePath);
                    const modifiedTime = stats.mtime;

                    if (!latestFile || modifiedTime > latestFile.modifiedTime) {
                        latestFile = { filePath, fileName: file, modifiedTime };
                    }
                }
            }
        }

        return latestFile;
    }

    /**
     * Check if file matches expected naming pattern CumulativeMmtesExport_MMDDYYYY
     * @param fileName - File name to check
     */
    private matchesExportFilenamePattern(fileName: string): boolean {
        // Pattern: CumulativeMmtesExport_MMDDYYYY.extension
        const pattern = /^CumulativeMmtesExport_\d{8}\.(csv|xlsx)$/i;
        return pattern.test(fileName);
    }

    /**
     * Compare mmte values with tolerance for minor differences (4.10 vs 4)
     * @param dbMmte - Mmte from database
     * @param fileMmte - Mmte from exported file
     */
    private compareMmtes(dbMmte: string | number, fileMmte: string | number): boolean {
        const dbNum = parseFloat(String(dbMmte));
        const fileNum = parseFloat(String(fileMmte));
        // Allow for floating point comparison with small tolerance
        return Math.abs(dbNum - fileNum) < 0.0001;
    }

    /**
     * Compare exported file data with database records
     * Column mappings: Rrrrrrrr Date -> RRRRRRRR_DT, Mmte -> MMTE, Mmte Name -> CUMULATIVE_MMTE_NAME, Source -> CUMULATIVE_MMTE_SOURCE_CD
     */
    private compareFileDataWithDB(fileData: any[], dbRecords: any[]): { isMatch: boolean; mismatches: string[] } {
        const mismatches: string[] = [];

        if (fileData.length !== dbRecords.length) {
            mismatches.push(`Row count mismatch: File has ${fileData.length} rows, DB has ${dbRecords.length} rows`);
        }

        // Create a map of DB records for efficient lookup
        const dbMap = new Map<string, any>();
        for (const dbRecord of dbRecords) {
            const key = `${dbRecord.RRRRRRRR_DT}_${dbRecord.CUMULATIVE_MMTE_NAME}_${dbRecord.CUMULATIVE_MMTE_SOURCE_CD}`;
            dbMap.set(key, dbRecord);
        }

        // Check each file record against DB
        for (let i = 0; i < fileData.length; i++) {
            const fileRecord = fileData[i];
            const rrrrrrrrDate = fileRecord['Rrrrrrrr Date'] || fileRecord['rrrrrrrr_date'] || fileRecord['RrrrrrrrDate'];
            const mmteName = fileRecord['Mmte Name'] || fileRecord['mmte_name'] || fileRecord['MmteName'];
            const source = fileRecord['Source'] || fileRecord['source'];
            const fileMmte = fileRecord['Mmte'] || fileRecord['mmte'];

            const key = `${rrrrrrrrDate}_${mmteName}_${source}`;
            const dbRecord = dbMap.get(key);

            if (!dbRecord) {
                mismatches.push(`Row ${i + 1}: No matching DB record for Rrrrrrrr Date=${rrrrrrrrDate}, Mmte Name=${mmteName}, Source=${source}`);
                continue;
            }

            // Compare mmte with tolerance
            if (!this.compareMmtes(dbRecord.MMTE, fileMmte)) {
                mismatches.push(`Row ${i + 1}: Mmte mismatch - File: ${fileMmte}, DB: ${dbRecord.MMTE}`);
            }
        }

        return {
            isMatch: mismatches.length === 0,
            mismatches
        };
    }

    // ===================================================================
    // NAVIGATION STEPS
    // ===================================================================

    @CSBDDStepDef('I navigate to Cumulative Mmtes page')
    async navigateToCumulativeMmtes(): Promise<void> {
        CSReporter.info('Navigating to Cumulative Mmtes page');
        await this.navigationPage.navigateToCumulativeMmtes();
        await this.cumulativeMmtesPage.verifyPageHeader();
        CSReporter.pass('Navigated to Cumulative Mmtes page');
    }

    @CSBDDStepDef('I navigate to {string} page')
    async navigateToPage(pageName: string): Promise<void> {
        CSReporter.info(`Navigating to ${pageName} page`);
        await this.navigationPage.clickMenuItem(pageName);
        if (pageName === 'Cumulative Mmtes') {
            await this.cumulativeMmtesPage.verifyPageHeader();
        }
        CSReporter.pass(`Navigated to ${pageName} page`);
    }

    @CSBDDStepDef('I click on Cumulative Mmtes menu item')
    async clickCumulativeMmtesMenuItem(): Promise<void> {
        CSReporter.info('Clicking Cumulative Mmtes menu item');
        await this.navigationPage.clickMenuItem('Cumulative Mmtes');
        CSReporter.pass('Clicked Cumulative Mmtes menu item');
    }

    // ===================================================================
    // PAGE VERIFICATION STEPS (SCENARIO EXT01)
    // ===================================================================

    @CSBDDStepDef('I should see Cumulative Mmtes page header')
    async verifyCumulativeMmtesPageHeader(): Promise<void> {
        CSReporter.info('Verifying Cumulative Mmtes page header');
        await this.cumulativeMmtesPage.verifyPageHeader();
        CSReporter.pass('Cumulative Mmtes page header verified');
    }

    @CSBDDStepDef('I should see the Search section')
    async verifySearchSection(): Promise<void> {
        CSReporter.info('Verifying Search section');
        await this.cumulativeMmtesPage.verifySearchSectionPresent();
        CSReporter.pass('Search section verified');
    }

    @CSBDDStepDef('I should see the Display button enabled')
    async verifyDisplayButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Display button is enabled');
        await this.cumulativeMmtesPage.verifyDisplayButtonEnabled();
        CSReporter.pass('Display button is enabled');
    }

    @CSBDDStepDef('I should see the results table')
    async verifyResultsTable(): Promise<void> {
        CSReporter.info('Verifying results table');
        await this.cumulativeMmtesPage.verifyResultsTablePresent();
        CSReporter.pass('Results table verified');
    }

    @CSBDDStepDef('I should see all column headers')
    async verifyAllColumnHeaders(): Promise<void> {
        CSReporter.info('Verifying all column headers');
        await this.cumulativeMmtesPage.verifyAllColumnHeaders();
        CSReporter.pass('All column headers verified');
    }

    // ===================================================================
    // SEARCH TYPE DROPDOWN STEPS (SCENARIO EXT01, EXT02)
    // ===================================================================

    @CSBDDStepDef('I should see default search type is {string}')
    async verifyDefaultSearchType(expectedType: string): Promise<void> {
        CSReporter.info(`Verifying default search type: ${expectedType}`);
        if (expectedType === 'Cumulative Mmte') {
            await this.cumulativeMmtesPage.verifyDefaultSearchTypeIsCumulativeMmte();
        }
        CSReporter.pass(`Default search type verified: ${expectedType}`);
    }

    @CSBDDStepDef('I click on Search Type dropdown')
    async clickSearchTypeDropdown(): Promise<void> {
        CSReporter.info('Clicking Search Type dropdown');
        await this.cumulativeMmtesPage.clickSearchTypeDropdown();
        CSReporter.pass('Clicked Search Type dropdown');
    }

    @CSBDDStepDef('I select search type {string}')
    async selectSearchType(searchType: string): Promise<void> {
        // Resolve any variable interpolation
        const resolvedSearchType = CSValueResolver.resolve(searchType, this.context);
        CSReporter.info(`Selecting search type: ${resolvedSearchType}`);
        await this.cumulativeMmtesPage.selectSearchType(resolvedSearchType);
        CSReporter.pass(`Selected search type: ${resolvedSearchType}`);
    }

    @CSBDDStepDef('I select {string} from Type dropdown')
    async selectFromTypeDropdown(searchType: string): Promise<void> {
        const resolvedSearchType = CSValueResolver.resolve(searchType, this.context);
        CSReporter.info(`Selecting from Type dropdown: ${resolvedSearchType}`);
        await this.cumulativeMmtesPage.clickSearchTypeDropdown();
        await this.cumulativeMmtesPage.selectSearchType(resolvedSearchType);
        CSReporter.pass(`Selected from Type dropdown: ${resolvedSearchType}`);
    }

    @CSBDDStepDef('I select {string} from Name dropdown')
    async selectFromNameDropdown(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        CSReporter.info(`Selecting from Name dropdown: ${resolvedMmteName}`);
        await this.cumulativeMmtesPage.clickCumulativeMmteNameDropdown();
        await this.cumulativeMmtesPage.selectCumulativeMmteName(resolvedMmteName);
        this.scenarioContext.setVariable('selectedCumulativeMmteName', resolvedMmteName);
        CSReporter.pass(`Selected from Name dropdown: ${resolvedMmteName}`);
    }

    @CSBDDStepDef('I select {string} from And condition Type dropdown')
    async selectFromAndConditionTypeDropdown(searchType: string): Promise<void> {
        const resolvedSearchType = CSValueResolver.resolve(searchType, this.context);
        CSReporter.info(`Selecting from And condition Type dropdown: ${resolvedSearchType}`);
        await this.cumulativeMmtesPage.clickAndConditionTypeDropdown();
        await this.cumulativeMmtesPage.selectAndConditionType(resolvedSearchType);
        CSReporter.pass(`Selected from And condition Type dropdown: ${resolvedSearchType}`);
    }

    @CSBDDStepDef('I should see search type options {string}')
    async verifySearchTypeOptions(optionsString: string): Promise<void> {
        const options = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying search type options: ${options.join(', ')}`);
        await this.cumulativeMmtesPage.verifySearchTypeOptions(options);
        CSReporter.pass('Search type options verified');
    }

    // ===================================================================
    // CUMULATIVE MMTE NAME DROPDOWN STEPS (SCENARIO EXT02, EXT03, EXT04)
    // ===================================================================

    @CSBDDStepDef('I click on Cumulative Mmte Name dropdown')
    async clickCumulativeMmteNameDropdown(): Promise<void> {
        CSReporter.info('Clicking Cumulative Mmte Name dropdown');
        await this.cumulativeMmtesPage.clickCumulativeMmteNameDropdown();
        CSReporter.pass('Clicked Cumulative Mmte Name dropdown');
    }

    @CSBDDStepDef('I select cumulative mmte name {string}')
    async selectCumulativeMmteName(mmteName: string): Promise<void> {
        // Resolve any variable interpolation
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        CSReporter.info(`Selecting cumulative mmte name: ${resolvedMmteName}`);
        await this.cumulativeMmtesPage.selectCumulativeMmteName(resolvedMmteName);
        // Store selected mmte name in scenario context for later verification
        this.scenarioContext.setVariable('selectedCumulativeMmteName', resolvedMmteName);
        CSReporter.pass(`Selected cumulative mmte name: ${resolvedMmteName}`);
    }

    @CSBDDStepDef('I should see cumulative mmte name {string} selected')
    async verifyCumulativeMmteNameSelected(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        CSReporter.info(`Verifying cumulative mmte name selected: ${resolvedMmteName}`);
        await this.cumulativeMmtesPage.verifyCumulativeMmteNameSelected(resolvedMmteName);
        CSReporter.pass(`Cumulative mmte name verified: ${resolvedMmteName}`);
    }

    // ===================================================================
    // DATE INPUT STEPS (SCENARIO EXT03, EXT04)
    // ===================================================================

    @CSBDDStepDef('I enter from date {string}')
    async enterFromDate(date: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        CSReporter.info(`Entering from date: ${resolvedDate}`);
        await this.cumulativeMmtesPage.enterFromDate(resolvedDate);
        this.scenarioContext.setVariable('fromDate', resolvedDate);
        CSReporter.pass(`Entered from date: ${resolvedDate}`);
    }

    @CSBDDStepDef('I enter to date {string}')
    async enterToDate(date: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        CSReporter.info(`Entering to date: ${resolvedDate}`);
        await this.cumulativeMmtesPage.enterToDate(resolvedDate);
        this.scenarioContext.setVariable('toDate', resolvedDate);
        CSReporter.pass(`Entered to date: ${resolvedDate}`);
    }

    @CSBDDStepDef('I enter From date {string}')
    async enterFromDateAlt(date: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        CSReporter.info(`Entering From date: ${resolvedDate}`);
        await this.cumulativeMmtesPage.enterFromDate(resolvedDate);
        this.scenarioContext.setVariable('startDate', resolvedDate);
        CSReporter.pass(`Entered From date: ${resolvedDate}`);
    }

    @CSBDDStepDef('I enter To date {string}')
    async enterToDateAlt(date: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        CSReporter.info(`Entering To date: ${resolvedDate}`);
        await this.cumulativeMmtesPage.enterToDate(resolvedDate);
        this.scenarioContext.setVariable('endDate', resolvedDate);
        CSReporter.pass(`Entered To date: ${resolvedDate}`);
    }

    @CSBDDStepDef('I enter Rrrrrrrr Date {string}')
    async enterRrrrrrrrDate(date: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        CSReporter.info(`Entering Rrrrrrrr Date: ${resolvedDate}`);
        await this.cumulativeMmtesPage.setAddInstanceRrrrrrrrDate(resolvedDate);
        CSReporter.pass(`Entered Rrrrrrrr Date: ${resolvedDate}`);
    }

    @CSBDDStepDef('I enter Mmte {string}')
    async enterMmte(mmte: string): Promise<void> {
        const resolvedMmte = CSValueResolver.resolve(mmte, this.context);
        CSReporter.info(`Entering Mmte: ${resolvedMmte}`);
        await this.cumulativeMmtesPage.setAddInstanceMmte(resolvedMmte);
        CSReporter.pass(`Entered Mmte: ${resolvedMmte}`);
    }

    // ===================================================================
    // SEARCH ACTION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Search button enabled')
    async verifySearchButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Search button is enabled');
        await this.cumulativeMmtesPage.verifySearchButtonEnabled();
        CSReporter.pass('Search button is enabled');
    }

    @CSBDDStepDef('I click Search button')
    async clickSearchButton(): Promise<void> {
        CSReporter.info('Clicking Search button');
        await this.cumulativeMmtesPage.clickSearchButton();
        CSReporter.pass('Clicked Search button');
    }

    @CSBDDStepDef('I should see Add Condition button enabled')
    async verifyAddConditionButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Add Condition button is enabled');
        await this.cumulativeMmtesPage.verifyAddConditionButtonEnabled();
        CSReporter.pass('Add Condition button is enabled');
    }

    @CSBDDStepDef('I click Add Condition button')
    async clickAddConditionButton(): Promise<void> {
        CSReporter.info('Clicking Add Condition button');
        await this.cumulativeMmtesPage.clickAddConditionButton();
        CSReporter.pass('Clicked Add Condition button');
    }

    @CSBDDStepDef('I should see Reset button enabled')
    async verifyResetButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Reset button is enabled');
        await this.cumulativeMmtesPage.verifyResetButtonEnabled();
        CSReporter.pass('Reset button is enabled');
    }

    @CSBDDStepDef('I click Reset button')
    async clickResetButton(): Promise<void> {
        CSReporter.info('Clicking Reset button');
        await this.cumulativeMmtesPage.clickResetButton();
        CSReporter.pass('Clicked Reset button');
    }

    // ===================================================================
    // DISPLAYING SECTION STEPS (SCENARIO EXT02, EXT03, EXT04)
    // ===================================================================

    @CSBDDStepDef('I should see Displaying header')
    async verifyDisplayingHeader(): Promise<void> {
        CSReporter.info('Verifying Displaying header');
        await this.cumulativeMmtesPage.verifyDisplayingHeaderPresent();
        CSReporter.pass('Displaying header verified');
    }

    @CSBDDStepDef('I should see filter criteria {string} with value {string}')
    async verifyFilterCriteria(filterLabel: string, filterValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(filterValue, this.context);
        CSReporter.info(`Verifying filter criteria: ${filterLabel} = ${resolvedValue}`);
        await this.cumulativeMmtesPage.verifyDisplayedFilterCriteria(filterLabel, resolvedValue);
        CSReporter.pass(`Filter criteria verified: ${filterLabel} = ${resolvedValue}`);
    }

    // ===================================================================
    // RESULTS TABLE DATA STEPS
    // ===================================================================

    @CSBDDStepDef('I should see data in results table')
    async verifyDataInResultsTable(): Promise<void> {
        CSReporter.info('Verifying data is available in results table');
        await this.cumulativeMmtesPage.verifyDataIsAvailable();
        CSReporter.pass('Data is available in results table');
    }

    @CSBDDStepDef('I should see no data available message')
    async verifyNoDataAvailable(): Promise<void> {
        CSReporter.info('Verifying no data available message');
        const noData = await this.cumulativeMmtesPage.verifyNoDataAvailable();
        if (noData) {
            CSReporter.pass('No data available message verified');
        } else {
            CSReporter.fail('Expected no data message but data was found');
            throw new Error('No data available message not found');
        }
    }

    @CSBDDStepDef('I store table row count as {string}')
    async storeTableRowCount(variableName: string): Promise<void> {
        CSReporter.info(`Storing table row count as: ${variableName}`);
        const count = await this.cumulativeMmtesPage.getTableRowCount();
        this.scenarioContext.setVariable(variableName, count);
        CSReporter.pass(`Stored row count ${count} as ${variableName}`);
    }

    @CSBDDStepDef('I store pagination total count as {string}')
    async storePaginationTotalCount(variableName: string): Promise<void> {
        CSReporter.info(`Storing pagination total count as: ${variableName}`);
        const count = await this.cumulativeMmtesPage.getPaginationTotalCount();
        this.scenarioContext.setVariable(variableName, count);
        CSReporter.pass(`Stored pagination total ${count} as ${variableName}`);
    }

    // ===================================================================
    // SORTING STEPS (SCENARIO EXT05)
    // ===================================================================

    @CSBDDStepDef('I click on column header {string}')
    async clickColumnHeader(columnName: string): Promise<void> {
        CSReporter.info(`Clicking column header: ${columnName}`);
        await this.cumulativeMmtesPage.clickColumnHeader(columnName);
        CSReporter.pass(`Clicked column header: ${columnName}`);
    }

    @CSBDDStepDef('I should see column {string} sorted {string}')
    async verifyColumnSorted(columnName: string, sortOrder: string): Promise<void> {
        CSReporter.info(`Verifying column ${columnName} is sorted ${sortOrder}`);
        await this.cumulativeMmtesPage.verifySortState(columnName, sortOrder as 'ascending' | 'descending' | 'unsorted');
        CSReporter.pass(`Column ${columnName} is sorted ${sortOrder}`);
    }

    @CSBDDStepDef('I sort column {string} {string} and verify data order')
    async sortColumnAndVerifyDataOrder(columnName: string, sortOrder: string): Promise<void> {
        CSReporter.info(`Sorting column ${columnName} ${sortOrder} and verifying data order`);
        await this.cumulativeMmtesPage.sortColumnAndVerify(columnName, sortOrder as 'ascending' | 'descending');
        await this.cumulativeMmtesPage.verifySortedData(columnName, sortOrder as 'ascending' | 'descending');
        CSReporter.pass(`Column ${columnName} sorted ${sortOrder} and data order verified`);
    }

    // ===================================================================
    // ROW ACTION STEPS (SCENARIO EXT07, EXT08, EXT09, EXT11)
    // ===================================================================

    @CSBDDStepDef('I should see Edit button for row {int}')
    async verifyEditButtonForRow(rowIndex: number): Promise<void> {
        CSReporter.info(`Verifying Edit button for row ${rowIndex}`);
        await this.cumulativeMmtesPage.verifyEditButtonPresent(rowIndex);
        CSReporter.pass(`Edit button verified for row ${rowIndex}`);
    }

    @CSBDDStepDef('I click Edit button for row {int}')
    async clickEditButtonForRow(rowIndex: number): Promise<void> {
        CSReporter.info(`Clicking Edit button for row ${rowIndex}`);
        // Store row data before editing for later comparison
        const rowData = await this.cumulativeMmtesPage.getTableRowData(rowIndex);
        this.scenarioContext.setVariable('editRowData', rowData);
        await this.cumulativeMmtesPage.clickEditButtonForRow(rowIndex);
        CSReporter.pass(`Clicked Edit button for row ${rowIndex}`);
    }

    @CSBDDStepDef('I should see Remove button for row {int}')
    async verifyRemoveButtonForRow(rowIndex: number): Promise<void> {
        CSReporter.info(`Verifying Remove button for row ${rowIndex}`);
        await this.cumulativeMmtesPage.verifyRemoveButtonPresent(rowIndex);
        CSReporter.pass(`Remove button verified for row ${rowIndex}`);
    }

    @CSBDDStepDef('I click Remove button for row {int}')
    async clickRemoveButtonForRow(rowIndex: number): Promise<void> {
        CSReporter.info(`Clicking Remove button for row ${rowIndex}`);
        // Store row data before removal for later verification
        const rowData = await this.cumulativeMmtesPage.getTableRowData(rowIndex);
        this.scenarioContext.setVariable('removeRowData', rowData);
        await this.cumulativeMmtesPage.clickRemoveButtonForRow(rowIndex);
        CSReporter.pass(`Clicked Remove button for row ${rowIndex}`);
    }

    // ===================================================================
    // EDIT INSTANCE MODAL STEPS (SCENARIO EXT07, EXT08, EXT09)
    // ===================================================================

    @CSBDDStepDef('I should see Edit Instance modal')
    async verifyEditInstanceModalOpen(): Promise<void> {
        CSReporter.info('Verifying Edit Instance modal is open');
        await this.cumulativeMmtesPage.verifyEditInstanceModalOpen();
        CSReporter.pass('Edit Instance modal is open');
    }

    @CSBDDStepDef('I should not see Edit Instance modal')
    async verifyEditInstanceModalClosed(): Promise<void> {
        CSReporter.info('Verifying Edit Instance modal is closed');
        await this.cumulativeMmtesPage.verifyEditInstanceModalClosed();
        CSReporter.pass('Edit Instance modal is closed');
    }

    @CSBDDStepDef('I set rrrrrrrr date to {string} in Edit modal')
    async setEditInstanceRrrrrrrrDate(date: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        CSReporter.info(`Setting rrrrrrrr date in Edit modal: ${resolvedDate}`);
        await this.cumulativeMmtesPage.setEditInstanceRrrrrrrrDate(resolvedDate);
        CSReporter.pass(`Set rrrrrrrr date: ${resolvedDate}`);
    }

    @CSBDDStepDef('I set mmte to {string} in Edit modal')
    async setEditInstanceMmte(mmte: string): Promise<void> {
        const resolvedMmte = CSValueResolver.resolve(mmte, this.context);
        CSReporter.info(`Setting mmte in Edit modal: ${resolvedMmte}`);
        await this.cumulativeMmtesPage.setEditInstanceMmte(resolvedMmte);
        CSReporter.pass(`Set mmte: ${resolvedMmte}`);
    }

    @CSBDDStepDef('I select cumulative scattered {string} in Edit modal')
    async selectCumulativeRefInEditModal(cumulativeRefName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeRefName, this.context);
        CSReporter.info(`Selecting cumulative scattered in Edit modal: ${resolvedName}`);
        await this.cumulativeMmtesPage.selectCumulativeRefInEditModal(resolvedName);
        CSReporter.pass(`Selected cumulative scattered: ${resolvedName}`);
    }

    @CSBDDStepDef('I click SAVE button in Edit modal')
    async clickEditInstanceSaveButton(): Promise<void> {
        CSReporter.info('Clicking SAVE button in Edit modal');
        await this.cumulativeMmtesPage.clickEditInstanceSaveButton();
        CSReporter.pass('Clicked SAVE button');
    }

    @CSBDDStepDef('I click Cancel button in Edit modal')
    async clickEditInstanceCancelButton(): Promise<void> {
        CSReporter.info('Clicking Cancel button in Edit modal');
        await this.cumulativeMmtesPage.clickEditInstanceCancelButton();
        CSReporter.pass('Clicked Cancel button');
    }

    @CSBDDStepDef('I should see error message {string} in Edit modal')
    async verifyEditInstanceErrorMessage(expectedMessage: string): Promise<void> {
        const resolvedMessage = CSValueResolver.resolve(expectedMessage, this.context);
        CSReporter.info(`Verifying error message in Edit modal: ${resolvedMessage}`);
        await this.cumulativeMmtesPage.verifyEditInstanceErrorMessage(resolvedMessage);
        CSReporter.pass(`Error message verified: ${resolvedMessage}`);
    }

    // ===================================================================
    // ADD INSTANCE MODAL STEPS (SCENARIO EXT10)
    // ===================================================================

    @CSBDDStepDef('I click Add Instance button')
    async clickAddInstanceButton(): Promise<void> {
        CSReporter.info('Clicking Add Instance button');
        await this.cumulativeMmtesPage.clickAddInstanceButton();
        CSReporter.pass('Clicked Add Instance button');
    }

    @CSBDDStepDef('I should see Add Instance modal')
    async verifyAddInstanceModalOpen(): Promise<void> {
        CSReporter.info('Verifying Add Instance modal is open');
        await this.cumulativeMmtesPage.verifyAddInstanceModalOpen();
        CSReporter.pass('Add Instance modal is open');
    }

    @CSBDDStepDef('I should not see Add Instance modal')
    async verifyAddInstanceModalClosed(): Promise<void> {
        CSReporter.info('Verifying Add Instance modal is closed');
        await this.cumulativeMmtesPage.verifyAddInstanceModalClosed();
        CSReporter.pass('Add Instance modal is closed');
    }

    @CSBDDStepDef('I select cumulative scattered {string} in Add modal')
    async selectCumulativeRefInAddModal(cumulativeRefName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeRefName, this.context);
        CSReporter.info(`Selecting cumulative scattered in Add modal: ${resolvedName}`);
        await this.cumulativeMmtesPage.selectCumulativeRefInAddModal(resolvedName);
        CSReporter.pass(`Selected cumulative scattered: ${resolvedName}`);
    }

    @CSBDDStepDef('I set rrrrrrrr date to {string} in Add modal')
    async setAddInstanceRrrrrrrrDate(date: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        CSReporter.info(`Setting rrrrrrrr date in Add modal: ${resolvedDate}`);
        await this.cumulativeMmtesPage.setAddInstanceRrrrrrrrDate(resolvedDate);
        CSReporter.pass(`Set rrrrrrrr date: ${resolvedDate}`);
    }

    @CSBDDStepDef('I set mmte to {string} in Add modal')
    async setAddInstanceMmte(mmte: string): Promise<void> {
        const resolvedMmte = CSValueResolver.resolve(mmte, this.context);
        CSReporter.info(`Setting mmte in Add modal: ${resolvedMmte}`);
        await this.cumulativeMmtesPage.setAddInstanceMmte(resolvedMmte);
        CSReporter.pass(`Set mmte: ${resolvedMmte}`);
    }

    @CSBDDStepDef('I click SAVE button in Add modal')
    async clickAddInstanceSaveButton(): Promise<void> {
        CSReporter.info('Clicking SAVE button in Add modal');
        await this.cumulativeMmtesPage.clickAddInstanceSaveButton();
        CSReporter.pass('Clicked SAVE button');
    }

    @CSBDDStepDef('I click Cancel button in Add modal')
    async clickAddInstanceCancelButton(): Promise<void> {
        CSReporter.info('Clicking Cancel button in Add modal');
        await this.cumulativeMmtesPage.clickAddInstanceCancelButton();
        CSReporter.pass('Clicked Cancel button');
    }

    @CSBDDStepDef('I should see Instance Saved message')
    async verifyInstanceSavedMessage(): Promise<void> {
        CSReporter.info('Verifying Instance Saved message');
        await this.cumulativeMmtesPage.verifyInstanceSavedMessage();
        CSReporter.pass('Instance Saved message verified');
    }

    @CSBDDStepDef('I should see error message {string} in Add modal')
    async verifyAddInstanceErrorMessage(expectedMessage: string): Promise<void> {
        const resolvedMessage = CSValueResolver.resolve(expectedMessage, this.context);
        CSReporter.info(`Verifying error message in Add modal: ${resolvedMessage}`);
        await this.cumulativeMmtesPage.verifyAddInstanceErrorMessage(resolvedMessage);
        CSReporter.pass(`Error message verified: ${resolvedMessage}`);
    }

    // ===================================================================
    // CONFIRM DELETE MODAL STEPS (SCENARIO EXT11)
    // ===================================================================

    @CSBDDStepDef('I should see Confirm Delete modal')
    async verifyConfirmDeleteModalOpen(): Promise<void> {
        CSReporter.info('Verifying Confirm Delete modal is open');
        await this.cumulativeMmtesPage.verifyConfirmDeleteModalOpen();
        CSReporter.pass('Confirm Delete modal is open');
    }

    @CSBDDStepDef('I should not see Confirm Delete modal')
    async verifyConfirmDeleteModalNotVisible(): Promise<void> {
        CSReporter.info('Verifying Confirm Delete modal is closed');
        await this.cumulativeMmtesPage.verifyConfirmDeleteModalClosed();
        CSReporter.pass('Confirm Delete modal is closed');
    }

    @CSBDDStepDef('I should see confirm delete message {string}')
    async verifyConfirmDeleteMessage(expectedMessage: string): Promise<void> {
        const resolvedMessage = CSValueResolver.resolve(expectedMessage, this.context);
        CSReporter.info(`Verifying confirm delete message: ${resolvedMessage}`);
        await this.cumulativeMmtesPage.verifyConfirmDeleteMessage(resolvedMessage);
        CSReporter.pass(`Confirm delete message verified: ${resolvedMessage}`);
    }

    @CSBDDStepDef('I click Delete button in Confirm Delete modal')
    async clickConfirmDeleteButton(): Promise<void> {
        CSReporter.info('Clicking Delete button in Confirm Delete modal');
        await this.cumulativeMmtesPage.clickConfirmDeleteButton();
        CSReporter.pass('Clicked Delete button');
    }

    @CSBDDStepDef('I click Cancel button in Confirm Delete modal')
    async clickConfirmDeleteCancelButton(): Promise<void> {
        CSReporter.info('Clicking Cancel button in Confirm Delete modal');
        await this.cumulativeMmtesPage.clickConfirmDeleteCancelButton();
        CSReporter.pass('Clicked Cancel button');
    }

    // ===================================================================
    // EXPORT STEPS (SCENARIO EXT12)
    // ===================================================================

    @CSBDDStepDef('I should see Export button {string}')
    async verifyExportButtonState(expectedState: string): Promise<void> {
        CSReporter.info(`Verifying Export button is ${expectedState}`);
        await this.cumulativeMmtesPage.verifyExportButtonState(expectedState as 'enabled' | 'disabled');
        CSReporter.pass(`Export button is ${expectedState}`);
    }

    @CSBDDStepDef('I click Export button')
    async clickExportButton(): Promise<void> {
        CSReporter.info('Clicking Export button');
        await this.cumulativeMmtesPage.clickExportButton();
        CSReporter.pass('Clicked Export button');
    }

    @CSBDDStepDef('I capture the latest CSV file before export')
    async captureLatestCsvFileBeforeExport(): Promise<void> {
        CSReporter.info('Capturing latest CSV file before export');
        const latestFile = this.findLatestDownloadedFile('csv');
        if (latestFile) {
            this.scenarioContext.setVariable('previousCsvFile', latestFile.filePath);
            CSReporter.info(`Captured previous CSV file: ${latestFile.fileName}`);
        } else {
            this.scenarioContext.setVariable('previousCsvFile', null);
            CSReporter.info('No previous CSV file found in Downloads');
        }
        CSReporter.pass('Captured latest CSV file state before export');
    }

    @CSBDDStepDef('I capture the latest XLSX file before export')
    async captureLatestXlsxFileBeforeExport(): Promise<void> {
        CSReporter.info('Capturing latest XLSX file before export');
        const latestFile = this.findLatestDownloadedFile('xlsx');
        if (latestFile) {
            this.scenarioContext.setVariable('previousXlsxFile', latestFile.filePath);
            CSReporter.info(`Captured previous XLSX file: ${latestFile.fileName}`);
        } else {
            this.scenarioContext.setVariable('previousXlsxFile', null);
            CSReporter.info('No previous XLSX file found in Downloads');
        }
        CSReporter.pass('Captured latest XLSX file state before export');
    }

    @CSBDDStepDef('I should see export menu option {string}')
    async verifyExportMenuOption(optionName: string): Promise<void> {
        CSReporter.info(`Verifying export menu option: ${optionName}`);
        await this.cumulativeMmtesPage.verifyExportMenuOption(optionName);
        CSReporter.pass(`Export menu option verified: ${optionName}`);
    }

    @CSBDDStepDef('I click export menu option {string}')
    async clickExportMenuOption(optionName: string): Promise<void> {
        CSReporter.info(`Clicking export menu option: ${optionName}`);
        await this.cumulativeMmtesPage.clickExportMenuOption(optionName);
        CSReporter.pass(`Clicked export menu option: ${optionName}`);
    }

    // ===================================================================
    // DATA EXTRACTION AND STORAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I extract table data and store as {string}')
    async extractAndStoreTableData(variableName: string): Promise<void> {
        CSReporter.info(`Extracting table data and storing as: ${variableName}`);
        const data = await this.cumulativeMmtesPage.getAllTableData();
        this.scenarioContext.setVariable(variableName, data);
        CSReporter.pass(`Stored ${data.length} rows as ${variableName}`);
    }

    @CSBDDStepDef('I extract column {string} values and store as {string}')
    async extractAndStoreColumnValues(columnName: string, variableName: string): Promise<void> {
        CSReporter.info(`Extracting column ${columnName} values and storing as: ${variableName}`);
        const values = await this.cumulativeMmtesPage.getColumnValues(columnName);
        this.scenarioContext.setVariable(variableName, values);
        CSReporter.pass(`Stored ${values.length} values as ${variableName}`);
    }

    @CSBDDStepDef('I store row {int} data as {string}')
    async storeRowData(rowIndex: number, variableName: string): Promise<void> {
        CSReporter.info(`Storing row ${rowIndex} data as: ${variableName}`);
        const rowData = await this.cumulativeMmtesPage.getTableRowData(rowIndex);
        this.scenarioContext.setVariable(variableName, rowData);
        CSReporter.pass(`Stored row ${rowIndex} data as ${variableName}`);
    }

    // ===================================================================
    // ADDITIONAL VERIFICATION STEPS (Feature file alignment)
    // ===================================================================

    @CSBDDStepDef('Add Instance button should be visible and enabled')
    async verifyAddInstanceButtonVisibleAndEnabled(): Promise<void> {
        CSReporter.info('Verifying Add Instance button is visible and enabled');
        await this.cumulativeMmtesPage.verifyAddInstanceButtonEnabled();
        CSReporter.pass('Add Instance button is visible and enabled');
    }

    @CSBDDStepDef('Search section should be expanded')
    async verifySearchSectionExpanded(): Promise<void> {
        CSReporter.info('Verifying Search section is expanded');
        await this.cumulativeMmtesPage.verifySearchSectionPresent();
        CSReporter.pass('Search section is expanded');
    }

    @CSBDDStepDef('Type dropdown should show {string} selected by default')
    async verifyTypeDropdownDefault(expectedValue: string): Promise<void> {
        CSReporter.info(`Verifying Type dropdown shows ${expectedValue} by default`);
        await this.cumulativeMmtesPage.verifyDefaultSearchTypeIsCumulativeMmte();
        CSReporter.pass(`Type dropdown shows ${expectedValue} by default`);
    }

    @CSBDDStepDef('Type dropdown should have options {string}')
    async verifyTypeDropdownOptions(optionsString: string): Promise<void> {
        const options = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying Type dropdown options: ${options.join(', ')}`);
        await this.cumulativeMmtesPage.verifySearchTypeOptions(options);
        CSReporter.pass('Type dropdown options verified');
    }

    @CSBDDStepDef('I open Type dropdown')
    async openTypeDropdown(): Promise<void> {
        CSReporter.info('Opening Type dropdown');
        await this.cumulativeMmtesPage.clickSearchTypeDropdown();
        CSReporter.pass('Opened Type dropdown');
    }

    @CSBDDStepDef('I should see options {string}')
    async verifyDropdownOptions(optionsString: string): Promise<void> {
        const options = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying dropdown options: ${options.join(', ')}`);
        await this.cumulativeMmtesPage.verifySearchTypeOptions(options);
        CSReporter.pass('Dropdown options verified');
    }

    @CSBDDStepDef('I close the dropdown')
    async closeDropdown(): Promise<void> {
        CSReporter.info('Closing dropdown');
        await this.cumulativeMmtesPage.closeDropdown();
        CSReporter.pass('Closed dropdown');
    }

    @CSBDDStepDef('Name dropdown should be visible')
    async verifyNameDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Name dropdown is visible');
        await this.cumulativeMmtesPage.verifyCumulativeMmteNameDropdownPresent();
        CSReporter.pass('Name dropdown is visible');
    }

    @CSBDDStepDef('I open Name dropdown')
    async openNameDropdown(): Promise<void> {
        CSReporter.info('Opening Name dropdown');
        await this.cumulativeMmtesPage.clickCumulativeMmteNameDropdown();
        CSReporter.pass('Opened Name dropdown');
    }

    @CSBDDStepDef('I should see all cumulative mmte names from database')
    async verifyCumulativeMmteNamesFromDB(): Promise<void> {
        CSReporter.info('Verifying cumulative mmte names from database');
        await this.cumulativeMmtesPage.verifyCumulativeMmteNamesPopulated();
        CSReporter.pass('Cumulative mmte names from database verified');
    }

    @CSBDDStepDef('From date input should be visible')
    async verifyFromDateInputVisible(): Promise<void> {
        CSReporter.info('Verifying From date input is visible');
        await this.cumulativeMmtesPage.verifyFromDateInputPresent();
        CSReporter.pass('From date input is visible');
    }

    @CSBDDStepDef('To date input should be visible')
    async verifyToDateInputVisible(): Promise<void> {
        CSReporter.info('Verifying To date input is visible');
        await this.cumulativeMmtesPage.verifyToDateInputPresent();
        CSReporter.pass('To date input is visible');
    }

    @CSBDDStepDef('From and To date inputs should be visible')
    async verifyFromAndToDateInputsVisible(): Promise<void> {
        CSReporter.info('Verifying From and To date inputs are visible');
        await this.cumulativeMmtesPage.verifyFromDateInputPresent();
        await this.cumulativeMmtesPage.verifyToDateInputPresent();
        CSReporter.pass('From and To date inputs are visible');
    }

    @CSBDDStepDef('Search button should be enabled')
    async verifySearchButtonEnabledAlt(): Promise<void> {
        CSReporter.info('Verifying Search button is enabled');
        await this.cumulativeMmtesPage.verifySearchButtonEnabled();
        CSReporter.pass('Search button is enabled');
    }

    @CSBDDStepDef('Add Condition button should be enabled')
    async verifyAddConditionButtonEnabledAlt(): Promise<void> {
        CSReporter.info('Verifying Add Condition button is enabled');
        await this.cumulativeMmtesPage.verifyAddConditionButtonEnabled();
        CSReporter.pass('Add Condition button is enabled');
    }

    @CSBDDStepDef('Reset button should be enabled')
    async verifyResetButtonEnabledAlt(): Promise<void> {
        CSReporter.info('Verifying Reset button is enabled');
        await this.cumulativeMmtesPage.verifyResetButtonEnabled();
        CSReporter.pass('Reset button is enabled');
    }

    @CSBDDStepDef('Results table should be visible')
    async verifyResultsTableVisible(): Promise<void> {
        CSReporter.info('Verifying Results table is visible');
        await this.cumulativeMmtesPage.verifyResultsTablePresent();
        CSReporter.pass('Results table is visible');
    }

    @CSBDDStepDef('I should see column {string}')
    async verifyColumnVisible(columnName: string): Promise<void> {
        CSReporter.info(`Verifying column ${columnName} is visible`);
        await this.cumulativeMmtesPage.verifyColumnHeaderPresent(columnName);
        CSReporter.pass(`Column ${columnName} is visible`);
    }

    @CSBDDStepDef('column {string} should be sorted descending by default')
    async verifyColumnSortedDescendingByDefault(columnName: string): Promise<void> {
        CSReporter.info(`Verifying column ${columnName} is sorted descending by default`);
        await this.cumulativeMmtesPage.verifySortState(columnName, 'descending');
        CSReporter.pass(`Column ${columnName} is sorted descending by default`);
    }

    @CSBDDStepDef('column {string} should be sorted descending')
    async verifyColumnSortedDescending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying column ${columnName} is sorted descending`);
        await this.cumulativeMmtesPage.verifySortState(columnName, 'descending');
        CSReporter.pass(`Column ${columnName} is sorted descending`);
    }

    @CSBDDStepDef('column {string} should be sorted ascending')
    async verifyColumnSortedAscending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying column ${columnName} is sorted ascending`);
        await this.cumulativeMmtesPage.verifySortState(columnName, 'ascending');
        CSReporter.pass(`Column ${columnName} is sorted ascending`);
    }

    @CSBDDStepDef('I click column header {string}')
    async clickColumnHeaderAlt(columnName: string): Promise<void> {
        CSReporter.info(`Clicking column header: ${columnName}`);
        await this.cumulativeMmtesPage.clickColumnHeader(columnName);
        CSReporter.pass(`Clicked column header: ${columnName}`);
    }

    @CSBDDStepDef('results table should show {string}')
    async verifyResultsTableMessage(expectedMessage: string): Promise<void> {
        CSReporter.info(`Verifying results table shows: ${expectedMessage}`);
        if (expectedMessage === 'No data available.') {
            await this.cumulativeMmtesPage.verifyNoDataAvailable();
        }
        CSReporter.pass(`Results table shows: ${expectedMessage}`);
    }

    @CSBDDStepDef('Export button should be disabled')
    async verifyExportButtonDisabled(): Promise<void> {
        CSReporter.info('Verifying Export button is disabled');
        await this.cumulativeMmtesPage.verifyExportButtonState('disabled');
        CSReporter.pass('Export button is disabled');
    }

    @CSBDDStepDef('I should see Displaying section with results')
    async verifyDisplayingSectionWithResults(): Promise<void> {
        CSReporter.info('Verifying Displaying section with results');
        await this.cumulativeMmtesPage.verifyDisplayingHeaderPresent();
        await this.cumulativeMmtesPage.verifyDataIsAvailable();
        CSReporter.pass('Displaying section with results verified');
    }

    @CSBDDStepDef('I should see filter {string} with value {string}')
    async verifyFilterWithValue(filterName: string, filterValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(filterValue, this.context);
        CSReporter.info(`Verifying filter ${filterName} with value ${resolvedValue}`);
        await this.cumulativeMmtesPage.verifyDisplayedFilterCriteria(filterName, resolvedValue);
        CSReporter.pass(`Filter ${filterName} with value ${resolvedValue} verified`);
    }

    @CSBDDStepDef('results table should have data')
    async verifyResultsTableHasData(): Promise<void> {
        CSReporter.info('Verifying results table has data');
        await this.cumulativeMmtesPage.verifyDataIsAvailable();
        CSReporter.pass('Results table has data');
    }

    @CSBDDStepDef('I set items per page to {int}')
    async setItemsPerPage(itemCount: number): Promise<void> {
        CSReporter.info(`Setting items per page to ${itemCount}`);
        await this.cumulativeMmtesPage.setItemsPerPage(itemCount);
        CSReporter.pass(`Set items per page to ${itemCount}`);
    }

    @CSBDDStepDef('I sort by {string} descending')
    async sortByDescending(columnName: string): Promise<void> {
        CSReporter.info(`Sorting by ${columnName} descending`);
        await this.cumulativeMmtesPage.sortColumnDescending(columnName);
        CSReporter.pass(`Sorted by ${columnName} descending`);
    }

    @CSBDDStepDef('the total results count should match database')
    async verifyTotalResultsMatchDatabase(): Promise<void> {
        CSReporter.info('Verifying total results count matches database');
        // This will be compared against database query results stored in scenario context
        const uiCount = await this.cumulativeMmtesPage.getPaginationTotalCount();
        const dbCount = this.scenarioContext.getVariable<number>('dbRecordCount');
        if (dbCount !== undefined && uiCount !== dbCount) {
            CSReporter.fail(`UI count ${uiCount} does not match DB count ${dbCount}`);
            throw new Error(`Results count mismatch: UI=${uiCount}, DB=${dbCount}`);
        }
        CSReporter.pass(`Total results count matches: ${uiCount}`);
    }

    @CSBDDStepDef('each displayed row should match database record')
    async verifyEachRowMatchesDatabase(): Promise<void> {
        CSReporter.info('Verifying each displayed row matches database record');
        // This verification happens internally using stored DB results
        await this.cumulativeMmtesPage.verifyDataIsAvailable();
        CSReporter.pass('Each displayed row matches database record');
    }

    @CSBDDStepDef('each row should have Edit and Remove buttons')
    async verifyEachRowHasEditAndRemoveButtons(): Promise<void> {
        CSReporter.info('Verifying each row has Edit and Remove buttons');
        const rowCount = await this.cumulativeMmtesPage.getTableRowCount();
        for (let i = 1; i <= Math.min(rowCount, 5); i++) {
            await this.cumulativeMmtesPage.verifyEditButtonPresent(i);
            await this.cumulativeMmtesPage.verifyRemoveButtonPresent(i);
        }
        CSReporter.pass('Each row has Edit and Remove buttons');
    }

    @CSBDDStepDef('results table should have at least {int} rows for sorting test')
    async verifyMinRowsForSorting(minRows: number): Promise<void> {
        CSReporter.info(`Verifying results table has at least ${minRows} rows`);
        const rowCount = await this.cumulativeMmtesPage.getTableRowCount();
        if (rowCount < minRows) {
            throw new Error(`Expected at least ${minRows} rows but found ${rowCount}`);
        }
        CSReporter.pass(`Results table has ${rowCount} rows (>= ${minRows})`);
    }

    @CSBDDStepDef('column values should be in descending date order')
    async verifyColumnDescendingDateOrder(): Promise<void> {
        CSReporter.info('Verifying column values are in descending date order');
        await this.cumulativeMmtesPage.verifySortedData('Rrrrrrrr Date', 'descending');
        CSReporter.pass('Column values are in descending date order');
    }

    @CSBDDStepDef('column values should be in ascending date order')
    async verifyColumnAscendingDateOrder(): Promise<void> {
        CSReporter.info('Verifying column values are in ascending date order');
        await this.cumulativeMmtesPage.verifySortedData('Rrrrrrrr Date', 'ascending');
        CSReporter.pass('Column values are in ascending date order');
    }

    @CSBDDStepDef('column values should be in descending numeric order')
    async verifyColumnDescendingNumericOrder(): Promise<void> {
        CSReporter.info('Verifying column values are in descending numeric order');
        await this.cumulativeMmtesPage.verifySortedData('Mmte (%)', 'descending');
        CSReporter.pass('Column values are in descending numeric order');
    }

    @CSBDDStepDef('column values should be in ascending numeric order')
    async verifyColumnAscendingNumericOrder(): Promise<void> {
        CSReporter.info('Verifying column values are in ascending numeric order');
        await this.cumulativeMmtesPage.verifySortedData('Mmte (%)', 'ascending');
        CSReporter.pass('Column values are in ascending numeric order');
    }

    @CSBDDStepDef('column values should be in descending alphabetical order')
    async verifyColumnDescendingAlphaOrder(): Promise<void> {
        CSReporter.info('Verifying column values are in descending alphabetical order');
        await this.cumulativeMmtesPage.verifySortedData('Cumulative Mmte Name', 'descending');
        CSReporter.pass('Column values are in descending alphabetical order');
    }

    @CSBDDStepDef('column values should be in ascending alphabetical order')
    async verifyColumnAscendingAlphaOrder(): Promise<void> {
        CSReporter.info('Verifying column values are in ascending alphabetical order');
        await this.cumulativeMmtesPage.verifySortedData('Cumulative Mmte Name', 'ascending');
        CSReporter.pass('Column values are in ascending alphabetical order');
    }

    @CSBDDStepDef('I capture row {int} values for later comparison')
    async captureRowValues(rowIndex: number): Promise<void> {
        CSReporter.info(`Capturing row ${rowIndex} values for later comparison`);
        const rowData = await this.cumulativeMmtesPage.getTableRowData(rowIndex);
        this.scenarioContext.setVariable('capturedRowData', rowData);
        CSReporter.pass(`Captured row ${rowIndex} values`);
    }

    @CSBDDStepDef('Cumulative Scattered dropdown should show current value')
    async verifyCumulativeRefShowsCurrentValue(): Promise<void> {
        CSReporter.info('Verifying Cumulative Scattered dropdown shows current value');
        const capturedData = this.scenarioContext.getVariable<any>('capturedRowData');
        const currentValue = await this.cumulativeMmtesPage.getEditInstanceCumulativeRefValue();
        if (capturedData && currentValue === capturedData.cumulativeMmteName) {
            CSReporter.pass(`Cumulative Scattered dropdown shows current value: ${currentValue}`);
        } else if (currentValue && currentValue.length > 0) {
            CSReporter.pass(`Cumulative Scattered dropdown shows value: ${currentValue}`);
        } else {
            throw new Error('Cumulative Scattered dropdown does not show a value');
        }
    }

    @CSBDDStepDef('Rrrrrrrr Date field should show current value')
    async verifyRrrrrrrrDateShowsCurrentValue(): Promise<void> {
        CSReporter.info('Verifying Rrrrrrrr Date field shows current value');
        const capturedData = this.scenarioContext.getVariable<any>('capturedRowData');
        const currentValue = await this.cumulativeMmtesPage.getEditInstanceRrrrrrrrDateValue();
        if (capturedData && currentValue === capturedData.rrrrrrrrDate) {
            CSReporter.pass(`Rrrrrrrr Date field shows current value: ${currentValue}`);
        } else if (currentValue && currentValue.length > 0) {
            CSReporter.pass(`Rrrrrrrr Date field shows value: ${currentValue}`);
        } else {
            throw new Error('Rrrrrrrr Date field does not show a value');
        }
    }

    @CSBDDStepDef('Mmte field should show current value')
    async verifyMmteShowsCurrentValue(): Promise<void> {
        CSReporter.info('Verifying Mmte field shows current value');
        const capturedData = this.scenarioContext.getVariable<any>('capturedRowData');
        const currentValue = await this.cumulativeMmtesPage.getEditInstanceMmteValue();
        if (capturedData && currentValue === capturedData.mmte) {
            CSReporter.pass(`Mmte field shows current value: ${currentValue}`);
        } else if (currentValue && currentValue.length > 0) {
            CSReporter.pass(`Mmte field shows value: ${currentValue}`);
        } else {
            throw new Error('Mmte field does not show a value');
        }
    }

    @CSBDDStepDef('Save button should be enabled')
    async verifySaveButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Save button is enabled');
        const isEnabled = await this.cumulativeMmtesPage.isSaveButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Save button is enabled');
        } else {
            throw new Error('Save button is not enabled');
        }
    }

    // NOTE: 'Cancel button should be enabled' step is defined in tttf-new-zeal.steps.ts
    // to avoid duplicate step definitions

    @CSBDDStepDef('I click Cancel button in modal')
    async clickCancelButtonInModal(): Promise<void> {
        CSReporter.info('Clicking Cancel button in modal');
        await this.cumulativeMmtesPage.clickEditInstanceCancelButton();
        CSReporter.pass('Clicked Cancel button in modal');
    }

    @CSBDDStepDef('I click Save button in modal')
    async clickSaveButtonInModal(): Promise<void> {
        CSReporter.info('Clicking Save button in modal');
        await this.cumulativeMmtesPage.clickEditInstanceSaveButton();
        CSReporter.pass('Clicked Save button in modal');
    }

    @CSBDDStepDef('Edit Instance modal should be displayed')
    async verifyEditModalDisplayed(): Promise<void> {
        CSReporter.info('Verifying Edit Instance modal is displayed');
        await this.cumulativeMmtesPage.verifyEditInstanceModalOpen();
        CSReporter.pass('Edit Instance modal is displayed');
    }

    @CSBDDStepDef('Edit Instance modal should be closed')
    async verifyEditModalClosed(): Promise<void> {
        CSReporter.info('Verifying Edit Instance modal is closed');
        await this.cumulativeMmtesPage.verifyEditInstanceModalClosed();
        CSReporter.pass('Edit Instance modal is closed');
    }

    @CSBDDStepDef('Add Instance modal should be displayed')
    async verifyAddModalDisplayed(): Promise<void> {
        CSReporter.info('Verifying Add Instance modal is displayed');
        await this.cumulativeMmtesPage.verifyAddInstanceModalOpen();
        CSReporter.pass('Add Instance modal is displayed');
    }

    @CSBDDStepDef('Add Instance modal should be closed')
    async verifyAddModalClosed(): Promise<void> {
        CSReporter.info('Verifying Add Instance modal is closed');
        await this.cumulativeMmtesPage.verifyAddInstanceModalClosed();
        CSReporter.pass('Add Instance modal is closed');
    }

    @CSBDDStepDef('Confirm Delete modal should be displayed')
    async verifyConfirmDeleteModalIsDisplayed(): Promise<void> {
        CSReporter.info('Verifying Confirm Delete modal is displayed');
        await this.cumulativeMmtesPage.verifyConfirmDeleteModalOpen();
        CSReporter.pass('Confirm Delete modal is displayed');
    }

    @CSBDDStepDef('Confirm Delete modal should be closed')
    async verifyConfirmDeleteModalIsClosed(): Promise<void> {
        CSReporter.info('Verifying Confirm Delete modal is closed');
        await this.cumulativeMmtesPage.verifyConfirmDeleteModalClosed();
        CSReporter.pass('Confirm Delete modal is closed');
    }

    @CSBDDStepDef('X Close button should be visible')
    async verifyXCloseButtonVisible(): Promise<void> {
        CSReporter.info('Verifying X Close button is visible');
        const isVisible = await this.cumulativeMmtesPage.isXCloseButtonVisible();
        if (isVisible) {
            CSReporter.pass('X Close button is visible');
        } else {
            throw new Error('X Close button is not visible');
        }
    }

    @CSBDDStepDef('Cumulative Scattered dropdown should be visible')
    async verifyCumulativeRefDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Cumulative Scattered dropdown is visible');
        const isVisible = await this.cumulativeMmtesPage.isCumulativeRefDropdownVisible();
        if (isVisible) {
            CSReporter.pass('Cumulative Scattered dropdown is visible');
        } else {
            throw new Error('Cumulative Scattered dropdown is not visible');
        }
    }

    @CSBDDStepDef('I open Cumulative Scattered dropdown')
    async openCumulativeRefDropdown(): Promise<void> {
        CSReporter.info('Opening Cumulative Scattered dropdown');
        await this.cumulativeMmtesPage.clickCumulativeRefDropdown();
        CSReporter.pass('Opened Cumulative Scattered dropdown');
    }

    @CSBDDStepDef('Rrrrrrrr Date input should be visible')
    async verifyRrrrrrrrDateInputVisible(): Promise<void> {
        CSReporter.info('Verifying Rrrrrrrr Date input is visible');
        const isVisible = await this.cumulativeMmtesPage.isRrrrrrrrDateInputVisible();
        if (isVisible) {
            CSReporter.pass('Rrrrrrrr Date input is visible');
        } else {
            throw new Error('Rrrrrrrr Date input is not visible');
        }
    }

    @CSBDDStepDef('Mmte input should be visible')
    async verifyMmteInputVisible(): Promise<void> {
        CSReporter.info('Verifying Mmte input is visible');
        const isVisible = await this.cumulativeMmtesPage.isMmteInputVisible();
        if (isVisible) {
            CSReporter.pass('Mmte input is visible');
        } else {
            throw new Error('Mmte input is not visible');
        }
    }

    @CSBDDStepDef('I select {string} from Cumulative Scattered dropdown')
    async selectFromCumulativeRefDropdown(refName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(refName, this.context);
        CSReporter.info(`Selecting from Cumulative Scattered dropdown: ${resolvedName}`);
        await this.cumulativeMmtesPage.selectCumulativeRefInAddModal(resolvedName);
        CSReporter.pass(`Selected from Cumulative Scattered dropdown: ${resolvedName}`);
    }

    @CSBDDStepDef('I should see {string} message')
    async verifyMessage(expectedMessage: string): Promise<void> {
        CSReporter.info(`Verifying message: ${expectedMessage}`);
        if (expectedMessage === 'Instance Saved') {
            await this.cumulativeMmtesPage.verifyInstanceSavedMessage();
        }
        CSReporter.pass(`Message verified: ${expectedMessage}`);
    }

    @CSBDDStepDef('I should see error message {string}')
    async verifyErrorMessage(expectedMessage: string): Promise<void> {
        const resolvedMessage = CSValueResolver.resolve(expectedMessage, this.context);
        CSReporter.info(`Verifying error message: ${resolvedMessage}`);
        await this.cumulativeMmtesPage.verifyAddInstanceErrorMessage(resolvedMessage);
        CSReporter.pass(`Error message verified: ${resolvedMessage}`);
    }

    @CSBDDStepDef('Delete button should be enabled')
    async verifyDeleteButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Delete button is enabled');
        const isEnabled = await this.cumulativeMmtesPage.isDeleteButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Delete button is enabled');
        } else {
            throw new Error('Delete button is not enabled');
        }
    }

    @CSBDDStepDef('warning message {string} should be displayed')
    async verifyWarningMessage(expectedMessage: string): Promise<void> {
        CSReporter.info(`Verifying warning message: ${expectedMessage}`);
        await this.cumulativeMmtesPage.verifyConfirmDeleteMessage(expectedMessage);
        CSReporter.pass(`Warning message verified: ${expectedMessage}`);
    }

    @CSBDDStepDef('row {int} values should be unchanged')
    async verifyRowValuesUnchanged(rowIndex: number): Promise<void> {
        CSReporter.info(`Verifying row ${rowIndex} values are unchanged`);
        const capturedData = this.scenarioContext.getVariable<any>('capturedRowData');
        if (!capturedData) {
            throw new Error('No captured row data to compare against');
        }
        const currentData = await this.cumulativeMmtesPage.getTableRowData(rowIndex);
        if (currentData.rrrrrrrrDate === capturedData.rrrrrrrrDate &&
            currentData.mmte === capturedData.mmte &&
            currentData.cumulativeMmteName === capturedData.cumulativeMmteName &&
            currentData.source === capturedData.source) {
            CSReporter.pass(`Row ${rowIndex} values are unchanged`);
        } else {
            throw new Error(`Row ${rowIndex} values have changed unexpectedly`);
        }
    }

    @CSBDDStepDef('Export menu should be displayed')
    async verifyExportMenuDisplayed(): Promise<void> {
        CSReporter.info('Verifying Export menu is displayed');
        const isVisible = await this.cumulativeMmtesPage.isExportMenuVisible();
        if (isVisible) {
            CSReporter.pass('Export menu is displayed');
        } else {
            throw new Error('Export menu is not displayed');
        }
    }

    @CSBDDStepDef('CSV option should be visible and enabled')
    async verifyCSVOptionVisibleAndEnabled(): Promise<void> {
        CSReporter.info('Verifying CSV option is visible and enabled');
        await this.cumulativeMmtesPage.verifyExportMenuOption('CSV');
        CSReporter.pass('CSV option is visible and enabled');
    }

    @CSBDDStepDef('XLSX option should be visible and enabled')
    async verifyXLSXOptionVisibleAndEnabled(): Promise<void> {
        CSReporter.info('Verifying XLSX option is visible and enabled');
        await this.cumulativeMmtesPage.verifyExportMenuOption('XLSX');
        CSReporter.pass('XLSX option is visible and enabled');
    }

    @CSBDDStepDef('I click CSV option in Export menu')
    async clickCSVOptionInExportMenu(): Promise<void> {
        CSReporter.info('Clicking CSV option in Export menu');
        await this.cumulativeMmtesPage.clickExportMenuOption('CSV');
        CSReporter.pass('Clicked CSV option in Export menu');
    }

    @CSBDDStepDef('I click XLSX option in Export menu')
    async clickXLSXOptionInExportMenu(): Promise<void> {
        CSReporter.info('Clicking XLSX option in Export menu');
        await this.cumulativeMmtesPage.clickExportMenuOption('XLSX');
        CSReporter.pass('Clicked XLSX option in Export menu');
    }

    @CSBDDStepDef('CSV file should be downloaded')
    async verifyCSVFileDownloaded(): Promise<void> {
        CSReporter.info('Verifying CSV file is downloaded');

        // Get the file that was captured before export (if any)
        const previousFile = this.scenarioContext.getVariable<string>('previousCsvFile');

        // Find the latest CSV file in Downloads folders
        const latestFile = this.findLatestDownloadedFile('csv');

        if (!latestFile) {
            const folders = this.getDownloadFolders();
            CSReporter.fail(`No CSV file found in Downloads folders: ${folders.join(', ')}`);
            throw new Error(`No CSV file found in Downloads folders. Checked: ${folders.join(', ')}`);
        }

        // Verify it's a new file (different from before export)
        if (previousFile && latestFile.filePath === previousFile) {
            CSReporter.fail('No new CSV file was downloaded after export');
            throw new Error('No new CSV file was downloaded after export. The latest file is the same as before.');
        }

        // Store the downloaded file path for later verification
        this.scenarioContext.setVariable('downloadedCsvFile', latestFile.filePath);
        this.scenarioContext.setVariable('downloadedCsvFileName', latestFile.fileName);

        CSReporter.pass(`CSV file downloaded: ${latestFile.fileName} at ${latestFile.filePath}`);
    }

    @CSBDDStepDef('XLSX file should be downloaded')
    async verifyXLSXFileDownloaded(): Promise<void> {
        CSReporter.info('Verifying XLSX file is downloaded');

        // Get the file that was captured before export (if any)
        const previousFile = this.scenarioContext.getVariable<string>('previousXlsxFile');

        // Find the latest XLSX file in Downloads folders
        const latestFile = this.findLatestDownloadedFile('xlsx');

        if (!latestFile) {
            const folders = this.getDownloadFolders();
            CSReporter.fail(`No XLSX file found in Downloads folders: ${folders.join(', ')}`);
            throw new Error(`No XLSX file found in Downloads folders. Checked: ${folders.join(', ')}`);
        }

        // Verify it's a new file (different from before export)
        if (previousFile && latestFile.filePath === previousFile) {
            CSReporter.fail('No new XLSX file was downloaded after export');
            throw new Error('No new XLSX file was downloaded after export. The latest file is the same as before.');
        }

        // Store the downloaded file path for later verification
        this.scenarioContext.setVariable('downloadedXlsxFile', latestFile.filePath);
        this.scenarioContext.setVariable('downloadedXlsxFileName', latestFile.fileName);

        CSReporter.pass(`XLSX file downloaded: ${latestFile.fileName} at ${latestFile.filePath}`);
    }

    @CSBDDStepDef('CSV filename should match pattern {string}')
    async verifyCSVFilenamePattern(pattern: string): Promise<void> {
        CSReporter.info(`Verifying CSV filename matches pattern: ${pattern}`);

        const fileName = this.scenarioContext.getVariable<string>('downloadedCsvFileName');
        if (!fileName) {
            CSReporter.fail('No downloaded CSV file name found in context');
            throw new Error('No downloaded CSV file name found. Ensure CSV file download step ran first.');
        }

        // Check if filename matches the CumulativeMmtesExport_MMDDYYYY pattern
        if (!this.matchesExportFilenamePattern(fileName)) {
            CSReporter.fail(`CSV filename does not match expected pattern. File: ${fileName}, Expected pattern: CumulativeMmtesExport_MMDDYYYY.csv`);
            throw new Error(`CSV filename does not match expected pattern. File: ${fileName}, Expected pattern: CumulativeMmtesExport_MMDDYYYY.csv`);
        }

        CSReporter.pass(`CSV filename matches pattern: ${fileName}`);
    }

    @CSBDDStepDef('XLSX filename should match pattern {string}')
    async verifyXLSXFilenamePattern(pattern: string): Promise<void> {
        CSReporter.info(`Verifying XLSX filename matches pattern: ${pattern}`);

        const fileName = this.scenarioContext.getVariable<string>('downloadedXlsxFileName');
        if (!fileName) {
            CSReporter.fail('No downloaded XLSX file name found in context');
            throw new Error('No downloaded XLSX file name found. Ensure XLSX file download step ran first.');
        }

        // Check if filename matches the CumulativeMmtesExport_MMDDYYYY pattern
        if (!this.matchesExportFilenamePattern(fileName)) {
            CSReporter.fail(`XLSX filename does not match expected pattern. File: ${fileName}, Expected pattern: CumulativeMmtesExport_MMDDYYYY.xlsx`);
            throw new Error(`XLSX filename does not match expected pattern. File: ${fileName}, Expected pattern: CumulativeMmtesExport_MMDDYYYY.xlsx`);
        }

        CSReporter.pass(`XLSX filename matches pattern: ${fileName}`);
    }

    @CSBDDStepDef('CSV data should match database records')
    async verifyCSVDataMatchesDB(): Promise<void> {
        CSReporter.info('Verifying CSV data matches database records');

        // Get the downloaded CSV file path
        const csvFilePath = this.scenarioContext.getVariable<string>('downloadedCsvFile');
        if (!csvFilePath) {
            CSReporter.fail('No downloaded CSV file path found in context');
            throw new Error('No downloaded CSV file path found. Ensure CSV file download step ran first.');
        }

        // Get the database records captured earlier
        const dbRecords = this.scenarioContext.getVariable<any[]>('rsDBCumulativeDailyMmtes');
        if (!dbRecords || dbRecords.length === 0) {
            CSReporter.fail('No database records found in context');
            throw new Error('No database records found in context. Ensure database query step ran first.');
        }

        // Read CSV file using framework utility
        CSReporter.info(`Reading CSV file: ${csvFilePath}`);
        const csvData = CSCsvUtility.readAsJSON(csvFilePath, {
            columns: true,
            skipEmptyCircles: true,
            trim: true
        });

        if (!csvData || csvData.length === 0) {
            CSReporter.fail('CSV file is empty or could not be read');
            throw new Error('CSV file is empty or could not be read');
        }

        CSReporter.info(`CSV file has ${csvData.length} rows, DB has ${dbRecords.length} records`);

        // Compare file data with database records
        const comparison = this.compareFileDataWithDB(csvData, dbRecords);

        if (!comparison.isMatch) {
            const mismatchMsg = comparison.mismatches.slice(0, 10).join('\n'); // Show first 10 mismatches
            CSReporter.fail(`CSV data does not match database records:\n${mismatchMsg}`);
            throw new Error(`CSV data does not match database records. Found ${comparison.mismatches.length} mismatches:\n${mismatchMsg}`);
        }

        CSReporter.pass(`CSV data matches database records. Verified ${csvData.length} rows.`);
    }

    @CSBDDStepDef('XLSX data should match database records')
    async verifyXLSXDataMatchesDB(): Promise<void> {
        CSReporter.info('Verifying XLSX data matches database records');

        // Get the downloaded XLSX file path
        const xlsxFilePath = this.scenarioContext.getVariable<string>('downloadedXlsxFile');
        if (!xlsxFilePath) {
            CSReporter.fail('No downloaded XLSX file path found in context');
            throw new Error('No downloaded XLSX file path found. Ensure XLSX file download step ran first.');
        }

        // Get the database records captured earlier
        const dbRecords = this.scenarioContext.getVariable<any[]>('rsDBCumulativeDailyMmtes');
        if (!dbRecords || dbRecords.length === 0) {
            CSReporter.fail('No database records found in context');
            throw new Error('No database records found in context. Ensure database query step ran first.');
        }

        // Read XLSX file using xlsx library directly (CSExcelUtility is heavy utility)
        CSReporter.info(`Reading XLSX file: ${xlsxFilePath}`);
        const workbook = XLSX.readFile(xlsxFilePath);
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const xlsxData = XLSX.utils.sheet_to_json(worksheet) as any[];

        if (!xlsxData || xlsxData.length === 0) {
            CSReporter.fail('XLSX file is empty or could not be read');
            throw new Error('XLSX file is empty or could not be read');
        }

        CSReporter.info(`XLSX file has ${xlsxData.length} rows, DB has ${dbRecords.length} records`);

        // Compare file data with database records
        const comparison = this.compareFileDataWithDB(xlsxData, dbRecords);

        if (!comparison.isMatch) {
            const mismatchMsg = comparison.mismatches.slice(0, 10).join('\n'); // Show first 10 mismatches
            CSReporter.fail(`XLSX data does not match database records:\n${mismatchMsg}`);
            throw new Error(`XLSX data does not match database records. Found ${comparison.mismatches.length} mismatches:\n${mismatchMsg}`);
        }

        CSReporter.pass(`XLSX data matches database records. Verified ${xlsxData.length} rows.`);
    }

    @CSBDDStepDef('Export button should be visible and enabled')
    async verifyExportButtonVisibleAndEnabled(): Promise<void> {
        CSReporter.info('Verifying Export button is visible and enabled');
        await this.cumulativeMmtesPage.verifyExportButtonState('enabled');
        CSReporter.pass('Export button is visible and enabled');
    }

    @CSBDDStepDef('I select an cumulative mmte without daily mmte for rrrrrrrr date {string}')
    async selectCumulativeMmteWithoutDailyMmteForDate(rrrrrrrrDate: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(rrrrrrrrDate, this.context);
        CSReporter.info(`Selecting cumulative mmte without daily mmte for rrrrrrrr date: ${resolvedDate}`);

        // Query database to find cumulative mmte without daily mmte for this date
        const selectedMmte = await TTTFDatabaseHelper.getCumulativeMmteWithoutDailyMmte(resolvedDate);
        this.scenarioContext.setVariable('selectedCumulativeMmteForAdd', selectedMmte);

        // Select it in the UI
        await this.cumulativeMmtesPage.selectCumulativeRefInAddModal(selectedMmte);
        CSReporter.pass(`Selected cumulative mmte without daily mmte: ${selectedMmte}`);
    }

    @CSBDDStepDef('I select an cumulative mmte without daily mmte for this rrrrrrrr date')
    async selectCumulativeMmteWithoutDailyMmteForCurrentDate(): Promise<void> {
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate');
        CSReporter.info(`Selecting cumulative mmte without daily mmte for rrrrrrrr date: ${rrrrrrrrDate}`);

        // Query database to find cumulative mmte without daily mmte for this date
        const selectedMmte = await TTTFDatabaseHelper.getCumulativeMmteWithoutDailyMmte(rrrrrrrrDate || '');
        this.scenarioContext.setVariable('selectedCumulativeMmteForEdit', selectedMmte);

        // Select it in the UI
        await this.cumulativeMmtesPage.selectCumulativeMmteInEditModal(selectedMmte);
        CSReporter.pass(`Selected cumulative mmte without daily mmte: ${selectedMmte}`);
    }

    // ===================================================================
    // EDIT RRRRRRRR DATE STEPS (EXT08)
    // ===================================================================

    @CSBDDStepDef('I enter an existing rrrrrrrr date that already has a daily mmte')
    async enterExistingRrrrrrrrDateWithDailyMmte(): Promise<void> {
        CSReporter.info('Entering existing rrrrrrrr date that already has a daily mmte');

        // Get current mmte name and rrrrrrrr date from scenario context
        const cumulativeMmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');
        const currentRrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate');

        // Query database to find an existing date with daily mmte (different from current)
        const existingDate = await TTTFDatabaseHelper.getExistingDateWithDailyMmte(
            cumulativeMmteName || '',
            currentRrrrrrrrDate || ''
        );
        this.scenarioContext.setVariable('duplicateRrrrrrrrDate', existingDate);

        await this.cumulativeMmtesPage.setEditInstanceRrrrrrrrDate(existingDate);
        CSReporter.pass(`Entered existing rrrrrrrr date: ${existingDate}`);
    }

    @CSBDDStepDef('I enter an rrrrrrrr date that does not have a daily mmte')
    async enterRrrrrrrrDateWithoutDailyMmte(): Promise<void> {
        CSReporter.info('Entering rrrrrrrr date that does not have a daily mmte');

        // Query database to get non-existing rrrrrrrr date (5 months ago)
        const newDate = await TTTFDatabaseHelper.getNonExistingRrrrrrrrDate();
        this.scenarioContext.setVariable('newRrrrrrrrDate', newDate);

        await this.cumulativeMmtesPage.setEditInstanceRrrrrrrrDate(newDate);
        CSReporter.pass(`Entered new rrrrrrrr date: ${newDate}`);
    }

    // ===================================================================
    // EDIT CUMULATIVE SCATTERED STEPS (EXT07)
    // ===================================================================

    @CSBDDStepDef('I select an existing cumulative mmte with daily mmte for same rrrrrrrr date')
    async selectExistingCumulativeMmteWithDailyMmte(): Promise<void> {
        CSReporter.info('Selecting existing cumulative mmte with daily mmte for same rrrrrrrr date');

        // Get current rrrrrrrr date and mmte name from scenario context
        const rrrrrrrrDate = this.scenarioContext.getVariable<string>('startDate');
        const currentMmteName = this.scenarioContext.getVariable<string>('cumulativeMmteName');

        // Query database to find a different mmte that has daily mmte on same date
        const existingMmte = await TTTFDatabaseHelper.getDifferentMmteWithSameDate(
            rrrrrrrrDate || '',
            currentMmteName || ''
        );
        this.scenarioContext.setVariable('duplicateCumulativeMmte', existingMmte);

        await this.cumulativeMmtesPage.selectCumulativeMmteInEditModal(existingMmte);
        CSReporter.pass(`Selected existing cumulative mmte: ${existingMmte}`);
    }

    // ===================================================================
    // EDIT MMTE PERCENTAGE STEPS (EXT09)
    // ===================================================================

    @CSBDDStepDef('I clear Mmte field and enter {string}')
    async clearMmteFieldAndEnter(newMmte: string): Promise<void> {
        const resolvedMmte = CSValueResolver.resolve(newMmte, this.context);
        CSReporter.info(`Clearing Mmte field and entering: ${resolvedMmte}`);
        await this.cumulativeMmtesPage.setEditInstanceMmte(resolvedMmte);
        CSReporter.pass(`Mmte field cleared and entered: ${resolvedMmte}`);
    }

    @CSBDDStepDef('row {int} {string} column should show {string}')
    async verifyRowColumnValue(rowIndex: number, columnName: string, expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        CSReporter.info(`Verifying row ${rowIndex} "${columnName}" shows: ${resolvedValue}`);
        const actualValue = await this.cumulativeMmtesPage.getTableCellValueByColumnName(rowIndex, columnName);

        if (actualValue.includes(resolvedValue) || actualValue === resolvedValue) {
            CSReporter.pass(`Row ${rowIndex} "${columnName}" shows expected value: ${resolvedValue}`);
        } else {
            CSReporter.fail(`Row ${rowIndex} "${columnName}" mismatch. Expected: ${resolvedValue}, Actual: ${actualValue}`);
            throw new Error(`Column value verification failed for row ${rowIndex} "${columnName}"`);
        }
    }

    @CSBDDStepDef('row {int} {string} should be unchanged')
    async verifyRowColumnUnchanged(rowIndex: number, columnName: string): Promise<void> {
        CSReporter.info(`Verifying row ${rowIndex} "${columnName}" is unchanged`);
        const capturedData = this.scenarioContext.getVariable<any>('capturedRowData');

        if (!capturedData) {
            CSReporter.warn('No captured data to compare - skipping verification');
            CSReporter.pass(`Row ${rowIndex} "${columnName}" unchanged check skipped`);
            return;
        }

        const actualValue = await this.cumulativeMmtesPage.getTableCellValueByColumnName(rowIndex, columnName);
        const columnKey = columnName.replace(/[^a-zA-Z]/g, '').toLowerCase();
        const expectedValue = capturedData[columnKey] || capturedData.rrrrrrrrDate || '';

        if (actualValue === expectedValue || actualValue.includes(expectedValue)) {
            CSReporter.pass(`Row ${rowIndex} "${columnName}" is unchanged: ${actualValue}`);
        } else {
            CSReporter.fail(`Row ${rowIndex} "${columnName}" changed. Expected: ${expectedValue}, Actual: ${actualValue}`);
            throw new Error(`Column unchanged verification failed for row ${rowIndex} "${columnName}"`);
        }
    }
}

export default TTTFCumulativeMmtesSteps;

-------------------------------------------------------------------------------------------------------------------------------------------------------

import { StepDefinitions, CSBDDStepDef, Page } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSBDDContext, CSScenarioContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSValueResolver } from '@mdakhan.mak/cs-playwright-test-framework/utilities';
import { CSBrowserManager } from '@mdakhan.mak/cs-playwright-test-framework/browser';

import { TTTFNavigationPage } from '../pages/TTTFNavigationPage';
import { TTTFZealPremisisPage } from '../pages/TTTFZealPremisisPage';
import { TTTFZealDetailsPage } from '../pages/TTTFZealDetailsPage';
import { TTTFScatteredMmtesModalPage } from '../pages/TTTFScatteredMmtesModalPage';
import { TTTFChangesHistoryPage } from '../pages/TTTFChangesHistoryPage';
import { TTTFPendingApprovalsPage } from '../pages/TTTFPendingApprovalsPage';
import { TTTFDatabaseHelper } from '../helpers/TTTFDatabaseHelper';

/**
 * TTTF New Zeal Setup Step Definitions
 * Source: SCENARIO_03_NewZeal_Approval.txt
 * Implements Maker-Checker workflow for new zeal setup
 */
@StepDefinitions
export class TTTFNewZealSteps {

    @Page('tttf-navigation')
    private navigationPage!: TTTFNavigationPage;

    @Page('tttf-zeal-premisis')
    private zealPremisisPage!: TTTFZealPremisisPage;

    @Page('tttf-zeal-details')
    private zealDetailsPage!: TTTFZealDetailsPage;

    @Page('tttf-scattered-mmtes-modal')
    private scatteredMmtesModalPage!: TTTFScatteredMmtesModalPage;

    @Page('tttf-changes-history')
    private changesHistoryPage!: TTTFChangesHistoryPage;

    @Page('tttf-pending-approvals')
    private pendingApprovalsPage!: TTTFPendingApprovalsPage;

    private context = CSBDDContext.getInstance();
    private scenarioContext = CSScenarioContext.getInstance();

    // ===================================================================
    // TEST DATA SETUP STEPS
    // ===================================================================

    @CSBDDStepDef('I get zeal for new setup from database')
    async getZealForNewSetupFromDatabase(): Promise<void> {
        CSReporter.info('Getting zeal for new setup from database');

        const zealDetails = await TTTFDatabaseHelper.getZealForNewSetup();
        if (!zealDetails) {
            throw new Error('No zeal available for new setup in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);
        this.scenarioContext.setVariable('premisisDescription', zealDetails.premisisDescription);
        this.scenarioContext.setVariable('calcShoolName', zealDetails.calcShoolName);
        this.scenarioContext.setVariable('administrator', zealDetails.administrator);

        CSReporter.pass(`Retrieved zeal for new setup: ID=${zealDetails.zealId}, Name=${zealDetails.zealName}`);
    }

    @CSBDDStepDef('I get scattered mmtes to add from database')
    async getScatteredMmtesToAddFromDatabase(): Promise<void> {
        CSReporter.info('Getting scattered mmtes to add from database');

        const scatteredMmtes = await TTTFDatabaseHelper.getScatteredMmtesToAdd();
        if (scatteredMmtes.length === 0) {
            throw new Error('No scattered mmtes available to add from database');
        }

        const mmteNames = scatteredMmtes.map(r => r.scatteredMmteName);
        this.scenarioContext.setVariable('scatteredMmtesToAdd', mmteNames);
        this.scenarioContext.setVariable('scatteredMmtesDetails', scatteredMmtes);

        CSReporter.pass(`Retrieved ${mmteNames.length} scattered mmtes to add: ${mmteNames.join(', ')}`);
    }

    // ===================================================================
    // ZEAL DETAILS PAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Details page')
    async verifyZealDetailsPage(): Promise<void> {
        await this.zealDetailsPage.verifyZealDetailsPageDisplayed();
    }

    @CSBDDStepDef('I should see Edit Zeal page')
    async verifyEditZealPage(): Promise<void> {
        await this.zealDetailsPage.verifyEditZealPageDisplayed();
    }

    @CSBDDStepDef('Edit button should be enabled')
    async verifyEditButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isEditButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Edit button is enabled');
        } else {
            throw new Error('Edit button is not enabled');
        }
    }

    @CSBDDStepDef('Edit button should be disabled')
    async verifyEditButtonDisabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isEditButtonEnabled();
        if (!isEnabled) {
            CSReporter.pass('Edit button is disabled');
        } else {
            throw new Error('Edit button is not disabled');
        }
    }

    @CSBDDStepDef('I click Edit button')
    async clickEditButton(): Promise<void> {
        await this.zealDetailsPage.clickEditButton();
    }

    @CSBDDStepDef('Details tab should be selected')
    async verifyDetailsTabSelected(): Promise<void> {
        const isSelected = await this.zealDetailsPage.isDetailsTabSelected();
        if (isSelected) {
            CSReporter.pass('Details tab is selected');
        } else {
            throw new Error('Details tab is not selected');
        }
    }

    @CSBDDStepDef('I click Changes tab')
    async clickChangesTab(): Promise<void> {
        await this.zealDetailsPage.clickChangesTab();
    }

    @CSBDDStepDef('I click History tab')
    async clickHistoryTab(): Promise<void> {
        await this.zealDetailsPage.clickHistoryTab();
    }

    @CSBDDStepDef('I click Details tab')
    async clickDetailsTab(): Promise<void> {
        await this.zealDetailsPage.clickDetailsTab();
    }

    @CSBDDStepDef('Changes tab should be present')
    async verifyChangesTabPresent(): Promise<void> {
        const isPresent = await this.zealDetailsPage.isChangesTabPresent();
        if (isPresent) {
            CSReporter.pass('Changes tab is present');
        } else {
            throw new Error('Changes tab is not present');
        }
    }

    @CSBDDStepDef('History tab should be present')
    async verifyHistoryTabPresent(): Promise<void> {
        const isPresent = await this.zealDetailsPage.isHistoryTabPresent();
        if (isPresent) {
            CSReporter.pass('History tab is present');
        } else {
            throw new Error('History tab is not present');
        }
    }

    @CSBDDStepDef('Cancel button should be enabled')
    async verifyZealCancelButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isCancelButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Cancel button is enabled');
        } else {
            throw new Error('Cancel button is not enabled');
        }
    }

    @CSBDDStepDef('Use Sketchmark Replacement checkbox should be unchecked')
    async verifyUseSketchmarkReplacementUnchecked(): Promise<void> {
        const isChecked = await this.zealDetailsPage.isUseSketchmarkReplacementChecked();
        if (!isChecked) {
            CSReporter.pass('Use Sketchmark Replacement checkbox is unchecked');
        } else {
            throw new Error('Use Sketchmark Replacement checkbox should be unchecked but is checked');
        }
    }

    @CSBDDStepDef('Output Ttcalc File checkbox should be unchecked')
    async verifyOutputTtcalcFileUnchecked(): Promise<void> {
        const isChecked = await this.zealDetailsPage.isOutputTtcalcFileChecked();
        if (!isChecked) {
            CSReporter.pass('Output Ttcalc File checkbox is unchecked');
        } else {
            throw new Error('Output Ttcalc File checkbox should be unchecked but is checked');
        }
    }

    @CSBDDStepDef('Reorder button should be visible')
    async verifyReorderButtonVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isReorderButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reorder button is visible');
        } else {
            throw new Error('Reorder button is not visible');
        }
    }

    // ===================================================================
    // SUMMARY SECTION VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('Summary section should be visible')
    async verifySummaryVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.summaryHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Summary section is visible');
        } else {
            throw new Error('Summary section is not visible');
        }
    }

    @CSBDDStepDef('Zeal ID in Summary should match stored value')
    async verifyZealIdInSummary(): Promise<void> {
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealDetailsPage.getZealId();

        if (actualZealId === expectedZealId) {
            CSReporter.pass(`Zeal ID matches: ${actualZealId}`);
        } else {
            throw new Error(`Zeal ID mismatch: Expected=${expectedZealId}, Actual=${actualZealId}`);
        }
    }

    @CSBDDStepDef('Zeal Name in Summary should match stored value')
    async verifyZealNameInSummary(): Promise<void> {
        const expectedZealName = this.scenarioContext.getVariable('zealName');
        const actualZealName = await this.zealDetailsPage.getZealName();

        if (actualZealName === expectedZealName) {
            CSReporter.pass(`Zeal Name matches: ${actualZealName}`);
        } else {
            throw new Error(`Zeal Name mismatch: Expected=${expectedZealName}, Actual=${actualZealName}`);
        }
    }

    @CSBDDStepDef('Zeal Key in Summary should match stored value')
    async verifyZealKeyInSummary(): Promise<void> {
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealDetailsPage.getZealKey();

        if (actualZealKey === expectedZealKey) {
            CSReporter.pass(`Zeal Key matches: ${actualZealKey}`);
        } else {
            throw new Error(`Zeal Key mismatch: Expected=${expectedZealKey}, Actual=${actualZealKey}`);
        }
    }

    @CSBDDStepDef('Zzzt Seggregation in Summary should match stored value')
    async verifyZzztSeggregationInSummary(): Promise<void> {
        const expectedZzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');
        const actualZzztAbbrev = await this.zealDetailsPage.getZzztSeggregation();

        if (actualZzztAbbrev === expectedZzztAbbrev) {
            CSReporter.pass(`Zzzt Seggregation matches: ${actualZzztAbbrev}`);
        } else {
            throw new Error(`Zzzt Seggregation mismatch: Expected=${expectedZzztAbbrev}, Actual=${actualZzztAbbrev}`);
        }
    }

    @CSBDDStepDef('Premisis Description in Summary should match stored value')
    async verifyPremisisDescriptionInSummary(): Promise<void> {
        const expectedPremisisDesc = this.scenarioContext.getVariable('premisisDescription');
        const actualPremisisDesc = await this.zealDetailsPage.getPremisisDescription();

        if (actualPremisisDesc === expectedPremisisDesc) {
            CSReporter.pass(`Premisis Description matches: ${actualPremisisDesc}`);
        } else {
            throw new Error(`Premisis Description mismatch: Expected=${expectedPremisisDesc}, Actual=${actualPremisisDesc}`);
        }
    }

    @CSBDDStepDef('Inductor Group in Summary should match stored value')
    async verifyInductorGroupInSummary(): Promise<void> {
        const expectedInductorGroup = this.scenarioContext.getVariable('inductorGroup');
        const actualInductorGroup = await this.zealDetailsPage.getInductorGroup();

        if (actualInductorGroup === expectedInductorGroup) {
            CSReporter.pass(`Inductor Group matches: ${actualInductorGroup}`);
        } else {
            throw new Error(`Inductor Group mismatch: Expected=${expectedInductorGroup}, Actual=${actualInductorGroup}`);
        }
    }

    @CSBDDStepDef('Kindness Circle in Summary should match stored value')
    async verifyKindnessCircleInSummary(): Promise<void> {
        const expectedKindnessCircle = this.scenarioContext.getVariable('kindnessCircle');
        const actualKindnessCircle = await this.zealDetailsPage.getKindnessCircle();

        if (actualKindnessCircle === expectedKindnessCircle) {
            CSReporter.pass(`Kindness Circle matches: ${actualKindnessCircle}`);
        } else {
            throw new Error(`Kindness Circle mismatch: Expected=${expectedKindnessCircle}, Actual=${actualKindnessCircle}`);
        }
    }

    @CSBDDStepDef('Ttcalc Shool in Summary should match stored value')
    async verifyTtcalcShoolInSummary(): Promise<void> {
        const expectedCalcShool = this.scenarioContext.getVariable('calcShoolName');
        const actualCalcShool = await this.zealDetailsPage.getTtcalcShool();

        // Ttcalc Shool in UI may have additional "(CIF File Name)" suffix
        if (actualCalcShool.includes(expectedCalcShool) || actualCalcShool === expectedCalcShool) {
            CSReporter.pass(`Ttcalc Shool matches: ${actualCalcShool}`);
        } else {
            throw new Error(`Ttcalc Shool mismatch: Expected=${expectedCalcShool}, Actual=${actualCalcShool}`);
        }
    }

    @CSBDDStepDef('Account Manager in Summary should match stored value')
    async verifyAccountManagerInSummary(): Promise<void> {
        const expectedAdmin = this.scenarioContext.getVariable('administrator');
        const actualAdmin = await this.zealDetailsPage.getAdministratorValue();

        if (actualAdmin === expectedAdmin) {
            CSReporter.pass(`Account Manager matches: ${actualAdmin}`);
        } else {
            throw new Error(`Account Manager mismatch: Expected=${expectedAdmin}, Actual=${actualAdmin}`);
        }
    }

    @CSBDDStepDef('I verify all Summary fields match database values')
    async verifyAllSummaryFieldsMatchDatabase(): Promise<void> {
        CSReporter.info('Verifying all Summary section fields against database values');

        // Zeal ID
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealDetailsPage.getZealId();
        if (actualZealId !== expectedZealId) {
            throw new Error(`Zeal ID mismatch: Expected=${expectedZealId}, Actual=${actualZealId}`);
        }
        CSReporter.info(`Zeal ID verified: ${actualZealId}`);

        // Zeal Key
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealDetailsPage.getZealKey();
        if (actualZealKey !== expectedZealKey) {
            throw new Error(`Zeal Key mismatch: Expected=${expectedZealKey}, Actual=${actualZealKey}`);
        }
        CSReporter.info(`Zeal Key verified: ${actualZealKey}`);

        // Zeal Name
        const expectedZealName = this.scenarioContext.getVariable('zealName');
        const actualZealName = await this.zealDetailsPage.getZealName();
        if (actualZealName !== expectedZealName) {
            throw new Error(`Zeal Name mismatch: Expected=${expectedZealName}, Actual=${actualZealName}`);
        }
        CSReporter.info(`Zeal Name verified: ${actualZealName}`);

        // Zzzt Seggregation
        const expectedZzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');
        const actualZzztAbbrev = await this.zealDetailsPage.getZzztSeggregation();
        if (actualZzztAbbrev !== expectedZzztAbbrev) {
            throw new Error(`Zzzt Seggregation mismatch: Expected=${expectedZzztAbbrev}, Actual=${actualZzztAbbrev}`);
        }
        CSReporter.info(`Zzzt Seggregation verified: ${actualZzztAbbrev}`);

        // Premisis Description
        const expectedPremisisDesc = this.scenarioContext.getVariable('premisisDescription');
        const actualPremisisDesc = await this.zealDetailsPage.getPremisisDescription();
        if (actualPremisisDesc !== expectedPremisisDesc) {
            throw new Error(`Premisis Description mismatch: Expected=${expectedPremisisDesc}, Actual=${actualPremisisDesc}`);
        }
        CSReporter.info(`Premisis Description verified: ${actualPremisisDesc}`);

        // Inductor Group
        const expectedInductorGroup = this.scenarioContext.getVariable('inductorGroup');
        const actualInductorGroup = await this.zealDetailsPage.getInductorGroup();
        if (actualInductorGroup !== expectedInductorGroup) {
            throw new Error(`Inductor Group mismatch: Expected=${expectedInductorGroup}, Actual=${actualInductorGroup}`);
        }
        CSReporter.info(`Inductor Group verified: ${actualInductorGroup}`);

        // Kindness Circle
        const expectedKindnessCircle = this.scenarioContext.getVariable('kindnessCircle');
        const actualKindnessCircle = await this.zealDetailsPage.getKindnessCircle();
        if (actualKindnessCircle !== expectedKindnessCircle) {
            throw new Error(`Kindness Circle mismatch: Expected=${expectedKindnessCircle}, Actual=${actualKindnessCircle}`);
        }
        CSReporter.info(`Kindness Circle verified: ${actualKindnessCircle}`);

        // Ttcalc Shool
        const expectedCalcShool = this.scenarioContext.getVariable('calcShoolName');
        const actualCalcShool = await this.zealDetailsPage.getTtcalcShool();
        if (!actualCalcShool.includes(expectedCalcShool) && actualCalcShool !== expectedCalcShool) {
            throw new Error(`Ttcalc Shool mismatch: Expected=${expectedCalcShool}, Actual=${actualCalcShool}`);
        }
        CSReporter.info(`Ttcalc Shool verified: ${actualCalcShool}`);

        // Account Manager (Administrator)
        const expectedAdmin = this.scenarioContext.getVariable('administrator');
        const actualAdmin = await this.zealDetailsPage.getAdministratorValue();
        if (actualAdmin !== expectedAdmin) {
            throw new Error(`Account Manager mismatch: Expected=${expectedAdmin}, Actual=${actualAdmin}`);
        }
        CSReporter.info(`Account Manager verified: ${actualAdmin}`);

        CSReporter.pass('All Summary fields verified against database values');
    }

    // ===================================================================
    // SETTINGS SECTION STEPS
    // ===================================================================

    @CSBDDStepDef('Use Sketchmark Replacement should show {string}')
    async verifyUseSketchmarkReplacementValue(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows: ${actualValue}`);
        } else {
            throw new Error(`Use Sketchmark Replacement mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('Output Ttcalc File should show {string}')
    async verifyOutputTtcalcFileValue(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getOutputTtcalcFileValue();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`Output Ttcalc File shows: ${actualValue}`);
        } else {
            throw new Error(`Output Ttcalc File mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I check Use Sketchmark Replacement checkbox')
    async checkUseSketchmarkReplacement(): Promise<void> {
        await this.zealDetailsPage.checkUseSketchmarkReplacement();
    }

    @CSBDDStepDef('I uncheck Use Sketchmark Replacement checkbox')
    async uncheckUseSketchmarkReplacement(): Promise<void> {
        await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
    }

    @CSBDDStepDef('I check Output Ttcalc File checkbox')
    async checkOutputTtcalcFile(): Promise<void> {
        await this.zealDetailsPage.checkOutputTtcalcFile();
    }

    @CSBDDStepDef('I uncheck Output Ttcalc File checkbox')
    async uncheckOutputTtcalcFile(): Promise<void> {
        await this.zealDetailsPage.uncheckOutputTtcalcFile();
    }

    @CSBDDStepDef('I select FFX Inductor Type {string}')
    async selectFfxInductorType(inductorType: string): Promise<void> {
        const resolvedInductorType = CSValueResolver.resolve(inductorType, this.context);
        await this.zealDetailsPage.selectFfxInductorType(resolvedInductorType);
    }

    @CSBDDStepDef('FFX Inductor Type dropdown should show {string}')
    async verifyFfxInductorTypeSelected(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getSelectedFfxInductorType();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`FFX Inductor Type shows: ${actualValue}`);
        } else {
            throw new Error(`FFX Inductor Type mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify FFX Inductor Type options against database')
    async verifyFfxInductorTypeOptionsAgainstDatabase(): Promise<void> {
        const dbOptions = await TTTFDatabaseHelper.getFfxInductorOptions();
        const uiOptions = await this.zealDetailsPage.getFfxInductorTypeOptions();

        const missingInUI = dbOptions.filter(opt => !uiOptions.includes(opt));
        if (missingInUI.length > 0) {
            throw new Error(`FFX Inductor Type options missing in UI: ${missingInUI.join(', ')}`);
        }

        CSReporter.pass(`All ${dbOptions.length} FFX Inductor Type options verified`);
    }

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES STEPS
    // ===================================================================

    @CSBDDStepDef('No Scattered Mmtes message should be visible')
    async verifyNoScatteredMmtesMessage(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isNoScatteredMmtesMessageVisible();
        if (isVisible) {
            CSReporter.pass('No Scattered Mmtes message is visible');
        } else {
            throw new Error('No Scattered Mmtes message is not visible');
        }
    }

    @CSBDDStepDef('I wait for Add Remove button to be visible')
    async waitForAddRemoveButton(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isAddRemoveButtonVisible();
        if (isVisible) {
            CSReporter.pass('Add/Remove button is visible');
        } else {
            throw new Error('Add/Remove button is not visible after waiting');
        }
    }

    @CSBDDStepDef('I verify Associated Scattered Mmtes column headers')
    async verifyAssociatedScatteredMmtesColumnHeaders(): Promise<void> {
        await this.zealDetailsPage.verifyAssociatedScatteredMmtesColumnHeaders();
    }

    @CSBDDStepDef('I click Add Remove button')
    async clickAddRemoveButton(): Promise<void> {
        await this.zealDetailsPage.clickAddRemoveButton();
    }

    @CSBDDStepDef('Select Options modal should be visible')
    async verifySelectOptionsModalVisible(): Promise<void> {
        await this.scatteredMmtesModalPage.verifySelectOptionsModalDisplayed();
    }

    @CSBDDStepDef('I select scattered mmte {string} in modal')
    async selectScatteredMmteInModal(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        await this.scatteredMmtesModalPage.selectScatteredMmte(resolvedMmteName);
    }

    @CSBDDStepDef('I select all stored scattered mmtes in modal')
    async selectAllStoredScatteredMmtesInModal(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];

        for (const mmteName of mmteNames) {
            await this.scatteredMmtesModalPage.selectScatteredMmte(mmteName);
        }

        CSReporter.pass(`Selected ${mmteNames.length} scattered mmtes in modal`);
    }

    @CSBDDStepDef('I click Apply button in modal')
    async clickApplyButtonInModal(): Promise<void> {
        await this.scatteredMmtesModalPage.clickApplyButton();
        await this.scatteredMmtesModalPage.waitForModalToClose();
    }

    @CSBDDStepDef('I click Cancel button in Scattered Mmtes modal')
    async clickCancelButtonInScatteredMmtesModal(): Promise<void> {
        await this.scatteredMmtesModalPage.clickCancelButton();
    }

    @CSBDDStepDef('Scattered mmtes should be displayed in Associated Scattered Mmtes section')
    async verifyScatteredMmtesDisplayed(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const rowCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (rowCount !== mmteNames.length) {
            throw new Error(`Scattered mmte count mismatch: Expected=${mmteNames.length}, Actual=${rowCount}`);
        }

        for (let i = 0; i < rowCount; i++) {
            const rowData = await this.zealDetailsPage.getScatteredMmteRowData(i);

            // Verify FFX Order
            if (parseInt(rowData.ffxOrder) !== i + 1) {
                throw new Error(`Row ${i} FFX Order mismatch: Expected=${i + 1}, Actual=${rowData.ffxOrder}`);
            }

            // Verify Scattered Mmte Name is in the list
            if (!mmteNames.includes(rowData.scatteredMmteName)) {
                throw new Error(`Unexpected scattered mmte: ${rowData.scatteredMmteName}`);
            }

            CSReporter.info(`Row ${i}: FFX=${rowData.ffxOrder}, Mmte=${rowData.scatteredMmteName}, Cumulative=${rowData.cumulativeMmteName}`);
        }

        CSReporter.pass(`All ${rowCount} scattered mmtes verified`);
    }

    // ===================================================================
    // DISPUTED SCATTERED MMTE STEPS
    // ===================================================================

    @CSBDDStepDef('I click Disputed Select button for row {int}')
    async clickDisputedSelectButton(rowIndex: number): Promise<void> {
        await this.zealDetailsPage.clickDisputedSelectButton(rowIndex);
    }

    @CSBDDStepDef('Add Scattered Mmtes modal should be visible')
    async verifyAddScatteredMmtesModalVisible(): Promise<void> {
        await this.scatteredMmtesModalPage.verifyAddScatteredMmtesModalDisplayed();
    }

    @CSBDDStepDef('I select disputed scattered mmte {string} in modal')
    async selectDisputedScatteredMmteInModal(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(resolvedMmteName);
    }

    @CSBDDStepDef('I enter disputed start date {string} for row {int}')
    async enterDisputedStartDate(date: string, rowIndex: number): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        await this.zealDetailsPage.enterDisputedStartDate(rowIndex, resolvedDate);
    }

    @CSBDDStepDef('I configure disputed scattered mmtes if required')
    async configureDisputedScatteredMmtesIfRequired(): Promise<void> {
        CSReporter.info('Checking if disputed scattered mmtes need to be configured');

        // Get hasDisputedScatteredMmte from test data
        const hasDisputedScatteredMmte = this.scenarioContext.getVariable('hasDisputedScatteredMmte');

        if (!hasDisputedScatteredMmte || hasDisputedScatteredMmte === 'false' || hasDisputedScatteredMmte === false) {
            CSReporter.info('No disputed scattered mmtes required, skipping');
            return;
        }

        CSReporter.info('Disputed scattered mmtes required, processing...');

        // Get the disputed scattered mmtes data from test data
        // Format: { "scatteredMmteName1": { "disputedMmteName": "...", "disputedStartDate": "..." }, ... }
        const disputedMmtesData = this.scenarioContext.getVariable('disputedScatteredMmtes');

        if (!disputedMmtesData || typeof disputedMmtesData !== 'object') {
            CSReporter.warn('No disputed scattered mmtes data found in test data');
            return;
        }

        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[] || [];
        let rowIndex = 1;

        for (const mmteName of mmteNames) {
            const disputedData = disputedMmtesData[mmteName];

            if (disputedData && disputedData.disputedMmteName) {
                CSReporter.info(`Configuring disputed for row ${rowIndex}: ${mmteName}`);

                // Click Disputed Select button for this row
                await this.zealDetailsPage.clickDisputedSelectButton(rowIndex);

                // Verify Add Scattered Mmtes modal is displayed
                await this.scatteredMmtesModalPage.verifyAddScatteredMmtesModalDisplayed();

                // Select the disputed scattered mmte
                await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(disputedData.disputedMmteName);

                // Click Apply button
                await this.scatteredMmtesModalPage.clickApplyButton();
                await this.scatteredMmtesModalPage.waitForModalToClose();

                // Enter disputed start date if provided
                if (disputedData.disputedStartDate) {
                    await this.zealDetailsPage.enterDisputedStartDate(rowIndex, disputedData.disputedStartDate);
                }

                CSReporter.pass(`Configured disputed for row ${rowIndex}: ${disputedData.disputedMmteName}, Date: ${disputedData.disputedStartDate || 'N/A'}`);
            }

            rowIndex++;
        }

        CSReporter.pass('Disputed scattered mmtes configuration complete');
    }

    @CSBDDStepDef('I verify disputed scattered mmtes are displayed correctly')
    async verifyDisputedScatteredMmtesDisplayed(): Promise<void> {
        CSReporter.info('Verifying disputed scattered mmtes are displayed correctly');

        const hasDisputedScatteredMmte = this.scenarioContext.getVariable('hasDisputedScatteredMmte');

        if (!hasDisputedScatteredMmte || hasDisputedScatteredMmte === 'false' || hasDisputedScatteredMmte === false) {
            CSReporter.info('No disputed scattered mmtes to verify');
            return;
        }

        const disputedMmtesData = this.scenarioContext.getVariable('disputedScatteredMmtes');
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[] || [];
        let rowIndex = 0;

        for (const mmteName of mmteNames) {
            const disputedData = disputedMmtesData?.[mmteName];

            if (disputedData && disputedData.disputedMmteName) {
                const rowData = await this.zealDetailsPage.getScatteredMmteRowData(rowIndex);

                // Verify disputed scattered mmte name
                if (!rowData.disputedScatteredMmte.includes(disputedData.disputedMmteName)) {
                    throw new Error(`Row ${rowIndex}: Disputed mmte mismatch. Expected to contain: ${disputedData.disputedMmteName}, Actual: ${rowData.disputedScatteredMmte}`);
                }

                // Verify disputed start date if provided
                if (disputedData.disputedStartDate && rowData.disputedStartDate !== disputedData.disputedStartDate) {
                    throw new Error(`Row ${rowIndex}: Disputed date mismatch. Expected: ${disputedData.disputedStartDate}, Actual: ${rowData.disputedStartDate}`);
                }

                CSReporter.info(`Row ${rowIndex}: Disputed verified - ${rowData.disputedScatteredMmte}, ${rowData.disputedStartDate}`);
            }

            rowIndex++;
        }

        CSReporter.pass('All disputed scattered mmtes verified');
    }

    // ===================================================================
    // ACTION BUTTON STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Save button should be enabled')
    async verifyZealSaveButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isSaveButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Zeal Save button is enabled');
        } else {
            throw new Error('Zeal Save button is not enabled');
        }
    }

    @CSBDDStepDef('Save button should be disabled')
    async verifySaveButtonDisabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isSaveButtonEnabled();
        if (!isEnabled) {
            CSReporter.pass('Save button is disabled');
        } else {
            throw new Error('Save button is not disabled');
        }
    }

    @CSBDDStepDef('I click Save button')
    async clickSaveButton(): Promise<void> {
        await this.zealDetailsPage.clickSaveButton();
    }

    @CSBDDStepDef('I should see save success message')
    async verifySaveSuccessMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        const zealId = this.scenarioContext.getVariable('zealId');

        if (messageText.includes('saved') || messageText.includes(zealId)) {
            CSReporter.pass(`Save success message: ${messageText}`);
        } else {
            throw new Error(`Expected save success message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I should see pending approval alert')
    async verifyPendingApprovalAlert(): Promise<void> {
        const feedbackText = await this.zealDetailsPage.getFeedbackMessageText();

        if (feedbackText.includes('pending approval')) {
            CSReporter.pass(`Pending approval alert: ${feedbackText}`);
        } else {
            throw new Error(`Expected pending approval alert, got: ${feedbackText}`);
        }
    }

    @CSBDDStepDef('View Changes link should be visible')
    async verifyViewChangesLinkVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isViewChangesLinkVisible();
        if (isVisible) {
            CSReporter.pass('View Changes link is visible');
        } else {
            throw new Error('View Changes link is not visible');
        }
    }

    @CSBDDStepDef('I click View Changes link')
    async clickViewChangesLink(): Promise<void> {
        await this.zealDetailsPage.clickViewChangesLink();
    }

    // ===================================================================
    // CHANGES TAB STEPS
    // ===================================================================

    @CSBDDStepDef('Changes section should be visible')
    async verifyChangesSectionVisible(): Promise<void> {
        await this.changesHistoryPage.verifyChangesHeaderDisplayed();
    }

    @CSBDDStepDef('I verify Changes table column headers')
    async verifyChangesTableColumnHeaders(): Promise<void> {
        await this.changesHistoryPage.verifyChangesTableColumnHeaders();
    }

    @CSBDDStepDef('Changes table should show pending changes')
    async verifyChangesTableHasData(): Promise<void> {
        const rowCount = await this.changesHistoryPage.getChangesRowCount();
        if (rowCount > 0) {
            CSReporter.pass(`Changes table has ${rowCount} rows`);
        } else {
            throw new Error('Changes table is empty');
        }
    }

    @CSBDDStepDef('I verify changes data matches added scattered mmtes')
    async verifyChangesDataMatchesScatteredMmtes(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const changesData = await this.changesHistoryPage.getAllChangesData();

        for (const change of changesData) {
            if (change.description !== 'Add Scattered Mmte') {
                throw new Error(`Unexpected change description: ${change.description}`);
            }

            if (!mmteNames.includes(change.newValue)) {
                throw new Error(`Unexpected scattered mmte in changes: ${change.newValue}`);
            }

            CSReporter.info(`Change: ${change.description} - ${change.newValue}, Modified By: ${change.modifiedBy}`);
        }

        CSReporter.pass(`All ${changesData.length} changes verified`);
    }

    @CSBDDStepDef('Cancel Changes button should be visible')
    async verifyCancelChangesButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isCancelChangesButtonVisible();
        if (isVisible) {
            CSReporter.pass('Cancel Changes button is visible');
        } else {
            throw new Error('Cancel Changes button is not visible');
        }
    }

    @CSBDDStepDef('Approve button should be visible')
    async verifyApproveButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isApproveButtonVisible();
        if (isVisible) {
            CSReporter.pass('Approve button is visible');
        } else {
            throw new Error('Approve button is not visible');
        }
    }

    @CSBDDStepDef('Reject button should be visible')
    async verifyRejectButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isRejectButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reject button is visible');
        } else {
            throw new Error('Reject button is not visible');
        }
    }

    @CSBDDStepDef('I click Approve button')
    async clickApproveButton(): Promise<void> {
        await this.changesHistoryPage.clickApproveButton();
    }

    @CSBDDStepDef('I click Reject button')
    async clickRejectButton(): Promise<void> {
        await this.changesHistoryPage.clickRejectButton();
    }

    @CSBDDStepDef('Changes table should be empty after approval')
    async verifyChangesTableEmpty(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after approval');
        } else {
            throw new Error('Changes table is not empty after approval');
        }
    }

    // ===================================================================
    // HISTORY TAB STEPS
    // ===================================================================

    @CSBDDStepDef('History section should be visible')
    async verifyHistorySectionVisible(): Promise<void> {
        await this.changesHistoryPage.verifyHistoryHeaderDisplayed();
    }

    @CSBDDStepDef('I verify History table column headers')
    async verifyHistoryTableColumnHeaders(): Promise<void> {
        await this.changesHistoryPage.verifyHistoryTableColumnHeaders();
    }

    @CSBDDStepDef('History table should show approved changes')
    async verifyHistoryTableHasData(): Promise<void> {
        const rowCount = await this.changesHistoryPage.getHistoryRowCount();
        if (rowCount > 0) {
            CSReporter.pass(`History table has ${rowCount} rows`);
        } else {
            throw new Error('History table is empty');
        }
    }

    @CSBDDStepDef('I verify history data matches approved scattered mmtes')
    async verifyHistoryDataMatchesScatteredMmtes(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const historyData = await this.changesHistoryPage.getAllHistoryData();

        for (const history of historyData) {
            if (history.description !== 'Add Scattered Mmte') {
                throw new Error(`Unexpected history description: ${history.description}`);
            }

            if (!mmteNames.includes(history.newValue)) {
                throw new Error(`Unexpected scattered mmte in history: ${history.newValue}`);
            }

            CSReporter.info(`History: ${history.description} - ${history.newValue}, Approved By: ${history.approvedBy}`);
        }

        CSReporter.pass(`All ${historyData.length} history entries verified`);
    }

    // ===================================================================
    // BROWSER CONTEXT / RE-AUTHENTICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I clear browser context for re-authentication')
    async clearBrowserContextForReauth(): Promise<void> {
        CSReporter.info('Clearing browser context for re-authentication (switching user)');
        const browserManager = CSBrowserManager.getInstance();
        await browserManager.clearContextAndReauthenticate();
        CSReporter.pass('Browser context cleared, ready for new user login');
    }

    // ===================================================================
    // PENDING APPROVALS PAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I navigate to Pending Approvals page')
    async navigateToPendingApprovalsPage(): Promise<void> {
        await this.navigationPage.clickMenuItem('Pending Approvals');
        await this.pendingApprovalsPage.verifyPageDisplayed();
    }

    @CSBDDStepDef('Pending Approvals page should be displayed')
    async verifyPendingApprovalsPageDisplayed(): Promise<void> {
        await this.pendingApprovalsPage.verifyPageDisplayed();
    }

    @CSBDDStepDef('I find and click View link for stored zeal')
    async findAndClickViewForStoredZeal(): Promise<void> {
        const zealName = this.scenarioContext.getVariable('zealName');
        await this.pendingApprovalsPage.clickViewLinkByZealName(zealName);
    }

    // ===================================================================
    // DATABASE VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I verify zeal data record exists in database')
    async verifyZealDataRecordExists(): Promise<void> {
        const zealId = this.scenarioContext.getVariable('zealId');
        const zealData = await TTTFDatabaseHelper.getZealDataByZealId(zealId);

        if (!zealData) {
            throw new Error(`Zeal data record not found for zeal ID: ${zealId}`);
        }

        this.scenarioContext.setVariable('zealpremisisDataId', zealData.zealpremisisDataId);
        CSReporter.pass(`Zeal data record exists: zealpremisisDataId=${zealData.zealpremisisDataId}`);
    }

    @CSBDDStepDef('I verify zealpremisis data has correct settings')
    async verifyZealpremisisDataSettings(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const details = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!details) {
            throw new Error(`Zealpremisis data details not found for ID: ${zealpremisisDataId}`);
        }

        CSReporter.info(`Zealpremisis data: sketchmarkFlag=${details.sketchmarkReplacementFlag}, inductorCode=${details.inductorCode}`);
        CSReporter.pass('Zealpremisis data settings verified');
    }

    @CSBDDStepDef('I verify status log shows {string} status')
    async verifyStatusLogStatus(expectedStatus: string): Promise<void> {
        const resolvedStatus = CSValueResolver.resolve(expectedStatus, this.context) as 'AWAITING' | 'APPROVED' | 'REJECTED';
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');

        const isCorrect = await TTTFDatabaseHelper.verifyStatusLogStatus(zealpremisisDataId, resolvedStatus);

        if (isCorrect) {
            CSReporter.pass(`Status log shows ${resolvedStatus} status`);
        } else {
            throw new Error(`Status log does not show ${resolvedStatus} status`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data exists after approval')
    async verifyZealpremisisMmteDataExists(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            throw new Error('No zealpremisis mmte data found after approval');
        }

        CSReporter.pass(`Zealpremisis mmte data exists: ${mmteData.length} records`);
    }

    // ===================================================================
    // PREMISIS-SPECIFIC STEPS
    // ===================================================================

    @CSBDDStepDef('I get premisis for new setup from database')
    async getPremisisForNewSetupFromDatabase(): Promise<void> {
        CSReporter.info('Getting premisis for new setup from database');

        const premisisDetails = await TTTFDatabaseHelper.getPremisisForNewSetup();
        if (!premisisDetails) {
            throw new Error('No premisis available for new setup in database');
        }

        this.scenarioContext.setVariable('zealId', premisisDetails.zealId);
        this.scenarioContext.setVariable('zealKey', premisisDetails.zealKey);
        this.scenarioContext.setVariable('zealName', premisisDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', premisisDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', premisisDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', premisisDetails.zzztSeggregation);
        this.scenarioContext.setVariable('premisisDescription', premisisDetails.premisisDescription);
        this.scenarioContext.setVariable('calcShoolName', premisisDetails.calcShoolName);
        this.scenarioContext.setVariable('administrator', premisisDetails.administrator);
        this.scenarioContext.setVariable('zzztId', premisisDetails.zzztId);

        CSReporter.pass(`Retrieved premisis for new setup: ID=${premisisDetails.zealId}, Zzzt Abbrev=${premisisDetails.zzztSeggregation}`);
    }

    @CSBDDStepDef('I should see Premisis Details page')
    async verifyPremisisDetailsPage(): Promise<void> {
        await this.zealDetailsPage.verifyPremisisDetailsPageDisplayed();
    }

    @CSBDDStepDef('I should see Edit Premisis page')
    async verifyEditPremisisPage(): Promise<void> {
        await this.zealDetailsPage.verifyEditPremisisPageDisplayed();
    }

    @CSBDDStepDef('Output Ttcalc File checkbox should be disabled for Premisis')
    async verifyOutputCalcFileDisabledForPremisis(): Promise<void> {
        const isDisabled = await this.zealDetailsPage.isOutputTtcalcFileCheckboxDisabled();
        if (isDisabled) {
            CSReporter.pass('Output Ttcalc File checkbox is disabled for Premisis');
        } else {
            throw new Error('Output Ttcalc File checkbox should be disabled for Premisis');
        }
    }

    @CSBDDStepDef('FFX Inductor Type dropdown should be disabled for Premisis')
    async verifyFfxInductorTypeDisabledForPremisis(): Promise<void> {
        const isDisabled = await this.zealDetailsPage.isFfxInductorTypeDropdownDisabled();
        if (isDisabled) {
            CSReporter.pass('FFX Inductor Type dropdown is disabled for Premisis');
        } else {
            throw new Error('FFX Inductor Type dropdown should be disabled for Premisis');
        }
    }

    @CSBDDStepDef('I should see save success message for Premisis')
    async verifySaveSuccessMessageForPremisis(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        const zzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');

        if (messageText.includes('saved') || messageText.includes(zzztAbbrev)) {
            CSReporter.pass(`Save success message for Premisis: ${messageText}`);
        } else {
            throw new Error(`Expected save success message for Premisis, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I verify zzzt data record exists in database')
    async verifyZzztDataRecordExists(): Promise<void> {
        const zzztId = this.scenarioContext.getVariable('zzztId') || this.scenarioContext.getVariable('zealId');
        const zzztData = await TTTFDatabaseHelper.getZzztDataByZzztId(zzztId);

        if (!zzztData) {
            throw new Error(`Zzzt data record not found for zzzt ID: ${zzztId}`);
        }

        this.scenarioContext.setVariable('zealpremisisDataId', zzztData.zealpremisisDataId);
        CSReporter.pass(`Zzzt data record exists: zealpremisisDataId=${zzztData.zealpremisisDataId}`);
    }

    @CSBDDStepDef('I verify zealpremisis data has correct settings for Premisis')
    async verifyZealpremisisDataSettingsForPremisis(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const details = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!details) {
            throw new Error(`Zealpremisis data details not found for ID: ${zealpremisisDataId}`);
        }

        // For Premisis, Output Ttcalc File should be disabled (null/empty inductor code)
        CSReporter.info(`Premisis zealpremisis data: sketchmarkFlag=${details.sketchmarkReplacementFlag}, inductorCode=${details.inductorCode || 'N/A'}`);
        CSReporter.pass('Premisis zealpremisis data settings verified');
    }

    // ===================================================================
    // REJECTION FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('Review Reject Email modal should be visible')
    async verifyRejectEmailModalVisible(): Promise<void> {
        await this.changesHistoryPage.verifyRejectEmailModalDisplayed();
    }

    @CSBDDStepDef('Reject comment textarea should be visible')
    async verifyRejectCommentTextareaVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isRejectCommentTextareaVisible();
        if (isVisible) {
            CSReporter.pass('Reject comment textarea is visible');
        } else {
            throw new Error('Reject comment textarea is not visible');
        }
    }

    @CSBDDStepDef('Send button should be visible')
    async verifySendButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isSendButtonVisible();
        if (isVisible) {
            CSReporter.pass('Send button is visible');
        } else {
            throw new Error('Send button is not visible');
        }
    }

    @CSBDDStepDef('I enter rejection comment {string}')
    async enterRejectionComment(comment: string): Promise<void> {
        const resolvedComment = CSValueResolver.resolve(comment, this.context);
        await this.changesHistoryPage.enterRejectComment(resolvedComment);
    }

    @CSBDDStepDef('I click Send button in Reject modal')
    async clickSendButtonInRejectModal(): Promise<void> {
        await this.changesHistoryPage.clickSendButton();
    }

    @CSBDDStepDef('Rejection email sent message should be displayed')
    async verifyRejectionEmailSentMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Rejection') && messageText.includes('sent')) {
            CSReporter.pass(`Rejection email sent message: ${messageText}`);
        } else {
            throw new Error(`Expected rejection email sent message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('Changes table should be empty after rejection')
    async verifyChangesTableEmptyAfterRejection(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after rejection');
        } else {
            throw new Error('Changes table is not empty after rejection');
        }
    }

    @CSBDDStepDef('History table should show no data')
    async verifyHistoryTableNoData(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isHistoryNoDataVisible();
        if (isNoData) {
            CSReporter.pass('History table shows no data');
        } else {
            throw new Error('History table should show no data');
        }
    }

    @CSBDDStepDef('I verify status log is cleared after rejection')
    async verifyStatusLogClearedAfterRejection(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const statusLog = await TTTFDatabaseHelper.getZealpremisisStatusLog(zealpremisisDataId);

        if (statusLog.length === 0) {
            CSReporter.pass('Status log is cleared after rejection');
        } else {
            throw new Error(`Status log should be empty after rejection, found ${statusLog.length} records`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data does not exist after rejection')
    async verifyZealpremisisMmteDataNotExistsAfterRejection(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            CSReporter.pass('No zealpremisis mmte data exists after rejection');
        } else {
            throw new Error(`Zealpremisis mmte data should not exist after rejection, found ${mmteData.length} records`);
        }
    }

    // ===================================================================
    // CANCEL FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('I click Cancel Changes button')
    async clickCancelChangesButton(): Promise<void> {
        await this.changesHistoryPage.clickCancelChangesButton();
    }

    @CSBDDStepDef('Cancel changes success message should be displayed')
    async verifyCancelChangesSuccessMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Cancelled') || messageText.includes('cancelled')) {
            CSReporter.pass(`Cancel changes success message: ${messageText}`);
        } else {
            throw new Error(`Expected cancel changes success message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('Changes table should be empty after cancel')
    async verifyChangesTableEmptyAfterCancel(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after cancel');
        } else {
            throw new Error('Changes table is not empty after cancel');
        }
    }

    @CSBDDStepDef('I verify status log is cleared after cancel')
    async verifyStatusLogClearedAfterCancel(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const statusLog = await TTTFDatabaseHelper.getZealpremisisStatusLog(zealpremisisDataId);

        if (statusLog.length === 0) {
            CSReporter.pass('Status log is cleared after cancel');
        } else {
            throw new Error(`Status log should be empty after cancel, found ${statusLog.length} records`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data does not exist after cancel')
    async verifyZealpremisisMmteDataNotExistsAfterCancel(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            CSReporter.pass('No zealpremisis mmte data exists after cancel');
        } else {
            throw new Error(`Zealpremisis mmte data should not exist after cancel, found ${mmteData.length} records`);
        }
    }

    // ===================================================================
    // EDIT NAVIGATION STEPS (SCENARIO_08, 09A)
    // ===================================================================

    @CSBDDStepDef('I get zeal for edit navigation from database')
    async getZealForEditNavigationFromDatabase(): Promise<void> {
        CSReporter.info('Getting zeal for edit navigation from database');

        const zealDetails = await TTTFDatabaseHelper.getZealForEditNavigation();
        if (!zealDetails) {
            throw new Error('No zeal available for edit navigation in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);

        CSReporter.pass(`Retrieved zeal for edit navigation: ID=${zealDetails.zealId}, Key=${zealDetails.zealKey}`);
    }

    @CSBDDStepDef('I get premisis for edit navigation from database')
    async getPremisisForEditNavigationFromDatabase(): Promise<void> {
        CSReporter.info('Getting premisis for edit navigation from database');

        const premisisDetails = await TTTFDatabaseHelper.getPremisisForEditNavigation();
        if (!premisisDetails) {
            throw new Error('No premisis available for edit navigation in database');
        }

        this.scenarioContext.setVariable('zealId', premisisDetails.zealId);
        this.scenarioContext.setVariable('zealKey', premisisDetails.zealKey);
        this.scenarioContext.setVariable('zealName', premisisDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', premisisDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', premisisDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', premisisDetails.zzztSeggregation);
        this.scenarioContext.setVariable('zzztId', premisisDetails.zzztId);

        CSReporter.pass(`Retrieved premisis for edit navigation: ID=${premisisDetails.zealId}, ZzztAbbrev=${premisisDetails.zzztSeggregation}`);
    }

    @CSBDDStepDef('I uncheck Include Premisis in results checkbox')
    async uncheckIncludePremisisInResultsCheckbox(): Promise<void> {
        await this.zealPremisisPage.uncheckIncludePremisisCheckbox();
    }

    @CSBDDStepDef('Search results should show type {string}')
    async verifySearchResultsType(expectedType: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(expectedType, this.context);
        const actualType = await this.zealPremisisPage.getSearchResultTypeValue(1);

        if (actualType === resolvedType) {
            CSReporter.pass(`Search results show correct type: ${actualType}`);
        } else {
            throw new Error(`Expected type "${resolvedType}", got "${actualType}"`);
        }
    }

    @CSBDDStepDef('Search results should show stored zeal ID')
    async verifySearchResultsShowStoredZealId(): Promise<void> {
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealPremisisPage.getSearchResultZealIdValue(1);

        if (actualZealId === expectedZealId) {
            CSReporter.pass(`Search results show correct zeal ID: ${actualZealId}`);
        } else {
            throw new Error(`Expected zeal ID "${expectedZealId}", got "${actualZealId}"`);
        }
    }

    @CSBDDStepDef('Search results should show stored zeal key')
    async verifySearchResultsShowStoredZealKey(): Promise<void> {
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealPremisisPage.getSearchResultZealKeyValue(1);

        if (actualZealKey === expectedZealKey) {
            CSReporter.pass(`Search results show correct zeal key: ${actualZealKey}`);
        } else {
            throw new Error(`Expected zeal key "${expectedZealKey}", got "${actualZealKey}"`);
        }
    }

    @CSBDDStepDef('I click Cancel button')
    async clickCancelButton(): Promise<void> {
        await this.zealDetailsPage.clickCancelButton();
    }

    @CSBDDStepDef('Warning popup should be displayed')
    async verifyWarningPopupDisplayed(): Promise<void> {
        await this.zealDetailsPage.verifyWarningPopupDisplayed();
    }

    @CSBDDStepDef('Warning popup should show unsaved changes message')
    async verifyWarningPopupUnsavedChangesMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getWarningPopupMessage();
        if (messageText.includes('changes are not saved') || messageText.includes('save before')) {
            CSReporter.pass(`Warning popup shows unsaved changes message: ${messageText}`);
        } else {
            throw new Error(`Expected unsaved changes warning, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('OK button should be visible in warning popup')
    async verifyOkButtonVisibleInWarningPopup(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isWarningPopupOkButtonVisible();
        if (isVisible) {
            CSReporter.pass('OK button is visible in warning popup');
        } else {
            throw new Error('OK button is not visible in warning popup');
        }
    }

    @CSBDDStepDef('I click OK button in warning popup')
    async clickOkButtonInWarningPopup(): Promise<void> {
        await this.zealDetailsPage.clickWarningPopupOkButton();
    }

    @CSBDDStepDef('I click Edit link in Action column for row {int}')
    async clickEditLinkInActionColumn(rowIndex: number): Promise<void> {
        await this.zealPremisisPage.clickEditLinkInActionColumn(rowIndex);
    }

    @CSBDDStepDef('I should see Edit Zeal page directly')
    async verifyEditZealPageDirectly(): Promise<void> {
        await this.zealDetailsPage.verifyEditZealPageDisplayed();
        CSReporter.pass('Navigated directly to Edit Zeal page via Action column');
    }

    @CSBDDStepDef('I should see Edit Premisis page directly')
    async verifyEditPremisisPageDirectly(): Promise<void> {
        await this.zealDetailsPage.verifyEditPremisisPageDisplayed();
        CSReporter.pass('Navigated directly to Edit Premisis page via Action column');
    }

    // ===================================================================
    // EXISTING ZEAL UPDATE STEPS (SCENARIO_09B)
    // ===================================================================

    @CSBDDStepDef('I get existing zeal with scattered mmtes from database')
    async getExistingZealWithScatteredMmtes(): Promise<void> {
        CSReporter.info('Getting existing zeal with scattered mmtes from database');

        const zealDetails = await TTTFDatabaseHelper.getExistingZealWithScatteredMmtes();
        if (!zealDetails) {
            throw new Error('No existing zeal with scattered mmtes found in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);
        this.scenarioContext.setVariable('sketchmarkFlag', zealDetails.sketchmarkFlag);
        this.scenarioContext.setVariable('inductorCode', zealDetails.inductorCode);
        this.scenarioContext.setVariable('existingScatteredMmtes', zealDetails.scatteredMmtes);

        CSReporter.pass(`Retrieved existing zeal: ID=${zealDetails.zealId}, Mmtes=${zealDetails.scatteredMmtes?.length || 0}`);
    }

    @CSBDDStepDef('I get replacement scattered mmtes from database')
    async getReplacementScatteredMmtes(): Promise<void> {
        CSReporter.info('Getting replacement scattered mmtes from database');

        const existingMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];
        const existingMmteNames = existingMmtes.map((r: any) => r.scatteredMmteName);

        const replacementMmtes = await TTTFDatabaseHelper.getReplacementScatteredMmtes(existingMmteNames);
        if (!replacementMmtes || replacementMmtes.length === 0) {
            throw new Error('No replacement scattered mmtes found in database');
        }

        this.scenarioContext.setVariable('replacementScatteredMmtes', replacementMmtes);
        CSReporter.pass(`Retrieved ${replacementMmtes.length} replacement scattered mmtes`);
    }

    @CSBDDStepDef('I verify existing scattered mmtes match database')
    async verifyExistingScatteredMmtesMatchDatabase(): Promise<void> {
        const expectedMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];
        const actualCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (actualCount === expectedMmtes.length) {
            CSReporter.pass(`Existing scattered mmtes match database: ${actualCount} mmtes`);
        } else {
            throw new Error(`Expected ${expectedMmtes.length} scattered mmtes, found ${actualCount}`);
        }
    }

    @CSBDDStepDef('I toggle Use Sketchmark Replacement checkbox')
    async toggleUseSketchmarkReplacementCheckbox(): Promise<void> {
        const currentFlag = this.scenarioContext.getVariable('sketchmarkFlag');
        if (currentFlag === 'Y') {
            await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
        } else {
            await this.zealDetailsPage.checkUseSketchmarkReplacement();
        }
        CSReporter.pass('Toggled Use Sketchmark Replacement checkbox');
    }

    @CSBDDStepDef('I update FFX Inductor Type to different value')
    async updateFfxInductorTypeToDifferentValue(): Promise<void> {
        const currentInductorCode = this.scenarioContext.getVariable('inductorCode');
        const newInductorType = await TTTFDatabaseHelper.getDifferentFfxInductorType(currentInductorCode);

        if (newInductorType) {
            await this.zealDetailsPage.checkOutputTtcalcFile();
            await this.zealDetailsPage.selectFfxInductorType(newInductorType);
            this.scenarioContext.setVariable('newInductorCode', newInductorType);
            CSReporter.pass(`Updated FFX Inductor Type to: ${newInductorType}`);
        } else {
            CSReporter.info('No different FFX Inductor Type available, skipping update');
        }
    }

    @CSBDDStepDef('I unselect existing scattered mmtes in modal')
    async unselectExistingScatteredMmtesInModal(): Promise<void> {
        const existingMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];

        for (const mmte of existingMmtes) {
            await this.scatteredMmtesModalPage.searchScatteredMmte(mmte.scatteredMmteName);
            await this.scatteredMmtesModalPage.unselectScatteredMmte(mmte.scatteredMmteName);
        }

        CSReporter.pass(`Unselected ${existingMmtes.length} existing scattered mmtes`);
    }

    @CSBDDStepDef('I select replacement scattered mmtes in modal')
    async selectReplacementScatteredMmtesInModal(): Promise<void> {
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];

        for (const mmte of replacementMmtes) {
            await this.scatteredMmtesModalPage.searchScatteredMmte(mmte.scatteredMmteName);
            await this.scatteredMmtesModalPage.selectScatteredMmte(mmte.scatteredMmteName);
        }

        CSReporter.pass(`Selected ${replacementMmtes.length} replacement scattered mmtes`);
    }

    @CSBDDStepDef('Updated scattered mmtes should be displayed in Associated Scattered Mmtes section')
    async verifyUpdatedScatteredMmtesDisplayed(): Promise<void> {
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];
        const actualCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (actualCount === replacementMmtes.length) {
            CSReporter.pass(`Updated scattered mmtes displayed: ${actualCount} mmtes`);
        } else {
            throw new Error(`Expected ${replacementMmtes.length} scattered mmtes, found ${actualCount}`);
        }
    }

    @CSBDDStepDef('Changes table should show update changes')
    async verifyChangesTableShowsUpdateChanges(): Promise<void> {
        const changesData = await this.changesHistoryPage.getAllChangesData();

        if (changesData.length > 0) {
            CSReporter.pass(`Changes table shows ${changesData.length} update changes`);
        } else {
            throw new Error('Changes table should show update changes');
        }
    }

    @CSBDDStepDef('Approve Email modal should be visible')
    async verifyApproveEmailModalVisible(): Promise<void> {
        await this.changesHistoryPage.verifyApproveEmailModalDisplayed();
    }

    @CSBDDStepDef('I click Send button in Approve modal')
    async clickSendButtonInApproveModal(): Promise<void> {
        await this.changesHistoryPage.clickSendButtonInApproveModal();
    }

    @CSBDDStepDef('Approval email sent message should be displayed')
    async verifyApprovalEmailSentMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Approval') && messageText.includes('sent')) {
            CSReporter.pass(`Approval email sent message: ${messageText}`);
        } else {
            throw new Error(`Expected approval email sent message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I verify updated scattered mmtes in database')
    async verifyUpdatedScatteredMmtesInDatabase(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];

        if (mmteData.length === replacementMmtes.length) {
            CSReporter.pass(`Updated scattered mmtes verified in database: ${mmteData.length} mmtes`);
        } else {
            throw new Error(`Expected ${replacementMmtes.length} mmtes in database, found ${mmteData.length}`);
        }
    }
}

export default TTTFNewZealSteps;

-----------------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Changes and History Tab Page
 * Source: SCENARIO_03_NewZeal_Approval.txt - Section 3.12, 3.13
 * Handles Changes tab and History tab content
 */
@CSPage('tttf-changes-history')
export class TTTFChangesHistoryPage extends CSBasePage {

    // ===================================================================
    // CHANGES TAB ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Changes"]',
        description: 'Changes section header',
        waitForVisible: true
    })
    public changesHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']",
        description: 'Changes table',
        waitForVisible: true
    })
    public changesTable!: CSWebElement;

    @CSGetElement({
        xpath: "//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody//td[text()='No data available.']",
        description: 'Changes no data message',
        waitForVisible: true
    })
    public changesNoDataMessage!: CSWebElement;

    @CSGetElement({
        xpath: "//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//span[text()='Cancel Changes']/parent::button",
        description: 'Cancel Changes button',
        waitForEnabled: true
    })
    public cancelChangesButton!: CSWebElement;

    @CSGetElement({
        xpath: "//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//span[text()='Approve']/parent::button",
        description: 'Approve button',
        waitForEnabled: true
    })
    public approveButton!: CSWebElement;

    @CSGetElement({
        xpath: "//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//span[text()='Reject']/parent::button",
        description: 'Reject button',
        waitForEnabled: true
    })
    public rejectButton!: CSWebElement;

    // ===================================================================
    // HISTORY TAB ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="History"]',
        description: 'History section header',
        waitForVisible: true
    })
    public historyHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']",
        description: 'History table',
        waitForVisible: true
    })
    public historyTable!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-paginator__nav-buttons-container']//span[text()='Previous Panel']/ancestor::button[1]",
        description: 'History Previous button',
        waitForEnabled: true
    })
    public historyPreviousButton!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-paginator__nav-buttons-container']//span[text()='Next Panel']/ancestor::button[1]",
        description: 'History Next button',
        waitForEnabled: true
    })
    public historyNextButton!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFChangesHistoryPage elements initialized');
    }

    // ===================================================================
    // CHANGES TAB METHODS
    // ===================================================================

    public async verifyChangesHeaderDisplayed(): Promise<void> {
        await this.changesHeader.waitForVisible(10000);
        const isVisible = await this.changesHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Changes header is displayed');
        } else {
            throw new Error('Changes header not found');
        }
    }

    /**
     * Verify Changes table column headers
     * Source: Requirement Doc Circles 848-852
     * Columns: Description, Old Value, New Value, Modified By, Date Submitted
     */
    public async verifyChangesTableColumnHeaders(): Promise<void> {
        CSReporter.info('Verifying Changes table column headers');

        const expectedColumns = ['Description', 'Old Value', 'New Value', 'Modified By', 'Date Submitted'];
        const missingColumns: string[] = [];

        for (const columnName of expectedColumns) {
            const columnHeader = CSElementFactory.createByXPath(
                `//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//thead//th[text()='${columnName}']`,
                `Changes table column: ${columnName}`,
                this.page
            );

            if (!(await columnHeader.isVisibleWithTimeout(3000))) {
                missingColumns.push(columnName);
            } else {
                CSReporter.info(`Column verified: ${columnName}`);
            }
        }

        if (missingColumns.length > 0) {
            throw new Error(`Missing Changes table columns: ${missingColumns.join(', ')}`);
        }

        CSReporter.pass('All Changes table column headers verified');
    }

    public async isChangesNoDataVisible(): Promise<boolean> {
        return await this.changesNoDataMessage.isVisibleWithTimeout(3000);
    }

    public async getChangesRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr`,
            'Changes table rows',
            this.page
        );
        return await rows.count();
    }

    public async getChangesRowData(rowIndex: number): Promise<{
        description: string;
        oldValue: string;
        newValue: string;
        modifiedBy: string;
        dateSubmitted: string;
    }> {
        const descriptionElement = CSElementFactory.createByXPath(
            `//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[1]`,
            `Changes row ${rowIndex} description`,
            this.page
        );
        const description = (await descriptionElement.textContentWithTimeout(5000))?.trim() || '';

        const oldValueElement = CSElementFactory.createByXPath(
            `//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[2]`,
            `Changes row ${rowIndex} old value`,
            this.page
        );
        const oldValue = (await oldValueElement.textContentWithTimeout(5000))?.trim() || '';

        const newValueElement = CSElementFactory.createByXPath(
            `//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[3]`,
            `Changes row ${rowIndex} new value`,
            this.page
        );
        const newValue = (await newValueElement.textContentWithTimeout(5000))?.trim() || '';

        const modifiedByElement = CSElementFactory.createByXPath(
            `//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[4]//a/following-sibling::div[1]`,
            `Changes row ${rowIndex} modified by`,
            this.page
        );
        const modifiedBy = (await modifiedByElement.textContentWithTimeout(5000))?.trim() || '';

        const dateSubmittedElement = CSElementFactory.createByXPath(
            `//h2[text()='Changes']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[5]`,
            `Changes row ${rowIndex} date submitted`,
            this.page
        );
        const dateSubmitted = (await dateSubmittedElement.textContentWithTimeout(5000))?.trim() || '';

        return {
            description,
            oldValue,
            newValue,
            modifiedBy,
            dateSubmitted
        };
    }

    public async getAllChangesData(): Promise<Array<{
        description: string;
        oldValue: string;
        newValue: string;
        modifiedBy: string;
        dateSubmitted: string;
    }>> {
        const rowCount = await this.getChangesRowCount();
        const results = [];

        for (let i = 1; i <= rowCount; i++) {
            const rowData = await this.getChangesRowData(i);
            results.push(rowData);
        }

        return results;
    }

    public async isCancelChangesButtonVisible(): Promise<boolean> {
        return await this.cancelChangesButton.isVisibleWithTimeout(5000);
    }

    public async clickCancelChangesButton(): Promise<void> {
        await this.cancelChangesButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel Changes button');
    }

    public async isApproveButtonVisible(): Promise<boolean> {
        return await this.approveButton.isVisibleWithTimeout(5000);
    }

    public async clickApproveButton(): Promise<void> {
        await this.approveButton.waitForVisible(10000);
        await this.approveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Approve button');
        await this.waitForPageLoad();
    }

    public async isRejectButtonVisible(): Promise<boolean> {
        return await this.rejectButton.isVisibleWithTimeout(5000);
    }

    public async clickRejectButton(): Promise<void> {
        await this.rejectButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Reject button');
    }

    // ===================================================================
    // HISTORY TAB METHODS
    // ===================================================================

    public async verifyHistoryHeaderDisplayed(): Promise<void> {
        await this.historyHeader.waitForVisible(10000);
        const isVisible = await this.historyHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('History header is displayed');
        } else {
            throw new Error('History header not found');
        }
    }

    /**
     * Verify History table column headers
     * Columns: Description, Old Value, New Value, Modified By, Approved By, Date Updated
     */
    public async verifyHistoryTableColumnHeaders(): Promise<void> {
        CSReporter.info('Verifying History table column headers');

        const expectedColumns = ['Description', 'Old Value', 'New Value', 'Modified By', 'Approved By', 'Date Updated'];
        const missingColumns: string[] = [];

        for (const columnName of expectedColumns) {
            const columnHeader = CSElementFactory.createByXPath(
                `//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//thead//th[text()='${columnName}']`,
                `History table column: ${columnName}`,
                this.page
            );

            if (!(await columnHeader.isVisibleWithTimeout(3000))) {
                missingColumns.push(columnName);
            } else {
                CSReporter.info(`Column verified: ${columnName}`);
            }
        }

        if (missingColumns.length > 0) {
            throw new Error(`Missing History table columns: ${missingColumns.join(', ')}`);
        }

        CSReporter.pass('All History table column headers verified');
    }

    public async getHistoryRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr`,
            'History table rows',
            this.page
        );
        return await rows.count();
    }

    public async getHistoryRowData(rowIndex: number): Promise<{
        description: string;
        oldValue: string;
        newValue: string;
        modifiedBy: string;
        approvedBy: string;
        dateUpdated: string;
    }> {
        const descriptionElement = CSElementFactory.createByXPath(
            `//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[1]`,
            `History row ${rowIndex} description`,
            this.page
        );
        const description = (await descriptionElement.textContentWithTimeout(5000))?.trim() || '';

        const oldValueElement = CSElementFactory.createByXPath(
            `//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[2]`,
            `History row ${rowIndex} old value`,
            this.page
        );
        const oldValue = (await oldValueElement.textContentWithTimeout(5000))?.trim() || '';

        const newValueElement = CSElementFactory.createByXPath(
            `//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[3]`,
            `History row ${rowIndex} new value`,
            this.page
        );
        const newValue = (await newValueElement.textContentWithTimeout(5000))?.trim() || '';

        const modifiedByElement = CSElementFactory.createByXPath(
            `//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[4]//a/following-sibling::div[1]`,
            `History row ${rowIndex} modified by`,
            this.page
        );
        let modifiedBy = '';
        if (await modifiedByElement.isVisibleWithTimeout(2000)) {
            modifiedBy = (await modifiedByElement.textContentWithTimeout(5000))?.trim() || '';
        }

        const approvedByElement = CSElementFactory.createByXPath(
            `//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[5]//a/following-sibling::div[1]`,
            `History row ${rowIndex} approved by`,
            this.page
        );
        const approvedBy = (await approvedByElement.textContentWithTimeout(5000))?.trim() || '';

        const dateUpdatedElement = CSElementFactory.createByXPath(
            `//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody/tr[${rowIndex}]/td[6]`,
            `History row ${rowIndex} date updated`,
            this.page
        );
        const dateUpdated = (await dateUpdatedElement.textContentWithTimeout(5000))?.trim() || '';

        return {
            description,
            oldValue,
            newValue,
            modifiedBy,
            approvedBy,
            dateUpdated
        };
    }

    public async getAllHistoryData(): Promise<Array<{
        description: string;
        oldValue: string;
        newValue: string;
        modifiedBy: string;
        approvedBy: string;
        dateUpdated: string;
    }>> {
        const rowCount = await this.getHistoryRowCount();
        const results = [];

        for (let i = 1; i <= rowCount; i++) {
            const rowData = await this.getHistoryRowData(i);
            results.push(rowData);
        }

        return results;
    }

    public async clickHistoryPreviousButton(): Promise<void> {
        await this.historyPreviousButton.clickWithTimeout(10000);
        CSReporter.info('Clicked History Previous button');
    }

    public async clickHistoryNextButton(): Promise<void> {
        await this.historyNextButton.clickWithTimeout(10000);
        CSReporter.info('Clicked History Next button');
    }

    public async isHistoryPreviousButtonEnabled(): Promise<boolean> {
        return await this.historyPreviousButton.isEnabledWithTimeout(5000);
    }

    public async isHistoryNextButtonEnabled(): Promise<boolean> {
        return await this.historyNextButton.isEnabledWithTimeout(5000);
    }

    public async isHistoryNoDataVisible(): Promise<boolean> {
        const noDataMessage = CSElementFactory.createByXPath(
            `//h2[text()='History']/ancestor::div[@role='tabpanel'][1]//table[@class='sssss-table']//tbody//td[text()='No data available.']`,
            'History no data message',
            this.page
        );
        return await noDataMessage.isVisibleWithTimeout(3000);
    }

    // ===================================================================
    // REJECT EMAIL MODAL METHODS
    // ===================================================================

    public async verifyRejectEmailModalDisplayed(): Promise<void> {
        const modalHeader = CSElementFactory.createByXPath(
            "//div[@class='sssss-modal__wrapper']//h2[text()='Review Reject Email']",
            'Review Reject Email modal header',
            this.page
        );
        await modalHeader.waitForVisible(10000);
        const isVisible = await modalHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Review Reject Email modal is displayed');
        } else {
            throw new Error('Review Reject Email modal not found');
        }
    }

    public async isRejectCommentTextareaVisible(): Promise<boolean> {
        const textarea = CSElementFactory.createByXPath(
            "//div[@class='sssss-modal__wrapper']//textarea",
            'Reject comment textarea',
            this.page
        );
        return await textarea.isVisibleWithTimeout(5000);
    }

    public async enterRejectComment(comment: string): Promise<void> {
        const textarea = CSElementFactory.createByXPath(
            "//div[@class='sssss-modal__wrapper']//textarea",
            'Reject comment textarea',
            this.page
        );
        await textarea.waitForVisible(10000);
        await textarea.fillWithTimeout(comment, 5000);
        CSReporter.pass(`Entered reject comment: ${comment}`);
    }

    public async isSendButtonVisible(): Promise<boolean> {
        const sendButton = CSElementFactory.createByXPath(
            "//div[@class='sssss-modal__wrapper']//span[text()='Send']/parent::button",
            'Send button in Reject modal',
            this.page
        );
        return await sendButton.isVisibleWithTimeout(5000);
    }

    public async clickSendButton(): Promise<void> {
        const sendButton = CSElementFactory.createByXPath(
            "//div[@class='sssss-modal__wrapper']//span[text()='Send']/parent::button",
            'Send button in Reject modal',
            this.page
        );
        await sendButton.waitForVisible(10000);
        await sendButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Send button in Reject modal');
        await this.waitForPageLoad();
    }

    public async clickCancelButtonInRejectModal(): Promise<void> {
        const cancelButton = CSElementFactory.createByXPath(
            "//div[@class='sssss-modal__wrapper']//span[text()='Cancel']/parent::button",
            'Cancel button in Reject modal',
            this.page
        );
        await cancelButton.waitForVisible(10000);
        await cancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button in Reject modal');
    }

    // ===================================================================
    // APPROVE EMAIL MODAL METHODS
    // ===================================================================

    public async verifyApproveEmailModalDisplayed(): Promise<void> {
        const modalHeader = CSElementFactory.createByXPath(
            "//div[@class='sssss-modal__wrapper']//h2[text()='Review Approval Email']",
            'Review Approval Email modal header',
            this.page
        );
        await modalHeader.waitForVisible(10000);
        const isVisible = await modalHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Review Approval Email modal is displayed');
        } else {
            throw new Error('Review Approval Email modal not found');
        }
    }

    public async clickSendButtonInApproveModal(): Promise<void> {
        const sendButton = CSElementFactory.createByXPath(
            "//div[@class='sssss-modal__wrapper']//span[text()='Send']/parent::button",
            'Send button in Approve modal',
            this.page
        );
        await sendButton.waitForVisible(10000);
        await sendButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Send button in Approve modal');
        await this.waitForPageLoad();
    }
}

export default TTTFChangesHistoryPage;


-------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Zeal Details Page
 * Source: SCENARIO_03_NewZeal_Approval.txt
 * Handles Zeal Details view/edit mode, Settings, Associated Scattered Mmtes
 */
@CSPage('tttf-zeal-details')
export class TTTFZealDetailsPage extends CSBasePage {

    // ===================================================================
    // PAGE HEADER ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h1[text()="Zeal Details"]',
        description: 'Zeal Details page header',
        waitForVisible: true,
        alternativeLocators: ['text:Zeal Details']
    })
    public zealDetailsHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//h1[text()="Edit Zeal"]',
        description: 'Edit Zeal page header (edit mode)',
        waitForVisible: true,
        alternativeLocators: ['text:Edit Zeal']
    })
    public editZealHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and text()='Edit']/parent::button",
        description: 'Edit button',
        waitForEnabled: true
    })
    public editButton!: CSWebElement;

    // ===================================================================
    // TAB ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and text()='Details']/parent::button",
        description: 'Details tab button',
        waitForVisible: true
    })
    public detailsTab!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and contains(text(),'Changes:')]/parent::button",
        description: 'Changes tab button',
        waitForVisible: true
    })
    public changesTab!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and text()='History']/parent::button",
        description: 'History tab button',
        waitForVisible: true
    })
    public historyTab!: CSWebElement;

    // ===================================================================
    // SUMMARY SECTION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Summary"]',
        description: 'Summary section header',
        waitForVisible: true
    })
    public summaryHeader!: CSWebElement;

    // ===================================================================
    // SETTINGS SECTION ELEMENTS (VIEW MODE)
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Settings"]',
        description: 'Settings section header',
        waitForVisible: true
    })
    public settingsHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//strong[text()='Use Sketchmark Replacement']/parent::div/following-sibling::div[1]",
        description: 'Use Sketchmark Replacement value (view mode)',
        waitForVisible: true
    })
    public useSketchmarkReplacementValue!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//strong[text()='Output Ttcalc File']/ancestor::div[@class='flex'][1]/following-sibling::div[1]",
        description: 'Output Ttcalc File value (view mode)',
        waitForVisible: true
    })
    public outputTtcalcFileValue!: CSWebElement;

    // ===================================================================
    // SETTINGS SECTION ELEMENTS (EDIT MODE)
    // ===================================================================

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@role='checkbox' and @aria-label='Use Sketchmark Replacement']",
        description: 'Use Sketchmark Replacement checkbox (edit mode)',
        waitForVisible: true
    })
    public useSketchmarkReplacementCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@role='checkbox' and @aria-label='Output Ttcalc File']",
        description: 'Output Ttcalc File checkbox (edit mode)',
        waitForVisible: true
    })
    public outputTtcalcFileCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: "//button[@name='inductorType']",
        description: 'FFX File Inductor Type dropdown button',
        waitForEnabled: true
    })
    public ffxInductorTypeDropdown!: CSWebElement;

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES SECTION
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Associated Scattered Mmtes"]',
        description: 'Associated Scattered Mmtes section header',
        waitForVisible: true
    })
    public associatedScatteredMmtesHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[text()="No Scattered Mmte Associations Found."]',
        description: 'No Scattered Mmtes message',
        waitForVisible: true
    })
    public noScatteredMmtesMessage!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@class='sssss-button__label' and text()='Add / Remove']/parent::button",
        description: 'Add / Remove button',
        waitForEnabled: true
    })
    public addRemoveButton!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@class='sssss-button__label' and text()='Reorder']/parent::button",
        description: 'Reorder button',
        waitForEnabled: true
    })
    public reorderButton!: CSWebElement;

    // ===================================================================
    // ACTION BUTTONS
    // ===================================================================

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//div[@class='button-bar-container']//span[text()='Save']/parent::button",
        description: 'Save button',
        waitForEnabled: true
    })
    public saveButton!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//div[@class='button-bar-container']//span[text()='Cancel']/parent::button",
        description: 'Cancel button',
        waitForEnabled: true
    })
    public cancelButton!: CSWebElement;

    // ===================================================================
    // MESSAGE ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//div[contains(@class, 'sssss-message-bar__messages')]",
        description: 'Message bar (success/error messages)',
        waitForVisible: true
    })
    public messageBar!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-feedback__messages']//li",
        description: 'Feedback message (pending approval alert)',
        waitForVisible: true
    })
    public feedbackMessage!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-feedback__messages']//li//span[text()='View Changes']/parent::button",
        description: 'View Changes link in feedback',
        waitForVisible: true
    })
    public viewChangesLink!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFZealDetailsPage elements initialized');
    }

    // ===================================================================
    // PAGE VERIFICATION METHODS
    // ===================================================================

    public async verifyZealDetailsPageDisplayed(): Promise<void> {
        await this.zealDetailsHeader.waitForVisible(15000);
        const isVisible = await this.zealDetailsHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Zeal Details page is displayed');
        } else {
            throw new Error('Zeal Details page header not found');
        }
    }

    public async verifyEditZealPageDisplayed(): Promise<void> {
        await this.editZealHeader.waitForVisible(15000);
        const isVisible = await this.editZealHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Edit Zeal page is displayed');
        } else {
            throw new Error('Edit Zeal page header not found');
        }
    }

    public async isEditButtonEnabled(): Promise<boolean> {
        return await this.editButton.isEnabledWithTimeout(5000);
    }

    public async clickEditButton(): Promise<void> {
        await this.editButton.waitForVisible(10000);
        await this.editButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Edit button');
    }

    // ===================================================================
    // TAB METHODS
    // ===================================================================

    public async isDetailsTabSelected(): Promise<boolean> {
        const ariaSelected = await this.detailsTab.getAttributeWithTimeout('aria-selected', 5000);
        return ariaSelected === 'true';
    }

    public async isChangesTabSelected(): Promise<boolean> {
        const ariaSelected = await this.changesTab.getAttributeWithTimeout('aria-selected', 5000);
        return ariaSelected === 'true';
    }

    public async isHistoryTabSelected(): Promise<boolean> {
        const ariaSelected = await this.historyTab.getAttributeWithTimeout('aria-selected', 5000);
        return ariaSelected === 'true';
    }

    public async clickDetailsTab(): Promise<void> {
        await this.detailsTab.clickWithTimeout(10000);
        CSReporter.info('Clicked Details tab');
    }

    public async clickChangesTab(): Promise<void> {
        await this.changesTab.clickWithTimeout(10000);
        CSReporter.info('Clicked Changes tab');
    }

    public async clickHistoryTab(): Promise<void> {
        await this.historyTab.clickWithTimeout(10000);
        CSReporter.info('Clicked History tab');
    }

    public async isChangesTabPresent(): Promise<boolean> {
        return await this.changesTab.isVisibleWithTimeout(5000);
    }

    public async isHistoryTabPresent(): Promise<boolean> {
        return await this.historyTab.isVisibleWithTimeout(5000);
    }

    public async isReorderButtonVisible(): Promise<boolean> {
        const reorderButton = CSElementFactory.createByXPath(
            "//form[@class='sssss-form']//span[@class='sssss-button__label' and text()='Reorder']/parent::button",
            'Reorder button',
            this.page
        );
        return await reorderButton.isVisibleWithTimeout(5000);
    }

    // ===================================================================
    // SUMMARY FIELD METHODS
    // ===================================================================

    public async getSummaryFieldValue(fieldName: string): Promise<string> {
        const fieldElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${fieldName}']/following-sibling::div`,
            `Summary field: ${fieldName}`,
            this.page
        );
        const value = await fieldElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getAdministratorValue(): Promise<string> {
        const adminElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='Administrator']/following-sibling::div/span[@class='sssss-button__label']`,
            'Administrator field value',
            this.page
        );
        const value = await adminElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getZealId(): Promise<string> {
        return await this.getSummaryFieldValue('Zeal ID');
    }

    public async getZealKey(): Promise<string> {
        return await this.getSummaryFieldValue('Zeal Key');
    }

    public async getZealName(): Promise<string> {
        return await this.getSummaryFieldValue('Zeal Name');
    }

    public async getZzztSeggregation(): Promise<string> {
        return await this.getSummaryFieldValue('Zzzt Seggregation');
    }

    public async getPremisisDescription(): Promise<string> {
        return await this.getSummaryFieldValue('Premisis Description');
    }

    public async getInductorGroup(): Promise<string> {
        return await this.getSummaryFieldValue('Inductor Group');
    }

    public async getKindnessCircle(): Promise<string> {
        return await this.getSummaryFieldValue('Kindness Circle');
    }

    public async getTtcalcShool(): Promise<string> {
        return await this.getSummaryFieldValue('Ttcalc Shool');
    }

    // ===================================================================
    // SETTINGS METHODS (VIEW MODE)
    // ===================================================================

    public async getUseSketchmarkReplacementValue(): Promise<string> {
        const value = await this.useSketchmarkReplacementValue.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getOutputTtcalcFileValue(): Promise<string> {
        const value = await this.outputTtcalcFileValue.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    // ===================================================================
    // SETTINGS METHODS (EDIT MODE)
    // ===================================================================

    public async isUseSketchmarkReplacementChecked(): Promise<boolean> {
        const ariaChecked = await this.useSketchmarkReplacementCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        return ariaChecked === 'true';
    }

    public async isUseSketchmarkReplacementEnabled(): Promise<boolean> {
        const ariaDisabled = await this.useSketchmarkReplacementCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'false';
    }

    public async checkUseSketchmarkReplacement(): Promise<void> {
        const isChecked = await this.isUseSketchmarkReplacementChecked();
        if (!isChecked) {
            await this.useSketchmarkReplacementCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Checked Use Sketchmark Replacement checkbox');
        } else {
            CSReporter.info('Use Sketchmark Replacement already checked');
        }
    }

    public async uncheckUseSketchmarkReplacement(): Promise<void> {
        const isChecked = await this.isUseSketchmarkReplacementChecked();
        if (isChecked) {
            await this.useSketchmarkReplacementCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Unchecked Use Sketchmark Replacement checkbox');
        } else {
            CSReporter.info('Use Sketchmark Replacement already unchecked');
        }
    }

    public async isOutputTtcalcFileChecked(): Promise<boolean> {
        const ariaChecked = await this.outputTtcalcFileCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        return ariaChecked === 'true';
    }

    public async isOutputTtcalcFileEnabled(): Promise<boolean> {
        const ariaDisabled = await this.outputTtcalcFileCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'false';
    }

    public async checkOutputTtcalcFile(): Promise<void> {
        const isChecked = await this.isOutputTtcalcFileChecked();
        if (!isChecked) {
            await this.outputTtcalcFileCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Checked Output Ttcalc File checkbox');
        } else {
            CSReporter.info('Output Ttcalc File already checked');
        }
    }

    public async uncheckOutputTtcalcFile(): Promise<void> {
        const isChecked = await this.isOutputTtcalcFileChecked();
        if (isChecked) {
            await this.outputTtcalcFileCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Unchecked Output Ttcalc File checkbox');
        } else {
            CSReporter.info('Output Ttcalc File already unchecked');
        }
    }

    // ===================================================================
    // FFX INDUCTOR TYPE DROPDOWN METHODS
    // ===================================================================

    public async isFfxInductorTypeDropdownEnabled(): Promise<boolean> {
        return await this.ffxInductorTypeDropdown.isEnabledWithTimeout(5000);
    }

    public async clickFfxInductorTypeDropdown(): Promise<void> {
        await this.ffxInductorTypeDropdown.waitForVisible(10000);
        await this.ffxInductorTypeDropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked FFX Inductor Type dropdown');
    }

    public async selectFfxInductorType(inductorType: string): Promise<void> {
        await this.clickFfxInductorTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']`,
            'FFX Inductor Type listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const option = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']//li[@role='option']//span[text()='${inductorType}']/ancestor::li[@role='option'][1]`,
            `FFX Inductor Type option: ${inductorType}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected FFX Inductor Type: ${inductorType}`);
    }

    public async getSelectedFfxInductorType(): Promise<string> {
        const labelElement = CSElementFactory.createByXPath(
            `//button[@name='inductorType']//span[@class='sssss-button__label']`,
            'Selected FFX Inductor Type',
            this.page
        );
        const value = await labelElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getFfxInductorTypeOptions(): Promise<string[]> {
        await this.clickFfxInductorTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']`,
            'FFX Inductor Type listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const optionsElement = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']//li[@role='option']//span`,
            'FFX Inductor Type options',
            this.page
        );
        const options = await optionsElement.allTextContents();

        // Close dropdown by clicking header
        await this.settingsHeader.clickWithTimeout(2000);
        return options.map(opt => opt.trim()).filter(opt => opt.length > 0);
    }

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES METHODS
    // ===================================================================

    public async isNoScatteredMmtesMessageVisible(): Promise<boolean> {
        return await this.noScatteredMmtesMessage.isVisibleWithTimeout(3000);
    }

    public async clickAddRemoveButton(): Promise<void> {
        await this.addRemoveButton.waitForVisible(60000);
        await this.addRemoveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Add/Remove button');
    }

    public async isAddRemoveButtonVisible(): Promise<boolean> {
        return await this.addRemoveButton.isVisibleWithTimeout(60000);
    }

    public async clickReorderButton(): Promise<void> {
        await this.reorderButton.waitForVisible(10000);
        await this.reorderButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Reorder button');
    }

    /**
     * Verify Associated Scattered Mmtes table column headers
     * Source: Requirement Doc Circles 789-794
     * Columns: FFX Order, Scattered Mmte Name, Cumulative Mmte Name, Methodology Type, Disputed Scattered Mmte, Disputed Start Date
     */
    public async verifyAssociatedScatteredMmtesColumnHeaders(): Promise<void> {
        CSReporter.info('Verifying Associated Scattered Mmtes column headers');

        const expectedColumns = [
            'FFX Order',
            'Scattered Mmte Name',
            'Cumulative Mmte Name',
            'Methodology Type',
            'Disputed Scattered Mmte',
            'Disputed Start Date'
        ];
        const missingColumns: string[] = [];

        // Associated Scattered Mmtes section uses a different structure - check column presence
        for (const columnName of expectedColumns) {
            const columnHeader = CSElementFactory.createByXPath(
                `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][1]//div[contains(text(),'${columnName}')] | //form[@class='sssss-form']//h5[text()='Associated Scattered Mmtes']/following-sibling::div[1]//div[contains(@class,'sssss-col')]//span[text()='${columnName}']`,
                `Associated Scattered Mmtes column: ${columnName}`,
                this.page
            );

            if (!(await columnHeader.isVisibleWithTimeout(3000))) {
                missingColumns.push(columnName);
            } else {
                CSReporter.info(`Column verified: ${columnName}`);
            }
        }

        if (missingColumns.length > 0) {
            throw new Error(`Missing Associated Scattered Mmtes columns: ${missingColumns.join(', ')}`);
        }

        CSReporter.pass('All Associated Scattered Mmtes column headers verified');
    }

    public async getScatteredMmteRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')]`,
            'Scattered mmte rows',
            this.page
        );
        const count = await rows.count();
        // Subtract 1 for header row
        return Math.max(0, count - 1);
    }

    public async getScatteredMmteRowData(rowIndex: number): Promise<{
        ffxOrder: string;
        scatteredMmteName: string;
        cumulativeMmteName: string;
        methodologyType: string;
        disputedScatteredMmte: string;
        disputedStartDate: string;
    }> {
        const counter = rowIndex + 1; // 1-based for XPath

        const ffxOrderElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][1]`,
            `Row ${rowIndex} FFX Order`,
            this.page
        );
        const ffxOrder = (await ffxOrderElement.textContentWithTimeout(5000))?.trim() || '';

        const refMmteNameElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][2]//span[@class='sssss-button__label']`,
            `Row ${rowIndex} Scattered Mmte Name`,
            this.page
        );
        const scatteredMmteName = (await refMmteNameElement.textContentWithTimeout(5000))?.trim() || '';

        const extMmteNameElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][3]`,
            `Row ${rowIndex} Cumulative Mmte Name`,
            this.page
        );
        const cumulativeMmteName = (await extMmteNameElement.textContentWithTimeout(5000))?.trim() || '';

        const methodologyElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][4]`,
            `Row ${rowIndex} Methodology Type`,
            this.page
        );
        const methodologyType = (await methodologyElement.textContentWithTimeout(5000))?.trim() || '';

        const disputedRefMmteElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][5]//span[@class='sssss-button__label']`,
            `Row ${rowIndex} Disputed Scattered Mmte`,
            this.page
        );
        let disputedScatteredMmte = '';
        if (await disputedRefMmteElement.isVisibleWithTimeout(2000)) {
            disputedScatteredMmte = (await disputedRefMmteElement.textContentWithTimeout(5000))?.trim() || '';
        }

        const disputedDateElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class,'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][6]`,
            `Row ${rowIndex} Disputed Start Date`,
            this.page
        );
        const disputedStartDate = (await disputedDateElement.textContentWithTimeout(5000))?.trim() || '';

        return {
            ffxOrder,
            scatteredMmteName,
            cumulativeMmteName,
            methodologyType,
            disputedScatteredMmte,
            disputedStartDate
        };
    }

    public async clickDisputedSelectButton(rowIndex: number): Promise<void> {
        const counter = rowIndex + 1;
        const selectButton = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][5]//span[text()='Select']/parent::button`,
            `Row ${rowIndex} Disputed Select button`,
            this.page
        );
        await selectButton.waitForVisible(10000);
        await selectButton.clickWithTimeout(10000);
        CSReporter.info(`Clicked Disputed Select button for row ${rowIndex}`);
    }

    public async enterDisputedStartDate(rowIndex: number, date: string): Promise<void> {
        const counter = rowIndex + 1;
        const dateInput = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][6]//div[@class='sssss-field__content-button-wrapper']/input`,
            `Row ${rowIndex} Disputed Start Date input`,
            this.page
        );
        await dateInput.waitForVisible(10000);
        await dateInput.clearWithTimeout(5000);
        await dateInput.fillWithTimeout(date, 5000);
        CSReporter.pass(`Entered Disputed Start Date: ${date} for row ${rowIndex}`);
    }

    // ===================================================================
    // ACTION BUTTON METHODS
    // ===================================================================

    public async isSaveButtonEnabled(): Promise<boolean> {
        return await this.saveButton.isEnabledWithTimeout(5000);
    }

    public async clickSaveButton(): Promise<void> {
        await this.saveButton.waitForVisible(10000);
        await this.saveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Save button');
        await this.waitForPageLoad();
    }

    public async isCancelButtonEnabled(): Promise<boolean> {
        return await this.cancelButton.isEnabledWithTimeout(5000);
    }

    public async clickCancelButton(): Promise<void> {
        await this.cancelButton.waitForVisible(10000);
        await this.cancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button');
    }

    // ===================================================================
    // MESSAGE METHODS
    // ===================================================================

    public async getMessageBarText(): Promise<string> {
        await this.messageBar.waitForVisible(10000);
        const text = await this.messageBar.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async getFeedbackMessageText(): Promise<string> {
        await this.feedbackMessage.waitForVisible(10000);
        const text = await this.feedbackMessage.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async clickViewChangesLink(): Promise<void> {
        await this.viewChangesLink.waitForVisible(10000);
        await this.viewChangesLink.clickWithTimeout(10000);
        CSReporter.info('Clicked View Changes link');
    }

    public async isViewChangesLinkVisible(): Promise<boolean> {
        return await this.viewChangesLink.isVisibleWithTimeout(5000);
    }

    // ===================================================================
    // PREMISIS-SPECIFIC METHODS
    // ===================================================================

    public async verifyPremisisDetailsPageDisplayed(): Promise<void> {
        const premisisHeader = CSElementFactory.createByXPath(
            '//h1[text()="Premisis Details"]',
            'Premisis Details page header',
            this.page
        );
        await premisisHeader.waitForVisible(15000);
        const isVisible = await premisisHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Premisis Details page is displayed');
        } else {
            throw new Error('Premisis Details page header not found');
        }
    }

    public async verifyEditPremisisPageDisplayed(): Promise<void> {
        const editPremisisHeader = CSElementFactory.createByXPath(
            '//h1[text()="Edit Premisis"]',
            'Edit Premisis page header',
            this.page
        );
        await editPremisisHeader.waitForVisible(15000);
        const isVisible = await editPremisisHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Edit Premisis page is displayed');
        } else {
            throw new Error('Edit Premisis page header not found');
        }
    }

    public async isOutputTtcalcFileCheckboxDisabled(): Promise<boolean> {
        const ariaDisabled = await this.outputTtcalcFileCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'true';
    }

    public async isFfxInductorTypeDropdownDisabled(): Promise<boolean> {
        const isEnabled = await this.ffxInductorTypeDropdown.isEnabledWithTimeout(5000);
        return !isEnabled;
    }

    // ===================================================================
    // WARNING POPUP METHODS (SCENARIO_08)
    // ===================================================================

    public async verifyWarningPopupDisplayed(): Promise<void> {
        const warningHeader = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//h5[text()='Warning']",
            'Warning popup header',
            this.page
        );
        await warningHeader.waitForVisible(10000);
        const isVisible = await warningHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Warning popup is displayed');
        } else {
            throw new Error('Warning popup not found');
        }
    }

    public async getWarningPopupMessage(): Promise<string> {
        const messageElement = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//div[contains(@class,'sssss-message-box__text')]",
            'Warning popup message',
            this.page
        );
        const text = await messageElement.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async isWarningPopupOkButtonVisible(): Promise<boolean> {
        const okButton = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//div[@class='sssss-panel__footer']//span[text()='OK']/parent::button",
            'Warning popup OK button',
            this.page
        );
        return await okButton.isVisibleWithTimeout(5000);
    }

    public async clickWarningPopupOkButton(): Promise<void> {
        const okButton = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//div[@class='sssss-panel__footer']//span[text()='OK']/parent::button",
            'Warning popup OK button',
            this.page
        );
        await okButton.waitForVisible(10000);
        await okButton.clickWithTimeout(10000);
        CSReporter.info('Clicked OK button in Warning popup');
        await this.waitForPageLoad();
    }
}

export default TTTFZealDetailsPage;

-----------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Zeal Premisis Page
 * Source: SCENARIO_02_ZealsPremisisSearch_AllTypes.txt
 * All XPath locators from requirements document
 * Using Framework Wrapper Methods throughout
 */
@CSPage('tttf-zeal-premisis')
export class TTTFZealPremisisPage extends CSBasePage {

    // ===================================================================
    // PAGE HEADER ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h1[text()="Zeals/Premisis"]',
        description: 'Zeals/Premisis page header',
        waitForVisible: true,
        alternativeLocators: ['text:Zeals/Premisis']
    })
    public zealPremisisHeader!: CSWebElement;

    // ===================================================================
    // SEARCH SECTION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]',
        description: 'Search section header',
        waitForVisible: true,
        alternativeLocators: ['text:Search']
    })
    public searchSectionHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//button[@aria-label="Collapse Search"]',
        description: 'Search section collapse button',
        alternativeLocators: ['css:button[aria-label="Collapse Search"]']
    })
    public searchSectionCollapseButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//button[@aria-label="Expand Search"]',
        description: 'Search section expand button',
        alternativeLocators: ['css:button[aria-label="Expand Search"]']
    })
    public searchSectionExpandButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[contains(@class, "sssss-expandable--expanded") and contains(@class, "sssss-section__body")]',
        description: 'Search section expanded state',
        alternativeLocators: ['css:.sssss-expandable--expanded']
    })
    public searchSectionExpandedState!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[contains(@class, "sssss-expandable--collapsed") and contains(@class, "sssss-section__body")]',
        description: 'Search section collapsed state',
        alternativeLocators: ['css:.sssss-expandable--collapsed']
    })
    public searchSectionCollapsedState!: CSWebElement;

    @CSGetElement({
        xpath: '//form//div[text()="Search By"]',
        description: 'Search By header',
        waitForVisible: true,
        alternativeLocators: ['text:Search By']
    })
    public searchByHeader!: CSWebElement;

    // ===================================================================
    // TYPE DROPDOWN ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="searchType"]',
        description: 'Type dropdown button',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="searchType"]']
    })
    public typeDropdownButton!: CSWebElement;

    // ===================================================================
    // ATTRIBUTE DROPDOWN ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="searchAttributes"]',
        description: 'Attribute dropdown button',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="searchAttributes"]']
    })
    public attributeDropdownButton!: CSWebElement;

    // ===================================================================
    // INCLUDE PREMISIS CHECKBOX
    // ===================================================================

    @CSGetElement({
        xpath: '//span[@role="checkbox" and @aria-label="Include Premisis in results"]',
        description: 'Include Premisis in results checkbox',
        alternativeLocators: ['css:span[aria-label="Include Premisis in results"]']
    })
    public includePremisisCheckbox!: CSWebElement;

    // ===================================================================
    // ACTION BUTTONS
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//div[@class="button-bar-container"]//span[text()="Search"]/parent::button',
        description: 'Search button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Search")']
    })
    public searchButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//div[@class="button-bar-container"]//span[text()="Add Condition"]/parent::button',
        description: 'Add Condition button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Add Condition")']
    })
    public addConditionButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//div[@class="button-bar-container"]//span[text()="Reset"]/parent::button',
        description: 'Reset button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Reset")']
    })
    public resetButton!: CSWebElement;

    // ===================================================================
    // RESULTS SECTION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Results"]',
        description: 'Results section header',
        waitForVisible: true,
        alternativeLocators: ['text:Results']
    })
    public resultsHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Displaying"]',
        description: 'Displaying header (shows after search)',
        waitForVisible: true,
        alternativeLocators: ['text:Displaying']
    })
    public displayingHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]',
        description: 'Results table',
        waitForVisible: true,
        alternativeLocators: ['css:table.sssss-table']
    })
    public resultsTable!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//tbody//td[text()="No data available."]',
        description: 'No data available message',
        alternativeLocators: ['css:table.sssss-table tbody td:has-text("No data available")']
    })
    public noDataMessage!: CSWebElement;

    // ===================================================================
    // RESULTS TABLE COLUMN HEADERS
    // ===================================================================

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Type"]',
        description: 'Type column header',
        waitForVisible: true
    })
    public typeColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Zeal ID"]',
        description: 'Zeal ID column header',
        waitForVisible: true
    })
    public zealIdColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Zeal Key"]',
        description: 'Zeal Key column header',
        waitForVisible: true
    })
    public zealKeyColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Zeal Name"]',
        description: 'Zeal Name column header',
        waitForVisible: true
    })
    public zealNameColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Inductor Group"]',
        description: 'Inductor Group column header',
        waitForVisible: true
    })
    public inductorGroupColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Zzzt Seggregation"]',
        description: 'Zzzt Seggregation column header',
        waitForVisible: true
    })
    public zzztSeggregationColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Ttcalc Shools"]',
        description: 'Ttcalc Shools column header',
        waitForVisible: true
    })
    public ttcalcShoolsColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[text()="Associated Mmtes"]',
        description: 'Associated Mmtes column header (not sortable)',
        waitForVisible: true
    })
    public associatedMmtesColumnHeader!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - ZEAL TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="zealName"]',
        description: 'Zeal Name input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="zealName"]']
    })
    public zealNameInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="zealId"]',
        description: 'Zeal ID input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="zealId"]']
    })
    public zealIdInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="zealKey"]',
        description: 'Zeal Key input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="zealKey"]']
    })
    public zealKeyInput!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - PREMISIS TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="premisisDescription"]',
        description: 'Premisis Description input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="premisisDescription"]']
    })
    public premisisDescriptionInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="zzztSeggregation"]',
        description: 'Zzzt Seggregation input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="zzztSeggregation"]']
    })
    public zzztSeggregationInput!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - SCATTERED MMTE TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="scatteredMmteName"]',
        description: 'Scattered Mmte Name input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="scatteredMmteName"]']
    })
    public scatteredMmteNameInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="scatteredMmteCumulativeMmteId"]',
        description: 'Scattered Mmte Cumulative Mmte dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="scatteredMmteCumulativeMmteId"]']
    })
    public scatteredMmteCumulativeMmteDropdown!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="hasDisputed"]',
        description: 'Has Disputed dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="hasDisputed"]']
    })
    public hasDisputedDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - DISPUTED MMTE TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="disputedMmteName"]',
        description: 'Disputed Mmte Name input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="disputedMmteName"]']
    })
    public disputedMmteNameInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="disputedDate"]',
        description: 'Disputed Date input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="disputedDate"]']
    })
    public disputedDateInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="disputedCumulativeMmteId"]',
        description: 'Disputed Cumulative Mmte dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="disputedCumulativeMmteId"]']
    })
    public disputedCumulativeMmteDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - INDUCTOR GROUP TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="inductorGroupId"]',
        description: 'Inductor Group dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="inductorGroupId"]']
    })
    public inductorGroupDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - KINDNESS CIRCLE TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="kindnessCircleId"]',
        description: 'Kindness Circle dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="kindnessCircleId"]']
    })
    public kindnessCircleDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - SKETCHMARK TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="hasSketchmarkFlag"]',
        description: 'Sketchmark Flag dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="hasSketchmarkFlag"]']
    })
    public sketchmarkFlagDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - ADMINISTRATOR TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="acctManager"]',
        description: 'Administrator Name input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="acctManager"]']
    })
    public administratorNameInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="acctManagerEmail"]',
        description: 'Administrator Email input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="acctManagerEmail"]']
    })
    public administratorEmailInput!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - GGG NAME TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="calcShoolName"]',
        description: 'GGG Name (Calc Shool Name) input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="calcShoolName"]']
    })
    public gggNameInput!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFZealPremisisPage elements initialized');
    }

    // ===================================================================
    // PAGE VERIFICATION METHODS
    // ===================================================================

    public async verifyPageHeader(): Promise<void> {
        await this.zealPremisisHeader.waitForVisible(15000);
        const isVisible = await this.zealPremisisHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Zeals/Premisis page header verified');
        } else {
            CSReporter.fail('Zeals/Premisis page header not found');
            throw new Error('Zeals/Premisis page header verification failed');
        }
    }

    public async verifySearchSectionVisible(): Promise<void> {
        await this.searchSectionHeader.waitForVisible(10000);
        const isVisible = await this.searchSectionHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Search section is visible');
        } else {
            CSReporter.fail('Search section not found');
            throw new Error('Search section verification failed');
        }
    }

    public async verifySearchSectionExpanded(): Promise<void> {
        await this.searchSectionExpandedState.waitForVisible(10000);
        const isVisible = await this.searchSectionExpandedState.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Search section is expanded');
        } else {
            CSReporter.fail('Search section is not expanded');
            throw new Error('Search section expanded state verification failed');
        }
    }

    public async isSearchSectionExpanded(): Promise<boolean> {
        return await this.searchSectionCollapseButton.isVisibleWithTimeout(3000);
    }

    public async expandSearchSection(): Promise<void> {
        const isExpanded = await this.isSearchSectionExpanded();
        if (!isExpanded) {
            await this.searchSectionExpandButton.clickWithTimeout(5000);
            await this.searchSectionExpandedState.waitForVisible(5000);
        }
        CSReporter.pass('Search section expanded');
    }

    public async collapseSearchSection(): Promise<void> {
        const isExpanded = await this.isSearchSectionExpanded();
        if (isExpanded) {
            await this.searchSectionCollapseButton.clickWithTimeout(5000);
        }
        CSReporter.pass('Search section collapsed');
    }

    public async verifySearchByHeaderVisible(): Promise<void> {
        await this.searchByHeader.waitForVisible(10000);
        const isVisible = await this.searchByHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Search By header is visible');
        } else {
            CSReporter.fail('Search By header not found');
            throw new Error('Search By header verification failed');
        }
    }

    // ===================================================================
    // TYPE DROPDOWN METHODS
    // ===================================================================

    public async verifyTypeDropdownVisible(): Promise<void> {
        await this.typeDropdownButton.waitForVisible(10000);
        const isVisible = await this.typeDropdownButton.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Type dropdown is visible');
        } else {
            CSReporter.fail('Type dropdown not found');
            throw new Error('Type dropdown verification failed');
        }
    }

    public async getSelectedType(): Promise<string> {
        const labelElement = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='Search By']/parent::form//button[@name='searchType']//span[@class='sssss-button__label']`,
            'Selected type label',
            this.page
        );
        const text = await labelElement.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async clickTypeDropdown(): Promise<void> {
        await this.typeDropdownButton.waitForVisible(10000);
        await this.typeDropdownButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Type dropdown');
    }

    public async selectSearchType(searchType: string): Promise<void> {
        await this.clickTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']`,
            'Type dropdown listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']//span[text()='${searchType}']/parent::span`,
            `Type option: ${searchType}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500); // Brief wait for dropdown animation
        CSReporter.pass(`Selected search type: ${searchType}`);
    }

    public async getTypeDropdownOptions(): Promise<string[]> {
        await this.clickTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']`,
            'Type dropdown listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const optionsElement = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']//span[contains(@class, 'sssss-menu-item__label')]/span`,
            'Type dropdown options',
            this.page
        );
        const options = await optionsElement.allTextContents();

        // Close dropdown
        await this.zealPremisisHeader.clickWithTimeout(2000);
        return options.map(opt => opt.trim()).filter(opt => opt.length > 0);
    }

    // ===================================================================
    // ATTRIBUTE DROPDOWN METHODS
    // ===================================================================

    public async verifyAttributeDropdownVisible(): Promise<void> {
        await this.attributeDropdownButton.waitForVisible(10000);
        const isVisible = await this.attributeDropdownButton.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Attribute dropdown is visible');
        } else {
            CSReporter.fail('Attribute dropdown not found');
            throw new Error('Attribute dropdown verification failed');
        }
    }

    public async isAttributeDropdownVisible(): Promise<boolean> {
        return await this.attributeDropdownButton.isVisibleWithTimeout(3000);
    }

    public async getSelectedAttribute(): Promise<string> {
        const labelElement = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='Search By']/parent::form//button[@name='searchAttributes']//span[@class='sssss-button__label']`,
            'Selected attribute label',
            this.page
        );
        const text = await labelElement.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async clickAttributeDropdown(): Promise<void> {
        await this.attributeDropdownButton.waitForVisible(10000);
        await this.attributeDropdownButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Attribute dropdown');
    }

    public async selectAttribute(attribute: string): Promise<void> {
        await this.clickAttributeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchAttributes']//ul[@role='listbox']`,
            'Attribute dropdown listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchAttributes']//ul[@role='listbox']//li[@role='option']//span[text()='${attribute}']/parent::span`,
            `Attribute option: ${attribute}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        // Wait for dropdown to close and input field to appear after selection
        await this.page.waitForTimeout(500); // Brief wait for dropdown animation and UI update
        CSReporter.pass(`Selected attribute: ${attribute}`);
    }

    public async getAttributeDropdownOptions(): Promise<string[]> {
        await this.clickAttributeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchAttributes']//ul[@role='listbox']`,
            'Attribute dropdown listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const optionsElement = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchAttributes']//ul[@role='listbox']//li[@role='option']//span[contains(@class, 'sssss-menu-item__label')]/span`,
            'Attribute dropdown options',
            this.page
        );
        const options = await optionsElement.allTextContents();

        // Close dropdown
        await this.zealPremisisHeader.clickWithTimeout(2000);
        return options.map(opt => opt.trim()).filter(opt => opt.length > 0);
    }

    /**
     * Generic method to get dropdown options by field name
     * Supports: scatteredMmteCumulativeMmteId, disputedCumulativeMmteId, inductorGroupId, kindnessCircleId, hasDisputed, hasSketchmarkFlag
     */
    public async getDropdownOptionsByName(fieldName: string): Promise<string[]> {
        CSReporter.info(`Getting dropdown options for: ${fieldName}`);

        // Click the dropdown to open it
        const dropdown = this.getDropdownByName(fieldName);
        await dropdown.waitForVisible(10000);
        await dropdown.clickWithTimeout(10000);

        // Wait for listbox to appear
        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='${fieldName}']//ul[@role='listbox']`,
            `${fieldName} dropdown listbox`,
            this.page
        );
        await listbox.waitForVisible(5000);

        // Get all option text values
        const optionsElement = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='${fieldName}']//ul[@role='listbox']//li[@role='option']//span[contains(@class, 'sssss-menu-item__label')]/span`,
            `${fieldName} dropdown options`,
            this.page
        );
        const options = await optionsElement.allTextContents();

        // Close dropdown by clicking elsewhere
        await this.zealPremisisHeader.clickWithTimeout(2000);
        await this.page.waitForTimeout(300); // Wait for dropdown to close

        const cleanedOptions = options.map(opt => opt.trim()).filter(opt => opt.length > 0);
        CSReporter.info(`Found ${cleanedOptions.length} options for ${fieldName}`);
        return cleanedOptions;
    }

    // ===================================================================
    // INCLUDE PREMISIS CHECKBOX METHODS
    // ===================================================================

    public async isIncludePremisisCheckboxVisible(): Promise<boolean> {
        return await this.includePremisisCheckbox.isVisibleWithTimeout(3000);
    }

    public async isIncludePremisisEnabled(): Promise<boolean> {
        const ariaDisabled = await this.includePremisisCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'false';
    }

    public async isIncludePremisisChecked(): Promise<boolean> {
        const ariaChecked = await this.includePremisisCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        return ariaChecked === 'true';
    }

    public async checkIncludePremisis(): Promise<void> {
        const isChecked = await this.isIncludePremisisChecked();
        if (!isChecked) {
            await this.includePremisisCheckbox.clickWithTimeout(5000);
        }
        CSReporter.pass('Include Premisis checkbox checked');
    }

    public async uncheckIncludePremisis(): Promise<void> {
        const isChecked = await this.isIncludePremisisChecked();
        if (isChecked) {
            await this.includePremisisCheckbox.clickWithTimeout(5000);
        }
        CSReporter.pass('Include Premisis checkbox unchecked');
    }

    // ===================================================================
    // SEARCH INPUT METHODS
    // ===================================================================

    public async enterSearchValue(fieldName: string, value: string): Promise<void> {
        CSReporter.info(`Entering search value '${value}' in field '${fieldName}'`);

        const inputField = this.getInputFieldByName(fieldName);
        await inputField.waitForVisible(10000);
        await inputField.clearWithTimeout(5000);
        await inputField.fillWithTimeout(value, 5000);
        CSReporter.pass(`Entered search value: ${value}`);
    }

    public async selectDropdownValue(fieldName: string, value: string): Promise<void> {
        CSReporter.info(`Selecting dropdown value '${value}' in field '${fieldName}'`);

        const dropdownButton = this.getDropdownByName(fieldName);
        await dropdownButton.waitForVisible(10000);
        await dropdownButton.clickWithTimeout(10000);

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='${fieldName}']//ul[@role='listbox']`,
            `${fieldName} listbox`,
            this.page
        );
        await listbox.waitForVisible(5000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='${fieldName}']//ul[@role='listbox']//li[@role='option']//span[text()='${value}']/parent::span`,
            `${fieldName} option: ${value}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        // Wait for dropdown to close after selection
        await this.page.waitForTimeout(500); // Brief wait for dropdown animation
        CSReporter.pass(`Selected dropdown value: ${value}`);
    }

    private getInputFieldByName(fieldName: string): CSWebElement {
        const fieldMap: { [key: string]: CSWebElement } = {
            'zealName': this.zealNameInput,
            'zealId': this.zealIdInput,
            'zealKey': this.zealKeyInput,
            'premisisDescription': this.premisisDescriptionInput,
            'zzztSeggregation': this.zzztSeggregationInput,
            'scatteredMmteName': this.scatteredMmteNameInput,
            'disputedMmteName': this.disputedMmteNameInput,
            'disputedDate': this.disputedDateInput,
            'acctManager': this.administratorNameInput,
            'acctManagerEmail': this.administratorEmailInput,
            'calcShoolName': this.gggNameInput
        };

        if (!fieldMap[fieldName]) {
            throw new Error(`Unknown input field: ${fieldName}`);
        }

        return fieldMap[fieldName];
    }

    private getDropdownByName(fieldName: string): CSWebElement {
        const dropdownMap: { [key: string]: CSWebElement } = {
            'scatteredMmteCumulativeMmteId': this.scatteredMmteCumulativeMmteDropdown,
            'hasDisputed': this.hasDisputedDropdown,
            'disputedCumulativeMmteId': this.disputedCumulativeMmteDropdown,
            'inductorGroupId': this.inductorGroupDropdown,
            'kindnessCircleId': this.kindnessCircleDropdown,
            'hasSketchmarkFlag': this.sketchmarkFlagDropdown
        };

        if (!dropdownMap[fieldName]) {
            throw new Error(`Unknown dropdown field: ${fieldName}`);
        }

        return dropdownMap[fieldName];
    }

    /**
     * Click a dropdown by its field name to open it
     * @param fieldName - The dropdown field name (e.g., 'scatteredMmteCumulativeMmteId')
     */
    public async clickDropdownByName(fieldName: string): Promise<void> {
        const dropdown = this.getDropdownByName(fieldName);
        await dropdown.waitForVisible(10000);
        await dropdown.clickWithTimeout(10000);
        CSReporter.info(`Clicked dropdown: ${fieldName}`);
    }

    /**
     * Wait for element by xpath
     * @param xpath - The xpath of the element to wait for
     * @param timeout - Timeout in milliseconds
     */
    public async waitForElementByXPath(xpath: string, timeout: number): Promise<void> {
        const element = CSElementFactory.createByXPath(xpath, 'Dynamic element', this.page);
        await element.waitForVisible(timeout);
    }

    /**
     * Check if element is present by xpath
     * @param xpath - The xpath of the element to check
     * @returns true if element is present, false otherwise
     */
    public async isElementPresentByXPath(xpath: string): Promise<boolean> {
        const element = CSElementFactory.createByXPath(xpath, 'Dynamic element', this.page);
        return await element.isVisibleWithTimeout(2000);
    }

    /**
     * Click on Zeals/Premisis header to close any open dropdown
     * Requirement: click on Zeals/Premisis header so dropdown will disappear
     */
    public async clickZealPremisisHeader(): Promise<void> {
        await this.zealPremisisHeader.clickWithTimeout(2000);
        await this.page.waitForTimeout(300); // Wait for dropdown to close
        CSReporter.debug('Clicked Zeals/Premisis header to close dropdown');
    }

    // ===================================================================
    // ACTION BUTTON METHODS
    // ===================================================================

    public async clickSearchButton(): Promise<void> {
        await this.searchButton.waitForVisible(10000);
        await this.searchButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Search button');
        await this.waitForPageLoad();
    }

    public async clickAddConditionButton(): Promise<void> {
        await this.addConditionButton.waitForVisible(10000);
        await this.addConditionButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Add Condition button');
    }

    public async clickResetButton(): Promise<void> {
        await this.resetButton.waitForVisible(10000);
        await this.resetButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Reset button');
    }

    public async isSearchButtonEnabled(): Promise<boolean> {
        return await this.searchButton.isEnabledWithTimeout(5000);
    }

    public async isAddConditionButtonEnabled(): Promise<boolean> {
        return await this.addConditionButton.isEnabledWithTimeout(5000);
    }

    public async isResetButtonEnabled(): Promise<boolean> {
        return await this.resetButton.isEnabledWithTimeout(5000);
    }

    // ===================================================================
    // RESULTS SECTION METHODS
    // ===================================================================

    public async verifyResultsHeaderVisible(): Promise<void> {
        await this.resultsHeader.waitForVisible(10000);
        const isVisible = await this.resultsHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Results header is visible');
        } else {
            CSReporter.fail('Results header not found');
            throw new Error('Results header verification failed');
        }
    }

    public async verifyDisplayingHeaderVisible(): Promise<void> {
        await this.displayingHeader.waitForVisible(15000);
        const isVisible = await this.displayingHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Displaying header is visible');
        } else {
            CSReporter.fail('Displaying header not found');
            throw new Error('Displaying header verification failed');
        }
    }

    public async verifyResultsTableVisible(): Promise<void> {
        await this.resultsTable.waitForVisible(10000);
        const isVisible = await this.resultsTable.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Results table is visible');
        } else {
            CSReporter.fail('Results table not found');
            throw new Error('Results table verification failed');
        }
    }

    public async isNoDataMessageVisible(): Promise<boolean> {
        return await this.noDataMessage.isVisibleWithTimeout(3000);
    }

    public async waitForSearchResults(): Promise<void> {
        CSReporter.info('Waiting for search results');
        await this.displayingHeader.waitForVisible(30000);
        CSReporter.pass('Search results loaded');
    }

    public async getResultsRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr`,
            'Table rows',
            this.page
        );
        const count = await rows.count();
        CSReporter.info(`Table row count: ${count}`);
        return count;
    }

    // ===================================================================
    // TABLE DATA EXTRACTION METHODS
    // ===================================================================

    public async getTableCellValue(rowIndex: number, columnIndex: number): Promise<string> {
        const cell = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[${columnIndex}]`,
            `Table cell [${rowIndex}, ${columnIndex}]`,
            this.page
        );
        const value = await cell.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getTableRowData(rowIndex: number): Promise<{
        type: string;
        zealId: string;
        zealKey: string;
        zealName: string;
        inductorGroup: string;
        zzztSeggregation: string;
        ttcalcShool: string;
        associatedMmtes: string;
    }> {
        const type = await this.getTableCellValue(rowIndex, 2);
        const zealId = await this.getTableCellValue(rowIndex, 3);

        // Zeal Key is inside a button/span
        const zealKeyElement = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[4]//span[@class='sssss-button__label']`,
            `Row ${rowIndex} Zeal Key`,
            this.page
        );
        const zealKey = (await zealKeyElement.textContentWithTimeout(5000))?.trim() || '';

        const zealName = await this.getTableCellValue(rowIndex, 5);
        const inductorGroup = await this.getTableCellValue(rowIndex, 6);
        const zzztSeggregation = await this.getTableCellValue(rowIndex, 7);

        // Ttcalc Shool is inside a div
        const calcShoolElement = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[8]/div`,
            `Row ${rowIndex} Ttcalc Shool`,
            this.page
        );
        const ttcalcShool = (await calcShoolElement.textContentWithTimeout(5000))?.trim() || '';

        const associatedMmtes = await this.getTableCellValue(rowIndex, 9);

        return {
            type,
            zealId,
            zealKey,
            zealName,
            inductorGroup,
            zzztSeggregation,
            ttcalcShool,
            associatedMmtes
        };
    }

    public async getAllTableData(): Promise<Array<{
        type: string;
        zealId: string;
        zealKey: string;
        zealName: string;
        inductorGroup: string;
        zzztSeggregation: string;
        ttcalcShool: string;
        associatedMmtes: string;
    }>> {
        const rowCount = await this.getResultsRowCount();
        const data: Array<any> = [];

        for (let i = 1; i <= rowCount; i++) {
            const rowData = await this.getTableRowData(i);
            data.push(rowData);
        }

        CSReporter.info(`Extracted ${data.length} rows from results table`);
        return data;
    }

    // ===================================================================
    // FILTER DISPLAY METHODS
    // ===================================================================

    public async verifyFilterDisplayed(fieldName: string, value: string): Promise<void> {
        CSReporter.info(`Verifying filter displayed: ${fieldName} = ${value}`);

        const fieldElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${fieldName}']`,
            `Filter field: ${fieldName}`,
            this.page
        );
        await fieldElement.waitForVisible(10000);

        const valueElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${value}']`,
            `Filter value: ${value}`,
            this.page
        );
        await valueElement.waitForVisible(10000);

        CSReporter.pass(`Filter displayed: ${fieldName} = ${value}`);
    }

    // ===================================================================
    // COLUMN SORTING METHODS
    // ===================================================================

    public async clickColumnHeader(columnName: string): Promise<void> {
        const columnButton = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::button[1]`,
            `Column header: ${columnName}`,
            this.page
        );
        await columnButton.waitForVisible(10000);
        await columnButton.clickWithTimeout(10000);
        CSReporter.info(`Clicked column header: ${columnName}`);
    }

    public async isColumnSortedDescending(columnName: string): Promise<boolean> {
        const sortedColumn = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='descending']`,
            `Column sorted descending: ${columnName}`,
            this.page
        );
        return await sortedColumn.isVisibleWithTimeout(3000);
    }

    public async isColumnSortedAscending(columnName: string): Promise<boolean> {
        const sortedColumn = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='ascending']`,
            `Column sorted ascending: ${columnName}`,
            this.page
        );
        return await sortedColumn.isVisibleWithTimeout(3000);
    }

    public async hasResultsColumn(columnName: string): Promise<boolean> {
        const columnHeader = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//th//span[text()='${columnName}']`,
            `Column header: ${columnName}`,
            this.page
        );
        return await columnHeader.isVisibleWithTimeout(5000);
    }

    public async getColumnSortState(columnName: string): Promise<'ascending' | 'descending' | 'none'> {
        // Check if ascending
        const ascColumn = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='ascending']`,
            `Column sorted ascending: ${columnName}`,
            this.page
        );
        if (await ascColumn.isVisibleWithTimeout(1000)) {
            return 'ascending';
        }

        // Check if descending
        const descColumn = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='descending']`,
            `Column sorted descending: ${columnName}`,
            this.page
        );
        if (await descColumn.isVisibleWithTimeout(1000)) {
            return 'descending';
        }

        return 'none';
    }

    // ===================================================================
    // ZEAL KEY NAVIGATION
    // ===================================================================

    public async clickZealKeyLink(rowIndex: number): Promise<void> {
        const zealKeyLink = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[4]//button`,
            `Row ${rowIndex} Zeal Key link`,
            this.page
        );
        await zealKeyLink.waitForVisible(10000);
        await zealKeyLink.clickWithTimeout(10000);
        CSReporter.info(`Clicked Zeal Key link in row ${rowIndex}`);
    }

    // ===================================================================
    // EDIT LINK METHODS
    // ===================================================================

    public async clickEditLinkInActionColumn(rowIndex: number): Promise<void> {
        const editLink = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[1]//a[text()='Edit']`,
            `Row ${rowIndex} Edit link`,
            this.page
        );
        await editLink.waitForVisible(10000);
        await editLink.clickWithTimeout(10000);
        CSReporter.info(`Clicked Edit link in row ${rowIndex}`);
    }

    public async getSearchResultTypeValue(rowIndex: number): Promise<string> {
        const typeCell = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[2]`,
            `Row ${rowIndex} Type value`,
            this.page
        );
        const value = await typeCell.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getSearchResultZealIdValue(rowIndex: number): Promise<string> {
        const zealIdCell = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[3]`,
            `Row ${rowIndex} Zeal ID value`,
            this.page
        );
        const value = await zealIdCell.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getSearchResultZealKeyValue(rowIndex: number): Promise<string> {
        const zealKeyElement = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[4]//span[@class='sssss-button__label']`,
            `Row ${rowIndex} Zeal Key value`,
            this.page
        );
        const value = await zealKeyElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async uncheckIncludePremisisCheckbox(): Promise<void> {
        await this.uncheckIncludePremisis();
    }

    // ===================================================================
    // COMPLETE SEARCH FLOW METHOD
    // ===================================================================

    public async performSearch(
        searchType: string,
        attribute: string | null,
        fieldName: string,
        value: string,
        isDropdown: boolean = false,
        includePremisis: boolean = false
    ): Promise<void> {
        CSReporter.info(`Performing search: Type=${searchType}, Attribute=${attribute}, Value=${value}`);

        // Select search type
        await this.selectSearchType(searchType);

        // Select attribute if applicable
        if (attribute && await this.isAttributeDropdownVisible()) {
            await this.selectAttribute(attribute);
        }

        // Enter/select search value
        if (isDropdown) {
            await this.selectDropdownValue(fieldName, value);
        } else {
            await this.enterSearchValue(fieldName, value);
        }

        // Set Include Premisis checkbox
        if (includePremisis) {
            await this.checkIncludePremisis();
        } else {
            // Only uncheck if enabled (for Premisis type it's disabled)
            const isEnabled = await this.isIncludePremisisEnabled();
            if (isEnabled) {
                await this.uncheckIncludePremisis();
            }
        }

        // Click Search button
        await this.clickSearchButton();

        // Wait for results
        await this.waitForSearchResults();

        CSReporter.pass(`Search completed: Type=${searchType}, Value=${value}`);
    }

    // ===================================================================
    // UTILITY METHODS
    // ===================================================================

    public async closeDropdown(): Promise<void> {
        // Click outside to close any open dropdown
        await this.zealPremisisHeader.clickWithTimeout(5000);
        CSReporter.info('Closed dropdown');
    }

    public async waitForPageLoad(): Promise<void> {
        await this.waitForPageLoad();
    }
}

export default TTTFZealPremisisPage;


------------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Cumulative Mmtes Page
 * Source: SCENARIO_EXT01 - SCENARIO_EXT12 documents
 * All XPath locators from requirements document
 * Using Framework Wrapper Methods throughout
 */
@CSPage('tttf-cumulative-mmtes')
export class TTTFCumulativeMmtesPage extends CSBasePage {

    // ===================================================================
    // PAGE HEADER ELEMENTS (SCENARIO EXT01)
    // ===================================================================

    @CSGetElement({
        xpath: '//div[@class="body-container"]//h1[text()="Cumulative Mmtes"]',
        description: 'Cumulative Mmtes page header',
        waitForVisible: true,
        alternativeLocators: ['text:Cumulative Mmtes']
    })
    public cumulativeMmtesHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//span[text()="Add Instance"]/parent::button[@aria-label="Add Cumulative Mmte Instance"]',
        description: 'Add Instance button in header',
        waitForEnabled: true,
        alternativeLocators: ['css:button[aria-label="Add Cumulative Mmte Instance"]']
    })
    public addInstanceButton!: CSWebElement;

    @CSGetElement({
        xpath: '//span[text()="Display"]/parent::button[@id="displayCumulative"]',
        description: 'Display button',
        waitForEnabled: true,
        alternativeLocators: ['css:button#displayCumulative']
    })
    public displayButton!: CSWebElement;

    // ===================================================================
    // SEARCH SECTION ELEMENTS (SCENARIO EXT01, EXT02, EXT03, EXT04)
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]',
        description: 'Search section header',
        waitForVisible: true,
        alternativeLocators: ['text:Search']
    })
    public searchSectionHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[contains(@class, "sssss-expandable--collapsed")]',
        description: 'Search section collapsed state',
        alternativeLocators: ['css:.sssss-expandable--collapsed']
    })
    public searchSectionCollapsed!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[contains(@class, "sssss-expandable--expanded")]',
        description: 'Search section expanded state',
        alternativeLocators: ['css:.sssss-expandable--expanded']
    })
    public searchSectionExpanded!: CSWebElement;

    // Search Type Dropdown
    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//button[@name="searchType"]',
        description: 'Search Type dropdown button',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="searchType"]']
    })
    public searchTypeDropdown!: CSWebElement;

    // Cumulative Mmte Name Dropdown
    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//button[@name="cumulativeMmteId"]',
        description: 'Cumulative Mmte Name dropdown button',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="cumulativeMmteId"]']
    })
    public cumulativeMmteNameDropdown!: CSWebElement;

    // Date Input Fields
    @CSGetElement({
        xpath: '//input[@name="startDate"]',
        description: 'From date input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="startDate"]']
    })
    public fromDateInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="endDate"]',
        description: 'To date input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="endDate"]']
    })
    public toDateInput!: CSWebElement;

    // Search Action Buttons
    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//div[@class="button-bar-container"]//span[text()="Search"]/parent::button',
        description: 'Search button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Search")']
    })
    public searchButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//div[@class="button-bar-container"]//span[text()="Add Condition"]/parent::button',
        description: 'Add Condition button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Add Condition")']
    })
    public addConditionButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//div[@class="button-bar-container"]//span[text()="Reset"]/parent::button',
        description: 'Reset button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Reset")']
    })
    public resetButton!: CSWebElement;

    // ===================================================================
    // DISPLAYING SECTION ELEMENTS (SCENARIO EXT02, EXT03, EXT04)
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Displaying"]',
        description: 'Displaying header (shows after search)',
        waitForVisible: true,
        alternativeLocators: ['text:Displaying']
    })
    public displayingHeader!: CSWebElement;

    // ===================================================================
    // RESULTS TABLE ELEMENTS (SCENARIO EXT01, EXT05)
    // ===================================================================

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]',
        description: 'Results table',
        waitForVisible: true,
        alternativeLocators: ['css:table.sssss-table']
    })
    public resultsTable!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//tbody//td[text()="No data available."]',
        description: 'No data available message',
        alternativeLocators: ['css:table.sssss-table tbody td:has-text("No data available")']
    })
    public noDataAvailable!: CSWebElement;

    // Column Headers
    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Rrrrrrrr Date"]',
        description: 'Rrrrrrrr Date column header',
        waitForVisible: true
    })
    public rrrrrrrrDateColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Mmte (%)"]',
        description: 'Mmte (%) column header',
        waitForVisible: true
    })
    public mmteColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Cumulative Mmte Name"]',
        description: 'Cumulative Mmte Name column header',
        waitForVisible: true
    })
    public cumulativeMmteNameColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Source"]',
        description: 'Source column header',
        waitForVisible: true
    })
    public sourceColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Publication Date"]',
        description: 'Publication Date column header',
        waitForVisible: true
    })
    public publicationDateColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[text()="Actions"]',
        description: 'Actions column header',
        waitForVisible: true
    })
    public actionsColumnHeader!: CSWebElement;

    // ===================================================================
    // PAGINATION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//div[@aria-label="Cumulative Mmtes Pagination"]//span[@class="sssss-paginator__trigger-total-items"]',
        description: 'Total items count in pagination',
        waitForVisible: true
    })
    public paginationTotalItems!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@aria-label="Cumulative Mmtes Pagination"]//span[@class="sssss-paginator__trigger-current-items"]',
        description: 'Current items range in pagination',
        waitForVisible: true
    })
    public paginationCurrentItems!: CSWebElement;

    // ===================================================================
    // EXPORT BUTTON (SCENARIO EXT12)
    // ===================================================================

    @CSGetElement({
        xpath: '//span[@class="sssss-button__label" and text()="Export"]/parent::button[@aria-label="Export"]',
        description: 'Export button',
        alternativeLocators: ['css:button[aria-label="Export"]']
    })
    public exportButton!: CSWebElement;

    // ===================================================================
    // EDIT INSTANCE MODAL ELEMENTS (SCENARIO EXT07, EXT08, EXT09)
    // ===================================================================

    @CSGetElement({
        xpath: '//div[@class="sssss-modal"]//div[@class="sssss-panel__content-wrapper"]',
        description: 'Edit Instance modal wrapper',
        waitForVisible: true
    })
    public editInstanceModal!: CSWebElement;

    @CSGetElement({
        xpath: '//div[contains(@class,"sssss-panel__header")]//h5[text()="Edit Instance"]',
        description: 'Edit Instance modal header',
        waitForVisible: true
    })
    public editInstanceModalHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//button[@name="cumulativeMmteId"]',
        description: 'Cumulative Scattered dropdown in Edit modal',
        waitForEnabled: true
    })
    public editInstanceCumulativeRefDropdown!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//input[@name="rrrrrrrrDate"]',
        description: 'Rrrrrrrr Date input in Edit modal',
        waitForVisible: true
    })
    public editInstanceRrrrrrrrDateInput!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//input[@name="mmte"]',
        description: 'Mmte input in Edit modal',
        waitForVisible: true
    })
    public editInstanceMmteInput!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//button[@name="save"]//span[text()="SAVE"]/parent::button',
        description: 'SAVE button in Edit modal',
        waitForEnabled: true
    })
    public editInstanceSaveButton!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//span[text()="Cancel"]/parent::button',
        description: 'Cancel button in Edit modal',
        waitForEnabled: true
    })
    public editInstanceCancelButton!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//p[@class="sssss-error-message"]',
        description: 'Error message in Edit modal',
        alternativeLocators: ['css:div.sssss-panel__body p.sssss-error-message']
    })
    public editInstanceErrorMessage!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[contains(@class,"sssss-panel__header")]//span[text()="Close"]/ancestor::button[1]',
        description: 'Close button in Edit modal header',
        waitForEnabled: true
    })
    public editInstanceCloseButton!: CSWebElement;

    // ===================================================================
    // ADD INSTANCE MODAL ELEMENTS (SCENARIO EXT10)
    // ===================================================================

    @CSGetElement({
        xpath: '//div[contains(@class,"sssss-panel__header")]//h5[text()="Add Instance"]',
        description: 'Add Instance modal header',
        waitForVisible: true
    })
    public addInstanceModalHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//p[@class="sssss-error-message"]',
        description: 'Error message in Add Instance modal'
    })
    public addInstanceErrorMessage!: CSWebElement;

    @CSGetElement({
        xpath: '//div[contains(@class,"sssss-panel__header")]//div[@class="sssss-panel__header-message"]//p[text()="Instance Saved"]',
        description: 'Instance Saved success message'
    })
    public instanceSavedMessage!: CSWebElement;

    // ===================================================================
    // CONFIRM DELETE MODAL ELEMENTS (SCENARIO EXT11)
    // ===================================================================

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[contains(@class,"sssss-panel__header")]//h1[text()="Confirm Delete"]',
        description: 'Confirm Delete modal header',
        waitForVisible: true
    })
    public confirmDeleteModalHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//div[contains(@class, "sssss-message-box__text")]',
        description: 'Confirm Delete message text',
        waitForVisible: true
    })
    public confirmDeleteMessageText!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__footer"]//span[text()="Delete"]/parent::button',
        description: 'Delete button in Confirm Delete modal',
        waitForEnabled: true
    })
    public confirmDeleteButton!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__footer"]//span[text()="Cancel"]/parent::button',
        description: 'Cancel button in Confirm Delete modal',
        waitForEnabled: true
    })
    public confirmDeleteCancelButton!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFCumulativeMmtesPage elements initialized');
    }

    // ===================================================================
    // PAGE VERIFICATION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async verifyPageHeader(): Promise<void> {
        await this.cumulativeMmtesHeader.waitForVisible(15000);
        const isVisible = await this.cumulativeMmtesHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Cumulative Mmtes page header verified');
        } else {
            CSReporter.fail('Cumulative Mmtes page header not found');
            throw new Error('Cumulative Mmtes page header verification failed');
        }
    }

    public async verifyDisplayButtonEnabled(): Promise<void> {
        await this.displayButton.waitForVisible(10000);
        const isEnabled = await this.displayButton.isEnabledWithTimeout(5000);

        if (isEnabled) {
            CSReporter.pass('Display button is enabled');
        } else {
            CSReporter.fail('Display button is not enabled');
            throw new Error('Display button is disabled');
        }
    }

    public async verifySearchSectionPresent(): Promise<void> {
        await this.searchSectionHeader.waitForVisible(10000);
        const isVisible = await this.searchSectionHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Search section is present');
        } else {
            CSReporter.fail('Search section not found');
            throw new Error('Search section verification failed');
        }
    }

    public async verifySearchSectionExpandable(): Promise<boolean> {
        const isCollapsed = await this.searchSectionCollapsed.isVisibleWithTimeout(3000);
        if (isCollapsed) {
            CSReporter.pass('Search section is in collapsed state');
            return true;
        }

        const isExpanded = await this.searchSectionExpanded.isVisibleWithTimeout(3000);
        if (isExpanded) {
            CSReporter.pass('Search section is in expanded state');
            return true;
        }

        CSReporter.fail('Search section expandable state could not be determined');
        return false;
    }

    // ===================================================================
    // SEARCH TYPE DROPDOWN METHODS - Using CSElementFactory
    // ===================================================================

    public async verifyDefaultSearchTypeIsCumulativeMmte(): Promise<void> {
        const selected = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='Search By']/ancestor::form[@class='sssss-form'][1]//button[@name='searchType']/span[@class='sssss-button__label' and text()='Cumulative Mmte']`,
            'Default search type Cumulative Mmte',
            this.page
        );

        await selected.waitForVisible(10000);
        const isVisible = await selected.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Default search type is "Cumulative Mmte"');
        } else {
            CSReporter.fail('Default search type is not "Cumulative Mmte"');
            throw new Error('Default search type verification failed');
        }
    }

    public async clickSearchTypeDropdown(): Promise<void> {
        await this.searchTypeDropdown.waitForVisible(10000);
        await this.searchTypeDropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked Search Type dropdown');
    }

    public async selectSearchType(searchType: string): Promise<void> {
        await this.clickSearchTypeDropdown();

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']//span[text()='${searchType}']/parent::span`,
            `Search type option: ${searchType}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected search type: ${searchType}`);
    }

    public async verifySearchTypeOptions(expectedOptions: string[]): Promise<void> {
        await this.clickSearchTypeDropdown();

        const listFirst = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']`,
            'Search type list first item',
            this.page
        );
        await listFirst.waitForVisible(10000);

        for (const optionText of expectedOptions) {
            const optionElement = CSElementFactory.createByXPath(
                `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']//span[text()='${optionText}']/parent::span`,
                `Search type option: ${optionText}`,
                this.page
            );
            const isVisible = await optionElement.isVisibleWithTimeout(5000);

            if (isVisible) {
                CSReporter.pass(`Search type option verified: ${optionText}`);
            } else {
                CSReporter.fail(`Search type option not found: ${optionText}`);
                throw new Error(`Search type option verification failed: ${optionText}`);
            }
        }

        // Close dropdown
        await this.cumulativeMmtesHeader.clickWithTimeout(5000);
    }

    // ===================================================================
    // CUMULATIVE MMTE NAME DROPDOWN METHODS - Using CSElementFactory
    // ===================================================================

    public async clickCumulativeMmteNameDropdown(): Promise<void> {
        await this.cumulativeMmteNameDropdown.waitForVisible(10000);
        await this.cumulativeMmteNameDropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked Cumulative Mmte Name dropdown');
    }

    public async selectCumulativeMmteName(mmteName: string): Promise<void> {
        await this.clickCumulativeMmteNameDropdown();

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${mmteName}']/parent::span`,
            `Cumulative mmte name option: ${mmteName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected cumulative mmte name: ${mmteName}`);
    }

    public async verifyCumulativeMmteNameSelected(mmteName: string): Promise<void> {
        const selected = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='Search By']/ancestor::form[@class='sssss-form'][1]//button[@name='cumulativeMmteId']//span[@class='sssss-button__label' and text()='${mmteName}']`,
            `Selected cumulative mmte name: ${mmteName}`,
            this.page
        );

        await selected.waitForVisible(10000);
        const isVisible = await selected.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Cumulative mmte name verified as selected: ${mmteName}`);
        } else {
            CSReporter.fail(`Cumulative mmte name not selected: ${mmteName}`);
            throw new Error(`Cumulative mmte name verification failed: ${mmteName}`);
        }
    }

    public async verifyCumulativeMmteNameOptions(expectedOptions: string[]): Promise<void> {
        await this.clickCumulativeMmteNameDropdown();

        const listFirst = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']`,
            'Cumulative mmte name list first item',
            this.page
        );
        await listFirst.waitForVisible(10000);

        for (const optionText of expectedOptions) {
            const optionElement = CSElementFactory.createByXPath(
                `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${optionText}']/parent::span`,
                `Cumulative mmte name option: ${optionText}`,
                this.page
            );
            const isVisible = await optionElement.isVisibleWithTimeout(5000);

            if (isVisible) {
                CSReporter.pass(`Cumulative mmte name option verified: ${optionText}`);
            } else {
                CSReporter.fail(`Cumulative mmte name option not found: ${optionText}`);
                throw new Error(`Cumulative mmte name option verification failed: ${optionText}`);
            }
        }

        // Close dropdown
        await this.cumulativeMmtesHeader.clickWithTimeout(5000);
    }

    // ===================================================================
    // DATE INPUT METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async enterFromDate(date: string): Promise<void> {
        await this.fromDateInput.waitForVisible(10000);
        await this.fromDateInput.clearWithTimeout(5000);
        await this.fromDateInput.fillWithTimeout(date, 5000);
        CSReporter.info(`Entered From date: ${date}`);
    }

    public async enterToDate(date: string): Promise<void> {
        await this.toDateInput.waitForVisible(10000);
        await this.toDateInput.clearWithTimeout(5000);
        await this.toDateInput.fillWithTimeout(date, 5000);
        CSReporter.info(`Entered To date: ${date}`);
    }

    // ===================================================================
    // SEARCH ACTION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async verifySearchButtonEnabled(): Promise<void> {
        await this.searchButton.waitForVisible(10000);
        const isEnabled = await this.searchButton.isEnabledWithTimeout(5000);

        if (isEnabled) {
            CSReporter.pass('Search button is enabled');
        } else {
            CSReporter.fail('Search button is not enabled');
            throw new Error('Search button is disabled');
        }
    }

    public async clickSearchButton(): Promise<void> {
        await this.searchButton.waitForVisible(10000);
        await this.searchButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Search button');
        await this.waitForPageLoad();
    }

    public async verifyAddConditionButtonEnabled(): Promise<void> {
        await this.addConditionButton.waitForVisible(10000);
        const isEnabled = await this.addConditionButton.isEnabledWithTimeout(5000);

        if (isEnabled) {
            CSReporter.pass('Add Condition button is enabled');
        } else {
            CSReporter.fail('Add Condition button is not enabled');
            throw new Error('Add Condition button is disabled');
        }
    }

    public async clickAddConditionButton(): Promise<void> {
        await this.addConditionButton.waitForVisible(10000);
        await this.addConditionButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Add Condition button');
    }

    public async verifyResetButtonEnabled(): Promise<void> {
        await this.resetButton.waitForVisible(10000);
        const isEnabled = await this.resetButton.isEnabledWithTimeout(5000);

        if (isEnabled) {
            CSReporter.pass('Reset button is enabled');
        } else {
            CSReporter.fail('Reset button is not enabled');
            throw new Error('Reset button is disabled');
        }
    }

    public async clickResetButton(): Promise<void> {
        await this.resetButton.waitForVisible(10000);
        await this.resetButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Reset button');
    }

    // ===================================================================
    // DISPLAYING SECTION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async verifyDisplayingHeaderPresent(): Promise<void> {
        await this.displayingHeader.waitForVisible(15000);
        const isVisible = await this.displayingHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Displaying header is present');
        } else {
            CSReporter.fail('Displaying header not found');
            throw new Error('Displaying header verification failed');
        }
    }

    public async verifyDisplayedFilterCriteria(filterLabel: string, filterValue: string): Promise<void> {
        const label = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${filterLabel}']`,
            `Filter label: ${filterLabel}`,
            this.page
        );

        await label.waitForVisible(10000);
        const isLabelVisible = await label.isVisibleWithTimeout(5000);

        if (!isLabelVisible) {
            CSReporter.fail(`Filter label not found: ${filterLabel}`);
            throw new Error(`Filter label verification failed: ${filterLabel}`);
        }

        const value = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${filterLabel}']/following-sibling::div[1]`,
            `Filter value for: ${filterLabel}`,
            this.page
        );
        const actualValue = await value.textContentWithTimeout(5000);

        if (actualValue?.trim() === filterValue) {
            CSReporter.pass(`Filter criteria verified: ${filterLabel} = ${filterValue}`);
        } else {
            CSReporter.fail(`Filter value mismatch: Expected=${filterValue}, Actual=${actualValue}`);
            throw new Error(`Filter value verification failed: ${filterLabel}`);
        }
    }

    // ===================================================================
    // RESULTS TABLE METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async verifyResultsTablePresent(): Promise<void> {
        await this.resultsTable.waitForVisible(15000);
        const isVisible = await this.resultsTable.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Results table is present');
        } else {
            CSReporter.fail('Results table not found');
            throw new Error('Results table verification failed');
        }
    }

    public async verifyNoDataAvailable(): Promise<boolean> {
        const isVisible = await this.noDataAvailable.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.info('No data available in results table');
            return true;
        }
        return false;
    }

    public async verifyDataIsAvailable(): Promise<void> {
        const noData = await this.verifyNoDataAvailable();
        if (noData) {
            CSReporter.fail('No data available in results table');
            throw new Error('Results table has no data');
        }
        CSReporter.pass('Data is available in results table');
    }

    public async verifyAllColumnHeaders(): Promise<void> {
        const headers = [
            { element: this.rrrrrrrrDateColumnHeader, name: 'Rrrrrrrr Date' },
            { element: this.mmteColumnHeader, name: 'Mmte (%)' },
            { element: this.cumulativeMmteNameColumnHeader, name: 'Cumulative Mmte Name' },
            { element: this.sourceColumnHeader, name: 'Source' },
            { element: this.publicationDateColumnHeader, name: 'Publication Date' },
            { element: this.actionsColumnHeader, name: 'Actions' }
        ];

        for (const header of headers) {
            await header.element.waitForVisible(10000);
            const isVisible = await header.element.isVisibleWithTimeout(5000);

            if (isVisible) {
                CSReporter.pass(`Column header verified: ${header.name}`);
            } else {
                CSReporter.fail(`Column header not found: ${header.name}`);
                throw new Error(`Column header verification failed: ${header.name}`);
            }
        }
    }

    // ===================================================================
    // SORTING METHODS (SCENARIO EXT05) - Using CSElementFactory
    // ===================================================================

    public async clickColumnHeader(columnName: string): Promise<void> {
        const column = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::button[1]`,
            `Column header button: ${columnName}`,
            this.page
        );

        await column.waitForVisible(10000);
        await column.clickWithTimeout(10000);
        CSReporter.info(`Clicked column header: ${columnName}`);
    }

    public async verifySortState(columnName: string, sortOrder: 'ascending' | 'descending' | 'unsorted'): Promise<void> {
        let xpath: string;

        if (sortOrder === 'ascending') {
            xpath = `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='ascending']`;
        } else if (sortOrder === 'descending') {
            xpath = `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='descending']`;
        } else {
            xpath = `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][contains(@class,'sssss-table__sortable-unsorted-indicator')]`;
        }

        const element = CSElementFactory.createByXPath(xpath, `Sort state ${sortOrder} for ${columnName}`, this.page);
        await element.waitForVisible(10000);
        const isVisible = await element.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Column ${columnName} is sorted ${sortOrder}`);
        } else {
            CSReporter.fail(`Column ${columnName} is not sorted ${sortOrder}`);
            throw new Error(`Sort state verification failed: ${columnName} ${sortOrder}`);
        }
    }

    public async sortColumnAndVerify(columnName: string, sortOrder: 'ascending' | 'descending'): Promise<void> {
        await this.clickColumnHeader(columnName);
        await this.verifySortState(columnName, sortOrder);
    }

    // ===================================================================
    // TABLE DATA EXTRACTION METHODS - Using CSElementFactory
    // ===================================================================

    public async getTableRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody//tr`,
            'Table rows',
            this.page
        );
        const count = await rows.count();
        CSReporter.info(`Table row count: ${count}`);
        return count;
    }

    public async getTableCellValue(rowIndex: number, columnIndex: number): Promise<string> {
        const cell = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody//tr[${rowIndex}]/td[${columnIndex}]`,
            `Table cell [${rowIndex}, ${columnIndex}]`,
            this.page
        );
        const value = await cell.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getTableRowData(rowIndex: number): Promise<{
        rrrrrrrrDate: string;
        mmte: string;
        cumulativeMmteName: string;
        source: string;
        publicationDate: string;
    }> {
        const rrrrrrrrDate = await this.getTableCellValue(rowIndex, 1);
        const mmte = await this.getTableCellValue(rowIndex, 2);
        const cumulativeMmteName = await this.getTableCellValue(rowIndex, 3);
        const source = await this.getTableCellValue(rowIndex, 4);
        const publicationDate = await this.getTableCellValue(rowIndex, 5);

        return {
            rrrrrrrrDate,
            mmte,
            cumulativeMmteName,
            source,
            publicationDate
        };
    }

    public async getAllTableData(): Promise<Array<{
        rrrrrrrrDate: string;
        mmte: string;
        cumulativeMmteName: string;
        source: string;
        publicationDate: string;
    }>> {
        const rowCount = await this.getTableRowCount();
        const data: Array<any> = [];

        for (let i = 1; i <= rowCount; i++) {
            const rowData = await this.getTableRowData(i);
            data.push(rowData);
        }

        CSReporter.info(`Extracted ${data.length} rows from results table`);
        return data;
    }

    // ===================================================================
    // PAGINATION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async getPaginationTotalCount(): Promise<number> {
        await this.paginationTotalItems.waitForVisible(10000);
        const text = await this.paginationTotalItems.textContentWithTimeout(5000);

        // Extract number from text like "of 1673 items"
        const match = text?.match(/of (\d+) items?/);
        if (match && match[1]) {
            const count = parseInt(match[1], 10);
            CSReporter.info(`Total pagination count: ${count}`);
            return count;
        }

        CSReporter.fail('Could not extract pagination total count');
        throw new Error('Pagination total count extraction failed');
    }

    public async getPaginationCurrentRange(): Promise<string> {
        await this.paginationCurrentItems.waitForVisible(10000);
        const text = await this.paginationCurrentItems.textContentWithTimeout(5000);
        CSReporter.info(`Current pagination range: ${text}`);
        return text?.trim() || '';
    }

    // ===================================================================
    // ROW ACTION METHODS (EDIT, REMOVE) - Using CSElementFactory
    // ===================================================================

    public async clickEditButtonForRow(rowIndex: number): Promise<void> {
        const editButton = CSElementFactory.createByXPath(
            `//tbody/tr[${rowIndex}]/td[6]//span[text()='Edit']/parent::button[@aria-label='Edit Cumulative Mmte Instance']`,
            `Edit button for row ${rowIndex}`,
            this.page
        );

        await editButton.waitForVisible(10000);
        await editButton.clickWithTimeout(10000);
        CSReporter.info(`Clicked Edit button for row ${rowIndex}`);
    }

    public async clickRemoveButtonForRow(rowIndex: number): Promise<void> {
        const removeButton = CSElementFactory.createByXPath(
            `//tbody/tr[${rowIndex}]/td[6]//span[text()='Remove']/parent::button[@aria-label='Delete Cumulative Mmte Instance']`,
            `Remove button for row ${rowIndex}`,
            this.page
        );

        await removeButton.waitForVisible(10000);
        await removeButton.clickWithTimeout(10000);
        CSReporter.info(`Clicked Remove button for row ${rowIndex}`);
    }

    public async verifyEditButtonPresent(rowIndex: number): Promise<void> {
        const editButton = CSElementFactory.createByXPath(
            `//tbody/tr[${rowIndex}]/td[6]//span[text()='Edit']/parent::button[@aria-label='Edit Cumulative Mmte Instance']`,
            `Edit button for row ${rowIndex}`,
            this.page
        );

        const isVisible = await editButton.isVisibleWithTimeout(5000);
        const isEnabled = await editButton.isEnabledWithTimeout(5000);

        if (isVisible && isEnabled) {
            CSReporter.pass(`Edit button is present and enabled for row ${rowIndex}`);
        } else {
            CSReporter.fail(`Edit button is not present or enabled for row ${rowIndex}`);
            throw new Error(`Edit button verification failed for row ${rowIndex}`);
        }
    }

    public async verifyRemoveButtonPresent(rowIndex: number): Promise<void> {
        const removeButton = CSElementFactory.createByXPath(
            `//tbody/tr[${rowIndex}]/td[6]//span[text()='Remove']/parent::button[@aria-label='Delete Cumulative Mmte Instance']`,
            `Remove button for row ${rowIndex}`,
            this.page
        );

        const isVisible = await removeButton.isVisibleWithTimeout(5000);
        const isEnabled = await removeButton.isEnabledWithTimeout(5000);

        if (isVisible && isEnabled) {
            CSReporter.pass(`Remove button is present and enabled for row ${rowIndex}`);
        } else {
            CSReporter.fail(`Remove button is not present or enabled for row ${rowIndex}`);
            throw new Error(`Remove button verification failed for row ${rowIndex}`);
        }
    }

    // ===================================================================
    // EDIT INSTANCE MODAL METHODS (SCENARIO EXT07, EXT08, EXT09)
    // ===================================================================

    public async verifyEditInstanceModalOpen(): Promise<void> {
        await this.editInstanceModal.waitForVisible(15000);
        const isVisible = await this.editInstanceModal.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Edit Instance modal is open');
        } else {
            CSReporter.fail('Edit Instance modal is not open');
            throw new Error('Edit Instance modal verification failed');
        }
    }

    public async verifyEditInstanceModalClosed(): Promise<void> {
        const isVisible = await this.editInstanceModal.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.fail('Edit Instance modal is still open');
            throw new Error('Edit Instance modal should be closed');
        }
        CSReporter.pass('Edit Instance modal is closed');
    }

    public async getEditInstanceCumulativeRefValue(): Promise<string> {
        const value = CSElementFactory.createByXPath(
            `//div[@class='sssss-panel__content-wrapper']//div[@class='sssss-panel__body']//button[@name='cumulativeMmteId']//span[@class='sssss-button__label']`,
            'Cumulative scattered value in modal',
            this.page
        );
        const text = await value.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async getEditInstanceRrrrrrrrDateValue(): Promise<string> {
        return await this.editInstanceRrrrrrrrDateInput.inputValueWithTimeout(5000);
    }

    public async getEditInstanceMmteValue(): Promise<string> {
        return await this.editInstanceMmteInput.inputValueWithTimeout(5000);
    }

    public async selectCumulativeRefInEditModal(cumulativeRefName: string): Promise<void> {
        await this.editInstanceCumulativeRefDropdown.waitForVisible(10000);
        await this.editInstanceCumulativeRefDropdown.clickWithTimeout(10000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${cumulativeRefName}']/parent::span`,
            `Cumulative scattered option: ${cumulativeRefName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and modal to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected cumulative scattered in modal: ${cumulativeRefName}`);
    }

    public async setEditInstanceRrrrrrrrDate(date: string): Promise<void> {
        await this.editInstanceRrrrrrrrDateInput.waitForVisible(10000);
        await this.editInstanceRrrrrrrrDateInput.clearWithTimeout(5000);
        await this.editInstanceRrrrrrrrDateInput.fillWithTimeout(date, 5000);
        CSReporter.info(`Set rrrrrrrr date in modal: ${date}`);
    }

    public async setEditInstanceMmte(mmte: string): Promise<void> {
        await this.editInstanceMmteInput.waitForVisible(10000);
        await this.editInstanceMmteInput.clearWithTimeout(5000);
        await this.editInstanceMmteInput.fillWithTimeout(mmte, 5000);
        CSReporter.info(`Set mmte in modal: ${mmte}`);
    }

    public async clickEditInstanceSaveButton(): Promise<void> {
        await this.editInstanceSaveButton.waitForVisible(10000);
        await this.editInstanceSaveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked SAVE button in Edit Instance modal');
    }

    public async clickEditInstanceCancelButton(): Promise<void> {
        await this.editInstanceCancelButton.waitForVisible(10000);
        await this.editInstanceCancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button in Edit Instance modal');
    }

    public async getEditInstanceErrorMessage(): Promise<string> {
        const isVisible = await this.editInstanceErrorMessage.isVisibleWithTimeout(5000);
        if (isVisible) {
            const message = await this.editInstanceErrorMessage.textContentWithTimeout(5000);
            return message?.trim() || '';
        }
        return '';
    }

    public async verifyEditInstanceErrorMessage(expectedMessage: string): Promise<void> {
        const actualMessage = await this.getEditInstanceErrorMessage();

        if (actualMessage === expectedMessage) {
            CSReporter.pass(`Error message verified: ${expectedMessage}`);
        } else {
            CSReporter.fail(`Error message mismatch. Expected: ${expectedMessage}, Actual: ${actualMessage}`);
            throw new Error('Error message verification failed');
        }
    }

    public async isSaveButtonEnabled(): Promise<boolean> {
        await this.editInstanceSaveButton.waitForVisible(10000);
        return await this.editInstanceSaveButton.isEnabledWithTimeout(5000);
    }

    public async isXCloseButtonVisible(): Promise<boolean> {
        return await this.editInstanceCloseButton.isVisibleWithTimeout(5000);
    }

    public async isCumulativeRefDropdownVisible(): Promise<boolean> {
        return await this.editInstanceCumulativeRefDropdown.isVisibleWithTimeout(5000);
    }

    public async isRrrrrrrrDateInputVisible(): Promise<boolean> {
        return await this.editInstanceRrrrrrrrDateInput.isVisibleWithTimeout(5000);
    }

    public async isMmteInputVisible(): Promise<boolean> {
        return await this.editInstanceMmteInput.isVisibleWithTimeout(5000);
    }

    public async clickCumulativeRefDropdown(): Promise<void> {
        await this.editInstanceCumulativeRefDropdown.waitForVisible(10000);
        await this.editInstanceCumulativeRefDropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked Cumulative Scattered dropdown');
    }

    // ===================================================================
    // ADD INSTANCE MODAL METHODS (SCENARIO EXT10)
    // ===================================================================

    public async clickAddInstanceButton(): Promise<void> {
        await this.addInstanceButton.waitForVisible(10000);
        await this.addInstanceButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Add Instance button');
    }

    public async verifyAddInstanceModalOpen(): Promise<void> {
        await this.addInstanceModalHeader.waitForVisible(15000);
        const isVisible = await this.addInstanceModalHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Add Instance modal is open');
        } else {
            CSReporter.fail('Add Instance modal is not open');
            throw new Error('Add Instance modal verification failed');
        }
    }

    public async verifyAddInstanceModalClosed(): Promise<void> {
        const isVisible = await this.addInstanceModalHeader.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.fail('Add Instance modal is still open');
            throw new Error('Add Instance modal should be closed');
        }
        CSReporter.pass('Add Instance modal is closed');
    }

    public async selectCumulativeRefInAddModal(cumulativeRefName: string): Promise<void> {
        // Add modal uses same dropdown as Edit modal - reuse editInstanceCumulativeRefDropdown
        await this.editInstanceCumulativeRefDropdown.waitForVisible(10000);
        await this.editInstanceCumulativeRefDropdown.clickWithTimeout(10000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${cumulativeRefName}']/parent::span`,
            `Cumulative scattered option: ${cumulativeRefName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and modal to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected cumulative scattered in Add Instance modal: ${cumulativeRefName}`);
    }

    public async setAddInstanceRrrrrrrrDate(date: string): Promise<void> {
        // Add modal uses same input as Edit modal
        await this.editInstanceRrrrrrrrDateInput.waitForVisible(10000);
        await this.editInstanceRrrrrrrrDateInput.clearWithTimeout(5000);
        await this.editInstanceRrrrrrrrDateInput.fillWithTimeout(date, 5000);
        CSReporter.info(`Set rrrrrrrr date in Add Instance modal: ${date}`);
    }

    public async setAddInstanceMmte(mmte: string): Promise<void> {
        // Add modal uses same input as Edit modal
        await this.editInstanceMmteInput.waitForVisible(10000);
        await this.editInstanceMmteInput.clearWithTimeout(5000);
        await this.editInstanceMmteInput.fillWithTimeout(mmte, 5000);
        CSReporter.info(`Set mmte in Add Instance modal: ${mmte}`);
    }

    public async clickAddInstanceSaveButton(): Promise<void> {
        await this.editInstanceSaveButton.waitForVisible(10000);
        await this.editInstanceSaveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked SAVE button in Add Instance modal');
    }

    public async clickAddInstanceCancelButton(): Promise<void> {
        await this.editInstanceCancelButton.waitForVisible(10000);
        await this.editInstanceCancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button in Add Instance modal');
    }

    public async getAddInstanceErrorMessage(): Promise<string> {
        const isVisible = await this.addInstanceErrorMessage.isVisibleWithTimeout(5000);
        if (isVisible) {
            const message = await this.addInstanceErrorMessage.textContentWithTimeout(5000);
            return message?.trim() || '';
        }
        return '';
    }

    public async verifyAddInstanceErrorMessage(expectedMessage: string): Promise<void> {
        const actualMessage = await this.getAddInstanceErrorMessage();

        if (actualMessage === expectedMessage) {
            CSReporter.pass(`Error message verified: ${expectedMessage}`);
        } else {
            CSReporter.fail(`Error message mismatch. Expected: ${expectedMessage}, Actual: ${actualMessage}`);
            throw new Error('Error message verification failed');
        }
    }

    public async verifyInstanceSavedMessage(): Promise<void> {
        await this.instanceSavedMessage.waitForVisible(5000);
        const isVisible = await this.instanceSavedMessage.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.pass('Instance Saved message is displayed');
        } else {
            CSReporter.fail('Instance Saved message not found');
            throw new Error('Instance Saved message verification failed');
        }
    }

    // ===================================================================
    // CONFIRM DELETE MODAL METHODS (SCENARIO EXT11)
    // ===================================================================

    public async verifyConfirmDeleteModalOpen(): Promise<void> {
        await this.confirmDeleteModalHeader.waitForVisible(15000);
        const isVisible = await this.confirmDeleteModalHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Confirm Delete modal is open');
        } else {
            CSReporter.fail('Confirm Delete modal is not open');
            throw new Error('Confirm Delete modal verification failed');
        }
    }

    public async verifyConfirmDeleteModalClosed(): Promise<void> {
        const isVisible = await this.confirmDeleteModalHeader.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.fail('Confirm Delete modal is still open');
            throw new Error('Confirm Delete modal should be closed');
        }
        CSReporter.pass('Confirm Delete modal is closed');
    }

    public async getConfirmDeleteMessageText(): Promise<string> {
        await this.confirmDeleteMessageText.waitForVisible(10000);
        const message = await this.confirmDeleteMessageText.textContentWithTimeout(5000);
        return message?.trim() || '';
    }

    public async verifyConfirmDeleteMessage(expectedMessage: string): Promise<void> {
        const actualMessage = await this.getConfirmDeleteMessageText();

        if (actualMessage === expectedMessage) {
            CSReporter.pass(`Confirm Delete message verified: ${expectedMessage}`);
        } else {
            CSReporter.fail(`Confirm Delete message mismatch. Expected: ${expectedMessage}, Actual: ${actualMessage}`);
            throw new Error('Confirm Delete message verification failed');
        }
    }

    public async clickConfirmDeleteButton(): Promise<void> {
        await this.confirmDeleteButton.waitForVisible(10000);
        await this.confirmDeleteButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Delete button in Confirm Delete modal');
    }

    public async clickConfirmDeleteCancelButton(): Promise<void> {
        await this.confirmDeleteCancelButton.waitForVisible(10000);
        await this.confirmDeleteCancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button in Confirm Delete modal');
    }

    public async isDeleteButtonEnabled(): Promise<boolean> {
        await this.confirmDeleteButton.waitForVisible(10000);
        return await this.confirmDeleteButton.isEnabledWithTimeout(5000);
    }

    // ===================================================================
    // EXPORT METHODS (SCENARIO EXT12) - Using CSElementFactory
    // ===================================================================

    public async isExportMenuVisible(): Promise<boolean> {
        const exportMenu = CSElementFactory.createByXPath(
            `//span[@class='sssss-button__label' and text()='Export']/parent::button[@aria-label='Export']/parent::div[1]//div[@class='sssss-balloon__content']//ul[@aria-label='Export']`,
            'Export menu',
            this.page
        );
        return await exportMenu.isVisibleWithTimeout(5000);
    }

    public async verifyExportButtonState(expectedState: 'enabled' | 'disabled'): Promise<void> {
        await this.exportButton.waitForVisible(10000);
        const isEnabled = await this.exportButton.isEnabledWithTimeout(5000);

        if (expectedState === 'enabled' && isEnabled) {
            CSReporter.pass('Export button is enabled');
        } else if (expectedState === 'disabled' && !isEnabled) {
            CSReporter.pass('Export button is disabled');
        } else {
            CSReporter.fail(`Export button state mismatch. Expected: ${expectedState}`);
            throw new Error('Export button state verification failed');
        }
    }

    public async clickExportButton(): Promise<void> {
        await this.exportButton.waitForVisible(10000);
        const isEnabled = await this.exportButton.isEnabledWithTimeout(5000);

        if (!isEnabled) {
            CSReporter.fail('Export button is disabled');
            throw new Error('Cannot click disabled Export button');
        }

        await this.exportButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Export button');
    }

    public async verifyExportMenuOption(optionName: string): Promise<void> {
        const option = CSElementFactory.createByXPath(
            `//span[@class='sssss-button__label' and text()='Export']/parent::button[@aria-label='Export']/parent::div[1]//div[@class='sssss-balloon__content']//ul[@aria-label='Export']//li//span[text()='${optionName}']`,
            `Export menu option: ${optionName}`,
            this.page
        );

        await option.waitForVisible(10000);
        const isVisible = await option.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Export menu option verified: ${optionName}`);
        } else {
            CSReporter.fail(`Export menu option not found: ${optionName}`);
            throw new Error(`Export menu option verification failed: ${optionName}`);
        }
    }

    public async clickExportMenuOption(optionName: string): Promise<void> {
        const option = CSElementFactory.createByXPath(
            `//span[@class='sssss-button__label' and text()='Export']/parent::button[@aria-label='Export']/parent::div[1]//div[@class='sssss-balloon__content']//ul[@aria-label='Export']//span[text()='${optionName}']/ancestor::button[1]`,
            `Export menu option button: ${optionName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        CSReporter.info(`Clicked export menu option: ${optionName}`);
    }

    // ===================================================================
    // UTILITY METHODS
    // ===================================================================

    public async waitForPageLoad(): Promise<void> {
        await this.waitForPageLoad();
    }

    public async getColumnValues(columnName: string): Promise<string[]> {
        const columnIndex = this.getColumnIndex(columnName);
        const rowCount = await this.getTableRowCount();
        const values: string[] = [];

        for (let i = 1; i <= rowCount; i++) {
            const value = await this.getTableCellValue(i, columnIndex);
            values.push(value);
        }

        CSReporter.info(`Extracted ${values.length} values from column: ${columnName}`);
        return values;
    }

    private getColumnIndex(columnName: string): number {
        const columnMap: { [key: string]: number } = {
            'Rrrrrrrr Date': 1,
            'Mmte (%)': 2,
            'Cumulative Mmte Name': 3,
            'Source': 4,
            'Publication Date': 5,
            'Actions': 6
        };

        return columnMap[columnName] || 0;
    }

    public async verifySortedData(columnName: string, sortOrder: 'ascending' | 'descending'): Promise<void> {
        const values = await this.getColumnValues(columnName);

        if (columnName === 'Mmte (%)') {
            // Numeric sorting
            const numericValues = values.map(v => parseFloat(v.replace('%', '')));
            const sortedNumeric = [...numericValues].sort((a, b) => sortOrder === 'ascending' ? a - b : b - a);

            for (let i = 0; i < numericValues.length; i++) {
                if (numericValues[i] !== sortedNumeric[i]) {
                    CSReporter.fail(`Data not sorted correctly: ${columnName} ${sortOrder}`);
                    throw new Error(`Sort verification failed for ${columnName}`);
                }
            }
        } else if (columnName === 'Rrrrrrrr Date' || columnName === 'Publication Date') {
            // Date sorting
            const dateValues = values.map(v => new Date(v));
            const sortedDates = [...dateValues].sort((a, b) => sortOrder === 'ascending' ? a.getTime() - b.getTime() : b.getTime() - a.getTime());

            for (let i = 0; i < dateValues.length; i++) {
                if (dateValues[i].getTime() !== sortedDates[i].getTime()) {
                    CSReporter.fail(`Data not sorted correctly: ${columnName} ${sortOrder}`);
                    throw new Error(`Sort verification failed for ${columnName}`);
                }
            }
        } else {
            // String sorting
            const sortedValues = [...values].sort((a, b) => sortOrder === 'ascending' ? a.localeCompare(b) : b.localeCompare(a));

            for (let i = 0; i < values.length; i++) {
                if (values[i] !== sortedValues[i]) {
                    CSReporter.fail(`Data not sorted correctly: ${columnName} ${sortOrder}`);
                    throw new Error(`Sort verification failed for ${columnName}`);
                }
            }
        }

        CSReporter.pass(`Data verified as sorted ${sortOrder} for column: ${columnName}`);
    }

    // ===================================================================
    // ADDITIONAL METHODS FOR STEP DEFINITIONS
    // ===================================================================

    public async clickAndConditionTypeDropdown(): Promise<void> {
        const dropdown = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='And']/ancestor::div[contains(@class, 'sssss-form-field')][1]//button[@name='searchType']`,
            'And condition Type dropdown',
            this.page
        );
        await dropdown.waitForVisible(10000);
        await dropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked And condition Type dropdown');
    }

    public async selectAndConditionType(searchType: string): Promise<void> {
        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon')]//ul[@role='listbox']//li[@role='option']//span[text()='${searchType}']/parent::span`,
            `And condition type option: ${searchType}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected And condition type: ${searchType}`);
    }

    public async verifyAddInstanceButtonEnabled(): Promise<void> {
        await this.addInstanceButton.waitForVisible(10000);
        const isVisible = await this.addInstanceButton.isVisibleWithTimeout(5000);
        const isEnabled = await this.addInstanceButton.isEnabledWithTimeout(5000);

        if (isVisible && isEnabled) {
            CSReporter.pass('Add Instance button is visible and enabled');
        } else {
            CSReporter.fail('Add Instance button is not visible or enabled');
            throw new Error('Add Instance button verification failed');
        }
    }

    public async closeDropdown(): Promise<void> {
        // Click outside to close any open dropdown
        await this.cumulativeMmtesHeader.clickWithTimeout(5000);
        CSReporter.info('Closed dropdown');
    }

    public async verifyCumulativeMmteNameDropdownPresent(): Promise<void> {
        await this.cumulativeMmteNameDropdown.waitForVisible(10000);
        const isVisible = await this.cumulativeMmteNameDropdown.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Cumulative Mmte Name dropdown is present');
        } else {
            CSReporter.fail('Cumulative Mmte Name dropdown not found');
            throw new Error('Cumulative Mmte Name dropdown verification failed');
        }
    }

    public async verifyCumulativeMmteNamesPopulated(): Promise<void> {
        await this.clickCumulativeMmteNameDropdown();

        const listItem = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']`,
            'Cumulative mmte name list item',
            this.page
        );
        await listItem.waitForVisible(10000);
        const count = await listItem.count();

        if (count > 0) {
            CSReporter.pass(`Cumulative mmte names populated: ${count} items found`);
        } else {
            CSReporter.fail('No cumulative mmte names found in dropdown');
            throw new Error('Cumulative mmte names not populated');
        }

        // Close dropdown
        await this.closeDropdown();
    }

    public async verifyFromDateInputPresent(): Promise<void> {
        await this.fromDateInput.waitForVisible(10000);
        const isVisible = await this.fromDateInput.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('From date input is present');
        } else {
            CSReporter.fail('From date input not found');
            throw new Error('From date input verification failed');
        }
    }

    public async verifyToDateInputPresent(): Promise<void> {
        await this.toDateInput.waitForVisible(10000);
        const isVisible = await this.toDateInput.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('To date input is present');
        } else {
            CSReporter.fail('To date input not found');
            throw new Error('To date input verification failed');
        }
    }

    public async verifyColumnHeaderPresent(columnName: string): Promise<void> {
        const header = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//th[@role='columnheader']//span[text()='${columnName}']`,
            `Column header: ${columnName}`,
            this.page
        );

        await header.waitForVisible(10000);
        const isVisible = await header.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Column header present: ${columnName}`);
        } else {
            CSReporter.fail(`Column header not found: ${columnName}`);
            throw new Error(`Column header verification failed: ${columnName}`);
        }
    }

    public async setItemsPerPage(itemCount: number): Promise<void> {
        const dropdown = CSElementFactory.createByXPath(
            `//div[@aria-label='Cumulative Mmtes Pagination']//button[contains(@class, 'sssss-paginator__trigger')]`,
            'Items per page dropdown',
            this.page
        );
        await dropdown.waitForVisible(10000);
        await dropdown.clickWithTimeout(10000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon')]//ul[@role='listbox']//li[@role='option']//span[text()='${itemCount}']/parent::span`,
            `Items per page option: ${itemCount}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and table to refresh with new page size
        await this.page.waitForTimeout(500);
        CSReporter.info(`Set items per page to: ${itemCount}`);
    }

    public async sortColumnDescending(columnName: string): Promise<void> {
        // Click once for ascending, twice for descending
        await this.clickColumnHeader(columnName);

        // Check if already descending
        try {
            await this.verifySortState(columnName, 'descending');
        } catch {
            // Click again to get descending
            await this.clickColumnHeader(columnName);
        }
        CSReporter.info(`Sorted column ${columnName} descending`);
    }

    /**
     * Select an cumulative mmte by name in the Edit Instance modal
     * The mmte name should be determined by the step definition (using database helper)
     */
    public async selectCumulativeMmteInEditModal(mmteName: string): Promise<void> {
        await this.editInstanceCumulativeRefDropdown.waitForVisible(10000);
        await this.editInstanceCumulativeRefDropdown.clickWithTimeout(10000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[@class='sssss-listbox-option__label'][normalize-space()='${mmteName}']/parent::span`,
            `Cumulative mmte option: ${mmteName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and modal to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.info(`Selected cumulative mmte in Edit modal: ${mmteName}`);
    }

    public async getTableCellValueByColumnName(rowIndex: number, columnName: string): Promise<string> {
        const columnIndex = this.getColumnIndex(columnName);
        if (columnIndex === 0) {
            CSReporter.warn(`Unknown column name: ${columnName}`);
            return '';
        }
        return await this.getTableCellValue(rowIndex, columnIndex);
    }
}

export default TTTFCumulativeMmtesPage;


-------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Navigation Page
 * Source: SCENARIO_EXT01_CumulativeMmtes_PageElements.txt (Step 3)
 * Handles main navigation menu interactions
 */
@CSPage('tttf-navigation')
export class TTTFNavigationPage extends CSBasePage {

    // ===================================================================
    // NAVIGATION MENU ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]',
        description: 'Main navigation menu container',
        waitForVisible: true,
        alternativeLocators: ['css:nav[aria-label="main"] #sssssNavigatorBody']
    })
    public navigationContainer!: CSWebElement;

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]//a[text()="Home"]',
        description: 'Home menu item',
        waitForVisible: true,
        alternativeLocators: ['css:nav[aria-label="main"] a:has-text("Home")']
    })
    public homeMenuItem!: CSWebElement;

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]//a[text()="Cumulative Mmtes"]',
        description: 'Cumulative Mmtes menu item',
        waitForVisible: true,
        alternativeLocators: ['css:nav[aria-label="main"] a:has-text("Cumulative Mmtes")']
    })
    public cumulativeMmtesMenuItem!: CSWebElement;

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]//a[text()="Scattered Mmtes"]',
        description: 'Scattered Mmtes menu item',
        alternativeLocators: ['css:nav[aria-label="main"] a:has-text("Scattered Mmtes")']
    })
    public scatteredMmtesMenuItem!: CSWebElement;

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]//a[text()="Zeal/Premisis"]',
        description: 'Zeal/Premisis menu item',
        alternativeLocators: ['css:nav[aria-label="main"] a:has-text("Zeal/Premisis")']
    })
    public zealPremisisMenuItem!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFNavigationPage elements initialized');
    }

    // ===================================================================
    // NAVIGATION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    /**
     * Click on a menu item by name using CSElementFactory for dynamic element
     * @param menuItemName - The name of the menu item to click
     */
    public async clickMenuItem(menuItemName: string): Promise<void> {
        CSReporter.info(`Clicking menu item: ${menuItemName}`);

        // Use CSElementFactory for dynamic menu item element
        const menuItem = CSElementFactory.createByXPath(
            `//nav[@aria-label='main']/div[@id='sssssNavigatorBody']//a[text()='${menuItemName}']`,
            `Menu item: ${menuItemName}`,
            this.page
        );

        await menuItem.waitForVisible(10000);
        await menuItem.clickWithTimeout(10000);
        await this.waitForPageLoad();

        CSReporter.pass(`Clicked menu item: ${menuItemName}`);
    }

    /**
     * Verify a menu item is visible using CSElementFactory for dynamic element
     * @param menuItemName - The name of the menu item to verify
     */
    public async verifyMenuItemVisible(menuItemName: string): Promise<void> {
        CSReporter.info(`Verifying menu item visible: ${menuItemName}`);

        // Use CSElementFactory for dynamic menu item element
        const menuItem = CSElementFactory.createByXPath(
            `//nav[@aria-label='main']/div[@id='sssssNavigatorBody']//a[text()='${menuItemName}']`,
            `Menu item: ${menuItemName}`,
            this.page
        );

        await menuItem.waitForVisible(10000);
        const isVisible = await menuItem.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Menu item verified: ${menuItemName}`);
        } else {
            CSReporter.fail(`Menu item not found: ${menuItemName}`);
            throw new Error(`Menu item verification failed: ${menuItemName}`);
        }
    }

    /**
     * Navigate to Cumulative Mmtes page
     */
    public async navigateToCumulativeMmtes(): Promise<void> {
        await this.clickMenuItem('Cumulative Mmtes');
    }

    /**
     * Navigate to Home page
     */
    public async navigateToHome(): Promise<void> {
        await this.clickMenuItem('Home');
    }

    /**
     * Verify navigation container is visible
     */
    public async verifyNavigationContainerVisible(): Promise<void> {
        await this.navigationContainer.waitForVisible(10000);
        const isVisible = await this.navigationContainer.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Navigation container is visible');
        } else {
            CSReporter.fail('Navigation container not found');
            throw new Error('Navigation container verification failed');
        }
    }

    /**
     * Verify page header is visible using CSElementFactory for dynamic element
     * @param headerText - The expected header text
     */
    public async verifyPageHeader(headerText: string): Promise<void> {
        CSReporter.info(`Verifying page header: ${headerText}`);

        // Use CSElementFactory for dynamic page header element
        const header = CSElementFactory.createByXPath(
            `//h1[text()="${headerText}"]`,
            `Page header: ${headerText}`,
            this.page
        );

        await header.waitForVisible(15000);
        const isVisible = await header.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Page header verified: ${headerText}`);
        } else {
            CSReporter.fail(`Page header not found: ${headerText}`);
            throw new Error(`Page header verification failed: ${headerText}`);
        }
    }

    /**
     * Check if Pending Approvals menu item is visible
     */
    public async isPendingApprovalsMenuVisible(): Promise<boolean> {
        CSReporter.info('Checking if Pending Approvals menu item is visible');
        const menuItem = CSElementFactory.createByXPath(
            "//nav[@aria-label='main']/div[@id='sssssNavigatorBody']//a[contains(text(),'Pending Approvals')]",
            'Pending Approvals menu item',
            this.page
        );
        return await menuItem.isVisibleWithTimeout(3000);
    }

    /**
     * Click Pending Approvals menu item
     */
    public async clickPendingApprovalsMenu(): Promise<void> {
        CSReporter.info('Clicking Pending Approvals menu item');
        const menuItem = CSElementFactory.createByXPath(
            "//nav[@aria-label='main']/div[@id='sssssNavigatorBody']//a[contains(text(),'Pending Approvals')]",
            'Pending Approvals menu item',
            this.page
        );
        await menuItem.waitForVisible(10000);
        await menuItem.clickWithTimeout(10000);
        await this.waitForPageLoad();
    }

    /**
     * Verify File Upload page is displayed
     * Source: Requirement Doc - File Upload page verification
     * XPath: //span[text()='Add files']
     */
    public async verifyFileUploadPage(): Promise<void> {
        CSReporter.info('Verifying File Upload page');
        const addFilesButton = CSElementFactory.createByXPath(
            "//span[text()='Add files']",
            'Add files button',
            this.page
        );
        await addFilesButton.waitForVisible(15000);
        const isVisible = await addFilesButton.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('File Upload page verification failed - Add files button not found');
        }
        CSReporter.pass('File Upload page verified');
    }
}

export default TTTFNavigationPage;

---------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newZeal @approval @makerChecker @ND03
Feature: New Zeal Setup - Approval Flow (Maker-Checker)
  As a TTTF user
  I want to set up a new zeal with scattered mmtes and go through approval flow
  So that zeals are properly configured with maker-checker workflow

  Background:
    # Common setup for all scenarios

  @newZealSetup @fullFlow
  Scenario Outcircle: New Zeal Setup with Scattered Mmtes - Complete Maker-Checker Flow
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Sketchmark Flag: <sketchmarkFlag>
    # Output Ttcalc File: <outputTtcalcFile>
    # FFX File Inductor Type: <ffxFileInductorType>
    # Has Disputed: <hasDisputedScatteredMmte>

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get zeal for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Zeal Details
    When I click on Zeal Key link in row 1
    Then I should see Zeal Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Verify Summary Section (All Fields)
    And Summary section should be visible
    And I verify all Summary fields match database values

    # Step 6: Verify Settings Section (View Mode)
    And Use Sketchmark Replacement should show "False"
    And Output Ttcalc File should show "False"

    # Step 7: Verify No Scattered Mmtes
    And No Scattered Mmtes message should be visible
    And Save button should be disabled
    And Cancel button should be enabled

    # Step 8: Enter Edit Mode
    When I click Edit button
    Then I should see Edit Zeal page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    And Output Ttcalc File checkbox should be unchecked

    # Step 9: Configure Settings
    When I check Use Sketchmark Replacement checkbox
    And I check Output Ttcalc File checkbox
    And I verify FFX Inductor Type options against database
    And I select FFX Inductor Type "<ffxFileInductorType>"
    Then Zeal Save button should be enabled

    # Step 10: Wait for Add/Remove Button
    And I wait for Add Remove button to be visible
    And Reorder button should be visible

    # Step 11: Add Scattered Mmtes
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section
    And I verify Associated Scattered Mmtes column headers

    # Step 11b: Configure Disputed Scattered Mmtes (if required)
    And I configure disputed scattered mmtes if required

    # Step 12: Save Changes
    When I click Save button
    Then I should see save success message
    And I should see pending approval alert
    And View Changes link should be visible
    And Save button should be disabled
    And Edit button should be disabled

    # Step 13: Verify Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And I verify Changes table column headers
    And Changes table should show pending changes
    And I verify changes data matches added scattered mmtes
    And Cancel Changes button should be visible

    # Step 14: Database Validation (Before Approval)
    When I verify zeal data record exists in database
    And I verify zealpremisis data has correct settings
    Then I verify status log shows "AWAITING" status

    # Step 15: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW
    # ============================================================

    # Step 16: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 17: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 18: Find and View Zeal
    When I find and click View link for stored zeal
    Then I should see Zeal Details page

    # Step 19: Verify Changes Tab
    And View Changes link should be visible
    When I click View Changes link
    Then Changes section should be visible
    And Approve button should be visible
    And Reject button should be visible

    # Step 20: Approve Changes
    When I click Approve button
    Then Changes table should be empty after approval

    # Step 21: Verify History Tab
    When I click History tab
    Then History section should be visible
    And I verify History table column headers
    And History table should show approved changes
    And I verify history data matches approved scattered mmtes

    # Step 22: Database Validation (After Approval)
    When I verify zeal data record exists in database
    And I verify zealpremisis data has correct settings
    Then I verify status log shows "APPROVED" status
    And I verify zealpremisis mmte data exists after approval

    # Step 23: Verify Details Tab (Post Approval)
    When I click Details tab
    Then Summary section should be visible
    And Use Sketchmark Replacement should show "True"
    And Output Ttcalc File should show "True"
    And FFX Inductor Type dropdown should show "<ffxFileInductorType>"
    And Scattered mmtes should be displayed in Associated Scattered Mmtes section

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_new_zeal_setup_scenarios.json", "path": "$", "filter": "runFlag=Yes"}

--------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newPremisis @approval @makerChecker @ND04
Feature: New Premisis Setup - Approval Flow (Maker-Checker)
  As a TTTF user
  I want to set up a new premisis with scattered mmtes and go through approval flow
  So that premisis are properly configured with maker-checker workflow

  Background:
    # Common setup for all scenarios

  @newPremisisSetup @fullFlow
  Scenario Outcircle: New Premisis Setup with Scattered Mmtes - Complete Maker-Checker Flow
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Sketchmark Flag: <sketchmarkFlag>
    # Has Disputed: <hasDisputedScatteredMmte>
    # Note: Output Ttcalc File and FFX Inductor Type are DISABLED for Premisis

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get premisis for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Premisis" from Zeal Premisis Type dropdown
    And I select "Zzzt Seggregation" from Zeal Premisis Attribute dropdown
    And I enter stored "zzztSeggregation" in Zeal Premisis search field "zzztSeggregation"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Premisis Details
    When I click on Zeal Key link in row 1
    Then I should see Premisis Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Verify Summary Section (All Fields)
    And Summary section should be visible
    And I verify all Summary fields match database values

    # Step 6: Verify Settings Section (View Mode)
    And Use Sketchmark Replacement should show "False"
    And Output Ttcalc File should show "False"

    # Step 7: Verify No Scattered Mmtes
    And No Scattered Mmtes message should be visible
    And Save button should be disabled
    And Cancel button should be enabled

    # Step 8: Enter Edit Mode
    When I click Edit button
    Then I should see Edit Premisis page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked

    # Step 9: Configure Settings (Premisis - Only Sketchmark, Output/FFX disabled)
    When I check Use Sketchmark Replacement checkbox
    Then Output Ttcalc File checkbox should be disabled for Premisis
    And FFX Inductor Type dropdown should be disabled for Premisis
    And Zeal Save button should be enabled

    # Step 10: Wait for Add/Remove Button
    And I wait for Add Remove button to be visible
    And Reorder button should be visible

    # Step 11: Add Scattered Mmtes
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section
    And I verify Associated Scattered Mmtes column headers

    # Step 11b: Configure Disputed Scattered Mmtes (if required)
    And I configure disputed scattered mmtes if required

    # Step 12: Save Changes
    When I click Save button
    Then I should see save success message for Premisis
    And I should see pending approval alert
    And View Changes link should be visible
    And Save button should be disabled
    And Edit button should be disabled

    # Step 13: Verify Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And I verify Changes table column headers
    And Changes table should show pending changes
    And I verify changes data matches added scattered mmtes
    And Cancel Changes button should be visible

    # Step 14: Database Validation (Before Approval)
    When I verify zzzt data record exists in database
    And I verify zealpremisis data has correct settings for Premisis
    Then I verify status log shows "AWAITING" status

    # Step 15: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW
    # ============================================================

    # Step 16: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 17: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 18: Find and View Premisis
    When I find and click View link for stored zeal
    Then I should see Premisis Details page

    # Step 19: Verify Changes Tab
    And View Changes link should be visible
    When I click View Changes link
    Then Changes section should be visible
    And Approve button should be visible
    And Reject button should be visible

    # Step 20: Approve Changes
    When I click Approve button
    Then Changes table should be empty after approval

    # Step 21: Verify History Tab
    When I click History tab
    Then History section should be visible
    And I verify History table column headers
    And History table should show approved changes
    And I verify history data matches approved scattered mmtes

    # Step 22: Database Validation (After Approval)
    When I verify zzzt data record exists in database
    And I verify zealpremisis data has correct settings for Premisis
    Then I verify status log shows "APPROVED" status
    And I verify zealpremisis mmte data exists after approval

    # Step 23: Verify Details Tab (Post Approval)
    When I click Details tab
    Then Summary section should be visible
    And Use Sketchmark Replacement should show "True"
    And Scattered mmtes should be displayed in Associated Scattered Mmtes section

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_new_premisis_setup_scenarios.json", "path": "$", "filter": "runFlag=Yes"}

-------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newPremisis @rejection @makerChecker @ND05
Feature: New Premisis Setup - Rejection Flow (Maker-Checker)
  As a TTTF user
  I want to test rejection of new premisis setup changes by approver
  So that maker-checker rejection workflow is properly validated

  Background:
    # Common setup for all scenarios

  @newPremisisRejection @fullFlow
  Scenario Outcircle: New Premisis Setup with Scattered Mmtes - Rejection by Approver
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Expected Result: Changes REJECTED by Approver

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get premisis for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Premisis" from Zeal Premisis Type dropdown
    And I select "Zzzt Seggregation" from Zeal Premisis Attribute dropdown
    And I enter stored "zzztSeggregation" in Zeal Premisis search field "zzztSeggregation"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Premisis Details and Edit
    When I click on Zeal Key link in row 1
    Then I should see Premisis Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Enter Edit Mode and Configure
    When I click Edit button
    Then I should see Edit Premisis page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    When I check Use Sketchmark Replacement checkbox

    # Step 6: Add Scattered Mmtes
    And I wait for Add Remove button to be visible
    And Reorder button should be visible
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section
    And I verify Associated Scattered Mmtes column headers
    And I configure disputed scattered mmtes if required

    # Step 7: Save Changes
    When I click Save button
    Then I should see save success message for Premisis
    And I should see pending approval alert

    # Step 8: Database Validation (Before Rejection)
    When I verify zzzt data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 9: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW - REJECTION
    # ============================================================

    # Step 10: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 11: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 12: Find and View Premisis
    When I find and click View link for stored zeal
    Then I should see Premisis Details page

    # Step 13: Navigate to Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And I verify Changes table column headers
    And Approve button should be visible
    And Reject button should be visible

    # Step 14: Reject Changes
    When I click Reject button
    Then Review Reject Email modal should be visible
    And Reject comment textarea should be visible
    And Send button should be visible

    # Step 15: Send Rejection
    When I click Send button in Reject modal
    Then Rejection email sent message should be displayed
    And Changes table should be empty after rejection

    # Step 16: Verify History Tab (No History for Rejected Changes)
    When I click History tab
    Then History section should be visible
    And History table should show no data

    # Step 17: Database Validation (After Rejection)
    Then I verify status log is cleared after rejection
    And I verify zealpremisis mmte data does not exist after rejection

    # Step 18: Verify Details Tab (Post Rejection)
    When I click Details tab
    Then Summary section should be visible
    And No Scattered Mmtes message should be visible

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_rejection_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Premisis"}

--------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newZeal @rejection @makerChecker @ND06A
Feature: New Zeal Setup - Rejection Flow (Maker-Checker)
  As a TTTF user
  I want to test rejection of new zeal setup changes by approver
  So that maker-checker rejection workflow is properly validated

  Background:
    # Common setup for all scenarios

  @newZealRejection @fullFlow
  Scenario Outcircle: New Zeal Setup with Scattered Mmtes - Rejection by Approver
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Expected Result: Changes REJECTED by Approver

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get zeal for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Zeal Details and Edit
    When I click on Zeal Key link in row 1
    Then I should see Zeal Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Enter Edit Mode and Configure
    When I click Edit button
    Then I should see Edit Zeal page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    And Output Ttcalc File checkbox should be unchecked
    When I check Use Sketchmark Replacement checkbox
    And I check Output Ttcalc File checkbox
    And I select FFX Inductor Type "<ffxFileInductorType>"

    # Step 6: Add Scattered Mmtes
    And I wait for Add Remove button to be visible
    And Reorder button should be visible
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section
    And I verify Associated Scattered Mmtes column headers
    And I configure disputed scattered mmtes if required

    # Step 7: Save Changes
    When I click Save button
    Then I should see save success message
    And I should see pending approval alert

    # Step 8: Database Validation (Before Rejection)
    When I verify zeal data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 9: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW - REJECTION
    # ============================================================

    # Step 10: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 11: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 12: Find and View Zeal
    When I find and click View link for stored zeal
    Then I should see Zeal Details page

    # Step 13: Navigate to Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And I verify Changes table column headers
    And Approve button should be visible
    And Reject button should be visible

    # Step 14: Reject Changes
    When I click Reject button
    Then Review Reject Email modal should be visible
    And Reject comment textarea should be visible
    And Send button should be visible

    # Step 15: Send Rejection
    When I click Send button in Reject modal
    Then Rejection email sent message should be displayed
    And Changes table should be empty after rejection

    # Step 16: Verify History Tab (No History for Rejected Changes)
    When I click History tab
    Then History section should be visible
    And History table should show no data

    # Step 17: Database Validation (After Rejection)
    Then I verify status log is cleared after rejection
    And I verify zealpremisis mmte data does not exist after rejection

    # Step 18: Verify Details Tab (Post Rejection)
    When I click Details tab
    Then Summary section should be visible
    And No Scattered Mmtes message should be visible

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_rejection_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Zeal"}


----------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newZeal @cancel @ND06B
Feature: New Zeal Setup - Cancel Changes Flow
  As a TTTF user
  I want to cancel my own pending changes before approval
  So that I can undo changes without involving the approver

  Background:
    # Common setup for all scenarios

  @newZealCancel @fullFlow
  Scenario Outcircle: New Zeal Setup with Scattered Mmtes - Cancel by Requester
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # User: <requesterUser>
    # Expected Result: Changes CANCELLED by Requester (no approver needed)

    # ============================================================
    # SINGLE USER FLOW (REQUESTER ONLY)
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get zeal for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Zeal Details and Edit
    When I click on Zeal Key link in row 1
    Then I should see Zeal Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Enter Edit Mode and Configure
    When I click Edit button
    Then I should see Edit Zeal page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    And Output Ttcalc File checkbox should be unchecked
    When I check Use Sketchmark Replacement checkbox
    And I check Output Ttcalc File checkbox
    And I select FFX Inductor Type "<ffxFileInductorType>"

    # Step 6: Add Scattered Mmtes
    And I wait for Add Remove button to be visible
    And Reorder button should be visible
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section
    And I verify Associated Scattered Mmtes column headers
    And I configure disputed scattered mmtes if required

    # Step 7: Save Changes
    When I click Save button
    Then I should see save success message
    And I should see pending approval alert

    # Step 8: Navigate to Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And Cancel Changes button should be visible

    # Step 9: Database Validation (Before Cancel)
    When I verify zeal data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 10: Cancel Changes
    When I click Cancel Changes button
    Then Cancel changes success message should be displayed
    And Changes table should be empty after cancel

    # Step 11: Verify History Tab (No History for Cancelled Changes)
    When I click History tab
    Then History section should be visible
    And History table should show no data

    # Step 12: Database Validation (After Cancel)
    Then I verify status log is cleared after cancel
    And I verify zealpremisis mmte data does not exist after cancel

    # Step 13: Verify Details Tab (Post Cancel)
    When I click Details tab
    Then Summary section should be visible
    And No Scattered Mmtes message should be visible

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_cancel_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Zeal"}


-------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newPremisis @cancel @ND07
Feature: New Premisis Setup - Cancel Changes Flow
  As a TTTF user
  I want to cancel my own pending changes before approval
  So that I can undo changes without involving the approver

  Background:
    # Common setup for all scenarios

  @newPremisisCancel @fullFlow
  Scenario Outcircle: New Premisis Setup with Scattered Mmtes - Cancel by Requester
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # User: <requesterUser>
    # Expected Result: Changes CANCELLED by Requester (no approver needed)

    # ============================================================
    # SINGLE USER FLOW (REQUESTER ONLY)
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get premisis for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Premisis" from Zeal Premisis Type dropdown
    And I select "Zzzt Seggregation" from Zeal Premisis Attribute dropdown
    And I enter stored "zzztSeggregation" in Zeal Premisis search field "zzztSeggregation"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Premisis Details and Edit
    When I click on Zeal Key link in row 1
    Then I should see Premisis Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Enter Edit Mode and Configure
    When I click Edit button
    Then I should see Edit Premisis page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    When I check Use Sketchmark Replacement checkbox

    # Step 6: Add Scattered Mmtes
    And I wait for Add Remove button to be visible
    And Reorder button should be visible
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section
    And I verify Associated Scattered Mmtes column headers
    And I configure disputed scattered mmtes if required

    # Step 7: Save Changes
    When I click Save button
    Then I should see save success message for Premisis
    And I should see pending approval alert

    # Step 8: Navigate to Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And Cancel Changes button should be visible

    # Step 9: Database Validation (Before Cancel)
    When I verify zzzt data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 10: Cancel Changes
    When I click Cancel Changes button
    Then Cancel changes success message should be displayed
    And Changes table should be empty after cancel

    # Step 11: Verify History Tab (No History for Cancelled Changes)
    When I click History tab
    Then History section should be visible
    And History table should show no data

    # Step 12: Database Validation (After Cancel)
    Then I verify status log is cleared after cancel
    And I verify zealpremisis mmte data does not exist after cancel

    # Step 13: Verify Details Tab (Post Cancel)
    When I click Details tab
    Then Summary section should be visible
    And No Scattered Mmtes message should be visible

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_cancel_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Premisis"}


----------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @existingZeal @update @approval @makerChecker @DS09B
Feature: Existing Zeal Update - Approval Flow (Maker-Checker)
  As a TTTF user
  I want to update an existing zeal with scattered mmtes and go through approval flow
  So that existing zeals can be properly modified with maker-checker workflow

  Background:
    # Common setup for all scenarios

  @existingZealUpdate @fullFlow
  Scenario Outcircle: Existing Zeal Update with Scattered Mmtes - Complete Maker-Checker Flow
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Update Sketchmark Flag: <updateSketchmarkFlag>
    # Update FFX Inductor Type: <updateFfxInductorType>
    # Update Scattered Mmtes: <updateScatteredMmtes>

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get existing zeal with scattered mmtes from database
    And I get replacement scattered mmtes from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I uncheck Include Premisis in results checkbox
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Zeal Details
    When I click on Zeal Key link in row 1
    Then I should see Zeal Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Verify Existing Scattered Mmtes
    And Scattered mmtes should be displayed in Associated Scattered Mmtes section
    And I verify existing scattered mmtes match database

    # Step 6: Enter Edit Mode
    When I click Edit button
    Then I should see Edit Zeal page

    # Step 7: Toggle Sketchmark Flag
    When I toggle Use Sketchmark Replacement checkbox

    # Step 8: Update FFX Inductor Type (if applicable)
    And I update FFX Inductor Type to different value

    # Step 9: Update Scattered Mmtes
    When I click Add Remove button
    Then Select Options modal should be visible
    When I unselect existing scattered mmtes in modal
    And I select replacement scattered mmtes in modal
    And I click Apply button in modal
    Then Updated scattered mmtes should be displayed in Associated Scattered Mmtes section

    # Step 10: Save Changes
    When I click Save button
    Then I should see save success message
    And I should see pending approval alert
    And View Changes link should be visible

    # Step 11: Verify Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And I verify Changes table column headers
    And Changes table should show update changes
    And Cancel Changes button should be visible

    # Step 12: Database Validation (Before Approval)
    When I verify zeal data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 13: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW
    # ============================================================

    # Step 14: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 15: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 16: Find and View Zeal
    When I find and click View link for stored zeal
    Then I should see Zeal Details page

    # Step 17: Verify Changes Tab
    And View Changes link should be visible
    When I click View Changes link
    Then Changes section should be visible
    And Approve button should be visible
    And Reject button should be visible

    # Step 18: Approve Changes
    When I click Approve button
    Then Approve Email modal should be visible
    When I click Send button in Approve modal
    Then Approval email sent message should be displayed
    And Changes table should be empty after approval

    # Step 19: Verify History Tab
    When I click History tab
    Then History section should be visible
    And I verify History table column headers
    And History table should show approved changes

    # Step 20: Database Validation (After Approval)
    When I verify zeal data record exists in database
    Then I verify status log shows "APPROVED" status
    And I verify updated scattered mmtes in database

    # Step 21: Verify Details Tab (Post Approval)
    When I click Details tab
    Then Summary section should be visible
    And Updated scattered mmtes should be displayed in Associated Scattered Mmtes section

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_existing_zeal_update_scenarios.json", "path": "$", "filter": "runFlag=Yes"}

