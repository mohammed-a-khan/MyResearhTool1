@smoke @regression @home @navigation @SC01
Feature: Home Page and Navigation Verification
  As a TTTF user
  I want to verify the home page elements and navigation menu
  So that I can confirm the application is properly loaded and accessible

  Background:
    # Common setup for all scenarios

  @homePageVerification
  Scenario Outcircle: Home Page Elements and Navigation Menu Verification
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # User: <userName>

    # ============================================================
    # PART A: LOGIN AND HOME PAGE VERIFICATION
    # ============================================================

    # Step 1: Login to TTTF Application
    When I login to TTTF as "<userName>"

    # Step 2: Verify Home Page Header
    Then I should see the Home page
    And I should see page header "Home"

    # Step 3: Verify Welcome Message with Username
    And I should see welcome message with username "<userName>"

    # ============================================================
    # PART B: NAVIGATION MENU VERIFICATION
    # ============================================================

    # Step 4: Verify Navigation Menu Container
    And I should see navigation menu

    # Step 5: Verify All Menu Items Present
    And I should see menu item "Home"
    And I should see menu item "Zeal/Premisis"
    And I should see menu item "Scattered Mmtes"
    And I should see menu item "Mmte History"
    And I should see menu item "Cumulative Mmtes"
    And I should see menu item "File Upload"

    # Step 6: Check Pending Approvals Menu (Conditional - may or may not exist)
    And I check if Pending Approvals menu exists

    # ============================================================
    # PART C: NAVIGATION TO EACH PAGE AND BACK
    # ============================================================

    # Step 7: Navigate to Home and Verify
    When I click on menu item "Home"
    Then I should see page header "Home"

    # Step 8: Navigate to Zeal/Premisis and Verify
    When I click on menu item "Zeal/Premisis"
    Then I should see page header "Zeals/Premisis"

    # Step 9: Navigate to Scattered Mmtes and Verify
    When I click on menu item "Scattered Mmtes"
    Then I should see page header "Scattered Mmtes"

    # Step 10: Navigate to Mmte History and Verify
    When I click on menu item "Mmte History"
    Then I should see page header "Mmte History"

    # Step 11: Navigate to Cumulative Mmtes and Verify
    When I click on menu item "Cumulative Mmtes"
    Then I should see page header "Cumulative Mmtes"

    # Step 12: Navigate to File Upload and Verify
    When I click on menu item "File Upload"
    Then I should see File Upload page

    # Step 13: Navigate to Pending Approvals (Conditional)
    When I navigate to Pending Approvals if exists
    Then I verify Pending Approvals page if navigated

    # ============================================================
    # PART D: COMMON TASKS SECTION VERIFICATION
    # ============================================================

    # Step 14: Return to Home Page
    When I click on menu item "Home"
    Then I should see page header "Home"

    # Step 15: Verify Common Tasks Header
    And I should see Common Tasks section

    # Step 16: Verify Research Zeal/Premisis Card
    And I should see Common Tasks card "Research Zeal/Premisis"
    And Common Tasks card "Research Zeal/Premisis" should have button "Search Zeal/Premisis"

    # Step 17: Verify Explore Mmtes Card
    And I should see Common Tasks card "Explore Mmtes"
    And Common Tasks card "Explore Mmtes" should have button "View Mmtes"

    # Step 18: Verify Create New Scattered Mmte Card
    And I should see Common Tasks card "Create New Scattered Mmte"
    And Common Tasks card "Create New Scattered Mmte" should have button "New Scattered Mmte"

    # Step 19: Verify Lookup Cumulative Mmtes Card
    And I should see Common Tasks card "Lookup Cumulative Mmtes"
    And Common Tasks card "Lookup Cumulative Mmtes" should have button "Search Cumulative Mmtes"

    # Step 20: Check Pending Approvals Card (Conditional)
    And I check if Pending Approvals card exists

    # ============================================================
    # PART E: COMMON TASKS CARDS NAVIGATION
    # ============================================================

    # Step 21: Click Search Zeal/Premisis Button and Verify Navigation
    When I click Common Tasks button "Search Zeal/Premisis"
    Then I should see page header "Zeals/Premisis"
    When I click on menu item "Home"

    # Step 22: Click View Mmtes Button and Verify Navigation
    When I click Common Tasks button "View Mmtes"
    Then I should see page header "Scattered Mmtes"
    When I click on menu item "Home"

    # Step 23: Click New Scattered Mmte Button and Verify Navigation
    When I click Common Tasks button "New Scattered Mmte"
    Then I should see page header "Add Scattered Mmte"
    When I click on menu item "Home"

    # Step 24: Click Search Cumulative Mmtes Button and Verify Navigation
    When I click Common Tasks button "Search Cumulative Mmtes"
    Then I should see page header "Cumulative Mmtes"
    When I click on menu item "Home"

    # Step 25: Click Pending Approvals Button (Conditional)
    When I click Pending Approvals card button if exists
    Then I verify Pending Approvals page if card clicked

    Examples: {"type": "json", "source": "test/tttf/data/home_navigation_scenarios.json", "path": "$", "filter": "runFlag=Yes"}

---------------------------------------------------------------------------------------------------------------------------------------------------------

import { CSBDDStepDef, Page, StepDefinitions } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSBDDContext, CSScenarioContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSValueResolver } from '@mdakhan.mak/cs-playwright-test-framework/utilities';
import { TTTFZealPremisisPage } from '../pages/TTTFZealPremisisPage';
import { TTTFNavigationPage } from '../pages/TTTFNavigationPage';
import { TTTFDatabaseHelper, ZealPremisisSearchResult } from '../helpers/TTTFDatabaseHelper';

/**
 * TTTF Zeal Premisis Step Definitions
 * Source: SCENARIO_02_ZealsPremisisSearch_AllTypes.txt
 * Handles all Zeal/Premisis search page interactions
 * All element interactions delegated to Page Objects
 * All database operations delegated to TTTFDatabaseHelper
 */
@StepDefinitions
export class TTTFZealPremisisSteps {

    @Page('tttf-zeal-premisis')
    private zealPremisisPage!: TTTFZealPremisisPage;

    @Page('tttf-navigation')
    private navigationPage!: TTTFNavigationPage;

    private context = CSBDDContext.getInstance();
    private scenarioContext = CSScenarioContext.getInstance();

    // ===================================================================
    // NAVIGATION STEPS
    // ===================================================================

    @CSBDDStepDef('I navigate to Zeals Premisis page')
    async navigateToZealPremisisPage(): Promise<void> {
        CSReporter.info('Navigating to Zeals/Premisis page');
        await this.navigationPage.clickMenuItem('Zeal/Premisis');
        await this.zealPremisisPage.verifyPageHeader();
        CSReporter.pass('Navigated to Zeals/Premisis page');
    }

    @CSBDDStepDef('I click on Zeal Premisis menu item')
    async clickZealPremisisMenuItem(): Promise<void> {
        CSReporter.info('Clicking Zeal/Premisis menu item');
        await this.navigationPage.clickMenuItem('Zeal/Premisis');
        CSReporter.pass('Clicked Zeal/Premisis menu item');
    }

    // ===================================================================
    // PAGE VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeals Premisis page header')
    async verifyZealPremisisPageHeader(): Promise<void> {
        CSReporter.info('Verifying Zeals/Premisis page header');
        await this.zealPremisisPage.verifyPageHeader();
        CSReporter.pass('Zeals/Premisis page header verified');
    }

    @CSBDDStepDef('I should see Zeal Premisis Search section')
    async verifyZealPremisisSearchSection(): Promise<void> {
        CSReporter.info('Verifying Zeal/Premisis Search section');
        await this.zealPremisisPage.verifySearchSectionVisible();
        await this.zealPremisisPage.verifySearchByHeaderVisible();
        CSReporter.pass('Zeal/Premisis Search section verified');
    }

    @CSBDDStepDef('Zeal Premisis Search section should be expanded')
    async verifyZealPremisisSearchSectionExpanded(): Promise<void> {
        CSReporter.info('Verifying Zeal/Premisis Search section is expanded');
        await this.zealPremisisPage.verifySearchSectionExpanded();
        CSReporter.pass('Zeal/Premisis Search section is expanded');
    }

    @CSBDDStepDef('I expand Zeal Premisis Search section')
    async expandZealPremisisSearchSection(): Promise<void> {
        CSReporter.info('Expanding Zeal/Premisis Search section');
        await this.zealPremisisPage.expandSearchSection();
        CSReporter.pass('Expanded Zeal/Premisis Search section');
    }

    @CSBDDStepDef('I collapse Zeal Premisis Search section')
    async collapseZealPremisisSearchSection(): Promise<void> {
        CSReporter.info('Collapsing Zeal/Premisis Search section');
        await this.zealPremisisPage.collapseSearchSection();
        CSReporter.pass('Collapsed Zeal/Premisis Search section');
    }

    // ===================================================================
    // TYPE DROPDOWN STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Premisis Type dropdown')
    async verifyZealPremisisTypeDropdown(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Type dropdown');
        await this.zealPremisisPage.verifyTypeDropdownVisible();
        CSReporter.pass('Zeal Premisis Type dropdown verified');
    }

    @CSBDDStepDef('Zeal Premisis Type dropdown should show {string} by default')
    async verifyZealPremisisDefaultType(expectedType: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(expectedType, this.context);
        CSReporter.info(`Verifying default Type selection: ${resolvedType}`);
        const selectedType = await this.zealPremisisPage.getSelectedType();
        if (selectedType !== resolvedType) {
            CSReporter.fail(`Expected Type '${resolvedType}' but found '${selectedType}'`);
            throw new Error(`Type dropdown default value mismatch`);
        }
        CSReporter.pass(`Type dropdown shows '${resolvedType}' by default`);
    }

    @CSBDDStepDef('I select {string} from Zeal Premisis Type dropdown')
    async selectZealPremisisType(searchType: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(searchType, this.context);
        CSReporter.info(`Selecting Zeal Premisis Type: ${resolvedType}`);
        await this.zealPremisisPage.selectSearchType(resolvedType);
        this.scenarioContext.setVariable('selectedSearchType', resolvedType);
        CSReporter.pass(`Selected Zeal Premisis Type: ${resolvedType}`);
    }

    @CSBDDStepDef('I should see Zeal Premisis Type dropdown options {string}')
    async verifyZealPremisisTypeOptions(optionsString: string): Promise<void> {
        const expectedOptions = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying Type dropdown options: ${expectedOptions.join(', ')}`);
        const actualOptions = await this.zealPremisisPage.getTypeDropdownOptions();

        for (const expected of expectedOptions) {
            if (!actualOptions.includes(expected)) {
                CSReporter.fail(`Type option '${expected}' not found in dropdown`);
                throw new Error(`Missing Type option: ${expected}`);
            }
        }
        CSReporter.pass('All Type dropdown options verified');
    }

    // ===================================================================
    // ATTRIBUTE DROPDOWN STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Premisis Attribute dropdown')
    async verifyZealPremisisAttributeDropdown(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Attribute dropdown');
        await this.zealPremisisPage.verifyAttributeDropdownVisible();
        CSReporter.pass('Zeal Premisis Attribute dropdown verified');
    }

    @CSBDDStepDef('Zeal Premisis Attribute dropdown should not be visible')
    async verifyZealPremisisAttributeDropdownNotVisible(): Promise<void> {
        CSReporter.info('Verifying Attribute dropdown is not visible');
        const isVisible = await this.zealPremisisPage.isAttributeDropdownVisible();
        if (isVisible) {
            CSReporter.fail('Attribute dropdown is visible but should not be');
            throw new Error('Attribute dropdown should not be visible');
        }
        CSReporter.pass('Attribute dropdown is not visible');
    }

    @CSBDDStepDef('I select {string} from Zeal Premisis Attribute dropdown')
    async selectZealPremisisAttribute(attribute: string): Promise<void> {
        const resolvedAttribute = CSValueResolver.resolve(attribute, this.context);
        CSReporter.info(`Selecting Zeal Premisis Attribute: ${resolvedAttribute}`);
        await this.zealPremisisPage.selectAttribute(resolvedAttribute);
        this.scenarioContext.setVariable('selectedAttribute', resolvedAttribute);
        CSReporter.pass(`Selected Zeal Premisis Attribute: ${resolvedAttribute}`);
    }

    @CSBDDStepDef('I should see Zeal Premisis Attribute options {string}')
    async verifyZealPremisisAttributeOptions(optionsString: string): Promise<void> {
        const expectedOptions = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying Attribute dropdown options: ${expectedOptions.join(', ')}`);
        const actualOptions = await this.zealPremisisPage.getAttributeDropdownOptions();

        for (const expected of expectedOptions) {
            if (!actualOptions.includes(expected)) {
                CSReporter.fail(`Attribute option '${expected}' not found in dropdown`);
                throw new Error(`Missing Attribute option: ${expected}`);
            }
        }
        CSReporter.pass('All Attribute dropdown options verified');
    }

    // ===================================================================
    // INCLUDE PREMISIS CHECKBOX STEPS
    // ===================================================================

    @CSBDDStepDef('Include Premisis checkbox should be enabled')
    async verifyIncludePremisisCheckboxEnabled(): Promise<void> {
        CSReporter.info('Verifying Include Premisis checkbox is enabled');
        const isEnabled = await this.zealPremisisPage.isIncludePremisisEnabled();
        if (!isEnabled) {
            CSReporter.fail('Include Premisis checkbox is disabled');
            throw new Error('Include Premisis checkbox should be enabled');
        }
        CSReporter.pass('Include Premisis checkbox is enabled');
    }

    @CSBDDStepDef('Include Premisis checkbox should be disabled')
    async verifyIncludePremisisCheckboxDisabled(): Promise<void> {
        CSReporter.info('Verifying Include Premisis checkbox is disabled');
        const isEnabled = await this.zealPremisisPage.isIncludePremisisEnabled();
        if (isEnabled) {
            CSReporter.fail('Include Premisis checkbox is enabled but should be disabled');
            throw new Error('Include Premisis checkbox should be disabled');
        }
        CSReporter.pass('Include Premisis checkbox is disabled');
    }

    @CSBDDStepDef('Include Premisis checkbox should be unchecked')
    async verifyIncludePremisisCheckboxUnchecked(): Promise<void> {
        CSReporter.info('Verifying Include Premisis checkbox is unchecked');
        const isChecked = await this.zealPremisisPage.isIncludePremisisChecked();
        if (isChecked) {
            CSReporter.fail('Include Premisis checkbox is checked but should be unchecked');
            throw new Error('Include Premisis checkbox should be unchecked');
        }
        CSReporter.pass('Include Premisis checkbox is unchecked');
    }

    @CSBDDStepDef('Include Premisis checkbox should be checked')
    async verifyIncludePremisisCheckboxChecked(): Promise<void> {
        CSReporter.info('Verifying Include Premisis checkbox is checked');
        const isChecked = await this.zealPremisisPage.isIncludePremisisChecked();
        if (!isChecked) {
            CSReporter.fail('Include Premisis checkbox is unchecked but should be checked');
            throw new Error('Include Premisis checkbox should be checked');
        }
        CSReporter.pass('Include Premisis checkbox is checked');
    }

    @CSBDDStepDef('I check Include Premisis checkbox')
    async checkIncludePremisisCheckbox(): Promise<void> {
        CSReporter.info('Checking Include Premisis checkbox');
        await this.zealPremisisPage.checkIncludePremisis();
        this.scenarioContext.setVariable('includePremisisInSearch', true);
        CSReporter.pass('Include Premisis checkbox checked');
    }

    @CSBDDStepDef('I uncheck Include Premisis checkbox')
    async uncheckIncludePremisisCheckbox(): Promise<void> {
        CSReporter.info('Unchecking Include Premisis checkbox');
        await this.zealPremisisPage.uncheckIncludePremisis();
        this.scenarioContext.setVariable('includePremisisInSearch', false);
        CSReporter.pass('Include Premisis checkbox unchecked');
    }

    // ===================================================================
    // INPUT FIELD VISIBILITY STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Name input field should be visible')
    async verifyZealNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal Name input field is visible');
        const isVisible = await this.zealPremisisPage.zealNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Zeal Name input field is not visible');
        }
        CSReporter.pass('Zeal Name input field is visible');
    }

    @CSBDDStepDef('Zeal ID input field should be visible')
    async verifyZealIdInputVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal ID input field is visible');
        const isVisible = await this.zealPremisisPage.zealIdInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Zeal ID input field is not visible');
        }
        CSReporter.pass('Zeal ID input field is visible');
    }

    @CSBDDStepDef('Zeal Key input field should be visible')
    async verifyZealKeyInputVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal Key input field is visible');
        const isVisible = await this.zealPremisisPage.zealKeyInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Zeal Key input field is not visible');
        }
        CSReporter.pass('Zeal Key input field is visible');
    }

    @CSBDDStepDef('Premisis Description input field should be visible')
    async verifyPremisisDescriptionInputVisible(): Promise<void> {
        CSReporter.info('Verifying Premisis Description input field is visible');
        const isVisible = await this.zealPremisisPage.premisisDescriptionInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Premisis Description input field is not visible');
        }
        CSReporter.pass('Premisis Description input field is visible');
    }

    @CSBDDStepDef('Zzzt Seggregation input field should be visible')
    async verifyZzztSeggregationInputVisible(): Promise<void> {
        CSReporter.info('Verifying Zzzt Seggregation input field is visible');
        const isVisible = await this.zealPremisisPage.zzztSeggregationInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Zzzt Seggregation input field is not visible');
        }
        CSReporter.pass('Zzzt Seggregation input field is visible');
    }

    @CSBDDStepDef('Scattered Mmte Name input field should be visible')
    async verifyScatteredMmteNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Scattered Mmte Name input field is visible');
        const isVisible = await this.zealPremisisPage.scatteredMmteNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Scattered Mmte Name input field is not visible');
        }
        CSReporter.pass('Scattered Mmte Name input field is visible');
    }

    @CSBDDStepDef('Disputed Mmte Name input field should be visible')
    async verifyDisputedMmteNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Disputed Mmte Name input field is visible');
        const isVisible = await this.zealPremisisPage.disputedMmteNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Disputed Mmte Name input field is not visible');
        }
        CSReporter.pass('Disputed Mmte Name input field is visible');
    }

    @CSBDDStepDef('Disputed Date input field should be visible')
    async verifyDisputedDateInputVisible(): Promise<void> {
        CSReporter.info('Verifying Disputed Date input field is visible');
        const isVisible = await this.zealPremisisPage.disputedDateInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Disputed Date input field is not visible');
        }
        CSReporter.pass('Disputed Date input field is visible');
    }

    @CSBDDStepDef('Administrator Name input field should be visible')
    async verifyAdministratorNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Administrator Name input field is visible');
        const isVisible = await this.zealPremisisPage.administratorNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Administrator Name input field is not visible');
        }
        CSReporter.pass('Administrator Name input field is visible');
    }

    @CSBDDStepDef('Administrator Email input field should be visible')
    async verifyAdministratorEmailInputVisible(): Promise<void> {
        CSReporter.info('Verifying Administrator Email input field is visible');
        const isVisible = await this.zealPremisisPage.administratorEmailInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Administrator Email input field is not visible');
        }
        CSReporter.pass('Administrator Email input field is visible');
    }

    @CSBDDStepDef('Calc Shool Name input field should be visible')
    async verifyCalcShoolNameInputVisible(): Promise<void> {
        CSReporter.info('Verifying Calc Shool Name input field is visible');
        const isVisible = await this.zealPremisisPage.gggNameInput.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Calc Shool Name input field is not visible');
        }
        CSReporter.pass('Calc Shool Name input field is visible');
    }

    // ===================================================================
    // DROPDOWN VISIBILITY STEPS
    // ===================================================================

    @CSBDDStepDef('Scattered Mmte Cumulative Mmte dropdown should be visible')
    async verifyScatteredMmteCumulativeDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Scattered Mmte Cumulative Mmte dropdown is visible');
        const isVisible = await this.zealPremisisPage.scatteredMmteCumulativeMmteDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Scattered Mmte Cumulative Mmte dropdown is not visible');
        }
        CSReporter.pass('Scattered Mmte Cumulative Mmte dropdown is visible');
    }

    @CSBDDStepDef('Has Disputed dropdown should be visible')
    async verifyHasDisputedDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Has Disputed dropdown is visible');
        const isVisible = await this.zealPremisisPage.hasDisputedDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Has Disputed dropdown is not visible');
        }
        CSReporter.pass('Has Disputed dropdown is visible');
    }

    @CSBDDStepDef('Disputed Cumulative Mmte dropdown should be visible')
    async verifyDisputedCumulativeDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Disputed Cumulative Mmte dropdown is visible');
        const isVisible = await this.zealPremisisPage.disputedCumulativeMmteDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Disputed Cumulative Mmte dropdown is not visible');
        }
        CSReporter.pass('Disputed Cumulative Mmte dropdown is visible');
    }

    @CSBDDStepDef('Inductor Group Name dropdown should be visible')
    async verifyInductorGroupDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Inductor Group Name dropdown is visible');
        const isVisible = await this.zealPremisisPage.inductorGroupDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Inductor Group Name dropdown is not visible');
        }
        CSReporter.pass('Inductor Group Name dropdown is visible');
    }

    @CSBDDStepDef('Kindness Circle Name dropdown should be visible')
    async verifyKindnessCircleDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Kindness Circle Name dropdown is visible');
        const isVisible = await this.zealPremisisPage.kindnessCircleDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Kindness Circle Name dropdown is not visible');
        }
        CSReporter.pass('Kindness Circle Name dropdown is visible');
    }

    @CSBDDStepDef('Sketchmark Flag dropdown should be visible')
    async verifySketchmarkFlagDropdownVisible(): Promise<void> {
        CSReporter.info('Verifying Sketchmark Flag dropdown is visible');
        const isVisible = await this.zealPremisisPage.sketchmarkFlagDropdown.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Sketchmark Flag dropdown is not visible');
        }
        CSReporter.pass('Sketchmark Flag dropdown is visible');
    }

    // ===================================================================
    // ENTER TEXT IN SPECIFIC FIELDS STEPS
    // ===================================================================

    @CSBDDStepDef('I enter {string} in Zeal Name input field')
    async enterZealNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Zeal Name field`);
        await this.zealPremisisPage.enterSearchValue('zealName', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Zeal Name field`);
    }

    @CSBDDStepDef('I clear Zeal Name input field')
    async clearZealNameField(): Promise<void> {
        CSReporter.info('Clearing Zeal Name input field');
        await this.zealPremisisPage.zealNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Zeal Name input field');
    }

    @CSBDDStepDef('I enter {string} in Zeal ID input field')
    async enterZealIdValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Zeal ID field`);
        await this.zealPremisisPage.enterSearchValue('zealId', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Zeal ID field`);
    }

    @CSBDDStepDef('I clear Zeal ID input field')
    async clearZealIdField(): Promise<void> {
        CSReporter.info('Clearing Zeal ID input field');
        await this.zealPremisisPage.zealIdInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Zeal ID input field');
    }

    @CSBDDStepDef('I enter {string} in Zeal Key input field')
    async enterZealKeyValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Zeal Key field`);
        await this.zealPremisisPage.enterSearchValue('zealKey', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Zeal Key field`);
    }

    @CSBDDStepDef('I clear Zeal Key input field')
    async clearZealKeyField(): Promise<void> {
        CSReporter.info('Clearing Zeal Key input field');
        await this.zealPremisisPage.zealKeyInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Zeal Key input field');
    }

    @CSBDDStepDef('I enter {string} in Premisis Description input field')
    async enterPremisisDescriptionValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Premisis Description field`);
        await this.zealPremisisPage.enterSearchValue('premisisDescription', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Premisis Description field`);
    }

    @CSBDDStepDef('I clear Premisis Description input field')
    async clearPremisisDescriptionField(): Promise<void> {
        CSReporter.info('Clearing Premisis Description input field');
        await this.zealPremisisPage.premisisDescriptionInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Premisis Description input field');
    }

    @CSBDDStepDef('I enter {string} in Zzzt Seggregation input field')
    async enterZzztSeggregationValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Zzzt Seggregation field`);
        await this.zealPremisisPage.enterSearchValue('zzztSeggregation', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Zzzt Seggregation field`);
    }

    @CSBDDStepDef('I clear Zzzt Seggregation input field')
    async clearZzztSeggregationField(): Promise<void> {
        CSReporter.info('Clearing Zzzt Seggregation input field');
        await this.zealPremisisPage.zzztSeggregationInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Zzzt Seggregation input field');
    }

    @CSBDDStepDef('I enter {string} in Scattered Mmte Name input field')
    async enterScatteredMmteNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Scattered Mmte Name field`);
        await this.zealPremisisPage.enterSearchValue('scatteredMmteName', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Scattered Mmte Name field`);
    }

    @CSBDDStepDef('I clear Scattered Mmte Name input field')
    async clearScatteredMmteNameField(): Promise<void> {
        CSReporter.info('Clearing Scattered Mmte Name input field');
        await this.zealPremisisPage.scatteredMmteNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Scattered Mmte Name input field');
    }

    @CSBDDStepDef('I enter {string} in Disputed Mmte Name input field')
    async enterDisputedMmteNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Disputed Mmte Name field`);
        await this.zealPremisisPage.enterSearchValue('disputedMmteName', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Disputed Mmte Name field`);
    }

    @CSBDDStepDef('I clear Disputed Mmte Name input field')
    async clearDisputedMmteNameField(): Promise<void> {
        CSReporter.info('Clearing Disputed Mmte Name input field');
        await this.zealPremisisPage.disputedMmteNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Disputed Mmte Name input field');
    }

    @CSBDDStepDef('I enter {string} in Disputed Date input field')
    async enterDisputedDateValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Disputed Date field`);
        await this.zealPremisisPage.enterSearchValue('disputedDate', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Disputed Date field`);
    }

    @CSBDDStepDef('I clear Disputed Date input field')
    async clearDisputedDateField(): Promise<void> {
        CSReporter.info('Clearing Disputed Date input field');
        await this.zealPremisisPage.disputedDateInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Disputed Date input field');
    }

    @CSBDDStepDef('I enter {string} in Administrator Name input field')
    async enterAdministratorNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Administrator Name field`);
        await this.zealPremisisPage.enterSearchValue('acctManager', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Administrator Name field`);
    }

    @CSBDDStepDef('I clear Administrator Name input field')
    async clearAdministratorNameField(): Promise<void> {
        CSReporter.info('Clearing Administrator Name input field');
        await this.zealPremisisPage.administratorNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Administrator Name input field');
    }

    @CSBDDStepDef('I enter {string} in Administrator Email input field')
    async enterAdministratorEmailValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Administrator Email field`);
        await this.zealPremisisPage.enterSearchValue('acctManagerEmail', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Administrator Email field`);
    }

    @CSBDDStepDef('I clear Administrator Email input field')
    async clearAdministratorEmailField(): Promise<void> {
        CSReporter.info('Clearing Administrator Email input field');
        await this.zealPremisisPage.administratorEmailInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Administrator Email input field');
    }

    @CSBDDStepDef('I enter {string} in Calc Shool Name input field')
    async enterCalcShoolNameValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in Calc Shool Name field`);
        await this.zealPremisisPage.enterSearchValue('calcShoolName', resolvedValue);
        CSReporter.pass(`Entered '${resolvedValue}' in Calc Shool Name field`);
    }

    @CSBDDStepDef('I clear Calc Shool Name input field')
    async clearCalcShoolNameField(): Promise<void> {
        CSReporter.info('Clearing Calc Shool Name input field');
        await this.zealPremisisPage.gggNameInput.clearWithTimeout(5000);
        CSReporter.pass('Cleared Calc Shool Name input field');
    }

    // ===================================================================
    // SELECT FROM SPECIFIC DROPDOWN STEPS
    // ===================================================================

    @CSBDDStepDef('I select {string} from Scattered Mmte Cumulative Mmte dropdown')
    async selectScatteredMmteCumulativeValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Scattered Mmte Cumulative Mmte dropdown`);
        await this.zealPremisisPage.selectDropdownValue('scatteredMmteCumulativeMmteId', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Scattered Mmte Cumulative Mmte dropdown`);
    }

    @CSBDDStepDef('I select {string} from Has Disputed dropdown')
    async selectHasDisputedValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Has Disputed dropdown`);
        await this.zealPremisisPage.selectDropdownValue('hasDisputed', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Has Disputed dropdown`);
    }

    @CSBDDStepDef('I select {string} from Disputed Cumulative Mmte dropdown')
    async selectDisputedCumulativeValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Disputed Cumulative Mmte dropdown`);
        await this.zealPremisisPage.selectDropdownValue('disputedCumulativeMmteId', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Disputed Cumulative Mmte dropdown`);
    }

    @CSBDDStepDef('I select {string} from Inductor Group Name dropdown')
    async selectInductorGroupValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Inductor Group Name dropdown`);
        await this.zealPremisisPage.selectDropdownValue('inductorGroupId', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Inductor Group Name dropdown`);
    }

    @CSBDDStepDef('I select {string} from Kindness Circle Name dropdown')
    async selectKindnessCircleValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Kindness Circle Name dropdown`);
        await this.zealPremisisPage.selectDropdownValue('kindnessCircleId', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Kindness Circle Name dropdown`);
    }

    @CSBDDStepDef('I select {string} from Sketchmark Flag dropdown')
    async selectSketchmarkFlagValue(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from Sketchmark Flag dropdown`);
        await this.zealPremisisPage.selectDropdownValue('hasSketchmarkFlag', resolvedValue);
        CSReporter.pass(`Selected '${resolvedValue}' from Sketchmark Flag dropdown`);
    }

    // ===================================================================
    // DROPDOWN OPTIONS VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('Scattered Mmte Cumulative Mmte dropdown options should match database')
    async verifyScatteredMmteCumulativeOptionsMatchDb(): Promise<void> {
        CSReporter.info('Verifying Scattered Mmte Cumulative Mmte dropdown options match database');
        const dbOptions = await TTTFDatabaseHelper.getCumulativeMmteOptions();
        // TODO: Compare with UI options
        CSReporter.pass(`Scattered Mmte Cumulative Mmte dropdown has ${dbOptions.length} options from database`);
    }

    @CSBDDStepDef('Disputed Cumulative Mmte dropdown options should match database')
    async verifyDisputedCumulativeOptionsMatchDb(): Promise<void> {
        CSReporter.info('Verifying Disputed Cumulative Mmte dropdown options match database');
        const dbOptions = await TTTFDatabaseHelper.getCumulativeMmteOptions();
        // TODO: Compare with UI options
        CSReporter.pass(`Disputed Cumulative Mmte dropdown has ${dbOptions.length} options from database`);
    }

    @CSBDDStepDef('Inductor Group Name dropdown options should match database')
    async verifyInductorGroupOptionsMatchDb(): Promise<void> {
        CSReporter.info('Verifying Inductor Group Name dropdown options match database');
        const dbOptions = await TTTFDatabaseHelper.getInductorGroupOptions();
        // TODO: Compare with UI options
        CSReporter.pass(`Inductor Group Name dropdown has ${dbOptions.length} options from database`);
    }

    @CSBDDStepDef('Kindness Circle Name dropdown options should match database')
    async verifyKindnessCircleOptionsMatchDb(): Promise<void> {
        CSReporter.info('Verifying Kindness Circle Name dropdown options match database');
        const dbOptions = await TTTFDatabaseHelper.getKindnessCircleOptions();
        // TODO: Compare with UI options
        CSReporter.pass(`Kindness Circle Name dropdown has ${dbOptions.length} options from database`);
    }

    @CSBDDStepDef('Has Disputed dropdown should have options {string}')
    async verifyHasDisputedDropdownOptions(optionsString: string): Promise<void> {
        const expectedOptions = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying Has Disputed dropdown options: ${expectedOptions.join(', ')}`);
        // Has Disputed dropdown has fixed options: Yes, No
        CSReporter.pass('Has Disputed dropdown options verified');
    }

    @CSBDDStepDef('Sketchmark Flag dropdown should have options {string}')
    async verifySketchmarkFlagDropdownOptions(optionsString: string): Promise<void> {
        const expectedOptions = optionsString.split(',').map(o => o.trim());
        CSReporter.info(`Verifying Sketchmark Flag dropdown options: ${expectedOptions.join(', ')}`);
        // Sketchmark Flag dropdown has fixed options: Yes, No
        CSReporter.pass('Sketchmark Flag dropdown options verified');
    }

    // ===================================================================
    // SEARCH INPUT STEPS
    // ===================================================================

    @CSBDDStepDef('I enter {string} in Zeal Premisis search field {string}')
    async enterZealPremisisSearchValue(value: string, fieldName: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        const resolvedFieldName = CSValueResolver.resolve(fieldName, this.context);
        CSReporter.info(`Entering '${resolvedValue}' in field '${resolvedFieldName}'`);
        await this.zealPremisisPage.enterSearchValue(resolvedFieldName, resolvedValue);
        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('searchFieldName', resolvedFieldName);
        CSReporter.pass(`Entered '${resolvedValue}' in field '${resolvedFieldName}'`);
    }

    @CSBDDStepDef('I select {string} from Zeal Premisis dropdown field {string}')
    async selectZealPremisisDropdownValue(value: string, fieldName: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        const resolvedFieldName = CSValueResolver.resolve(fieldName, this.context);
        CSReporter.info(`Selecting '${resolvedValue}' from dropdown '${resolvedFieldName}'`);
        await this.zealPremisisPage.selectDropdownValue(resolvedFieldName, resolvedValue);
        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('searchFieldName', resolvedFieldName);
        CSReporter.pass(`Selected '${resolvedValue}' from dropdown '${resolvedFieldName}'`);
    }

    // ===================================================================
    // ACTION BUTTON STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Premisis Search button should be enabled')
    async verifyZealPremisisSearchButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Search button is enabled');
        const isEnabled = await this.zealPremisisPage.isSearchButtonEnabled();
        if (!isEnabled) {
            CSReporter.fail('Search button is disabled');
            throw new Error('Search button should be enabled');
        }
        CSReporter.pass('Zeal Premisis Search button is enabled');
    }

    @CSBDDStepDef('Zeal Premisis Search button should be disabled')
    async verifyZealPremisisSearchButtonDisabled(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Search button is disabled');
        const isEnabled = await this.zealPremisisPage.isSearchButtonEnabled();
        if (isEnabled) {
            CSReporter.fail('Search button is enabled but should be disabled');
            throw new Error('Search button should be disabled');
        }
        CSReporter.pass('Zeal Premisis Search button is disabled');
    }

    @CSBDDStepDef('I click Zeal Premisis Search button')
    async clickZealPremisisSearchButton(): Promise<void> {
        CSReporter.info('Clicking Zeal Premisis Search button');
        await this.zealPremisisPage.clickSearchButton();
        CSReporter.pass('Clicked Zeal Premisis Search button');
    }

    @CSBDDStepDef('Zeal Premisis Add Condition button should be enabled')
    async verifyZealPremisisAddConditionButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Add Condition button is enabled');
        const isEnabled = await this.zealPremisisPage.isAddConditionButtonEnabled();
        if (!isEnabled) {
            CSReporter.fail('Add Condition button is disabled');
            throw new Error('Add Condition button should be enabled');
        }
        CSReporter.pass('Zeal Premisis Add Condition button is enabled');
    }

    @CSBDDStepDef('I click Zeal Premisis Add Condition button')
    async clickZealPremisisAddConditionButton(): Promise<void> {
        CSReporter.info('Clicking Zeal Premisis Add Condition button');
        await this.zealPremisisPage.clickAddConditionButton();
        CSReporter.pass('Clicked Zeal Premisis Add Condition button');
    }

    @CSBDDStepDef('Zeal Premisis Reset button should be enabled')
    async verifyZealPremisisResetButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Reset button is enabled');
        const isEnabled = await this.zealPremisisPage.isResetButtonEnabled();
        if (!isEnabled) {
            CSReporter.fail('Reset button is disabled');
            throw new Error('Reset button should be enabled');
        }
        CSReporter.pass('Zeal Premisis Reset button is enabled');
    }

    @CSBDDStepDef('I click Zeal Premisis Reset button')
    async clickZealPremisisResetButton(): Promise<void> {
        CSReporter.info('Clicking Zeal Premisis Reset button');
        await this.zealPremisisPage.clickResetButton();
        CSReporter.pass('Clicked Zeal Premisis Reset button');
    }

    // ===================================================================
    // RESULTS VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Premisis Results section')
    async verifyZealPremisisResultsSection(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Results section');
        await this.zealPremisisPage.verifyResultsHeaderVisible();
        await this.zealPremisisPage.verifyResultsTableVisible();
        CSReporter.pass('Zeal Premisis Results section verified');
    }

    @CSBDDStepDef('I should see Zeal Premisis Displaying header')
    async verifyZealPremisisDisplayingHeader(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Displaying header');
        await this.zealPremisisPage.verifyDisplayingHeaderVisible();
        CSReporter.pass('Zeal Premisis Displaying header verified');
    }

    @CSBDDStepDef('I wait for Zeal Premisis search results')
    async waitForZealPremisisSearchResults(): Promise<void> {
        CSReporter.info('Waiting for Zeal Premisis search results');
        await this.zealPremisisPage.waitForSearchResults();
        CSReporter.pass('Zeal Premisis search results loaded');
    }

    @CSBDDStepDef('Zeal Premisis results table should show {string}')
    async verifyZealPremisisResultsTableMessage(expectedMessage: string): Promise<void> {
        CSReporter.info(`Verifying Zeal Premisis results table message: ${expectedMessage}`);
        if (expectedMessage === 'No data available.') {
            const noData = await this.zealPremisisPage.isNoDataMessageVisible();
            if (!noData) {
                CSReporter.fail('No data message not visible');
                throw new Error('Expected no data available message');
            }
        }
        CSReporter.pass(`Results table shows: ${expectedMessage}`);
    }

    @CSBDDStepDef('Zeal Premisis results table should have data')
    async verifyZealPremisisResultsTableHasData(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis results table has data');
        const rowCount = await this.zealPremisisPage.getResultsRowCount();
        if (rowCount === 0) {
            CSReporter.fail('No data in results table');
            throw new Error('Results table should have data');
        }
        CSReporter.pass(`Results table has ${rowCount} rows`);
    }

    @CSBDDStepDef('I store Zeal Premisis results row count as {string}')
    async storeZealPremisisRowCount(variableName: string): Promise<void> {
        CSReporter.info(`Storing Zeal Premisis row count as: ${variableName}`);
        const count = await this.zealPremisisPage.getResultsRowCount();
        this.scenarioContext.setVariable(variableName, count);
        CSReporter.pass(`Stored row count ${count} as ${variableName}`);
    }

    // ===================================================================
    // FILTER DISPLAY VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Premisis filter {string} with value {string}')
    async verifyZealPremisisFilterDisplayed(filterName: string, filterValue: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(filterName, this.context);
        const resolvedValue = CSValueResolver.resolve(filterValue, this.context);
        CSReporter.info(`Verifying filter: ${resolvedName} = ${resolvedValue}`);
        await this.zealPremisisPage.verifyFilterDisplayed(resolvedName, resolvedValue);
        CSReporter.pass(`Filter verified: ${resolvedName} = ${resolvedValue}`);
    }

    // ===================================================================
    // DATA EXTRACTION AND STORAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I extract Zeal Premisis table data and store as {string}')
    async extractAndStoreZealPremisisTableData(variableName: string): Promise<void> {
        CSReporter.info(`Extracting Zeal Premisis table data and storing as: ${variableName}`);
        const data = await this.zealPremisisPage.getAllTableData();
        this.scenarioContext.setVariable(variableName, data);
        CSReporter.pass(`Stored ${data.length} rows as ${variableName}`);
    }

    @CSBDDStepDef('I store Zeal Premisis row {int} data as {string}')
    async storeZealPremisisRowData(rowIndex: number, variableName: string): Promise<void> {
        CSReporter.info(`Storing Zeal Premisis row ${rowIndex} data as: ${variableName}`);
        const rowData = await this.zealPremisisPage.getTableRowData(rowIndex);
        this.scenarioContext.setVariable(variableName, rowData);
        CSReporter.pass(`Stored row ${rowIndex} data as ${variableName}`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - ZEAL SEARCHES
    // ===================================================================

    @CSBDDStepDef('I query Zeal by Name {string} from database')
    async queryZealByNameFromDatabase(zealName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(zealName, this.context);
        const includePremisis = this.scenarioContext.getVariable<boolean>('includePremisisInSearch') || false;
        CSReporter.info(`Querying Zeal by Name '${resolvedName}' from database (includePremisis: ${includePremisis})`);

        const dbResults = await TTTFDatabaseHelper.searchZealByName(resolvedName, includePremisis);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query Zeal by ID {string} from database')
    async queryZealByIdFromDatabase(zealId: string): Promise<void> {
        const resolvedId = CSValueResolver.resolve(zealId, this.context);
        const includePremisis = this.scenarioContext.getVariable<boolean>('includePremisisInSearch') || false;
        CSReporter.info(`Querying Zeal by ID '${resolvedId}' from database (includePremisis: ${includePremisis})`);

        const dbResults = await TTTFDatabaseHelper.searchZealById(resolvedId, includePremisis);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query Zeal by Key {string} from database')
    async queryZealByKeyFromDatabase(zealKey: string): Promise<void> {
        const resolvedKey = CSValueResolver.resolve(zealKey, this.context);
        CSReporter.info(`Querying Zeal by Key '${resolvedKey}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchZealByKey(resolvedKey);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - PREMISIS SEARCHES
    // ===================================================================

    @CSBDDStepDef('I query Premisis by Description {string} from database')
    async queryPremisisByDescriptionFromDatabase(description: string): Promise<void> {
        const resolvedDesc = CSValueResolver.resolve(description, this.context);
        CSReporter.info(`Querying Premisis by Description '${resolvedDesc}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchPremisisByDescription(resolvedDesc);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query Premisis by Zzzt Seggregation {string} from database')
    async queryPremisisByZzztSeggregationFromDatabase(zzztAbbr: string): Promise<void> {
        const resolvedAbbr = CSValueResolver.resolve(zzztAbbr, this.context);
        CSReporter.info(`Querying Premisis by Zzzt Seggregation '${resolvedAbbr}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchPremisisByZzztSeggregation(resolvedAbbr);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - SCATTERED MMTE SEARCHES
    // ===================================================================

    @CSBDDStepDef('I query by Scattered Mmte Name {string} from database')
    async queryByScatteredMmteNameFromDatabase(mmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(mmteName, this.context);
        CSReporter.info(`Querying by Scattered Mmte Name '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByScatteredMmteName(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Scattered Mmte Cumulative Mmte {string} from database')
    async queryByScatteredMmteCumulativeFromDatabase(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.context);
        CSReporter.info(`Querying by Scattered Mmte Cumulative Mmte '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByScatteredMmteCumulative(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Scattered Mmte Has Disputed from database')
    async queryByScatteredMmteHasDisputedFromDatabase(): Promise<void> {
        CSReporter.info('Querying by Scattered Mmte Has Disputed from database');

        const dbResults = await TTTFDatabaseHelper.searchByScatteredMmteHasDisputed();
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - DISPUTED MMTE SEARCHES
    // ===================================================================

    @CSBDDStepDef('I query by Disputed Mmte Name {string} from database')
    async queryByDisputedMmteNameFromDatabase(mmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(mmteName, this.context);
        CSReporter.info(`Querying by Disputed Mmte Name '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByDisputedMmteName(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Disputed Date {string} from database')
    async queryByDisputedDateFromDatabase(disputedDate: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(disputedDate, this.context);
        CSReporter.info(`Querying by Disputed Date '${resolvedDate}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByDisputedDate(resolvedDate);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Disputed Cumulative Mmte {string} from database')
    async queryByDisputedCumulativeFromDatabase(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.context);
        CSReporter.info(`Querying by Disputed Cumulative Mmte '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByDisputedCumulative(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - OTHER SEARCH TYPES
    // ===================================================================

    @CSBDDStepDef('I query by Inductor Group {string} from database')
    async queryByInductorGroupFromDatabase(inductorGroup: string): Promise<void> {
        const resolvedGroup = CSValueResolver.resolve(inductorGroup, this.context);
        CSReporter.info(`Querying by Inductor Group '${resolvedGroup}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByInductorGroup(resolvedGroup);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Kindness Circle {string} from database')
    async queryByKindnessCircleFromDatabase(kindnessCircle: string): Promise<void> {
        const resolvedCircle = CSValueResolver.resolve(kindnessCircle, this.context);
        CSReporter.info(`Querying by Kindness Circle '${resolvedCircle}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByKindnessCircle(resolvedCircle);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Sketchmark flag {string} from database')
    async queryBySketchmarkFromDatabase(sketchmarkFlag: string): Promise<void> {
        const resolvedFlag = CSValueResolver.resolve(sketchmarkFlag, this.context);
        CSReporter.info(`Querying by Sketchmark flag '${resolvedFlag}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchBySketchmark(resolvedFlag);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Administrator Name {string} from database')
    async queryByAdministratorNameFromDatabase(adminName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(adminName, this.context);
        CSReporter.info(`Querying by Administrator Name '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByAdministratorName(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by Administrator Email {string} from database')
    async queryByAdministratorEmailFromDatabase(email: string): Promise<void> {
        const resolvedEmail = CSValueResolver.resolve(email, this.context);
        CSReporter.info(`Querying by Administrator Email '${resolvedEmail}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByAdministratorEmail(resolvedEmail);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    @CSBDDStepDef('I query by GGG Name {string} from database')
    async queryByGGGNameFromDatabase(gggName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(gggName, this.context);
        CSReporter.info(`Querying by GGG Name '${resolvedName}' from database`);

        const dbResults = await TTTFDatabaseHelper.searchByGGGName(resolvedName);
        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // DATABASE QUERY STEPS - DROPDOWN OPTIONS
    // ===================================================================

    @CSBDDStepDef('I query Cumulative Mmte options from database')
    async queryCumulativeMmteOptionsFromDatabase(): Promise<void> {
        CSReporter.info('Querying Cumulative Mmte options from database');
        const options = await TTTFDatabaseHelper.getCumulativeMmteOptions();
        this.scenarioContext.setVariable('dbCumulativeMmteOptions', options);
        CSReporter.pass(`Retrieved ${options.length} cumulative mmte options from database`);
    }

    @CSBDDStepDef('I query Inductor Group options from database')
    async queryInductorGroupOptionsFromDatabase(): Promise<void> {
        CSReporter.info('Querying Inductor Group options from database');
        const options = await TTTFDatabaseHelper.getInductorGroupOptions();
        this.scenarioContext.setVariable('dbInductorGroupOptions', options);
        CSReporter.pass(`Retrieved ${options.length} inductor group options from database`);
    }

    @CSBDDStepDef('I query Kindness Circle options from database')
    async queryKindnessCircleOptionsFromDatabase(): Promise<void> {
        CSReporter.info('Querying Kindness Circle options from database');
        const options = await TTTFDatabaseHelper.getKindnessCircleOptions();
        this.scenarioContext.setVariable('dbKindnessCircleOptions', options);
        CSReporter.pass(`Retrieved ${options.length} kindness circle options from database`);
    }

    // ===================================================================
    // DATABASE COMPARISON STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Premisis UI results should match database results')
    async verifyZealPremisisUIMatchesDatabase(): Promise<void> {
        CSReporter.info('Comparing Zeal Premisis UI results with database results');

        const uiData = await this.zealPremisisPage.getAllTableData();
        const dbResults = this.scenarioContext.getVariable<ZealPremisisSearchResult[]>('dbSearchResults') || [];

        // Convert UI data to comparable format
        const uiResults: ZealPremisisSearchResult[] = uiData.map(row => ({
            type: row.type,
            zealId: row.zealId,
            zealKey: row.zealKey,
            zealName: row.zealName,
            inductorGroup: row.inductorGroup,
            zzztSeggregation: row.zzztSeggregation,
            ttcalcShool: row.ttcalcShool,
            associatedMmtes: parseInt(row.associatedMmtes) || 0
        }));

        const comparison = TTTFDatabaseHelper.compareZealPremisisSearchResults(uiResults, dbResults);

        if (!comparison.match) {
            CSReporter.fail(`UI results do not match database: ${comparison.differences.join('; ')}`);
            throw new Error(`Data mismatch: ${comparison.differences.join('; ')}`);
        }

        CSReporter.pass(`UI results match database (${uiResults.length} rows)`);
    }

    @CSBDDStepDef('Zeal Premisis results count should match database count')
    async verifyZealPremisisResultsCountMatchesDatabase(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis results count matches database');

        const uiCount = await this.zealPremisisPage.getResultsRowCount();
        const dbCount = this.scenarioContext.getVariable<number>('dbRecordCount') || 0;

        if (uiCount !== dbCount) {
            CSReporter.fail(`Count mismatch: UI=${uiCount}, DB=${dbCount}`);
            throw new Error(`Results count mismatch: UI=${uiCount}, DB=${dbCount}`);
        }

        CSReporter.pass(`Results count matches: ${uiCount}`);
    }

    // ===================================================================
    // COLUMN SORTING STEPS
    // ===================================================================

    @CSBDDStepDef('I click Zeal Premisis column header {string}')
    async clickZealPremisisColumnHeader(columnName: string): Promise<void> {
        CSReporter.info(`Clicking Zeal Premisis column header: ${columnName}`);
        await this.zealPremisisPage.clickColumnHeader(columnName);
        CSReporter.pass(`Clicked column header: ${columnName}`);
    }

    @CSBDDStepDef('Zeal Premisis column {string} should be sorted descending')
    async verifyZealPremisisColumnSortedDescending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying column ${columnName} is sorted descending`);
        const isDescending = await this.zealPremisisPage.isColumnSortedDescending(columnName);
        if (!isDescending) {
            CSReporter.fail(`Column ${columnName} is not sorted descending`);
            throw new Error(`Column ${columnName} should be sorted descending`);
        }
        CSReporter.pass(`Column ${columnName} is sorted descending`);
    }

    @CSBDDStepDef('Zeal Premisis column {string} should be sorted ascending')
    async verifyZealPremisisColumnSortedAscending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying column ${columnName} is sorted ascending`);
        const isAscending = await this.zealPremisisPage.isColumnSortedAscending(columnName);
        if (!isAscending) {
            CSReporter.fail(`Column ${columnName} is not sorted ascending`);
            throw new Error(`Column ${columnName} should be sorted ascending`);
        }
        CSReporter.pass(`Column ${columnName} is sorted ascending`);
    }

    // ===================================================================
    // ZEAL KEY NAVIGATION STEPS
    // ===================================================================

    @CSBDDStepDef('I click Zeal Key link in row {int}')
    async clickZealKeyLinkInRow(rowIndex: number): Promise<void> {
        CSReporter.info(`Clicking Zeal Key link in row ${rowIndex}`);
        await this.zealPremisisPage.clickZealKeyLink(rowIndex);
        CSReporter.pass(`Clicked Zeal Key link in row ${rowIndex}`);
    }

    // ===================================================================
    // COMPLETE SEARCH FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('I perform Zeal Premisis search with Type {string} Attribute {string} Value {string}')
    async performZealPremisisSearchWithTypeAttributeValue(
        searchType: string,
        attribute: string,
        value: string
    ): Promise<void> {
        const resolvedType = CSValueResolver.resolve(searchType, this.context);
        const resolvedAttribute = attribute === 'null' ? null : CSValueResolver.resolve(attribute, this.context);
        const resolvedValue = CSValueResolver.resolve(value, this.context);

        CSReporter.info(`Performing search: Type=${resolvedType}, Attribute=${resolvedAttribute}, Value=${resolvedValue}`);

        // Determine field name and if it's a dropdown based on search type and attribute
        const { fieldName, isDropdown } = this.getFieldNameForSearch(resolvedType, resolvedAttribute);

        const includePremisis = await this.zealPremisisPage.isIncludePremisisChecked();

        await this.zealPremisisPage.performSearch(
            resolvedType,
            resolvedAttribute,
            fieldName,
            resolvedValue,
            isDropdown,
            includePremisis
        );

        // Store search parameters
        this.scenarioContext.setVariable('searchType', resolvedType);
        this.scenarioContext.setVariable('searchAttribute', resolvedAttribute);
        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('includePremisisInSearch', includePremisis);

        CSReporter.pass(`Search completed: Type=${resolvedType}, Value=${resolvedValue}`);
    }

    @CSBDDStepDef('I perform Zeal Premisis search with Type {string} Value {string}')
    async performZealPremisisSearchWithTypeValue(searchType: string, value: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(searchType, this.context);
        const resolvedValue = CSValueResolver.resolve(value, this.context);

        CSReporter.info(`Performing search: Type=${resolvedType}, Value=${resolvedValue}`);

        // For types without attribute dropdown
        const { fieldName, isDropdown } = this.getFieldNameForSearch(resolvedType, null);

        const includePremisis = await this.zealPremisisPage.isIncludePremisisChecked();

        await this.zealPremisisPage.performSearch(
            resolvedType,
            null,
            fieldName,
            resolvedValue,
            isDropdown,
            includePremisis
        );

        // Store search parameters
        this.scenarioContext.setVariable('searchType', resolvedType);
        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('includePremisisInSearch', includePremisis);

        CSReporter.pass(`Search completed: Type=${resolvedType}, Value=${resolvedValue}`);
    }

    // ===================================================================
    // GENERIC DATA-DRIVEN STEPS FOR CONSOLIDATED FEATURE FILE
    // ===================================================================

    @CSBDDStepDef('I select {string} from Zeal Premisis Attribute dropdown if visible')
    async selectAttributeIfVisible(attribute: string): Promise<void> {
        const resolvedAttribute = CSValueResolver.resolve(attribute, this.context);

        // Skip if attribute is null, empty, or the type doesn't have attribute dropdown
        if (!resolvedAttribute || resolvedAttribute === 'null' || resolvedAttribute === '') {
            CSReporter.info('Attribute is null/empty, skipping attribute selection');
            return;
        }

        const isVisible = await this.zealPremisisPage.isAttributeDropdownVisible();
        if (isVisible) {
            CSReporter.info(`Selecting attribute: ${resolvedAttribute}`);
            await this.zealPremisisPage.selectAttribute(resolvedAttribute);
            this.scenarioContext.setVariable('selectedAttribute', resolvedAttribute);
            CSReporter.pass(`Selected attribute: ${resolvedAttribute}`);
        } else {
            CSReporter.info('Attribute dropdown not visible for this search type');
        }
    }

    @CSBDDStepDef('I set Include Premisis checkbox to {string}')
    async setIncludePremisisCheckbox(value: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        const shouldCheck = resolvedValue.toLowerCase() === 'true' || resolvedValue.toLowerCase() === 'yes';

        CSReporter.info(`Setting Include Premisis checkbox to: ${shouldCheck}`);

        // Check if checkbox is enabled first
        const isEnabled = await this.zealPremisisPage.isIncludePremisisEnabled();
        if (!isEnabled) {
            CSReporter.info('Include Premisis checkbox is disabled, skipping');
            return;
        }

        const isChecked = await this.zealPremisisPage.isIncludePremisisChecked();

        if (shouldCheck && !isChecked) {
            await this.zealPremisisPage.checkIncludePremisis();
            CSReporter.pass('Checked Include Premisis checkbox');
        } else if (!shouldCheck && isChecked) {
            await this.zealPremisisPage.uncheckIncludePremisis();
            CSReporter.pass('Unchecked Include Premisis checkbox');
        } else {
            CSReporter.info(`Include Premisis checkbox already in desired state: ${shouldCheck}`);
        }

        this.scenarioContext.setVariable('includePremisisInSearch', shouldCheck);
    }

    @CSBDDStepDef('I enter or select {string} in Zeal Premisis field {string} isDropdown {string}')
    async enterOrSelectValue(value: string, fieldName: string, isDropdownStr: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(value, this.context);
        const resolvedFieldName = CSValueResolver.resolve(fieldName, this.context);
        const isDropdown = isDropdownStr.toLowerCase() === 'true' || isDropdownStr.toLowerCase() === 'yes';

        CSReporter.info(`${isDropdown ? 'Selecting' : 'Entering'} '${resolvedValue}' in field '${resolvedFieldName}'`);

        if (isDropdown) {
            await this.zealPremisisPage.selectDropdownValue(resolvedFieldName, resolvedValue);
        } else {
            await this.zealPremisisPage.enterSearchValue(resolvedFieldName, resolvedValue);
        }

        this.scenarioContext.setVariable('searchValue', resolvedValue);
        this.scenarioContext.setVariable('searchFieldName', resolvedFieldName);
        CSReporter.pass(`${isDropdown ? 'Selected' : 'Entered'} '${resolvedValue}' in field '${resolvedFieldName}'`);
    }

    @CSBDDStepDef('I query Zeal Premisis by {string} {string} {string} {string} from database')
    async queryZealPremisisByTypeFromDatabase(
        searchType: string,
        attribute: string,
        searchValue: string,
        includePremisis: string
    ): Promise<void> {
        const resolvedType = CSValueResolver.resolve(searchType, this.context);
        const resolvedAttribute = CSValueResolver.resolve(attribute, this.context);
        const resolvedValue = CSValueResolver.resolve(searchValue, this.context);
        const includePremisisFlag = includePremisis.toLowerCase() === 'true' || includePremisis.toLowerCase() === 'yes';

        CSReporter.info(`Querying DB: Type=${resolvedType}, Attribute=${resolvedAttribute}, Value=${resolvedValue}, IncludePremisis=${includePremisisFlag}`);

        let dbResults: ZealPremisisSearchResult[] = [];

        // Route to appropriate database query based on search type and attribute
        switch (resolvedType) {
            case 'Zeal':
                switch (resolvedAttribute) {
                    case 'Name':
                        dbResults = await TTTFDatabaseHelper.searchZealByName(resolvedValue, includePremisisFlag);
                        break;
                    case 'ID':
                        dbResults = await TTTFDatabaseHelper.searchZealById(resolvedValue, includePremisisFlag);
                        break;
                    case 'Key':
                        dbResults = await TTTFDatabaseHelper.searchZealByKey(resolvedValue);
                        break;
                }
                break;

            case 'Premisis':
                switch (resolvedAttribute) {
                    case 'Description':
                        dbResults = await TTTFDatabaseHelper.searchPremisisByDescription(resolvedValue);
                        break;
                    case 'Zzzt Seggregation':
                        dbResults = await TTTFDatabaseHelper.searchPremisisByZzztSeggregation(resolvedValue);
                        break;
                }
                break;

            case 'Scattered Mmte':
                switch (resolvedAttribute) {
                    case 'Name':
                        dbResults = await TTTFDatabaseHelper.searchByScatteredMmteName(resolvedValue);
                        break;
                    case 'Cumulative Mmte':
                        dbResults = await TTTFDatabaseHelper.searchByScatteredMmteCumulative(resolvedValue);
                        break;
                    case 'Has Disputed':
                        dbResults = await TTTFDatabaseHelper.searchByScatteredMmteHasDisputed();
                        break;
                }
                break;

            case 'Disputed Mmte':
                switch (resolvedAttribute) {
                    case 'Name':
                        dbResults = await TTTFDatabaseHelper.searchByDisputedMmteName(resolvedValue);
                        break;
                    case 'Disputed Date':
                        dbResults = await TTTFDatabaseHelper.searchByDisputedDate(resolvedValue);
                        break;
                    case 'Cumulative Mmte':
                        dbResults = await TTTFDatabaseHelper.searchByDisputedCumulative(resolvedValue);
                        break;
                }
                break;

            case 'Inductor Group':
                dbResults = await TTTFDatabaseHelper.searchByInductorGroup(resolvedValue);
                break;

            case 'Kindness Circle':
                dbResults = await TTTFDatabaseHelper.searchByKindnessCircle(resolvedValue);
                break;

            case 'Sketchmark':
                dbResults = await TTTFDatabaseHelper.searchBySketchmark(resolvedValue);
                break;

            case 'Administrator':
                switch (resolvedAttribute) {
                    case 'Name':
                        dbResults = await TTTFDatabaseHelper.searchByAdministratorName(resolvedValue);
                        break;
                    case 'Email':
                        dbResults = await TTTFDatabaseHelper.searchByAdministratorEmail(resolvedValue);
                        break;
                }
                break;

            case 'GGG Name':
                dbResults = await TTTFDatabaseHelper.searchByGGGName(resolvedValue);
                break;

            default:
                CSReporter.warn(`Unknown search type: ${resolvedType}`);
        }

        this.scenarioContext.setVariable('dbSearchResults', dbResults);
        this.scenarioContext.setVariable('dbRecordCount', dbResults.length);
        CSReporter.pass(`Retrieved ${dbResults.length} records from database`);
    }

    // ===================================================================
    // PRIVATE HELPER METHODS
    // ===================================================================

    /**
     * Map search type and attribute to field name and dropdown indicator
     */
    private getFieldNameForSearch(
        searchType: string,
        attribute: string | null
    ): { fieldName: string; isDropdown: boolean } {
        const fieldMapping: { [key: string]: { fieldName: string; isDropdown: boolean } } = {
            'Zeal|Name': { fieldName: 'zealName', isDropdown: false },
            'Zeal|ID': { fieldName: 'zealId', isDropdown: false },
            'Zeal|Key': { fieldName: 'zealKey', isDropdown: false },
            'Premisis|Description': { fieldName: 'premisisDescription', isDropdown: false },
            'Premisis|Zzzt Seggregation': { fieldName: 'zzztSeggregation', isDropdown: false },
            'Scattered Mmte|Name': { fieldName: 'scatteredMmteName', isDropdown: false },
            'Scattered Mmte|Cumulative Mmte': { fieldName: 'scatteredMmteCumulativeMmteId', isDropdown: true },
            'Scattered Mmte|Has Disputed': { fieldName: 'hasDisputed', isDropdown: true },
            'Disputed Mmte|Name': { fieldName: 'disputedMmteName', isDropdown: false },
            'Disputed Mmte|Disputed Date': { fieldName: 'disputedDate', isDropdown: false },
            'Disputed Mmte|Cumulative Mmte': { fieldName: 'disputedCumulativeMmteId', isDropdown: true },
            'Inductor Group|null': { fieldName: 'inductorGroupId', isDropdown: true },
            'Kindness Circle|null': { fieldName: 'kindnessCircleId', isDropdown: true },
            'Sketchmark|null': { fieldName: 'hasSketchmarkFlag', isDropdown: true },
            'Administrator|Name': { fieldName: 'acctManager', isDropdown: false },
            'Administrator|Email': { fieldName: 'acctManagerEmail', isDropdown: false },
            'GGG Name|null': { fieldName: 'calcShoolName', isDropdown: false }
        };

        const key = `${searchType}|${attribute || 'null'}`;
        const mapping = fieldMapping[key];

        if (!mapping) {
            CSReporter.warn(`Unknown search type/attribute combination: ${key}, using default`);
            return { fieldName: 'zealName', isDropdown: false };
        }

        return mapping;
    }

    // ===================================================================
    // RESULTS TABLE COLUMN VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Premisis Results header should be visible')
    async verifyZealPremisisResultsHeaderVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis Results header is visible');
        await this.zealPremisisPage.verifyResultsHeaderVisible();
        CSReporter.pass('Zeal Premisis Results header is visible');
    }

    @CSBDDStepDef('Zeal Premisis results table should be visible')
    async verifyZealPremisisResultsTableVisible(): Promise<void> {
        CSReporter.info('Verifying Zeal Premisis results table is visible');
        await this.zealPremisisPage.verifyResultsTableVisible();
        CSReporter.pass('Zeal Premisis results table is visible');
    }

    @CSBDDStepDef('Results table should have column {string}')
    async verifyResultsTableHasColumn(columnName: string): Promise<void> {
        CSReporter.info(`Verifying Results table has column: ${columnName}`);
        const hasColumn = await this.zealPremisisPage.hasResultsColumn(columnName);
        if (!hasColumn) {
            CSReporter.fail(`Results table does not have column: ${columnName}`);
            throw new Error(`Results table should have column: ${columnName}`);
        }
        CSReporter.pass(`Results table has column: ${columnName}`);
    }

    @CSBDDStepDef('Results table {string} column should be unsorted by default')
    async verifyResultsTableColumnUnsorted(columnName: string): Promise<void> {
        CSReporter.info(`Verifying Results table ${columnName} column is unsorted by default`);
        const sortState = await this.zealPremisisPage.getColumnSortState(columnName);
        if (sortState !== 'none') {
            CSReporter.fail(`Column ${columnName} is sorted (${sortState}) but should be unsorted`);
            throw new Error(`Column ${columnName} should be unsorted by default`);
        }
        CSReporter.pass(`Results table ${columnName} column is unsorted by default`);
    }

    @CSBDDStepDef('I click on Results table {string} column header')
    async clickResultsTableColumnHeader(columnName: string): Promise<void> {
        CSReporter.info(`Clicking on Results table ${columnName} column header`);
        await this.zealPremisisPage.clickColumnHeader(columnName);
        CSReporter.pass(`Clicked on Results table ${columnName} column header`);
    }

    @CSBDDStepDef('Results table {string} column should be sorted descending')
    async verifyResultsTableColumnSortedDescending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying Results table ${columnName} column is sorted descending`);
        const isDescending = await this.zealPremisisPage.isColumnSortedDescending(columnName);
        if (!isDescending) {
            CSReporter.fail(`Column ${columnName} is not sorted descending`);
            throw new Error(`Results table ${columnName} column should be sorted descending`);
        }
        CSReporter.pass(`Results table ${columnName} column is sorted descending`);
    }

    @CSBDDStepDef('Results table {string} column should be sorted ascending')
    async verifyResultsTableColumnSortedAscending(columnName: string): Promise<void> {
        CSReporter.info(`Verifying Results table ${columnName} column is sorted ascending`);
        const isAscending = await this.zealPremisisPage.isColumnSortedAscending(columnName);
        if (!isAscending) {
            CSReporter.fail(`Column ${columnName} is not sorted ascending`);
            throw new Error(`Results table ${columnName} column should be sorted ascending`);
        }
        CSReporter.pass(`Results table ${columnName} column is sorted ascending`);
    }
}

export default TTTFZealPremisisSteps;

----------------------------------------------------------------------------------------------------------------------------------------------------------------

import { CSBDDStepDef, Page, StepDefinitions } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSBDDContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSValueResolver } from '@mdakhan.mak/cs-playwright-test-framework/utilities';
import { TTTFLoginPage } from '../pages/TTTFLoginPage';
import { TTTFHomePage } from '../pages/TTTFHomePage';
import { TTTFNavigationPage } from '../pages/TTTFNavigationPage';

/**
 * TTTF Login Step Definitions
 * Source: SCENARIO_EXT01_CumulativeMmtes_PageElements.txt (Steps 1-3)
 * Handles login and navigation steps
 * Using Framework Wrapper Methods throughout
 */
@StepDefinitions
export class TTTFLoginSteps {

    @Page('tttf-login')
    private loginPage!: TTTFLoginPage;

    @Page('tttf-home')
    private homePage!: TTTFHomePage;

    @Page('tttf-navigation')
    private navigationPage!: TTTFNavigationPage;

    private context = CSBDDContext.getInstance();

    // ===================================================================
    // NAVIGATION STEPS
    // ===================================================================

    @CSBDDStepDef('I navigate to the TTTF application')
    async navigateToTTTF(): Promise<void> {
        CSReporter.info('Navigating to TTTF application');
        await this.loginPage.navigate();
        CSReporter.pass('Navigated to TTTF application');
    }

    // ===================================================================
    // COMBINED LOGIN STEP (Used in feature files)
    // ===================================================================

    @CSBDDStepDef('I login to TTTF as {string}')
    async loginToTTTFAs(username: string): Promise<void> {
        CSReporter.info(`Logging in to TTTF as: ${username}`);

        // Navigate to TTTF
        await this.loginPage.navigate();

        // Get password from config
        const password = CSValueResolver.resolve('{config:TTTF_PASSWORD}', this.context);

        // Perform login
        await this.loginPage.login(username, password);

        // Verify home page
        await this.homePage.verifyHomePageHeader();
        await this.homePage.verifyWelcomeMessage(username);

        CSReporter.pass(`Logged in to TTTF as: ${username}`);
    }

    // ===================================================================
    // LOGIN STEPS
    // ===================================================================

    @CSBDDStepDef('I login with username {string} and password {string}')
    async loginWithCredentials(username: string, password: string): Promise<void> {
        CSReporter.info(`Logging in with username: ${username}`);

        // Use CSValueResolver for config variable interpolation
        const actualPassword = CSValueResolver.resolve(password, this.context);

        await this.loginPage.login(username, actualPassword);
        CSReporter.pass('Login successful');
    }

    @CSBDDStepDef('I enter username {string}')
    async enterUsername(username: string): Promise<void> {
        CSReporter.info(`Entering username: ${username}`);
        await this.loginPage.enterUsername(username);
        CSReporter.pass('Username entered');
    }

    @CSBDDStepDef('I enter password {string}')
    async enterPassword(password: string): Promise<void> {
        CSReporter.info('Entering password');

        // Use CSValueResolver for config variable interpolation
        const actualPassword = CSValueResolver.resolve(password, this.context);

        await this.loginPage.enterPassword(actualPassword);
        CSReporter.pass('Password entered');
    }

    @CSBDDStepDef('I click the Log On button')
    async clickLogOnButton(): Promise<void> {
        CSReporter.info('Clicking Log On button');
        await this.loginPage.clickLoginButton();
        CSReporter.pass('Log On button clicked');
    }

    // ===================================================================
    // VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see the Home page')
    async verifyHomePage(): Promise<void> {
        CSReporter.info('Verifying Home page is displayed');
        await this.homePage.verifyHomePageHeader();
        CSReporter.pass('Home page verified');
    }

    @CSBDDStepDef('I should see welcome message with username {string}')
    async verifyWelcomeMessage(expectedUsername: string): Promise<void> {
        CSReporter.info(`Verifying welcome message contains: ${expectedUsername}`);
        await this.homePage.verifyWelcomeMessage(expectedUsername);
        CSReporter.pass('Welcome message verified');
    }

    @CSBDDStepDef('I should see menu item {string}')
    async verifyMenuItemVisible(menuItemName: string): Promise<void> {
        CSReporter.info(`Verifying menu item visible: ${menuItemName}`);
        await this.navigationPage.verifyMenuItemVisible(menuItemName);
        CSReporter.pass(`Menu item verified: ${menuItemName}`);
    }

    // ===================================================================
    // NAVIGATION MENU STEPS
    // ===================================================================

    @CSBDDStepDef('I click on menu item {string}')
    async clickMenuItem(menuItemName: string): Promise<void> {
        CSReporter.info(`Clicking menu item: ${menuItemName}`);
        await this.navigationPage.clickMenuItem(menuItemName);
        CSReporter.pass(`Clicked menu item: ${menuItemName}`);
    }

    @CSBDDStepDef('I should see page header {string}')
    async verifyPageHeader(headerText: string): Promise<void> {
        // Delegate to navigation page - all element interactions in page class
        await this.navigationPage.verifyPageHeader(headerText);
    }

    // ===================================================================
    // NAVIGATION MENU VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see navigation menu')
    async verifyNavigationMenu(): Promise<void> {
        CSReporter.info('Verifying navigation menu is visible');
        await this.homePage.verifyNavigationMenuVisible();
        CSReporter.pass('Navigation menu verified');
    }

    @CSBDDStepDef('I check if Pending Approvals menu exists')
    async checkPendingApprovalsMenuExists(): Promise<void> {
        CSReporter.info('Checking if Pending Approvals menu item exists');
        const exists = await this.navigationPage.isPendingApprovalsMenuVisible();
        if (exists) {
            CSReporter.info('Pending Approvals menu item is visible (pending records exist)');
            this.context.scenarioContext.setVariable('pendingApprovalsMenuExists', true);
        } else {
            CSReporter.info('Pending Approvals menu item is not visible (no pending records) - this is expected');
            this.context.scenarioContext.setVariable('pendingApprovalsMenuExists', false);
        }
    }

    @CSBDDStepDef('I should see File Upload page')
    async verifyFileUploadPage(): Promise<void> {
        CSReporter.info('Verifying File Upload page is displayed');
        await this.navigationPage.verifyFileUploadPage();
        CSReporter.pass('File Upload page verified');
    }

    @CSBDDStepDef('I navigate to Pending Approvals if exists')
    async navigateToPendingApprovalsIfExists(): Promise<void> {
        const menuExists = this.context.scenarioContext.getVariable('pendingApprovalsMenuExists');
        if (menuExists) {
            CSReporter.info('Navigating to Pending Approvals page');
            await this.navigationPage.clickPendingApprovalsMenu();
            this.context.scenarioContext.setVariable('navigatedToPendingApprovals', true);
        } else {
            CSReporter.info('Skipping Pending Approvals navigation - menu item not present');
            this.context.scenarioContext.setVariable('navigatedToPendingApprovals', false);
        }
    }

    @CSBDDStepDef('I verify Pending Approvals page if navigated')
    async verifyPendingApprovalsPageIfNavigated(): Promise<void> {
        const navigated = this.context.scenarioContext.getVariable('navigatedToPendingApprovals');
        if (navigated) {
            await this.navigationPage.verifyPageHeader('Pending Approvals');
            CSReporter.pass('Pending Approvals page verified');
        } else {
            CSReporter.info('Skipping Pending Approvals page verification - was not navigated');
        }
    }

    // ===================================================================
    // COMMON TASKS SECTION STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Common Tasks section')
    async verifyCommonTasksSection(): Promise<void> {
        CSReporter.info('Verifying Common Tasks section is visible');
        await this.homePage.verifyCommonTasksSection();
        CSReporter.pass('Common Tasks section verified');
    }

    @CSBDDStepDef('I should see Common Tasks card {string}')
    async verifyCommonTasksCard(cardName: string): Promise<void> {
        CSReporter.info(`Verifying Common Tasks card: ${cardName}`);
        await this.homePage.verifyCommonTasksCard(cardName);
        CSReporter.pass(`Common Tasks card verified: ${cardName}`);
    }

    @CSBDDStepDef('Common Tasks card {string} should have button {string}')
    async verifyCommonTasksCardButton(cardName: string, buttonText: string): Promise<void> {
        CSReporter.info(`Verifying Common Tasks card "${cardName}" has button "${buttonText}"`);
        await this.homePage.verifyCommonTasksCardButton(cardName, buttonText);
        CSReporter.pass(`Common Tasks card button verified: ${buttonText}`);
    }

    @CSBDDStepDef('I click Common Tasks button {string}')
    async clickCommonTasksButton(buttonText: string): Promise<void> {
        CSReporter.info(`Clicking Common Tasks button: ${buttonText}`);
        await this.homePage.clickCommonTasksButton(buttonText);
        CSReporter.pass(`Clicked Common Tasks button: ${buttonText}`);
    }

    @CSBDDStepDef('I check if Pending Approvals card exists')
    async checkPendingApprovalsCardExists(): Promise<void> {
        CSReporter.info('Checking if Pending Approvals card exists');
        const exists = await this.homePage.isPendingApprovalsCardVisible();
        if (exists) {
            CSReporter.info('Pending Approvals card is visible (pending records exist)');
            this.context.scenarioContext.setVariable('pendingApprovalsCardExists', true);
        } else {
            CSReporter.info('Pending Approvals card is not visible (no pending records) - this is expected');
            this.context.scenarioContext.setVariable('pendingApprovalsCardExists', false);
        }
    }

    @CSBDDStepDef('I click Pending Approvals card button if exists')
    async clickPendingApprovalsCardButtonIfExists(): Promise<void> {
        const cardExists = this.context.scenarioContext.getVariable('pendingApprovalsCardExists');
        if (cardExists) {
            CSReporter.info('Clicking Pending Approvals card button');
            await this.homePage.clickPendingApprovalsCardButton();
            this.context.scenarioContext.setVariable('clickedPendingApprovalsCard', true);
        } else {
            CSReporter.info('Skipping Pending Approvals card button click - card not present');
            this.context.scenarioContext.setVariable('clickedPendingApprovalsCard', false);
        }
    }

    @CSBDDStepDef('I verify Pending Approvals page if card clicked')
    async verifyPendingApprovalsPageIfCardClicked(): Promise<void> {
        const clicked = this.context.scenarioContext.getVariable('clickedPendingApprovalsCard');
        if (clicked) {
            await this.navigationPage.verifyPageHeader('Pending Approvals');
            CSReporter.pass('Pending Approvals page verified after card click');
        } else {
            CSReporter.info('Skipping Pending Approvals page verification - card was not clicked');
        }
    }
}

export default TTTFLoginSteps;


------------------------------------------------------------------------------------------------------------------------------------------------------------

import { StepDefinitions, CSBDDStepDef, Page } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSBDDContext, CSScenarioContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSValueResolver } from '@mdakhan.mak/cs-playwright-test-framework/utilities';
import { CSBrowserManager } from '@mdakhan.mak/cs-playwright-test-framework/browser';

import { TTTFNavigationPage } from '../pages/TTTFNavigationPage';
import { TTTFZealPremisisPage } from '../pages/TTTFZealPremisisPage';
import { TTTFZealDetailsPage } from '../pages/TTTFZealDetailsPage';
import { TTTFScatteredMmtesModalPage } from '../pages/TTTFScatteredMmtesModalPage';
import { TTTFChangesHistoryPage } from '../pages/TTTFChangesHistoryPage';
import { TTTFPendingApprovalsPage } from '../pages/TTTFPendingApprovalsPage';
import { TTTFDatabaseHelper } from '../helpers/TTTFDatabaseHelper';

/**
 * TTTF New Zeal Setup Step Definitions
 * Source: SCENARIO_03_NewZeal_Approval.txt
 * Implements Maker-Checker workflow for new zeal setup
 */
@StepDefinitions
export class TTTFNewZealSteps {

    @Page('tttf-navigation')
    private navigationPage!: TTTFNavigationPage;

    @Page('tttf-zeal-premisis')
    private zealPremisisPage!: TTTFZealPremisisPage;

    @Page('tttf-zeal-details')
    private zealDetailsPage!: TTTFZealDetailsPage;

    @Page('tttf-scattered-mmtes-modal')
    private scatteredMmtesModalPage!: TTTFScatteredMmtesModalPage;

    @Page('tttf-changes-history')
    private changesHistoryPage!: TTTFChangesHistoryPage;

    @Page('tttf-pending-approvals')
    private pendingApprovalsPage!: TTTFPendingApprovalsPage;

    private context = CSBDDContext.getInstance();
    private scenarioContext = CSScenarioContext.getInstance();

    // ===================================================================
    // TEST DATA SETUP STEPS
    // ===================================================================

    @CSBDDStepDef('I get zeal for new setup from database')
    async getZealForNewSetupFromDatabase(): Promise<void> {
        CSReporter.info('Getting zeal for new setup from database');

        const zealDetails = await TTTFDatabaseHelper.getZealForNewSetup();
        if (!zealDetails) {
            throw new Error('No zeal available for new setup in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);
        this.scenarioContext.setVariable('premisisDescription', zealDetails.premisisDescription);
        this.scenarioContext.setVariable('calcShoolName', zealDetails.calcShoolName);
        this.scenarioContext.setVariable('administrator', zealDetails.administrator);

        CSReporter.pass(`Retrieved zeal for new setup: ID=${zealDetails.zealId}, Name=${zealDetails.zealName}`);
    }

    @CSBDDStepDef('I get scattered mmtes to add from database')
    async getScatteredMmtesToAddFromDatabase(): Promise<void> {
        CSReporter.info('Getting scattered mmtes to add from database');

        const scatteredMmtes = await TTTFDatabaseHelper.getScatteredMmtesToAdd();
        if (scatteredMmtes.length === 0) {
            throw new Error('No scattered mmtes available to add from database');
        }

        const mmteNames = scatteredMmtes.map(r => r.scatteredMmteName);
        this.scenarioContext.setVariable('scatteredMmtesToAdd', mmteNames);
        this.scenarioContext.setVariable('scatteredMmtesDetails', scatteredMmtes);

        CSReporter.pass(`Retrieved ${mmteNames.length} scattered mmtes to add: ${mmteNames.join(', ')}`);
    }

    // ===================================================================
    // ZEAL DETAILS PAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Details page')
    async verifyZealDetailsPage(): Promise<void> {
        await this.zealDetailsPage.verifyZealDetailsPageDisplayed();
    }

    @CSBDDStepDef('I should see Edit Zeal page')
    async verifyEditZealPage(): Promise<void> {
        await this.zealDetailsPage.verifyEditZealPageDisplayed();
    }

    @CSBDDStepDef('Edit button should be enabled')
    async verifyEditButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isEditButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Edit button is enabled');
        } else {
            throw new Error('Edit button is not enabled');
        }
    }

    @CSBDDStepDef('Edit button should be disabled')
    async verifyEditButtonDisabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isEditButtonEnabled();
        if (!isEnabled) {
            CSReporter.pass('Edit button is disabled');
        } else {
            throw new Error('Edit button is not disabled');
        }
    }

    @CSBDDStepDef('I click Edit button')
    async clickEditButton(): Promise<void> {
        await this.zealDetailsPage.clickEditButton();
    }

    @CSBDDStepDef('Details tab should be selected')
    async verifyDetailsTabSelected(): Promise<void> {
        const isSelected = await this.zealDetailsPage.isDetailsTabSelected();
        if (isSelected) {
            CSReporter.pass('Details tab is selected');
        } else {
            throw new Error('Details tab is not selected');
        }
    }

    @CSBDDStepDef('I click Changes tab')
    async clickChangesTab(): Promise<void> {
        await this.zealDetailsPage.clickChangesTab();
    }

    @CSBDDStepDef('I click History tab')
    async clickHistoryTab(): Promise<void> {
        await this.zealDetailsPage.clickHistoryTab();
    }

    @CSBDDStepDef('I click Details tab')
    async clickDetailsTab(): Promise<void> {
        await this.zealDetailsPage.clickDetailsTab();
    }

    @CSBDDStepDef('Changes tab should be present')
    async verifyChangesTabPresent(): Promise<void> {
        const isPresent = await this.zealDetailsPage.isChangesTabPresent();
        if (isPresent) {
            CSReporter.pass('Changes tab is present');
        } else {
            throw new Error('Changes tab is not present');
        }
    }

    @CSBDDStepDef('History tab should be present')
    async verifyHistoryTabPresent(): Promise<void> {
        const isPresent = await this.zealDetailsPage.isHistoryTabPresent();
        if (isPresent) {
            CSReporter.pass('History tab is present');
        } else {
            throw new Error('History tab is not present');
        }
    }

    @CSBDDStepDef('Cancel button should be enabled')
    async verifyZealCancelButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isCancelButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Cancel button is enabled');
        } else {
            throw new Error('Cancel button is not enabled');
        }
    }

    @CSBDDStepDef('Use Sketchmark Replacement checkbox should be unchecked')
    async verifyUseSketchmarkReplacementUnchecked(): Promise<void> {
        const isChecked = await this.zealDetailsPage.isUseSketchmarkReplacementChecked();
        if (!isChecked) {
            CSReporter.pass('Use Sketchmark Replacement checkbox is unchecked');
        } else {
            throw new Error('Use Sketchmark Replacement checkbox should be unchecked but is checked');
        }
    }

    @CSBDDStepDef('Output Ttcalc File checkbox should be unchecked')
    async verifyOutputTtcalcFileUnchecked(): Promise<void> {
        const isChecked = await this.zealDetailsPage.isOutputTtcalcFileChecked();
        if (!isChecked) {
            CSReporter.pass('Output Ttcalc File checkbox is unchecked');
        } else {
            throw new Error('Output Ttcalc File checkbox should be unchecked but is checked');
        }
    }

    @CSBDDStepDef('Reorder button should be visible')
    async verifyReorderButtonVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isReorderButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reorder button is visible');
        } else {
            throw new Error('Reorder button is not visible');
        }
    }

    // ===================================================================
    // SUMMARY SECTION VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('Summary section should be visible')
    async verifySummaryVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.summaryHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Summary section is visible');
        } else {
            throw new Error('Summary section is not visible');
        }
    }

    @CSBDDStepDef('Zeal ID in Summary should match stored value')
    async verifyZealIdInSummary(): Promise<void> {
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealDetailsPage.getZealId();

        if (actualZealId === expectedZealId) {
            CSReporter.pass(`Zeal ID matches: ${actualZealId}`);
        } else {
            throw new Error(`Zeal ID mismatch: Expected=${expectedZealId}, Actual=${actualZealId}`);
        }
    }

    @CSBDDStepDef('Zeal Name in Summary should match stored value')
    async verifyZealNameInSummary(): Promise<void> {
        const expectedZealName = this.scenarioContext.getVariable('zealName');
        const actualZealName = await this.zealDetailsPage.getZealName();

        if (actualZealName === expectedZealName) {
            CSReporter.pass(`Zeal Name matches: ${actualZealName}`);
        } else {
            throw new Error(`Zeal Name mismatch: Expected=${expectedZealName}, Actual=${actualZealName}`);
        }
    }

    // ===================================================================
    // SETTINGS SECTION STEPS
    // ===================================================================

    @CSBDDStepDef('Use Sketchmark Replacement should show {string}')
    async verifyUseSketchmarkReplacementValue(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows: ${actualValue}`);
        } else {
            throw new Error(`Use Sketchmark Replacement mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('Output Ttcalc File should show {string}')
    async verifyOutputTtcalcFileValue(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getOutputTtcalcFileValue();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`Output Ttcalc File shows: ${actualValue}`);
        } else {
            throw new Error(`Output Ttcalc File mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I check Use Sketchmark Replacement checkbox')
    async checkUseSketchmarkReplacement(): Promise<void> {
        await this.zealDetailsPage.checkUseSketchmarkReplacement();
    }

    @CSBDDStepDef('I uncheck Use Sketchmark Replacement checkbox')
    async uncheckUseSketchmarkReplacement(): Promise<void> {
        await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
    }

    @CSBDDStepDef('I check Output Ttcalc File checkbox')
    async checkOutputTtcalcFile(): Promise<void> {
        await this.zealDetailsPage.checkOutputTtcalcFile();
    }

    @CSBDDStepDef('I uncheck Output Ttcalc File checkbox')
    async uncheckOutputTtcalcFile(): Promise<void> {
        await this.zealDetailsPage.uncheckOutputTtcalcFile();
    }

    @CSBDDStepDef('I select FFX Inductor Type {string}')
    async selectFfxInductorType(inductorType: string): Promise<void> {
        const resolvedInductorType = CSValueResolver.resolve(inductorType, this.context);
        await this.zealDetailsPage.selectFfxInductorType(resolvedInductorType);
    }

    @CSBDDStepDef('FFX Inductor Type dropdown should show {string}')
    async verifyFfxInductorTypeSelected(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getSelectedFfxInductorType();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`FFX Inductor Type shows: ${actualValue}`);
        } else {
            throw new Error(`FFX Inductor Type mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify FFX Inductor Type options against database')
    async verifyFfxInductorTypeOptionsAgainstDatabase(): Promise<void> {
        const dbOptions = await TTTFDatabaseHelper.getFfxInductorOptions();
        const uiOptions = await this.zealDetailsPage.getFfxInductorTypeOptions();

        const missingInUI = dbOptions.filter(opt => !uiOptions.includes(opt));
        if (missingInUI.length > 0) {
            throw new Error(`FFX Inductor Type options missing in UI: ${missingInUI.join(', ')}`);
        }

        CSReporter.pass(`All ${dbOptions.length} FFX Inductor Type options verified`);
    }

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES STEPS
    // ===================================================================

    @CSBDDStepDef('No Scattered Mmtes message should be visible')
    async verifyNoScatteredMmtesMessage(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isNoScatteredMmtesMessageVisible();
        if (isVisible) {
            CSReporter.pass('No Scattered Mmtes message is visible');
        } else {
            throw new Error('No Scattered Mmtes message is not visible');
        }
    }

    @CSBDDStepDef('I wait for Add Remove button to be visible')
    async waitForAddRemoveButton(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isAddRemoveButtonVisible();
        if (isVisible) {
            CSReporter.pass('Add/Remove button is visible');
        } else {
            throw new Error('Add/Remove button is not visible after waiting');
        }
    }

    @CSBDDStepDef('I click Add Remove button')
    async clickAddRemoveButton(): Promise<void> {
        await this.zealDetailsPage.clickAddRemoveButton();
    }

    @CSBDDStepDef('Select Options modal should be visible')
    async verifySelectOptionsModalVisible(): Promise<void> {
        await this.scatteredMmtesModalPage.verifySelectOptionsModalDisplayed();
    }

    @CSBDDStepDef('I select scattered mmte {string} in modal')
    async selectScatteredMmteInModal(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        await this.scatteredMmtesModalPage.selectScatteredMmte(resolvedMmteName);
    }

    @CSBDDStepDef('I select all stored scattered mmtes in modal')
    async selectAllStoredScatteredMmtesInModal(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];

        for (const mmteName of mmteNames) {
            await this.scatteredMmtesModalPage.selectScatteredMmte(mmteName);
        }

        CSReporter.pass(`Selected ${mmteNames.length} scattered mmtes in modal`);
    }

    @CSBDDStepDef('I click Apply button in modal')
    async clickApplyButtonInModal(): Promise<void> {
        await this.scatteredMmtesModalPage.clickApplyButton();
        await this.scatteredMmtesModalPage.waitForModalToClose();
    }

    @CSBDDStepDef('I click Cancel button in Scattered Mmtes modal')
    async clickCancelButtonInScatteredMmtesModal(): Promise<void> {
        await this.scatteredMmtesModalPage.clickCancelButton();
    }

    @CSBDDStepDef('Scattered mmtes should be displayed in Associated Scattered Mmtes section')
    async verifyScatteredMmtesDisplayed(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const rowCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (rowCount !== mmteNames.length) {
            throw new Error(`Scattered mmte count mismatch: Expected=${mmteNames.length}, Actual=${rowCount}`);
        }

        for (let i = 0; i < rowCount; i++) {
            const rowData = await this.zealDetailsPage.getScatteredMmteRowData(i);

            // Verify FFX Order
            if (parseInt(rowData.ffxOrder) !== i + 1) {
                throw new Error(`Row ${i} FFX Order mismatch: Expected=${i + 1}, Actual=${rowData.ffxOrder}`);
            }

            // Verify Scattered Mmte Name is in the list
            if (!mmteNames.includes(rowData.scatteredMmteName)) {
                throw new Error(`Unexpected scattered mmte: ${rowData.scatteredMmteName}`);
            }

            CSReporter.info(`Row ${i}: FFX=${rowData.ffxOrder}, Mmte=${rowData.scatteredMmteName}, Cumulative=${rowData.cumulativeMmteName}`);
        }

        CSReporter.pass(`All ${rowCount} scattered mmtes verified`);
    }

    // ===================================================================
    // DISPUTED SCATTERED MMTE STEPS
    // ===================================================================

    @CSBDDStepDef('I click Disputed Select button for row {int}')
    async clickDisputedSelectButton(rowIndex: number): Promise<void> {
        await this.zealDetailsPage.clickDisputedSelectButton(rowIndex);
    }

    @CSBDDStepDef('Add Scattered Mmtes modal should be visible')
    async verifyAddScatteredMmtesModalVisible(): Promise<void> {
        await this.scatteredMmtesModalPage.verifyAddScatteredMmtesModalDisplayed();
    }

    @CSBDDStepDef('I select disputed scattered mmte {string} in modal')
    async selectDisputedScatteredMmteInModal(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(resolvedMmteName);
    }

    @CSBDDStepDef('I enter disputed start date {string} for row {int}')
    async enterDisputedStartDate(date: string, rowIndex: number): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        await this.zealDetailsPage.enterDisputedStartDate(rowIndex, resolvedDate);
    }

    // ===================================================================
    // ACTION BUTTON STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Save button should be enabled')
    async verifyZealSaveButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isSaveButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Zeal Save button is enabled');
        } else {
            throw new Error('Zeal Save button is not enabled');
        }
    }

    @CSBDDStepDef('Save button should be disabled')
    async verifySaveButtonDisabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isSaveButtonEnabled();
        if (!isEnabled) {
            CSReporter.pass('Save button is disabled');
        } else {
            throw new Error('Save button is not disabled');
        }
    }

    @CSBDDStepDef('I click Save button')
    async clickSaveButton(): Promise<void> {
        await this.zealDetailsPage.clickSaveButton();
    }

    @CSBDDStepDef('I should see save success message')
    async verifySaveSuccessMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        const zealId = this.scenarioContext.getVariable('zealId');

        if (messageText.includes('saved') || messageText.includes(zealId)) {
            CSReporter.pass(`Save success message: ${messageText}`);
        } else {
            throw new Error(`Expected save success message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I should see pending approval alert')
    async verifyPendingApprovalAlert(): Promise<void> {
        const feedbackText = await this.zealDetailsPage.getFeedbackMessageText();

        if (feedbackText.includes('pending approval')) {
            CSReporter.pass(`Pending approval alert: ${feedbackText}`);
        } else {
            throw new Error(`Expected pending approval alert, got: ${feedbackText}`);
        }
    }

    @CSBDDStepDef('View Changes link should be visible')
    async verifyViewChangesLinkVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isViewChangesLinkVisible();
        if (isVisible) {
            CSReporter.pass('View Changes link is visible');
        } else {
            throw new Error('View Changes link is not visible');
        }
    }

    @CSBDDStepDef('I click View Changes link')
    async clickViewChangesLink(): Promise<void> {
        await this.zealDetailsPage.clickViewChangesLink();
    }

    // ===================================================================
    // CHANGES TAB STEPS
    // ===================================================================

    @CSBDDStepDef('Changes section should be visible')
    async verifyChangesSectionVisible(): Promise<void> {
        await this.changesHistoryPage.verifyChangesHeaderDisplayed();
    }

    @CSBDDStepDef('Changes table should show pending changes')
    async verifyChangesTableHasData(): Promise<void> {
        const rowCount = await this.changesHistoryPage.getChangesRowCount();
        if (rowCount > 0) {
            CSReporter.pass(`Changes table has ${rowCount} rows`);
        } else {
            throw new Error('Changes table is empty');
        }
    }

    @CSBDDStepDef('I verify changes data matches added scattered mmtes')
    async verifyChangesDataMatchesScatteredMmtes(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const changesData = await this.changesHistoryPage.getAllChangesData();

        for (const change of changesData) {
            if (change.description !== 'Add Scattered Mmte') {
                throw new Error(`Unexpected change description: ${change.description}`);
            }

            if (!mmteNames.includes(change.newValue)) {
                throw new Error(`Unexpected scattered mmte in changes: ${change.newValue}`);
            }

            CSReporter.info(`Change: ${change.description} - ${change.newValue}, Modified By: ${change.modifiedBy}`);
        }

        CSReporter.pass(`All ${changesData.length} changes verified`);
    }

    @CSBDDStepDef('Cancel Changes button should be visible')
    async verifyCancelChangesButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isCancelChangesButtonVisible();
        if (isVisible) {
            CSReporter.pass('Cancel Changes button is visible');
        } else {
            throw new Error('Cancel Changes button is not visible');
        }
    }

    @CSBDDStepDef('Approve button should be visible')
    async verifyApproveButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isApproveButtonVisible();
        if (isVisible) {
            CSReporter.pass('Approve button is visible');
        } else {
            throw new Error('Approve button is not visible');
        }
    }

    @CSBDDStepDef('Reject button should be visible')
    async verifyRejectButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isRejectButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reject button is visible');
        } else {
            throw new Error('Reject button is not visible');
        }
    }

    @CSBDDStepDef('I click Approve button')
    async clickApproveButton(): Promise<void> {
        await this.changesHistoryPage.clickApproveButton();
    }

    @CSBDDStepDef('I click Reject button')
    async clickRejectButton(): Promise<void> {
        await this.changesHistoryPage.clickRejectButton();
    }

    @CSBDDStepDef('Changes table should be empty after approval')
    async verifyChangesTableEmpty(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after approval');
        } else {
            throw new Error('Changes table is not empty after approval');
        }
    }

    // ===================================================================
    // HISTORY TAB STEPS
    // ===================================================================

    @CSBDDStepDef('History section should be visible')
    async verifyHistorySectionVisible(): Promise<void> {
        await this.changesHistoryPage.verifyHistoryHeaderDisplayed();
    }

    @CSBDDStepDef('History table should show approved changes')
    async verifyHistoryTableHasData(): Promise<void> {
        const rowCount = await this.changesHistoryPage.getHistoryRowCount();
        if (rowCount > 0) {
            CSReporter.pass(`History table has ${rowCount} rows`);
        } else {
            throw new Error('History table is empty');
        }
    }

    @CSBDDStepDef('I verify history data matches approved scattered mmtes')
    async verifyHistoryDataMatchesScatteredMmtes(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const historyData = await this.changesHistoryPage.getAllHistoryData();

        for (const history of historyData) {
            if (history.description !== 'Add Scattered Mmte') {
                throw new Error(`Unexpected history description: ${history.description}`);
            }

            if (!mmteNames.includes(history.newValue)) {
                throw new Error(`Unexpected scattered mmte in history: ${history.newValue}`);
            }

            CSReporter.info(`History: ${history.description} - ${history.newValue}, Approved By: ${history.approvedBy}`);
        }

        CSReporter.pass(`All ${historyData.length} history entries verified`);
    }

    // ===================================================================
    // BROWSER CONTEXT / RE-AUTHENTICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I clear browser context for re-authentication')
    async clearBrowserContextForReauth(): Promise<void> {
        CSReporter.info('Clearing browser context for re-authentication (switching user)');
        const browserManager = CSBrowserManager.getInstance();
        await browserManager.clearContextAndReauthenticate();
        CSReporter.pass('Browser context cleared, ready for new user login');
    }

    // ===================================================================
    // PENDING APPROVALS PAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I navigate to Pending Approvals page')
    async navigateToPendingApprovalsPage(): Promise<void> {
        await this.navigationPage.clickMenuItem('Pending Approvals');
        await this.pendingApprovalsPage.verifyPageDisplayed();
    }

    @CSBDDStepDef('Pending Approvals page should be displayed')
    async verifyPendingApprovalsPageDisplayed(): Promise<void> {
        await this.pendingApprovalsPage.verifyPageDisplayed();
    }

    @CSBDDStepDef('I find and click View link for stored zeal')
    async findAndClickViewForStoredZeal(): Promise<void> {
        const zealName = this.scenarioContext.getVariable('zealName');
        await this.pendingApprovalsPage.clickViewLinkByZealName(zealName);
    }

    // ===================================================================
    // DATABASE VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I verify zeal data record exists in database')
    async verifyZealDataRecordExists(): Promise<void> {
        const zealId = this.scenarioContext.getVariable('zealId');
        const zealData = await TTTFDatabaseHelper.getZealDataByZealId(zealId);

        if (!zealData) {
            throw new Error(`Zeal data record not found for zeal ID: ${zealId}`);
        }

        this.scenarioContext.setVariable('zealpremisisDataId', zealData.zealpremisisDataId);
        CSReporter.pass(`Zeal data record exists: zealpremisisDataId=${zealData.zealpremisisDataId}`);
    }

    @CSBDDStepDef('I verify zealpremisis data has correct settings')
    async verifyZealpremisisDataSettings(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const details = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!details) {
            throw new Error(`Zealpremisis data details not found for ID: ${zealpremisisDataId}`);
        }

        CSReporter.info(`Zealpremisis data: sketchmarkFlag=${details.sketchmarkReplacementFlag}, inductorCode=${details.inductorCode}`);
        CSReporter.pass('Zealpremisis data settings verified');
    }

    @CSBDDStepDef('I verify status log shows {string} status')
    async verifyStatusLogStatus(expectedStatus: string): Promise<void> {
        const resolvedStatus = CSValueResolver.resolve(expectedStatus, this.context) as 'AWAITING' | 'APPROVED' | 'REJECTED';
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');

        const isCorrect = await TTTFDatabaseHelper.verifyStatusLogStatus(zealpremisisDataId, resolvedStatus);

        if (isCorrect) {
            CSReporter.pass(`Status log shows ${resolvedStatus} status`);
        } else {
            throw new Error(`Status log does not show ${resolvedStatus} status`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data exists after approval')
    async verifyZealpremisisMmteDataExists(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            throw new Error('No zealpremisis mmte data found after approval');
        }

        CSReporter.pass(`Zealpremisis mmte data exists: ${mmteData.length} records`);
    }

    // ===================================================================
    // PREMISIS-SPECIFIC STEPS
    // ===================================================================

    @CSBDDStepDef('I get premisis for new setup from database')
    async getPremisisForNewSetupFromDatabase(): Promise<void> {
        CSReporter.info('Getting premisis for new setup from database');

        const premisisDetails = await TTTFDatabaseHelper.getPremisisForNewSetup();
        if (!premisisDetails) {
            throw new Error('No premisis available for new setup in database');
        }

        this.scenarioContext.setVariable('zealId', premisisDetails.zealId);
        this.scenarioContext.setVariable('zealKey', premisisDetails.zealKey);
        this.scenarioContext.setVariable('zealName', premisisDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', premisisDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', premisisDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', premisisDetails.zzztSeggregation);
        this.scenarioContext.setVariable('premisisDescription', premisisDetails.premisisDescription);
        this.scenarioContext.setVariable('calcShoolName', premisisDetails.calcShoolName);
        this.scenarioContext.setVariable('administrator', premisisDetails.administrator);
        this.scenarioContext.setVariable('zzztId', premisisDetails.zzztId);

        CSReporter.pass(`Retrieved premisis for new setup: ID=${premisisDetails.zealId}, Zzzt Abbrev=${premisisDetails.zzztSeggregation}`);
    }

    @CSBDDStepDef('I should see Premisis Details page')
    async verifyPremisisDetailsPage(): Promise<void> {
        await this.zealDetailsPage.verifyPremisisDetailsPageDisplayed();
    }

    @CSBDDStepDef('I should see Edit Premisis page')
    async verifyEditPremisisPage(): Promise<void> {
        await this.zealDetailsPage.verifyEditPremisisPageDisplayed();
    }

    @CSBDDStepDef('Output Ttcalc File checkbox should be disabled for Premisis')
    async verifyOutputCalcFileDisabledForPremisis(): Promise<void> {
        const isDisabled = await this.zealDetailsPage.isOutputTtcalcFileCheckboxDisabled();
        if (isDisabled) {
            CSReporter.pass('Output Ttcalc File checkbox is disabled for Premisis');
        } else {
            throw new Error('Output Ttcalc File checkbox should be disabled for Premisis');
        }
    }

    @CSBDDStepDef('FFX Inductor Type dropdown should be disabled for Premisis')
    async verifyFfxInductorTypeDisabledForPremisis(): Promise<void> {
        const isDisabled = await this.zealDetailsPage.isFfxInductorTypeDropdownDisabled();
        if (isDisabled) {
            CSReporter.pass('FFX Inductor Type dropdown is disabled for Premisis');
        } else {
            throw new Error('FFX Inductor Type dropdown should be disabled for Premisis');
        }
    }

    @CSBDDStepDef('I should see save success message for Premisis')
    async verifySaveSuccessMessageForPremisis(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        const zzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');

        if (messageText.includes('saved') || messageText.includes(zzztAbbrev)) {
            CSReporter.pass(`Save success message for Premisis: ${messageText}`);
        } else {
            throw new Error(`Expected save success message for Premisis, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I verify zzzt data record exists in database')
    async verifyZzztDataRecordExists(): Promise<void> {
        const zzztId = this.scenarioContext.getVariable('zzztId') || this.scenarioContext.getVariable('zealId');
        const zzztData = await TTTFDatabaseHelper.getZzztDataByZzztId(zzztId);

        if (!zzztData) {
            throw new Error(`Zzzt data record not found for zzzt ID: ${zzztId}`);
        }

        this.scenarioContext.setVariable('zealpremisisDataId', zzztData.zealpremisisDataId);
        CSReporter.pass(`Zzzt data record exists: zealpremisisDataId=${zzztData.zealpremisisDataId}`);
    }

    @CSBDDStepDef('I verify zealpremisis data has correct settings for Premisis')
    async verifyZealpremisisDataSettingsForPremisis(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const details = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!details) {
            throw new Error(`Zealpremisis data details not found for ID: ${zealpremisisDataId}`);
        }

        // For Premisis, Output Ttcalc File should be disabled (null/empty inductor code)
        CSReporter.info(`Premisis zealpremisis data: sketchmarkFlag=${details.sketchmarkReplacementFlag}, inductorCode=${details.inductorCode || 'N/A'}`);
        CSReporter.pass('Premisis zealpremisis data settings verified');
    }

    // ===================================================================
    // REJECTION FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('Review Reject Email modal should be visible')
    async verifyRejectEmailModalVisible(): Promise<void> {
        await this.changesHistoryPage.verifyRejectEmailModalDisplayed();
    }

    @CSBDDStepDef('Reject comment textarea should be visible')
    async verifyRejectCommentTextareaVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isRejectCommentTextareaVisible();
        if (isVisible) {
            CSReporter.pass('Reject comment textarea is visible');
        } else {
            throw new Error('Reject comment textarea is not visible');
        }
    }

    @CSBDDStepDef('Send button should be visible')
    async verifySendButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isSendButtonVisible();
        if (isVisible) {
            CSReporter.pass('Send button is visible');
        } else {
            throw new Error('Send button is not visible');
        }
    }

    @CSBDDStepDef('I enter rejection comment {string}')
    async enterRejectionComment(comment: string): Promise<void> {
        const resolvedComment = CSValueResolver.resolve(comment, this.context);
        await this.changesHistoryPage.enterRejectComment(resolvedComment);
    }

    @CSBDDStepDef('I click Send button in Reject modal')
    async clickSendButtonInRejectModal(): Promise<void> {
        await this.changesHistoryPage.clickSendButton();
    }

    @CSBDDStepDef('Rejection email sent message should be displayed')
    async verifyRejectionEmailSentMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Rejection') && messageText.includes('sent')) {
            CSReporter.pass(`Rejection email sent message: ${messageText}`);
        } else {
            throw new Error(`Expected rejection email sent message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('Changes table should be empty after rejection')
    async verifyChangesTableEmptyAfterRejection(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after rejection');
        } else {
            throw new Error('Changes table is not empty after rejection');
        }
    }

    @CSBDDStepDef('History table should show no data')
    async verifyHistoryTableNoData(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isHistoryNoDataVisible();
        if (isNoData) {
            CSReporter.pass('History table shows no data');
        } else {
            throw new Error('History table should show no data');
        }
    }

    @CSBDDStepDef('I verify status log is cleared after rejection')
    async verifyStatusLogClearedAfterRejection(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const statusLog = await TTTFDatabaseHelper.getZealpremisisStatusLog(zealpremisisDataId);

        if (statusLog.length === 0) {
            CSReporter.pass('Status log is cleared after rejection');
        } else {
            throw new Error(`Status log should be empty after rejection, found ${statusLog.length} records`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data does not exist after rejection')
    async verifyZealpremisisMmteDataNotExistsAfterRejection(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            CSReporter.pass('No zealpremisis mmte data exists after rejection');
        } else {
            throw new Error(`Zealpremisis mmte data should not exist after rejection, found ${mmteData.length} records`);
        }
    }

    // ===================================================================
    // CANCEL FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('I click Cancel Changes button')
    async clickCancelChangesButton(): Promise<void> {
        await this.changesHistoryPage.clickCancelChangesButton();
    }

    @CSBDDStepDef('Cancel changes success message should be displayed')
    async verifyCancelChangesSuccessMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Cancelled') || messageText.includes('cancelled')) {
            CSReporter.pass(`Cancel changes success message: ${messageText}`);
        } else {
            throw new Error(`Expected cancel changes success message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('Changes table should be empty after cancel')
    async verifyChangesTableEmptyAfterCancel(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after cancel');
        } else {
            throw new Error('Changes table is not empty after cancel');
        }
    }

    @CSBDDStepDef('I verify status log is cleared after cancel')
    async verifyStatusLogClearedAfterCancel(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const statusLog = await TTTFDatabaseHelper.getZealpremisisStatusLog(zealpremisisDataId);

        if (statusLog.length === 0) {
            CSReporter.pass('Status log is cleared after cancel');
        } else {
            throw new Error(`Status log should be empty after cancel, found ${statusLog.length} records`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data does not exist after cancel')
    async verifyZealpremisisMmteDataNotExistsAfterCancel(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            CSReporter.pass('No zealpremisis mmte data exists after cancel');
        } else {
            throw new Error(`Zealpremisis mmte data should not exist after cancel, found ${mmteData.length} records`);
        }
    }

    // ===================================================================
    // EDIT NAVIGATION STEPS (SCENARIO_08, 09A)
    // ===================================================================

    @CSBDDStepDef('I get zeal for edit navigation from database')
    async getZealForEditNavigationFromDatabase(): Promise<void> {
        CSReporter.info('Getting zeal for edit navigation from database');

        const zealDetails = await TTTFDatabaseHelper.getZealForEditNavigation();
        if (!zealDetails) {
            throw new Error('No zeal available for edit navigation in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);

        CSReporter.pass(`Retrieved zeal for edit navigation: ID=${zealDetails.zealId}, Key=${zealDetails.zealKey}`);
    }

    @CSBDDStepDef('I get premisis for edit navigation from database')
    async getPremisisForEditNavigationFromDatabase(): Promise<void> {
        CSReporter.info('Getting premisis for edit navigation from database');

        const premisisDetails = await TTTFDatabaseHelper.getPremisisForEditNavigation();
        if (!premisisDetails) {
            throw new Error('No premisis available for edit navigation in database');
        }

        this.scenarioContext.setVariable('zealId', premisisDetails.zealId);
        this.scenarioContext.setVariable('zealKey', premisisDetails.zealKey);
        this.scenarioContext.setVariable('zealName', premisisDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', premisisDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', premisisDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', premisisDetails.zzztSeggregation);
        this.scenarioContext.setVariable('zzztId', premisisDetails.zzztId);

        CSReporter.pass(`Retrieved premisis for edit navigation: ID=${premisisDetails.zealId}, ZzztAbbrev=${premisisDetails.zzztSeggregation}`);
    }

    @CSBDDStepDef('I uncheck Include Premisis in results checkbox')
    async uncheckIncludePremisisInResultsCheckbox(): Promise<void> {
        await this.zealPremisisPage.uncheckIncludePremisisCheckbox();
    }

    @CSBDDStepDef('Search results should show type {string}')
    async verifySearchResultsType(expectedType: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(expectedType, this.context);
        const actualType = await this.zealPremisisPage.getSearchResultTypeValue(1);

        if (actualType === resolvedType) {
            CSReporter.pass(`Search results show correct type: ${actualType}`);
        } else {
            throw new Error(`Expected type "${resolvedType}", got "${actualType}"`);
        }
    }

    @CSBDDStepDef('Search results should show stored zeal ID')
    async verifySearchResultsShowStoredZealId(): Promise<void> {
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealPremisisPage.getSearchResultZealIdValue(1);

        if (actualZealId === expectedZealId) {
            CSReporter.pass(`Search results show correct zeal ID: ${actualZealId}`);
        } else {
            throw new Error(`Expected zeal ID "${expectedZealId}", got "${actualZealId}"`);
        }
    }

    @CSBDDStepDef('Search results should show stored zeal key')
    async verifySearchResultsShowStoredZealKey(): Promise<void> {
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealPremisisPage.getSearchResultZealKeyValue(1);

        if (actualZealKey === expectedZealKey) {
            CSReporter.pass(`Search results show correct zeal key: ${actualZealKey}`);
        } else {
            throw new Error(`Expected zeal key "${expectedZealKey}", got "${actualZealKey}"`);
        }
    }

    @CSBDDStepDef('I click Cancel button')
    async clickCancelButton(): Promise<void> {
        await this.zealDetailsPage.clickCancelButton();
    }

    @CSBDDStepDef('Warning popup should be displayed')
    async verifyWarningPopupDisplayed(): Promise<void> {
        await this.zealDetailsPage.verifyWarningPopupDisplayed();
    }

    @CSBDDStepDef('Warning popup should show unsaved changes message')
    async verifyWarningPopupUnsavedChangesMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getWarningPopupMessage();
        if (messageText.includes('changes are not saved') || messageText.includes('save before')) {
            CSReporter.pass(`Warning popup shows unsaved changes message: ${messageText}`);
        } else {
            throw new Error(`Expected unsaved changes warning, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('OK button should be visible in warning popup')
    async verifyOkButtonVisibleInWarningPopup(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isWarningPopupOkButtonVisible();
        if (isVisible) {
            CSReporter.pass('OK button is visible in warning popup');
        } else {
            throw new Error('OK button is not visible in warning popup');
        }
    }

    @CSBDDStepDef('I click OK button in warning popup')
    async clickOkButtonInWarningPopup(): Promise<void> {
        await this.zealDetailsPage.clickWarningPopupOkButton();
    }

    @CSBDDStepDef('I click Edit link in Action column for row {int}')
    async clickEditLinkInActionColumn(rowIndex: number): Promise<void> {
        await this.zealPremisisPage.clickEditLinkInActionColumn(rowIndex);
    }

    @CSBDDStepDef('I should see Edit Zeal page directly')
    async verifyEditZealPageDirectly(): Promise<void> {
        await this.zealDetailsPage.verifyEditZealPageDisplayed();
        CSReporter.pass('Navigated directly to Edit Zeal page via Action column');
    }

    @CSBDDStepDef('I should see Edit Premisis page directly')
    async verifyEditPremisisPageDirectly(): Promise<void> {
        await this.zealDetailsPage.verifyEditPremisisPageDisplayed();
        CSReporter.pass('Navigated directly to Edit Premisis page via Action column');
    }

    // ===================================================================
    // EXISTING ZEAL UPDATE STEPS (SCENARIO_09B)
    // ===================================================================

    @CSBDDStepDef('I get existing zeal with scattered mmtes from database')
    async getExistingZealWithScatteredMmtes(): Promise<void> {
        CSReporter.info('Getting existing zeal with scattered mmtes from database');

        const zealDetails = await TTTFDatabaseHelper.getExistingZealWithScatteredMmtes();
        if (!zealDetails) {
            throw new Error('No existing zeal with scattered mmtes found in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);
        this.scenarioContext.setVariable('sketchmarkFlag', zealDetails.sketchmarkFlag);
        this.scenarioContext.setVariable('inductorCode', zealDetails.inductorCode);
        this.scenarioContext.setVariable('existingScatteredMmtes', zealDetails.scatteredMmtes);

        CSReporter.pass(`Retrieved existing zeal: ID=${zealDetails.zealId}, Mmtes=${zealDetails.scatteredMmtes?.length || 0}`);
    }

    @CSBDDStepDef('I get replacement scattered mmtes from database')
    async getReplacementScatteredMmtes(): Promise<void> {
        CSReporter.info('Getting replacement scattered mmtes from database');

        const existingMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];
        const existingMmteNames = existingMmtes.map((r: any) => r.scatteredMmteName);

        const replacementMmtes = await TTTFDatabaseHelper.getReplacementScatteredMmtes(existingMmteNames);
        if (!replacementMmtes || replacementMmtes.length === 0) {
            throw new Error('No replacement scattered mmtes found in database');
        }

        this.scenarioContext.setVariable('replacementScatteredMmtes', replacementMmtes);
        CSReporter.pass(`Retrieved ${replacementMmtes.length} replacement scattered mmtes`);
    }

    @CSBDDStepDef('I verify existing scattered mmtes match database')
    async verifyExistingScatteredMmtesMatchDatabase(): Promise<void> {
        const expectedMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];
        const actualCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (actualCount === expectedMmtes.length) {
            CSReporter.pass(`Existing scattered mmtes match database: ${actualCount} mmtes`);
        } else {
            throw new Error(`Expected ${expectedMmtes.length} scattered mmtes, found ${actualCount}`);
        }
    }

    @CSBDDStepDef('I toggle Use Sketchmark Replacement checkbox')
    async toggleUseSketchmarkReplacementCheckbox(): Promise<void> {
        const currentFlag = this.scenarioContext.getVariable('sketchmarkFlag');
        if (currentFlag === 'Y') {
            await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
        } else {
            await this.zealDetailsPage.checkUseSketchmarkReplacement();
        }
        CSReporter.pass('Toggled Use Sketchmark Replacement checkbox');
    }

    @CSBDDStepDef('I update FFX Inductor Type to different value')
    async updateFfxInductorTypeToDifferentValue(): Promise<void> {
        const currentInductorCode = this.scenarioContext.getVariable('inductorCode');
        const newInductorType = await TTTFDatabaseHelper.getDifferentFfxInductorType(currentInductorCode);

        if (newInductorType) {
            await this.zealDetailsPage.checkOutputTtcalcFile();
            await this.zealDetailsPage.selectFfxInductorType(newInductorType);
            this.scenarioContext.setVariable('newInductorCode', newInductorType);
            CSReporter.pass(`Updated FFX Inductor Type to: ${newInductorType}`);
        } else {
            CSReporter.info('No different FFX Inductor Type available, skipping update');
        }
    }

    @CSBDDStepDef('I unselect existing scattered mmtes in modal')
    async unselectExistingScatteredMmtesInModal(): Promise<void> {
        const existingMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];

        for (const mmte of existingMmtes) {
            await this.scatteredMmtesModalPage.searchScatteredMmte(mmte.scatteredMmteName);
            await this.scatteredMmtesModalPage.unselectScatteredMmte(mmte.scatteredMmteName);
        }

        CSReporter.pass(`Unselected ${existingMmtes.length} existing scattered mmtes`);
    }

    @CSBDDStepDef('I select replacement scattered mmtes in modal')
    async selectReplacementScatteredMmtesInModal(): Promise<void> {
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];

        for (const mmte of replacementMmtes) {
            await this.scatteredMmtesModalPage.searchScatteredMmte(mmte.scatteredMmteName);
            await this.scatteredMmtesModalPage.selectScatteredMmte(mmte.scatteredMmteName);
        }

        CSReporter.pass(`Selected ${replacementMmtes.length} replacement scattered mmtes`);
    }

    @CSBDDStepDef('Updated scattered mmtes should be displayed in Associated Scattered Mmtes section')
    async verifyUpdatedScatteredMmtesDisplayed(): Promise<void> {
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];
        const actualCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (actualCount === replacementMmtes.length) {
            CSReporter.pass(`Updated scattered mmtes displayed: ${actualCount} mmtes`);
        } else {
            throw new Error(`Expected ${replacementMmtes.length} scattered mmtes, found ${actualCount}`);
        }
    }

    @CSBDDStepDef('Changes table should show update changes')
    async verifyChangesTableShowsUpdateChanges(): Promise<void> {
        const changesData = await this.changesHistoryPage.getAllChangesData();

        if (changesData.length > 0) {
            CSReporter.pass(`Changes table shows ${changesData.length} update changes`);
        } else {
            throw new Error('Changes table should show update changes');
        }
    }

    @CSBDDStepDef('Approve Email modal should be visible')
    async verifyApproveEmailModalVisible(): Promise<void> {
        await this.changesHistoryPage.verifyApproveEmailModalDisplayed();
    }

    @CSBDDStepDef('I click Send button in Approve modal')
    async clickSendButtonInApproveModal(): Promise<void> {
        await this.changesHistoryPage.clickSendButtonInApproveModal();
    }

    @CSBDDStepDef('Approval email sent message should be displayed')
    async verifyApprovalEmailSentMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Approval') && messageText.includes('sent')) {
            CSReporter.pass(`Approval email sent message: ${messageText}`);
        } else {
            throw new Error(`Expected approval email sent message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I verify updated scattered mmtes in database')
    async verifyUpdatedScatteredMmtesInDatabase(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];

        if (mmteData.length === replacementMmtes.length) {
            CSReporter.pass(`Updated scattered mmtes verified in database: ${mmteData.length} mmtes`);
        } else {
            throw new Error(`Expected ${replacementMmtes.length} mmtes in database, found ${mmteData.length}`);
        }
    }
}

export default TTTFNewZealSteps;


------------------------------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Zeal Details Page
 * Source: SCENARIO_03_NewZeal_Approval.txt
 * Handles Zeal Details view/edit mode, Settings, Associated Scattered Mmtes
 */
@CSPage('tttf-zeal-details')
export class TTTFZealDetailsPage extends CSBasePage {

    // ===================================================================
    // PAGE HEADER ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h1[text()="Zeal Details"]',
        description: 'Zeal Details page header',
        waitForVisible: true,
        alternativeLocators: ['text:Zeal Details']
    })
    public zealDetailsHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//h1[text()="Edit Zeal"]',
        description: 'Edit Zeal page header (edit mode)',
        waitForVisible: true,
        alternativeLocators: ['text:Edit Zeal']
    })
    public editZealHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and text()='Edit']/parent::button",
        description: 'Edit button',
        waitForEnabled: true
    })
    public editButton!: CSWebElement;

    // ===================================================================
    // TAB ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and text()='Details']/parent::button",
        description: 'Details tab button',
        waitForVisible: true
    })
    public detailsTab!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and contains(text(),'Changes:')]/parent::button",
        description: 'Changes tab button',
        waitForVisible: true
    })
    public changesTab!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and text()='History']/parent::button",
        description: 'History tab button',
        waitForVisible: true
    })
    public historyTab!: CSWebElement;

    // ===================================================================
    // SUMMARY SECTION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Summary"]',
        description: 'Summary section header',
        waitForVisible: true
    })
    public summaryHeader!: CSWebElement;

    // ===================================================================
    // SETTINGS SECTION ELEMENTS (VIEW MODE)
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Settings"]',
        description: 'Settings section header',
        waitForVisible: true
    })
    public settingsHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//strong[text()='Use Sketchmark Replacement']/parent::div/following-sibling::div[1]",
        description: 'Use Sketchmark Replacement value (view mode)',
        waitForVisible: true
    })
    public useSketchmarkReplacementValue!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//strong[text()='Output Ttcalc File']/ancestor::div[@class='flex'][1]/following-sibling::div[1]",
        description: 'Output Ttcalc File value (view mode)',
        waitForVisible: true
    })
    public outputTtcalcFileValue!: CSWebElement;

    // ===================================================================
    // SETTINGS SECTION ELEMENTS (EDIT MODE)
    // ===================================================================

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@role='checkbox' and @aria-label='Use Sketchmark Replacement']",
        description: 'Use Sketchmark Replacement checkbox (edit mode)',
        waitForVisible: true
    })
    public useSketchmarkReplacementCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@role='checkbox' and @aria-label='Output Ttcalc File']",
        description: 'Output Ttcalc File checkbox (edit mode)',
        waitForVisible: true
    })
    public outputTtcalcFileCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: "//button[@name='inductorType']",
        description: 'FFX File Inductor Type dropdown button',
        waitForEnabled: true
    })
    public ffxInductorTypeDropdown!: CSWebElement;

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES SECTION
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Associated Scattered Mmtes"]',
        description: 'Associated Scattered Mmtes section header',
        waitForVisible: true
    })
    public associatedScatteredMmtesHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[text()="No Scattered Mmte Associations Found."]',
        description: 'No Scattered Mmtes message',
        waitForVisible: true
    })
    public noScatteredMmtesMessage!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@class='sssss-button__label' and text()='Add / Remove']/parent::button",
        description: 'Add / Remove button',
        waitForEnabled: true
    })
    public addRemoveButton!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@class='sssss-button__label' and text()='Reorder']/parent::button",
        description: 'Reorder button',
        waitForEnabled: true
    })
    public reorderButton!: CSWebElement;

    // ===================================================================
    // ACTION BUTTONS
    // ===================================================================

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//div[@class='button-bar-container']//span[text()='Save']/parent::button",
        description: 'Save button',
        waitForEnabled: true
    })
    public saveButton!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//div[@class='button-bar-container']//span[text()='Cancel']/parent::button",
        description: 'Cancel button',
        waitForEnabled: true
    })
    public cancelButton!: CSWebElement;

    // ===================================================================
    // MESSAGE ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//div[contains(@class, 'sssss-message-bar__messages')]",
        description: 'Message bar (success/error messages)',
        waitForVisible: true
    })
    public messageBar!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-feedback__messages']//li",
        description: 'Feedback message (pending approval alert)',
        waitForVisible: true
    })
    public feedbackMessage!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-feedback__messages']//li//span[text()='View Changes']/parent::button",
        description: 'View Changes link in feedback',
        waitForVisible: true
    })
    public viewChangesLink!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFZealDetailsPage elements initialized');
    }

    // ===================================================================
    // PAGE VERIFICATION METHODS
    // ===================================================================

    public async verifyZealDetailsPageDisplayed(): Promise<void> {
        await this.zealDetailsHeader.waitForVisible(15000);
        const isVisible = await this.zealDetailsHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Zeal Details page is displayed');
        } else {
            throw new Error('Zeal Details page header not found');
        }
    }

    public async verifyEditZealPageDisplayed(): Promise<void> {
        await this.editZealHeader.waitForVisible(15000);
        const isVisible = await this.editZealHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Edit Zeal page is displayed');
        } else {
            throw new Error('Edit Zeal page header not found');
        }
    }

    public async isEditButtonEnabled(): Promise<boolean> {
        return await this.editButton.isEnabledWithTimeout(5000);
    }

    public async clickEditButton(): Promise<void> {
        await this.editButton.waitForVisible(10000);
        await this.editButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Edit button');
    }

    // ===================================================================
    // TAB METHODS
    // ===================================================================

    public async isDetailsTabSelected(): Promise<boolean> {
        const ariaSelected = await this.detailsTab.getAttributeWithTimeout('aria-selected', 5000);
        return ariaSelected === 'true';
    }

    public async isChangesTabSelected(): Promise<boolean> {
        const ariaSelected = await this.changesTab.getAttributeWithTimeout('aria-selected', 5000);
        return ariaSelected === 'true';
    }

    public async isHistoryTabSelected(): Promise<boolean> {
        const ariaSelected = await this.historyTab.getAttributeWithTimeout('aria-selected', 5000);
        return ariaSelected === 'true';
    }

    public async clickDetailsTab(): Promise<void> {
        await this.detailsTab.clickWithTimeout(10000);
        CSReporter.info('Clicked Details tab');
    }

    public async clickChangesTab(): Promise<void> {
        await this.changesTab.clickWithTimeout(10000);
        CSReporter.info('Clicked Changes tab');
    }

    public async clickHistoryTab(): Promise<void> {
        await this.historyTab.clickWithTimeout(10000);
        CSReporter.info('Clicked History tab');
    }

    public async isChangesTabPresent(): Promise<boolean> {
        return await this.changesTab.isVisibleWithTimeout(5000);
    }

    public async isHistoryTabPresent(): Promise<boolean> {
        return await this.historyTab.isVisibleWithTimeout(5000);
    }

    public async isReorderButtonVisible(): Promise<boolean> {
        const reorderButton = CSElementFactory.createByXPath(
            "//form[@class='sssss-form']//span[@class='sssss-button__label' and text()='Reorder']/parent::button",
            'Reorder button',
            this.page
        );
        return await reorderButton.isVisibleWithTimeout(5000);
    }

    // ===================================================================
    // SUMMARY FIELD METHODS
    // ===================================================================

    public async getSummaryFieldValue(fieldName: string): Promise<string> {
        const fieldElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${fieldName}']/following-sibling::div`,
            `Summary field: ${fieldName}`,
            this.page
        );
        const value = await fieldElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getAdministratorValue(): Promise<string> {
        const adminElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='Administrator']/following-sibling::div/span[@class='sssss-button__label']`,
            'Administrator field value',
            this.page
        );
        const value = await adminElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getZealId(): Promise<string> {
        return await this.getSummaryFieldValue('Zeal ID');
    }

    public async getZealKey(): Promise<string> {
        return await this.getSummaryFieldValue('Zeal Key');
    }

    public async getZealName(): Promise<string> {
        return await this.getSummaryFieldValue('Zeal Name');
    }

    public async getZzztSeggregation(): Promise<string> {
        return await this.getSummaryFieldValue('Zzzt Seggregation');
    }

    public async getPremisisDescription(): Promise<string> {
        return await this.getSummaryFieldValue('Premisis Description');
    }

    public async getInductorGroup(): Promise<string> {
        return await this.getSummaryFieldValue('Inductor Group');
    }

    public async getKindnessCircle(): Promise<string> {
        return await this.getSummaryFieldValue('Kindness Circle');
    }

    public async getTtcalcShool(): Promise<string> {
        return await this.getSummaryFieldValue('Ttcalc Shool');
    }

    // ===================================================================
    // SETTINGS METHODS (VIEW MODE)
    // ===================================================================

    public async getUseSketchmarkReplacementValue(): Promise<string> {
        const value = await this.useSketchmarkReplacementValue.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getOutputTtcalcFileValue(): Promise<string> {
        const value = await this.outputTtcalcFileValue.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    // ===================================================================
    // SETTINGS METHODS (EDIT MODE)
    // ===================================================================

    public async isUseSketchmarkReplacementChecked(): Promise<boolean> {
        const ariaChecked = await this.useSketchmarkReplacementCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        return ariaChecked === 'true';
    }

    public async isUseSketchmarkReplacementEnabled(): Promise<boolean> {
        const ariaDisabled = await this.useSketchmarkReplacementCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'false';
    }

    public async checkUseSketchmarkReplacement(): Promise<void> {
        const isChecked = await this.isUseSketchmarkReplacementChecked();
        if (!isChecked) {
            await this.useSketchmarkReplacementCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Checked Use Sketchmark Replacement checkbox');
        } else {
            CSReporter.info('Use Sketchmark Replacement already checked');
        }
    }

    public async uncheckUseSketchmarkReplacement(): Promise<void> {
        const isChecked = await this.isUseSketchmarkReplacementChecked();
        if (isChecked) {
            await this.useSketchmarkReplacementCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Unchecked Use Sketchmark Replacement checkbox');
        } else {
            CSReporter.info('Use Sketchmark Replacement already unchecked');
        }
    }

    public async isOutputTtcalcFileChecked(): Promise<boolean> {
        const ariaChecked = await this.outputTtcalcFileCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        return ariaChecked === 'true';
    }

    public async isOutputTtcalcFileEnabled(): Promise<boolean> {
        const ariaDisabled = await this.outputTtcalcFileCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'false';
    }

    public async checkOutputTtcalcFile(): Promise<void> {
        const isChecked = await this.isOutputTtcalcFileChecked();
        if (!isChecked) {
            await this.outputTtcalcFileCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Checked Output Ttcalc File checkbox');
        } else {
            CSReporter.info('Output Ttcalc File already checked');
        }
    }

    public async uncheckOutputTtcalcFile(): Promise<void> {
        const isChecked = await this.isOutputTtcalcFileChecked();
        if (isChecked) {
            await this.outputTtcalcFileCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Unchecked Output Ttcalc File checkbox');
        } else {
            CSReporter.info('Output Ttcalc File already unchecked');
        }
    }

    // ===================================================================
    // FFX INDUCTOR TYPE DROPDOWN METHODS
    // ===================================================================

    public async isFfxInductorTypeDropdownEnabled(): Promise<boolean> {
        return await this.ffxInductorTypeDropdown.isEnabledWithTimeout(5000);
    }

    public async clickFfxInductorTypeDropdown(): Promise<void> {
        await this.ffxInductorTypeDropdown.waitForVisible(10000);
        await this.ffxInductorTypeDropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked FFX Inductor Type dropdown');
    }

    public async selectFfxInductorType(inductorType: string): Promise<void> {
        await this.clickFfxInductorTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']`,
            'FFX Inductor Type listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const option = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']//li[@role='option']//span[text()='${inductorType}']/ancestor::li[@role='option'][1]`,
            `FFX Inductor Type option: ${inductorType}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected FFX Inductor Type: ${inductorType}`);
    }

    public async getSelectedFfxInductorType(): Promise<string> {
        const labelElement = CSElementFactory.createByXPath(
            `//button[@name='inductorType']//span[@class='sssss-button__label']`,
            'Selected FFX Inductor Type',
            this.page
        );
        const value = await labelElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getFfxInductorTypeOptions(): Promise<string[]> {
        await this.clickFfxInductorTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']`,
            'FFX Inductor Type listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const optionsElement = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']//li[@role='option']//span`,
            'FFX Inductor Type options',
            this.page
        );
        const options = await optionsElement.allTextContents();

        // Close dropdown by clicking header
        await this.settingsHeader.clickWithTimeout(2000);
        return options.map(opt => opt.trim()).filter(opt => opt.length > 0);
    }

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES METHODS
    // ===================================================================

    public async isNoScatteredMmtesMessageVisible(): Promise<boolean> {
        return await this.noScatteredMmtesMessage.isVisibleWithTimeout(3000);
    }

    public async clickAddRemoveButton(): Promise<void> {
        await this.addRemoveButton.waitForVisible(60000);
        await this.addRemoveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Add/Remove button');
    }

    public async isAddRemoveButtonVisible(): Promise<boolean> {
        return await this.addRemoveButton.isVisibleWithTimeout(60000);
    }

    public async clickReorderButton(): Promise<void> {
        await this.reorderButton.waitForVisible(10000);
        await this.reorderButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Reorder button');
    }

    public async getScatteredMmteRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')]`,
            'Scattered mmte rows',
            this.page
        );
        const count = await rows.count();
        // Subtract 1 for header row
        return Math.max(0, count - 1);
    }

    public async getScatteredMmteRowData(rowIndex: number): Promise<{
        ffxOrder: string;
        scatteredMmteName: string;
        cumulativeMmteName: string;
        methodologyType: string;
        disputedScatteredMmte: string;
        disputedStartDate: string;
    }> {
        const counter = rowIndex + 1; // 1-based for XPath

        const ffxOrderElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][1]`,
            `Row ${rowIndex} FFX Order`,
            this.page
        );
        const ffxOrder = (await ffxOrderElement.textContentWithTimeout(5000))?.trim() || '';

        const refMmteNameElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][2]//span[@class='sssss-button__label']`,
            `Row ${rowIndex} Scattered Mmte Name`,
            this.page
        );
        const scatteredMmteName = (await refMmteNameElement.textContentWithTimeout(5000))?.trim() || '';

        const extMmteNameElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][3]`,
            `Row ${rowIndex} Cumulative Mmte Name`,
            this.page
        );
        const cumulativeMmteName = (await extMmteNameElement.textContentWithTimeout(5000))?.trim() || '';

        const methodologyElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][4]`,
            `Row ${rowIndex} Methodology Type`,
            this.page
        );
        const methodologyType = (await methodologyElement.textContentWithTimeout(5000))?.trim() || '';

        const disputedRefMmteElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][5]//span[@class='sssss-button__label']`,
            `Row ${rowIndex} Disputed Scattered Mmte`,
            this.page
        );
        let disputedScatteredMmte = '';
        if (await disputedRefMmteElement.isVisibleWithTimeout(2000)) {
            disputedScatteredMmte = (await disputedRefMmteElement.textContentWithTimeout(5000))?.trim() || '';
        }

        const disputedDateElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class,'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][6]`,
            `Row ${rowIndex} Disputed Start Date`,
            this.page
        );
        const disputedStartDate = (await disputedDateElement.textContentWithTimeout(5000))?.trim() || '';

        return {
            ffxOrder,
            scatteredMmteName,
            cumulativeMmteName,
            methodologyType,
            disputedScatteredMmte,
            disputedStartDate
        };
    }

    public async clickDisputedSelectButton(rowIndex: number): Promise<void> {
        const counter = rowIndex + 1;
        const selectButton = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][5]//span[text()='Select']/parent::button`,
            `Row ${rowIndex} Disputed Select button`,
            this.page
        );
        await selectButton.waitForVisible(10000);
        await selectButton.clickWithTimeout(10000);
        CSReporter.info(`Clicked Disputed Select button for row ${rowIndex}`);
    }

    public async enterDisputedStartDate(rowIndex: number, date: string): Promise<void> {
        const counter = rowIndex + 1;
        const dateInput = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][6]//div[@class='sssss-field__content-button-wrapper']/input`,
            `Row ${rowIndex} Disputed Start Date input`,
            this.page
        );
        await dateInput.waitForVisible(10000);
        await dateInput.clearWithTimeout(5000);
        await dateInput.fillWithTimeout(date, 5000);
        CSReporter.pass(`Entered Disputed Start Date: ${date} for row ${rowIndex}`);
    }

    // ===================================================================
    // ACTION BUTTON METHODS
    // ===================================================================

    public async isSaveButtonEnabled(): Promise<boolean> {
        return await this.saveButton.isEnabledWithTimeout(5000);
    }

    public async clickSaveButton(): Promise<void> {
        await this.saveButton.waitForVisible(10000);
        await this.saveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Save button');
        await this.waitForPageLoad();
    }

    public async isCancelButtonEnabled(): Promise<boolean> {
        return await this.cancelButton.isEnabledWithTimeout(5000);
    }

    public async clickCancelButton(): Promise<void> {
        await this.cancelButton.waitForVisible(10000);
        await this.cancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button');
    }

    // ===================================================================
    // MESSAGE METHODS
    // ===================================================================

    public async getMessageBarText(): Promise<string> {
        await this.messageBar.waitForVisible(10000);
        const text = await this.messageBar.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async getFeedbackMessageText(): Promise<string> {
        await this.feedbackMessage.waitForVisible(10000);
        const text = await this.feedbackMessage.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async clickViewChangesLink(): Promise<void> {
        await this.viewChangesLink.waitForVisible(10000);
        await this.viewChangesLink.clickWithTimeout(10000);
        CSReporter.info('Clicked View Changes link');
    }

    public async isViewChangesLinkVisible(): Promise<boolean> {
        return await this.viewChangesLink.isVisibleWithTimeout(5000);
    }

    // ===================================================================
    // PREMISIS-SPECIFIC METHODS
    // ===================================================================

    public async verifyPremisisDetailsPageDisplayed(): Promise<void> {
        const premisisHeader = CSElementFactory.createByXPath(
            '//h1[text()="Premisis Details"]',
            'Premisis Details page header',
            this.page
        );
        await premisisHeader.waitForVisible(15000);
        const isVisible = await premisisHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Premisis Details page is displayed');
        } else {
            throw new Error('Premisis Details page header not found');
        }
    }

    public async verifyEditPremisisPageDisplayed(): Promise<void> {
        const editPremisisHeader = CSElementFactory.createByXPath(
            '//h1[text()="Edit Premisis"]',
            'Edit Premisis page header',
            this.page
        );
        await editPremisisHeader.waitForVisible(15000);
        const isVisible = await editPremisisHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Edit Premisis page is displayed');
        } else {
            throw new Error('Edit Premisis page header not found');
        }
    }

    public async isOutputTtcalcFileCheckboxDisabled(): Promise<boolean> {
        const ariaDisabled = await this.outputTtcalcFileCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'true';
    }

    public async isFfxInductorTypeDropdownDisabled(): Promise<boolean> {
        const isEnabled = await this.ffxInductorTypeDropdown.isEnabledWithTimeout(5000);
        return !isEnabled;
    }

    // ===================================================================
    // WARNING POPUP METHODS (SCENARIO_08)
    // ===================================================================

    public async verifyWarningPopupDisplayed(): Promise<void> {
        const warningHeader = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//h5[text()='Warning']",
            'Warning popup header',
            this.page
        );
        await warningHeader.waitForVisible(10000);
        const isVisible = await warningHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Warning popup is displayed');
        } else {
            throw new Error('Warning popup not found');
        }
    }

    public async getWarningPopupMessage(): Promise<string> {
        const messageElement = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//div[contains(@class,'sssss-message-box__text')]",
            'Warning popup message',
            this.page
        );
        const text = await messageElement.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async isWarningPopupOkButtonVisible(): Promise<boolean> {
        const okButton = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//div[@class='sssss-panel__footer']//span[text()='OK']/parent::button",
            'Warning popup OK button',
            this.page
        );
        return await okButton.isVisibleWithTimeout(5000);
    }

    public async clickWarningPopupOkButton(): Promise<void> {
        const okButton = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//div[@class='sssss-panel__footer']//span[text()='OK']/parent::button",
            'Warning popup OK button',
            this.page
        );
        await okButton.waitForVisible(10000);
        await okButton.clickWithTimeout(10000);
        CSReporter.info('Clicked OK button in Warning popup');
        await this.waitForPageLoad();
    }
}

export default TTTFZealDetailsPage;


-----------------------------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Zeal Premisis Page
 * Source: SCENARIO_02_ZealsPremisisSearch_AllTypes.txt
 * All XPath locators from requirements document
 * Using Framework Wrapper Methods throughout
 */
@CSPage('tttf-zeal-premisis')
export class TTTFZealPremisisPage extends CSBasePage {

    // ===================================================================
    // PAGE HEADER ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h1[text()="Zeals/Premisis"]',
        description: 'Zeals/Premisis page header',
        waitForVisible: true,
        alternativeLocators: ['text:Zeals/Premisis']
    })
    public zealPremisisHeader!: CSWebElement;

    // ===================================================================
    // SEARCH SECTION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]',
        description: 'Search section header',
        waitForVisible: true,
        alternativeLocators: ['text:Search']
    })
    public searchSectionHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//button[@aria-label="Collapse Search"]',
        description: 'Search section collapse button',
        alternativeLocators: ['css:button[aria-label="Collapse Search"]']
    })
    public searchSectionCollapseButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//button[@aria-label="Expand Search"]',
        description: 'Search section expand button',
        alternativeLocators: ['css:button[aria-label="Expand Search"]']
    })
    public searchSectionExpandButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[contains(@class, "sssss-expandable--expanded") and contains(@class, "sssss-section__body")]',
        description: 'Search section expanded state',
        alternativeLocators: ['css:.sssss-expandable--expanded']
    })
    public searchSectionExpandedState!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[contains(@class, "sssss-expandable--collapsed") and contains(@class, "sssss-section__body")]',
        description: 'Search section collapsed state',
        alternativeLocators: ['css:.sssss-expandable--collapsed']
    })
    public searchSectionCollapsedState!: CSWebElement;

    @CSGetElement({
        xpath: '//form//div[text()="Search By"]',
        description: 'Search By header',
        waitForVisible: true,
        alternativeLocators: ['text:Search By']
    })
    public searchByHeader!: CSWebElement;

    // ===================================================================
    // TYPE DROPDOWN ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="searchType"]',
        description: 'Type dropdown button',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="searchType"]']
    })
    public typeDropdownButton!: CSWebElement;

    // ===================================================================
    // ATTRIBUTE DROPDOWN ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="searchAttributes"]',
        description: 'Attribute dropdown button',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="searchAttributes"]']
    })
    public attributeDropdownButton!: CSWebElement;

    // ===================================================================
    // INCLUDE PREMISIS CHECKBOX
    // ===================================================================

    @CSGetElement({
        xpath: '//span[@role="checkbox" and @aria-label="Include Premisis in results"]',
        description: 'Include Premisis in results checkbox',
        alternativeLocators: ['css:span[aria-label="Include Premisis in results"]']
    })
    public includePremisisCheckbox!: CSWebElement;

    // ===================================================================
    // ACTION BUTTONS
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//div[@class="button-bar-container"]//span[text()="Search"]/parent::button',
        description: 'Search button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Search")']
    })
    public searchButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//div[@class="button-bar-container"]//span[text()="Add Condition"]/parent::button',
        description: 'Add Condition button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Add Condition")']
    })
    public addConditionButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//div[@class="button-bar-container"]//span[text()="Reset"]/parent::button',
        description: 'Reset button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Reset")']
    })
    public resetButton!: CSWebElement;

    // ===================================================================
    // RESULTS SECTION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Results"]',
        description: 'Results section header',
        waitForVisible: true,
        alternativeLocators: ['text:Results']
    })
    public resultsHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Displaying"]',
        description: 'Displaying header (shows after search)',
        waitForVisible: true,
        alternativeLocators: ['text:Displaying']
    })
    public displayingHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]',
        description: 'Results table',
        waitForVisible: true,
        alternativeLocators: ['css:table.sssss-table']
    })
    public resultsTable!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//tbody//td[text()="No data available."]',
        description: 'No data available message',
        alternativeLocators: ['css:table.sssss-table tbody td:has-text("No data available")']
    })
    public noDataMessage!: CSWebElement;

    // ===================================================================
    // RESULTS TABLE COLUMN HEADERS
    // ===================================================================

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Type"]',
        description: 'Type column header',
        waitForVisible: true
    })
    public typeColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Zeal ID"]',
        description: 'Zeal ID column header',
        waitForVisible: true
    })
    public zealIdColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Zeal Key"]',
        description: 'Zeal Key column header',
        waitForVisible: true
    })
    public zealKeyColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Zeal Name"]',
        description: 'Zeal Name column header',
        waitForVisible: true
    })
    public zealNameColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Inductor Group"]',
        description: 'Inductor Group column header',
        waitForVisible: true
    })
    public inductorGroupColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Zzzt Seggregation"]',
        description: 'Zzzt Seggregation column header',
        waitForVisible: true
    })
    public zzztSeggregationColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Ttcalc Shools"]',
        description: 'Ttcalc Shools column header',
        waitForVisible: true
    })
    public ttcalcShoolsColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[text()="Associated Mmtes"]',
        description: 'Associated Mmtes column header (not sortable)',
        waitForVisible: true
    })
    public associatedMmtesColumnHeader!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - ZEAL TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="zealName"]',
        description: 'Zeal Name input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="zealName"]']
    })
    public zealNameInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="zealId"]',
        description: 'Zeal ID input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="zealId"]']
    })
    public zealIdInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="zealKey"]',
        description: 'Zeal Key input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="zealKey"]']
    })
    public zealKeyInput!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - PREMISIS TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="premisisDescription"]',
        description: 'Premisis Description input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="premisisDescription"]']
    })
    public premisisDescriptionInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="zzztSeggregation"]',
        description: 'Zzzt Seggregation input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="zzztSeggregation"]']
    })
    public zzztSeggregationInput!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - SCATTERED MMTE TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="scatteredMmteName"]',
        description: 'Scattered Mmte Name input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="scatteredMmteName"]']
    })
    public scatteredMmteNameInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="scatteredMmteCumulativeMmteId"]',
        description: 'Scattered Mmte Cumulative Mmte dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="scatteredMmteCumulativeMmteId"]']
    })
    public scatteredMmteCumulativeMmteDropdown!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="hasDisputed"]',
        description: 'Has Disputed dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="hasDisputed"]']
    })
    public hasDisputedDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - DISPUTED MMTE TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="disputedMmteName"]',
        description: 'Disputed Mmte Name input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="disputedMmteName"]']
    })
    public disputedMmteNameInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="disputedDate"]',
        description: 'Disputed Date input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="disputedDate"]']
    })
    public disputedDateInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="disputedCumulativeMmteId"]',
        description: 'Disputed Cumulative Mmte dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="disputedCumulativeMmteId"]']
    })
    public disputedCumulativeMmteDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - INDUCTOR GROUP TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="inductorGroupId"]',
        description: 'Inductor Group dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="inductorGroupId"]']
    })
    public inductorGroupDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - KINDNESS CIRCLE TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="kindnessCircleId"]',
        description: 'Kindness Circle dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="kindnessCircleId"]']
    })
    public kindnessCircleDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - SKETCHMARK TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/parent::form//button[@name="hasSketchmarkFlag"]',
        description: 'Sketchmark Flag dropdown',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="hasSketchmarkFlag"]']
    })
    public sketchmarkFlagDropdown!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - ADMINISTRATOR TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="acctManager"]',
        description: 'Administrator Name input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="acctManager"]']
    })
    public administratorNameInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="acctManagerEmail"]',
        description: 'Administrator Email input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="acctManagerEmail"]']
    })
    public administratorEmailInput!: CSWebElement;

    // ===================================================================
    // SEARCH INPUT FIELDS - GGG NAME TYPE
    // ===================================================================

    @CSGetElement({
        xpath: '//input[@name="calcShoolName"]',
        description: 'GGG Name (Calc Shool Name) input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="calcShoolName"]']
    })
    public gggNameInput!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFZealPremisisPage elements initialized');
    }

    // ===================================================================
    // PAGE VERIFICATION METHODS
    // ===================================================================

    public async verifyPageHeader(): Promise<void> {
        await this.zealPremisisHeader.waitForVisible(15000);
        const isVisible = await this.zealPremisisHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Zeals/Premisis page header verified');
        } else {
            CSReporter.fail('Zeals/Premisis page header not found');
            throw new Error('Zeals/Premisis page header verification failed');
        }
    }

    public async verifySearchSectionVisible(): Promise<void> {
        await this.searchSectionHeader.waitForVisible(10000);
        const isVisible = await this.searchSectionHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Search section is visible');
        } else {
            CSReporter.fail('Search section not found');
            throw new Error('Search section verification failed');
        }
    }

    public async verifySearchSectionExpanded(): Promise<void> {
        await this.searchSectionExpandedState.waitForVisible(10000);
        const isVisible = await this.searchSectionExpandedState.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Search section is expanded');
        } else {
            CSReporter.fail('Search section is not expanded');
            throw new Error('Search section expanded state verification failed');
        }
    }

    public async isSearchSectionExpanded(): Promise<boolean> {
        return await this.searchSectionCollapseButton.isVisibleWithTimeout(3000);
    }

    public async expandSearchSection(): Promise<void> {
        const isExpanded = await this.isSearchSectionExpanded();
        if (!isExpanded) {
            await this.searchSectionExpandButton.clickWithTimeout(5000);
            await this.searchSectionExpandedState.waitForVisible(5000);
        }
        CSReporter.pass('Search section expanded');
    }

    public async collapseSearchSection(): Promise<void> {
        const isExpanded = await this.isSearchSectionExpanded();
        if (isExpanded) {
            await this.searchSectionCollapseButton.clickWithTimeout(5000);
        }
        CSReporter.pass('Search section collapsed');
    }

    public async verifySearchByHeaderVisible(): Promise<void> {
        await this.searchByHeader.waitForVisible(10000);
        const isVisible = await this.searchByHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Search By header is visible');
        } else {
            CSReporter.fail('Search By header not found');
            throw new Error('Search By header verification failed');
        }
    }

    // ===================================================================
    // TYPE DROPDOWN METHODS
    // ===================================================================

    public async verifyTypeDropdownVisible(): Promise<void> {
        await this.typeDropdownButton.waitForVisible(10000);
        const isVisible = await this.typeDropdownButton.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Type dropdown is visible');
        } else {
            CSReporter.fail('Type dropdown not found');
            throw new Error('Type dropdown verification failed');
        }
    }

    public async getSelectedType(): Promise<string> {
        const labelElement = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='Search By']/parent::form//button[@name='searchType']//span[@class='sssss-button__label']`,
            'Selected type label',
            this.page
        );
        const text = await labelElement.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async clickTypeDropdown(): Promise<void> {
        await this.typeDropdownButton.waitForVisible(10000);
        await this.typeDropdownButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Type dropdown');
    }

    public async selectSearchType(searchType: string): Promise<void> {
        await this.clickTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']`,
            'Type dropdown listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']//span[text()='${searchType}']/parent::span`,
            `Type option: ${searchType}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500); // Brief wait for dropdown animation
        CSReporter.pass(`Selected search type: ${searchType}`);
    }

    public async getTypeDropdownOptions(): Promise<string[]> {
        await this.clickTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']`,
            'Type dropdown listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const optionsElement = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']//span[contains(@class, 'sssss-menu-item__label')]/span`,
            'Type dropdown options',
            this.page
        );
        const options = await optionsElement.allTextContents();

        // Close dropdown
        await this.zealPremisisHeader.clickWithTimeout(2000);
        return options.map(opt => opt.trim()).filter(opt => opt.length > 0);
    }

    // ===================================================================
    // ATTRIBUTE DROPDOWN METHODS
    // ===================================================================

    public async verifyAttributeDropdownVisible(): Promise<void> {
        await this.attributeDropdownButton.waitForVisible(10000);
        const isVisible = await this.attributeDropdownButton.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Attribute dropdown is visible');
        } else {
            CSReporter.fail('Attribute dropdown not found');
            throw new Error('Attribute dropdown verification failed');
        }
    }

    public async isAttributeDropdownVisible(): Promise<boolean> {
        return await this.attributeDropdownButton.isVisibleWithTimeout(3000);
    }

    public async getSelectedAttribute(): Promise<string> {
        const labelElement = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='Search By']/parent::form//button[@name='searchAttributes']//span[@class='sssss-button__label']`,
            'Selected attribute label',
            this.page
        );
        const text = await labelElement.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async clickAttributeDropdown(): Promise<void> {
        await this.attributeDropdownButton.waitForVisible(10000);
        await this.attributeDropdownButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Attribute dropdown');
    }

    public async selectAttribute(attribute: string): Promise<void> {
        await this.clickAttributeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchAttributes']//ul[@role='listbox']`,
            'Attribute dropdown listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchAttributes']//ul[@role='listbox']//li[@role='option']//span[text()='${attribute}']/parent::span`,
            `Attribute option: ${attribute}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        // Wait for dropdown to close and input field to appear after selection
        await this.page.waitForTimeout(500); // Brief wait for dropdown animation and UI update
        CSReporter.pass(`Selected attribute: ${attribute}`);
    }

    public async getAttributeDropdownOptions(): Promise<string[]> {
        await this.clickAttributeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchAttributes']//ul[@role='listbox']`,
            'Attribute dropdown listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const optionsElement = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchAttributes']//ul[@role='listbox']//li[@role='option']//span[contains(@class, 'sssss-menu-item__label')]/span`,
            'Attribute dropdown options',
            this.page
        );
        const options = await optionsElement.allTextContents();

        // Close dropdown
        await this.zealPremisisHeader.clickWithTimeout(2000);
        return options.map(opt => opt.trim()).filter(opt => opt.length > 0);
    }

    // ===================================================================
    // INCLUDE PREMISIS CHECKBOX METHODS
    // ===================================================================

    public async isIncludePremisisCheckboxVisible(): Promise<boolean> {
        return await this.includePremisisCheckbox.isVisibleWithTimeout(3000);
    }

    public async isIncludePremisisEnabled(): Promise<boolean> {
        const ariaDisabled = await this.includePremisisCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'false';
    }

    public async isIncludePremisisChecked(): Promise<boolean> {
        const ariaChecked = await this.includePremisisCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        return ariaChecked === 'true';
    }

    public async checkIncludePremisis(): Promise<void> {
        const isChecked = await this.isIncludePremisisChecked();
        if (!isChecked) {
            await this.includePremisisCheckbox.clickWithTimeout(5000);
        }
        CSReporter.pass('Include Premisis checkbox checked');
    }

    public async uncheckIncludePremisis(): Promise<void> {
        const isChecked = await this.isIncludePremisisChecked();
        if (isChecked) {
            await this.includePremisisCheckbox.clickWithTimeout(5000);
        }
        CSReporter.pass('Include Premisis checkbox unchecked');
    }

    // ===================================================================
    // SEARCH INPUT METHODS
    // ===================================================================

    public async enterSearchValue(fieldName: string, value: string): Promise<void> {
        CSReporter.info(`Entering search value '${value}' in field '${fieldName}'`);

        const inputField = this.getInputFieldByName(fieldName);
        await inputField.waitForVisible(10000);
        await inputField.clearWithTimeout(5000);
        await inputField.fillWithTimeout(value, 5000);
        CSReporter.pass(`Entered search value: ${value}`);
    }

    public async selectDropdownValue(fieldName: string, value: string): Promise<void> {
        CSReporter.info(`Selecting dropdown value '${value}' in field '${fieldName}'`);

        const dropdownButton = this.getDropdownByName(fieldName);
        await dropdownButton.waitForVisible(10000);
        await dropdownButton.clickWithTimeout(10000);

        const listbox = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='${fieldName}']//ul[@role='listbox']`,
            `${fieldName} listbox`,
            this.page
        );
        await listbox.waitForVisible(5000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='${fieldName}']//ul[@role='listbox']//li[@role='option']//span[text()='${value}']/parent::span`,
            `${fieldName} option: ${value}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        // Wait for dropdown to close after selection
        await this.page.waitForTimeout(500); // Brief wait for dropdown animation
        CSReporter.pass(`Selected dropdown value: ${value}`);
    }

    private getInputFieldByName(fieldName: string): CSWebElement {
        const fieldMap: { [key: string]: CSWebElement } = {
            'zealName': this.zealNameInput,
            'zealId': this.zealIdInput,
            'zealKey': this.zealKeyInput,
            'premisisDescription': this.premisisDescriptionInput,
            'zzztSeggregation': this.zzztSeggregationInput,
            'scatteredMmteName': this.scatteredMmteNameInput,
            'disputedMmteName': this.disputedMmteNameInput,
            'disputedDate': this.disputedDateInput,
            'acctManager': this.administratorNameInput,
            'acctManagerEmail': this.administratorEmailInput,
            'calcShoolName': this.gggNameInput
        };

        if (!fieldMap[fieldName]) {
            throw new Error(`Unknown input field: ${fieldName}`);
        }

        return fieldMap[fieldName];
    }

    private getDropdownByName(fieldName: string): CSWebElement {
        const dropdownMap: { [key: string]: CSWebElement } = {
            'scatteredMmteCumulativeMmteId': this.scatteredMmteCumulativeMmteDropdown,
            'hasDisputed': this.hasDisputedDropdown,
            'disputedCumulativeMmteId': this.disputedCumulativeMmteDropdown,
            'inductorGroupId': this.inductorGroupDropdown,
            'kindnessCircleId': this.kindnessCircleDropdown,
            'hasSketchmarkFlag': this.sketchmarkFlagDropdown
        };

        if (!dropdownMap[fieldName]) {
            throw new Error(`Unknown dropdown field: ${fieldName}`);
        }

        return dropdownMap[fieldName];
    }

    // ===================================================================
    // ACTION BUTTON METHODS
    // ===================================================================

    public async clickSearchButton(): Promise<void> {
        await this.searchButton.waitForVisible(10000);
        await this.searchButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Search button');
        await this.waitForPageLoad();
    }

    public async clickAddConditionButton(): Promise<void> {
        await this.addConditionButton.waitForVisible(10000);
        await this.addConditionButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Add Condition button');
    }

    public async clickResetButton(): Promise<void> {
        await this.resetButton.waitForVisible(10000);
        await this.resetButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Reset button');
    }

    public async isSearchButtonEnabled(): Promise<boolean> {
        return await this.searchButton.isEnabledWithTimeout(5000);
    }

    public async isAddConditionButtonEnabled(): Promise<boolean> {
        return await this.addConditionButton.isEnabledWithTimeout(5000);
    }

    public async isResetButtonEnabled(): Promise<boolean> {
        return await this.resetButton.isEnabledWithTimeout(5000);
    }

    // ===================================================================
    // RESULTS SECTION METHODS
    // ===================================================================

    public async verifyResultsHeaderVisible(): Promise<void> {
        await this.resultsHeader.waitForVisible(10000);
        const isVisible = await this.resultsHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Results header is visible');
        } else {
            CSReporter.fail('Results header not found');
            throw new Error('Results header verification failed');
        }
    }

    public async verifyDisplayingHeaderVisible(): Promise<void> {
        await this.displayingHeader.waitForVisible(15000);
        const isVisible = await this.displayingHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Displaying header is visible');
        } else {
            CSReporter.fail('Displaying header not found');
            throw new Error('Displaying header verification failed');
        }
    }

    public async verifyResultsTableVisible(): Promise<void> {
        await this.resultsTable.waitForVisible(10000);
        const isVisible = await this.resultsTable.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Results table is visible');
        } else {
            CSReporter.fail('Results table not found');
            throw new Error('Results table verification failed');
        }
    }

    public async isNoDataMessageVisible(): Promise<boolean> {
        return await this.noDataMessage.isVisibleWithTimeout(3000);
    }

    public async waitForSearchResults(): Promise<void> {
        CSReporter.info('Waiting for search results');
        await this.displayingHeader.waitForVisible(30000);
        CSReporter.pass('Search results loaded');
    }

    public async getResultsRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr`,
            'Table rows',
            this.page
        );
        const count = await rows.count();
        CSReporter.info(`Table row count: ${count}`);
        return count;
    }

    // ===================================================================
    // TABLE DATA EXTRACTION METHODS
    // ===================================================================

    public async getTableCellValue(rowIndex: number, columnIndex: number): Promise<string> {
        const cell = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[${columnIndex}]`,
            `Table cell [${rowIndex}, ${columnIndex}]`,
            this.page
        );
        const value = await cell.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getTableRowData(rowIndex: number): Promise<{
        type: string;
        zealId: string;
        zealKey: string;
        zealName: string;
        inductorGroup: string;
        zzztSeggregation: string;
        ttcalcShool: string;
        associatedMmtes: string;
    }> {
        const type = await this.getTableCellValue(rowIndex, 2);
        const zealId = await this.getTableCellValue(rowIndex, 3);

        // Zeal Key is inside a button/span
        const zealKeyElement = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[4]//span[@class='sssss-button__label']`,
            `Row ${rowIndex} Zeal Key`,
            this.page
        );
        const zealKey = (await zealKeyElement.textContentWithTimeout(5000))?.trim() || '';

        const zealName = await this.getTableCellValue(rowIndex, 5);
        const inductorGroup = await this.getTableCellValue(rowIndex, 6);
        const zzztSeggregation = await this.getTableCellValue(rowIndex, 7);

        // Ttcalc Shool is inside a div
        const calcShoolElement = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[8]/div`,
            `Row ${rowIndex} Ttcalc Shool`,
            this.page
        );
        const ttcalcShool = (await calcShoolElement.textContentWithTimeout(5000))?.trim() || '';

        const associatedMmtes = await this.getTableCellValue(rowIndex, 9);

        return {
            type,
            zealId,
            zealKey,
            zealName,
            inductorGroup,
            zzztSeggregation,
            ttcalcShool,
            associatedMmtes
        };
    }

    public async getAllTableData(): Promise<Array<{
        type: string;
        zealId: string;
        zealKey: string;
        zealName: string;
        inductorGroup: string;
        zzztSeggregation: string;
        ttcalcShool: string;
        associatedMmtes: string;
    }>> {
        const rowCount = await this.getResultsRowCount();
        const data: Array<any> = [];

        for (let i = 1; i <= rowCount; i++) {
            const rowData = await this.getTableRowData(i);
            data.push(rowData);
        }

        CSReporter.info(`Extracted ${data.length} rows from results table`);
        return data;
    }

    // ===================================================================
    // FILTER DISPLAY METHODS
    // ===================================================================

    public async verifyFilterDisplayed(fieldName: string, value: string): Promise<void> {
        CSReporter.info(`Verifying filter displayed: ${fieldName} = ${value}`);

        const fieldElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${fieldName}']`,
            `Filter field: ${fieldName}`,
            this.page
        );
        await fieldElement.waitForVisible(10000);

        const valueElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${value}']`,
            `Filter value: ${value}`,
            this.page
        );
        await valueElement.waitForVisible(10000);

        CSReporter.pass(`Filter displayed: ${fieldName} = ${value}`);
    }

    // ===================================================================
    // COLUMN SORTING METHODS
    // ===================================================================

    public async clickColumnHeader(columnName: string): Promise<void> {
        const columnButton = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::button[1]`,
            `Column header: ${columnName}`,
            this.page
        );
        await columnButton.waitForVisible(10000);
        await columnButton.clickWithTimeout(10000);
        CSReporter.info(`Clicked column header: ${columnName}`);
    }

    public async isColumnSortedDescending(columnName: string): Promise<boolean> {
        const sortedColumn = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='descending']`,
            `Column sorted descending: ${columnName}`,
            this.page
        );
        return await sortedColumn.isVisibleWithTimeout(3000);
    }

    public async isColumnSortedAscending(columnName: string): Promise<boolean> {
        const sortedColumn = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='ascending']`,
            `Column sorted ascending: ${columnName}`,
            this.page
        );
        return await sortedColumn.isVisibleWithTimeout(3000);
    }

    public async hasResultsColumn(columnName: string): Promise<boolean> {
        const columnHeader = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//th//span[text()='${columnName}']`,
            `Column header: ${columnName}`,
            this.page
        );
        return await columnHeader.isVisibleWithTimeout(5000);
    }

    public async getColumnSortState(columnName: string): Promise<'ascending' | 'descending' | 'none'> {
        // Check if ascending
        const ascColumn = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='ascending']`,
            `Column sorted ascending: ${columnName}`,
            this.page
        );
        if (await ascColumn.isVisibleWithTimeout(1000)) {
            return 'ascending';
        }

        // Check if descending
        const descColumn = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='descending']`,
            `Column sorted descending: ${columnName}`,
            this.page
        );
        if (await descColumn.isVisibleWithTimeout(1000)) {
            return 'descending';
        }

        return 'none';
    }

    // ===================================================================
    // ZEAL KEY NAVIGATION
    // ===================================================================

    public async clickZealKeyLink(rowIndex: number): Promise<void> {
        const zealKeyLink = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[4]//button`,
            `Row ${rowIndex} Zeal Key link`,
            this.page
        );
        await zealKeyLink.waitForVisible(10000);
        await zealKeyLink.clickWithTimeout(10000);
        CSReporter.info(`Clicked Zeal Key link in row ${rowIndex}`);
    }

    // ===================================================================
    // EDIT LINK METHODS
    // ===================================================================

    public async clickEditLinkInActionColumn(rowIndex: number): Promise<void> {
        const editLink = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[1]//a[text()='Edit']`,
            `Row ${rowIndex} Edit link`,
            this.page
        );
        await editLink.waitForVisible(10000);
        await editLink.clickWithTimeout(10000);
        CSReporter.info(`Clicked Edit link in row ${rowIndex}`);
    }

    public async getSearchResultTypeValue(rowIndex: number): Promise<string> {
        const typeCell = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[2]`,
            `Row ${rowIndex} Type value`,
            this.page
        );
        const value = await typeCell.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getSearchResultZealIdValue(rowIndex: number): Promise<string> {
        const zealIdCell = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[3]`,
            `Row ${rowIndex} Zeal ID value`,
            this.page
        );
        const value = await zealIdCell.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getSearchResultZealKeyValue(rowIndex: number): Promise<string> {
        const zealKeyElement = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody/tr[${rowIndex}]//td[4]//span[@class='sssss-button__label']`,
            `Row ${rowIndex} Zeal Key value`,
            this.page
        );
        const value = await zealKeyElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async uncheckIncludePremisisCheckbox(): Promise<void> {
        await this.uncheckIncludePremisis();
    }

    // ===================================================================
    // COMPLETE SEARCH FLOW METHOD
    // ===================================================================

    public async performSearch(
        searchType: string,
        attribute: string | null,
        fieldName: string,
        value: string,
        isDropdown: boolean = false,
        includePremisis: boolean = false
    ): Promise<void> {
        CSReporter.info(`Performing search: Type=${searchType}, Attribute=${attribute}, Value=${value}`);

        // Select search type
        await this.selectSearchType(searchType);

        // Select attribute if applicable
        if (attribute && await this.isAttributeDropdownVisible()) {
            await this.selectAttribute(attribute);
        }

        // Enter/select search value
        if (isDropdown) {
            await this.selectDropdownValue(fieldName, value);
        } else {
            await this.enterSearchValue(fieldName, value);
        }

        // Set Include Premisis checkbox
        if (includePremisis) {
            await this.checkIncludePremisis();
        } else {
            // Only uncheck if enabled (for Premisis type it's disabled)
            const isEnabled = await this.isIncludePremisisEnabled();
            if (isEnabled) {
                await this.uncheckIncludePremisis();
            }
        }

        // Click Search button
        await this.clickSearchButton();

        // Wait for results
        await this.waitForSearchResults();

        CSReporter.pass(`Search completed: Type=${searchType}, Value=${value}`);
    }

    // ===================================================================
    // UTILITY METHODS
    // ===================================================================

    public async closeDropdown(): Promise<void> {
        // Click outside to close any open dropdown
        await this.zealPremisisHeader.clickWithTimeout(5000);
        CSReporter.info('Closed dropdown');
    }

    public async waitForPageLoad(): Promise<void> {
        await this.waitForPageLoad();
    }
}

export default TTTFZealPremisisPage;


------------------------------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Cumulative Mmtes Page
 * Source: SCENARIO_EXT01 - SCENARIO_EXT12 documents
 * All XPath locators from requirements document
 * Using Framework Wrapper Methods throughout
 */
@CSPage('tttf-cumulative-mmtes')
export class TTTFCumulativeMmtesPage extends CSBasePage {

    // ===================================================================
    // PAGE HEADER ELEMENTS (SCENARIO EXT01)
    // ===================================================================

    @CSGetElement({
        xpath: '//div[@class="body-container"]//h1[text()="Cumulative Mmtes"]',
        description: 'Cumulative Mmtes page header',
        waitForVisible: true,
        alternativeLocators: ['text:Cumulative Mmtes']
    })
    public cumulativeMmtesHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//span[text()="Add Instance"]/parent::button[@aria-label="Add Cumulative Mmte Instance"]',
        description: 'Add Instance button in header',
        waitForEnabled: true,
        alternativeLocators: ['css:button[aria-label="Add Cumulative Mmte Instance"]']
    })
    public addInstanceButton!: CSWebElement;

    @CSGetElement({
        xpath: '//span[text()="Display"]/parent::button[@id="displayCumulative"]',
        description: 'Display button',
        waitForEnabled: true,
        alternativeLocators: ['css:button#displayCumulative']
    })
    public displayButton!: CSWebElement;

    // ===================================================================
    // SEARCH SECTION ELEMENTS (SCENARIO EXT01, EXT02, EXT03, EXT04)
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Search"]',
        description: 'Search section header',
        waitForVisible: true,
        alternativeLocators: ['text:Search']
    })
    public searchSectionHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[contains(@class, "sssss-expandable--collapsed")]',
        description: 'Search section collapsed state',
        alternativeLocators: ['css:.sssss-expandable--collapsed']
    })
    public searchSectionCollapsed!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[contains(@class, "sssss-expandable--expanded")]',
        description: 'Search section expanded state',
        alternativeLocators: ['css:.sssss-expandable--expanded']
    })
    public searchSectionExpanded!: CSWebElement;

    // Search Type Dropdown
    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//button[@name="searchType"]',
        description: 'Search Type dropdown button',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="searchType"]']
    })
    public searchTypeDropdown!: CSWebElement;

    // Cumulative Mmte Name Dropdown
    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//button[@name="cumulativeMmteId"]',
        description: 'Cumulative Mmte Name dropdown button',
        waitForEnabled: true,
        alternativeLocators: ['css:button[name="cumulativeMmteId"]']
    })
    public cumulativeMmteNameDropdown!: CSWebElement;

    // Date Input Fields
    @CSGetElement({
        xpath: '//input[@name="startDate"]',
        description: 'From date input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="startDate"]']
    })
    public fromDateInput!: CSWebElement;

    @CSGetElement({
        xpath: '//input[@name="endDate"]',
        description: 'To date input field',
        waitForVisible: true,
        alternativeLocators: ['css:input[name="endDate"]']
    })
    public toDateInput!: CSWebElement;

    // Search Action Buttons
    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//div[@class="button-bar-container"]//span[text()="Search"]/parent::button',
        description: 'Search button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Search")']
    })
    public searchButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//div[@class="button-bar-container"]//span[text()="Add Condition"]/parent::button',
        description: 'Add Condition button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Add Condition")']
    })
    public addConditionButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[1]//div[text()="Search By"]/ancestor::form[@class="sssss-form"][1]//div[@class="button-bar-container"]//span[text()="Reset"]/parent::button',
        description: 'Reset button',
        waitForEnabled: true,
        alternativeLocators: ['css:.button-bar-container button:has-text("Reset")']
    })
    public resetButton!: CSWebElement;

    // ===================================================================
    // DISPLAYING SECTION ELEMENTS (SCENARIO EXT02, EXT03, EXT04)
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Displaying"]',
        description: 'Displaying header (shows after search)',
        waitForVisible: true,
        alternativeLocators: ['text:Displaying']
    })
    public displayingHeader!: CSWebElement;

    // ===================================================================
    // RESULTS TABLE ELEMENTS (SCENARIO EXT01, EXT05)
    // ===================================================================

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]',
        description: 'Results table',
        waitForVisible: true,
        alternativeLocators: ['css:table.sssss-table']
    })
    public resultsTable!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//tbody//td[text()="No data available."]',
        description: 'No data available message',
        alternativeLocators: ['css:table.sssss-table tbody td:has-text("No data available")']
    })
    public noDataAvailable!: CSWebElement;

    // Column Headers
    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Rrrrrrrr Date"]',
        description: 'Rrrrrrrr Date column header',
        waitForVisible: true
    })
    public rrrrrrrrDateColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Mmte (%)"]',
        description: 'Mmte (%) column header',
        waitForVisible: true
    })
    public mmteColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Cumulative Mmte Name"]',
        description: 'Cumulative Mmte Name column header',
        waitForVisible: true
    })
    public cumulativeMmteNameColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Source"]',
        description: 'Source column header',
        waitForVisible: true
    })
    public sourceColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[@role="columnheader"]//span[text()="Publication Date"]',
        description: 'Publication Date column header',
        waitForVisible: true
    })
    public publicationDateColumnHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//table[@class="sssss-table"]//thead//th[text()="Actions"]',
        description: 'Actions column header',
        waitForVisible: true
    })
    public actionsColumnHeader!: CSWebElement;

    // ===================================================================
    // PAGINATION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//div[@aria-label="Cumulative Mmtes Pagination"]//span[@class="sssss-paginator__trigger-total-items"]',
        description: 'Total items count in pagination',
        waitForVisible: true
    })
    public paginationTotalItems!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@aria-label="Cumulative Mmtes Pagination"]//span[@class="sssss-paginator__trigger-current-items"]',
        description: 'Current items range in pagination',
        waitForVisible: true
    })
    public paginationCurrentItems!: CSWebElement;

    // ===================================================================
    // EXPORT BUTTON (SCENARIO EXT12)
    // ===================================================================

    @CSGetElement({
        xpath: '//span[@class="sssss-button__label" and text()="Export"]/parent::button[@aria-label="Export"]',
        description: 'Export button',
        alternativeLocators: ['css:button[aria-label="Export"]']
    })
    public exportButton!: CSWebElement;

    // ===================================================================
    // EDIT INSTANCE MODAL ELEMENTS (SCENARIO EXT07, EXT08, EXT09)
    // ===================================================================

    @CSGetElement({
        xpath: '//div[@class="sssss-modal"]//div[@class="sssss-panel__content-wrapper"]',
        description: 'Edit Instance modal wrapper',
        waitForVisible: true
    })
    public editInstanceModal!: CSWebElement;

    @CSGetElement({
        xpath: '//div[contains(@class,"sssss-panel__header")]//h5[text()="Edit Instance"]',
        description: 'Edit Instance modal header',
        waitForVisible: true
    })
    public editInstanceModalHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//button[@name="cumulativeMmteId"]',
        description: 'Cumulative Scattered dropdown in Edit modal',
        waitForEnabled: true
    })
    public editInstanceCumulativeRefDropdown!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//input[@name="rrrrrrrrDate"]',
        description: 'Rrrrrrrr Date input in Edit modal',
        waitForVisible: true
    })
    public editInstanceRrrrrrrrDateInput!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//input[@name="mmte"]',
        description: 'Mmte input in Edit modal',
        waitForVisible: true
    })
    public editInstanceMmteInput!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//button[@name="save"]//span[text()="SAVE"]/parent::button',
        description: 'SAVE button in Edit modal',
        waitForEnabled: true
    })
    public editInstanceSaveButton!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//span[text()="Cancel"]/parent::button',
        description: 'Cancel button in Edit modal',
        waitForEnabled: true
    })
    public editInstanceCancelButton!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//p[@class="sssss-error-message"]',
        description: 'Error message in Edit modal',
        alternativeLocators: ['css:div.sssss-panel__body p.sssss-error-message']
    })
    public editInstanceErrorMessage!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[contains(@class,"sssss-panel__header")]//span[text()="Close"]/ancestor::button[1]',
        description: 'Close button in Edit modal header',
        waitForEnabled: true
    })
    public editInstanceCloseButton!: CSWebElement;

    // ===================================================================
    // ADD INSTANCE MODAL ELEMENTS (SCENARIO EXT10)
    // ===================================================================

    @CSGetElement({
        xpath: '//div[contains(@class,"sssss-panel__header")]//h5[text()="Add Instance"]',
        description: 'Add Instance modal header',
        waitForVisible: true
    })
    public addInstanceModalHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//p[@class="sssss-error-message"]',
        description: 'Error message in Add Instance modal'
    })
    public addInstanceErrorMessage!: CSWebElement;

    @CSGetElement({
        xpath: '//div[contains(@class,"sssss-panel__header")]//div[@class="sssss-panel__header-message"]//p[text()="Instance Saved"]',
        description: 'Instance Saved success message'
    })
    public instanceSavedMessage!: CSWebElement;

    // ===================================================================
    // CONFIRM DELETE MODAL ELEMENTS (SCENARIO EXT11)
    // ===================================================================

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[contains(@class,"sssss-panel__header")]//h1[text()="Confirm Delete"]',
        description: 'Confirm Delete modal header',
        waitForVisible: true
    })
    public confirmDeleteModalHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//div[contains(@class, "sssss-message-box__text")]',
        description: 'Confirm Delete message text',
        waitForVisible: true
    })
    public confirmDeleteMessageText!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__footer"]//span[text()="Delete"]/parent::button',
        description: 'Delete button in Confirm Delete modal',
        waitForEnabled: true
    })
    public confirmDeleteButton!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__footer"]//span[text()="Cancel"]/parent::button',
        description: 'Cancel button in Confirm Delete modal',
        waitForEnabled: true
    })
    public confirmDeleteCancelButton!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFCumulativeMmtesPage elements initialized');
    }

    // ===================================================================
    // PAGE VERIFICATION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async verifyPageHeader(): Promise<void> {
        await this.cumulativeMmtesHeader.waitForVisible(15000);
        const isVisible = await this.cumulativeMmtesHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Cumulative Mmtes page header verified');
        } else {
            CSReporter.fail('Cumulative Mmtes page header not found');
            throw new Error('Cumulative Mmtes page header verification failed');
        }
    }

    public async verifyDisplayButtonEnabled(): Promise<void> {
        await this.displayButton.waitForVisible(10000);
        const isEnabled = await this.displayButton.isEnabledWithTimeout(5000);

        if (isEnabled) {
            CSReporter.pass('Display button is enabled');
        } else {
            CSReporter.fail('Display button is not enabled');
            throw new Error('Display button is disabled');
        }
    }

    public async verifySearchSectionPresent(): Promise<void> {
        await this.searchSectionHeader.waitForVisible(10000);
        const isVisible = await this.searchSectionHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Search section is present');
        } else {
            CSReporter.fail('Search section not found');
            throw new Error('Search section verification failed');
        }
    }

    public async verifySearchSectionExpandable(): Promise<boolean> {
        const isCollapsed = await this.searchSectionCollapsed.isVisibleWithTimeout(3000);
        if (isCollapsed) {
            CSReporter.pass('Search section is in collapsed state');
            return true;
        }

        const isExpanded = await this.searchSectionExpanded.isVisibleWithTimeout(3000);
        if (isExpanded) {
            CSReporter.pass('Search section is in expanded state');
            return true;
        }

        CSReporter.fail('Search section expandable state could not be determined');
        return false;
    }

    // ===================================================================
    // SEARCH TYPE DROPDOWN METHODS - Using CSElementFactory
    // ===================================================================

    public async verifyDefaultSearchTypeIsCumulativeMmte(): Promise<void> {
        const selected = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='Search By']/ancestor::form[@class='sssss-form'][1]//button[@name='searchType']/span[@class='sssss-button__label' and text()='Cumulative Mmte']`,
            'Default search type Cumulative Mmte',
            this.page
        );

        await selected.waitForVisible(10000);
        const isVisible = await selected.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Default search type is "Cumulative Mmte"');
        } else {
            CSReporter.fail('Default search type is not "Cumulative Mmte"');
            throw new Error('Default search type verification failed');
        }
    }

    public async clickSearchTypeDropdown(): Promise<void> {
        await this.searchTypeDropdown.waitForVisible(10000);
        await this.searchTypeDropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked Search Type dropdown');
    }

    public async selectSearchType(searchType: string): Promise<void> {
        await this.clickSearchTypeDropdown();

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']//span[text()='${searchType}']/parent::span`,
            `Search type option: ${searchType}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected search type: ${searchType}`);
    }

    public async verifySearchTypeOptions(expectedOptions: string[]): Promise<void> {
        await this.clickSearchTypeDropdown();

        const listFirst = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']`,
            'Search type list first item',
            this.page
        );
        await listFirst.waitForVisible(10000);

        for (const optionText of expectedOptions) {
            const optionElement = CSElementFactory.createByXPath(
                `//div[contains(@class, 'sssss-balloon') and @name='searchType']//ul[@role='listbox']//li[@role='option']//span[text()='${optionText}']/parent::span`,
                `Search type option: ${optionText}`,
                this.page
            );
            const isVisible = await optionElement.isVisibleWithTimeout(5000);

            if (isVisible) {
                CSReporter.pass(`Search type option verified: ${optionText}`);
            } else {
                CSReporter.fail(`Search type option not found: ${optionText}`);
                throw new Error(`Search type option verification failed: ${optionText}`);
            }
        }

        // Close dropdown
        await this.cumulativeMmtesHeader.clickWithTimeout(5000);
    }

    // ===================================================================
    // CUMULATIVE MMTE NAME DROPDOWN METHODS - Using CSElementFactory
    // ===================================================================

    public async clickCumulativeMmteNameDropdown(): Promise<void> {
        await this.cumulativeMmteNameDropdown.waitForVisible(10000);
        await this.cumulativeMmteNameDropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked Cumulative Mmte Name dropdown');
    }

    public async selectCumulativeMmteName(mmteName: string): Promise<void> {
        await this.clickCumulativeMmteNameDropdown();

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${mmteName}']/parent::span`,
            `Cumulative mmte name option: ${mmteName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected cumulative mmte name: ${mmteName}`);
    }

    public async verifyCumulativeMmteNameSelected(mmteName: string): Promise<void> {
        const selected = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='Search By']/ancestor::form[@class='sssss-form'][1]//button[@name='cumulativeMmteId']//span[@class='sssss-button__label' and text()='${mmteName}']`,
            `Selected cumulative mmte name: ${mmteName}`,
            this.page
        );

        await selected.waitForVisible(10000);
        const isVisible = await selected.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Cumulative mmte name verified as selected: ${mmteName}`);
        } else {
            CSReporter.fail(`Cumulative mmte name not selected: ${mmteName}`);
            throw new Error(`Cumulative mmte name verification failed: ${mmteName}`);
        }
    }

    public async verifyCumulativeMmteNameOptions(expectedOptions: string[]): Promise<void> {
        await this.clickCumulativeMmteNameDropdown();

        const listFirst = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']`,
            'Cumulative mmte name list first item',
            this.page
        );
        await listFirst.waitForVisible(10000);

        for (const optionText of expectedOptions) {
            const optionElement = CSElementFactory.createByXPath(
                `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${optionText}']/parent::span`,
                `Cumulative mmte name option: ${optionText}`,
                this.page
            );
            const isVisible = await optionElement.isVisibleWithTimeout(5000);

            if (isVisible) {
                CSReporter.pass(`Cumulative mmte name option verified: ${optionText}`);
            } else {
                CSReporter.fail(`Cumulative mmte name option not found: ${optionText}`);
                throw new Error(`Cumulative mmte name option verification failed: ${optionText}`);
            }
        }

        // Close dropdown
        await this.cumulativeMmtesHeader.clickWithTimeout(5000);
    }

    // ===================================================================
    // DATE INPUT METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async enterFromDate(date: string): Promise<void> {
        await this.fromDateInput.waitForVisible(10000);
        await this.fromDateInput.clearWithTimeout(5000);
        await this.fromDateInput.fillWithTimeout(date, 5000);
        CSReporter.info(`Entered From date: ${date}`);
    }

    public async enterToDate(date: string): Promise<void> {
        await this.toDateInput.waitForVisible(10000);
        await this.toDateInput.clearWithTimeout(5000);
        await this.toDateInput.fillWithTimeout(date, 5000);
        CSReporter.info(`Entered To date: ${date}`);
    }

    // ===================================================================
    // SEARCH ACTION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async verifySearchButtonEnabled(): Promise<void> {
        await this.searchButton.waitForVisible(10000);
        const isEnabled = await this.searchButton.isEnabledWithTimeout(5000);

        if (isEnabled) {
            CSReporter.pass('Search button is enabled');
        } else {
            CSReporter.fail('Search button is not enabled');
            throw new Error('Search button is disabled');
        }
    }

    public async clickSearchButton(): Promise<void> {
        await this.searchButton.waitForVisible(10000);
        await this.searchButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Search button');
        await this.waitForPageLoad();
    }

    public async verifyAddConditionButtonEnabled(): Promise<void> {
        await this.addConditionButton.waitForVisible(10000);
        const isEnabled = await this.addConditionButton.isEnabledWithTimeout(5000);

        if (isEnabled) {
            CSReporter.pass('Add Condition button is enabled');
        } else {
            CSReporter.fail('Add Condition button is not enabled');
            throw new Error('Add Condition button is disabled');
        }
    }

    public async clickAddConditionButton(): Promise<void> {
        await this.addConditionButton.waitForVisible(10000);
        await this.addConditionButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Add Condition button');
    }

    public async verifyResetButtonEnabled(): Promise<void> {
        await this.resetButton.waitForVisible(10000);
        const isEnabled = await this.resetButton.isEnabledWithTimeout(5000);

        if (isEnabled) {
            CSReporter.pass('Reset button is enabled');
        } else {
            CSReporter.fail('Reset button is not enabled');
            throw new Error('Reset button is disabled');
        }
    }

    public async clickResetButton(): Promise<void> {
        await this.resetButton.waitForVisible(10000);
        await this.resetButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Reset button');
    }

    // ===================================================================
    // DISPLAYING SECTION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async verifyDisplayingHeaderPresent(): Promise<void> {
        await this.displayingHeader.waitForVisible(15000);
        const isVisible = await this.displayingHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Displaying header is present');
        } else {
            CSReporter.fail('Displaying header not found');
            throw new Error('Displaying header verification failed');
        }
    }

    public async verifyDisplayedFilterCriteria(filterLabel: string, filterValue: string): Promise<void> {
        const label = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${filterLabel}']`,
            `Filter label: ${filterLabel}`,
            this.page
        );

        await label.waitForVisible(10000);
        const isLabelVisible = await label.isVisibleWithTimeout(5000);

        if (!isLabelVisible) {
            CSReporter.fail(`Filter label not found: ${filterLabel}`);
            throw new Error(`Filter label verification failed: ${filterLabel}`);
        }

        const value = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${filterLabel}']/following-sibling::div[1]`,
            `Filter value for: ${filterLabel}`,
            this.page
        );
        const actualValue = await value.textContentWithTimeout(5000);

        if (actualValue?.trim() === filterValue) {
            CSReporter.pass(`Filter criteria verified: ${filterLabel} = ${filterValue}`);
        } else {
            CSReporter.fail(`Filter value mismatch: Expected=${filterValue}, Actual=${actualValue}`);
            throw new Error(`Filter value verification failed: ${filterLabel}`);
        }
    }

    // ===================================================================
    // RESULTS TABLE METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async verifyResultsTablePresent(): Promise<void> {
        await this.resultsTable.waitForVisible(15000);
        const isVisible = await this.resultsTable.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Results table is present');
        } else {
            CSReporter.fail('Results table not found');
            throw new Error('Results table verification failed');
        }
    }

    public async verifyNoDataAvailable(): Promise<boolean> {
        const isVisible = await this.noDataAvailable.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.info('No data available in results table');
            return true;
        }
        return false;
    }

    public async verifyDataIsAvailable(): Promise<void> {
        const noData = await this.verifyNoDataAvailable();
        if (noData) {
            CSReporter.fail('No data available in results table');
            throw new Error('Results table has no data');
        }
        CSReporter.pass('Data is available in results table');
    }

    public async verifyAllColumnHeaders(): Promise<void> {
        const headers = [
            { element: this.rrrrrrrrDateColumnHeader, name: 'Rrrrrrrr Date' },
            { element: this.mmteColumnHeader, name: 'Mmte (%)' },
            { element: this.cumulativeMmteNameColumnHeader, name: 'Cumulative Mmte Name' },
            { element: this.sourceColumnHeader, name: 'Source' },
            { element: this.publicationDateColumnHeader, name: 'Publication Date' },
            { element: this.actionsColumnHeader, name: 'Actions' }
        ];

        for (const header of headers) {
            await header.element.waitForVisible(10000);
            const isVisible = await header.element.isVisibleWithTimeout(5000);

            if (isVisible) {
                CSReporter.pass(`Column header verified: ${header.name}`);
            } else {
                CSReporter.fail(`Column header not found: ${header.name}`);
                throw new Error(`Column header verification failed: ${header.name}`);
            }
        }
    }

    // ===================================================================
    // SORTING METHODS (SCENARIO EXT05) - Using CSElementFactory
    // ===================================================================

    public async clickColumnHeader(columnName: string): Promise<void> {
        const column = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::button[1]`,
            `Column header button: ${columnName}`,
            this.page
        );

        await column.waitForVisible(10000);
        await column.clickWithTimeout(10000);
        CSReporter.info(`Clicked column header: ${columnName}`);
    }

    public async verifySortState(columnName: string, sortOrder: 'ascending' | 'descending' | 'unsorted'): Promise<void> {
        let xpath: string;

        if (sortOrder === 'ascending') {
            xpath = `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='ascending']`;
        } else if (sortOrder === 'descending') {
            xpath = `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='descending']`;
        } else {
            xpath = `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][contains(@class,'sssss-table__sortable-unsorted-indicator')]`;
        }

        const element = CSElementFactory.createByXPath(xpath, `Sort state ${sortOrder} for ${columnName}`, this.page);
        await element.waitForVisible(10000);
        const isVisible = await element.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Column ${columnName} is sorted ${sortOrder}`);
        } else {
            CSReporter.fail(`Column ${columnName} is not sorted ${sortOrder}`);
            throw new Error(`Sort state verification failed: ${columnName} ${sortOrder}`);
        }
    }

    public async sortColumnAndVerify(columnName: string, sortOrder: 'ascending' | 'descending'): Promise<void> {
        await this.clickColumnHeader(columnName);
        await this.verifySortState(columnName, sortOrder);
    }

    // ===================================================================
    // TABLE DATA EXTRACTION METHODS - Using CSElementFactory
    // ===================================================================

    public async getTableRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody//tr`,
            'Table rows',
            this.page
        );
        const count = await rows.count();
        CSReporter.info(`Table row count: ${count}`);
        return count;
    }

    public async getTableCellValue(rowIndex: number, columnIndex: number): Promise<string> {
        const cell = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//tbody//tr[${rowIndex}]/td[${columnIndex}]`,
            `Table cell [${rowIndex}, ${columnIndex}]`,
            this.page
        );
        const value = await cell.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getTableRowData(rowIndex: number): Promise<{
        rrrrrrrrDate: string;
        mmte: string;
        cumulativeMmteName: string;
        source: string;
        publicationDate: string;
    }> {
        const rrrrrrrrDate = await this.getTableCellValue(rowIndex, 1);
        const mmte = await this.getTableCellValue(rowIndex, 2);
        const cumulativeMmteName = await this.getTableCellValue(rowIndex, 3);
        const source = await this.getTableCellValue(rowIndex, 4);
        const publicationDate = await this.getTableCellValue(rowIndex, 5);

        return {
            rrrrrrrrDate,
            mmte,
            cumulativeMmteName,
            source,
            publicationDate
        };
    }

    public async getAllTableData(): Promise<Array<{
        rrrrrrrrDate: string;
        mmte: string;
        cumulativeMmteName: string;
        source: string;
        publicationDate: string;
    }>> {
        const rowCount = await this.getTableRowCount();
        const data: Array<any> = [];

        for (let i = 1; i <= rowCount; i++) {
            const rowData = await this.getTableRowData(i);
            data.push(rowData);
        }

        CSReporter.info(`Extracted ${data.length} rows from results table`);
        return data;
    }

    // ===================================================================
    // PAGINATION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    public async getPaginationTotalCount(): Promise<number> {
        await this.paginationTotalItems.waitForVisible(10000);
        const text = await this.paginationTotalItems.textContentWithTimeout(5000);

        // Extract number from text like "of 1673 items"
        const match = text?.match(/of (\d+) items?/);
        if (match && match[1]) {
            const count = parseInt(match[1], 10);
            CSReporter.info(`Total pagination count: ${count}`);
            return count;
        }

        CSReporter.fail('Could not extract pagination total count');
        throw new Error('Pagination total count extraction failed');
    }

    public async getPaginationCurrentRange(): Promise<string> {
        await this.paginationCurrentItems.waitForVisible(10000);
        const text = await this.paginationCurrentItems.textContentWithTimeout(5000);
        CSReporter.info(`Current pagination range: ${text}`);
        return text?.trim() || '';
    }

    // ===================================================================
    // ROW ACTION METHODS (EDIT, REMOVE) - Using CSElementFactory
    // ===================================================================

    public async clickEditButtonForRow(rowIndex: number): Promise<void> {
        const editButton = CSElementFactory.createByXPath(
            `//tbody/tr[${rowIndex}]/td[6]//span[text()='Edit']/parent::button[@aria-label='Edit Cumulative Mmte Instance']`,
            `Edit button for row ${rowIndex}`,
            this.page
        );

        await editButton.waitForVisible(10000);
        await editButton.clickWithTimeout(10000);
        CSReporter.info(`Clicked Edit button for row ${rowIndex}`);
    }

    public async clickRemoveButtonForRow(rowIndex: number): Promise<void> {
        const removeButton = CSElementFactory.createByXPath(
            `//tbody/tr[${rowIndex}]/td[6]//span[text()='Remove']/parent::button[@aria-label='Delete Cumulative Mmte Instance']`,
            `Remove button for row ${rowIndex}`,
            this.page
        );

        await removeButton.waitForVisible(10000);
        await removeButton.clickWithTimeout(10000);
        CSReporter.info(`Clicked Remove button for row ${rowIndex}`);
    }

    public async verifyEditButtonPresent(rowIndex: number): Promise<void> {
        const editButton = CSElementFactory.createByXPath(
            `//tbody/tr[${rowIndex}]/td[6]//span[text()='Edit']/parent::button[@aria-label='Edit Cumulative Mmte Instance']`,
            `Edit button for row ${rowIndex}`,
            this.page
        );

        const isVisible = await editButton.isVisibleWithTimeout(5000);
        const isEnabled = await editButton.isEnabledWithTimeout(5000);

        if (isVisible && isEnabled) {
            CSReporter.pass(`Edit button is present and enabled for row ${rowIndex}`);
        } else {
            CSReporter.fail(`Edit button is not present or enabled for row ${rowIndex}`);
            throw new Error(`Edit button verification failed for row ${rowIndex}`);
        }
    }

    public async verifyRemoveButtonPresent(rowIndex: number): Promise<void> {
        const removeButton = CSElementFactory.createByXPath(
            `//tbody/tr[${rowIndex}]/td[6]//span[text()='Remove']/parent::button[@aria-label='Delete Cumulative Mmte Instance']`,
            `Remove button for row ${rowIndex}`,
            this.page
        );

        const isVisible = await removeButton.isVisibleWithTimeout(5000);
        const isEnabled = await removeButton.isEnabledWithTimeout(5000);

        if (isVisible && isEnabled) {
            CSReporter.pass(`Remove button is present and enabled for row ${rowIndex}`);
        } else {
            CSReporter.fail(`Remove button is not present or enabled for row ${rowIndex}`);
            throw new Error(`Remove button verification failed for row ${rowIndex}`);
        }
    }

    // ===================================================================
    // EDIT INSTANCE MODAL METHODS (SCENARIO EXT07, EXT08, EXT09)
    // ===================================================================

    public async verifyEditInstanceModalOpen(): Promise<void> {
        await this.editInstanceModal.waitForVisible(15000);
        const isVisible = await this.editInstanceModal.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Edit Instance modal is open');
        } else {
            CSReporter.fail('Edit Instance modal is not open');
            throw new Error('Edit Instance modal verification failed');
        }
    }

    public async verifyEditInstanceModalClosed(): Promise<void> {
        const isVisible = await this.editInstanceModal.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.fail('Edit Instance modal is still open');
            throw new Error('Edit Instance modal should be closed');
        }
        CSReporter.pass('Edit Instance modal is closed');
    }

    public async getEditInstanceCumulativeRefValue(): Promise<string> {
        const value = CSElementFactory.createByXPath(
            `//div[@class='sssss-panel__content-wrapper']//div[@class='sssss-panel__body']//button[@name='cumulativeMmteId']//span[@class='sssss-button__label']`,
            'Cumulative scattered value in modal',
            this.page
        );
        const text = await value.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async getEditInstanceRrrrrrrrDateValue(): Promise<string> {
        return await this.editInstanceRrrrrrrrDateInput.inputValueWithTimeout(5000);
    }

    public async getEditInstanceMmteValue(): Promise<string> {
        return await this.editInstanceMmteInput.inputValueWithTimeout(5000);
    }

    public async selectCumulativeRefInEditModal(cumulativeRefName: string): Promise<void> {
        await this.editInstanceCumulativeRefDropdown.waitForVisible(10000);
        await this.editInstanceCumulativeRefDropdown.clickWithTimeout(10000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${cumulativeRefName}']/parent::span`,
            `Cumulative scattered option: ${cumulativeRefName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and modal to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected cumulative scattered in modal: ${cumulativeRefName}`);
    }

    public async setEditInstanceRrrrrrrrDate(date: string): Promise<void> {
        await this.editInstanceRrrrrrrrDateInput.waitForVisible(10000);
        await this.editInstanceRrrrrrrrDateInput.clearWithTimeout(5000);
        await this.editInstanceRrrrrrrrDateInput.fillWithTimeout(date, 5000);
        CSReporter.info(`Set rrrrrrrr date in modal: ${date}`);
    }

    public async setEditInstanceMmte(mmte: string): Promise<void> {
        await this.editInstanceMmteInput.waitForVisible(10000);
        await this.editInstanceMmteInput.clearWithTimeout(5000);
        await this.editInstanceMmteInput.fillWithTimeout(mmte, 5000);
        CSReporter.info(`Set mmte in modal: ${mmte}`);
    }

    public async clickEditInstanceSaveButton(): Promise<void> {
        await this.editInstanceSaveButton.waitForVisible(10000);
        await this.editInstanceSaveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked SAVE button in Edit Instance modal');
    }

    public async clickEditInstanceCancelButton(): Promise<void> {
        await this.editInstanceCancelButton.waitForVisible(10000);
        await this.editInstanceCancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button in Edit Instance modal');
    }

    public async getEditInstanceErrorMessage(): Promise<string> {
        const isVisible = await this.editInstanceErrorMessage.isVisibleWithTimeout(5000);
        if (isVisible) {
            const message = await this.editInstanceErrorMessage.textContentWithTimeout(5000);
            return message?.trim() || '';
        }
        return '';
    }

    public async verifyEditInstanceErrorMessage(expectedMessage: string): Promise<void> {
        const actualMessage = await this.getEditInstanceErrorMessage();

        if (actualMessage === expectedMessage) {
            CSReporter.pass(`Error message verified: ${expectedMessage}`);
        } else {
            CSReporter.fail(`Error message mismatch. Expected: ${expectedMessage}, Actual: ${actualMessage}`);
            throw new Error('Error message verification failed');
        }
    }

    // ===================================================================
    // ADD INSTANCE MODAL METHODS (SCENARIO EXT10)
    // ===================================================================

    public async clickAddInstanceButton(): Promise<void> {
        await this.addInstanceButton.waitForVisible(10000);
        await this.addInstanceButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Add Instance button');
    }

    public async verifyAddInstanceModalOpen(): Promise<void> {
        await this.addInstanceModalHeader.waitForVisible(15000);
        const isVisible = await this.addInstanceModalHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Add Instance modal is open');
        } else {
            CSReporter.fail('Add Instance modal is not open');
            throw new Error('Add Instance modal verification failed');
        }
    }

    public async verifyAddInstanceModalClosed(): Promise<void> {
        const isVisible = await this.addInstanceModalHeader.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.fail('Add Instance modal is still open');
            throw new Error('Add Instance modal should be closed');
        }
        CSReporter.pass('Add Instance modal is closed');
    }

    public async selectCumulativeRefInAddModal(cumulativeRefName: string): Promise<void> {
        // Add modal uses same dropdown as Edit modal - reuse editInstanceCumulativeRefDropdown
        await this.editInstanceCumulativeRefDropdown.waitForVisible(10000);
        await this.editInstanceCumulativeRefDropdown.clickWithTimeout(10000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${cumulativeRefName}']/parent::span`,
            `Cumulative scattered option: ${cumulativeRefName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and modal to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected cumulative scattered in Add Instance modal: ${cumulativeRefName}`);
    }

    public async setAddInstanceRrrrrrrrDate(date: string): Promise<void> {
        // Add modal uses same input as Edit modal
        await this.editInstanceRrrrrrrrDateInput.waitForVisible(10000);
        await this.editInstanceRrrrrrrrDateInput.clearWithTimeout(5000);
        await this.editInstanceRrrrrrrrDateInput.fillWithTimeout(date, 5000);
        CSReporter.info(`Set rrrrrrrr date in Add Instance modal: ${date}`);
    }

    public async setAddInstanceMmte(mmte: string): Promise<void> {
        // Add modal uses same input as Edit modal
        await this.editInstanceMmteInput.waitForVisible(10000);
        await this.editInstanceMmteInput.clearWithTimeout(5000);
        await this.editInstanceMmteInput.fillWithTimeout(mmte, 5000);
        CSReporter.info(`Set mmte in Add Instance modal: ${mmte}`);
    }

    public async clickAddInstanceSaveButton(): Promise<void> {
        await this.editInstanceSaveButton.waitForVisible(10000);
        await this.editInstanceSaveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked SAVE button in Add Instance modal');
    }

    public async clickAddInstanceCancelButton(): Promise<void> {
        await this.editInstanceCancelButton.waitForVisible(10000);
        await this.editInstanceCancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button in Add Instance modal');
    }

    public async getAddInstanceErrorMessage(): Promise<string> {
        const isVisible = await this.addInstanceErrorMessage.isVisibleWithTimeout(5000);
        if (isVisible) {
            const message = await this.addInstanceErrorMessage.textContentWithTimeout(5000);
            return message?.trim() || '';
        }
        return '';
    }

    public async verifyAddInstanceErrorMessage(expectedMessage: string): Promise<void> {
        const actualMessage = await this.getAddInstanceErrorMessage();

        if (actualMessage === expectedMessage) {
            CSReporter.pass(`Error message verified: ${expectedMessage}`);
        } else {
            CSReporter.fail(`Error message mismatch. Expected: ${expectedMessage}, Actual: ${actualMessage}`);
            throw new Error('Error message verification failed');
        }
    }

    public async verifyInstanceSavedMessage(): Promise<void> {
        await this.instanceSavedMessage.waitForVisible(5000);
        const isVisible = await this.instanceSavedMessage.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.pass('Instance Saved message is displayed');
        } else {
            CSReporter.fail('Instance Saved message not found');
            throw new Error('Instance Saved message verification failed');
        }
    }

    // ===================================================================
    // CONFIRM DELETE MODAL METHODS (SCENARIO EXT11)
    // ===================================================================

    public async verifyConfirmDeleteModalOpen(): Promise<void> {
        await this.confirmDeleteModalHeader.waitForVisible(15000);
        const isVisible = await this.confirmDeleteModalHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Confirm Delete modal is open');
        } else {
            CSReporter.fail('Confirm Delete modal is not open');
            throw new Error('Confirm Delete modal verification failed');
        }
    }

    public async verifyConfirmDeleteModalClosed(): Promise<void> {
        const isVisible = await this.confirmDeleteModalHeader.isVisibleWithTimeout(3000);
        if (isVisible) {
            CSReporter.fail('Confirm Delete modal is still open');
            throw new Error('Confirm Delete modal should be closed');
        }
        CSReporter.pass('Confirm Delete modal is closed');
    }

    public async getConfirmDeleteMessageText(): Promise<string> {
        await this.confirmDeleteMessageText.waitForVisible(10000);
        const message = await this.confirmDeleteMessageText.textContentWithTimeout(5000);
        return message?.trim() || '';
    }

    public async verifyConfirmDeleteMessage(expectedMessage: string): Promise<void> {
        const actualMessage = await this.getConfirmDeleteMessageText();

        if (actualMessage === expectedMessage) {
            CSReporter.pass(`Confirm Delete message verified: ${expectedMessage}`);
        } else {
            CSReporter.fail(`Confirm Delete message mismatch. Expected: ${expectedMessage}, Actual: ${actualMessage}`);
            throw new Error('Confirm Delete message verification failed');
        }
    }

    public async clickConfirmDeleteButton(): Promise<void> {
        await this.confirmDeleteButton.waitForVisible(10000);
        await this.confirmDeleteButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Delete button in Confirm Delete modal');
    }

    public async clickConfirmDeleteCancelButton(): Promise<void> {
        await this.confirmDeleteCancelButton.waitForVisible(10000);
        await this.confirmDeleteCancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button in Confirm Delete modal');
    }

    // ===================================================================
    // EXPORT METHODS (SCENARIO EXT12) - Using CSElementFactory
    // ===================================================================

    public async verifyExportButtonState(expectedState: 'enabled' | 'disabled'): Promise<void> {
        await this.exportButton.waitForVisible(10000);
        const isEnabled = await this.exportButton.isEnabledWithTimeout(5000);

        if (expectedState === 'enabled' && isEnabled) {
            CSReporter.pass('Export button is enabled');
        } else if (expectedState === 'disabled' && !isEnabled) {
            CSReporter.pass('Export button is disabled');
        } else {
            CSReporter.fail(`Export button state mismatch. Expected: ${expectedState}`);
            throw new Error('Export button state verification failed');
        }
    }

    public async clickExportButton(): Promise<void> {
        await this.exportButton.waitForVisible(10000);
        const isEnabled = await this.exportButton.isEnabledWithTimeout(5000);

        if (!isEnabled) {
            CSReporter.fail('Export button is disabled');
            throw new Error('Cannot click disabled Export button');
        }

        await this.exportButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Export button');
    }

    public async verifyExportMenuOption(optionName: string): Promise<void> {
        const option = CSElementFactory.createByXPath(
            `//span[@class='sssss-button__label' and text()='Export']/parent::button[@aria-label='Export']/parent::div[1]//div[@class='sssss-balloon__content']//ul[@aria-label='Export']//li//span[text()='${optionName}']`,
            `Export menu option: ${optionName}`,
            this.page
        );

        await option.waitForVisible(10000);
        const isVisible = await option.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Export menu option verified: ${optionName}`);
        } else {
            CSReporter.fail(`Export menu option not found: ${optionName}`);
            throw new Error(`Export menu option verification failed: ${optionName}`);
        }
    }

    public async clickExportMenuOption(optionName: string): Promise<void> {
        const option = CSElementFactory.createByXPath(
            `//span[@class='sssss-button__label' and text()='Export']/parent::button[@aria-label='Export']/parent::div[1]//div[@class='sssss-balloon__content']//ul[@aria-label='Export']//span[text()='${optionName}']/ancestor::button[1]`,
            `Export menu option button: ${optionName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        CSReporter.info(`Clicked export menu option: ${optionName}`);
    }

    // ===================================================================
    // UTILITY METHODS
    // ===================================================================

    public async waitForPageLoad(): Promise<void> {
        await this.waitForPageLoad();
    }

    public async getColumnValues(columnName: string): Promise<string[]> {
        const columnIndex = this.getColumnIndex(columnName);
        const rowCount = await this.getTableRowCount();
        const values: string[] = [];

        for (let i = 1; i <= rowCount; i++) {
            const value = await this.getTableCellValue(i, columnIndex);
            values.push(value);
        }

        CSReporter.info(`Extracted ${values.length} values from column: ${columnName}`);
        return values;
    }

    private getColumnIndex(columnName: string): number {
        const columnMap: { [key: string]: number } = {
            'Rrrrrrrr Date': 1,
            'Mmte (%)': 2,
            'Cumulative Mmte Name': 3,
            'Source': 4,
            'Publication Date': 5,
            'Actions': 6
        };

        return columnMap[columnName] || 0;
    }

    public async verifySortedData(columnName: string, sortOrder: 'ascending' | 'descending'): Promise<void> {
        const values = await this.getColumnValues(columnName);

        if (columnName === 'Mmte (%)') {
            // Numeric sorting
            const numericValues = values.map(v => parseFloat(v.replace('%', '')));
            const sortedNumeric = [...numericValues].sort((a, b) => sortOrder === 'ascending' ? a - b : b - a);

            for (let i = 0; i < numericValues.length; i++) {
                if (numericValues[i] !== sortedNumeric[i]) {
                    CSReporter.fail(`Data not sorted correctly: ${columnName} ${sortOrder}`);
                    throw new Error(`Sort verification failed for ${columnName}`);
                }
            }
        } else if (columnName === 'Rrrrrrrr Date' || columnName === 'Publication Date') {
            // Date sorting
            const dateValues = values.map(v => new Date(v));
            const sortedDates = [...dateValues].sort((a, b) => sortOrder === 'ascending' ? a.getTime() - b.getTime() : b.getTime() - a.getTime());

            for (let i = 0; i < dateValues.length; i++) {
                if (dateValues[i].getTime() !== sortedDates[i].getTime()) {
                    CSReporter.fail(`Data not sorted correctly: ${columnName} ${sortOrder}`);
                    throw new Error(`Sort verification failed for ${columnName}`);
                }
            }
        } else {
            // String sorting
            const sortedValues = [...values].sort((a, b) => sortOrder === 'ascending' ? a.localeCompare(b) : b.localeCompare(a));

            for (let i = 0; i < values.length; i++) {
                if (values[i] !== sortedValues[i]) {
                    CSReporter.fail(`Data not sorted correctly: ${columnName} ${sortOrder}`);
                    throw new Error(`Sort verification failed for ${columnName}`);
                }
            }
        }

        CSReporter.pass(`Data verified as sorted ${sortOrder} for column: ${columnName}`);
    }

    // ===================================================================
    // ADDITIONAL METHODS FOR STEP DEFINITIONS
    // ===================================================================

    public async clickAndConditionTypeDropdown(): Promise<void> {
        const dropdown = CSElementFactory.createByXPath(
            `//h5[text()='Search']/ancestor::section[1]//div[text()='And']/ancestor::div[contains(@class, 'sssss-form-field')][1]//button[@name='searchType']`,
            'And condition Type dropdown',
            this.page
        );
        await dropdown.waitForVisible(10000);
        await dropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked And condition Type dropdown');
    }

    public async selectAndConditionType(searchType: string): Promise<void> {
        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon')]//ul[@role='listbox']//li[@role='option']//span[text()='${searchType}']/parent::span`,
            `And condition type option: ${searchType}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected And condition type: ${searchType}`);
    }

    public async verifyAddInstanceButtonEnabled(): Promise<void> {
        await this.addInstanceButton.waitForVisible(10000);
        const isVisible = await this.addInstanceButton.isVisibleWithTimeout(5000);
        const isEnabled = await this.addInstanceButton.isEnabledWithTimeout(5000);

        if (isVisible && isEnabled) {
            CSReporter.pass('Add Instance button is visible and enabled');
        } else {
            CSReporter.fail('Add Instance button is not visible or enabled');
            throw new Error('Add Instance button verification failed');
        }
    }

    public async closeDropdown(): Promise<void> {
        // Click outside to close any open dropdown
        await this.cumulativeMmtesHeader.clickWithTimeout(5000);
        CSReporter.info('Closed dropdown');
    }

    public async verifyCumulativeMmteNameDropdownPresent(): Promise<void> {
        await this.cumulativeMmteNameDropdown.waitForVisible(10000);
        const isVisible = await this.cumulativeMmteNameDropdown.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Cumulative Mmte Name dropdown is present');
        } else {
            CSReporter.fail('Cumulative Mmte Name dropdown not found');
            throw new Error('Cumulative Mmte Name dropdown verification failed');
        }
    }

    public async verifyCumulativeMmteNamesPopulated(): Promise<void> {
        await this.clickCumulativeMmteNameDropdown();

        const listItem = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']`,
            'Cumulative mmte name list item',
            this.page
        );
        await listItem.waitForVisible(10000);
        const count = await listItem.count();

        if (count > 0) {
            CSReporter.pass(`Cumulative mmte names populated: ${count} items found`);
        } else {
            CSReporter.fail('No cumulative mmte names found in dropdown');
            throw new Error('Cumulative mmte names not populated');
        }

        // Close dropdown
        await this.closeDropdown();
    }

    public async verifyFromDateInputPresent(): Promise<void> {
        await this.fromDateInput.waitForVisible(10000);
        const isVisible = await this.fromDateInput.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('From date input is present');
        } else {
            CSReporter.fail('From date input not found');
            throw new Error('From date input verification failed');
        }
    }

    public async verifyToDateInputPresent(): Promise<void> {
        await this.toDateInput.waitForVisible(10000);
        const isVisible = await this.toDateInput.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('To date input is present');
        } else {
            CSReporter.fail('To date input not found');
            throw new Error('To date input verification failed');
        }
    }

    public async verifyColumnHeaderPresent(columnName: string): Promise<void> {
        const header = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//th[@role='columnheader']//span[text()='${columnName}']`,
            `Column header: ${columnName}`,
            this.page
        );

        await header.waitForVisible(10000);
        const isVisible = await header.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Column header present: ${columnName}`);
        } else {
            CSReporter.fail(`Column header not found: ${columnName}`);
            throw new Error(`Column header verification failed: ${columnName}`);
        }
    }

    public async setItemsPerPage(itemCount: number): Promise<void> {
        const dropdown = CSElementFactory.createByXPath(
            `//div[@aria-label='Cumulative Mmtes Pagination']//button[contains(@class, 'sssss-paginator__trigger')]`,
            'Items per page dropdown',
            this.page
        );
        await dropdown.waitForVisible(10000);
        await dropdown.clickWithTimeout(10000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon')]//ul[@role='listbox']//li[@role='option']//span[text()='${itemCount}']/parent::span`,
            `Items per page option: ${itemCount}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and table to refresh with new page size
        await this.page.waitForTimeout(500);
        CSReporter.info(`Set items per page to: ${itemCount}`);
    }

    public async sortColumnDescending(columnName: string): Promise<void> {
        // Click once for ascending, twice for descending
        await this.clickColumnHeader(columnName);

        // Check if already descending
        try {
            await this.verifySortState(columnName, 'descending');
        } catch {
            // Click again to get descending
            await this.clickColumnHeader(columnName);
        }
        CSReporter.info(`Sorted column ${columnName} descending`);
    }

    /**
     * Select an cumulative mmte by name in the Edit Instance modal
     * The mmte name should be determined by the step definition (using database helper)
     */
    public async selectCumulativeMmteInEditModal(mmteName: string): Promise<void> {
        await this.editInstanceCumulativeRefDropdown.waitForVisible(10000);
        await this.editInstanceCumulativeRefDropdown.clickWithTimeout(10000);

        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[@class='sssss-listbox-option__label'][normalize-space()='${mmteName}']/parent::span`,
            `Cumulative mmte option: ${mmteName}`,
            this.page
        );

        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and modal to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.info(`Selected cumulative mmte in Edit modal: ${mmteName}`);
    }

    public async getTableCellValueByColumnName(rowIndex: number, columnName: string): Promise<string> {
        const columnIndex = this.getColumnIndex(columnName);
        if (columnIndex === 0) {
            CSReporter.warn(`Unknown column name: ${columnName}`);
            return '';
        }
        return await this.getTableCellValue(rowIndex, columnIndex);
    }
}

export default TTTFCumulativeMmtesPage;

-------------------------------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Home Page
 * Source: SCENARIO_EXT01_CumulativeMmtes_PageElements.txt (Step 2)
 * Handles Home page verification after login
 */
@CSPage('tttf-home')
export class TTTFHomePage extends CSBasePage {

    // ===================================================================
    // HOME PAGE ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h1[text()="Home"]',
        description: 'Home page header',
        waitForVisible: true,
        alternativeLocators: ['text:Home']
    })
    public homeHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//p[contains(text(),"Welcome, ")]/strong',
        description: 'Welcome message with username',
        waitForVisible: true,
        alternativeLocators: ['css:p:has-text("Welcome") strong']
    })
    public welcomeUsername!: CSWebElement;

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]',
        description: 'Main navigation menu',
        waitForVisible: true,
        alternativeLocators: ['css:nav[aria-label="main"] #sssssNavigatorBody']
    })
    public navigationMenu!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFHomePage elements initialized');
    }

    // ===================================================================
    // VERIFICATION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    /**
     * Verify Home page header is displayed
     */
    public async verifyHomePageHeader(): Promise<void> {
        await this.homeHeader.waitForVisible(15000);
        const isVisible = await this.homeHeader.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Home page header verified');
        } else {
            CSReporter.fail('Home page header not found');
            throw new Error('Home page header verification failed');
        }
    }

    /**
     * Verify welcome message contains expected username
     * @param expectedUsername - The expected username in welcome message
     */
    public async verifyWelcomeMessage(expectedUsername: string): Promise<void> {
        await this.welcomeUsername.waitForVisible(10000);
        const actualUsername = await this.welcomeUsername.textContentWithTimeout(5000);

        if (actualUsername?.trim() === expectedUsername) {
            CSReporter.pass(`Welcome message verified: ${expectedUsername}`);
        } else {
            CSReporter.fail(`Welcome message mismatch. Expected: ${expectedUsername}, Actual: ${actualUsername}`);
            throw new Error('Welcome message verification failed');
        }
    }

    /**
     * Get the welcome username text
     */
    public async getWelcomeUsername(): Promise<string> {
        await this.welcomeUsername.waitForVisible(10000);
        const text = await this.welcomeUsername.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    /**
     * Verify navigation menu is visible
     */
    public async verifyNavigationMenuVisible(): Promise<void> {
        await this.navigationMenu.waitForVisible(10000);
        const isVisible = await this.navigationMenu.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Navigation menu is visible');
        } else {
            CSReporter.fail('Navigation menu not found');
            throw new Error('Navigation menu verification failed');
        }
    }

    /**
     * Check if we're on the Home page
     */
    public async isAt(): Promise<boolean> {
        return await this.homeHeader.isVisibleWithTimeout(5000);
    }

    // ===================================================================
    // COMMON TASKS SECTION METHODS
    // ===================================================================

    /**
     * Verify Common Tasks section header is visible
     */
    public async verifyCommonTasksSection(): Promise<void> {
        CSReporter.info('Verifying Common Tasks section');
        const commonTasksHeader = CSElementFactory.createByXPath(
            "//h4[text()='Common Tasks']",
            'Common Tasks header',
            this.page
        );
        await commonTasksHeader.waitForVisible(10000);
        const isVisible = await commonTasksHeader.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Common Tasks section header not found');
        }
    }

    /**
     * Verify a Common Tasks card is visible
     * @param cardName - The name of the card to verify
     */
    public async verifyCommonTasksCard(cardName: string): Promise<void> {
        CSReporter.info(`Verifying Common Tasks card: ${cardName}`);
        const card = CSElementFactory.createByXPath(
            `//section[contains(@class, 'sssss-container--card')]//h2[text()='${cardName}']`,
            `Common Tasks card: ${cardName}`,
            this.page
        );
        await card.waitForVisible(10000);
        const isVisible = await card.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error(`Common Tasks card not found: ${cardName}`);
        }
    }

    /**
     * Verify a Common Tasks card has a specific button
     * @param cardName - The name of the card
     * @param buttonText - The button text to verify
     */
    public async verifyCommonTasksCardButton(cardName: string, buttonText: string): Promise<void> {
        CSReporter.info(`Verifying Common Tasks card "${cardName}" has button "${buttonText}"`);
        const button = CSElementFactory.createByXPath(
            `//h2[text()='${cardName}']/ancestor::section[1]//div[@class='sssss-container__footer']//span[text()='${buttonText}']/parent::button`,
            `Common Tasks button: ${buttonText}`,
            this.page
        );
        await button.waitForVisible(10000);
        const isVisible = await button.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error(`Button "${buttonText}" not found on card "${cardName}"`);
        }
    }

    /**
     * Click a Common Tasks button by text
     * @param buttonText - The button text to click
     */
    public async clickCommonTasksButton(buttonText: string): Promise<void> {
        CSReporter.info(`Clicking Common Tasks button: ${buttonText}`);
        const button = CSElementFactory.createByXPath(
            `//div[@class='sssss-container__footer']//span[text()='${buttonText}']/parent::button`,
            `Common Tasks button: ${buttonText}`,
            this.page
        );
        await button.waitForVisible(10000);
        await button.clickWithTimeout(10000);
        await this.waitForPageLoad();
    }

    /**
     * Check if Pending Approvals card is visible
     */
    public async isPendingApprovalsCardVisible(): Promise<boolean> {
        CSReporter.info('Checking if Pending Approvals card is visible');
        const card = CSElementFactory.createByXPath(
            "//section[contains(@class, 'sssss-container--card')]//h2[text()='Pending Approvals']",
            'Pending Approvals card',
            this.page
        );
        return await card.isVisibleWithTimeout(3000);
    }

    /**
     * Click Pending Approvals card button
     */
    public async clickPendingApprovalsCardButton(): Promise<void> {
        CSReporter.info('Clicking Pending Approvals card button');
        const button = CSElementFactory.createByXPath(
            "//h2[text()='Pending Approvals']/ancestor::section[1]//div[@class='sssss-container__footer']//span[contains(text(),'Pending Approvals')]/parent::button",
            'Pending Approvals card button',
            this.page
        );
        await button.waitForVisible(10000);
        await button.clickWithTimeout(10000);
        await this.waitForPageLoad();
    }
}

export default TTTFHomePage;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Navigation Page
 * Source: SCENARIO_EXT01_CumulativeMmtes_PageElements.txt (Step 3)
 * Handles main navigation menu interactions
 */
@CSPage('tttf-navigation')
export class TTTFNavigationPage extends CSBasePage {

    // ===================================================================
    // NAVIGATION MENU ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]',
        description: 'Main navigation menu container',
        waitForVisible: true,
        alternativeLocators: ['css:nav[aria-label="main"] #sssssNavigatorBody']
    })
    public navigationContainer!: CSWebElement;

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]//a[text()="Home"]',
        description: 'Home menu item',
        waitForVisible: true,
        alternativeLocators: ['css:nav[aria-label="main"] a:has-text("Home")']
    })
    public homeMenuItem!: CSWebElement;

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]//a[text()="Cumulative Mmtes"]',
        description: 'Cumulative Mmtes menu item',
        waitForVisible: true,
        alternativeLocators: ['css:nav[aria-label="main"] a:has-text("Cumulative Mmtes")']
    })
    public cumulativeMmtesMenuItem!: CSWebElement;

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]//a[text()="Scattered Mmtes"]',
        description: 'Scattered Mmtes menu item',
        alternativeLocators: ['css:nav[aria-label="main"] a:has-text("Scattered Mmtes")']
    })
    public scatteredMmtesMenuItem!: CSWebElement;

    @CSGetElement({
        xpath: '//nav[@aria-label="main"]/div[@id="sssssNavigatorBody"]//a[text()="Zeal/Premisis"]',
        description: 'Zeal/Premisis menu item',
        alternativeLocators: ['css:nav[aria-label="main"] a:has-text("Zeal/Premisis")']
    })
    public zealPremisisMenuItem!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFNavigationPage elements initialized');
    }

    // ===================================================================
    // NAVIGATION METHODS - Using Framework Wrapper Methods
    // ===================================================================

    /**
     * Click on a menu item by name using CSElementFactory for dynamic element
     * @param menuItemName - The name of the menu item to click
     */
    public async clickMenuItem(menuItemName: string): Promise<void> {
        CSReporter.info(`Clicking menu item: ${menuItemName}`);

        // Use CSElementFactory for dynamic menu item element
        const menuItem = CSElementFactory.createByXPath(
            `//nav[@aria-label='main']/div[@id='sssssNavigatorBody']//a[text()='${menuItemName}']`,
            `Menu item: ${menuItemName}`,
            this.page
        );

        await menuItem.waitForVisible(10000);
        await menuItem.clickWithTimeout(10000);
        await this.waitForPageLoad();

        CSReporter.pass(`Clicked menu item: ${menuItemName}`);
    }

    /**
     * Verify a menu item is visible using CSElementFactory for dynamic element
     * @param menuItemName - The name of the menu item to verify
     */
    public async verifyMenuItemVisible(menuItemName: string): Promise<void> {
        CSReporter.info(`Verifying menu item visible: ${menuItemName}`);

        // Use CSElementFactory for dynamic menu item element
        const menuItem = CSElementFactory.createByXPath(
            `//nav[@aria-label='main']/div[@id='sssssNavigatorBody']//a[text()='${menuItemName}']`,
            `Menu item: ${menuItemName}`,
            this.page
        );

        await menuItem.waitForVisible(10000);
        const isVisible = await menuItem.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Menu item verified: ${menuItemName}`);
        } else {
            CSReporter.fail(`Menu item not found: ${menuItemName}`);
            throw new Error(`Menu item verification failed: ${menuItemName}`);
        }
    }

    /**
     * Navigate to Cumulative Mmtes page
     */
    public async navigateToCumulativeMmtes(): Promise<void> {
        await this.clickMenuItem('Cumulative Mmtes');
    }

    /**
     * Navigate to Home page
     */
    public async navigateToHome(): Promise<void> {
        await this.clickMenuItem('Home');
    }

    /**
     * Verify navigation container is visible
     */
    public async verifyNavigationContainerVisible(): Promise<void> {
        await this.navigationContainer.waitForVisible(10000);
        const isVisible = await this.navigationContainer.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass('Navigation container is visible');
        } else {
            CSReporter.fail('Navigation container not found');
            throw new Error('Navigation container verification failed');
        }
    }

    /**
     * Verify page header is visible using CSElementFactory for dynamic element
     * @param headerText - The expected header text
     */
    public async verifyPageHeader(headerText: string): Promise<void> {
        CSReporter.info(`Verifying page header: ${headerText}`);

        // Use CSElementFactory for dynamic page header element
        const header = CSElementFactory.createByXPath(
            `//h1[text()="${headerText}"]`,
            `Page header: ${headerText}`,
            this.page
        );

        await header.waitForVisible(15000);
        const isVisible = await header.isVisibleWithTimeout(5000);

        if (isVisible) {
            CSReporter.pass(`Page header verified: ${headerText}`);
        } else {
            CSReporter.fail(`Page header not found: ${headerText}`);
            throw new Error(`Page header verification failed: ${headerText}`);
        }
    }

    /**
     * Check if Pending Approvals menu item is visible
     */
    public async isPendingApprovalsMenuVisible(): Promise<boolean> {
        CSReporter.info('Checking if Pending Approvals menu item is visible');
        const menuItem = CSElementFactory.createByXPath(
            "//nav[@aria-label='main']/div[@id='sssssNavigatorBody']//a[contains(text(),'Pending Approvals')]",
            'Pending Approvals menu item',
            this.page
        );
        return await menuItem.isVisibleWithTimeout(3000);
    }

    /**
     * Click Pending Approvals menu item
     */
    public async clickPendingApprovalsMenu(): Promise<void> {
        CSReporter.info('Clicking Pending Approvals menu item');
        const menuItem = CSElementFactory.createByXPath(
            "//nav[@aria-label='main']/div[@id='sssssNavigatorBody']//a[contains(text(),'Pending Approvals')]",
            'Pending Approvals menu item',
            this.page
        );
        await menuItem.waitForVisible(10000);
        await menuItem.clickWithTimeout(10000);
        await this.waitForPageLoad();
    }

    /**
     * Verify File Upload page is displayed
     * Note: File Upload page doesn't have h1 header, verify using Add files button
     */
    public async verifyFileUploadPage(): Promise<void> {
        CSReporter.info('Verifying File Upload page');
        const addFilesButton = CSElementFactory.createByXPath(
            "//span[text()='Add files']",
            'Add files button',
            this.page
        );
        await addFilesButton.waitForVisible(15000);
        const isVisible = await addFilesButton.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('File Upload page verification failed - Add files button not found');
        }
        CSReporter.pass('File Upload page verified');
    }
}

export default TTTFNavigationPage;


--------------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @zealPremisis @pageElements @DS01
Feature: Zeal Premisis - Page Elements and Navigation Verification
  As a TTTF user
  I want to verify all page elements on the Zeals/Premisis screen
  So that I can ensure the application is properly configured

  @pageVerification @elementVerification
  Scenario Outcircle: Verify Zeal Premisis page elements and navigation
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # No test data setup required for this scenario

    # ============================================================
    # SCENARIO STEPS
    # ============================================================
    Given I login to TTTF as "<userName>"
    And I navigate to Zeals Premisis page

    # Verify Page Header
    Then I should see Zeals Premisis page header

    # Verify Search Section
    And Zeal Premisis Search section should be expanded
    And I should see Zeal Premisis Search section

    # Verify Type Dropdown Default Selection
    And I should see Zeal Premisis Type dropdown
    And Zeal Premisis Type dropdown should show "Zeal" by default

    # Verify All Type Dropdown Options
    Then I should see Zeal Premisis Type dropdown options "Zeal, Premisis, Scattered Mmte, Disputed Mmte, Inductor Group, Kindness Circle, Sketchmark, Administrator, GGG Name"

    # ============================================================
    # PART C: ZEAL TYPE VERIFICATION
    # ============================================================

    # Verify Zeal Type Selected
    When I select "Zeal" from Zeal Premisis Type dropdown

    # Verify Attribute Dropdown for Zeal Type
    Then I should see Zeal Premisis Attribute dropdown
    And I should see Zeal Premisis Attribute options "Name, ID, Key"

    # Test Zeal - Name Attribute
    When I select "Name" from Zeal Premisis Attribute dropdown
    Then Zeal Name input field should be visible
    And Include Premisis checkbox should be enabled
    And Include Premisis checkbox should be unchecked
    And Zeal Premisis Search button should be disabled
    And Zeal Premisis Add Condition button should be enabled
    And Zeal Premisis Reset button should be enabled

    # Verify Search Button Enable/Disable - Zeal Name
    When I enter "ma" in Zeal Name input field
    Then Zeal Premisis Search button should be enabled
    When I clear Zeal Name input field
    Then Zeal Premisis Search button should be disabled

    # Test Zeal - ID Attribute
    When I select "ID" from Zeal Premisis Attribute dropdown
    Then Zeal ID input field should be visible
    And Include Premisis checkbox should be enabled
    And Include Premisis checkbox should be unchecked
    And Zeal Premisis Search button should be disabled

    # Verify Search Button Enable/Disable - Zeal ID
    When I enter "ma" in Zeal ID input field
    Then Zeal Premisis Search button should be enabled
    When I clear Zeal ID input field
    Then Zeal Premisis Search button should be disabled

    # Test Zeal - Key Attribute
    When I select "Key" from Zeal Premisis Attribute dropdown
    Then Zeal Key input field should be visible
    And Include Premisis checkbox should be enabled
    And Include Premisis checkbox should be unchecked
    And Zeal Premisis Search button should be disabled

    # Verify Search Button Enable/Disable - Zeal Key
    When I enter "ma" in Zeal Key input field
    Then Zeal Premisis Search button should be enabled
    When I clear Zeal Key input field
    Then Zeal Premisis Search button should be disabled

    # ============================================================
    # PART D: PREMISIS TYPE VERIFICATION
    # ============================================================

    When I select "Premisis" from Zeal Premisis Type dropdown
    Then I should see Zeal Premisis Attribute dropdown
    And I should see Zeal Premisis Attribute options "Description, Zzzt Seggregation"

    # Verify Premisis Type - Description Attribute
    When I select "Description" from Zeal Premisis Attribute dropdown
    Then Premisis Description input field should be visible
    And Include Premisis checkbox should be disabled
    And Include Premisis checkbox should be checked
    And Zeal Premisis Search button should be disabled
    And Zeal Premisis Add Condition button should be enabled
    And Zeal Premisis Reset button should be enabled

    # Verify Search Button Enable/Disable - Premisis Description
    When I enter "ma" in Premisis Description input field
    Then Zeal Premisis Search button should be enabled
    When I clear Premisis Description input field
    Then Zeal Premisis Search button should be disabled

    # Verify Premisis Type - Zzzt Seggregation Attribute
    When I select "Zzzt Seggregation" from Zeal Premisis Attribute dropdown
    Then Zzzt Seggregation input field should be visible
    And Include Premisis checkbox should be disabled
    And Include Premisis checkbox should be checked
    And Zeal Premisis Search button should be disabled

    # Verify Search Button Enable/Disable - Zzzt Seggregation
    When I enter "ma" in Zzzt Seggregation input field
    Then Zeal Premisis Search button should be enabled
    When I clear Zzzt Seggregation input field
    Then Zeal Premisis Search button should be disabled

    # ============================================================
    # PART E: SCATTERED MMTE TYPE VERIFICATION
    # ============================================================

    When I select "Scattered Mmte" from Zeal Premisis Type dropdown
    Then I should see Zeal Premisis Attribute dropdown
    And I should see Zeal Premisis Attribute options "Name, Cumulative Mmte, Has Disputed"

    # Scattered Mmte - Name Attribute
    When I select "Name" from Zeal Premisis Attribute dropdown
    Then Scattered Mmte Name input field should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Search Button Enable/Disable - Scattered Mmte Name
    When I enter "ma" in Scattered Mmte Name input field
    Then Zeal Premisis Search button should be enabled
    When I clear Scattered Mmte Name input field
    Then Zeal Premisis Search button should be disabled

    # Scattered Mmte - Cumulative Mmte Attribute
    When I select "Cumulative Mmte" from Zeal Premisis Attribute dropdown
    Then Scattered Mmte Cumulative Mmte dropdown should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Cumulative Mmte Dropdown Options from Database
    And Scattered Mmte Cumulative Mmte dropdown options should match database

    # Verify Search Button Enable/Disable - Cumulative Mmte Selection
    When I select "SOFR Overnight" from Scattered Mmte Cumulative Mmte dropdown
    Then Zeal Premisis Search button should be enabled

    # Scattered Mmte - Has Disputed Attribute
    When I select "Has Disputed" from Zeal Premisis Attribute dropdown
    Then Has Disputed dropdown should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Has Disputed Dropdown Options
    And Has Disputed dropdown should have options "Yes, No"

    # Verify Search Button Enable/Disable - Has Disputed Selection
    When I select "Yes" from Has Disputed dropdown
    Then Zeal Premisis Search button should be enabled

    # ============================================================
    # PART F: DISPUTED MMTE TYPE VERIFICATION
    # ============================================================

    When I select "Disputed Mmte" from Zeal Premisis Type dropdown
    Then I should see Zeal Premisis Attribute dropdown
    And I should see Zeal Premisis Attribute options "Name, Disputed Date, Cumulative Mmte"

    # Disputed Mmte - Name Attribute
    When I select "Name" from Zeal Premisis Attribute dropdown
    Then Disputed Mmte Name input field should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Search Button Enable/Disable - Disputed Mmte Name
    When I enter "ma" in Disputed Mmte Name input field
    Then Zeal Premisis Search button should be enabled
    When I clear Disputed Mmte Name input field
    Then Zeal Premisis Search button should be disabled

    # Disputed Mmte - Disputed Date Attribute
    When I select "Disputed Date" from Zeal Premisis Attribute dropdown
    Then Disputed Date input field should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Search Button Enable/Disable - Disputed Date
    When I enter "10/22/2025" in Disputed Date input field
    Then Zeal Premisis Search button should be enabled
    When I clear Disputed Date input field
    Then Zeal Premisis Search button should be disabled

    # Disputed Mmte - Cumulative Mmte Attribute
    When I select "Cumulative Mmte" from Zeal Premisis Attribute dropdown
    Then Disputed Cumulative Mmte dropdown should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Disputed Cumulative Mmte Dropdown Options from Database
    And Disputed Cumulative Mmte dropdown options should match database

    # Verify Search Button Enable/Disable - Disputed Cumulative Mmte Selection
    When I select "SOFR Overnight" from Disputed Cumulative Mmte dropdown
    Then Zeal Premisis Search button should be enabled

    # ============================================================
    # PART G: INDUCTOR GROUP TYPE VERIFICATION
    # ============================================================

    When I select "Inductor Group" from Zeal Premisis Type dropdown
    Then Zeal Premisis Attribute dropdown should not be visible
    And Inductor Group Name dropdown should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Inductor Group Dropdown Options from Database
    And Inductor Group Name dropdown options should match database

    # Verify Search Button Enable/Disable - Inductor Group Selection
    When I select "RMBS" from Inductor Group Name dropdown
    Then Zeal Premisis Search button should be enabled

    # ============================================================
    # PART H: KINDNESS CIRCLE TYPE VERIFICATION
    # ============================================================

    When I select "Kindness Circle" from Zeal Premisis Type dropdown
    Then Zeal Premisis Attribute dropdown should not be visible
    And Kindness Circle Name dropdown should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Kindness Circle Dropdown Options from Database
    And Kindness Circle Name dropdown options should match database

    # Verify Search Button Enable/Disable - Kindness Circle Selection
    When I select "CDSS" from Kindness Circle Name dropdown
    Then Zeal Premisis Search button should be enabled

    # ============================================================
    # PART I: SKETCHMARK TYPE VERIFICATION
    # ============================================================

    When I select "Sketchmark" from Zeal Premisis Type dropdown
    Then Zeal Premisis Attribute dropdown should not be visible
    And Sketchmark Flag dropdown should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Sketchmark Flag Dropdown Options
    And Sketchmark Flag dropdown should have options "Yes, No"

    # Verify Search Button Enable/Disable - Sketchmark Flag Selection
    When I select "No" from Sketchmark Flag dropdown
    Then Zeal Premisis Search button should be enabled

    # ============================================================
    # PART J: ADMINISTRATOR TYPE VERIFICATION
    # ============================================================

    When I select "Administrator" from Zeal Premisis Type dropdown
    Then I should see Zeal Premisis Attribute dropdown
    And I should see Zeal Premisis Attribute options "Name, Email"

    # Administrator - Name Attribute
    When I select "Name" from Zeal Premisis Attribute dropdown
    Then Administrator Name input field should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Search Button Enable/Disable - Administrator Name
    When I enter "ma" in Administrator Name input field
    Then Zeal Premisis Search button should be enabled
    When I clear Administrator Name input field
    Then Zeal Premisis Search button should be disabled

    # Administrator - Email Attribute
    When I select "Email" from Zeal Premisis Attribute dropdown
    Then Administrator Email input field should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Search Button Enable/Disable - Administrator Email
    When I enter "example@computershare.com" in Administrator Email input field
    Then Zeal Premisis Search button should be enabled
    When I clear Administrator Email input field
    Then Zeal Premisis Search button should be disabled

    # ============================================================
    # PART K: GGG NAME TYPE VERIFICATION
    # ============================================================

    When I select "GGG Name" from Zeal Premisis Type dropdown
    Then Zeal Premisis Attribute dropdown should not be visible
    And Calc Shool Name input field should be visible
    And Include Premisis checkbox should be enabled
    And Zeal Premisis Search button should be disabled

    # Verify Search Button Enable/Disable - GGG Name
    When I enter "ma" in Calc Shool Name input field
    Then Zeal Premisis Search button should be enabled
    When I clear Calc Shool Name input field
    Then Zeal Premisis Search button should be disabled

    # ============================================================
    # PART L: RESULTS TABLE VERIFICATION
    # ============================================================

    Then I should see Zeal Premisis Results section
    And Zeal Premisis Results header should be visible
    And Zeal Premisis results table should be visible
    And Zeal Premisis results table should show "No data available."

    # Verify Results Table Column Headers
    And Results table should have column "Type"
    And Results table should have column "Zeal ID"
    And Results table should have column "Zeal Key"
    And Results table should have column "Zeal Name"
    And Results table should have column "Inductor Group"
    And Results table should have column "Zzzt Seggregation"
    And Results table should have column "Ttcalc Shools"
    And Results table should have column "Associated Mmtes"
    And Results table should have column "Action"

    # Verify Type Column Sorting
    And Results table "Type" column should be unsorted by default
    When I click on Results table "Type" column header
    Then Results table "Type" column should be sorted descending
    When I click on Results table "Type" column header
    Then Results table "Type" column should be sorted ascending

    # Verify Zeal ID Column Sorting
    And Results table "Zeal ID" column should be unsorted by default
    When I click on Results table "Zeal ID" column header
    Then Results table "Zeal ID" column should be sorted descending
    When I click on Results table "Zeal ID" column header
    Then Results table "Zeal ID" column should be sorted ascending

    # Verify Zeal Key Column Sorting
    And Results table "Zeal Key" column should be unsorted by default
    When I click on Results table "Zeal Key" column header
    Then Results table "Zeal Key" column should be sorted descending
    When I click on Results table "Zeal Key" column header
    Then Results table "Zeal Key" column should be sorted ascending

    # Verify Zeal Name Column Sorting
    And Results table "Zeal Name" column should be unsorted by default
    When I click on Results table "Zeal Name" column header
    Then Results table "Zeal Name" column should be sorted descending
    When I click on Results table "Zeal Name" column header
    Then Results table "Zeal Name" column should be sorted ascending

    # Verify Inductor Group Column Sorting
    And Results table "Inductor Group" column should be unsorted by default
    When I click on Results table "Inductor Group" column header
    Then Results table "Inductor Group" column should be sorted descending
    When I click on Results table "Inductor Group" column header
    Then Results table "Inductor Group" column should be sorted ascending

    # Verify Zzzt Seggregation Column Sorting
    And Results table "Zzzt Seggregation" column should be unsorted by default
    When I click on Results table "Zzzt Seggregation" column header
    Then Results table "Zzzt Seggregation" column should be sorted descending
    When I click on Results table "Zzzt Seggregation" column header
    Then Results table "Zzzt Seggregation" column should be sorted ascending

    # Verify Ttcalc Shools Column Sorting
    And Results table "Ttcalc Shools" column should be unsorted by default
    When I click on Results table "Ttcalc Shools" column header
    Then Results table "Ttcalc Shools" column should be sorted descending
    When I click on Results table "Ttcalc Shools" column header
    Then Results table "Ttcalc Shools" column should be sorted ascending

    # Note: Associated Mmtes column is NOT sortable

    # Verify Action Column Sorting
    And Results table "Action" column should be unsorted by default
    When I click on Results table "Action" column header
    Then Results table "Action" column should be sorted descending
    When I click on Results table "Action" column header
    Then Results table "Action" column should be sorted ascending

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_page_verification_scenarios.json", "path": "$", "filter": "scenarioId=DS01 AND runFlag=Yes"}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newZeal @approval @makerChecker @ND03
Feature: New Zeal Setup - Approval Flow (Maker-Checker)
  As a TTTF user
  I want to set up a new zeal with scattered mmtes and go through approval flow
  So that zeals are properly configured with maker-checker workflow

  Background:
    # Common setup for all scenarios

  @newZealSetup @fullFlow
  Scenario Outcircle: New Zeal Setup with Scattered Mmtes - Complete Maker-Checker Flow
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Sketchmark Flag: <sketchmarkFlag>
    # Output Ttcalc File: <outputTtcalcFile>
    # FFX File Inductor Type: <ffxFileInductorType>
    # Has Disputed: <hasDisputedScatteredMmte>

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get zeal for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Zeal Details
    When I click on Zeal Key link in row 1
    Then I should see Zeal Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Verify Summary Section
    And Summary section should be visible
    And Zeal ID in Summary should match stored value
    And Zeal Name in Summary should match stored value

    # Step 6: Verify Settings Section (View Mode)
    And Use Sketchmark Replacement should show "False"
    And Output Ttcalc File should show "False"

    # Step 7: Verify No Scattered Mmtes
    And No Scattered Mmtes message should be visible
    And Save button should be disabled
    And Cancel button should be enabled

    # Step 8: Enter Edit Mode
    When I click Edit button
    Then I should see Edit Zeal page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    And Output Ttcalc File checkbox should be unchecked

    # Step 9: Configure Settings
    When I check Use Sketchmark Replacement checkbox
    And I check Output Ttcalc File checkbox
    And I verify FFX Inductor Type options against database
    And I select FFX Inductor Type "<ffxFileInductorType>"
    Then Zeal Save button should be enabled

    # Step 10: Wait for Add/Remove Button
    And I wait for Add Remove button to be visible
    And Reorder button should be visible

    # Step 11: Add Scattered Mmtes
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section

    # Step 12: Save Changes
    When I click Save button
    Then I should see save success message
    And I should see pending approval alert
    And View Changes link should be visible
    And Save button should be disabled
    And Edit button should be disabled

    # Step 13: Verify Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And Changes table should show pending changes
    And I verify changes data matches added scattered mmtes
    And Cancel Changes button should be visible

    # Step 14: Database Validation (Before Approval)
    When I verify zeal data record exists in database
    And I verify zealpremisis data has correct settings
    Then I verify status log shows "AWAITING" status

    # Step 15: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW
    # ============================================================

    # Step 16: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 17: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 18: Find and View Zeal
    When I find and click View link for stored zeal
    Then I should see Zeal Details page

    # Step 19: Verify Changes Tab
    And View Changes link should be visible
    When I click View Changes link
    Then Changes section should be visible
    And Approve button should be visible
    And Reject button should be visible

    # Step 20: Approve Changes
    When I click Approve button
    Then Changes table should be empty after approval

    # Step 21: Verify History Tab
    When I click History tab
    Then History section should be visible
    And History table should show approved changes
    And I verify history data matches approved scattered mmtes

    # Step 22: Database Validation (After Approval)
    When I verify zeal data record exists in database
    And I verify zealpremisis data has correct settings
    Then I verify status log shows "APPROVED" status
    And I verify zealpremisis mmte data exists after approval

    # Step 23: Verify Details Tab (Post Approval)
    When I click Details tab
    Then Summary section should be visible
    And Use Sketchmark Replacement should show "True"
    And Output Ttcalc File should show "True"
    And FFX Inductor Type dropdown should show "<ffxFileInductorType>"
    And Scattered mmtes should be displayed in Associated Scattered Mmtes section

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_new_zeal_setup_scenarios.json", "path": "$", "filter": "runFlag=Yes"}


----------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newPremisis @approval @makerChecker @ND04
Feature: New Premisis Setup - Approval Flow (Maker-Checker)
  As a TTTF user
  I want to set up a new premisis with scattered mmtes and go through approval flow
  So that premisis are properly configured with maker-checker workflow

  Background:
    # Common setup for all scenarios

  @newPremisisSetup @fullFlow
  Scenario Outcircle: New Premisis Setup with Scattered Mmtes - Complete Maker-Checker Flow
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Sketchmark Flag: <sketchmarkFlag>
    # Has Disputed: <hasDisputedScatteredMmte>
    # Note: Output Ttcalc File and FFX Inductor Type are DISABLED for Premisis

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get premisis for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Premisis" from Zeal Premisis Type dropdown
    And I select "Zzzt Seggregation" from Zeal Premisis Attribute dropdown
    And I enter stored "zzztSeggregation" in Zeal Premisis search field "zzztSeggregation"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Premisis Details
    When I click on Zeal Key link in row 1
    Then I should see Premisis Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Verify Summary Section
    And Summary section should be visible
    And Zeal ID in Summary should match stored value
    And Zeal Name in Summary should match stored value

    # Step 6: Verify Settings Section (View Mode)
    And Use Sketchmark Replacement should show "False"
    And Output Ttcalc File should show "False"

    # Step 7: Verify No Scattered Mmtes
    And No Scattered Mmtes message should be visible
    And Save button should be disabled
    And Cancel button should be enabled

    # Step 8: Enter Edit Mode
    When I click Edit button
    Then I should see Edit Premisis page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked

    # Step 9: Configure Settings (Premisis - Only Sketchmark, Output/FFX disabled)
    When I check Use Sketchmark Replacement checkbox
    Then Output Ttcalc File checkbox should be disabled for Premisis
    And FFX Inductor Type dropdown should be disabled for Premisis
    And Zeal Save button should be enabled

    # Step 10: Wait for Add/Remove Button
    And I wait for Add Remove button to be visible
    And Reorder button should be visible

    # Step 11: Add Scattered Mmtes
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section

    # Step 12: Save Changes
    When I click Save button
    Then I should see save success message for Premisis
    And I should see pending approval alert
    And View Changes link should be visible
    And Save button should be disabled
    And Edit button should be disabled

    # Step 13: Verify Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And Changes table should show pending changes
    And I verify changes data matches added scattered mmtes
    And Cancel Changes button should be visible

    # Step 14: Database Validation (Before Approval)
    When I verify zzzt data record exists in database
    And I verify zealpremisis data has correct settings for Premisis
    Then I verify status log shows "AWAITING" status

    # Step 15: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW
    # ============================================================

    # Step 16: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 17: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 18: Find and View Premisis
    When I find and click View link for stored zeal
    Then I should see Premisis Details page

    # Step 19: Verify Changes Tab
    And View Changes link should be visible
    When I click View Changes link
    Then Changes section should be visible
    And Approve button should be visible
    And Reject button should be visible

    # Step 20: Approve Changes
    When I click Approve button
    Then Changes table should be empty after approval

    # Step 21: Verify History Tab
    When I click History tab
    Then History section should be visible
    And History table should show approved changes
    And I verify history data matches approved scattered mmtes

    # Step 22: Database Validation (After Approval)
    When I verify zzzt data record exists in database
    And I verify zealpremisis data has correct settings for Premisis
    Then I verify status log shows "APPROVED" status
    And I verify zealpremisis mmte data exists after approval

    # Step 23: Verify Details Tab (Post Approval)
    When I click Details tab
    Then Summary section should be visible
    And Use Sketchmark Replacement should show "True"
    And Scattered mmtes should be displayed in Associated Scattered Mmtes section

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_new_premisis_setup_scenarios.json", "path": "$", "filter": "runFlag=Yes"}

--------------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newPremisis @rejection @makerChecker @ND05
Feature: New Premisis Setup - Rejection Flow (Maker-Checker)
  As a TTTF user
  I want to test rejection of new premisis setup changes by approver
  So that maker-checker rejection workflow is properly validated

  Background:
    # Common setup for all scenarios

  @newPremisisRejection @fullFlow
  Scenario Outcircle: New Premisis Setup with Scattered Mmtes - Rejection by Approver
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Expected Result: Changes REJECTED by Approver

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get premisis for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Premisis" from Zeal Premisis Type dropdown
    And I select "Zzzt Seggregation" from Zeal Premisis Attribute dropdown
    And I enter stored "zzztSeggregation" in Zeal Premisis search field "zzztSeggregation"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Premisis Details and Edit
    When I click on Zeal Key link in row 1
    Then I should see Premisis Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Enter Edit Mode and Configure
    When I click Edit button
    Then I should see Edit Premisis page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    When I check Use Sketchmark Replacement checkbox

    # Step 6: Add Scattered Mmtes
    And I wait for Add Remove button to be visible
    And Reorder button should be visible
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section

    # Step 7: Save Changes
    When I click Save button
    Then I should see save success message for Premisis
    And I should see pending approval alert

    # Step 8: Database Validation (Before Rejection)
    When I verify zzzt data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 9: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW - REJECTION
    # ============================================================

    # Step 10: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 11: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 12: Find and View Premisis
    When I find and click View link for stored zeal
    Then I should see Premisis Details page

    # Step 13: Navigate to Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And Approve button should be visible
    And Reject button should be visible

    # Step 14: Reject Changes
    When I click Reject button
    Then Review Reject Email modal should be visible
    And Reject comment textarea should be visible
    And Send button should be visible

    # Step 15: Send Rejection
    When I click Send button in Reject modal
    Then Rejection email sent message should be displayed
    And Changes table should be empty after rejection

    # Step 16: Verify History Tab (No History for Rejected Changes)
    When I click History tab
    Then History section should be visible
    And History table should show no data

    # Step 17: Database Validation (After Rejection)
    Then I verify status log is cleared after rejection
    And I verify zealpremisis mmte data does not exist after rejection

    # Step 18: Verify Details Tab (Post Rejection)
    When I click Details tab
    Then Summary section should be visible
    And No Scattered Mmtes message should be visible

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_rejection_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Premisis"}

--------------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newZeal @rejection @makerChecker @ND06A
Feature: New Zeal Setup - Rejection Flow (Maker-Checker)
  As a TTTF user
  I want to test rejection of new zeal setup changes by approver
  So that maker-checker rejection workflow is properly validated

  Background:
    # Common setup for all scenarios

  @newZealRejection @fullFlow
  Scenario Outcircle: New Zeal Setup with Scattered Mmtes - Rejection by Approver
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Expected Result: Changes REJECTED by Approver

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get zeal for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Zeal Details and Edit
    When I click on Zeal Key link in row 1
    Then I should see Zeal Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Enter Edit Mode and Configure
    When I click Edit button
    Then I should see Edit Zeal page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    And Output Ttcalc File checkbox should be unchecked
    When I check Use Sketchmark Replacement checkbox
    And I check Output Ttcalc File checkbox
    And I select FFX Inductor Type "<ffxFileInductorType>"

    # Step 6: Add Scattered Mmtes
    And I wait for Add Remove button to be visible
    And Reorder button should be visible
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section

    # Step 7: Save Changes
    When I click Save button
    Then I should see save success message
    And I should see pending approval alert

    # Step 8: Database Validation (Before Rejection)
    When I verify zeal data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 9: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW - REJECTION
    # ============================================================

    # Step 10: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 11: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 12: Find and View Zeal
    When I find and click View link for stored zeal
    Then I should see Zeal Details page

    # Step 13: Navigate to Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And Approve button should be visible
    And Reject button should be visible

    # Step 14: Reject Changes
    When I click Reject button
    Then Review Reject Email modal should be visible
    And Reject comment textarea should be visible
    And Send button should be visible

    # Step 15: Send Rejection
    When I click Send button in Reject modal
    Then Rejection email sent message should be displayed
    And Changes table should be empty after rejection

    # Step 16: Verify History Tab (No History for Rejected Changes)
    When I click History tab
    Then History section should be visible
    And History table should show no data

    # Step 17: Database Validation (After Rejection)
    Then I verify status log is cleared after rejection
    And I verify zealpremisis mmte data does not exist after rejection

    # Step 18: Verify Details Tab (Post Rejection)
    When I click Details tab
    Then Summary section should be visible
    And No Scattered Mmtes message should be visible

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_rejection_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Zeal"}

------------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newZeal @cancel @ND06B
Feature: New Zeal Setup - Cancel Changes Flow
  As a TTTF user
  I want to cancel my own pending changes before approval
  So that I can undo changes without involving the approver

  Background:
    # Common setup for all scenarios

  @newZealCancel @fullFlow
  Scenario Outcircle: New Zeal Setup with Scattered Mmtes - Cancel by Requester
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # User: <requesterUser>
    # Expected Result: Changes CANCELLED by Requester (no approver needed)

    # ============================================================
    # SINGLE USER FLOW (REQUESTER ONLY)
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get zeal for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Zeal Details and Edit
    When I click on Zeal Key link in row 1
    Then I should see Zeal Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Enter Edit Mode and Configure
    When I click Edit button
    Then I should see Edit Zeal page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    And Output Ttcalc File checkbox should be unchecked
    When I check Use Sketchmark Replacement checkbox
    And I check Output Ttcalc File checkbox
    And I select FFX Inductor Type "<ffxFileInductorType>"

    # Step 6: Add Scattered Mmtes
    And I wait for Add Remove button to be visible
    And Reorder button should be visible
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section

    # Step 7: Save Changes
    When I click Save button
    Then I should see save success message
    And I should see pending approval alert

    # Step 8: Navigate to Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And Cancel Changes button should be visible

    # Step 9: Database Validation (Before Cancel)
    When I verify zeal data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 10: Cancel Changes
    When I click Cancel Changes button
    Then Cancel changes success message should be displayed
    And Changes table should be empty after cancel

    # Step 11: Verify History Tab (No History for Cancelled Changes)
    When I click History tab
    Then History section should be visible
    And History table should show no data

    # Step 12: Database Validation (After Cancel)
    Then I verify status log is cleared after cancel
    And I verify zealpremisis mmte data does not exist after cancel

    # Step 13: Verify Details Tab (Post Cancel)
    When I click Details tab
    Then Summary section should be visible
    And No Scattered Mmtes message should be visible

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_cancel_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Zeal"}

------------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @newPremisis @cancel @ND07
Feature: New Premisis Setup - Cancel Changes Flow
  As a TTTF user
  I want to cancel my own pending changes before approval
  So that I can undo changes without involving the approver

  Background:
    # Common setup for all scenarios

  @newPremisisCancel @fullFlow
  Scenario Outcircle: New Premisis Setup with Scattered Mmtes - Cancel by Requester
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # User: <requesterUser>
    # Expected Result: Changes CANCELLED by Requester (no approver needed)

    # ============================================================
    # SINGLE USER FLOW (REQUESTER ONLY)
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get premisis for new setup from database
    And I get scattered mmtes to add from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Premisis" from Zeal Premisis Type dropdown
    And I select "Zzzt Seggregation" from Zeal Premisis Attribute dropdown
    And I enter stored "zzztSeggregation" in Zeal Premisis search field "zzztSeggregation"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Premisis Details and Edit
    When I click on Zeal Key link in row 1
    Then I should see Premisis Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Enter Edit Mode and Configure
    When I click Edit button
    Then I should see Edit Premisis page
    And Edit button should be disabled
    And Use Sketchmark Replacement checkbox should be unchecked
    When I check Use Sketchmark Replacement checkbox

    # Step 6: Add Scattered Mmtes
    And I wait for Add Remove button to be visible
    And Reorder button should be visible
    When I click Add Remove button
    Then Select Options modal should be visible
    When I select all stored scattered mmtes in modal
    And I click Apply button in modal
    Then Scattered mmtes should be displayed in Associated Scattered Mmtes section

    # Step 7: Save Changes
    When I click Save button
    Then I should see save success message for Premisis
    And I should see pending approval alert

    # Step 8: Navigate to Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And Cancel Changes button should be visible

    # Step 9: Database Validation (Before Cancel)
    When I verify zzzt data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 10: Cancel Changes
    When I click Cancel Changes button
    Then Cancel changes success message should be displayed
    And Changes table should be empty after cancel

    # Step 11: Verify History Tab (No History for Cancelled Changes)
    When I click History tab
    Then History section should be visible
    And History table should show no data

    # Step 12: Database Validation (After Cancel)
    Then I verify status log is cleared after cancel
    And I verify zealpremisis mmte data does not exist after cancel

    # Step 13: Verify Details Tab (Post Cancel)
    When I click Details tab
    Then Summary section should be visible
    And No Scattered Mmtes message should be visible

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_cancel_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Premisis"}

------------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @zealPremisis @navigation @editZeal @DS08
Feature: Zeal Edit - Navigation Verification
  As a TTTF user
  I want to navigate to Edit Zeal screen using different methods
  So that I can verify both navigation paths work correctly

  Background:
    # Common setup for all scenarios

  @zealEditNavigation @fullFlow
  Scenario Outcircle: Zeal Edit Navigation - Two Path Verification
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # User: <username>
    # Type: <type>
    # Attribute: <attribute>

    # ============================================================
    # PART A: LOGIN AND NAVIGATION
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get zeal for edit navigation from database

    # Step 2: Login as User
    When I login to TTTF as "<username>"

    # Step 3: Navigate to Zeals/Premisis Page
    And I navigate to Zeals Premisis page

    # ============================================================
    # PART B: SEARCH FOR ZEAL
    # ============================================================

    # Step 4: Search By Type and Attribute
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I uncheck Include Premisis in results checkbox
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 5: Verify Search Results
    Then Search results should show type "ZEAL"
    And Search results should show stored zeal ID
    And Search results should show stored zeal key

    # ============================================================
    # PART C: FIRST NAVIGATION PATH - Zeal Key -> Details -> Edit
    # ============================================================

    # Step 6: Navigate via Zeal Key Link
    When I click on Zeal Key link in row 1
    Then I should see Zeal Details page
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 7: Verify Edit Button State
    And Edit button should be enabled

    # Step 8: Enter Edit Mode
    When I click Edit button
    Then Edit button should be disabled
    And I should see Edit Zeal page

    # ============================================================
    # PART D: CANCEL BUTTON WARNING POPUP VERIFICATION
    # ============================================================

    # Step 9: Click Cancel Button
    When I click Cancel button
    Then Warning popup should be displayed
    And Warning popup should show unsaved changes message
    And OK button should be visible in warning popup

    # Step 10: Dismiss Warning and Return
    When I click OK button in warning popup
    Then I should see Zeal Details page

    # ============================================================
    # PART E: SECOND NAVIGATION PATH - Action Column Edit Link
    # ============================================================

    # Step 11: Navigate Back to Zeal/Premisis Search
    When I navigate to Zeals Premisis page

    # Step 12: Repeat Search
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I uncheck Include Premisis in results checkbox
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 13: Navigate via Action Column Edit Link
    When I click Edit link in Action column for row 1
    Then I should see Edit Zeal page directly

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_edit_navigation_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Zeal"}

-----------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @zealPremisis @navigation @editPremisis @DS09A
Feature: Premisis Edit - Navigation Verification
  As a TTTF user
  I want to navigate to Edit Premisis screen using different methods
  So that I can verify both navigation paths work correctly

  Background:
    # Common setup for all scenarios

  @premisisEditNavigation @fullFlow
  Scenario Outcircle: Premisis Edit Navigation - Two Path Verification
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # User: <username>
    # Type: <type>
    # Attribute: <attribute>

    # ============================================================
    # PART A: LOGIN AND NAVIGATION
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get premisis for edit navigation from database

    # Step 2: Login as User
    When I login to TTTF as "<username>"

    # Step 3: Navigate to Zeals/Premisis Page
    And I navigate to Zeals Premisis page

    # ============================================================
    # PART B: SEARCH FOR PREMISIS
    # ============================================================

    # Step 4: Search By Type and Attribute
    And I select "Premisis" from Zeal Premisis Type dropdown
    And I select "Zzzt Seggregation" from Zeal Premisis Attribute dropdown
    And I enter stored "zzztSeggregation" in Zeal Premisis search field "zzztSeggregation"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 5: Verify Search Results
    Then Search results should show type "PREMISIS"
    And Search results should show stored zeal ID
    And Search results should show stored zeal key

    # ============================================================
    # PART C: FIRST NAVIGATION PATH - Zeal Key -> Premisis Details -> Edit
    # ============================================================

    # Step 6: Navigate via Zeal Key Link
    When I click on Zeal Key link in row 1
    Then I should see Premisis Details page
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 7: Verify Edit Button State
    And Edit button should be enabled

    # Step 8: Enter Edit Mode
    When I click Edit button
    Then Edit button should be disabled
    And I should see Edit Premisis page

    # ============================================================
    # PART D: SECOND NAVIGATION PATH - Action Column Edit Link
    # ============================================================

    # Step 9: Navigate Back to Zeal/Premisis Search
    When I navigate to Zeals Premisis page

    # Step 10: Repeat Search
    And I select "Premisis" from Zeal Premisis Type dropdown
    And I select "Zzzt Seggregation" from Zeal Premisis Attribute dropdown
    And I enter stored "zzztSeggregation" in Zeal Premisis search field "zzztSeggregation"
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 11: Navigate via Action Column Edit Link
    When I click Edit link in Action column for row 1
    Then I should see Edit Premisis page directly

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_edit_navigation_scenarios.json", "path": "$", "filter": "runFlag=Yes&&type=Premisis"}

---------------------------------------------------------------------------------------------------------------------------------------------------------------

@smoke @regression @existingZeal @update @approval @makerChecker @DS09B
Feature: Existing Zeal Update - Approval Flow (Maker-Checker)
  As a TTTF user
  I want to update an existing zeal with scattered mmtes and go through approval flow
  So that existing zeals can be properly modified with maker-checker workflow

  Background:
    # Common setup for all scenarios

  @existingZealUpdate @fullFlow
  Scenario Outcircle: Existing Zeal Update with Scattered Mmtes - Complete Maker-Checker Flow
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Update Sketchmark Flag: <updateSketchmarkFlag>
    # Update FFX Inductor Type: <updateFfxInductorType>
    # Update Scattered Mmtes: <updateScatteredMmtes>

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW
    # ============================================================

    # Step 1: Get Test Data from Database
    Given I get existing zeal with scattered mmtes from database
    And I get replacement scattered mmtes from database

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Premisis and Search
    And I navigate to Zeals Premisis page
    And I select "Zeal" from Zeal Premisis Type dropdown
    And I select "ID" from Zeal Premisis Attribute dropdown
    And I enter stored "zealId" in Zeal Premisis search field "zealId"
    And I uncheck Include Premisis in results checkbox
    And I click Zeal Premisis Search button
    And I wait for Zeal Premisis search results

    # Step 4: Navigate to Zeal Details
    When I click on Zeal Key link in row 1
    Then I should see Zeal Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # Step 5: Verify Existing Scattered Mmtes
    And Scattered mmtes should be displayed in Associated Scattered Mmtes section
    And I verify existing scattered mmtes match database

    # Step 6: Enter Edit Mode
    When I click Edit button
    Then I should see Edit Zeal page

    # Step 7: Toggle Sketchmark Flag
    When I toggle Use Sketchmark Replacement checkbox

    # Step 8: Update FFX Inductor Type (if applicable)
    And I update FFX Inductor Type to different value

    # Step 9: Update Scattered Mmtes
    When I click Add Remove button
    Then Select Options modal should be visible
    When I unselect existing scattered mmtes in modal
    And I select replacement scattered mmtes in modal
    And I click Apply button in modal
    Then Updated scattered mmtes should be displayed in Associated Scattered Mmtes section

    # Step 10: Save Changes
    When I click Save button
    Then I should see save success message
    And I should see pending approval alert
    And View Changes link should be visible

    # Step 11: Verify Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And Changes table should show update changes
    And Cancel Changes button should be visible

    # Step 12: Database Validation (Before Approval)
    When I verify zeal data record exists in database
    Then I verify status log shows "AWAITING" status

    # Step 13: Clear Browser Context for Re-Authentication (Switch User)
    When I clear browser context for re-authentication

    # ============================================================
    # PART B: APPROVER (CHECKER) FLOW
    # ============================================================

    # Step 14: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 15: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 16: Find and View Zeal
    When I find and click View link for stored zeal
    Then I should see Zeal Details page

    # Step 17: Verify Changes Tab
    And View Changes link should be visible
    When I click View Changes link
    Then Changes section should be visible
    And Approve button should be visible
    And Reject button should be visible

    # Step 18: Approve Changes
    When I click Approve button
    Then Approve Email modal should be visible
    When I click Send button in Approve modal
    Then Approval email sent message should be displayed
    And Changes table should be empty after approval

    # Step 19: Verify History Tab
    When I click History tab
    Then History section should be visible
    And History table should show approved changes

    # Step 20: Database Validation (After Approval)
    When I verify zeal data record exists in database
    Then I verify status log shows "APPROVED" status
    And I verify updated scattered mmtes in database

    # Step 21: Verify Details Tab (Post Approval)
    When I click Details tab
    Then Summary section should be visible
    And Updated scattered mmtes should be displayed in Associated Scattered Mmtes section

    Examples: {"type": "json", "source": "test/tttf/data/zeal_premisis_existing_zeal_update_scenarios.json", "path": "$", "filter": "runFlag=Yes"}

