private async verifyDisputedScatteredRateChanges(changeLog: ChangeLogRow[], disputedScatteredRateToUpdate: string, oldScatteredRatesList: string[], newScatteredRatesList: string[]): Promise<void> {
        const listDisputedScatteredRateToUpdate = disputedScatteredRateToUpdate.split(';').filter(p => p.trim());

        for (const item of listDisputedScatteredRateToUpdate) {
            const subItems = item.split('||');
            if (subItems.length < 2) continue;

            const refRateName = subItems[0].trim();
            const disputedRateName = subItems[1].trim();

            // CASE 1: Scattered rate is being ADDED as NEW (complete replacement scenario)
            // When old rates are removed and new rates added, there is NO separate disputed record
            // Only "Remove Scattered Rate" and "Add Scattered Rate" records exist - SKIP verification
            if (newScatteredRatesList.includes(refRateName)) {
                CSReporter.info(`Scattered rate ${refRateName} is newly added - no separate disputed rate record expected in change log`);
                continue;
            }

            // CASE 2: Scattered rate is in oldScatteredRatesList (being removed completely)
            // When a scattered rate is removed, there is NO separate disputed update record - SKIP verification
            if (oldScatteredRatesList.includes(refRateName)) {
                CSReporter.info(`Scattered rate ${refRateName} is being removed - no separate disputed rate record expected`);
                continue;
            }

            // CASE 3: Scattered rate EXISTS and is NOT being removed/replaced (update disputed on existing rate)
            // ONLY in this case, we expect a separate "Disputed Rate for <refRateName>" UPDATE record
            let found = false;
            const expectedFieldName = `Disputed Rate for ${refRateName}`;
            for (const row of changeLog) {
                // Check for "Disputed Rate for <refRateName>" or "DisputedScatteredRate" with scatteredRateName
                if ((row.fieldName === expectedFieldName) ||
                    (row.fieldName === 'DisputedScatteredRate' && row.scatteredRateName === refRateName)) {
                    const strDBNewValue = row.newValue;
                    const strDBAction = row.action;
                    const isUpdatedToday = TTTFDatabaseHelper.isOracleTimestampToday(row.updatedDt);

                    if (strDBNewValue === disputedRateName && strDBAction === 'UPDATE' && isUpdatedToday) {
                        CSReporter.pass(`DisputedScatteredRate UPDATE verified for existing rate ${refRateName}: NewValue=${strDBNewValue}`);
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                throw new Error(`DisputedScatteredRate UPDATE not found for existing rate: ${refRateName}. Expected: NewValue=${disputedRateName}`);
            }
        }
    }

    private async verifyDisputedStartDateChanges(changeLog: ChangeLogRow[], disputedStartDateToUpdate: string, oldScatteredRatesList: string[], newScatteredRatesList: string[]): Promise<void> {
        const listDisputedStartDateToUpdate = disputedStartDateToUpdate.split(';').filter(p => p.trim());

        for (const item of listDisputedStartDateToUpdate) {
            const subItems = item.split('||');
            if (subItems.length < 2) continue;

            const refRateName = subItems[0].trim();
            const disputedStartDate = subItems[1].trim();

            // CASE 1: Scattered rate is being ADDED as NEW (complete replacement scenario)
            // When old rates are removed and new rates added, there is NO separate disputed date record
            // Only "Remove Scattered Rate" and "Add Scattered Rate" records exist - SKIP verification
            if (newScatteredRatesList.includes(refRateName)) {
                CSReporter.info(`Scattered rate ${refRateName} is newly added - no separate disputed date record expected in change log`);
                continue;
            }

            // CASE 2: Scattered rate is in oldScatteredRatesList (being removed completely)
            // When a scattered rate is removed, there is NO separate disputed date update record - SKIP verification
            if (oldScatteredRatesList.includes(refRateName)) {
                CSReporter.info(`Scattered rate ${refRateName} is being removed - no separate disputed date record expected`);
                continue;
            }

            // CASE 3: Scattered rate EXISTS and is NOT being removed/replaced (update disputed date on existing rate)
            // ONLY in this case, we expect a separate "Disputed Date for <refRateName>" UPDATE record
            let found = false;
            const expectedFieldName = `Disputed Date for ${refRateName}`;
            for (const row of changeLog) {
                // Check for "Disputed Date for <refRateName>" or "DisputedDate" with scatteredRateName
                if ((row.fieldName === expectedFieldName) ||
                    (row.fieldName === 'DisputedDate' && row.scatteredRateName === refRateName)) {
                    const strDBNewValue = row.newValue;
                    const strDBAction = row.action;
                    const isUpdatedToday = TTTFDatabaseHelper.isOracleTimestampToday(row.updatedDt);

                    if (strDBNewValue === disputedStartDate && strDBAction === 'UPDATE' && isUpdatedToday) {
                        CSReporter.pass(`DisputedDate UPDATE verified for existing rate ${refRateName}: NewValue=${strDBNewValue}`);
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                throw new Error(`DisputedDate UPDATE not found for existing rate: ${refRateName}. Expected: NewValue=${disputedStartDate}`);
            }
        }
    }


    @CSBDDStepDef('I verify changes data matches expected updates')
    async verifyChangesDataMatchesExpectedUpdates(): Promise<void> {
        const zealId = this.scenarioContext.getVariable<string>('zealId');
        if (!zealId) {
            throw new Error('Zeal ID not found in scenario context');
        }
        CSReporter.info(`Verifying database change log for zeal ID: ${zealId}`);

        // Step 1: Execute change log query
        const changeLogResultSet = await TTTFDatabaseHelper.getChangeLogForZeal(zealId);
        if (changeLogResultSet.length === 0) {
            throw new Error(`No change log records found for zeal ID: ${zealId}`);
        }
        CSReporter.info(`Retrieved ${changeLogResultSet.length} change log records`);

        // Build scattered rates lists for later use
        const oldScatteredRatesList: string[] = [];
        const newScatteredRatesList: string[] = [];

        // Step 2: Verify SketchmarkFlagToUpdate
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (sketchmarkFlagToUpdate) {
            await this.verifySketchmarkFlagChange(changeLogResultSet, sketchmarkFlagToUpdate);
        }

        // Step 3: Verify FFXFileInductorTypeToUpdate
        const ffxFileInductorTypeToUpdate = this.scenarioContext.getVariable<string>('ffxFileInductorTypeToUpdate');
        if (ffxFileInductorTypeToUpdate) {
            await this.verifyOutputTtcalcChange(changeLogResultSet, ffxFileInductorTypeToUpdate);
        }

        // Step 4: Verify UpdateScatteredRatesFlag
        const updateScatteredRatesFlag = this.scenarioContext.getVariable<boolean>('updateScatteredRatesFlag');
        if (updateScatteredRatesFlag) {
            const scatteredRatesToUpdate = this.scenarioContext.getVariable<string>('scatteredRatesToUpdate') || '';
            if (scatteredRatesToUpdate) {
                const listScatteredRatesToUpdate = scatteredRatesToUpdate.split(';').filter(p => p.trim());
                for (const item of listScatteredRatesToUpdate) {
                    const subItems = item.split('||');
                    if (subItems.length >= 2) {
                        oldScatteredRatesList.push(subItems[0].trim());
                        newScatteredRatesList.push(subItems[1].trim());
                    }
                }

                // Store for later verification steps
                this.scenarioContext.setVariable('oldScatteredRatesList', oldScatteredRatesList);
                this.scenarioContext.setVariable('newScatteredRatesList', newScatteredRatesList);

                // Verify removed scattered rates
                await this.verifyRemovedScatteredRates(changeLogResultSet, oldScatteredRatesList);

                // Verify added scattered rates
                await this.verifyAddedScatteredRates(changeLogResultSet, newScatteredRatesList);
            }
        }

        // Step 5: Verify UpdateDisputedScatteredRateFlag
        const updateDisputedScatteredRateFlag = this.scenarioContext.getVariable<boolean>('updateDisputedScatteredRateFlag');
        if (updateDisputedScatteredRateFlag) {
            const disputedScatteredRateToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredRateToUpdate') || '';
            if (disputedScatteredRateToUpdate) {
                await this.verifyDisputedScatteredRateChanges(changeLogResultSet, disputedScatteredRateToUpdate, oldScatteredRatesList, newScatteredRatesList);
            }
        }

        // Step 6: Verify UpdateDisputedStartDateFlag
        const updateDisputedStartDateFlag = this.scenarioContext.getVariable<boolean>('updateDisputedStartDateFlag');
        if (updateDisputedStartDateFlag) {
            const disputedStartDateToUpdate = this.scenarioContext.getVariable<string>('disputedStartDateToUpdate') || '';
            if (disputedStartDateToUpdate) {
                await this.verifyDisputedStartDateChanges(changeLogResultSet, disputedStartDateToUpdate, oldScatteredRatesList, newScatteredRatesList);
            }
        }

        // Step 7: Verify FFXOrderUpdateFlag (user-provided)
        const ffxOrderUpdateFlag = this.scenarioContext.getVariable<boolean>('ffxOrderUpdateFlag');
        if (ffxOrderUpdateFlag) {
            const ffxOrderToUpdate = this.scenarioContext.getVariable<string>('ffxOrderToUpdate') || '';
            if (ffxOrderToUpdate) {
                await this.verifyFfxOrderChanges(changeLogResultSet, ffxOrderToUpdate, oldScatteredRatesList, newScatteredRatesList);
            }
        }

        // Step 8: Verify automatic FFX Order changes (CASE 3: partial removal scenario)
        // When some scattered rates are removed but others remain, the remaining rates'
        // FFX order changes automatically - verify these automatic changes
        const removeScatteredRatesFlag = this.scenarioContext.getVariable<boolean>('removeScatteredRatesFlag');
        const scatteredRatesToRemove = this.scenarioContext.getVariable<string>('scatteredRatesToRemove') || '';
        const existingScatteredRates = this.scenarioContext.getVariable<Array<{
            scatteredRateName: string;
            disputedScatteredRateName: string;
            disputedDate: string | Date;
            ffxOrder: number;
        }>>('existingScatteredRates') || [];

        // Build list of all removed rates (from both update and remove operations)
        const allRemovedRates: string[] = [...oldScatteredRatesList];
        if (removeScatteredRatesFlag && scatteredRatesToRemove) {
            const removeList = scatteredRatesToRemove.split(';').filter(r => r.trim());
            for (const rate of removeList) {
                if (!allRemovedRates.includes(rate.trim())) {
                    allRemovedRates.push(rate.trim());
                }
            }
        }

        // Check for automatic FFX order changes if partial removal occurred
        if (allRemovedRates.length > 0 && existingScatteredRates.length > allRemovedRates.length) {
            await this.verifyAutomaticFfxOrderChanges(changeLogResultSet, existingScatteredRates, allRemovedRates);
        }

        CSReporter.pass('All database change log verifications passed');
    }


    /**
     * Verifies automatic FFX Order changes that occur when scattered rates are partially removed.
     * CASE 3: When one scattered rate is removed but others remain, the remaining rates'
     * FFX order changes automatically (e.g., if rate at order 1 is removed, rate at order 2 becomes order 1).
     *
     * Change log format for FFX Order:
     * - Old value: "(<oldOrder>)<scatteredRate>"
     * - New value: "(<newOrder>)<scatteredRate>"
     */
    private async verifyAutomaticFfxOrderChanges(changeLog: ChangeLogRow[], existingScatteredRates: Array<{scatteredRateName: string; ffxOrder: number}>, removedScatteredRates: string[]): Promise<void> {
        // Find scattered rates that remain after partial removal
        const remainingRates = existingScatteredRates.filter(r => !removedScatteredRates.includes(r.scatteredRateName));

        if (remainingRates.length === 0 || removedScatteredRates.length === 0) {
            // No partial removal scenario - either all removed or none removed
            return;
        }

        CSReporter.info(`Checking automatic FFX Order changes for ${remainingRates.length} remaining scattered rates`);

        // Find FFX Order change records in the change log
        const ffxOrderRecords = changeLog.filter(row =>
            row.fieldName === 'FFX Order' &&
            row.action === 'UPDATE' &&
            TTTFDatabaseHelper.isOracleTimestampToday(row.updatedDt)
        );

        if (ffxOrderRecords.length === 0) {
            CSReporter.info('No automatic FFX Order changes found in change log (may not be required)');
            return;
        }

        // Verify each FFX Order change record
        for (const record of ffxOrderRecords) {
            const oldValue = record.oldValue || '';
            const newValue = record.newValue || '';

            // Parse format: "(<order>)<scatteredRate>"
            const oldMatch = oldValue.match(/\((\d+)\)(.+)/);
            const newMatch = newValue.match(/\((\d+)\)(.+)/);

            if (oldMatch && newMatch) {
                const oldOrder = oldMatch[1];
                const oldRateName = oldMatch[2];
                const newOrder = newMatch[1];
                const newRateName = newMatch[2];

                CSReporter.pass(`Automatic FFX Order change verified: ${oldRateName} moved from order ${oldOrder} to ${newOrder}`);
            } else {
                // Alternative format - just log the change
                CSReporter.info(`FFX Order change found: OldValue=${oldValue}, NewValue=${newValue}`);
            }
        }
    }


    
