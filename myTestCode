@CSBDDStepDef('I verify Details tab shows approved updates for existing zeal')
    async verifyDetailsTabShowsApprovedUpdatesForExistingZeal(): Promise<void> {
        CSReporter.info('Verifying Details tab shows approved updates for existing zeal');

        // Click Details tab first
        await this.zealDetailsPage.clickDetailsTab();
        await this.zealDetailsPage.waitForPageLoad();

        // Get all scattered mmte rows from Details tab
        const rowCount = await this.zealDetailsPage.getScatteredMmteRowCount();
        CSReporter.info(`Found ${rowCount} scattered mmte rows in Details tab`);

        const detailsMmtes: Array<{
            scatteredMmteName: string;
            disputedScatteredMmte: string;
            disputedStartDate: string;
            ffxOrder: string;
        }> = [];

        for (let i = 0; i < rowCount; i++) {
            const rowData = await this.zealDetailsPage.getScatteredMmteRowData(i);
            detailsMmtes.push(rowData);
            CSReporter.info(`Row ${i + 1}: ${rowData.scatteredMmteName}, Disputed: ${rowData.disputedScatteredMmte}, Date: ${rowData.disputedStartDate}, FFX: ${rowData.ffxOrder}`);
        }

        // Get update flags and data from context
        const updateScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('updateScatteredMmtesFlag');
        const updateDisputedScatteredMmteFlag = this.scenarioContext.getVariable<boolean>('updateDisputedScatteredMmteFlag');
        const updateDisputedStartDateFlag = this.scenarioContext.getVariable<boolean>('updateDisputedStartDateFlag');

        // Step 1: Verify Scattered Mmtes Update (old mmtes removed, new mmtes added)
        if (updateScatteredMmtesFlag) {
            const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
            if (scatteredMmtesToUpdate) {
                const pairs = scatteredMmtesToUpdate.split(';').filter(p => p.trim());
                for (const pair of pairs) {
                    const [oldMmte, newMmte] = pair.split('||').map(s => s.trim());

                    // Verify old mmte is NOT present
                    if (oldMmte) {
                        const oldMmteFound = detailsMmtes.some(r => r.scatteredMmteName === oldMmte);
                        if (oldMmteFound) {
                            throw new Error(`Details tab: Old scattered mmte ${oldMmte} should have been removed but is still present`);
                        }
                        CSReporter.pass(`Details tab: Old scattered mmte ${oldMmte} correctly removed`);
                    }

                    // Verify new mmte IS present
                    if (newMmte) {
                        const newMmteFound = detailsMmtes.some(r => r.scatteredMmteName === newMmte);
                        if (!newMmteFound) {
                            throw new Error(`Details tab: New scattered mmte ${newMmte} not found after approval`);
                        }
                        CSReporter.pass(`Details tab: New scattered mmte ${newMmte} correctly added`);
                    }
                }
            }
        }

        // Step 2: Verify Disputed Scattered Mmte Update
        if (updateDisputedScatteredMmteFlag) {
            const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
            if (disputedScatteredMmteToUpdate) {
                // Format: "PrimaryMmte||DisputedMmte;PrimaryMmte||DisputedMmte"
                const pairs = disputedScatteredMmteToUpdate.split(';').filter(p => p.trim());
                for (const pair of pairs) {
                    const [primaryMmte, disputedMmte] = pair.split('||').map(s => s.trim());
                    if (primaryMmte && disputedMmte) {
                        // Find the primary mmte row and check its disputed
                        const mmteRow = detailsMmtes.find(r => r.scatteredMmteName === primaryMmte);
                        if (mmteRow) {
                            if (mmteRow.disputedScatteredMmte === disputedMmte) {
                                CSReporter.pass(`Details tab: Disputed mmte for ${primaryMmte} correctly updated to ${disputedMmte}`);
                            } else {
                                throw new Error(`Details tab: Disputed mmte mismatch for ${primaryMmte}. Expected: ${disputedMmte}, Actual: ${mmteRow.disputedScatteredMmte}`);
                            }
                        } else {
                            CSReporter.info(`Details tab: Primary mmte ${primaryMmte} not found - may have been replaced`);
                        }
                    }
                }
            }
        }

        // Step 3: Verify Disputed Start Date Update
        if (updateDisputedStartDateFlag) {
            const disputedStartDateToUpdate = this.scenarioContext.getVariable<string>('disputedStartDateToUpdate') || '';
            const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';

            if (disputedStartDateToUpdate && disputedScatteredMmteToUpdate) {
                // Build map of DisputedMmte -> PrimaryMmte
                const disputedToPrimaryMap = new Map<string, string>();
                const fbPairs = disputedScatteredMmteToUpdate.split(';').filter(p => p.trim());
                for (const pair of fbPairs) {
                    const [primaryMmte, disputedMmte] = pair.split('||').map(s => s.trim());
                    if (primaryMmte && disputedMmte) {
                        disputedToPrimaryMap.set(disputedMmte, primaryMmte);
                    }
                }

                // Format: "DisputedMmte||Date;DisputedMmte||Date"
                const datePairs = disputedStartDateToUpdate.split(';').filter(p => p.trim());
                for (const pair of datePairs) {
                    const [disputedMmte, expectedDate] = pair.split('||').map(s => s.trim());
                    if (disputedMmte && expectedDate) {
                        // Get the primary mmte for this disputed
                        const primaryMmte = disputedToPrimaryMap.get(disputedMmte);
                        if (primaryMmte) {
                            const mmteRow = detailsMmtes.find(r => r.scatteredMmteName === primaryMmte);
                            if (mmteRow) {
                                if (mmteRow.disputedStartDate === expectedDate) {
                                    CSReporter.pass(`Details tab: Disputed start date for ${primaryMmte} correctly updated to ${expectedDate}`);
                                } else {
                                    throw new Error(`Details tab: Disputed start date mismatch for ${primaryMmte}. Expected: ${expectedDate}, Actual: ${mmteRow.disputedStartDate}`);
                                }
                            } else {
                                CSReporter.info(`Details tab: Primary mmte ${primaryMmte} not found - may have been replaced`);
                            }
                        }
                    }
                }
            }
        }

        // Step 4: Verify Sketchmark Flag (if updated)
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (sketchmarkFlagToUpdate) {
            const expectedValue = this.normalizeBooleanFlag(sketchmarkFlagToUpdate);
            const actualValue = await this.zealDetailsPage.isUseSketchmarkReplacementChecked();
            if (actualValue === expectedValue) {
                CSReporter.pass(`Details tab: Use Sketchmark Replacement correctly set to ${expectedValue}`);
            } else {
                throw new Error(`Details tab: Use Sketchmark Replacement mismatch. Expected: ${expectedValue}, Actual: ${actualValue}`);
            }
        }

        // Step 5: Verify FFX Inductor Type (if updated)
        const ffxFileInductorTypeToUpdate = this.scenarioContext.getVariable<string>('ffxFileInductorTypeToUpdate');
        if (ffxFileInductorTypeToUpdate) {
            const actualValue = await this.zealDetailsPage.getOutputTtcalcFileValue();
            if (actualValue === ffxFileInductorTypeToUpdate) {
                CSReporter.pass(`Details tab: Output Ttcalc File correctly set to ${ffxFileInductorTypeToUpdate}`);
            } else {
                throw new Error(`Details tab: Output Ttcalc File mismatch. Expected: ${ffxFileInductorTypeToUpdate}, Actual: ${actualValue}`);
            }
        }

        CSReporter.pass('Details tab verification completed for existing zeal update');
    }
