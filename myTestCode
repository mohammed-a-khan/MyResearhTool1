import { CSConfigurationManager } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporting';
import { CSAssert } from '@mdakhan.mak/cs-playwright-test-framework/assertions';
import { CSDBUtils } from '@mdakhan.mak/cs-playwright-test-framework/database';
import { CSDateTimeUtility } from '@mdakhan.mak/cs-playwright-test-framework/utilities';

/**
 * API Response Validator
 * TTTF-specific database validation logic for ffff details
 * Uses CS Playwright Framework utilities for database operations and assertions
 *
 * Updated for NEW API Response Structure (November 2025):
 * - Ffff data moved from flat fields to nested `ffffs` array
 * - Each ffffDetail now contains: ffffRrrr, inputDate, ffffs[], systemError, statusMessages
 * - ffffs[] can contain multiple ffff objects (for composite ffffs like MMMM)
 * - Each ffff object contains: ffff, cumulativeDate, insertedDate, updateDate, mutativeDate
 */
export class ApiResponseValidator {
    private static instance: ApiResponseValidator;
    private config = CSConfigurationManager.getInstance();
    private assert = CSAssert.getInstance();

    private constructor() {}

    public static getInstance(): ApiResponseValidator {
        if (!ApiResponseValidator.instance) {
            ApiResponseValidator.instance = new ApiResponseValidator();
        }
        return ApiResponseValidator.instance;
    }

    /**
     * Get all expected ffff data from database for a given ffff rrrr and input date
     * Returns all matching records (for composite ffffs that may have multiple entries)
     *
     * NEW STRUCTURE (November 2025): This is the ONLY method to use for DB queries.
     * Multi-ffff rrrrs like MMMM can have multiple records with different cumulativeDates.
     */
    public async getAllExpectedFfffDataFromDB(ffffRrrr: string, inputDate: string): Promise<any[]> {
        try {
            const queryKey = 'DB_QUERY_GET_EXTERNAL_DAILY_FFFF';
            const query = this.config.get(queryKey) as string;

            if (!query) {
                throw new Error(`Query not found: ${queryKey}`);
            }

            const result = await CSDBUtils.executeQuery('TTTF_ORACLE', query, [ffffRrrr, inputDate]);

            if (result.rowCount === 0) {
                CSReporter.info(`No database records found for ${ffffRrrr} on ${inputDate}`);
                return [];
            }

            CSReporter.info(`Found ${result.rowCount} database record(s) for ${ffffRrrr}`);
            return result.rows;
        } catch (error) {
            CSReporter.fail(`Failed to get ffff data from database: ${error}`);
            throw error;
        }
    }

    /**
     * Validate no-data scenario (ffff not available)
     * NEW STRUCTURE: Check that ffffs[] is empty instead of checking individual null fields
     */
    public async validateNoDataScenario(ffffDetail: any): Promise<void> {
        const ffffRrrr = ffffDetail.ffffRrrr;
        CSReporter.info(`Validating no-data scenario for ${ffffRrrr}`);

        // NEW STRUCTURE: Validate ffffs array is empty
        if (!ffffDetail.ffffs) {
            throw new Error(`ffffs array should be present for ${ffffRrrr}`);
        }

        await this.assert.assertEqual(
            ffffDetail.ffffs.length,
            0,
            `ffffs array should be empty for ${ffffRrrr} when no data available`
        );

        CSReporter.pass(`✓ ffffs array is empty for ${ffffRrrr}`);

        // Validate systemError
        if (!ffffDetail.systemError) {
            throw new Error(`systemError should be present for ${ffffRrrr} when ffff is not available`);
        }

        await this.assert.assertEqual(
            ffffDetail.systemError.rrrr,
            '204',
            `systemError.rrrr should be "204" for ${ffffRrrr}`
        );

        await this.assert.assertEqual(
            ffffDetail.systemError.subRrrr,
            '5003',
            `systemError.subRrrr should be "5003" for ${ffffRrrr}`
        );

        await this.assert.assertEqual(
            ffffDetail.systemError.message,
            'No Content',
            `systemError.message should be "No Content" for ${ffffRrrr}`
        );

        await this.assert.assertEqual(
            ffffDetail.systemError.cause,
            'Ffff not available for the given input date. Please contact TTTF Team.',
            `systemError.cause validation for ${ffffRrrr}`
        );

        if (ffffDetail.systemError.diagnostics && ffffDetail.systemError.diagnostics['5003']) {
            await this.assert.assertEqual(
                ffffDetail.systemError.diagnostics['5003'],
                'Ffff not found for the given rrrr and input date.',
                `systemError.diagnostics["5003"] validation for ${ffffRrrr}`
            );
        }

        // Validate statusMessages is null
        await this.assert.assertEqual(
            ffffDetail.statusMessages,
            null,
            `statusMessages should be null for ${ffffRrrr}`
        );

        CSReporter.pass(`No-data scenario validated for ${ffffRrrr}`);
    }

    /**
     * Validate success scenario (ffff data available)
     * NEW STRUCTURE (November 2025): Validates ALL ffffs in ffffs[] array against ALL database records
     *
     * @param ffffDetail - The ffff detail from API response containing ffffs[] array
     * @param dbDataArray - Array of ALL database records for this ffffRrrr (can be 1 or many)
     *
     * Works for both:
     * - Single-ffff rrrrs (1 ffff in response, 1 DB record)
     * - Multi-ffff rrrrs like MMMM (N ffffs in response, N DB records)
     */
    public async validateSuccessScenario(ffffDetail: any, dbDataArray: any[]): Promise<void> {
        const ffffRrrr = ffffDetail.ffffRrrr;
        CSReporter.info(`Validating success scenario for ${ffffRrrr}`);

        // NEW STRUCTURE: Get all ffffs from ffffs array
        if (!ffffDetail.ffffs || !Array.isArray(ffffDetail.ffffs)) {
            throw new Error(`ffffs array should be present for ${ffffRrrr}`);
        }

        const responseFfffs = ffffDetail.ffffs;
        CSReporter.info(`Response contains ${responseFfffs.length} ffff(s), Database has ${dbDataArray.length} record(s)`);

        // Validate count matches
        await this.assert.assertEqual(
            responseFfffs.length,
            dbDataArray.length,
            `Number of ffffs should match database records for ${ffffRrrr}`
        );

        // Validate each ffff against corresponding database record
        // Match by cumulativeDate since ffffs can be in different order
        for (let i = 0; i < responseFfffs.length; i++) {
            const ffffObj = responseFfffs[i];

            // Find matching database record by cumulativeDate
            const matchingDbRecord = this.findMatchingDbRecord(ffffObj, dbDataArray);

            if (!matchingDbRecord) {
                throw new Error(
                    `No matching database record found for ffff at index ${i} with cumulativeDate ${ffffObj.cumulativeDate}\n` +
                    `  Available DB cumulativeDates: ${dbDataArray.map(r => r.CUMULATIVE_DT).join(', ')}`
                );
            }

            CSReporter.info(`Validating ffff ${i + 1}/${responseFfffs.length}: cumulativeDate=${ffffObj.cumulativeDate}`);

            // Validate ffff value with precision tolerance
            const dbFfff = parseFloat(matchingDbRecord.FFFF);
            const responseFfff = parseFloat(ffffObj.ffff);
            const difference = Math.abs(dbFfff - responseFfff);

            if (difference >= 0.0001) {
                throw new Error(`Ffff mismatch for ${ffffRrrr} at index ${i}: Expected ${dbFfff}, got ${responseFfff}`);
            }
            CSReporter.pass(`  ✓ Ffff value validated: ${responseFfff}`);

            // Validate dates (comparing date portions only, ignoring time)
            await this.validateDateField(ffffObj.insertedDate, matchingDbRecord.INSERTED_DT, 'insertedDate', `${ffffRrrr}[${i}]`);
            await this.validateDateField(ffffObj.cumulativeDate, matchingDbRecord.CUMULATIVE_DT, 'cumulativeDate', `${ffffRrrr}[${i}]`);
            await this.validateDateField(ffffObj.updateDate, matchingDbRecord.UPDATED_DT, 'updateDate', `${ffffRrrr}[${i}]`);
            await this.validateDateField(ffffObj.mutativeDate, matchingDbRecord.MUTATIVE_DT, 'mutativeDate', `${ffffRrrr}[${i}]`);

            CSReporter.pass(`  ✓ Ffff ${i + 1} validated for ${ffffRrrr}`);
        }

        // Validate systemError is null (at ffffDetail level)
        await this.assert.assertEqual(
            ffffDetail.systemError,
            null,
            `systemError should be null for ${ffffRrrr}`
        );

        // Validate statusMessages (at ffffDetail level)
        if (!ffffDetail.statusMessages) {
            throw new Error(`statusMessages should be present for ${ffffRrrr}`);
        }

        await this.assert.assertEqual(
            ffffDetail.statusMessages.type,
            null,
            `statusMessages.type should be null for ${ffffRrrr}`
        );

        await this.assert.assertEqual(
            ffffDetail.statusMessages.rrrr,
            '200',
            `statusMessages.rrrr should be "200" for ${ffffRrrr}`
        );

        await this.assert.assertEqual(
            ffffDetail.statusMessages.message,
            'Success',
            `statusMessages.message should be "Success" for ${ffffRrrr}`
        );

        // Validate fields array is empty
        if (ffffDetail.statusMessages.fields && Array.isArray(ffffDetail.statusMessages.fields)) {
            await this.assert.assertEqual(
                ffffDetail.statusMessages.fields.length,
                0,
                `statusMessages.fields should be empty array for ${ffffRrrr}`
            );
        }

        CSReporter.pass(`Success scenario validated for ${ffffRrrr} (${responseFfffs.length} ffff(s))`);
    }

    /**
     * Helper: Find matching database record by cumulativeDate
     * Compares date portions only, ignoring time components
     * Uses Americas timezone to ensure consistent date comparison regardless of system timezone
     */
    private findMatchingDbRecord(ffffObj: any, dbDataArray: any[]): any | null {
        const responseCumulativeDate = new Date(ffffObj.cumulativeDate);
        // Get date string in Americas timezone for consistent comparison
        const responseDateStr = CSDateTimeUtility.toDateStringInTimezone(responseCumulativeDate);

        for (const dbRecord of dbDataArray) {
            const dbCumulativeDate = new Date(dbRecord.CUMULATIVE_DT);
            const dbDateStr = CSDateTimeUtility.toDateStringInTimezone(dbCumulativeDate);

            // Compare date strings in Americas timezone
            if (responseDateStr === dbDateStr) {
                return dbRecord;
            }
        }

        return null;
    }

    /**
     * Validate date field (compare date portions only)
     * Uses Americas timezone to ensure consistent date comparison regardless of system timezone
     */
    public async validateDateField(
        responseDate: string,
        dbDate: any,
        fieldName: string,
        ffffRrrr: string
    ): Promise<void> {
        try {
            CSReporter.info(`  Validating ${fieldName} for ${ffffRrrr}:`);
            CSReporter.info(`    Response date: ${responseDate}`);
            CSReporter.info(`    Database date: ${dbDate}`);

            // Parse both dates
            const responseDateObj = new Date(responseDate);
            const dbDateObj = new Date(dbDate);

            // Use Americas timezone-aware formatting to get consistent date strings
            // This ensures dates are compared in Americas timezone regardless of system timezone
            const responseDateStr = CSDateTimeUtility.toDateStringInTimezone(responseDateObj);
            const dbDateStr = CSDateTimeUtility.toDateStringInTimezone(dbDateObj);

            CSReporter.info(`    Parsed response date (Americas TZ): ${responseDateStr}`);
            CSReporter.info(`    Parsed database date (Americas TZ): ${dbDateStr}`);

            await this.assert.assertEqual(
                responseDateStr,
                dbDateStr,
                `${fieldName} should match database for ${ffffRrrr}`
            );

            CSReporter.pass(`  ✓ ${fieldName} validated for ${ffffRrrr}`);
        } catch (error) {
            CSReporter.fail(`Date validation failed for ${fieldName} of ${ffffRrrr}: ${error}`);
            throw error;
        }
    }

    /**
     * Helper: Check if ffffDetail has valid ffffs (non-empty ffffs array)
     * Use this to determine if ffffs[] array contains data before validation
     */
    public hasValidFfffs(ffffDetail: any): boolean {
        return ffffDetail.ffffs &&
               Array.isArray(ffffDetail.ffffs) &&
               ffffDetail.ffffs.length > 0;
    }

    /**
     * Helper: Get all ffffs from ffffDetail
     * Returns empty array if no ffffs available
     */
    public getAllFfffs(ffffDetail: any): any[] {
        if (this.hasValidFfffs(ffffDetail)) {
            return ffffDetail.ffffs;
        }
        return [];
    }

    /**
     * Helper: Get ffff count from ffffDetail
     */
    public getFfffCount(ffffDetail: any): number {
        if (this.hasValidFfffs(ffffDetail)) {
            return ffffDetail.ffffs.length;
        }
        return 0;
    }
}
