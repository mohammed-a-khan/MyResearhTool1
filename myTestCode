public async sortColumnDescending(columnName: string): Promise<void> {
        CSReporter.info(`Sorting column ${columnName} in descending order`);

        // Step 1: Check if column is already sorted descending
        const descendingSortElement = CSElementFactory.createByXPath(
            `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::th[1][@aria-sort='descending']`,
            `${columnName} column sorted descending`,
            this.page
        );

        const isAlreadyDescending = await descendingSortElement.isVisibleWithTimeout(3000);

        if (!isAlreadyDescending) {
            CSReporter.info(`${columnName} is not sorted descending, clicking to sort`);

            // Step 2: Click on the column header button
            const columnButton = CSElementFactory.createByXPath(
                `//table[@class='sssss-table']//thead//span[text()='${columnName}']/ancestor::button[1]`,
                `${columnName} column header button`,
                this.page
            );
            await columnButton.waitForVisible(10000);
            await columnButton.clickWithTimeout(10000);
            CSReporter.info(`Clicked ${columnName} column header`);

            // Wait for sort to apply
            await this.page.waitForTimeout(500);

            // Step 3: Check if now descending
            const isDescendingAfterFirstClick = await descendingSortElement.isVisibleWithTimeout(3000);

            if (!isDescendingAfterFirstClick) {
                CSReporter.info(`${columnName} is not descending after first click, clicking again`);

                // Click again to get descending
                await columnButton.clickWithTimeout(10000);
                await this.page.waitForTimeout(500);

                // Verify descending after second click
                const isDescendingAfterSecondClick = await descendingSortElement.isVisibleWithTimeout(5000);

                if (!isDescendingAfterSecondClick) {
                    throw new Error(`Failed to sort ${columnName} in descending order after two clicks. Database results are fetched in descending order, UI must match.`);
                }
            }

            CSReporter.pass(`${columnName} column sorted descending successfully`);
        } else {
            CSReporter.info(`${columnName} is already sorted descending`);
        }

        // Step 4: Verify actual data is in descending order by extracting Termination Date values
        await this.verifyColumnDataInDescendingOrder(columnName);
    }

    /**
     * Verifies that the column data in the UI is actually sorted in descending order
     * by extracting values from visible rows and comparing them
     */
    private async verifyColumnDataInDescendingOrder(columnName: string): Promise<void> {
        CSReporter.info(`Verifying ${columnName} data is in descending order`);

        const rowCount = await this.getTableRowCount();
        if (rowCount === 0) {
            CSReporter.warn('No rows in table to verify sort order');
            return;
        }

        // Get column index for the specified column
        const columnIndex = this.getColumnIndex(columnName);
        if (columnIndex === 0) {
            CSReporter.warn(`Unknown column: ${columnName}, skipping data verification`);
            return;
        }

        // Extract values from visible rows (check first 10 rows or all if less)
        const rowsToCheck = Math.min(rowCount, 10);
        const values: string[] = [];

        for (let row = 1; row <= rowsToCheck; row++) {
            const cellElement = CSElementFactory.createByXPath(
                `//table[@class='sssss-table']//tbody/tr[${row}]/td[${columnIndex}]`,
                `Row ${row} ${columnName} cell`,
                this.page
            );
            const cellValue = await cellElement.textContentWithTimeout(5000) || '';
            values.push(cellValue.trim());
        }

        CSReporter.info(`Extracted ${values.length} ${columnName} values: ${values.slice(0, 5).join(', ')}${values.length > 5 ? '...' : ''}`);

        // Verify descending order for date values
        if (columnName === 'Termination Date') {
            for (let i = 0; i < values.length - 1; i++) {
                const currentDate = this.parseDate(values[i]);
                const nextDate = this.parseDate(values[i + 1]);

                if (currentDate && nextDate && currentDate < nextDate) {
                    throw new Error(`${columnName} is not in descending order. Row ${i + 1} (${values[i]}) should be >= Row ${i + 2} (${values[i + 1]})`);
                }
            }
            CSReporter.pass(`${columnName} data verified in descending order`);
        } else {
            // For non-date columns, do string comparison
            for (let i = 0; i < values.length - 1; i++) {
                if (values[i].localeCompare(values[i + 1]) < 0) {
                    CSReporter.warn(`${columnName} may not be in descending order at row ${i + 1}`);
                }
            }
            CSReporter.info(`${columnName} data order check completed`);
        }
    }

    /**
     * Parse date string to Date object for comparison
     * Supports formats: MM/DD/YYYY, YYYY-MM-DD, etc.
     */
    private parseDate(dateStr: string): Date | null {
        if (!dateStr) return null;

        // Try MM/DD/YYYY format
        const usMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
        if (usMatch) {
            return new Date(parseInt(usMatch[3]), parseInt(usMatch[1]) - 1, parseInt(usMatch[2]));
        }

        // Try YYYY-MM-DD format
        const isoMatch = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (isoMatch) {
            return new Date(parseInt(isoMatch[1]), parseInt(isoMatch[2]) - 1, parseInt(isoMatch[3]));
        }

        // Try to parse as generic date
        const parsed = new Date(dateStr);
        return isNaN(parsed.getTime()) ? null : parsed;
    }
