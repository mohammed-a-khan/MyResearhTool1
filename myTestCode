# ==============================================================================
# EXISTING ZEAL UPDATE - TEST DATA RETRIEVAL QUERIES (SCENARIO_09B)
# ==============================================================================

# Get existing zeal with scattered mmtes (returns MULTIPLE ROWS - one per scattered mmte)
# Per SCENARIO_09B requirement: Returns all rows with zeal info + one scattered mmte per row
# Uses subquery to find a zeal with COUNT(*) > 1 scattered mmtes, ordered randomly
DB_QUERY_GET_EXISTING_ZEAL_WITH_SCATTERED_MMTES=SELECT cdsv.type_value, cdsv.zeal_id, cdsv.zeal_key, cdsv.zeal_name, cdsv.zzzt_seggregation, cdsv.premisis_description, cdsv.inductor_group, cdsv.acct_manager, cdsv.acct_mgr_email, cdsv.calc_shool_name, dsd.sketchmark_replacement_flag, idp.inductor_code, rr1.scattered_mmte_name AS scattered_mmte_name, rr2.scattered_mmte_name AS disputed_scattered_mmte_name, dsrd.disputed_date, dsrd.ffx_order FROM ttttinfo.tttf_zeals_premisis_view cdsv INNER JOIN tttfapp.zeal_data dd ON cdsv.zeal_id = dd.zeal_id AND cdsv.type_value = 'ZEAL' INNER JOIN tttfapp.zealpremisis_data dsd ON dsd.zealpremisis_data_id = dd.zealpremisis_data_id LEFT JOIN tttfapp.FFX_INDUCTOR idp ON idp.ffx_inductor_id = dsd.ffx_inductor_id INNER JOIN tttfapp.zealpremisis_mmte_data dsrd ON dsd.zealpremisis_data_id = dsrd.zealpremisis_data_id INNER JOIN tttfapp.scattered_mmte rr1 ON dsrd.scattered_mmte_id = rr1.scattered_mmte_id LEFT JOIN tttfapp.scattered_mmte rr2 ON dsrd.disputed_scattered_mmte_id = rr2.scattered_mmte_id WHERE cdsv.zeal_id = (SELECT MIN(zeal_id) FROM (SELECT cdsv2.zeal_id FROM ttttinfo.tttf_zeals_premisis_view cdsv2 INNER JOIN tttfapp.zeal_data dd2 ON cdsv2.zeal_id = dd2.zeal_id AND cdsv2.type_value = 'ZEAL' INNER JOIN tttfapp.zealpremisis_data dsd2 ON dsd2.zealpremisis_data_id = dd2.zealpremisis_data_id INNER JOIN tttfapp.zealpremisis_mmte_data dsrd2 ON dsd2.zealpremisis_data_id = dsrd2.zealpremisis_data_id GROUP BY cdsv2.zeal_id HAVING COUNT(*) > 1)) ORDER BY dsrd.ffx_order ASC

# Get existing zeal by Zeal ID (returns MULTIPLE ROWS - one per scattered mmte)
# Used when user provides ZealId in test data JSON
DB_QUERY_GET_EXISTING_ZEAL_BY_ID=SELECT cdsv.type_value, cdsv.zeal_id, cdsv.zeal_key, cdsv.zeal_name, cdsv.zzzt_seggregation, cdsv.premisis_description, cdsv.inductor_group, cdsv.acct_manager, cdsv.acct_mgr_email, cdsv.calc_shool_name, dsd.sketchmark_replacement_flag, idp.inductor_code, rr1.scattered_mmte_name AS scattered_mmte_name, rr2.scattered_mmte_name AS disputed_scattered_mmte_name, dsrd.disputed_date, dsrd.ffx_order FROM ttttinfo.tttf_zeals_premisis_view cdsv INNER JOIN tttfapp.zeal_data dd ON cdsv.zeal_id = dd.zeal_id AND cdsv.type_value = 'ZEAL' INNER JOIN tttfapp.zealpremisis_data dsd ON dsd.zealpremisis_data_id = dd.zealpremisis_data_id LEFT JOIN tttfapp.FFX_INDUCTOR idp ON idp.ffx_inductor_id = dsd.ffx_inductor_id INNER JOIN tttfapp.zealpremisis_mmte_data dsrd ON dsd.zealpremisis_data_id = dsrd.zealpremisis_data_id INNER JOIN tttfapp.scattered_mmte rr1 ON dsrd.scattered_mmte_id = rr1.scattered_mmte_id LEFT JOIN tttfapp.scattered_mmte rr2 ON dsrd.disputed_scattered_mmte_id = rr2.scattered_mmte_id WHERE cdsv.zeal_id = ? ORDER BY dsrd.ffx_order ASC

# Get zeal by Zeal Name (used when only ZealName is provided)
DB_QUERY_GET_ZEAL_BY_NAME=SELECT zeal_id, zeal_key, zeal_name FROM ttttinfo.tttf_zeals_premisis_view WHERE zeal_name = ? AND type_value = 'ZEAL'

# Get different FFX Inductor Type (excludes current inductor code)
DB_QUERY_GET_DIFFERENT_FFX_INDUCTOR_TYPE=SELECT inductor_code FROM tttfapp.FFX_INDUCTOR WHERE inductor_code NOT IN (?) AND ROWNUM = 1


# ==============================================================================
# DYNAMIC CTE QUERIES FOR REPLACEMENT/DISPUTED MMTES (SCENARIO_09B)
# Per TTTF_Update_Zeal_Scenario.txt requirement - Uses WITH exclusions AS (...) pattern
# The {{EXCLUSIONS_CTE}} placeholder will be replaced at runtime with actual exclusion values
# Format: SELECT 'MMTE1' as excluded_name FROM DUAL UNION ALL SELECT 'MMTE2' FROM DUAL ...
# ==============================================================================

# Get replacement scattered mmtes using dynamic CTE exclusions
# Returns one mmte per methodology type (SPORT_MMTE_LOOKUP, TTCALC_PERIOD, MANUAL) excluding already associated mmtes
DB_QUERY_GET_REPLACEMENT_MMTES_DYNAMIC=WITH exclusions AS ({{EXCLUSIONS_CTE}}), ranked_data AS (SELECT scattered_mmte_name, methodology_type, ROW_NUMBER() OVER (PARTITION BY methodology_type ORDER BY scattered_mmte_name DESC) as rn_per_type FROM tttfapp.scattered_mmte rr WHERE methodology_type IN ('SPORT_MMTE_LOOKUP', 'TTCALC_PERIOD', 'MANUAL') AND cumulative_mmte_id IN (SELECT cumulative_mmte_id FROM tttfapp.cumulative_mmte WHERE active_flag = 'Y') AND scattered_mmte_name NOT IN (SELECT excluded_name FROM exclusions)) SELECT scattered_mmte_name, methodology_type FROM (SELECT scattered_mmte_name, methodology_type, rn_per_type, ROW_NUMBER() OVER (ORDER BY rn_per_type, methodology_type) as final_rn FROM ranked_data WHERE rn_per_type <= CEIL((SELECT COUNT(*) FROM exclusions) / 3.0)) WHERE final_rn <= (SELECT COUNT(*) FROM exclusions)

# Get disputed scattered mmtes using dynamic CTE exclusions (same structure as replacement mmtes)
# Used to get disputed mmtes that are different from the new/replacement mmtes
DB_QUERY_GET_DISPUTED_MMTES_DYNAMIC=WITH exclusions AS ({{EXCLUSIONS_CTE}}), ranked_data AS (SELECT scattered_mmte_name, methodology_type, ROW_NUMBER() OVER (PARTITION BY methodology_type ORDER BY scattered_mmte_name DESC) as rn_per_type FROM tttfapp.scattered_mmte rr WHERE methodology_type IN ('SPORT_MMTE_LOOKUP', 'TTCALC_PERIOD', 'MANUAL') AND cumulative_mmte_id IN (SELECT cumulative_mmte_id FROM tttfapp.cumulative_mmte WHERE active_flag = 'Y') AND scattered_mmte_name NOT IN (SELECT excluded_name FROM exclusions)) SELECT scattered_mmte_name, methodology_type FROM (SELECT scattered_mmte_name, methodology_type, rn_per_type, ROW_NUMBER() OVER (ORDER BY rn_per_type, methodology_type) as final_rn FROM ranked_data WHERE rn_per_type <= CEIL((SELECT COUNT(*) FROM exclusions) / 3.0)) WHERE final_rn <= (SELECT COUNT(*) FROM exclusions)


helper
--------------------------------------------------------------------------------------------------------------------------


/**
 * Interface for existing zeal data row (one row per scattered mmte)
 * Used for SCENARIO_09B: Existing Zeal Update
 */
export interface ExistingZealRow {
    typeValue: string;
    zealId: string;
    zealKey: string;
    zealName: string;
    zzztSeggregation: string;
    premisisDescription: string;
    inductorGroup: string;
    acctManager: string;
    acctMgrEmail: string;
    calcShoolName: string;
    sketchmarkReplacementFlag: string;
    inductorCode: string;
    scatteredMmteName: string;
    disputedScatteredMmteName: string;
    disputedDate: string;
    ffxOrder: number;
}

// ===================================================================
    // EXISTING ZEAL UPDATE METHODS (SCENARIO_09B)
    // Per TTTF_Update_Zeal_Scenario.txt requirement
    // ===================================================================

    /**
     * Get an existing zeal with scattered mmtes - returns ARRAY OF ROWS
     * Each row contains zeal info + one scattered mmte per row
     * Query: DB_QUERY_GET_EXISTING_ZEAL_WITH_SCATTERED_MMTES
     */
    public static async getExistingZealWithScatteredMmtes(): Promise<ExistingZealRow[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EXISTING_ZEAL_WITH_SCATTERED_MMTES'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No existing zeal with scattered mmtes found');
            return [];
        }

        const rows = result.rows.map((row: any) => ({
            typeValue: row.type_value || 'ZEAL',
            zealId: String(row.zeal_id),
            zealKey: row.zeal_key || '',
            zealName: row.zeal_name || '',
            zzztSeggregation: row.zzzt_seggregation || '',
            premisisDescription: row.premisis_description || '',
            inductorGroup: row.inductor_group || '',
            acctManager: row.acct_manager || '',
            acctMgrEmail: row.acct_mgr_email || '',
            calcShoolName: row.calc_shool_name || '',
            sketchmarkReplacementFlag: row.sketchmark_replacement_flag || 'N',
            inductorCode: row.inductor_code || '',
            scatteredMmteName: row.scattered_mmte_name || '',
            disputedScatteredMmteName: row.disputed_scattered_mmte_name || '',
            disputedDate: row.disputed_date || '',
            ffxOrder: row.ffx_order || 0
        }));

        CSReporter.debug(`Found existing zeal: ${rows[0].zealId} with ${rows.length} scattered mmtes`);
        return rows;
    }

    /**
     * Get existing zeal by Zeal ID - returns ARRAY OF ROWS
     * Query: DB_QUERY_GET_EXISTING_ZEAL_BY_ID
     */
    public static async getExistingZealById(zealId: string): Promise<ExistingZealRow[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EXISTING_ZEAL_BY_ID',
            [zealId]
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn(`No existing zeal found for ID: ${zealId}`);
            return [];
        }

        return result.rows.map((row: any) => ({
            typeValue: row.type_value || 'ZEAL',
            zealId: String(row.zeal_id),
            zealKey: row.zeal_key || '',
            zealName: row.zeal_name || '',
            zzztSeggregation: row.zzzt_seggregation || '',
            premisisDescription: row.premisis_description || '',
            inductorGroup: row.inductor_group || '',
            acctManager: row.acct_manager || '',
            acctMgrEmail: row.acct_mgr_email || '',
            calcShoolName: row.calc_shool_name || '',
            sketchmarkReplacementFlag: row.sketchmark_replacement_flag || 'N',
            inductorCode: row.inductor_code || '',
            scatteredMmteName: row.scattered_mmte_name || '',
            disputedScatteredMmteName: row.disputed_scattered_mmte_name || '',
            disputedDate: row.disputed_date || '',
            ffxOrder: row.ffx_order || 0
        }));
    }

    /**
     * Get zeal by Zeal Name - returns basic zeal info
     * Query: DB_QUERY_GET_ZEAL_BY_NAME
     */
    public static async getZealByName(zealName: string): Promise<{ zealId: string; zealKey: string; zealName: string } | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEAL_BY_NAME',
            [zealName]
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn(`No zeal found with name: ${zealName}`);
            return null;
        }

        return {
            zealId: String(result.rows[0].zeal_id),
            zealKey: result.rows[0].zeal_key || '',
            zealName: result.rows[0].zeal_name || ''
        };
    }

    /**
     * Build exclusions CTE string for dynamic queries
     * Format: SELECT 'MMTE1' as excluded_name FROM DUAL UNION ALL SELECT 'MMTE2' FROM DUAL ...
     * @param mmteNames - Array of scattered mmte names to exclude
     */
    private static buildExclusionsCTE(mmteNames: string[]): string {
        return mmteNames
            .map((name, index) => index === 0
                ? `SELECT '${name}' as excluded_name FROM DUAL`
                : `SELECT '${name}' FROM DUAL`)
            .join(' UNION ALL ');
    }

    /**
     * Get replacement scattered mmtes using dynamic CTE query from env file
     * Query: DB_QUERY_GET_REPLACEMENT_MMTES_DYNAMIC (with {{EXCLUSIONS_CTE}} placeholder)
     * Per requirement: Uses CTE WITH exclusions AS (...) pattern
     * @param existingMmteNames - Array of scattered mmte names to exclude
     */
    public static async getReplacementScatteredMmtesDynamic(
        existingMmteNames: string[]
    ): Promise<Array<{ scatteredMmteName: string; methodologyType: string }>> {
        if (!existingMmteNames || existingMmteNames.length === 0) {
            CSReporter.warn('No existing mmte names provided for exclusion');
            return [];
        }

        // Build exclusions CTE and get query template from env
        const exclusionsCTE = this.buildExclusionsCTE(existingMmteNames);
        const queryTemplate = process.env['DB_QUERY_GET_REPLACEMENT_MMTES_DYNAMIC'] || '';

        if (!queryTemplate) {
            throw new Error('Query template DB_QUERY_GET_REPLACEMENT_MMTES_DYNAMIC not found in env');
        }

        // Replace placeholder with actual exclusions
        const dynamicQuery = queryTemplate.replace('{{EXCLUSIONS_CTE}}', exclusionsCTE);

        CSReporter.debug(`Executing dynamic replacement mmtes query with ${existingMmteNames.length} exclusions`);

        const result = await CSDBUtils.executeQuery(this.DB_ALIAS, dynamicQuery);

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No replacement scattered mmtes available');
            return [];
        }

        const mmtes = result.rows.map((row: any) => ({
            scatteredMmteName: row.scattered_mmte_name || row.SCATTERED_MMTE_NAME,
            methodologyType: row.methodology_type || row.METHODOLOGY_TYPE
        }));

        CSReporter.debug(`Found ${mmtes.length} replacement scattered mmtes`);
        return mmtes;
    }

    /**
     * Get disputed scattered mmtes using dynamic CTE query from env file
     * Query: DB_QUERY_GET_DISPUTED_MMTES_DYNAMIC (with {{EXCLUSIONS_CTE}} placeholder)
     * Per requirement: Uses CTE WITH exclusions AS (...) pattern
     * @param excludeMmteNames - Array of scattered mmte names to exclude
     */
    public static async getDisputedScatteredMmtesDynamic(
        excludeMmteNames: string[]
    ): Promise<Array<{ scatteredMmteName: string; methodologyType: string }>> {
        if (!excludeMmteNames || excludeMmteNames.length === 0) {
            CSReporter.warn('No mmte names provided for exclusion');
            return [];
        }

        // Build exclusions CTE and get query template from env
        const exclusionsCTE = this.buildExclusionsCTE(excludeMmteNames);
        const queryTemplate = process.env['DB_QUERY_GET_DISPUTED_MMTES_DYNAMIC'] || '';

        if (!queryTemplate) {
            throw new Error('Query template DB_QUERY_GET_DISPUTED_MMTES_DYNAMIC not found in env');
        }

        // Replace placeholder with actual exclusions
        const dynamicQuery = queryTemplate.replace('{{EXCLUSIONS_CTE}}', exclusionsCTE);

        CSReporter.debug(`Executing dynamic disputed mmtes query with ${excludeMmteNames.length} exclusions`);

        const result = await CSDBUtils.executeQuery(this.DB_ALIAS, dynamicQuery);

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No disputed scattered mmtes available');
            return [];
        }

        const mmtes = result.rows.map((row: any) => ({
            scatteredMmteName: row.scattered_mmte_name || row.SCATTERED_MMTE_NAME,
            methodologyType: row.methodology_type || row.METHODOLOGY_TYPE
        }));

        CSReporter.debug(`Found ${mmtes.length} disputed scattered mmtes`);
        return mmtes;
    }

    /**
     * Calculate disputed start date: current date minus 15 days
     * If it falls on weekend, get previous weekday
     * Returns date in MM/DD/YYYY format
     */
    public static calculateDisputedStartDate(): string {
        const today = new Date();
        const disputedDate = new Date(today);
        disputedDate.setDate(disputedDate.getDate() - 15);

        // If weekend, get previous weekday
        const dayOfWeek = disputedDate.getDay();
        if (dayOfWeek === 0) {
            disputedDate.setDate(disputedDate.getDate() - 2); // Sunday -> Friday
        } else if (dayOfWeek === 6) {
            disputedDate.setDate(disputedDate.getDate() - 1); // Saturday -> Friday
        }

        // Format as MM/DD/YYYY
        const month = String(disputedDate.getMonth() + 1).padStart(2, '0');
        const day = String(disputedDate.getDate()).padStart(2, '0');
        const year = disputedDate.getFullYear();

        return `${month}/${day}/${year}`;
    }

    /**
     * Get a different FFX Inductor Type than the current one
     * Query: DB_QUERY_GET_DIFFERENT_FFX_INDUCTOR_TYPE
     */
    public static async getDifferentFfxInductorType(currentInductorCode: string): Promise<string | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_DIFFERENT_FFX_INDUCTOR_TYPE',
            [currentInductorCode]
        );

        if (!result.rows || result.rows.length === 0) {
            return null;
        }

        return result.rows[0].inductor_code;
    }



    -----------------------------------------------------------------------------------------------------------------

    
    // ===================================================================
    // SCENARIO_09B: EXISTING ZEAL UPDATE - TEST DATA PREPARATION AND UPDATE STEPS
    // ===================================================================

    @CSBDDStepDef('I prepare test data for existing zeal update')
    async prepareTestDataForExistingZealUpdate(): Promise<void> {
        CSReporter.info('Preparing comprehensive test data for existing zeal update (SCENARIO_09B)');
        CSReporter.info('Per TTTF_Update_Zeal_Scenario.txt requirement');

        // Get current row test data from BDD context
        const currentRow = this.context.getVariable('currentRow') as any || {};
        CSReporter.debug(`Current row test data: ${JSON.stringify(currentRow)}`);

        // ===================================================================
        // STEP 1: Resolve Zeal Information and Get Main Test Data from DB
        // Per requirement: Check ZealKey, ZealId, ZealName in order
        // ===================================================================
        let zealId = currentRow.zealId || '';
        let zealKey = currentRow.zealKey || '';
        let zealName = currentRow.zealName || '';
        let mainTestDataFromDB: ExistingZealRow[] = [];

        // Case 1: No zeal info provided - use main query to get random zeal with >1 scattered mmtes
        if (!zealKey && !zealId && !zealName) {
            CSReporter.info('No zeal info in test data JSON, querying database for existing zeal with scattered mmtes...');
            mainTestDataFromDB = await TTTFDatabaseHelper.getExistingZealWithScatteredMmtes();

            if (mainTestDataFromDB.length === 0) {
                throw new Error('No existing zeal with scattered mmtes found in database');
            }

            // Get zeal info from first row (all rows have same zeal info)
            const firstRow = mainTestDataFromDB[0];
            zealId = firstRow.zealId;
            zealKey = firstRow.zealKey;
            zealName = firstRow.zealName;

            CSReporter.info(`Retrieved existing zeal from DB: ID=${zealId}, Key=${zealKey}, with ${mainTestDataFromDB.length} scattered mmtes`);
        }
        // Case 2: ZealId provided - get zeal data by ID
        else if (!zealKey && zealId) {
            CSReporter.info(`ZealId provided in JSON: ${zealId}, querying full zeal data...`);
            mainTestDataFromDB = await TTTFDatabaseHelper.getExistingZealById(zealId);

            if (mainTestDataFromDB.length === 0) {
                throw new Error(`No existing zeal found for ID: ${zealId}`);
            }

            // Get zealKey and zealName from result
            const firstRow = mainTestDataFromDB[0];
            zealKey = firstRow.zealKey;
            if (!zealName) {
                zealName = firstRow.zealName;
            }

            CSReporter.info(`Retrieved zeal by ID: Key=${zealKey}, Name=${zealName}, with ${mainTestDataFromDB.length} scattered mmtes`);
        }
        // Case 3: ZealName provided but no ZealId or ZealKey
        else if (!zealKey && !zealId && zealName) {
            CSReporter.info(`ZealName provided in JSON: ${zealName}, querying zeal info...`);
            const zealByName = await TTTFDatabaseHelper.getZealByName(zealName);

            if (!zealByName) {
                throw new Error(`No zeal found with name: ${zealName}`);
            }

            zealId = zealByName.zealId;
            zealKey = zealByName.zealKey;

            // Now get full data by zeal ID
            mainTestDataFromDB = await TTTFDatabaseHelper.getExistingZealById(zealId);
            CSReporter.info(`Retrieved zeal by name: ID=${zealId}, Key=${zealKey}, with ${mainTestDataFromDB.length} scattered mmtes`);
        }

        // Store the main result set in scenario context for future use
        this.scenarioContext.setVariable('mainTestDataFromDB', mainTestDataFromDB);

        // Store resolved zeal info
        this.scenarioContext.setVariable('zealId', zealId);
        this.scenarioContext.setVariable('zealKey', zealKey);
        this.scenarioContext.setVariable('zealName', zealName);

        // Store additional zeal details from first row
        if (mainTestDataFromDB.length > 0) {
            const firstRow = mainTestDataFromDB[0];
            this.scenarioContext.setVariable('inductorGroup', firstRow.inductorGroup);
            this.scenarioContext.setVariable('zzztSeggregation', firstRow.zzztSeggregation);
            this.scenarioContext.setVariable('premisisDescription', firstRow.premisisDescription);
            this.scenarioContext.setVariable('calcShoolName', firstRow.calcShoolName);
            this.scenarioContext.setVariable('acctManager', firstRow.acctManager);
            this.scenarioContext.setVariable('currentSketchmarkFlag', firstRow.sketchmarkReplacementFlag || 'N');
            this.scenarioContext.setVariable('currentInductorCode', firstRow.inductorCode || '');
        }

        // ===================================================================
        // STEP 2: Resolve SketchmarkFlagToUpdate
        // Per requirement: Toggle current value if not provided
        // ===================================================================
        let sketchmarkFlagToUpdate = currentRow.sketchmarkFlagToUpdate || '';
        if (sketchmarkFlagToUpdate) {
            // Normalize user-provided value: Yes/True -> Y, No/False -> N
            sketchmarkFlagToUpdate = this.normalizeYesNoFlag(sketchmarkFlagToUpdate);
        } else {
            // Auto-toggle: If current is Y, set to N; if N, set to Y
            const currentSketchmarkFlag = this.scenarioContext.getVariable<string>('currentSketchmarkFlag') || 'N';
            sketchmarkFlagToUpdate = currentSketchmarkFlag === 'Y' ? 'N' : 'Y';
            CSReporter.info(`Auto-toggling sketchmarkFlagToUpdate: current=${currentSketchmarkFlag}, new=${sketchmarkFlagToUpdate}`);
        }
        this.scenarioContext.setVariable('sketchmarkFlagToUpdate', sketchmarkFlagToUpdate);

        // ===================================================================
        // STEP 3: Resolve FFXFileInductorTypeToUpdate
        // Per requirement: Query for different inductor type if not provided
        // ===================================================================
        let ffxFileInductorTypeToUpdate = currentRow.ffxFileInductorTypeToUpdate || '';
        if (!ffxFileInductorTypeToUpdate) {
            const currentInductorCode = this.scenarioContext.getVariable<string>('currentInductorCode') || '';
            if (currentInductorCode) {
                const differentInductorCode = await TTTFDatabaseHelper.getDifferentFfxInductorType(currentInductorCode);
                if (differentInductorCode) {
                    ffxFileInductorTypeToUpdate = differentInductorCode;
                    CSReporter.info(`Auto-selected different FFX Inductor Type: ${ffxFileInductorTypeToUpdate} (current: ${currentInductorCode})`);
                }
            }
        }
        this.scenarioContext.setVariable('ffxFileInductorTypeToUpdate', ffxFileInductorTypeToUpdate);

        // ===================================================================
        // STEP 4: Resolve Update Flags
        // ===================================================================
        const updateScatteredMmtesFlag = this.isYesOrTrue(currentRow.updateScatteredMmtesFlag || 'false');
        const removeScatteredMmtesFlag = this.isYesOrTrue(currentRow.removeScatteredMmtesFlag || 'false');
        const updateDisputedScatteredMmteFlag = this.isYesOrTrue(currentRow.updateDisputedScatteredMmteFlag || 'false');
        const updateDisputedStartDateFlag = this.isYesOrTrue(currentRow.updateDisputedStartDateFlag || 'false');
        const ffxOrderUpdateFlag = this.isYesOrTrue(currentRow.ffxOrderUpdateFlag || 'false');

        this.scenarioContext.setVariable('updateScatteredMmtesFlag', updateScatteredMmtesFlag);
        this.scenarioContext.setVariable('removeScatteredMmtesFlag', removeScatteredMmtesFlag);
        this.scenarioContext.setVariable('updateDisputedScatteredMmteFlag', updateDisputedScatteredMmteFlag);
        this.scenarioContext.setVariable('updateDisputedStartDateFlag', updateDisputedStartDateFlag);
        this.scenarioContext.setVariable('ffxOrderUpdateFlag', ffxOrderUpdateFlag);

        // ===================================================================
        // STEP 5: Resolve ScatteredMmtesToUpdate
        // Per requirement: Uses dynamic CTE query with exclusions
        // Format: "OldMmte||NewMmte;OldMmte||NewMmte"
        // ===================================================================
        let scatteredMmtesToUpdate = currentRow.scatteredMmtesToUpdate || '';
        let scatteredMmtesNamesData: Array<{ scatteredMmteName: string; methodologyType: string }> = [];

        if (updateScatteredMmtesFlag && !scatteredMmtesToUpdate) {
            // Get existing scattered mmtes from mainTestDataFromDB, excluding any to be removed
            const mmtesToRemove = removeScatteredMmtesFlag
                ? (currentRow.scatteredMmtesToRemove || '').split(';').filter((r: string) => r.trim())
                : [];

            const existingMmteNames: string[] = [];
            for (const row of mainTestDataFromDB) {
                const mmteName = row.scatteredMmteName;
                if (mmteName && !mmtesToRemove.includes(mmteName)) {
                    existingMmteNames.push(mmteName);
                }
            }

            if (existingMmteNames.length > 0) {
                // Execute dynamic CTE query for replacement mmtes per requirement
                scatteredMmtesNamesData = await TTTFDatabaseHelper.getReplacementScatteredMmtesDynamic(existingMmteNames);

                // Build ScatteredMmtesToUpdate string: "OldMmte||NewMmte;..."
                const updatePairs: string[] = [];
                for (let i = 0; i < existingMmteNames.length && i < scatteredMmtesNamesData.length; i++) {
                    updatePairs.push(`${existingMmteNames[i]}||${scatteredMmtesNamesData[i].scatteredMmteName}`);
                }
                scatteredMmtesToUpdate = updatePairs.join(';');
                CSReporter.info(`Auto-genemmted scatteredMmtesToUpdate: ${scatteredMmtesToUpdate}`);
            }
        }
        this.scenarioContext.setVariable('scatteredMmtesToUpdate', scatteredMmtesToUpdate);
        this.scenarioContext.setVariable('scatteredMmtesNamesData', scatteredMmtesNamesData);

        // ===================================================================
        // STEP 6: Resolve ScatteredMmtesToRemove (Section B.5)
        // ===================================================================
        if (removeScatteredMmtesFlag) {
            const scatteredMmtesToRemove = currentRow.scatteredMmtesToRemove || '';
            this.scenarioContext.setVariable('scatteredMmtesToRemove', scatteredMmtesToRemove);
        }

        // ===================================================================
        // STEP 7: Resolve DisputedScatteredMmteToUpdate (Section B.6)
        // ===================================================================
        if (updateDisputedScatteredMmteFlag) {
            let disputedScatteredMmteToUpdate = currentRow.disputedScatteredMmteToUpdate || '';
            if (!disputedScatteredMmteToUpdate) {
                // Get new scattered mmtes (from scatteredMmtesToUpdate) and pair with disputed mmtes
                const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
                if (scatteredMmtesToUpdate) {
                    const newMmteNames: string[] = [];
                    scatteredMmtesToUpdate.split(';').forEach(pair => {
                        const [, newMmte] = pair.split('||');
                        if (newMmte) newMmteNames.push(newMmte.trim());
                    });

                    // Get disputed mmtes using dynamic CTE query per requirement
                    // The new scattered mmtes are excluded to get different disputed mmtes
                    const disputedMmtes = await TTTFDatabaseHelper.getDisputedScatteredMmtesDynamic(newMmteNames);
                    if (disputedMmtes.length > 0) {
                        const disputedPairs: string[] = [];
                        for (let i = 0; i < newMmteNames.length && i < disputedMmtes.length; i++) {
                            disputedPairs.push(`${newMmteNames[i]}||${disputedMmtes[i].scatteredMmteName}`);
                        }
                        disputedScatteredMmteToUpdate = disputedPairs.join(';');
                        CSReporter.info(`Auto-genemmted disputedScatteredMmteToUpdate: ${disputedScatteredMmteToUpdate}`);
                    }
                }
            }
            this.scenarioContext.setVariable('disputedScatteredMmteToUpdate', disputedScatteredMmteToUpdate);
        }

        // ===================================================================
        // STEP 8: Resolve DisputedStartDateToUpdate (Section B.7)
        // ===================================================================
        if (updateDisputedStartDateFlag && updateDisputedScatteredMmteFlag) {
            let disputedStartDateToUpdate = currentRow.disputedStartDateToUpdate || '';
            if (!disputedStartDateToUpdate) {
                // Auto-genemmte: Calculate date = Current Date - 15 days (exclude weekends)
                const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
                if (disputedScatteredMmteToUpdate) {
                    const disputedStartDate = TTTFDatabaseHelper.calculateDisputedStartDate();
                    const datePairs: string[] = [];

                    disputedScatteredMmteToUpdate.split(';').forEach(pair => {
                        const [, disputedMmte] = pair.split('||');
                        if (disputedMmte) {
                            datePairs.push(`${disputedMmte.trim()}||${disputedStartDate}`);
                        }
                    });
                    disputedStartDateToUpdate = datePairs.join(';');
                    CSReporter.info(`Auto-genemmted disputedStartDateToUpdate: ${disputedStartDateToUpdate}`);
                }
            }
            this.scenarioContext.setVariable('disputedStartDateToUpdate', disputedStartDateToUpdate);
        }

        // ===================================================================
        // STEP 9: FFXOrderToUpdate (Section B.8 - Must be user-provided)
        // ===================================================================
        if (ffxOrderUpdateFlag) {
            const ffxOrderToUpdate = currentRow.ffxOrderToUpdate || '';
            if (!ffxOrderToUpdate) {
                CSReporter.warn('FFXOrderToUpdate must be user-provided. Skipping FFX order update.');
                this.scenarioContext.setVariable('ffxOrderUpdateFlag', false);
            } else {
                this.scenarioContext.setVariable('ffxOrderToUpdate', ffxOrderToUpdate);
            }
        }

        CSReporter.pass('Test data preparation for existing zeal update completed successfully');
    }

    /**
     * Normalize Yes/No flag to Y/N format
     */
    private normalizeYesNoFlag(value: string): string {
        const lowerValue = value.toLowerCase();
        if (lowerValue === 'yes' || lowerValue === 'true' || lowerValue === 'y') {
            return 'Y';
        }
        return 'N';
    }

    @CSBDDStepDef('I verify Use Sketchmark Replacement shows current value')
    async verifyUseSketchmarkReplacementShowsCurrentValue(): Promise<void> {
        const currentFlag = this.scenarioContext.getVariable<string>('currentSketchmarkFlag') || 'N';
        const expectedValue = currentFlag === 'Y' ? 'True' : 'False';
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === expectedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows current value: ${actualValue}`);
        } else {
            CSReporter.warn(`Use Sketchmark Replacement mismatch: Expected=${expectedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify Output Ttcalc File shows current value')
    async verifyOutputTtcalcFileShowsCurrentValue(): Promise<void> {
        const inductorCode = this.scenarioContext.getVariable<string>('currentInductorCode');
        const expectedValue = inductorCode ? 'True' : 'False';
        const actualValue = await this.zealDetailsPage.getOutputTtcalcFileValue();

        CSReporter.info(`Output Ttcalc File: Expected=${expectedValue}, Actual=${actualValue}`);
    }

    @CSBDDStepDef('I verify existing scattered mmtes match database')
    async verifyExistingScatteredMmtesMatchDatabase(): Promise<void> {
        const existingMmtes = this.scenarioContext.getVariable<any[]>('existingScatteredMmtes') || [];
        const uiMmteCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (uiMmteCount === existingMmtes.length) {
            CSReporter.pass(`Existing scattered mmtes match database: ${uiMmteCount} mmtes`);
        } else {
            throw new Error(`Scattered mmtes count mismatch: DB=${existingMmtes.length}, UI=${uiMmteCount}`);
        }
    }

    @CSBDDStepDef('I update sketchmark flag if required')
    async updateSketchmarkFlagIfRequired(): Promise<void> {
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (!sketchmarkFlagToUpdate) {
            CSReporter.info('sketchmarkFlagToUpdate not set, skipping sketchmark flag update');
            return;
        }

        const shouldBeChecked = sketchmarkFlagToUpdate === 'Y';

        if (shouldBeChecked) {
            await this.zealDetailsPage.checkUseSketchmarkReplacement();
        } else {
            await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
        }
        CSReporter.pass(`Updated Use Sketchmark Replacement to: ${shouldBeChecked ? 'checked' : 'unchecked'}`);
    }

    @CSBDDStepDef('I update FFX Inductor Type if required')
    async updateFfxInductorTypeIfRequired(): Promise<void> {
        const ffxFileInductorTypeToUpdate = this.scenarioContext.getVariable<string>('ffxFileInductorTypeToUpdate');
        if (!ffxFileInductorTypeToUpdate) {
            CSReporter.info('ffxFileInductorTypeToUpdate not set, skipping FFX Inductor Type update');
            return;
        }

        // Ensure Output Ttcalc File is checked first
        await this.zealDetailsPage.checkOutputTtcalcFile();

        // Select the new FFX Inductor Type
        await this.zealDetailsPage.selectFfxInductorType(ffxFileInductorTypeToUpdate);
        CSReporter.pass(`Updated FFX Inductor Type to: ${ffxFileInductorTypeToUpdate}`);
    }

    @CSBDDStepDef('I update scattered mmtes if required')
    async updateScatteredMmtesIfRequired(): Promise<void> {
        const updateScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('updateScatteredMmtesFlag');
        if (!updateScatteredMmtesFlag) {
            CSReporter.info('updateScatteredMmtesFlag is false, skipping scattered mmtes update');
            return;
        }

        const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
        if (!scatteredMmtesToUpdate) {
            CSReporter.info('scatteredMmtesToUpdate is empty, skipping');
            return;
        }

        // Parse format: "OldMmte||NewMmte;OldMmte||NewMmte"
        const updatePairs = scatteredMmtesToUpdate.split(';').filter(p => p.trim());
        const oldMmtes: string[] = [];
        const newMmtes: string[] = [];

        updatePairs.forEach(pair => {
            const [oldMmte, newMmte] = pair.split('||').map(s => s.trim());
            if (oldMmte && newMmte) {
                oldMmtes.push(oldMmte);
                newMmtes.push(newMmte);
            }
        });

        // Open Add/Remove modal
        await this.zealDetailsPage.clickAddRemoveButton();
        // Wait for modal to be visible
        const isModalVisible = await this.scatteredMmtesModalPage.isModalVisible();
        if (!isModalVisible) {
            throw new Error('Select Options modal did not appear');
        }

        // Unselect old mmtes
        for (const oldMmte of oldMmtes) {
            await this.scatteredMmtesModalPage.unselectScatteredMmte(oldMmte);
        }

        // Select new mmtes
        for (const newMmte of newMmtes) {
            await this.scatteredMmtesModalPage.selectScatteredMmte(newMmte);
        }

        // Apply changes
        await this.scatteredMmtesModalPage.clickApplyButton();
        CSReporter.pass(`Updated scattered mmtes: Removed ${oldMmtes.length}, Added ${newMmtes.length}`);

        // Store replacement mmtes for verification
        this.scenarioContext.setVariable('replacementScatteredMmtes', newMmtes);
    }

    @CSBDDStepDef('I remove scattered mmtes if required')
    async removeScatteredMmtesIfRequired(): Promise<void> {
        const removeScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('removeScatteredMmtesFlag');
        if (!removeScatteredMmtesFlag) {
            CSReporter.info('removeScatteredMmtesFlag is false, skipping scattered mmtes removal');
            return;
        }

        const scatteredMmtesToRemove = this.scenarioContext.getVariable<string>('scatteredMmtesToRemove') || '';
        if (!scatteredMmtesToRemove) {
            CSReporter.info('scatteredMmtesToRemove is empty, skipping');
            return;
        }

        // Parse format: "Mmte1;Mmte2"
        const mmtesToRemove = scatteredMmtesToRemove.split(';').map(s => s.trim()).filter(s => s);

        // Open Add/Remove modal
        await this.zealDetailsPage.clickAddRemoveButton();
        // Wait for modal to be visible
        const isModalVisible = await this.scatteredMmtesModalPage.isModalVisible();
        if (!isModalVisible) {
            throw new Error('Select Options modal did not appear');
        }

        // Unselect mmtes to remove
        for (const mmte of mmtesToRemove) {
            await this.scatteredMmtesModalPage.unselectScatteredMmte(mmte);
        }

        // Apply changes
        await this.scatteredMmtesModalPage.clickApplyButton();
        CSReporter.pass(`Removed ${mmtesToRemove.length} scattered mmtes`);
    }

    @CSBDDStepDef('I update disputed scattered mmtes if required')
    async updateDisputedScatteredMmtesIfRequired(): Promise<void> {
        const updateDisputedScatteredMmteFlag = this.scenarioContext.getVariable<boolean>('updateDisputedScatteredMmteFlag');
        if (!updateDisputedScatteredMmteFlag) {
            CSReporter.info('updateDisputedScatteredMmteFlag is false, skipping disputed scattered mmtes update');
            return;
        }

        const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
        if (!disputedScatteredMmteToUpdate) {
            CSReporter.info('disputedScatteredMmteToUpdate is empty, skipping');
            return;
        }

        // Parse format: "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
        const disputedPairs = disputedScatteredMmteToUpdate.split(';').filter(p => p.trim());

        for (const pair of disputedPairs) {
            const [refMmte, disputedMmte] = pair.split('||').map(s => s.trim());
            if (refMmte && disputedMmte) {
                // Open disputed modal for this scattered mmte row
                await this.zealDetailsPage.setDisputedScatteredMmteForRow(refMmte, disputedMmte);
                // Select the disputed mmte in the modal
                await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(disputedMmte);
                // Close modal by clicking Apply/Select button (disputed modal uses Apply)
                await this.scatteredMmtesModalPage.clickApplyButton();
                CSReporter.info(`Set disputed for ${refMmte} -> ${disputedMmte}`);
            }
        }
        CSReporter.pass(`Updated ${disputedPairs.length} disputed scattered mmtes`);
    }

    @CSBDDStepDef('I update disputed start dates if required')
    async updateDisputedStartDatesIfRequired(): Promise<void> {
        const updateDisputedStartDateFlag = this.scenarioContext.getVariable<boolean>('updateDisputedStartDateFlag');
        if (!updateDisputedStartDateFlag) {
            CSReporter.info('updateDisputedStartDateFlag is false, skipping disputed start dates update');
            return;
        }

        const disputedStartDateToUpdate = this.scenarioContext.getVariable<string>('disputedStartDateToUpdate') || '';
        if (!disputedStartDateToUpdate) {
            CSReporter.info('disputedStartDateToUpdate is empty, skipping');
            return;
        }

        // Parse format: "DisputedMmte||MM/DD/YYYY;DisputedMmte||MM/DD/YYYY"
        const datePairs = disputedStartDateToUpdate.split(';').filter(p => p.trim());

        for (const pair of datePairs) {
            const [disputedMmte, dateValue] = pair.split('||').map(s => s.trim());
            if (disputedMmte && dateValue) {
                await this.zealDetailsPage.setDisputedStartDateForRow(disputedMmte, dateValue);
                CSReporter.info(`Set disputed start date for ${disputedMmte}: ${dateValue}`);
            }
        }
        CSReporter.pass(`Updated ${datePairs.length} disputed start dates`);
    }

    @CSBDDStepDef('I update FFX order if required')
    async updateFfxOrderIfRequired(): Promise<void> {
        const ffxOrderUpdateFlag = this.scenarioContext.getVariable<boolean>('ffxOrderUpdateFlag');
        if (!ffxOrderUpdateFlag) {
            CSReporter.info('ffxOrderUpdateFlag is false, skipping FFX order update');
            return;
        }

        const ffxOrderToUpdate = this.scenarioContext.getVariable<string>('ffxOrderToUpdate') || '';
        if (!ffxOrderToUpdate) {
            CSReporter.info('ffxOrderToUpdate is empty, skipping');
            return;
        }

        // Parse format: "MmteName||OrderNumber;MmteName||OrderNumber"
        const orderPairs = ffxOrderToUpdate.split(';').filter(p => p.trim());

        for (const pair of orderPairs) {
            const [mmteName, orderNumber] = pair.split('||').map(s => s.trim());
            if (mmteName && orderNumber) {
                await this.zealDetailsPage.setFfxOrderForRow(mmteName, parseInt(orderNumber, 10));
                CSReporter.info(`Set FFX order for ${mmteName}: ${orderNumber}`);
            }
        }
        CSReporter.pass(`Updated ${orderPairs.length} FFX orders`);
    }

    @CSBDDStepDef('I verify changes data matches expected updates')
    async verifyChangesDataMatchesExpectedUpdates(): Promise<void> {
        const changesData = await this.changesHistoryPage.getAllChangesData();

        // Build expected changes based on flags
        let expectedChangesCount = 0;

        if (this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate')) {
            expectedChangesCount++;
        }
        if (this.scenarioContext.getVariable<string>('ffxFileInductorTypeToUpdate')) {
            expectedChangesCount++;
        }
        if (this.scenarioContext.getVariable<boolean>('updateScatteredMmtesFlag')) {
            const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
            const pairs = scatteredMmtesToUpdate.split(';').filter(p => p.trim());
            expectedChangesCount += pairs.length * 2; // Each update = 1 remove + 1 add
        }
        if (this.scenarioContext.getVariable<boolean>('updateDisputedScatteredMmteFlag')) {
            expectedChangesCount++;
        }

        CSReporter.info(`Changes data: Found ${changesData.length} changes, expected approximately ${expectedChangesCount}`);

        if (changesData.length > 0) {
            CSReporter.pass(`Changes table shows ${changesData.length} pending changes`);
        } else {
            throw new Error('Changes table should show pending changes');
        }
    }

    @CSBDDStepDef('I verify zealpremisis data has updated settings')
    async verifyZealpremisisDataHasUpdatedSettings(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const zealpremisisData = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!zealpremisisData) {
            throw new Error(`Zealpremisis data not found for ID: ${zealpremisisDataId}`);
        }

        // Verify updated sketchmark flag
        const expectedSketchmarkFlag = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (expectedSketchmarkFlag && zealpremisisData.sketchmarkReplacementFlag !== expectedSketchmarkFlag) {
            throw new Error(`Sketchmark flag mismatch: Expected=${expectedSketchmarkFlag}, Actual=${zealpremisisData.sketchmarkReplacementFlag}`);
        }

        CSReporter.pass('Zealpremisis data has updated settings');
    }

    @CSBDDStepDef('I verify Use Sketchmark Replacement shows expected updated value')
    async verifyUseSketchmarkReplacementShowsExpectedUpdatedValue(): Promise<void> {
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate') || 'N';
        const expectedValue = sketchmarkFlagToUpdate === 'Y' ? 'True' : 'False';
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === expectedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows expected updated value: ${actualValue}`);
        } else {
            throw new Error(`Use Sketchmark Replacement mismatch after approval: Expected=${expectedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify updated scattered mmtes in UI match database')
    async verifyUpdatedScatteredMmtesInUIMatchDatabase(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const dbMmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);
        const uiMmteCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (uiMmteCount === dbMmteData.length) {
            CSReporter.pass(`Updated scattered mmtes in UI match database: ${uiMmteCount} mmtes`);
        } else {
            throw new Error(`Scattered mmtes count mismatch: UI=${uiMmteCount}, DB=${dbMmteData.length}`);
        }
    }


