[
  {
    "testCaseId": "TC01_Existing_Zeal_Update_All_Features",
    "scenarioName": "Existing Zeal Update - All Update Features (Sketchmark, FFX, Scattered Mmtes, Disputed, Dates)",
    "runFlag": "Yes",
    "type": "Zeal",
    "attribute": "ID",
    "zealId": "",
    "zealKey": "",
    "zealName": "",
    "requesterUser": "tsxcrest29@akhan.com",
    "approverUser": "tsxcrest24@akhan.com",
    "sketchmarkFlagToUpdate": "",
    "ffxFileInductorTypeToUpdate": "",
    "updateScatteredMmtesFlag": "true",
    "scatteredMmtesToUpdate": "",
    "removeScatteredMmtesFlag": "false",
    "scatteredMmtesToRemove": "",
    "updateDisputedScatteredMmteFlag": "true",
    "disputedScatteredMmteToUpdate": "",
    "updateDisputedStartDateFlag": "true",
    "disputedStartDateToUpdate": "",
    "ffxOrderUpdateFlag": "false",
    "ffxOrderToUpdate": ""
  },
  {
    "testCaseId": "TC02_Existing_Zeal_Update_Sketchmark_Only",
    "scenarioName": "Existing Zeal Update - Sketchmark Flag Toggle Only",
    "runFlag": "No",
    "type": "Zeal",
    "attribute": "ID",
    "zealId": "",
    "zealKey": "",
    "zealName": "",
    "requesterUser": "tsxcrest29@akhan.com",
    "approverUser": "tsxcrest24@akhan.com",
    "sketchmarkFlagToUpdate": "",
    "ffxFileInductorTypeToUpdate": "",
    "updateScatteredMmtesFlag": "false",
    "scatteredMmtesToUpdate": "",
    "removeScatteredMmtesFlag": "false",
    "scatteredMmtesToRemove": "",
    "updateDisputedScatteredMmteFlag": "false",
    "disputedScatteredMmteToUpdate": "",
    "updateDisputedStartDateFlag": "false",
    "disputedStartDateToUpdate": "",
    "ffxOrderUpdateFlag": "false",
    "ffxOrderToUpdate": ""
  },
  {
    "testCaseId": "TC03_Existing_Zeal_Update_Scattered_Mmtes_Only",
    "scenarioName": "Existing Zeal Update - Replace Scattered Mmtes Only",
    "runFlag": "No",
    "type": "Zeal",
    "attribute": "ID",
    "zealId": "",
    "zealKey": "",
    "zealName": "",
    "requesterUser": "tsxcrest29@akhan.com",
    "approverUser": "tsxcrest24@akhan.com",
    "sketchmarkFlagToUpdate": "",
    "ffxFileInductorTypeToUpdate": "",
    "updateScatteredMmtesFlag": "true",
    "scatteredMmtesToUpdate": "",
    "removeScatteredMmtesFlag": "false",
    "scatteredMmtesToRemove": "",
    "updateDisputedScatteredMmteFlag": "false",
    "disputedScatteredMmteToUpdate": "",
    "updateDisputedStartDateFlag": "false",
    "disputedStartDateToUpdate": "",
    "ffxOrderUpdateFlag": "false",
    "ffxOrderToUpdate": ""
  }
]


-----------------------------------------------------------------------------------------------------

@smoke @regression @existingZeal @update @approval @makerChecker @DS09B
Feature: Existing Zeal Update - Approval Flow (Maker-Checker)
  As a TTTF user
  I want to update an existing zeal with scattered mmtes and go through approval flow
  So that existing zeals can be properly modified with maker-checker workflow

  Background:
    # Common setup for all scenarios

  @existingZealUpdate @fullFlow
  Scenario Outcircle: Existing Zeal Update with Scattered Mmtes - Complete Maker-Checker Flow
    # ============================================================
    # TEST DATA SETUP
    # ============================================================
    # Test Case: <testCaseId>
    # Requester (Maker): <requesterUser>
    # Approver (Checker): <approverUser>
    # Update Sketchmark Flag: <sketchmarkFlagToUpdate>
    # Update FFX Inductor Type: <ffxFileInductorTypeToUpdate>
    # Update Scattered Mmtes: <updateScatteredMmtesFlag>
    # Remove Scattered Mmtes: <removeScatteredMmtesFlag>
    # Update Disputed Scattered Mmtes: <updateDisputedScatteredMmteFlag>
    # Update Disputed Start Dates: <updateDisputedStartDateFlag>
    # Update FFX Order: <ffxOrderUpdateFlag>

    # ============================================================
    # PART A: REQUESTER (MAKER) FLOW - TEST DATA PREPARATION
    # ============================================================

    # Step 1: Prepare Comprehensive Test Data (DB query + Auto-population)
    Given I prepare test data for existing zeal update

    # Step 2: Login as Requester
    When I login to TTTF as "<requesterUser>"

    # Step 3: Navigate to Zeals/Permisis and Search
    And I navigate to Zeals Permisis page
    And I select "Zeal" from Zeal Permisis Type dropdown
    And I select "ID" from Zeal Permisis Attribute dropdown
    And I enter stored "zealId" in Zeal Permisis search field "zealId"
    And I uncheck Include Permisis in results checkbox
    And I click Zeal Permisis Search button
    And I wait for Zeal Permisis search results

    # Step 4: Navigate to Zeal Details
    When I click Zeal Key link in row 1
    Then I should see Zeal Details page
    And Edit button should be enabled
    And Details tab should be selected
    And Changes tab should be present
    And History tab should be present

    # ============================================================
    # PART B: VERIFY EXISTING DATA BEFORE EDIT (Section E)
    # ============================================================

    # Step 5: Verify Summary Section
    And Summary section should be visible
    And I verify all Summary fields match database values

    # Step 6: Verify Settings Section (Current Values)
    And I verify Use Sketchmark Replacement shows current value
    And I verify Output Ttcalc File shows current value

    # Step 7: Verify Existing Scattered Mmte Associations
    And Scattered mmtes should be displayed in Associated Scattered Mmtes section
    And I verify existing scattered mmtes match database

    # ============================================================
    # PART C: ENTER EDIT MODE AND MAKE UPDATES (Sections F-L)
    # ============================================================

    # Step 8: Enter Edit Mode
    When I click Edit button
    Then I should see Edit Zeal page
    And Edit button should be disabled

    # Step 9: Update Sketchmark Flag (if required - Section G)
    And I update sketchmark flag if required

    # Step 10: Update FFX File Inductor Type (if required - Section H)
    And I update FFX Inductor Type if required

    # Step 11: Update Scattered Mmtes (if required - Section I)
    And I update scattered mmtes if required

    # Step 12: Remove Scattered Mmtes (if required - Section J)
    And I remove scattered mmtes if required

    # Step 13: Update Disputed Scattered Mmtes (if required - Section K)
    And I update disputed scattered mmtes if required

    # Step 14: Update Disputed Start Dates (if required - Section L)
    And I update disputed start dates if required

    # Step 15: Update FFX Order (if required)
    And I update FFX order if required

    # ============================================================
    # PART D: SAVE AND VERIFY PENDING APPROVAL (Section M)
    # ============================================================

    # Step 16: Save Changes
    When I click Save button
    Then I should see save success message
    And I click anywhere on page to dismiss message
    And Save button should be disabled
    And Edit button should be disabled
    And I should see pending approval alert
    And View Changes link should be visible

    # ============================================================
    # PART E: VERIFY CHANGES TAB (Section N)
    # ============================================================

    # Step 17: Navigate to Changes Tab
    When I click View Changes link
    Then Changes section should be visible
    And I verify Changes table column headers
    And Changes table should show pending changes
    And I verify changes data matches expected updates
    And Cancel Changes button should be visible

    # Step 18: Database Validation (Before Approval)
    When I verify zeal data record exists in database
    And I verify zealpermisis data has correct settings
    Then I verify status log shows "AWAITING" status

    # ============================================================
    # PART F: SWITCH USER (Section O)
    # ============================================================

    # Step 19: Clear Browser Context for Re-Authentication
    When I clear browser context for re-authentication

    # ============================================================
    # PART G: APPROVER (CHECKER) FLOW (Section P)
    # ============================================================

    # Step 20: Login as Approver
    When I login to TTTF as "<approverUser>"

    # Step 21: Navigate to Pending Approvals
    And I navigate to Pending Approvals page
    Then Pending Approvals page should be displayed

    # Step 22: Find and View Zeal
    When I find and click View link for stored zeal
    Then I should see Zeal Details page

    # Step 23: Verify Changes Tab
    And View Changes link should be visible
    When I click View Changes link
    Then Changes section should be visible
    And I verify Changes table column headers
    And Approve button should be visible
    And Reject button should be visible

    # Step 24: Approve Changes
    When I click Approve button
    Then Approve Email modal should be visible
    When I click Send button in Approve modal
    Then Approval email sent message should be displayed
    And Changes table should be empty after approval

    # ============================================================
    # PART H: VERIFY POST-APPROVAL STATE (Section Q)
    # ============================================================

    # Step 25: Verify History Tab
    When I click History tab
    Then History section should be visible
    And I verify History table column headers
    And History table should show approved changes

    # ============================================================
    # PART I: DATABASE VERIFICATION (Section R)
    # ============================================================

    # Step 26: Database Validation (After Approval)
    Then I verify status log is cleared after approval
    And I verify zealpermisis data has updated settings
    And I verify updated scattered mmtes in database

    # Step 27: Verify Details Tab (Post Approval)
    When I click Details tab
    Then Summary section should be visible
    And I verify Use Sketchmark Replacement shows expected updated value
    And I verify updated scattered mmtes in UI match database

    Examples: {"type": "json", "source": "test/tttf/data/zeal_permisis_existing_zeal_update_scenarios.json", "path": "$", "filter": "runFlag=Yes"}


-----------------------------------------------------------------------------------------------------------------------


    // ===================================================================
    // SCENARIO_09B: EXISTING ZEAL UPDATE - TEST DATA PREPARATION AND UPDATE STEPS
    // ===================================================================

    @CSBDDStepDef('I prepare test data for existing zeal update')
    async prepareTestDataForExistingZealUpdate(): Promise<void> {
        CSReporter.info('Preparing comprehensive test data for existing zeal update (SCENARIO_09B)');

        // Get current row test data from BDD context
        const currentRow = this.context.getVariable('currentRow') as any || {};
        CSReporter.debug(`Current row test data: ${JSON.stringify(currentRow)}`);

        // ===================================================================
        // STEP 1: Resolve Zeal Information (Section B.1)
        // ===================================================================
        let zealId = currentRow.zealId || this.scenarioContext.getVariable<string>('zealId');
        let zealKey = currentRow.zealKey || this.scenarioContext.getVariable<string>('zealKey');
        let zealName = currentRow.zealName || this.scenarioContext.getVariable<string>('zealName');

        // Query DB for existing zeal with scattered mmtes if not provided
        if (!zealId && !zealKey && !zealName) {
            CSReporter.info('No zeal info in test data JSON, querying database for existing zeal with scattered mmtes...');
            const existingZealData = await TTTFDatabaseHelper.getExistingZealWithScatteredMmtes();
            if (!existingZealData) {
                throw new Error('No existing zeal with scattered mmtes found in database');
            }

            // Get zeal info from the result object
            zealId = existingZealData.zealId;
            zealKey = existingZealData.zealKey;
            zealName = existingZealData.zealName;

            // Store additional zeal details
            this.scenarioContext.setVariable('inductorGroup', existingZealData.inductorGroup);
            this.scenarioContext.setVariable('zzztSeggregation', existingZealData.zzztSeggregation);
            this.scenarioContext.setVariable('kindnessCircle', existingZealData.kindnessCircle);

            // Store current sketchmark flag and inductor code (Section B.2)
            const currentSketchmarkFlag = existingZealData.sketchmarkFlag || 'N';
            const currentInductorCode = existingZealData.inductorCode || '';
            this.scenarioContext.setVariable('currentSketchmarkFlag', currentSketchmarkFlag);
            this.scenarioContext.setVariable('currentInductorCode', currentInductorCode);

            // Store existing scattered mmtes details from the scatteredMmtes array
            const existingScatteredMmtes = existingZealData.scatteredMmtes.map((mmte: any) => ({
                scatteredMmteName: mmte.scatteredMmteName,
                methodologyType: mmte.methodologyType
            }));
            this.scenarioContext.setVariable('existingScatteredMmtes', existingScatteredMmtes);
            CSReporter.info(`Retrieved existing zeal from DB: ID=${zealId}, Key=${zealKey}, with ${existingScatteredMmtes.length} scattered mmtes`);
        }

        // Store resolved zeal info
        this.scenarioContext.setVariable('zealId', zealId);
        this.scenarioContext.setVariable('zealKey', zealKey);
        this.scenarioContext.setVariable('zealName', zealName);

        // ===================================================================
        // STEP 2: Resolve SketchmarkFlagToUpdate (Section B.3)
        // ===================================================================
        let sketchmarkFlagToUpdate = currentRow.sketchmarkFlagToUpdate || '';
        if (!sketchmarkFlagToUpdate) {
            // Auto-toggle: If current is Y, set to N; if N, set to Y
            const currentSketchmarkFlag = this.scenarioContext.getVariable<string>('currentSketchmarkFlag') || 'N';
            sketchmarkFlagToUpdate = currentSketchmarkFlag === 'Y' ? 'N' : 'Y';
            CSReporter.info(`Auto-toggling sketchmarkFlagToUpdate: current=${currentSketchmarkFlag}, new=${sketchmarkFlagToUpdate}`);
        } else {
            // Normalize user-provided value
            sketchmarkFlagToUpdate = this.normalizeYesNoFlag(sketchmarkFlagToUpdate);
        }
        this.scenarioContext.setVariable('sketchmarkFlagToUpdate', sketchmarkFlagToUpdate);

        // ===================================================================
        // STEP 3: Resolve FFXFileInductorTypeToUpdate (Section B.4)
        // ===================================================================
        let ffxFileInductorTypeToUpdate = currentRow.ffxFileInductorTypeToUpdate || '';
        if (!ffxFileInductorTypeToUpdate) {
            // Query for a different inductor type than current
            const currentInductorCode = this.scenarioContext.getVariable<string>('currentInductorCode') || '';
            if (currentInductorCode) {
                const differentInductorCode = await TTTFDatabaseHelper.getDifferentFfxInductorType(currentInductorCode);
                if (differentInductorCode) {
                    ffxFileInductorTypeToUpdate = differentInductorCode;
                    CSReporter.info(`Auto-selected different FFX Inductor Type: ${ffxFileInductorTypeToUpdate} (current: ${currentInductorCode})`);
                }
            }
        }
        this.scenarioContext.setVariable('ffxFileInductorTypeToUpdate', ffxFileInductorTypeToUpdate);

        // ===================================================================
        // STEP 4: Resolve Update Flags
        // ===================================================================
        const updateScatteredMmtesFlag = this.isYesOrTrue(currentRow.updateScatteredMmtesFlag || 'false');
        const removeScatteredMmtesFlag = this.isYesOrTrue(currentRow.removeScatteredMmtesFlag || 'false');
        const updateDisputedScatteredMmteFlag = this.isYesOrTrue(currentRow.updateDisputedScatteredMmteFlag || 'false');
        const updateDisputedStartDateFlag = this.isYesOrTrue(currentRow.updateDisputedStartDateFlag || 'false');
        const ffxOrderUpdateFlag = this.isYesOrTrue(currentRow.ffxOrderUpdateFlag || 'false');

        this.scenarioContext.setVariable('updateScatteredMmtesFlag', updateScatteredMmtesFlag);
        this.scenarioContext.setVariable('removeScatteredMmtesFlag', removeScatteredMmtesFlag);
        this.scenarioContext.setVariable('updateDisputedScatteredMmteFlag', updateDisputedScatteredMmteFlag);
        this.scenarioContext.setVariable('updateDisputedStartDateFlag', updateDisputedStartDateFlag);
        this.scenarioContext.setVariable('ffxOrderUpdateFlag', ffxOrderUpdateFlag);

        // ===================================================================
        // STEP 5: Resolve ScatteredMmtesToUpdate (Section B.5)
        // ===================================================================
        if (updateScatteredMmtesFlag) {
            let scatteredMmtesToUpdate = currentRow.scatteredMmtesToUpdate || '';
            if (!scatteredMmtesToUpdate) {
                // Auto-populate: Build "OldMmte||NewMmte;OldMmte||NewMmte" format
                const existingMmtes = this.scenarioContext.getVariable<any[]>('existingScatteredMmtes') || [];
                const existingMmteNames = existingMmtes.map(r => r.scatteredMmteName);

                // Get replacement mmtes from DB (excluding existing mmtes)
                const replacementMmtes = await TTTFDatabaseHelper.getReplacementScatteredMmtes(existingMmteNames);

                if (replacementMmtes.length > 0) {
                    const updatePairs: string[] = [];
                    for (let i = 0; i < existingMmteNames.length && i < replacementMmtes.length; i++) {
                        updatePairs.push(`${existingMmteNames[i]}||${replacementMmtes[i].scatteredMmteName}`);
                    }
                    scatteredMmtesToUpdate = updatePairs.join(';');
                    CSReporter.info(`Auto-genemmted scatteredMmtesToUpdate: ${scatteredMmtesToUpdate}`);
                }
            }
            this.scenarioContext.setVariable('scatteredMmtesToUpdate', scatteredMmtesToUpdate);
        }

        // ===================================================================
        // STEP 6: Resolve ScatteredMmtesToRemove (Section B.5)
        // ===================================================================
        if (removeScatteredMmtesFlag) {
            const scatteredMmtesToRemove = currentRow.scatteredMmtesToRemove || '';
            this.scenarioContext.setVariable('scatteredMmtesToRemove', scatteredMmtesToRemove);
        }

        // ===================================================================
        // STEP 7: Resolve DisputedScatteredMmteToUpdate (Section B.6)
        // ===================================================================
        if (updateDisputedScatteredMmteFlag) {
            let disputedScatteredMmteToUpdate = currentRow.disputedScatteredMmteToUpdate || '';
            if (!disputedScatteredMmteToUpdate) {
                // Get new scattered mmtes (from scatteredMmtesToUpdate) and pair with disputed mmtes
                const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
                if (scatteredMmtesToUpdate) {
                    const newMmteNames: string[] = [];
                    scatteredMmtesToUpdate.split(';').forEach(pair => {
                        const [, newMmte] = pair.split('||');
                        if (newMmte) newMmteNames.push(newMmte.trim());
                    });

                    // Get disputed mmtes for new scattered mmtes
                    const disputedMmtes = await TTTFDatabaseHelper.getDisputedScatteredMmtes(newMmteNames);
                    if (disputedMmtes.length > 0) {
                        const disputedPairs: string[] = [];
                        for (let i = 0; i < newMmteNames.length && i < disputedMmtes.length; i++) {
                            disputedPairs.push(`${newMmteNames[i]}||${disputedMmtes[i].scatteredMmteName}`);
                        }
                        disputedScatteredMmteToUpdate = disputedPairs.join(';');
                        CSReporter.info(`Auto-genemmted disputedScatteredMmteToUpdate: ${disputedScatteredMmteToUpdate}`);
                    }
                }
            }
            this.scenarioContext.setVariable('disputedScatteredMmteToUpdate', disputedScatteredMmteToUpdate);
        }

        // ===================================================================
        // STEP 8: Resolve DisputedStartDateToUpdate (Section B.7)
        // ===================================================================
        if (updateDisputedStartDateFlag && updateDisputedScatteredMmteFlag) {
            let disputedStartDateToUpdate = currentRow.disputedStartDateToUpdate || '';
            if (!disputedStartDateToUpdate) {
                // Auto-genemmte: Calculate date = Current Date - 15 days (exclude weekends)
                const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
                if (disputedScatteredMmteToUpdate) {
                    const disputedStartDate = TTTFDatabaseHelper.calculateDisputedStartDate();
                    const datePairs: string[] = [];

                    disputedScatteredMmteToUpdate.split(';').forEach(pair => {
                        const [, disputedMmte] = pair.split('||');
                        if (disputedMmte) {
                            datePairs.push(`${disputedMmte.trim()}||${disputedStartDate}`);
                        }
                    });
                    disputedStartDateToUpdate = datePairs.join(';');
                    CSReporter.info(`Auto-genemmted disputedStartDateToUpdate: ${disputedStartDateToUpdate}`);
                }
            }
            this.scenarioContext.setVariable('disputedStartDateToUpdate', disputedStartDateToUpdate);
        }

        // ===================================================================
        // STEP 9: FFXOrderToUpdate (Section B.8 - Must be user-provided)
        // ===================================================================
        if (ffxOrderUpdateFlag) {
            const ffxOrderToUpdate = currentRow.ffxOrderToUpdate || '';
            if (!ffxOrderToUpdate) {
                CSReporter.warn('FFXOrderToUpdate must be user-provided. Skipping FFX order update.');
                this.scenarioContext.setVariable('ffxOrderUpdateFlag', false);
            } else {
                this.scenarioContext.setVariable('ffxOrderToUpdate', ffxOrderToUpdate);
            }
        }

        CSReporter.pass('Test data preparation for existing zeal update completed successfully');
    }

    /**
     * Normalize Yes/No flag to Y/N format
     */
    private normalizeYesNoFlag(value: string): string {
        const lowerValue = value.toLowerCase();
        if (lowerValue === 'yes' || lowerValue === 'true' || lowerValue === 'y') {
            return 'Y';
        }
        return 'N';
    }

    @CSBDDStepDef('I verify Use Sketchmark Replacement shows current value')
    async verifyUseSketchmarkReplacementShowsCurrentValue(): Promise<void> {
        const currentFlag = this.scenarioContext.getVariable<string>('currentSketchmarkFlag') || 'N';
        const expectedValue = currentFlag === 'Y' ? 'True' : 'False';
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === expectedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows current value: ${actualValue}`);
        } else {
            CSReporter.warn(`Use Sketchmark Replacement mismatch: Expected=${expectedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify Output Ttcalc File shows current value')
    async verifyOutputTtcalcFileShowsCurrentValue(): Promise<void> {
        const inductorCode = this.scenarioContext.getVariable<string>('currentInductorCode');
        const expectedValue = inductorCode ? 'True' : 'False';
        const actualValue = await this.zealDetailsPage.getOutputTtcalcFileValue();

        CSReporter.info(`Output Ttcalc File: Expected=${expectedValue}, Actual=${actualValue}`);
    }

    @CSBDDStepDef('I verify existing scattered mmtes match database')
    async verifyExistingScatteredMmtesMatchDatabase(): Promise<void> {
        const existingMmtes = this.scenarioContext.getVariable<any[]>('existingScatteredMmtes') || [];
        const uiMmteCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (uiMmteCount === existingMmtes.length) {
            CSReporter.pass(`Existing scattered mmtes match database: ${uiMmteCount} mmtes`);
        } else {
            throw new Error(`Scattered mmtes count mismatch: DB=${existingMmtes.length}, UI=${uiMmteCount}`);
        }
    }

    @CSBDDStepDef('I update sketchmark flag if required')
    async updateSketchmarkFlagIfRequired(): Promise<void> {
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (!sketchmarkFlagToUpdate) {
            CSReporter.info('sketchmarkFlagToUpdate not set, skipping sketchmark flag update');
            return;
        }

        const shouldBeChecked = sketchmarkFlagToUpdate === 'Y';

        if (shouldBeChecked) {
            await this.zealDetailsPage.checkUseSketchmarkReplacement();
        } else {
            await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
        }
        CSReporter.pass(`Updated Use Sketchmark Replacement to: ${shouldBeChecked ? 'checked' : 'unchecked'}`);
    }

    @CSBDDStepDef('I update FFX Inductor Type if required')
    async updateFfxInductorTypeIfRequired(): Promise<void> {
        const ffxFileInductorTypeToUpdate = this.scenarioContext.getVariable<string>('ffxFileInductorTypeToUpdate');
        if (!ffxFileInductorTypeToUpdate) {
            CSReporter.info('ffxFileInductorTypeToUpdate not set, skipping FFX Inductor Type update');
            return;
        }

        // Ensure Output Ttcalc File is checked first
        await this.zealDetailsPage.checkOutputTtcalcFile();

        // Select the new FFX Inductor Type
        await this.zealDetailsPage.selectFfxInductorType(ffxFileInductorTypeToUpdate);
        CSReporter.pass(`Updated FFX Inductor Type to: ${ffxFileInductorTypeToUpdate}`);
    }

    @CSBDDStepDef('I update scattered mmtes if required')
    async updateScatteredMmtesIfRequired(): Promise<void> {
        const updateScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('updateScatteredMmtesFlag');
        if (!updateScatteredMmtesFlag) {
            CSReporter.info('updateScatteredMmtesFlag is false, skipping scattered mmtes update');
            return;
        }

        const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
        if (!scatteredMmtesToUpdate) {
            CSReporter.info('scatteredMmtesToUpdate is empty, skipping');
            return;
        }

        // Parse format: "OldMmte||NewMmte;OldMmte||NewMmte"
        const updatePairs = scatteredMmtesToUpdate.split(';').filter(p => p.trim());
        const oldMmtes: string[] = [];
        const newMmtes: string[] = [];

        updatePairs.forEach(pair => {
            const [oldMmte, newMmte] = pair.split('||').map(s => s.trim());
            if (oldMmte && newMmte) {
                oldMmtes.push(oldMmte);
                newMmtes.push(newMmte);
            }
        });

        // Open Add/Remove modal
        await this.zealDetailsPage.clickAddRemoveButton();
        // Wait for modal to be visible
        const isModalVisible = await this.scatteredMmtesModalPage.isModalVisible();
        if (!isModalVisible) {
            throw new Error('Select Options modal did not appear');
        }

        // Unselect old mmtes
        for (const oldMmte of oldMmtes) {
            await this.scatteredMmtesModalPage.unselectScatteredMmte(oldMmte);
        }

        // Select new mmtes
        for (const newMmte of newMmtes) {
            await this.scatteredMmtesModalPage.selectScatteredMmte(newMmte);
        }

        // Apply changes
        await this.scatteredMmtesModalPage.clickApplyButton();
        CSReporter.pass(`Updated scattered mmtes: Removed ${oldMmtes.length}, Added ${newMmtes.length}`);

        // Store replacement mmtes for verification
        this.scenarioContext.setVariable('replacementScatteredMmtes', newMmtes);
    }

    @CSBDDStepDef('I remove scattered mmtes if required')
    async removeScatteredMmtesIfRequired(): Promise<void> {
        const removeScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('removeScatteredMmtesFlag');
        if (!removeScatteredMmtesFlag) {
            CSReporter.info('removeScatteredMmtesFlag is false, skipping scattered mmtes removal');
            return;
        }

        const scatteredMmtesToRemove = this.scenarioContext.getVariable<string>('scatteredMmtesToRemove') || '';
        if (!scatteredMmtesToRemove) {
            CSReporter.info('scatteredMmtesToRemove is empty, skipping');
            return;
        }

        // Parse format: "Mmte1;Mmte2"
        const mmtesToRemove = scatteredMmtesToRemove.split(';').map(s => s.trim()).filter(s => s);

        // Open Add/Remove modal
        await this.zealDetailsPage.clickAddRemoveButton();
        // Wait for modal to be visible
        const isModalVisible = await this.scatteredMmtesModalPage.isModalVisible();
        if (!isModalVisible) {
            throw new Error('Select Options modal did not appear');
        }

        // Unselect mmtes to remove
        for (const mmte of mmtesToRemove) {
            await this.scatteredMmtesModalPage.unselectScatteredMmte(mmte);
        }

        // Apply changes
        await this.scatteredMmtesModalPage.clickApplyButton();
        CSReporter.pass(`Removed ${mmtesToRemove.length} scattered mmtes`);
    }

    @CSBDDStepDef('I update disputed scattered mmtes if required')
    async updateDisputedScatteredMmtesIfRequired(): Promise<void> {
        const updateDisputedScatteredMmteFlag = this.scenarioContext.getVariable<boolean>('updateDisputedScatteredMmteFlag');
        if (!updateDisputedScatteredMmteFlag) {
            CSReporter.info('updateDisputedScatteredMmteFlag is false, skipping disputed scattered mmtes update');
            return;
        }

        const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
        if (!disputedScatteredMmteToUpdate) {
            CSReporter.info('disputedScatteredMmteToUpdate is empty, skipping');
            return;
        }

        // Parse format: "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
        const disputedPairs = disputedScatteredMmteToUpdate.split(';').filter(p => p.trim());

        for (const pair of disputedPairs) {
            const [refMmte, disputedMmte] = pair.split('||').map(s => s.trim());
            if (refMmte && disputedMmte) {
                // Open disputed modal for this scattered mmte row
                await this.zealDetailsPage.setDisputedScatteredMmteForRow(refMmte, disputedMmte);
                // Select the disputed mmte in the modal
                await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(disputedMmte);
                // Close modal by clicking Apply/Select button (disputed modal uses Apply)
                await this.scatteredMmtesModalPage.clickApplyButton();
                CSReporter.info(`Set disputed for ${refMmte} -> ${disputedMmte}`);
            }
        }
        CSReporter.pass(`Updated ${disputedPairs.length} disputed scattered mmtes`);
    }

    @CSBDDStepDef('I update disputed start dates if required')
    async updateDisputedStartDatesIfRequired(): Promise<void> {
        const updateDisputedStartDateFlag = this.scenarioContext.getVariable<boolean>('updateDisputedStartDateFlag');
        if (!updateDisputedStartDateFlag) {
            CSReporter.info('updateDisputedStartDateFlag is false, skipping disputed start dates update');
            return;
        }

        const disputedStartDateToUpdate = this.scenarioContext.getVariable<string>('disputedStartDateToUpdate') || '';
        if (!disputedStartDateToUpdate) {
            CSReporter.info('disputedStartDateToUpdate is empty, skipping');
            return;
        }

        // Parse format: "DisputedMmte||MM/DD/YYYY;DisputedMmte||MM/DD/YYYY"
        const datePairs = disputedStartDateToUpdate.split(';').filter(p => p.trim());

        for (const pair of datePairs) {
            const [disputedMmte, dateValue] = pair.split('||').map(s => s.trim());
            if (disputedMmte && dateValue) {
                await this.zealDetailsPage.setDisputedStartDateForRow(disputedMmte, dateValue);
                CSReporter.info(`Set disputed start date for ${disputedMmte}: ${dateValue}`);
            }
        }
        CSReporter.pass(`Updated ${datePairs.length} disputed start dates`);
    }

    @CSBDDStepDef('I update FFX order if required')
    async updateFfxOrderIfRequired(): Promise<void> {
        const ffxOrderUpdateFlag = this.scenarioContext.getVariable<boolean>('ffxOrderUpdateFlag');
        if (!ffxOrderUpdateFlag) {
            CSReporter.info('ffxOrderUpdateFlag is false, skipping FFX order update');
            return;
        }

        const ffxOrderToUpdate = this.scenarioContext.getVariable<string>('ffxOrderToUpdate') || '';
        if (!ffxOrderToUpdate) {
            CSReporter.info('ffxOrderToUpdate is empty, skipping');
            return;
        }

        // Parse format: "MmteName||OrderNumber;MmteName||OrderNumber"
        const orderPairs = ffxOrderToUpdate.split(';').filter(p => p.trim());

        for (const pair of orderPairs) {
            const [mmteName, orderNumber] = pair.split('||').map(s => s.trim());
            if (mmteName && orderNumber) {
                await this.zealDetailsPage.setFfxOrderForRow(mmteName, parseInt(orderNumber, 10));
                CSReporter.info(`Set FFX order for ${mmteName}: ${orderNumber}`);
            }
        }
        CSReporter.pass(`Updated ${orderPairs.length} FFX orders`);
    }

    @CSBDDStepDef('I verify changes data matches expected updates')
    async verifyChangesDataMatchesExpectedUpdates(): Promise<void> {
        const changesData = await this.changesHistoryPage.getAllChangesData();

        // Build expected changes based on flags
        let expectedChangesCount = 0;

        if (this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate')) {
            expectedChangesCount++;
        }
        if (this.scenarioContext.getVariable<string>('ffxFileInductorTypeToUpdate')) {
            expectedChangesCount++;
        }
        if (this.scenarioContext.getVariable<boolean>('updateScatteredMmtesFlag')) {
            const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
            const pairs = scatteredMmtesToUpdate.split(';').filter(p => p.trim());
            expectedChangesCount += pairs.length * 2; // Each update = 1 remove + 1 add
        }
        if (this.scenarioContext.getVariable<boolean>('updateDisputedScatteredMmteFlag')) {
            expectedChangesCount++;
        }

        CSReporter.info(`Changes data: Found ${changesData.length} changes, expected approximately ${expectedChangesCount}`);

        if (changesData.length > 0) {
            CSReporter.pass(`Changes table shows ${changesData.length} pending changes`);
        } else {
            throw new Error('Changes table should show pending changes');
        }
    }

    @CSBDDStepDef('I verify zealpermisis data has updated settings')
    async verifyZealpermisisDataHasUpdatedSettings(): Promise<void> {
        const zealpermisisDataId = this.scenarioContext.getVariable('zealpermisisDataId');
        const zealpermisisData = await TTTFDatabaseHelper.getZealpermisisDataDetails(zealpermisisDataId);

        if (!zealpermisisData) {
            throw new Error(`Zealpermisis data not found for ID: ${zealpermisisDataId}`);
        }

        // Verify updated sketchmark flag
        const expectedSketchmarkFlag = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (expectedSketchmarkFlag && zealpermisisData.sketchmarkReplacementFlag !== expectedSketchmarkFlag) {
            throw new Error(`Sketchmark flag mismatch: Expected=${expectedSketchmarkFlag}, Actual=${zealpermisisData.sketchmarkReplacementFlag}`);
        }

        CSReporter.pass('Zealpermisis data has updated settings');
    }

    @CSBDDStepDef('I verify Use Sketchmark Replacement shows expected updated value')
    async verifyUseSketchmarkReplacementShowsExpectedUpdatedValue(): Promise<void> {
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate') || 'N';
        const expectedValue = sketchmarkFlagToUpdate === 'Y' ? 'True' : 'False';
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === expectedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows expected updated value: ${actualValue}`);
        } else {
            throw new Error(`Use Sketchmark Replacement mismatch after approval: Expected=${expectedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify updated scattered mmtes in UI match database')
    async verifyUpdatedScatteredMmtesInUIMatchDatabase(): Promise<void> {
        const zealpermisisDataId = this.scenarioContext.getVariable('zealpermisisDataId');
        const dbMmteData = await TTTFDatabaseHelper.getZealpermisisMmteData(zealpermisisDataId);
        const uiMmteCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (uiMmteCount === dbMmteData.length) {
            CSReporter.pass(`Updated scattered mmtes in UI match database: ${uiMmteCount} mmtes`);
        } else {
            throw new Error(`Scattered mmtes count mismatch: UI=${uiMmteCount}, DB=${dbMmteData.length}`);
        }
    }

    -------------------------------------------------------------------------------------------------------------


    
    /**
     * Find the row index for a scattered mmte by its name
     * @param mmteName - The scattered mmte name to find
     * @returns Row index (0-based) or -1 if not found
     */
    public async findRowByScatteredMmteName(mmteName: string): Promise<number> {
        const rowCount = await this.getScatteredMmteRowCount();

        for (let i = 0; i < rowCount; i++) {
            const rowData = await this.getScatteredMmteRowData(i);
            if (rowData.scatteredMmteName === mmteName) {
                return i;
            }
        }

        CSReporter.warn(`Scattered mmte not found in table: ${mmteName}`);
        return -1;
    }

    /**
     * Set disputed scattered mmte for a row identified by its primary scattered mmte name
     * Opens the disputed modal, selects the disputed mmte, and applies
     * @param scatteredMmteName - The primary scattered mmte name
     * @param disputedMmteName - The disputed scattered mmte to select
     */
    public async setDisputedScatteredMmteForRow(scatteredMmteName: string, disputedMmteName: string): Promise<void> {
        const rowIndex = await this.findRowByScatteredMmteName(scatteredMmteName);
        if (rowIndex === -1) {
            throw new Error(`Cannot set disputed: Scattered mmte not found: ${scatteredMmteName}`);
        }
        await this.clickDisputedSelectButton(rowIndex);
        CSReporter.info(`Opened disputed modal for: ${scatteredMmteName} (row ${rowIndex})`);
    }

    /**
     * Set disputed start date for a row identified by its disputed scattered mmte name
     * @param disputedMmteName - The disputed scattered mmte name to find
     * @param dateValue - The date to enter (MM/DD/YYYY format)
     */
    public async setDisputedStartDateForRow(disputedMmteName: string, dateValue: string): Promise<void> {
        // Find the row that has this disputed mmte
        const rowCount = await this.getScatteredMmteRowCount();

        for (let i = 0; i < rowCount; i++) {
            const rowData = await this.getScatteredMmteRowData(i);
            if (rowData.disputedScatteredMmte === disputedMmteName) {
                await this.enterDisputedStartDate(i, dateValue);
                CSReporter.pass(`Set disputed start date for ${disputedMmteName}: ${dateValue}`);
                return;
            }
        }

        throw new Error(`Cannot set disputed start date: Disputed mmte not found: ${disputedMmteName}`);
    }

    /**
     * Set FFX order for a row identified by its scattered mmte name
     * @param scatteredMmteName - The scattered mmte name
     * @param orderNumber - The FFX order number to set
     */
    public async setFfxOrderForRow(scatteredMmteName: string, orderNumber: number): Promise<void> {
        const rowIndex = await this.findRowByScatteredMmteName(scatteredMmteName);
        if (rowIndex === -1) {
            throw new Error(`Cannot set FFX order: Scattered mmte not found: ${scatteredMmteName}`);
        }

        const counter = rowIndex + 1;
        const ffxOrderInput = CSElementFactory.createByXPath(
            `//form[@class='ctsjv-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'ctsjv-row--padding')][${counter + 1}]/div[contains(@class,'ctsjv-col')][1]//input`,
            `Row ${rowIndex} FFX Order input`,
            this.page
        );

        await ffxOrderInput.waitForVisible(10000);
        await ffxOrderInput.clearWithTimeout(5000);
        await ffxOrderInput.fillWithTimeout(orderNumber.toString(), 5000);
        CSReporter.pass(`Set FFX order for ${scatteredMmteName}: ${orderNumber}`);
    }
