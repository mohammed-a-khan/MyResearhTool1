import { StepDefinitions, CSBDDStepDef, Page } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSBDDContext, CSScenarioContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSValueResolver } from '@mdakhan.mak/cs-playwright-test-framework/utilities';
import { CSBrowserManager } from '@mdakhan.mak/cs-playwright-test-framework/browser';

import { TTTFNavigationPage } from '../pages/TTTFNavigationPage';
import { TTTFZealPremisisPage } from '../pages/TTTFZealPremisisPage';
import { TTTFZealDetailsPage } from '../pages/TTTFZealDetailsPage';
import { TTTFScatteredMmtesModalPage } from '../pages/TTTFScatteredMmtesModalPage';
import { TTTFChangesHistoryPage } from '../pages/TTTFChangesHistoryPage';
import { TTTFPendingApprovalsPage } from '../pages/TTTFPendingApprovalsPage';
import { TTTFDatabaseHelper } from '../helpers/TTTFDatabaseHelper';

/**
 * TTTF New Zeal Setup Step Definitions
 * Source: SCENARIO_03_NewZeal_Approval.txt
 * Implements Maker-Checker workflow for new zeal setup
 */
@StepDefinitions
export class TTTFNewZealSteps {

    @Page('tttf-navigation')
    private navigationPage!: TTTFNavigationPage;

    @Page('tttf-zeal-premisis')
    private zealPremisisPage!: TTTFZealPremisisPage;

    @Page('tttf-zeal-details')
    private zealDetailsPage!: TTTFZealDetailsPage;

    @Page('tttf-scattered-mmtes-modal')
    private scatteredMmtesModalPage!: TTTFScatteredMmtesModalPage;

    @Page('tttf-changes-history')
    private changesHistoryPage!: TTTFChangesHistoryPage;

    @Page('tttf-pending-approvals')
    private pendingApprovalsPage!: TTTFPendingApprovalsPage;

    private context = CSBDDContext.getInstance();
    private scenarioContext = CSScenarioContext.getInstance();

    // ===================================================================
    // TEST DATA SETUP STEPS
    // ===================================================================

    @CSBDDStepDef('I get zeal for new setup from database')
    async getZealForNewSetupFromDatabase(): Promise<void> {
        CSReporter.info('Getting zeal for new setup from database');

        const zealDetails = await TTTFDatabaseHelper.getZealForNewSetup();
        if (!zealDetails) {
            throw new Error('No zeal available for new setup in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);
        this.scenarioContext.setVariable('premisisDescription', zealDetails.premisisDescription);
        this.scenarioContext.setVariable('calcShoolName', zealDetails.calcShoolName);
        this.scenarioContext.setVariable('administrator', zealDetails.administrator);

        CSReporter.pass(`Retrieved zeal for new setup: ID=${zealDetails.zealId}, Name=${zealDetails.zealName}`);
    }

    @CSBDDStepDef('I get scattered mmtes to add from database')
    async getScatteredMmtesToAddFromDatabase(): Promise<void> {
        CSReporter.info('Getting scattered mmtes to add from database');

        const scatteredMmtes = await TTTFDatabaseHelper.getScatteredMmtesToAdd();
        if (scatteredMmtes.length === 0) {
            throw new Error('No scattered mmtes available to add from database');
        }

        const mmteNames = scatteredMmtes.map(r => r.scatteredMmteName);
        this.scenarioContext.setVariable('scatteredMmtesToAdd', mmteNames);
        this.scenarioContext.setVariable('scatteredMmtesDetails', scatteredMmtes);

        CSReporter.pass(`Retrieved ${mmteNames.length} scattered mmtes to add: ${mmteNames.join(', ')}`);
    }

    // ===================================================================
    // ZEAL DETAILS PAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Details page')
    async verifyZealDetailsPage(): Promise<void> {
        await this.zealDetailsPage.verifyZealDetailsPageDisplayed();
    }

    @CSBDDStepDef('I should see Edit Zeal page')
    async verifyEditZealPage(): Promise<void> {
        await this.zealDetailsPage.verifyEditZealPageDisplayed();
    }

    @CSBDDStepDef('Edit button should be enabled')
    async verifyEditButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isEditButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Edit button is enabled');
        } else {
            throw new Error('Edit button is not enabled');
        }
    }

    @CSBDDStepDef('Edit button should be disabled')
    async verifyEditButtonDisabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isEditButtonEnabled();
        if (!isEnabled) {
            CSReporter.pass('Edit button is disabled');
        } else {
            throw new Error('Edit button is not disabled');
        }
    }

    @CSBDDStepDef('I click Edit button')
    async clickEditButton(): Promise<void> {
        await this.zealDetailsPage.clickEditButton();
    }

    @CSBDDStepDef('Details tab should be selected')
    async verifyDetailsTabSelected(): Promise<void> {
        const isSelected = await this.zealDetailsPage.isDetailsTabSelected();
        if (isSelected) {
            CSReporter.pass('Details tab is selected');
        } else {
            throw new Error('Details tab is not selected');
        }
    }

    @CSBDDStepDef('I click Changes tab')
    async clickChangesTab(): Promise<void> {
        await this.zealDetailsPage.clickChangesTab();
    }

    @CSBDDStepDef('I click History tab')
    async clickHistoryTab(): Promise<void> {
        await this.zealDetailsPage.clickHistoryTab();
    }

    @CSBDDStepDef('I click Details tab')
    async clickDetailsTab(): Promise<void> {
        await this.zealDetailsPage.clickDetailsTab();
    }

    @CSBDDStepDef('Changes tab should be present')
    async verifyChangesTabPresent(): Promise<void> {
        const isPresent = await this.zealDetailsPage.isChangesTabPresent();
        if (isPresent) {
            CSReporter.pass('Changes tab is present');
        } else {
            throw new Error('Changes tab is not present');
        }
    }

    @CSBDDStepDef('History tab should be present')
    async verifyHistoryTabPresent(): Promise<void> {
        const isPresent = await this.zealDetailsPage.isHistoryTabPresent();
        if (isPresent) {
            CSReporter.pass('History tab is present');
        } else {
            throw new Error('History tab is not present');
        }
    }

    @CSBDDStepDef('Cancel button should be enabled')
    async verifyZealCancelButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isCancelButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Cancel button is enabled');
        } else {
            throw new Error('Cancel button is not enabled');
        }
    }

    @CSBDDStepDef('Use Sketchmark Replacement checkbox should be unchecked')
    async verifyUseSketchmarkReplacementUnchecked(): Promise<void> {
        const isChecked = await this.zealDetailsPage.isUseSketchmarkReplacementChecked();
        if (!isChecked) {
            CSReporter.pass('Use Sketchmark Replacement checkbox is unchecked');
        } else {
            throw new Error('Use Sketchmark Replacement checkbox should be unchecked but is checked');
        }
    }

    @CSBDDStepDef('Output Ttcalc File checkbox should be unchecked')
    async verifyOutputTtcalcFileUnchecked(): Promise<void> {
        const isChecked = await this.zealDetailsPage.isOutputTtcalcFileChecked();
        if (!isChecked) {
            CSReporter.pass('Output Ttcalc File checkbox is unchecked');
        } else {
            throw new Error('Output Ttcalc File checkbox should be unchecked but is checked');
        }
    }

    @CSBDDStepDef('Reorder button should be visible')
    async verifyReorderButtonVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isReorderButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reorder button is visible');
        } else {
            throw new Error('Reorder button is not visible');
        }
    }

    // ===================================================================
    // SUMMARY SECTION VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('Summary section should be visible')
    async verifySummaryVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.summaryHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Summary section is visible');
        } else {
            throw new Error('Summary section is not visible');
        }
    }

    @CSBDDStepDef('Zeal ID in Summary should match stored value')
    async verifyZealIdInSummary(): Promise<void> {
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealDetailsPage.getZealId();

        if (actualZealId === expectedZealId) {
            CSReporter.pass(`Zeal ID matches: ${actualZealId}`);
        } else {
            throw new Error(`Zeal ID mismatch: Expected=${expectedZealId}, Actual=${actualZealId}`);
        }
    }

    @CSBDDStepDef('Zeal Name in Summary should match stored value')
    async verifyZealNameInSummary(): Promise<void> {
        const expectedZealName = this.scenarioContext.getVariable('zealName');
        const actualZealName = await this.zealDetailsPage.getZealName();

        if (actualZealName === expectedZealName) {
            CSReporter.pass(`Zeal Name matches: ${actualZealName}`);
        } else {
            throw new Error(`Zeal Name mismatch: Expected=${expectedZealName}, Actual=${actualZealName}`);
        }
    }

    @CSBDDStepDef('Zeal Key in Summary should match stored value')
    async verifyZealKeyInSummary(): Promise<void> {
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealDetailsPage.getZealKey();

        if (actualZealKey === expectedZealKey) {
            CSReporter.pass(`Zeal Key matches: ${actualZealKey}`);
        } else {
            throw new Error(`Zeal Key mismatch: Expected=${expectedZealKey}, Actual=${actualZealKey}`);
        }
    }

    @CSBDDStepDef('Zzzt Seggregation in Summary should match stored value')
    async verifyZzztSeggregationInSummary(): Promise<void> {
        const expectedZzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');
        const actualZzztAbbrev = await this.zealDetailsPage.getZzztSeggregation();

        if (actualZzztAbbrev === expectedZzztAbbrev) {
            CSReporter.pass(`Zzzt Seggregation matches: ${actualZzztAbbrev}`);
        } else {
            throw new Error(`Zzzt Seggregation mismatch: Expected=${expectedZzztAbbrev}, Actual=${actualZzztAbbrev}`);
        }
    }

    @CSBDDStepDef('Premisis Description in Summary should match stored value')
    async verifyPremisisDescriptionInSummary(): Promise<void> {
        const expectedPremisisDesc = this.scenarioContext.getVariable('premisisDescription');
        const actualPremisisDesc = await this.zealDetailsPage.getPremisisDescription();

        if (actualPremisisDesc === expectedPremisisDesc) {
            CSReporter.pass(`Premisis Description matches: ${actualPremisisDesc}`);
        } else {
            throw new Error(`Premisis Description mismatch: Expected=${expectedPremisisDesc}, Actual=${actualPremisisDesc}`);
        }
    }

    @CSBDDStepDef('Inductor Group in Summary should match stored value')
    async verifyInductorGroupInSummary(): Promise<void> {
        const expectedInductorGroup = this.scenarioContext.getVariable('inductorGroup');
        const actualInductorGroup = await this.zealDetailsPage.getInductorGroup();

        if (actualInductorGroup === expectedInductorGroup) {
            CSReporter.pass(`Inductor Group matches: ${actualInductorGroup}`);
        } else {
            throw new Error(`Inductor Group mismatch: Expected=${expectedInductorGroup}, Actual=${actualInductorGroup}`);
        }
    }

    @CSBDDStepDef('Kindness Circle in Summary should match stored value')
    async verifyKindnessCircleInSummary(): Promise<void> {
        const expectedKindnessCircle = this.scenarioContext.getVariable('kindnessCircle');
        const actualKindnessCircle = await this.zealDetailsPage.getKindnessCircle();

        if (actualKindnessCircle === expectedKindnessCircle) {
            CSReporter.pass(`Kindness Circle matches: ${actualKindnessCircle}`);
        } else {
            throw new Error(`Kindness Circle mismatch: Expected=${expectedKindnessCircle}, Actual=${actualKindnessCircle}`);
        }
    }

    @CSBDDStepDef('Ttcalc Shool in Summary should match stored value')
    async verifyTtcalcShoolInSummary(): Promise<void> {
        const expectedCalcShool = this.scenarioContext.getVariable('calcShoolName');
        const actualCalcShool = await this.zealDetailsPage.getTtcalcShool();

        // Ttcalc Shool in UI may have additional "(CIF File Name)" suffix
        if (actualCalcShool.includes(expectedCalcShool) || actualCalcShool === expectedCalcShool) {
            CSReporter.pass(`Ttcalc Shool matches: ${actualCalcShool}`);
        } else {
            throw new Error(`Ttcalc Shool mismatch: Expected=${expectedCalcShool}, Actual=${actualCalcShool}`);
        }
    }

    @CSBDDStepDef('Account Manager in Summary should match stored value')
    async verifyAccountManagerInSummary(): Promise<void> {
        const expectedAdmin = this.scenarioContext.getVariable('administrator');
        const actualAdmin = await this.zealDetailsPage.getAdministratorValue();

        if (actualAdmin === expectedAdmin) {
            CSReporter.pass(`Account Manager matches: ${actualAdmin}`);
        } else {
            throw new Error(`Account Manager mismatch: Expected=${expectedAdmin}, Actual=${actualAdmin}`);
        }
    }

    @CSBDDStepDef('I verify all Summary fields match database values')
    async verifyAllSummaryFieldsMatchDatabase(): Promise<void> {
        CSReporter.info('Verifying all Summary section fields against database values');

        // Zeal ID
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealDetailsPage.getZealId();
        if (actualZealId !== expectedZealId) {
            throw new Error(`Zeal ID mismatch: Expected=${expectedZealId}, Actual=${actualZealId}`);
        }
        CSReporter.info(`Zeal ID verified: ${actualZealId}`);

        // Zeal Key
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealDetailsPage.getZealKey();
        if (actualZealKey !== expectedZealKey) {
            throw new Error(`Zeal Key mismatch: Expected=${expectedZealKey}, Actual=${actualZealKey}`);
        }
        CSReporter.info(`Zeal Key verified: ${actualZealKey}`);

        // Zeal Name
        const expectedZealName = this.scenarioContext.getVariable('zealName');
        const actualZealName = await this.zealDetailsPage.getZealName();
        if (actualZealName !== expectedZealName) {
            throw new Error(`Zeal Name mismatch: Expected=${expectedZealName}, Actual=${actualZealName}`);
        }
        CSReporter.info(`Zeal Name verified: ${actualZealName}`);

        // Zzzt Seggregation
        const expectedZzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');
        const actualZzztAbbrev = await this.zealDetailsPage.getZzztSeggregation();
        if (actualZzztAbbrev !== expectedZzztAbbrev) {
            throw new Error(`Zzzt Seggregation mismatch: Expected=${expectedZzztAbbrev}, Actual=${actualZzztAbbrev}`);
        }
        CSReporter.info(`Zzzt Seggregation verified: ${actualZzztAbbrev}`);

        // Premisis Description
        const expectedPremisisDesc = this.scenarioContext.getVariable('premisisDescription');
        const actualPremisisDesc = await this.zealDetailsPage.getPremisisDescription();
        if (actualPremisisDesc !== expectedPremisisDesc) {
            throw new Error(`Premisis Description mismatch: Expected=${expectedPremisisDesc}, Actual=${actualPremisisDesc}`);
        }
        CSReporter.info(`Premisis Description verified: ${actualPremisisDesc}`);

        // Inductor Group
        const expectedInductorGroup = this.scenarioContext.getVariable('inductorGroup');
        const actualInductorGroup = await this.zealDetailsPage.getInductorGroup();
        if (actualInductorGroup !== expectedInductorGroup) {
            throw new Error(`Inductor Group mismatch: Expected=${expectedInductorGroup}, Actual=${actualInductorGroup}`);
        }
        CSReporter.info(`Inductor Group verified: ${actualInductorGroup}`);

        // Kindness Circle
        const expectedKindnessCircle = this.scenarioContext.getVariable('kindnessCircle');
        const actualKindnessCircle = await this.zealDetailsPage.getKindnessCircle();
        if (actualKindnessCircle !== expectedKindnessCircle) {
            throw new Error(`Kindness Circle mismatch: Expected=${expectedKindnessCircle}, Actual=${actualKindnessCircle}`);
        }
        CSReporter.info(`Kindness Circle verified: ${actualKindnessCircle}`);

        // Ttcalc Shool
        const expectedCalcShool = this.scenarioContext.getVariable('calcShoolName');
        const actualCalcShool = await this.zealDetailsPage.getTtcalcShool();
        if (!actualCalcShool.includes(expectedCalcShool) && actualCalcShool !== expectedCalcShool) {
            throw new Error(`Ttcalc Shool mismatch: Expected=${expectedCalcShool}, Actual=${actualCalcShool}`);
        }
        CSReporter.info(`Ttcalc Shool verified: ${actualCalcShool}`);

        // Account Manager (Administrator)
        const expectedAdmin = this.scenarioContext.getVariable('administrator');
        const actualAdmin = await this.zealDetailsPage.getAdministratorValue();
        if (actualAdmin !== expectedAdmin) {
            throw new Error(`Account Manager mismatch: Expected=${expectedAdmin}, Actual=${actualAdmin}`);
        }
        CSReporter.info(`Account Manager verified: ${actualAdmin}`);

        CSReporter.pass('All Summary fields verified against database values');
    }

    // ===================================================================
    // SETTINGS SECTION STEPS
    // ===================================================================

    @CSBDDStepDef('Use Sketchmark Replacement should show {string}')
    async verifyUseSketchmarkReplacementValue(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows: ${actualValue}`);
        } else {
            throw new Error(`Use Sketchmark Replacement mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('Output Ttcalc File should show {string}')
    async verifyOutputTtcalcFileValue(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getOutputTtcalcFileValue();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`Output Ttcalc File shows: ${actualValue}`);
        } else {
            throw new Error(`Output Ttcalc File mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I check Use Sketchmark Replacement checkbox')
    async checkUseSketchmarkReplacement(): Promise<void> {
        await this.zealDetailsPage.checkUseSketchmarkReplacement();
    }

    @CSBDDStepDef('I uncheck Use Sketchmark Replacement checkbox')
    async uncheckUseSketchmarkReplacement(): Promise<void> {
        await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
    }

    @CSBDDStepDef('I check Output Ttcalc File checkbox')
    async checkOutputTtcalcFile(): Promise<void> {
        await this.zealDetailsPage.checkOutputTtcalcFile();
    }

    @CSBDDStepDef('I uncheck Output Ttcalc File checkbox')
    async uncheckOutputTtcalcFile(): Promise<void> {
        await this.zealDetailsPage.uncheckOutputTtcalcFile();
    }

    @CSBDDStepDef('I select FFX Inductor Type {string}')
    async selectFfxInductorType(inductorType: string): Promise<void> {
        const resolvedInductorType = CSValueResolver.resolve(inductorType, this.context);
        await this.zealDetailsPage.selectFfxInductorType(resolvedInductorType);
    }

    @CSBDDStepDef('FFX Inductor Type dropdown should show {string}')
    async verifyFfxInductorTypeSelected(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getSelectedFfxInductorType();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`FFX Inductor Type shows: ${actualValue}`);
        } else {
            throw new Error(`FFX Inductor Type mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify FFX Inductor Type options against database')
    async verifyFfxInductorTypeOptionsAgainstDatabase(): Promise<void> {
        const dbOptions = await TTTFDatabaseHelper.getFfxInductorOptions();
        const uiOptions = await this.zealDetailsPage.getFfxInductorTypeOptions();

        const missingInUI = dbOptions.filter(opt => !uiOptions.includes(opt));
        if (missingInUI.length > 0) {
            throw new Error(`FFX Inductor Type options missing in UI: ${missingInUI.join(', ')}`);
        }

        CSReporter.pass(`All ${dbOptions.length} FFX Inductor Type options verified`);
    }

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES STEPS
    // ===================================================================

    @CSBDDStepDef('No Scattered Mmtes message should be visible')
    async verifyNoScatteredMmtesMessage(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isNoScatteredMmtesMessageVisible();
        if (isVisible) {
            CSReporter.pass('No Scattered Mmtes message is visible');
        } else {
            throw new Error('No Scattered Mmtes message is not visible');
        }
    }

    @CSBDDStepDef('I wait for Add Remove button to be visible')
    async waitForAddRemoveButton(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isAddRemoveButtonVisible();
        if (isVisible) {
            CSReporter.pass('Add/Remove button is visible');
        } else {
            throw new Error('Add/Remove button is not visible after waiting');
        }
    }

    @CSBDDStepDef('I verify Associated Scattered Mmtes column headers')
    async verifyAssociatedScatteredMmtesColumnHeaders(): Promise<void> {
        await this.zealDetailsPage.verifyAssociatedScatteredMmtesColumnHeaders();
    }

    @CSBDDStepDef('I click Add Remove button')
    async clickAddRemoveButton(): Promise<void> {
        await this.zealDetailsPage.clickAddRemoveButton();
    }

    @CSBDDStepDef('Select Options modal should be visible')
    async verifySelectOptionsModalVisible(): Promise<void> {
        await this.scatteredMmtesModalPage.verifySelectOptionsModalDisplayed();
    }

    @CSBDDStepDef('X Close button should be visible')
    async verifyCloseButtonVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isCloseButtonVisible();
        if (isVisible) {
            CSReporter.pass('X Close button is visible');
        } else {
            throw new Error('X Close button is not visible');
        }
    }

    @CSBDDStepDef('Select items text should show {string}')
    async verifySelectItemsText(expectedText: string): Promise<void> {
        const actualText = await this.scatteredMmtesModalPage.getSelectItemsText();
        if (actualText.includes(expectedText)) {
            CSReporter.pass(`Select items text shows: ${actualText}`);
        } else {
            throw new Error(`Expected "${expectedText}", got "${actualText}"`);
        }
    }

    @CSBDDStepDef('Selected count should show {string}')
    async verifySelectedCount(expectedCount: string): Promise<void> {
        const actualCount = await this.scatteredMmtesModalPage.getSelectedCount();
        if (actualCount.includes(expectedCount)) {
            CSReporter.pass(`Selected count shows: ${actualCount}`);
        } else {
            throw new Error(`Expected "${expectedCount}", got "${actualCount}"`);
        }
    }

    @CSBDDStepDef('Find by input field should be visible')
    async verifyFindByInputVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isFindByInputVisible();
        if (isVisible) {
            CSReporter.pass('Find by input field is visible');
        } else {
            throw new Error('Find by input field is not visible');
        }
    }

    @CSBDDStepDef('Go button should be visible')
    async verifyGoButtonVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isGoButtonVisible();
        if (isVisible) {
            CSReporter.pass('Go button is visible');
        } else {
            throw new Error('Go button is not visible');
        }
    }

    @CSBDDStepDef('Reset button should be visible')
    async verifyResetButtonVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isResetButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reset button is visible');
        } else {
            throw new Error('Reset button is not visible');
        }
    }

    @CSBDDStepDef('Pagination should be visible')
    async verifyPaginationVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isPaginationVisible();
        if (isVisible) {
            CSReporter.pass('Pagination is visible');
        } else {
            throw new Error('Pagination is not visible');
        }
    }

    @CSBDDStepDef('Previous panel button should be visible')
    async verifyPreviousButtonVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isPreviousButtonVisible();
        if (isVisible) {
            CSReporter.pass('Previous panel button is visible');
        } else {
            throw new Error('Previous panel button is not visible');
        }
    }

    @CSBDDStepDef('Next panel button should be visible')
    async verifyNextButtonVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isNextButtonVisible();
        if (isVisible) {
            CSReporter.pass('Next panel button is visible');
        } else {
            throw new Error('Next panel button is not visible');
        }
    }

    @CSBDDStepDef('Scattered Mmtes table should be visible')
    async verifyScatteredMmtesTableVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isScatteredMmtesTableVisible();
        if (isVisible) {
            CSReporter.pass('Scattered Mmtes table is visible');
        } else {
            throw new Error('Scattered Mmtes table is not visible');
        }
    }

    @CSBDDStepDef('Scattered Mmte Name column should be visible in modal')
    async verifyScatteredMmteNameColumnVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isScatteredMmteNameColumnVisible();
        if (isVisible) {
            CSReporter.pass('Scattered Mmte Name column is visible');
        } else {
            throw new Error('Scattered Mmte Name column is not visible');
        }
    }

    @CSBDDStepDef('Cumulative Mmte Name column should be visible in modal')
    async verifyCumulativeMmteNameColumnVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isCumulativeMmteNameColumnVisible();
        if (isVisible) {
            CSReporter.pass('Cumulative Mmte Name column is visible');
        } else {
            throw new Error('Cumulative Mmte Name column is not visible');
        }
    }

    @CSBDDStepDef('Apply button should be visible in modal')
    async verifyApplyButtonVisibleInModal(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isApplyButtonVisible();
        if (isVisible) {
            CSReporter.pass('Apply button is visible');
        } else {
            throw new Error('Apply button is not visible');
        }
    }

    @CSBDDStepDef('Cancel button should be visible in modal')
    async verifyCancelButtonVisibleInModal(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isCancelButtonVisible();
        if (isVisible) {
            CSReporter.pass('Cancel button is visible');
        } else {
            throw new Error('Cancel button is not visible');
        }
    }

    @CSBDDStepDef('I select scattered mmte {string} in modal')
    async selectScatteredMmteInModal(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        await this.scatteredMmtesModalPage.selectScatteredMmte(resolvedMmteName);
    }

    @CSBDDStepDef('I select all stored scattered mmtes in modal')
    async selectAllStoredScatteredMmtesInModal(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];

        for (const mmteName of mmteNames) {
            await this.scatteredMmtesModalPage.selectScatteredMmte(mmteName);
        }

        CSReporter.pass(`Selected ${mmteNames.length} scattered mmtes in modal`);
    }

    @CSBDDStepDef('I click Apply button in modal')
    async clickApplyButtonInModal(): Promise<void> {
        await this.scatteredMmtesModalPage.clickApplyButton();
        await this.scatteredMmtesModalPage.waitForModalToClose();
    }

    @CSBDDStepDef('I click Cancel button in Scattered Mmtes modal')
    async clickCancelButtonInScatteredMmtesModal(): Promise<void> {
        await this.scatteredMmtesModalPage.clickCancelButton();
    }

    @CSBDDStepDef('Scattered mmtes should be displayed in Associated Scattered Mmtes section')
    async verifyScatteredMmtesDisplayed(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const rowCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (rowCount !== mmteNames.length) {
            throw new Error(`Scattered mmte count mismatch: Expected=${mmteNames.length}, Actual=${rowCount}`);
        }

        for (let i = 0; i < rowCount; i++) {
            const rowData = await this.zealDetailsPage.getScatteredMmteRowData(i);

            // Verify FFX Order
            if (parseInt(rowData.ffxOrder) !== i + 1) {
                throw new Error(`Row ${i} FFX Order mismatch: Expected=${i + 1}, Actual=${rowData.ffxOrder}`);
            }

            // Verify Scattered Mmte Name is in the list
            if (!mmteNames.includes(rowData.scatteredMmteName)) {
                throw new Error(`Unexpected scattered mmte: ${rowData.scatteredMmteName}`);
            }

            CSReporter.info(`Row ${i}: FFX=${rowData.ffxOrder}, Mmte=${rowData.scatteredMmteName}, Cumulative=${rowData.cumulativeMmteName}`);
        }

        CSReporter.pass(`All ${rowCount} scattered mmtes verified`);
    }

    // ===================================================================
    // DISPUTED SCATTERED MMTE STEPS
    // ===================================================================

    @CSBDDStepDef('I click Disputed Select button for row {int}')
    async clickDisputedSelectButton(rowIndex: number): Promise<void> {
        await this.zealDetailsPage.clickDisputedSelectButton(rowIndex);
    }

    @CSBDDStepDef('Add Scattered Mmtes modal should be visible')
    async verifyAddScatteredMmtesModalVisible(): Promise<void> {
        await this.scatteredMmtesModalPage.verifyAddScatteredMmtesModalDisplayed();
    }

    @CSBDDStepDef('I select disputed scattered mmte {string} in modal')
    async selectDisputedScatteredMmteInModal(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(resolvedMmteName);
    }

    @CSBDDStepDef('I enter disputed start date {string} for row {int}')
    async enterDisputedStartDate(date: string, rowIndex: number): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        await this.zealDetailsPage.enterDisputedStartDate(rowIndex, resolvedDate);
    }

    @CSBDDStepDef('I configure disputed scattered mmtes if required')
    async configureDisputedScatteredMmtesIfRequired(): Promise<void> {
        CSReporter.info('Checking if disputed scattered mmtes need to be configured');

        // Get hasDisputedScatteredMmte from test data
        const hasDisputedScatteredMmte = this.scenarioContext.getVariable('hasDisputedScatteredMmte');

        if (!hasDisputedScatteredMmte || hasDisputedScatteredMmte === 'false' || hasDisputedScatteredMmte === false) {
            CSReporter.info('No disputed scattered mmtes required, skipping');
            return;
        }

        CSReporter.info('Disputed scattered mmtes required, processing...');

        // Get the disputed scattered mmtes data from test data
        // Format: { "scatteredMmteName1": { "disputedMmteName": "...", "disputedStartDate": "..." }, ... }
        const disputedMmtesData = this.scenarioContext.getVariable('disputedScatteredMmtes');

        if (!disputedMmtesData || typeof disputedMmtesData !== 'object') {
            CSReporter.warn('No disputed scattered mmtes data found in test data');
            return;
        }

        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[] || [];
        let rowIndex = 1;

        for (const mmteName of mmteNames) {
            const disputedData = disputedMmtesData[mmteName];

            if (disputedData && disputedData.disputedMmteName) {
                CSReporter.info(`Configuring disputed for row ${rowIndex}: ${mmteName}`);

                // Click Disputed Select button for this row
                await this.zealDetailsPage.clickDisputedSelectButton(rowIndex);

                // Verify Add Scattered Mmtes modal is displayed
                await this.scatteredMmtesModalPage.verifyAddScatteredMmtesModalDisplayed();

                // Select the disputed scattered mmte
                await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(disputedData.disputedMmteName);

                // Click Apply button
                await this.scatteredMmtesModalPage.clickApplyButton();
                await this.scatteredMmtesModalPage.waitForModalToClose();

                // Enter disputed start date if provided
                if (disputedData.disputedStartDate) {
                    await this.zealDetailsPage.enterDisputedStartDate(rowIndex, disputedData.disputedStartDate);
                }

                CSReporter.pass(`Configured disputed for row ${rowIndex}: ${disputedData.disputedMmteName}, Date: ${disputedData.disputedStartDate || 'N/A'}`);
            }

            rowIndex++;
        }

        CSReporter.pass('Disputed scattered mmtes configuration complete');
    }

    @CSBDDStepDef('I verify disputed scattered mmtes are displayed correctly')
    async verifyDisputedScatteredMmtesDisplayed(): Promise<void> {
        CSReporter.info('Verifying disputed scattered mmtes are displayed correctly');

        const hasDisputedScatteredMmte = this.scenarioContext.getVariable('hasDisputedScatteredMmte');

        if (!hasDisputedScatteredMmte || hasDisputedScatteredMmte === 'false' || hasDisputedScatteredMmte === false) {
            CSReporter.info('No disputed scattered mmtes to verify');
            return;
        }

        const disputedMmtesData = this.scenarioContext.getVariable('disputedScatteredMmtes');
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[] || [];
        let rowIndex = 0;

        for (const mmteName of mmteNames) {
            const disputedData = disputedMmtesData?.[mmteName];

            if (disputedData && disputedData.disputedMmteName) {
                const rowData = await this.zealDetailsPage.getScatteredMmteRowData(rowIndex);

                // Verify disputed scattered mmte name
                if (!rowData.disputedScatteredMmte.includes(disputedData.disputedMmteName)) {
                    throw new Error(`Row ${rowIndex}: Disputed mmte mismatch. Expected to contain: ${disputedData.disputedMmteName}, Actual: ${rowData.disputedScatteredMmte}`);
                }

                // Verify disputed start date if provided
                if (disputedData.disputedStartDate && rowData.disputedStartDate !== disputedData.disputedStartDate) {
                    throw new Error(`Row ${rowIndex}: Disputed date mismatch. Expected: ${disputedData.disputedStartDate}, Actual: ${rowData.disputedStartDate}`);
                }

                CSReporter.info(`Row ${rowIndex}: Disputed verified - ${rowData.disputedScatteredMmte}, ${rowData.disputedStartDate}`);
            }

            rowIndex++;
        }

        CSReporter.pass('All disputed scattered mmtes verified');
    }

    // ===================================================================
    // ACTION BUTTON STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Save button should be enabled')
    async verifyZealSaveButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isSaveButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Zeal Save button is enabled');
        } else {
            throw new Error('Zeal Save button is not enabled');
        }
    }

    @CSBDDStepDef('Save button should be disabled')
    async verifySaveButtonDisabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isSaveButtonEnabled();
        if (!isEnabled) {
            CSReporter.pass('Save button is disabled');
        } else {
            throw new Error('Save button is not disabled');
        }
    }

    @CSBDDStepDef('I click Save button')
    async clickSaveButton(): Promise<void> {
        await this.zealDetailsPage.clickSaveButton();
    }

    @CSBDDStepDef('I should see save success message')
    async verifySaveSuccessMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        const zealId = this.scenarioContext.getVariable('zealId');

        if (messageText.includes('saved') || messageText.includes(zealId)) {
            CSReporter.pass(`Save success message: ${messageText}`);
        } else {
            throw new Error(`Expected save success message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I should see pending approval alert')
    async verifyPendingApprovalAlert(): Promise<void> {
        const feedbackText = await this.zealDetailsPage.getFeedbackMessageText();

        if (feedbackText.includes('pending approval')) {
            CSReporter.pass(`Pending approval alert: ${feedbackText}`);
        } else {
            throw new Error(`Expected pending approval alert, got: ${feedbackText}`);
        }
    }

    @CSBDDStepDef('View Changes link should be visible')
    async verifyViewChangesLinkVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isViewChangesLinkVisible();
        if (isVisible) {
            CSReporter.pass('View Changes link is visible');
        } else {
            throw new Error('View Changes link is not visible');
        }
    }

    @CSBDDStepDef('I click View Changes link')
    async clickViewChangesLink(): Promise<void> {
        await this.zealDetailsPage.clickViewChangesLink();
    }

    // ===================================================================
    // CHANGES TAB STEPS
    // ===================================================================

    @CSBDDStepDef('Changes section should be visible')
    async verifyChangesSectionVisible(): Promise<void> {
        await this.changesHistoryPage.verifyChangesHeaderDisplayed();
    }

    @CSBDDStepDef('I verify Changes table column headers')
    async verifyChangesTableColumnHeaders(): Promise<void> {
        await this.changesHistoryPage.verifyChangesTableColumnHeaders();
    }

    @CSBDDStepDef('Changes table should show pending changes')
    async verifyChangesTableHasData(): Promise<void> {
        const rowCount = await this.changesHistoryPage.getChangesRowCount();
        if (rowCount > 0) {
            CSReporter.pass(`Changes table has ${rowCount} rows`);
        } else {
            throw new Error('Changes table is empty');
        }
    }

    @CSBDDStepDef('I verify changes data matches added scattered mmtes')
    async verifyChangesDataMatchesScatteredMmtes(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const changesData = await this.changesHistoryPage.getAllChangesData();

        for (const change of changesData) {
            if (change.description !== 'Add Scattered Mmte') {
                throw new Error(`Unexpected change description: ${change.description}`);
            }

            if (!mmteNames.includes(change.newValue)) {
                throw new Error(`Unexpected scattered mmte in changes: ${change.newValue}`);
            }

            CSReporter.info(`Change: ${change.description} - ${change.newValue}, Modified By: ${change.modifiedBy}`);
        }

        CSReporter.pass(`All ${changesData.length} changes verified`);
    }

    @CSBDDStepDef('Cancel Changes button should be visible')
    async verifyCancelChangesButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isCancelChangesButtonVisible();
        if (isVisible) {
            CSReporter.pass('Cancel Changes button is visible');
        } else {
            throw new Error('Cancel Changes button is not visible');
        }
    }

    @CSBDDStepDef('Approve button should be visible')
    async verifyApproveButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isApproveButtonVisible();
        if (isVisible) {
            CSReporter.pass('Approve button is visible');
        } else {
            throw new Error('Approve button is not visible');
        }
    }

    @CSBDDStepDef('Reject button should be visible')
    async verifyRejectButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isRejectButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reject button is visible');
        } else {
            throw new Error('Reject button is not visible');
        }
    }

    @CSBDDStepDef('I click Approve button')
    async clickApproveButton(): Promise<void> {
        await this.changesHistoryPage.clickApproveButton();
    }

    @CSBDDStepDef('I click Reject button')
    async clickRejectButton(): Promise<void> {
        await this.changesHistoryPage.clickRejectButton();
    }

    @CSBDDStepDef('Changes table should be empty after approval')
    async verifyChangesTableEmpty(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after approval');
        } else {
            throw new Error('Changes table is not empty after approval');
        }
    }

    // ===================================================================
    // HISTORY TAB STEPS
    // ===================================================================

    @CSBDDStepDef('History section should be visible')
    async verifyHistorySectionVisible(): Promise<void> {
        await this.changesHistoryPage.verifyHistoryHeaderDisplayed();
    }

    @CSBDDStepDef('I verify History table column headers')
    async verifyHistoryTableColumnHeaders(): Promise<void> {
        await this.changesHistoryPage.verifyHistoryTableColumnHeaders();
    }

    @CSBDDStepDef('History table should show approved changes')
    async verifyHistoryTableHasData(): Promise<void> {
        const rowCount = await this.changesHistoryPage.getHistoryRowCount();
        if (rowCount > 0) {
            CSReporter.pass(`History table has ${rowCount} rows`);
        } else {
            throw new Error('History table is empty');
        }
    }

    @CSBDDStepDef('I verify history data matches approved scattered mmtes')
    async verifyHistoryDataMatchesScatteredMmtes(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const historyData = await this.changesHistoryPage.getAllHistoryData();

        for (const history of historyData) {
            if (history.description !== 'Add Scattered Mmte') {
                throw new Error(`Unexpected history description: ${history.description}`);
            }

            if (!mmteNames.includes(history.newValue)) {
                throw new Error(`Unexpected scattered mmte in history: ${history.newValue}`);
            }

            CSReporter.info(`History: ${history.description} - ${history.newValue}, Approved By: ${history.approvedBy}`);
        }

        CSReporter.pass(`All ${historyData.length} history entries verified`);
    }

    // ===================================================================
    // BROWSER CONTEXT / RE-AUTHENTICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I clear browser context for re-authentication')
    async clearBrowserContextForReauth(): Promise<void> {
        CSReporter.info('Clearing browser context for re-authentication (switching user)');
        const browserManager = CSBrowserManager.getInstance();
        await browserManager.clearContextAndReauthenticate();
        CSReporter.pass('Browser context cleared, ready for new user login');
    }

    // ===================================================================
    // PENDING APPROVALS PAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I navigate to Pending Approvals page')
    async navigateToPendingApprovalsPage(): Promise<void> {
        await this.navigationPage.clickMenuItem('Pending Approvals');
        await this.pendingApprovalsPage.verifyPageDisplayed();
    }

    @CSBDDStepDef('Pending Approvals page should be displayed')
    async verifyPendingApprovalsPageDisplayed(): Promise<void> {
        await this.pendingApprovalsPage.verifyPageDisplayed();
    }

    @CSBDDStepDef('I find and click View link for stored zeal')
    async findAndClickViewForStoredZeal(): Promise<void> {
        const zealName = this.scenarioContext.getVariable('zealName');
        await this.pendingApprovalsPage.clickViewLinkByZealName(zealName);
    }

    // ===================================================================
    // DATABASE VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I verify zeal data record exists in database')
    async verifyZealDataRecordExists(): Promise<void> {
        const zealId = this.scenarioContext.getVariable('zealId');
        const zealData = await TTTFDatabaseHelper.getZealDataByZealId(zealId);

        if (!zealData) {
            throw new Error(`Zeal data record not found for zeal ID: ${zealId}`);
        }

        this.scenarioContext.setVariable('zealpremisisDataId', zealData.zealpremisisDataId);
        CSReporter.pass(`Zeal data record exists: zealpremisisDataId=${zealData.zealpremisisDataId}`);
    }

    @CSBDDStepDef('I verify zealpremisis data has correct settings')
    async verifyZealpremisisDataSettings(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const details = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!details) {
            throw new Error(`Zealpremisis data details not found for ID: ${zealpremisisDataId}`);
        }

        CSReporter.info(`Zealpremisis data: sketchmarkFlag=${details.sketchmarkReplacementFlag}, inductorCode=${details.inductorCode}`);
        CSReporter.pass('Zealpremisis data settings verified');
    }

    @CSBDDStepDef('I verify status log shows {string} status')
    async verifyStatusLogStatus(expectedStatus: string): Promise<void> {
        const resolvedStatus = CSValueResolver.resolve(expectedStatus, this.context) as 'AWAITING' | 'APPROVED' | 'REJECTED';
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');

        const isCorrect = await TTTFDatabaseHelper.verifyStatusLogStatus(zealpremisisDataId, resolvedStatus);

        if (isCorrect) {
            CSReporter.pass(`Status log shows ${resolvedStatus} status`);
        } else {
            throw new Error(`Status log does not show ${resolvedStatus} status`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data exists after approval')
    async verifyZealpremisisMmteDataExists(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            throw new Error('No zealpremisis mmte data found after approval');
        }

        CSReporter.pass(`Zealpremisis mmte data exists: ${mmteData.length} records`);
    }

    // ===================================================================
    // PREMISIS-SPECIFIC STEPS
    // ===================================================================

    @CSBDDStepDef('I get premisis for new setup from database')
    async getPremisisForNewSetupFromDatabase(): Promise<void> {
        CSReporter.info('Getting premisis for new setup from database');

        const premisisDetails = await TTTFDatabaseHelper.getPremisisForNewSetup();
        if (!premisisDetails) {
            throw new Error('No premisis available for new setup in database');
        }

        this.scenarioContext.setVariable('zealId', premisisDetails.zealId);
        this.scenarioContext.setVariable('zealKey', premisisDetails.zealKey);
        this.scenarioContext.setVariable('zealName', premisisDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', premisisDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', premisisDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', premisisDetails.zzztSeggregation);
        this.scenarioContext.setVariable('premisisDescription', premisisDetails.premisisDescription);
        this.scenarioContext.setVariable('calcShoolName', premisisDetails.calcShoolName);
        this.scenarioContext.setVariable('administrator', premisisDetails.administrator);
        this.scenarioContext.setVariable('zzztId', premisisDetails.zzztId);

        CSReporter.pass(`Retrieved premisis for new setup: ID=${premisisDetails.zealId}, Zzzt Abbrev=${premisisDetails.zzztSeggregation}`);
    }

    @CSBDDStepDef('I should see Premisis Details page')
    async verifyPremisisDetailsPage(): Promise<void> {
        await this.zealDetailsPage.verifyPremisisDetailsPageDisplayed();
    }

    @CSBDDStepDef('I should see Edit Premisis page')
    async verifyEditPremisisPage(): Promise<void> {
        await this.zealDetailsPage.verifyEditPremisisPageDisplayed();
    }

    @CSBDDStepDef('Output Ttcalc File checkbox should be disabled for Premisis')
    async verifyOutputCalcFileDisabledForPremisis(): Promise<void> {
        const isDisabled = await this.zealDetailsPage.isOutputTtcalcFileCheckboxDisabled();
        if (isDisabled) {
            CSReporter.pass('Output Ttcalc File checkbox is disabled for Premisis');
        } else {
            throw new Error('Output Ttcalc File checkbox should be disabled for Premisis');
        }
    }

    @CSBDDStepDef('FFX Inductor Type dropdown should be disabled for Premisis')
    async verifyFfxInductorTypeDisabledForPremisis(): Promise<void> {
        const isDisabled = await this.zealDetailsPage.isFfxInductorTypeDropdownDisabled();
        if (isDisabled) {
            CSReporter.pass('FFX Inductor Type dropdown is disabled for Premisis');
        } else {
            throw new Error('FFX Inductor Type dropdown should be disabled for Premisis');
        }
    }

    @CSBDDStepDef('I should see save success message for Premisis')
    async verifySaveSuccessMessageForPremisis(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        const zzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');

        if (messageText.includes('saved') || messageText.includes(zzztAbbrev)) {
            CSReporter.pass(`Save success message for Premisis: ${messageText}`);
        } else {
            throw new Error(`Expected save success message for Premisis, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I verify zzzt data record exists in database')
    async verifyZzztDataRecordExists(): Promise<void> {
        const zzztId = this.scenarioContext.getVariable('zzztId') || this.scenarioContext.getVariable('zealId');
        const zzztData = await TTTFDatabaseHelper.getZzztDataByZzztId(zzztId);

        if (!zzztData) {
            throw new Error(`Zzzt data record not found for zzzt ID: ${zzztId}`);
        }

        this.scenarioContext.setVariable('zealpremisisDataId', zzztData.zealpremisisDataId);
        CSReporter.pass(`Zzzt data record exists: zealpremisisDataId=${zzztData.zealpremisisDataId}`);
    }

    @CSBDDStepDef('I verify zealpremisis data has correct settings for Premisis')
    async verifyZealpremisisDataSettingsForPremisis(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const details = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!details) {
            throw new Error(`Zealpremisis data details not found for ID: ${zealpremisisDataId}`);
        }

        // For Premisis, Output Ttcalc File should be disabled (null/empty inductor code)
        CSReporter.info(`Premisis zealpremisis data: sketchmarkFlag=${details.sketchmarkReplacementFlag}, inductorCode=${details.inductorCode || 'N/A'}`);
        CSReporter.pass('Premisis zealpremisis data settings verified');
    }

    // ===================================================================
    // REJECTION FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('Review Reject Email modal should be visible')
    async verifyRejectEmailModalVisible(): Promise<void> {
        await this.changesHistoryPage.verifyRejectEmailModalDisplayed();
    }

    @CSBDDStepDef('Reject comment textarea should be visible')
    async verifyRejectCommentTextareaVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isRejectCommentTextareaVisible();
        if (isVisible) {
            CSReporter.pass('Reject comment textarea is visible');
        } else {
            throw new Error('Reject comment textarea is not visible');
        }
    }

    @CSBDDStepDef('Send button should be visible')
    async verifySendButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isSendButtonVisible();
        if (isVisible) {
            CSReporter.pass('Send button is visible');
        } else {
            throw new Error('Send button is not visible');
        }
    }

    @CSBDDStepDef('I enter rejection comment {string}')
    async enterRejectionComment(comment: string): Promise<void> {
        const resolvedComment = CSValueResolver.resolve(comment, this.context);
        await this.changesHistoryPage.enterRejectComment(resolvedComment);
    }

    @CSBDDStepDef('I click Send button in Reject modal')
    async clickSendButtonInRejectModal(): Promise<void> {
        await this.changesHistoryPage.clickSendButton();
    }

    @CSBDDStepDef('Rejection email sent message should be displayed')
    async verifyRejectionEmailSentMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Rejection') && messageText.includes('sent')) {
            CSReporter.pass(`Rejection email sent message: ${messageText}`);
        } else {
            throw new Error(`Expected rejection email sent message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('Changes table should be empty after rejection')
    async verifyChangesTableEmptyAfterRejection(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after rejection');
        } else {
            throw new Error('Changes table is not empty after rejection');
        }
    }

    @CSBDDStepDef('History table should show no data')
    async verifyHistoryTableNoData(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isHistoryNoDataVisible();
        if (isNoData) {
            CSReporter.pass('History table shows no data');
        } else {
            throw new Error('History table should show no data');
        }
    }

    @CSBDDStepDef('I verify status log is cleared after rejection')
    async verifyStatusLogClearedAfterRejection(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const statusLog = await TTTFDatabaseHelper.getZealpremisisStatusLog(zealpremisisDataId);

        if (statusLog.length === 0) {
            CSReporter.pass('Status log is cleared after rejection');
        } else {
            throw new Error(`Status log should be empty after rejection, found ${statusLog.length} records`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data does not exist after rejection')
    async verifyZealpremisisMmteDataNotExistsAfterRejection(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            CSReporter.pass('No zealpremisis mmte data exists after rejection');
        } else {
            throw new Error(`Zealpremisis mmte data should not exist after rejection, found ${mmteData.length} records`);
        }
    }

    // ===================================================================
    // CANCEL FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('I click Cancel Changes button')
    async clickCancelChangesButton(): Promise<void> {
        await this.changesHistoryPage.clickCancelChangesButton();
    }

    @CSBDDStepDef('Cancel changes success message should be displayed')
    async verifyCancelChangesSuccessMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Cancelled') || messageText.includes('cancelled')) {
            CSReporter.pass(`Cancel changes success message: ${messageText}`);
        } else {
            throw new Error(`Expected cancel changes success message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('Changes table should be empty after cancel')
    async verifyChangesTableEmptyAfterCancel(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after cancel');
        } else {
            throw new Error('Changes table is not empty after cancel');
        }
    }

    @CSBDDStepDef('I verify status log is cleared after cancel')
    async verifyStatusLogClearedAfterCancel(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const statusLog = await TTTFDatabaseHelper.getZealpremisisStatusLog(zealpremisisDataId);

        if (statusLog.length === 0) {
            CSReporter.pass('Status log is cleared after cancel');
        } else {
            throw new Error(`Status log should be empty after cancel, found ${statusLog.length} records`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data does not exist after cancel')
    async verifyZealpremisisMmteDataNotExistsAfterCancel(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            CSReporter.pass('No zealpremisis mmte data exists after cancel');
        } else {
            throw new Error(`Zealpremisis mmte data should not exist after cancel, found ${mmteData.length} records`);
        }
    }

    // ===================================================================
    // EDIT NAVIGATION STEPS (SCENARIO_08, 09A)
    // ===================================================================

    @CSBDDStepDef('I get zeal for edit navigation from database')
    async getZealForEditNavigationFromDatabase(): Promise<void> {
        CSReporter.info('Getting zeal for edit navigation from database');

        const zealDetails = await TTTFDatabaseHelper.getZealForEditNavigation();
        if (!zealDetails) {
            throw new Error('No zeal available for edit navigation in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);

        CSReporter.pass(`Retrieved zeal for edit navigation: ID=${zealDetails.zealId}, Key=${zealDetails.zealKey}`);
    }

    @CSBDDStepDef('I get premisis for edit navigation from database')
    async getPremisisForEditNavigationFromDatabase(): Promise<void> {
        CSReporter.info('Getting premisis for edit navigation from database');

        const premisisDetails = await TTTFDatabaseHelper.getPremisisForEditNavigation();
        if (!premisisDetails) {
            throw new Error('No premisis available for edit navigation in database');
        }

        this.scenarioContext.setVariable('zealId', premisisDetails.zealId);
        this.scenarioContext.setVariable('zealKey', premisisDetails.zealKey);
        this.scenarioContext.setVariable('zealName', premisisDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', premisisDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', premisisDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', premisisDetails.zzztSeggregation);
        this.scenarioContext.setVariable('zzztId', premisisDetails.zzztId);

        CSReporter.pass(`Retrieved premisis for edit navigation: ID=${premisisDetails.zealId}, ZzztAbbrev=${premisisDetails.zzztSeggregation}`);
    }

    @CSBDDStepDef('I uncheck Include Premisis in results checkbox')
    async uncheckIncludePremisisInResultsCheckbox(): Promise<void> {
        await this.zealPremisisPage.uncheckIncludePremisisCheckbox();
    }

    @CSBDDStepDef('Search results should show type {string}')
    async verifySearchResultsType(expectedType: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(expectedType, this.context);
        const actualType = await this.zealPremisisPage.getSearchResultTypeValue(1);

        if (actualType === resolvedType) {
            CSReporter.pass(`Search results show correct type: ${actualType}`);
        } else {
            throw new Error(`Expected type "${resolvedType}", got "${actualType}"`);
        }
    }

    @CSBDDStepDef('Search results should show stored zeal ID')
    async verifySearchResultsShowStoredZealId(): Promise<void> {
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealPremisisPage.getSearchResultZealIdValue(1);

        if (actualZealId === expectedZealId) {
            CSReporter.pass(`Search results show correct zeal ID: ${actualZealId}`);
        } else {
            throw new Error(`Expected zeal ID "${expectedZealId}", got "${actualZealId}"`);
        }
    }

    @CSBDDStepDef('Search results should show stored zeal key')
    async verifySearchResultsShowStoredZealKey(): Promise<void> {
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealPremisisPage.getSearchResultZealKeyValue(1);

        if (actualZealKey === expectedZealKey) {
            CSReporter.pass(`Search results show correct zeal key: ${actualZealKey}`);
        } else {
            throw new Error(`Expected zeal key "${expectedZealKey}", got "${actualZealKey}"`);
        }
    }

    @CSBDDStepDef('I click Cancel button')
    async clickCancelButton(): Promise<void> {
        await this.zealDetailsPage.clickCancelButton();
    }

    @CSBDDStepDef('Warning popup should be displayed')
    async verifyWarningPopupDisplayed(): Promise<void> {
        await this.zealDetailsPage.verifyWarningPopupDisplayed();
    }

    @CSBDDStepDef('Warning popup should show unsaved changes message')
    async verifyWarningPopupUnsavedChangesMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getWarningPopupMessage();
        if (messageText.includes('changes are not saved') || messageText.includes('save before')) {
            CSReporter.pass(`Warning popup shows unsaved changes message: ${messageText}`);
        } else {
            throw new Error(`Expected unsaved changes warning, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('OK button should be visible in warning popup')
    async verifyOkButtonVisibleInWarningPopup(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isWarningPopupOkButtonVisible();
        if (isVisible) {
            CSReporter.pass('OK button is visible in warning popup');
        } else {
            throw new Error('OK button is not visible in warning popup');
        }
    }

    @CSBDDStepDef('I click OK button in warning popup')
    async clickOkButtonInWarningPopup(): Promise<void> {
        await this.zealDetailsPage.clickWarningPopupOkButton();
    }

    @CSBDDStepDef('I click Edit link in Action column for row {int}')
    async clickEditLinkInActionColumn(rowIndex: number): Promise<void> {
        await this.zealPremisisPage.clickEditLinkInActionColumn(rowIndex);
    }

    @CSBDDStepDef('I should see Edit Zeal page directly')
    async verifyEditZealPageDirectly(): Promise<void> {
        await this.zealDetailsPage.verifyEditZealPageDisplayed();
        CSReporter.pass('Navigated directly to Edit Zeal page via Action column');
    }

    @CSBDDStepDef('I should see Edit Premisis page directly')
    async verifyEditPremisisPageDirectly(): Promise<void> {
        await this.zealDetailsPage.verifyEditPremisisPageDisplayed();
        CSReporter.pass('Navigated directly to Edit Premisis page via Action column');
    }

    // ===================================================================
    // EXISTING ZEAL UPDATE STEPS (SCENARIO_09B)
    // ===================================================================

    @CSBDDStepDef('I get existing zeal with scattered mmtes from database')
    async getExistingZealWithScatteredMmtes(): Promise<void> {
        CSReporter.info('Getting existing zeal with scattered mmtes from database');

        const zealDetails = await TTTFDatabaseHelper.getExistingZealWithScatteredMmtes();
        if (!zealDetails) {
            throw new Error('No existing zeal with scattered mmtes found in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);
        this.scenarioContext.setVariable('sketchmarkFlag', zealDetails.sketchmarkFlag);
        this.scenarioContext.setVariable('inductorCode', zealDetails.inductorCode);
        this.scenarioContext.setVariable('existingScatteredMmtes', zealDetails.scatteredMmtes);

        CSReporter.pass(`Retrieved existing zeal: ID=${zealDetails.zealId}, Mmtes=${zealDetails.scatteredMmtes?.length || 0}`);
    }

    @CSBDDStepDef('I get replacement scattered mmtes from database')
    async getReplacementScatteredMmtes(): Promise<void> {
        CSReporter.info('Getting replacement scattered mmtes from database');

        const existingMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];
        const existingMmteNames = existingMmtes.map((r: any) => r.scatteredMmteName);

        const replacementMmtes = await TTTFDatabaseHelper.getReplacementScatteredMmtes(existingMmteNames);
        if (!replacementMmtes || replacementMmtes.length === 0) {
            throw new Error('No replacement scattered mmtes found in database');
        }

        this.scenarioContext.setVariable('replacementScatteredMmtes', replacementMmtes);
        CSReporter.pass(`Retrieved ${replacementMmtes.length} replacement scattered mmtes`);
    }

    @CSBDDStepDef('I verify existing scattered mmtes match database')
    async verifyExistingScatteredMmtesMatchDatabase(): Promise<void> {
        const expectedMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];
        const actualCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (actualCount === expectedMmtes.length) {
            CSReporter.pass(`Existing scattered mmtes match database: ${actualCount} mmtes`);
        } else {
            throw new Error(`Expected ${expectedMmtes.length} scattered mmtes, found ${actualCount}`);
        }
    }

    @CSBDDStepDef('I toggle Use Sketchmark Replacement checkbox')
    async toggleUseSketchmarkReplacementCheckbox(): Promise<void> {
        const currentFlag = this.scenarioContext.getVariable('sketchmarkFlag');
        if (currentFlag === 'Y') {
            await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
        } else {
            await this.zealDetailsPage.checkUseSketchmarkReplacement();
        }
        CSReporter.pass('Toggled Use Sketchmark Replacement checkbox');
    }

    @CSBDDStepDef('I update FFX Inductor Type to different value')
    async updateFfxInductorTypeToDifferentValue(): Promise<void> {
        const currentInductorCode = this.scenarioContext.getVariable('inductorCode');
        const newInductorType = await TTTFDatabaseHelper.getDifferentFfxInductorType(currentInductorCode);

        if (newInductorType) {
            await this.zealDetailsPage.checkOutputTtcalcFile();
            await this.zealDetailsPage.selectFfxInductorType(newInductorType);
            this.scenarioContext.setVariable('newInductorCode', newInductorType);
            CSReporter.pass(`Updated FFX Inductor Type to: ${newInductorType}`);
        } else {
            CSReporter.info('No different FFX Inductor Type available, skipping update');
        }
    }

    @CSBDDStepDef('I unselect existing scattered mmtes in modal')
    async unselectExistingScatteredMmtesInModal(): Promise<void> {
        const existingMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];

        for (const mmte of existingMmtes) {
            await this.scatteredMmtesModalPage.searchScatteredMmte(mmte.scatteredMmteName);
            await this.scatteredMmtesModalPage.unselectScatteredMmte(mmte.scatteredMmteName);
        }

        CSReporter.pass(`Unselected ${existingMmtes.length} existing scattered mmtes`);
    }

    @CSBDDStepDef('I select replacement scattered mmtes in modal')
    async selectReplacementScatteredMmtesInModal(): Promise<void> {
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];

        for (const mmte of replacementMmtes) {
            await this.scatteredMmtesModalPage.searchScatteredMmte(mmte.scatteredMmteName);
            await this.scatteredMmtesModalPage.selectScatteredMmte(mmte.scatteredMmteName);
        }

        CSReporter.pass(`Selected ${replacementMmtes.length} replacement scattered mmtes`);
    }

    @CSBDDStepDef('Updated scattered mmtes should be displayed in Associated Scattered Mmtes section')
    async verifyUpdatedScatteredMmtesDisplayed(): Promise<void> {
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];
        const actualCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (actualCount === replacementMmtes.length) {
            CSReporter.pass(`Updated scattered mmtes displayed: ${actualCount} mmtes`);
        } else {
            throw new Error(`Expected ${replacementMmtes.length} scattered mmtes, found ${actualCount}`);
        }
    }

    @CSBDDStepDef('Changes table should show update changes')
    async verifyChangesTableShowsUpdateChanges(): Promise<void> {
        const changesData = await this.changesHistoryPage.getAllChangesData();

        if (changesData.length > 0) {
            CSReporter.pass(`Changes table shows ${changesData.length} update changes`);
        } else {
            throw new Error('Changes table should show update changes');
        }
    }

    @CSBDDStepDef('Approve Email modal should be visible')
    async verifyApproveEmailModalVisible(): Promise<void> {
        await this.changesHistoryPage.verifyApproveEmailModalDisplayed();
    }

    @CSBDDStepDef('I click Send button in Approve modal')
    async clickSendButtonInApproveModal(): Promise<void> {
        await this.changesHistoryPage.clickSendButtonInApproveModal();
    }

    @CSBDDStepDef('Approval email sent message should be displayed')
    async verifyApprovalEmailSentMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Approval') && messageText.includes('sent')) {
            CSReporter.pass(`Approval email sent message: ${messageText}`);
        } else {
            throw new Error(`Expected approval email sent message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I verify updated scattered mmtes in database')
    async verifyUpdatedScatteredMmtesInDatabase(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];

        if (mmteData.length === replacementMmtes.length) {
            CSReporter.pass(`Updated scattered mmtes verified in database: ${mmteData.length} mmtes`);
        } else {
            throw new Error(`Expected ${replacementMmtes.length} mmtes in database, found ${mmteData.length}`);
        }
    }
}

export default TTTFNewZealSteps;

----------------------------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Scattered Mmtes Modal Page
 * Source: SCENARIO_03_NewZeal_Approval.txt - Section 3.10, 3.11
 * Handles Add/Remove Scattered Mmtes modal and Disputed Scattered Mmte modal
 */
@CSPage('tttf-scattered-mmtes-modal')
export class TTTFScatteredMmtesModalPage extends CSBasePage {

    // ===================================================================
    // MODAL CONTAINER ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__content-wrapper']",
        description: 'Modal container',
        waitForVisible: true
    })
    public modalContainer!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__content-wrapper']//div[contains(@class, 'sssss-panel__header')]//h5[text()='Select Options']",
        description: 'Select Options modal header',
        waitForVisible: true
    })
    public selectOptionsHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__content-wrapper']//div[contains(@class, 'sssss-panel__header')]//h5[text()='Add Scattered Mmtes']",
        description: 'Add Scattered Mmtes modal header (disputed)',
        waitForVisible: true
    })
    public addScatteredMmtesHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__content-wrapper']//div[contains(@class, 'sssss-panel__header')]//button[contains(@class, 'sssss-panel__close-icon')]",
        description: 'Modal close button',
        waitForEnabled: true
    })
    public closeButton!: CSWebElement;

    // ===================================================================
    // SEARCH ELEMENTS (ADD/REMOVE MODAL)
    // ===================================================================

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__content-wrapper']//section[@aria-label='Scattered Mmtes']//span[text()='Select items to continue.']",
        description: 'Select items to continue text',
        waitForVisible: true
    })
    public selectItemsText!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__content-wrapper']//section[@aria-label='Scattered Mmtes']//span[@class='sssss-panel-selections-dock__selected-count']",
        description: 'Selected count display',
        waitForVisible: true
    })
    public selectedCount!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__content-wrapper']//section[@aria-label='Scattered Mmtes']//input[@class='sssss-field__component']",
        description: 'Find by input field',
        waitForVisible: true
    })
    public findByInput!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__content-wrapper']//section[@aria-label='Scattered Mmtes']//span[@class='sssss-button__label' and text()='Go']/parent::button",
        description: 'Go button',
        waitForEnabled: true
    })
    public goButton!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__content-wrapper']//section[@aria-label='Scattered Mmtes']//span[@class='sssss-button__label' and text()='Reset']/parent::button",
        description: 'Reset button',
        waitForEnabled: true
    })
    public resetButton!: CSWebElement;

    // ===================================================================
    // SEARCH ELEMENTS (DISPUTED MODAL)
    // ===================================================================

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//div[@role='search']//input[@class='sssss-field__component']",
        description: 'Disputed modal find by input',
        waitForVisible: true
    })
    public disputedFindByInput!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//div[@role='search']//span[@class='sssss-button__label' and text()='Go']/parent::button",
        description: 'Disputed modal Go button',
        waitForEnabled: true
    })
    public disputedGoButton!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//div[@role='search']//span[@class='sssss-button__label' and text()='Reset']/parent::button",
        description: 'Disputed modal Reset button',
        waitForEnabled: true
    })
    public disputedResetButton!: CSWebElement;

    // ===================================================================
    // PAGINATION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//div[@class='sssss-paginator']",
        description: 'Pagination container',
        waitForVisible: true
    })
    public paginationContainer!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//div[@class='sssss-paginator']//span[text()='Previous Panel']/ancestor::button[1]",
        description: 'Previous panel button',
        waitForEnabled: true
    })
    public previousButton!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//div[@class='sssss-paginator']//span[text()='Next Panel']/ancestor::button[1]",
        description: 'Next panel button',
        waitForEnabled: true
    })
    public nextButton!: CSWebElement;

    // ===================================================================
    // TABLE ELEMENTS (ADD/REMOVE MODAL)
    // ===================================================================

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']",
        description: 'Scattered mmtes table',
        waitForVisible: true
    })
    public scatteredMmtesTable!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//tbody//td[text()='No data available.']",
        description: 'No data message',
        waitForVisible: true
    })
    public noDataMessage!: CSWebElement;

    // ===================================================================
    // TABLE ELEMENTS (DISPUTED MODAL)
    // ===================================================================

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//span[text()='Select Scattered Mmtes']/ancestor::table[@class='sssss-table'][1]",
        description: 'Disputed scattered mmtes table',
        waitForVisible: true
    })
    public disputedTable!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//span[text()='Select Scattered Mmtes']/ancestor::table[@class='sssss-table'][1]//tbody//td[text()='No data available.']",
        description: 'Disputed no data message',
        waitForVisible: true
    })
    public disputedNoDataMessage!: CSWebElement;

    // ===================================================================
    // FOOTER ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__footer']//span[text()='Apply']/parent::button",
        description: 'Apply button',
        waitForEnabled: true
    })
    public applyButton!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__footer']//span[text()='Cancel']/parent::button",
        description: 'Cancel button',
        waitForEnabled: true
    })
    public cancelButton!: CSWebElement;

    // ===================================================================
    // COLUMN HEADER ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//thead//span[text()='Scattered Mmte Name']",
        description: 'Scattered Mmte Name column header',
        waitForVisible: true
    })
    public scatteredMmteNameColumn!: CSWebElement;

    @CSGetElement({
        xpath: "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//thead//span[text()='Cumulative Mmte Name']",
        description: 'Cumulative Mmte Name column header',
        waitForVisible: true
    })
    public cumulativeMmteNameColumn!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFScatteredMmtesModalPage elements initialized');
    }

    // ===================================================================
    // ELEMENT VISIBILITY METHODS
    // ===================================================================

    public async isCloseButtonVisible(): Promise<boolean> {
        try {
            const count = await this.closeButton.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async getSelectItemsText(): Promise<string> {
        return await this.selectItemsText.textContentWithTimeout(5000) || '';
    }

    public async isFindByInputVisible(): Promise<boolean> {
        try {
            const count = await this.findByInput.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isGoButtonVisible(): Promise<boolean> {
        try {
            const count = await this.goButton.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isResetButtonVisible(): Promise<boolean> {
        try {
            const count = await this.resetButton.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isPaginationVisible(): Promise<boolean> {
        try {
            const count = await this.paginationContainer.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isPreviousButtonVisible(): Promise<boolean> {
        try {
            const count = await this.previousButton.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isNextButtonVisible(): Promise<boolean> {
        try {
            const count = await this.nextButton.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isScatteredMmtesTableVisible(): Promise<boolean> {
        try {
            const count = await this.scatteredMmtesTable.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isScatteredMmteNameColumnVisible(): Promise<boolean> {
        try {
            const count = await this.scatteredMmteNameColumn.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isCumulativeMmteNameColumnVisible(): Promise<boolean> {
        try {
            const count = await this.cumulativeMmteNameColumn.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isApplyButtonVisible(): Promise<boolean> {
        try {
            const count = await this.applyButton.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async isCancelButtonVisible(): Promise<boolean> {
        try {
            const count = await this.cancelButton.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    // ===================================================================
    // MODAL VERIFICATION METHODS
    // ===================================================================

    public async isModalVisible(): Promise<boolean> {
        return await this.modalContainer.isVisibleWithTimeout(10000);
    }

    public async waitForModalToClose(): Promise<void> {
        await this.modalContainer.waitForDetached(10000);
        CSReporter.info('Modal closed');
    }

    public async verifySelectOptionsModalDisplayed(): Promise<void> {
        await this.selectOptionsHeader.waitForVisible(10000);
        const isVisible = await this.selectOptionsHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Select Options modal is displayed');
        } else {
            throw new Error('Select Options modal header not found');
        }
    }

    public async verifyAddScatteredMmtesModalDisplayed(): Promise<void> {
        await this.addScatteredMmtesHeader.waitForVisible(10000);
        const isVisible = await this.addScatteredMmtesHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Add Scattered Mmtes modal is displayed');
        } else {
            throw new Error('Add Scattered Mmtes modal header not found');
        }
    }

    public async closeModal(): Promise<void> {
        await this.closeButton.clickWithTimeout(10000);
        CSReporter.info('Closed modal');
    }

    // ===================================================================
    // SELECTED COUNT METHODS
    // ===================================================================

    public async getSelectedCount(): Promise<string> {
        const text = await this.selectedCount.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    // ===================================================================
    // SEARCH METHODS (ADD/REMOVE MODAL)
    // ===================================================================

    public async searchScatteredMmte(mmteName: string): Promise<void> {
        await this.findByInput.waitForVisible(10000);
        await this.findByInput.clearWithTimeout(5000);
        await this.findByInput.fillWithTimeout(mmteName, 5000);
        await this.goButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        CSReporter.info(`Searched for scattered mmte: ${mmteName}`);
    }

    public async clearSearch(): Promise<void> {
        await this.resetButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        CSReporter.info('Cleared search');
    }

    // ===================================================================
    // SEARCH METHODS (DISPUTED MODAL)
    // ===================================================================

    public async searchDisputedScatteredMmte(mmteName: string): Promise<void> {
        await this.disputedFindByInput.waitForVisible(10000);
        await this.disputedFindByInput.clearWithTimeout(5000);
        await this.disputedFindByInput.fillWithTimeout(mmteName, 5000);
        await this.disputedGoButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        CSReporter.info(`Searched for disputed scattered mmte: ${mmteName}`);
    }

    public async clearDisputedSearch(): Promise<void> {
        await this.disputedResetButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        CSReporter.info('Cleared disputed search');
    }

    // ===================================================================
    // TABLE ROW METHODS (ADD/REMOVE MODAL)
    // ===================================================================

    public async isNoDataMessageVisible(): Promise<boolean> {
        try {
            const noDataElement = CSElementFactory.createByXPath(
                "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//tbody//td[text()='No data available.']",
                'No data message',
                this.page
            );
            const count = await noDataElement.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async getTableRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//tbody/tr`,
            'Table rows',
            this.page
        );
        return await rows.count();
    }

    public async findRowByScatteredMmteName(mmteName: string): Promise<number> {
        const rowCount = await this.getTableRowCount();

        for (let row = 1; row <= rowCount; row++) {
            const cellElement = CSElementFactory.createByXPath(
                `//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//tbody/tr[${row}]//td[text()='${mmteName}']`,
                `Row ${row} matching ${mmteName}`,
                this.page
            );

            if (await cellElement.isVisibleWithTimeout(1000)) {
                return row;
            }
        }

        return -1;
    }

    public async isRowCheckboxChecked(rowIndex: number): Promise<boolean> {
        const checkbox = CSElementFactory.createByXPath(
            `//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//tbody/tr[${rowIndex}]/td[1]//span[@role='checkbox']`,
            `Row ${rowIndex} checkbox`,
            this.page
        );
        const ariaChecked = await checkbox.getAttributeWithTimeout('aria-checked', 5000);
        return ariaChecked === 'true';
    }

    public async isRowCheckboxEnabled(rowIndex: number): Promise<boolean> {
        const checkbox = CSElementFactory.createByXPath(
            `//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//tbody/tr[${rowIndex}]/td[1]//span[@role='checkbox']`,
            `Row ${rowIndex} checkbox`,
            this.page
        );
        const ariaDisabled = await checkbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'false';
    }

    public async checkRowCheckbox(rowIndex: number): Promise<void> {
        const checkbox = CSElementFactory.createByXPath(
            `//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//tbody/tr[${rowIndex}]/td[1]//span[@role='checkbox']`,
            `Row ${rowIndex} checkbox`,
            this.page
        );

        const isChecked = await this.isRowCheckboxChecked(rowIndex);
        if (!isChecked) {
            await checkbox.clickWithTimeout(5000);
            CSReporter.pass(`Checked row ${rowIndex} checkbox`);
        } else {
            CSReporter.info(`Row ${rowIndex} already checked`);
        }
    }

    public async uncheckRowCheckbox(rowIndex: number): Promise<void> {
        const checkbox = CSElementFactory.createByXPath(
            `//div[@class='sssss-modal']//div[@class='sssss-panel__body']//table[@id='refMmteTableId1']//tbody/tr[${rowIndex}]/td[1]//span[@role='checkbox']`,
            `Row ${rowIndex} checkbox`,
            this.page
        );

        const isChecked = await this.isRowCheckboxChecked(rowIndex);
        if (isChecked) {
            await checkbox.clickWithTimeout(5000);
            CSReporter.pass(`Unchecked row ${rowIndex} checkbox`);
        } else {
            CSReporter.info(`Row ${rowIndex} already unchecked`);
        }
    }

    public async selectScatteredMmte(mmteName: string): Promise<void> {
        await this.searchScatteredMmte(mmteName);

        const isNoData = await this.isNoDataMessageVisible();
        if (isNoData) {
            throw new Error(`Scattered mmte not found: ${mmteName}`);
        }

        const rowIndex = await this.findRowByScatteredMmteName(mmteName);
        if (rowIndex === -1) {
            throw new Error(`Could not find row for scattered mmte: ${mmteName}`);
        }

        await this.checkRowCheckbox(rowIndex);
        CSReporter.pass(`Selected scattered mmte: ${mmteName}`);
    }

    public async unselectScatteredMmte(mmteName: string): Promise<void> {
        await this.searchScatteredMmte(mmteName);

        const isNoData = await this.isNoDataMessageVisible();
        if (isNoData) {
            throw new Error(`Scattered mmte not found: ${mmteName}`);
        }

        const rowIndex = await this.findRowByScatteredMmteName(mmteName);
        if (rowIndex === -1) {
            throw new Error(`Could not find row for scattered mmte: ${mmteName}`);
        }

        await this.uncheckRowCheckbox(rowIndex);
        CSReporter.pass(`Unselected scattered mmte: ${mmteName}`);
    }

    // ===================================================================
    // TABLE ROW METHODS (DISPUTED MODAL)
    // ===================================================================

    public async isDisputedNoDataMessageVisible(): Promise<boolean> {
        try {
            const noDataElement = CSElementFactory.createByXPath(
                "//div[@class='sssss-modal']//div[@class='sssss-panel__body']//span[text()='Select Scattered Mmtes']/ancestor::table[@class='sssss-table'][1]//tbody//td[text()='No data available.']",
                'Disputed no data message',
                this.page
            );
            const count = await noDataElement.count();
            return count > 0;
        } catch {
            return false;
        }
    }

    public async getDisputedTableRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//div[@class='sssss-modal']//div[@class='sssss-panel__body']//span[text()='Select Scattered Mmtes']/ancestor::table[@class='sssss-table'][1]//tbody/tr`,
            'Disputed table rows',
            this.page
        );
        return await rows.count();
    }

    public async findDisputedRowByScatteredMmteName(mmteName: string): Promise<number> {
        const rowCount = await this.getDisputedTableRowCount();

        for (let row = 1; row <= rowCount; row++) {
            const cellElement = CSElementFactory.createByXPath(
                `//div[@class='sssss-modal']//div[@class='sssss-panel__body']//span[text()='Select Scattered Mmtes']/ancestor::table[@class='sssss-table'][1]//tbody/tr[${row}]//td[text()='${mmteName}']`,
                `Disputed row ${row} matching ${mmteName}`,
                this.page
            );

            if (await cellElement.isVisibleWithTimeout(1000)) {
                return row;
            }
        }

        return -1;
    }

    public async selectDisputedScatteredMmte(mmteName: string): Promise<void> {
        await this.searchDisputedScatteredMmte(mmteName);

        const isNoData = await this.isDisputedNoDataMessageVisible();
        if (isNoData) {
            throw new Error(`Disputed scattered mmte not found: ${mmteName}`);
        }

        const rowIndex = await this.findDisputedRowByScatteredMmteName(mmteName);
        if (rowIndex === -1) {
            throw new Error(`Could not find row for disputed scattered mmte: ${mmteName}`);
        }

        const radioButton = CSElementFactory.createByXPath(
            `//div[@class='sssss-modal']//div[@class='sssss-panel__body']//span[text()='Select Scattered Mmtes']/ancestor::table[@class='sssss-table'][1]//tbody/tr[${rowIndex}]/td[1]/div[contains(@class,'sssss-radio-button')]`,
            `Disputed row ${rowIndex} radio button`,
            this.page
        );
        await radioButton.clickWithTimeout(5000);
        CSReporter.pass(`Selected disputed scattered mmte: ${mmteName}`);
    }

    // ===================================================================
    // FOOTER BUTTON METHODS
    // ===================================================================

    public async clickApplyButton(): Promise<void> {
        await this.applyButton.waitForVisible(10000);
        await this.applyButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Apply button');
    }

    public async clickCancelButton(): Promise<void> {
        await this.cancelButton.waitForVisible(10000);
        await this.cancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button');
    }

    public async isApplyButtonEnabled(): Promise<boolean> {
        return await this.applyButton.isEnabledWithTimeout(5000);
    }

    // ===================================================================
    // PAGINATION METHODS
    // ===================================================================

    public async clickPreviousButton(): Promise<void> {
        await this.previousButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Previous button');
    }

    public async clickNextButton(): Promise<void> {
        await this.nextButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Next button');
    }

    public async isPreviousButtonEnabled(): Promise<boolean> {
        return await this.previousButton.isEnabledWithTimeout(5000);
    }

    public async isNextButtonEnabled(): Promise<boolean> {
        return await this.nextButton.isEnabledWithTimeout(5000);
    }
}

export default TTTFScatteredMmtesModalPage;

