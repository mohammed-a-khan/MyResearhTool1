@CSBDDStepDef('I verify changes data matches expected updates')
    async verifyChangesDataMatchesExpectedUpdates(): Promise<void> {
        const zealId = this.scenarioContext.getVariable<string>('zealId');
        if (!zealId) {
            throw new Error('Zeal ID not found in scenario context');
        }
        CSReporter.info(`Verifying database change log for zeal ID: ${zealId}`);

        // Step 1: Execute change log query
        const changeLogResultSet = await TTTFDatabaseHelper.getChangeLogForZeal(zealId);
        if (changeLogResultSet.length === 0) {
            throw new Error(`No change log records found for zeal ID: ${zealId}`);
        }
        CSReporter.info(`Retrieved ${changeLogResultSet.length} change log records`);

        // Build scattered mmtes lists for later use
        const oldScatteredMmtesList: string[] = [];
        const newScatteredMmtesList: string[] = [];

        // Step 2: Verify SketchmarkFlagToUpdate
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (sketchmarkFlagToUpdate) {
            await this.verifySketchmarkFlagChange(changeLogResultSet, sketchmarkFlagToUpdate);
        }

        // Step 3: Verify FFXFileInductorTypeToUpdate
        const ffxFileInductorTypeToUpdate = this.scenarioContext.getVariable<string>('ffxFileInductorTypeToUpdate');
        if (ffxFileInductorTypeToUpdate) {
            await this.verifyOutputTtcalcChange(changeLogResultSet, ffxFileInductorTypeToUpdate);
        }

        // Step 4: Verify UpdateScatteredMmtesFlag
        const updateScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('updateScatteredMmtesFlag');
        if (updateScatteredMmtesFlag) {
            const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
            if (scatteredMmtesToUpdate) {
                const listScatteredMmtesToUpdate = scatteredMmtesToUpdate.split(';').filter(p => p.trim());
                for (const item of listScatteredMmtesToUpdate) {
                    const subItems = item.split('||');
                    if (subItems.length >= 2) {
                        oldScatteredMmtesList.push(subItems[0].trim());
                        newScatteredMmtesList.push(subItems[1].trim());
                    }
                }

                // Store for later verification steps
                this.scenarioContext.setVariable('oldScatteredMmtesList', oldScatteredMmtesList);
                this.scenarioContext.setVariable('newScatteredMmtesList', newScatteredMmtesList);

                // Verify removed scattered mmtes
                await this.verifyRemovedScatteredMmtes(changeLogResultSet, oldScatteredMmtesList);

                // Verify added scattered mmtes
                await this.verifyAddedScatteredMmtes(changeLogResultSet, newScatteredMmtesList);
            }
        }

        // Step 5: Verify UpdateDisputedScatteredMmteFlag
        const updateDisputedScatteredMmteFlag = this.scenarioContext.getVariable<boolean>('updateDisputedScatteredMmteFlag');
        if (updateDisputedScatteredMmteFlag) {
            const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
            if (disputedScatteredMmteToUpdate) {
                await this.verifyDisputedScatteredMmteChanges(changeLogResultSet, disputedScatteredMmteToUpdate, oldScatteredMmtesList, newScatteredMmtesList);
            }
        }

        // Step 6: Verify UpdateDisputedStartDateFlag
        const updateDisputedStartDateFlag = this.scenarioContext.getVariable<boolean>('updateDisputedStartDateFlag');
        if (updateDisputedStartDateFlag) {
            const disputedStartDateToUpdate = this.scenarioContext.getVariable<string>('disputedStartDateToUpdate') || '';
            if (disputedStartDateToUpdate) {
                // Get disputedScatteredMmteToUpdate from context to build the mapping of DisputedMmte -> PrimaryMmte
                const disputedScatteredMmteToUpdateForDate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
                await this.verifyDisputedStartDateChanges(
                    changeLogResultSet,
                    disputedStartDateToUpdate,
                    oldScatteredMmtesList,
                    newScatteredMmtesList,
                    disputedScatteredMmteToUpdateForDate
                );
            }
        }

        // Step 7: Verify FFXOrderUpdateFlag (user-provided)
        const ffxOrderUpdateFlag = this.scenarioContext.getVariable<boolean>('ffxOrderUpdateFlag');
        if (ffxOrderUpdateFlag) {
            const ffxOrderToUpdate = this.scenarioContext.getVariable<string>('ffxOrderToUpdate') || '';
            if (ffxOrderToUpdate) {
                await this.verifyFfxOrderChanges(changeLogResultSet, ffxOrderToUpdate, oldScatteredMmtesList, newScatteredMmtesList);
            }
        }

        // Step 8: Verify automatic FFX Order changes (CASE 3: partial removal scenario)
        // When some scattered mmtes are removed but others remain, the remaining mmtes'
        // FFX order changes automatically - verify these automatic changes
        const removeScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('removeScatteredMmtesFlag');
        const scatteredMmtesToRemove = this.scenarioContext.getVariable<string>('scatteredMmtesToRemove') || '';
        const existingScatteredMmtes = this.scenarioContext.getVariable<Array<{
            scatteredMmteName: string;
            disputedScatteredMmteName: string;
            disputedDate: string | Date;
            ffxOrder: number;
        }>>('existingScatteredMmtes') || [];

        // Build list of all removed mmtes (from both update and remove operations)
        const allRemovedMmtes: string[] = [...oldScatteredMmtesList];
        if (removeScatteredMmtesFlag && scatteredMmtesToRemove) {
            const removeList = scatteredMmtesToRemove.split(';').filter(r => r.trim());
            for (const mmte of removeList) {
                if (!allRemovedMmtes.includes(mmte.trim())) {
                    allRemovedMmtes.push(mmte.trim());
                }
            }
        }

        // Check for automatic FFX order changes if partial removal occurred
        if (allRemovedMmtes.length > 0 && existingScatteredMmtes.length > allRemovedMmtes.length) {
            await this.verifyAutomaticFfxOrderChanges(changeLogResultSet, existingScatteredMmtes, allRemovedMmtes);
        }

        CSReporter.pass('All database change log verifications passed');
    }


private async verifyDisputedScatteredMmteChanges(changeLog: ChangeLogRow[], disputedScatteredMmteToUpdate: string, oldScatteredMmtesList: string[], newScatteredMmtesList: string[]): Promise<void> {
        // Format: "PrimaryMmte||DisputedMmte;PrimaryMmte||DisputedMmte"
        const listDisputedScatteredMmteToUpdate = disputedScatteredMmteToUpdate.split(';').filter(p => p.trim());

        for (const item of listDisputedScatteredMmteToUpdate) {
            const subItems = item.split('||');
            if (subItems.length < 2) continue;

            const primaryRefMmteName = subItems[0].trim();  // Primary scattered mmte
            const disputedMmteName = subItems[1].trim();    // Disputed scattered mmte to set

            // CASE 1: Primary scattered mmte is being ADDED as NEW (complete replacement scenario)
            // When new mmtes are added, there is NO sepammte disputed record - SKIP verification
            if (newScatteredMmtesList.includes(primaryRefMmteName)) {
                CSReporter.info(`Primary mmte ${primaryRefMmteName} is newly added - no sepammte disputed mmte record expected`);
                continue;
            }

            // CASE 2: Primary scattered mmte is in oldScatteredMmtesList AND is being REMOVED
            // oldScatteredMmtesList contains mmtes that are being removed in the update operation
            // When a scattered mmte is removed, there is NO sepammte disputed update record - SKIP verification
            if (oldScatteredMmtesList.includes(primaryRefMmteName)) {
                CSReporter.info(`Primary mmte ${primaryRefMmteName} is being removed - no sepammte disputed mmte record expected`);
                continue;
            }

            // CASE 3: Primary scattered mmte EXISTS and is NOT being added/removed
            // This means it's an existing mmte getting its disputed updated
            // ONLY in this case, we expect a "DisputedScatteredMmte" UPDATE record
            let found = false;
            for (const row of changeLog) {
                if (row.fieldName === 'DisputedScatteredMmte' && row.scatteredMmteName === primaryRefMmteName) {
                    const strDBNewValue = row.newValue;
                    const strDBAction = row.action;
                    const isUpdatedToday = TTTFDatabaseHelper.isOracleTimestampToday(row.updatedDt);

                    if (strDBNewValue === disputedMmteName && strDBAction === 'UPDATE' && isUpdatedToday) {
                        CSReporter.pass(`DisputedScatteredMmte UPDATE verified for existing mmte ${primaryRefMmteName}: NewValue=${strDBNewValue}`);
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                throw new Error(`DisputedScatteredMmte UPDATE not found for existing mmte: ${primaryRefMmteName}. Expected: NewValue=${disputedMmteName}`);
            }
        }
    }

    private async verifyDisputedStartDateChanges(
        changeLog: ChangeLogRow[],
        disputedStartDateToUpdate: string,
        oldScatteredMmtesList: string[],
        newScatteredMmtesList: string[],
        disputedScatteredMmteToUpdate: string = ''
    ): Promise<void> {
        // Format: "DisputedMmteName||MM/DD/YYYY;DisputedMmteName||MM/DD/YYYY"
        // Note: First part is the DISPUTED scattered mmte name, not the primary scattered mmte!
        const listDisputedStartDateToUpdate = disputedStartDateToUpdate.split(';').filter(p => p.trim());

        // Build map of DisputedMmte -> PrimaryMmte from disputedScatteredMmteToUpdate
        // Format of disputedScatteredMmteToUpdate: "PrimaryMmte||DisputedMmte;PrimaryMmte||DisputedMmte"
        const disputedToPrimaryMap = new Map<string, string>();
        const disputedScatteredMmtesList: string[] = [];

        if (disputedScatteredMmteToUpdate) {
            const pairs = disputedScatteredMmteToUpdate.split(';').filter(p => p.trim());
            for (const pair of pairs) {
                const [primaryMmte, disputedMmte] = pair.split('||').map(s => s.trim());
                if (primaryMmte && disputedMmte) {
                    disputedToPrimaryMap.set(disputedMmte, primaryMmte);
                    disputedScatteredMmtesList.push(disputedMmte);
                }
            }
        }

        for (const item of listDisputedStartDateToUpdate) {
            const subItems = item.split('||');
            if (subItems.length < 2) continue;

            const disputedMmteName = subItems[0].trim(); // This is the DISPUTED scattered mmte name
            const disputedStartDate = subItems[1].trim();

            // Step 1: Check if this disputedMmteName is in the disputedScatteredMmtesList
            if (!disputedScatteredMmtesList.includes(disputedMmteName)) {
                CSReporter.info(`Disputed mmte ${disputedMmteName} is not in disputedScatteredMmtesList - skipping`);
                continue;
            }

            // Step 2: Get the PRIMARY scattered mmte that has this disputed
            const primaryRefMmteName = disputedToPrimaryMap.get(disputedMmteName) || '';
            if (!primaryRefMmteName) {
                CSReporter.warn(`Could not find primary mmte for disputed ${disputedMmteName} - skipping`);
                continue;
            }

            // CASE 1: Primary scattered mmte is being ADDED as NEW (complete replacement scenario)
            // When new mmtes are added, there is NO sepammte disputed date record - SKIP
            if (newScatteredMmtesList.includes(primaryRefMmteName)) {
                CSReporter.info(`Primary mmte ${primaryRefMmteName} is newly added - no sepammte disputed date record expected`);
                continue;
            }

            // CASE 2: Primary scattered mmte is in oldScatteredMmtesList (being REMOVED)
            // When the primary mmte is removed, there is NO sepammte disputed date record - SKIP
            if (oldScatteredMmtesList.includes(primaryRefMmteName)) {
                CSReporter.info(`Primary mmte ${primaryRefMmteName} is being removed - no sepammte disputed date record expected`);
                continue;
            }

            // CASE 3: Primary scattered mmte EXISTS and is NOT being added/removed
            // This means it's an existing mmte getting its disputed date updated
            // ONLY in this case, we expect a "DisputedDate" UPDATE record
            let found = false;
            for (const row of changeLog) {
                if (row.fieldName === 'DisputedDate' && row.scatteredMmteName === primaryRefMmteName) {
                    const strDBNewValue = row.newValue;
                    const strDBAction = row.action;
                    const isUpdatedToday = TTTFDatabaseHelper.isOracleTimestampToday(row.updatedDt);

                    if (strDBNewValue === disputedStartDate && strDBAction === 'UPDATE' && isUpdatedToday) {
                        CSReporter.pass(`DisputedDate UPDATE verified for ${primaryRefMmteName} (disputed: ${disputedMmteName}): NewValue=${strDBNewValue}`);
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                throw new Error(`DisputedDate UPDATE not found for primary mmte: ${primaryRefMmteName} (disputed: ${disputedMmteName}). Expected: NewValue=${disputedStartDate}`);
            }
        }
    }
