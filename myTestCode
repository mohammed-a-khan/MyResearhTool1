# ==============================================================================
# EXISTING ZEAL UPDATE - CHANGE LOG VERIFICATION QUERIES (SCENARIO_09B)
# ==============================================================================

# Get change log records for zeal verification (AWAITING status, updated today)
# Returns all pending changes in zealpremisis_data_status_log for verification
# Columns: field_name, scattered_mmte_name, old_value, new_value, action, inserted_dt, updated_dt,
#          disputed_scattered_mmte_name, disputed_start_date, ffx_order, zealpremisis_status_cd
DB_QUERY_GET_CHANGE_LOG_FOR_ZEAL=SELECT dsdsl.field_name, (SELECT scattered_mmte_name FROM tttfapp.scattered_mmte WHERE scattered_mmte_id=dsdsl.scattered_mmte_id) AS scattered_mmte_name, dsdsl.old_value, CASE WHEN dsdsl.field_name='DisputedScatteredMmte' THEN (SELECT scattered_mmte_name FROM tttfapp.scattered_mmte WHERE scattered_mmte_id=TO_NUMBER(dsdsl.new_value)) ELSE dsdsl.new_value END AS new_value, dsdsl.action, TO_CHAR(dsdsl.inserted_dt, 'DD-MON-YY HH.MI.SS.FF AM') AS inserted_dt, TO_CHAR(dsdsl.updated_dt, 'DD-MON-YY HH.MI.SS.FF AM') AS updated_dt, rr.scattered_mmte_name AS disputed_scattered_mmte_name, TO_CHAR(dsdsl.disputed_start_date, 'MM/DD/YYYY') AS disputed_start_date, dsdsl.ffx_order, dsds.zealpremisis_status_cd FROM tttfapp.zeal_data dd INNER JOIN tttfapp.zealpremisis_data_status_log dsdsl ON dsdsl.zealpremisis_data_id=dd.zealpremisis_data_id INNER JOIN tttfapp.zealpremisis_data_status dsds ON dsdsl.zealpremisis_status_id=dsds.zealpremisis_status_id LEFT JOIN tttfapp.scattered_mmte rr ON rr.scattered_mmte_id=dsdsl.disputed_scattered_mmte_id WHERE dd.zeal_id=? AND dsds.zealpremisis_status_cd='AWAITING' AND TRUNC(dsdsl.updated_dt)=TRUNC(SYSDATE)


----------------------------------------------------------------------------------------------------------------------

helper:

// ===================================================================
    // CHANGE LOG VERIFICATION METHODS (SCENARIO_09B)
    // ===================================================================

    /**
     * Get change log records for zeal verification (AWAITING status, updated today)
     * Query: DB_QUERY_GET_CHANGE_LOG_FOR_ZEAL
     * @param zealId - The zeal ID to get change log for
     * @returns Array of change log records
     */
    public static async getChangeLogForZeal(zealId: string): Promise<ChangeLogRow[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_CHANGE_LOG_FOR_ZEAL',
            [zealId]
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn(`No change log records found for zeal ID: ${zealId}`);
            return [];
        }

        const rows = result.rows.map((row: any) => ({
            fieldName: row.field_name || row.FIELD_NAME || '',
            scatteredMmteName: row.scattered_mmte_name || row.SCATTERED_MMTE_NAME || '',
            oldValue: row.old_value || row.OLD_VALUE || '',
            newValue: row.new_value || row.NEW_VALUE || '',
            action: row.action || row.ACTION || '',
            insertedDt: row.inserted_dt || row.INSERTED_DT || '',
            updatedDt: row.updated_dt || row.UPDATED_DT || '',
            disputedScatteredMmteName: row.disputed_scattered_mmte_name || row.DISPUTED_SCATTERED_MMTE_NAME || '',
            disputedStartDate: row.disputed_start_date || row.DISPUTED_START_DATE || '',
            ffxOrder: row.ffx_order || row.FFX_ORDER || 0,
            zealpremisisStatusCd: row.zealpremisis_status_cd || row.ZEALPREMISIS_STATUS_CD || ''
        }));

        CSReporter.debug(`Found ${rows.length} change log records for zeal ID: ${zealId}`);
        return rows;
    }

    /**
     * Extract date from Oracle timestamp string
     * Input format example: "02-NOV-25 02.45.28.363770465 PM"
     * Output format: "02-NOV-25" (just the date part)
     * @param oracleTimestamp - The Oracle timestamp string
     * @returns The date portion of the timestamp
     */
    public static extractDateFromOracleTimestamp(oracleTimestamp: string): string {
        if (!oracleTimestamp) return '';
        // Extract just the date part (before the first space)
        const datePart = oracleTimestamp.split(' ')[0];
        return datePart || '';
    }

    /**
     * Get current date in Oracle format (DD-MON-YY)
     * @returns Current date in DD-MON-YY format (e.g., "02-NOV-25")
     */
    public static getCurrentDateInOracleFormat(): string {
        const now = new Date();
        const day = String(now.getDate()).padStart(2, '0');
        const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const month = months[now.getMonth()];
        const year = String(now.getFullYear()).slice(-2);
        return `${day}-${month}-${year}`;
    }


/**
 * Interface for change log row from zealpremisis_data_status_log
 * Used for SCENARIO_09B: Database verification of pending changes
 */
export interface ChangeLogRow {
    fieldName: string;
    scatteredMmteName: string;
    oldValue: string;
    newValue: string;
    action: string;
    insertedDt: string;
    updatedDt: string;
    disputedScatteredMmteName: string;
    disputedStartDate: string;
    ffxOrder: number;
    zealpremisisStatusCd: string;
}

----------------------------------------------------------------------------------------------------------------
tttf-new-zeal.steps.ts)


import { TTTFDatabaseHelper, ExistingZealRow, ChangeLogRow } from '../helpers/TTTFDatabaseHelper';




    // ===================================================================
    // SCENARIO_09B: EXISTING ZEAL UPDATE - TEST DATA PREPARATION AND UPDATE STEPS
    // ===================================================================

    @CSBDDStepDef('I prepare test data for existing zeal update')
    async prepareTestDataForExistingZealUpdate(): Promise<void> {
        CSReporter.info('Preparing comprehensive test data for existing zeal update (SCENARIO_09B)');
        CSReporter.info('Per TTTF_Update_Zeal_Scenario.txt requirement');

        // Get current row test data from BDD context
        const currentRow = this.context.getVariable('currentRow') as any || {};
        CSReporter.debug(`Current row test data: ${JSON.stringify(currentRow)}`);

        // ===================================================================
        // STEP 1: Resolve Zeal Information and Get Main Test Data from DB
        // Per requirement: Check ZealKey, ZealId, ZealName in order
        // ===================================================================
        let zealId = currentRow.zealId || '';
        let zealKey = currentRow.zealKey || '';
        let zealName = currentRow.zealName || '';
        let mainTestDataFromDB: ExistingZealRow[] = [];

        // Case 1: No zeal info provided - use main query to get random zeal with >1 scattered mmtes
        if (!zealKey && !zealId && !zealName) {
            CSReporter.info('No zeal info in test data JSON, querying database for existing zeal with scattered mmtes...');
            mainTestDataFromDB = await TTTFDatabaseHelper.getExistingZealWithScatteredMmtes();

            if (mainTestDataFromDB.length === 0) {
                throw new Error('No existing zeal with scattered mmtes found in database');
            }

            // Get zeal info from first row (all rows have same zeal info)
            const firstRow = mainTestDataFromDB[0];
            zealId = firstRow.zealId;
            zealKey = firstRow.zealKey;
            zealName = firstRow.zealName;

            CSReporter.info(`Retrieved existing zeal from DB: ID=${zealId}, Key=${zealKey}, with ${mainTestDataFromDB.length} scattered mmtes`);
        }
        // Case 2: ZealId provided - get zeal data by ID
        else if (!zealKey && zealId) {
            CSReporter.info(`ZealId provided in JSON: ${zealId}, querying full zeal data...`);
            mainTestDataFromDB = await TTTFDatabaseHelper.getExistingZealById(zealId);

            if (mainTestDataFromDB.length === 0) {
                throw new Error(`No existing zeal found for ID: ${zealId}`);
            }

            // Get zealKey and zealName from result
            const firstRow = mainTestDataFromDB[0];
            zealKey = firstRow.zealKey;
            if (!zealName) {
                zealName = firstRow.zealName;
            }

            CSReporter.info(`Retrieved zeal by ID: Key=${zealKey}, Name=${zealName}, with ${mainTestDataFromDB.length} scattered mmtes`);
        }
        // Case 3: ZealName provided but no ZealId or ZealKey
        else if (!zealKey && !zealId && zealName) {
            CSReporter.info(`ZealName provided in JSON: ${zealName}, querying zeal info...`);
            const zealByName = await TTTFDatabaseHelper.getZealByName(zealName);

            if (!zealByName) {
                throw new Error(`No zeal found with name: ${zealName}`);
            }

            zealId = zealByName.zealId;
            zealKey = zealByName.zealKey;

            // Now get full data by zeal ID
            mainTestDataFromDB = await TTTFDatabaseHelper.getExistingZealById(zealId);
            CSReporter.info(`Retrieved zeal by name: ID=${zealId}, Key=${zealKey}, with ${mainTestDataFromDB.length} scattered mmtes`);
        }

        // Store the main result set in scenario context for future use
        this.scenarioContext.setVariable('mainTestDataFromDB', mainTestDataFromDB);

        // Store resolved zeal info
        this.scenarioContext.setVariable('zealId', zealId);
        this.scenarioContext.setVariable('zealKey', zealKey);
        this.scenarioContext.setVariable('zealName', zealName);

        // Store additional zeal details from first row
        if (mainTestDataFromDB.length > 0) {
            const firstRow = mainTestDataFromDB[0];
            this.scenarioContext.setVariable('inductorGroup', firstRow.inductorGroup);
            this.scenarioContext.setVariable('kindnessCircle', firstRow.kindnessCircle);
            this.scenarioContext.setVariable('zzztSeggregation', firstRow.zzztSeggregation);
            this.scenarioContext.setVariable('premisisDescription', firstRow.premisisDescription);
            this.scenarioContext.setVariable('calcShoolName', firstRow.calcShoolName);
            this.scenarioContext.setVariable('acctManager', firstRow.acctManager);
            this.scenarioContext.setVariable('currentSketchmarkFlag', firstRow.sketchmarkReplacementFlag || 'N');
            this.scenarioContext.setVariable('currentInductorCode', firstRow.inductorCode || '');

            // Extract and store existing scattered mmtes from mainTestDataFromDB
            // Each row contains one scattered mmte - build array for verification steps
            const existingScatteredMmtes = mainTestDataFromDB.map(row => ({
                scatteredMmteName: row.scatteredMmteName,
                disputedScatteredMmteName: row.disputedScatteredMmteName,
                disputedDate: row.disputedDate,
                ffxOrder: row.ffxOrder
            }));
            this.scenarioContext.setVariable('existingScatteredMmtes', existingScatteredMmtes);
            CSReporter.info(`Stored ${existingScatteredMmtes.length} existing scattered mmtes: ${existingScatteredMmtes.map(r => r.scatteredMmteName).join(', ')}`);
        }

        // ===================================================================
        // STEP 2: Resolve SketchmarkFlagToUpdate
        // Per requirement: Toggle current value if not provided
        // ===================================================================
        let sketchmarkFlagToUpdate = currentRow.sketchmarkFlagToUpdate || '';
        if (sketchmarkFlagToUpdate) {
            // Normalize user-provided value: Yes/True -> Y, No/False -> N
            sketchmarkFlagToUpdate = this.normalizeYesNoFlag(sketchmarkFlagToUpdate);
        } else {
            // Auto-toggle: If current is Y, set to N; if N, set to Y
            const currentSketchmarkFlag = this.scenarioContext.getVariable<string>('currentSketchmarkFlag') || 'N';
            sketchmarkFlagToUpdate = currentSketchmarkFlag === 'Y' ? 'N' : 'Y';
            CSReporter.info(`Auto-toggling sketchmarkFlagToUpdate: current=${currentSketchmarkFlag}, new=${sketchmarkFlagToUpdate}`);
        }
        this.scenarioContext.setVariable('sketchmarkFlagToUpdate', sketchmarkFlagToUpdate);

        // ===================================================================
        // STEP 3: Resolve FFXFileInductorTypeToUpdate
        // Per requirement: Query for different inductor type if not provided
        // ===================================================================
        let ffxFileInductorTypeToUpdate = currentRow.ffxFileInductorTypeToUpdate || '';
        if (!ffxFileInductorTypeToUpdate) {
            const currentInductorCode = this.scenarioContext.getVariable<string>('currentInductorCode') || '';
            if (currentInductorCode) {
                const differentInductorCode = await TTTFDatabaseHelper.getDifferentFfxInductorType(currentInductorCode);
                if (differentInductorCode) {
                    ffxFileInductorTypeToUpdate = differentInductorCode;
                    CSReporter.info(`Auto-selected different FFX Inductor Type: ${ffxFileInductorTypeToUpdate} (current: ${currentInductorCode})`);
                }
            }
        }
        this.scenarioContext.setVariable('ffxFileInductorTypeToUpdate', ffxFileInductorTypeToUpdate);

        // ===================================================================
        // STEP 4: Resolve Update Flags
        // ===================================================================
        const updateScatteredMmtesFlag = this.isYesOrTrue(currentRow.updateScatteredMmtesFlag || 'false');
        const removeScatteredMmtesFlag = this.isYesOrTrue(currentRow.removeScatteredMmtesFlag || 'false');
        const updateDisputedScatteredMmteFlag = this.isYesOrTrue(currentRow.updateDisputedScatteredMmteFlag || 'false');
        const updateDisputedStartDateFlag = this.isYesOrTrue(currentRow.updateDisputedStartDateFlag || 'false');
        const ffxOrderUpdateFlag = this.isYesOrTrue(currentRow.ffxOrderUpdateFlag || 'false');

        this.scenarioContext.setVariable('updateScatteredMmtesFlag', updateScatteredMmtesFlag);
        this.scenarioContext.setVariable('removeScatteredMmtesFlag', removeScatteredMmtesFlag);
        this.scenarioContext.setVariable('updateDisputedScatteredMmteFlag', updateDisputedScatteredMmteFlag);
        this.scenarioContext.setVariable('updateDisputedStartDateFlag', updateDisputedStartDateFlag);
        this.scenarioContext.setVariable('ffxOrderUpdateFlag', ffxOrderUpdateFlag);

        // ===================================================================
        // STEP 5: Resolve ScatteredMmtesToUpdate
        // Per requirement: Uses dynamic CTE query with exclusions
        // Format: "OldMmte||NewMmte;OldMmte||NewMmte"
        // ===================================================================
        let scatteredMmtesToUpdate = currentRow.scatteredMmtesToUpdate || '';
        let scatteredMmtesNamesData: Array<{ scatteredMmteName: string; methodologyType: string }> = [];

        if (updateScatteredMmtesFlag && !scatteredMmtesToUpdate) {
            // Get existing scattered mmtes from mainTestDataFromDB, excluding any to be removed
            const mmtesToRemove = removeScatteredMmtesFlag
                ? (currentRow.scatteredMmtesToRemove || '').split(';').filter((r: string) => r.trim())
                : [];

            const existingMmteNames: string[] = [];
            for (const row of mainTestDataFromDB) {
                const mmteName = row.scatteredMmteName;
                if (mmteName && !mmtesToRemove.includes(mmteName)) {
                    existingMmteNames.push(mmteName);
                }
            }

            if (existingMmteNames.length > 0) {
                // Execute dynamic CTE query for replacement mmtes per requirement
                scatteredMmtesNamesData = await TTTFDatabaseHelper.getReplacementScatteredMmtesDynamic(existingMmteNames);

                // Build ScatteredMmtesToUpdate string: "OldMmte||NewMmte;..."
                const updatePairs: string[] = [];
                for (let i = 0; i < existingMmteNames.length && i < scatteredMmtesNamesData.length; i++) {
                    updatePairs.push(`${existingMmteNames[i]}||${scatteredMmtesNamesData[i].scatteredMmteName}`);
                }
                scatteredMmtesToUpdate = updatePairs.join(';');
                CSReporter.info(`Auto-genemmted scatteredMmtesToUpdate: ${scatteredMmtesToUpdate}`);
            }
        }
        this.scenarioContext.setVariable('scatteredMmtesToUpdate', scatteredMmtesToUpdate);
        this.scenarioContext.setVariable('scatteredMmtesNamesData', scatteredMmtesNamesData);

        // ===================================================================
        // STEP 6: Resolve ScatteredMmtesToRemove (Section B.5)
        // ===================================================================
        if (removeScatteredMmtesFlag) {
            const scatteredMmtesToRemove = currentRow.scatteredMmtesToRemove || '';
            this.scenarioContext.setVariable('scatteredMmtesToRemove', scatteredMmtesToRemove);
        }

        // ===================================================================
        // STEP 7: Resolve DisputedScatteredMmteToUpdate (Section B.6)
        // ===================================================================
        if (updateDisputedScatteredMmteFlag) {
            let disputedScatteredMmteToUpdate = currentRow.disputedScatteredMmteToUpdate || '';
            if (!disputedScatteredMmteToUpdate) {
                // Get new scattered mmtes (from scatteredMmtesToUpdate) and pair with disputed mmtes
                const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
                if (scatteredMmtesToUpdate) {
                    const newMmteNames: string[] = [];
                    scatteredMmtesToUpdate.split(';').forEach(pair => {
                        const [, newMmte] = pair.split('||');
                        if (newMmte) newMmteNames.push(newMmte.trim());
                    });

                    // Get disputed mmtes using dynamic CTE query per requirement
                    // The new scattered mmtes are excluded to get different disputed mmtes
                    const disputedMmtes = await TTTFDatabaseHelper.getDisputedScatteredMmtesDynamic(newMmteNames);
                    if (disputedMmtes.length > 0) {
                        const disputedPairs: string[] = [];
                        for (let i = 0; i < newMmteNames.length && i < disputedMmtes.length; i++) {
                            disputedPairs.push(`${newMmteNames[i]}||${disputedMmtes[i].scatteredMmteName}`);
                        }
                        disputedScatteredMmteToUpdate = disputedPairs.join(';');
                        CSReporter.info(`Auto-genemmted disputedScatteredMmteToUpdate: ${disputedScatteredMmteToUpdate}`);
                    }
                }
            }
            this.scenarioContext.setVariable('disputedScatteredMmteToUpdate', disputedScatteredMmteToUpdate);
        }

        // ===================================================================
        // STEP 8: Resolve DisputedStartDateToUpdate (Section B.7)
        // ===================================================================
        if (updateDisputedStartDateFlag && updateDisputedScatteredMmteFlag) {
            let disputedStartDateToUpdate = currentRow.disputedStartDateToUpdate || '';
            if (!disputedStartDateToUpdate) {
                // Auto-genemmte: Calculate date = Current Date - 15 days (exclude weekends)
                const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
                if (disputedScatteredMmteToUpdate) {
                    const disputedStartDate = TTTFDatabaseHelper.calculateDisputedStartDate();
                    const datePairs: string[] = [];

                    disputedScatteredMmteToUpdate.split(';').forEach(pair => {
                        const [, disputedMmte] = pair.split('||');
                        if (disputedMmte) {
                            datePairs.push(`${disputedMmte.trim()}||${disputedStartDate}`);
                        }
                    });
                    disputedStartDateToUpdate = datePairs.join(';');
                    CSReporter.info(`Auto-genemmted disputedStartDateToUpdate: ${disputedStartDateToUpdate}`);
                }
            }
            this.scenarioContext.setVariable('disputedStartDateToUpdate', disputedStartDateToUpdate);
        }

        // ===================================================================
        // STEP 9: FFXOrderToUpdate (Section B.8 - Must be user-provided)
        // ===================================================================
        if (ffxOrderUpdateFlag) {
            const ffxOrderToUpdate = currentRow.ffxOrderToUpdate || '';
            if (!ffxOrderToUpdate) {
                CSReporter.warn('FFXOrderToUpdate must be user-provided. Skipping FFX order update.');
                this.scenarioContext.setVariable('ffxOrderUpdateFlag', false);
            } else {
                this.scenarioContext.setVariable('ffxOrderToUpdate', ffxOrderToUpdate);
            }
        }

        CSReporter.pass('Test data preparation for existing zeal update completed successfully');
    }

    /**
     * Normalize Yes/No flag to Y/N format
     */
    private normalizeYesNoFlag(value: string): string {
        const lowerValue = value.toLowerCase();
        if (lowerValue === 'yes' || lowerValue === 'true' || lowerValue === 'y') {
            return 'Y';
        }
        return 'N';
    }

    @CSBDDStepDef('I verify Use Sketchmark Replacement shows current value')
    async verifyUseSketchmarkReplacementShowsCurrentValue(): Promise<void> {
        const currentFlag = this.scenarioContext.getVariable<string>('currentSketchmarkFlag') || 'N';
        const expectedValue = currentFlag === 'Y' ? 'True' : 'False';
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === expectedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows current value: ${actualValue}`);
        } else {
            CSReporter.warn(`Use Sketchmark Replacement mismatch: Expected=${expectedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify Output Ttcalc File shows current value')
    async verifyOutputTtcalcFileShowsCurrentValue(): Promise<void> {
        const inductorCode = this.scenarioContext.getVariable<string>('currentInductorCode');
        const expectedValue = inductorCode ? 'True' : 'False';
        const actualValue = await this.zealDetailsPage.getOutputTtcalcFileValue();

        CSReporter.info(`Output Ttcalc File: Expected=${expectedValue}, Actual=${actualValue}`);
    }

    @CSBDDStepDef('I verify existing scattered mmtes match database')
    async verifyExistingScatteredMmtesMatchDatabase(): Promise<void> {
        const existingMmtes = this.scenarioContext.getVariable<any[]>('existingScatteredMmtes') || [];
        const uiMmteCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (uiMmteCount === existingMmtes.length) {
            CSReporter.pass(`Existing scattered mmtes match database: ${uiMmteCount} mmtes`);
        } else {
            throw new Error(`Scattered mmtes count mismatch: DB=${existingMmtes.length}, UI=${uiMmteCount}`);
        }
    }

    @CSBDDStepDef('I update sketchmark flag if required')
    async updateSketchmarkFlagIfRequired(): Promise<void> {
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (!sketchmarkFlagToUpdate) {
            CSReporter.info('sketchmarkFlagToUpdate not set, skipping sketchmark flag update');
            return;
        }

        const shouldBeChecked = sketchmarkFlagToUpdate === 'Y';

        if (shouldBeChecked) {
            await this.zealDetailsPage.checkUseSketchmarkReplacement();
        } else {
            await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
        }
        CSReporter.pass(`Updated Use Sketchmark Replacement to: ${shouldBeChecked ? 'checked' : 'unchecked'}`);
    }

    @CSBDDStepDef('I update FFX Inductor Type if required')
    async updateFfxInductorTypeIfRequired(): Promise<void> {
        const ffxFileInductorTypeToUpdate = this.scenarioContext.getVariable<string>('ffxFileInductorTypeToUpdate');
        if (!ffxFileInductorTypeToUpdate) {
            CSReporter.info('ffxFileInductorTypeToUpdate not set, skipping FFX Inductor Type update');
            return;
        }

        // Ensure Output Ttcalc File is checked first
        await this.zealDetailsPage.checkOutputTtcalcFile();

        // Select the new FFX Inductor Type
        await this.zealDetailsPage.selectFfxInductorType(ffxFileInductorTypeToUpdate);
        CSReporter.pass(`Updated FFX Inductor Type to: ${ffxFileInductorTypeToUpdate}`);
    }

    @CSBDDStepDef('I update scattered mmtes if required')
    async updateScatteredMmtesIfRequired(): Promise<void> {
        const updateScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('updateScatteredMmtesFlag');
        if (!updateScatteredMmtesFlag) {
            CSReporter.info('updateScatteredMmtesFlag is false, skipping scattered mmtes update');
            return;
        }

        const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
        if (!scatteredMmtesToUpdate) {
            CSReporter.info('scatteredMmtesToUpdate is empty, skipping');
            return;
        }

        // Parse format: "OldMmte||NewMmte;OldMmte||NewMmte"
        const updatePairs = scatteredMmtesToUpdate.split(';').filter(p => p.trim());
        const oldMmtes: string[] = [];
        const newMmtes: string[] = [];

        updatePairs.forEach(pair => {
            const [oldMmte, newMmte] = pair.split('||').map(s => s.trim());
            if (oldMmte && newMmte) {
                oldMmtes.push(oldMmte);
                newMmtes.push(newMmte);
            }
        });

        // Open Add/Remove modal
        await this.zealDetailsPage.clickAddRemoveButton();
        // Wait for modal to be visible
        const isModalVisible = await this.scatteredMmtesModalPage.isModalVisible();
        if (!isModalVisible) {
            throw new Error('Select Options modal did not appear');
        }

        // Unselect old mmtes
        for (const oldMmte of oldMmtes) {
            await this.scatteredMmtesModalPage.unselectScatteredMmte(oldMmte);
        }

        // Select new mmtes
        for (const newMmte of newMmtes) {
            await this.scatteredMmtesModalPage.selectScatteredMmte(newMmte);
        }

        // Apply changes
        await this.scatteredMmtesModalPage.clickApplyButton();
        CSReporter.pass(`Updated scattered mmtes: Removed ${oldMmtes.length}, Added ${newMmtes.length}`);

        // Store replacement mmtes for verification
        this.scenarioContext.setVariable('replacementScatteredMmtes', newMmtes);
    }

    @CSBDDStepDef('I remove scattered mmtes if required')
    async removeScatteredMmtesIfRequired(): Promise<void> {
        const removeScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('removeScatteredMmtesFlag');
        if (!removeScatteredMmtesFlag) {
            CSReporter.info('removeScatteredMmtesFlag is false, skipping scattered mmtes removal');
            return;
        }

        const scatteredMmtesToRemove = this.scenarioContext.getVariable<string>('scatteredMmtesToRemove') || '';
        if (!scatteredMmtesToRemove) {
            CSReporter.info('scatteredMmtesToRemove is empty, skipping');
            return;
        }

        // Parse format: "Mmte1;Mmte2"
        const mmtesToRemove = scatteredMmtesToRemove.split(';').map(s => s.trim()).filter(s => s);

        // Open Add/Remove modal
        await this.zealDetailsPage.clickAddRemoveButton();
        // Wait for modal to be visible
        const isModalVisible = await this.scatteredMmtesModalPage.isModalVisible();
        if (!isModalVisible) {
            throw new Error('Select Options modal did not appear');
        }

        // Unselect mmtes to remove
        for (const mmte of mmtesToRemove) {
            await this.scatteredMmtesModalPage.unselectScatteredMmte(mmte);
        }

        // Apply changes
        await this.scatteredMmtesModalPage.clickApplyButton();
        CSReporter.pass(`Removed ${mmtesToRemove.length} scattered mmtes`);
    }

    @CSBDDStepDef('I update disputed scattered mmtes if required')
    async updateDisputedScatteredMmtesIfRequired(): Promise<void> {
        const updateDisputedScatteredMmteFlag = this.scenarioContext.getVariable<boolean>('updateDisputedScatteredMmteFlag');
        if (!updateDisputedScatteredMmteFlag) {
            CSReporter.info('updateDisputedScatteredMmteFlag is false, skipping disputed scattered mmtes update');
            return;
        }

        const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
        if (!disputedScatteredMmteToUpdate) {
            CSReporter.info('disputedScatteredMmteToUpdate is empty, skipping');
            return;
        }

        // Parse format: "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
        const disputedPairs = disputedScatteredMmteToUpdate.split(';').filter(p => p.trim());

        for (const pair of disputedPairs) {
            const [refMmte, disputedMmte] = pair.split('||').map(s => s.trim());
            if (refMmte && disputedMmte) {
                // Open disputed modal for this scattered mmte row
                await this.zealDetailsPage.setDisputedScatteredMmteForRow(refMmte, disputedMmte);
                // Select the disputed mmte in the modal
                await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(disputedMmte);
                // Close modal by clicking Apply/Select button (disputed modal uses Apply)
                await this.scatteredMmtesModalPage.clickApplyButton();
                CSReporter.info(`Set disputed for ${refMmte} -> ${disputedMmte}`);
            }
        }
        CSReporter.pass(`Updated ${disputedPairs.length} disputed scattered mmtes`);
    }

    @CSBDDStepDef('I update disputed start dates if required')
    async updateDisputedStartDatesIfRequired(): Promise<void> {
        const updateDisputedStartDateFlag = this.scenarioContext.getVariable<boolean>('updateDisputedStartDateFlag');
        if (!updateDisputedStartDateFlag) {
            CSReporter.info('updateDisputedStartDateFlag is false, skipping disputed start dates update');
            return;
        }

        const disputedStartDateToUpdate = this.scenarioContext.getVariable<string>('disputedStartDateToUpdate') || '';
        if (!disputedStartDateToUpdate) {
            CSReporter.info('disputedStartDateToUpdate is empty, skipping');
            return;
        }

        // Parse format: "DisputedMmte||MM/DD/YYYY;DisputedMmte||MM/DD/YYYY"
        const datePairs = disputedStartDateToUpdate.split(';').filter(p => p.trim());

        for (const pair of datePairs) {
            const [disputedMmte, dateValue] = pair.split('||').map(s => s.trim());
            if (disputedMmte && dateValue) {
                await this.zealDetailsPage.setDisputedStartDateForRow(disputedMmte, dateValue);
                CSReporter.info(`Set disputed start date for ${disputedMmte}: ${dateValue}`);
            }
        }
        CSReporter.pass(`Updated ${datePairs.length} disputed start dates`);
    }

    @CSBDDStepDef('I update FFX order if required')
    async updateFfxOrderIfRequired(): Promise<void> {
        const ffxOrderUpdateFlag = this.scenarioContext.getVariable<boolean>('ffxOrderUpdateFlag');
        if (!ffxOrderUpdateFlag) {
            CSReporter.info('ffxOrderUpdateFlag is false, skipping FFX order update');
            return;
        }

        const ffxOrderToUpdate = this.scenarioContext.getVariable<string>('ffxOrderToUpdate') || '';
        if (!ffxOrderToUpdate) {
            CSReporter.info('ffxOrderToUpdate is empty, skipping');
            return;
        }

        // Parse format: "MmteName||OrderNumber;MmteName||OrderNumber"
        const orderPairs = ffxOrderToUpdate.split(';').filter(p => p.trim());

        for (const pair of orderPairs) {
            const [mmteName, orderNumber] = pair.split('||').map(s => s.trim());
            if (mmteName && orderNumber) {
                await this.zealDetailsPage.setFfxOrderForRow(mmteName, parseInt(orderNumber, 10));
                CSReporter.info(`Set FFX order for ${mmteName}: ${orderNumber}`);
            }
        }
        CSReporter.pass(`Updated ${orderPairs.length} FFX orders`);
    }

    @CSBDDStepDef('I verify changes data matches expected updates')
    async verifyChangesDataMatchesExpectedUpdates(): Promise<void> {
        const zealId = this.scenarioContext.getVariable<string>('zealId');
        if (!zealId) {
            throw new Error('Zeal ID not found in scenario context');
        }
        CSReporter.info(`Verifying database change log for zeal ID: ${zealId}`);

        // Step 1: Execute change log query
        const changeLogResultSet = await TTTFDatabaseHelper.getChangeLogForZeal(zealId);
        if (changeLogResultSet.length === 0) {
            throw new Error(`No change log records found for zeal ID: ${zealId}`);
        }
        CSReporter.info(`Retrieved ${changeLogResultSet.length} change log records`);

        const currentDate = TTTFDatabaseHelper.getCurrentDateInOracleFormat();

        // Build scattered mmtes lists for later use
        const oldScatteredMmtesList: string[] = [];
        const newScatteredMmtesList: string[] = [];

        // Step 2: Verify SketchmarkFlagToUpdate
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (sketchmarkFlagToUpdate) {
            await this.verifySketchmarkFlagChange(changeLogResultSet, sketchmarkFlagToUpdate, currentDate);
        }

        // Step 3: Verify FFXFileInductorTypeToUpdate
        const ffxFileInductorTypeToUpdate = this.scenarioContext.getVariable<string>('ffxFileInductorTypeToUpdate');
        if (ffxFileInductorTypeToUpdate) {
            await this.verifyOutputTtcalcChange(changeLogResultSet, ffxFileInductorTypeToUpdate, currentDate);
        }

        // Step 4: Verify UpdateScatteredMmtesFlag
        const updateScatteredMmtesFlag = this.scenarioContext.getVariable<boolean>('updateScatteredMmtesFlag');
        if (updateScatteredMmtesFlag) {
            const scatteredMmtesToUpdate = this.scenarioContext.getVariable<string>('scatteredMmtesToUpdate') || '';
            if (scatteredMmtesToUpdate) {
                const listScatteredMmtesToUpdate = scatteredMmtesToUpdate.split(';').filter(p => p.trim());
                for (const item of listScatteredMmtesToUpdate) {
                    const subItems = item.split('||');
                    if (subItems.length >= 2) {
                        oldScatteredMmtesList.push(subItems[0].trim());
                        newScatteredMmtesList.push(subItems[1].trim());
                    }
                }

                // Store for later verification steps
                this.scenarioContext.setVariable('oldScatteredMmtesList', oldScatteredMmtesList);
                this.scenarioContext.setVariable('newScatteredMmtesList', newScatteredMmtesList);

                // Verify removed scattered mmtes
                await this.verifyRemovedScatteredMmtes(changeLogResultSet, oldScatteredMmtesList, currentDate);

                // Verify added scattered mmtes
                await this.verifyAddedScatteredMmtes(changeLogResultSet, newScatteredMmtesList, currentDate);
            }
        }

        // Step 5: Verify UpdateDisputedScatteredMmteFlag
        const updateDisputedScatteredMmteFlag = this.scenarioContext.getVariable<boolean>('updateDisputedScatteredMmteFlag');
        if (updateDisputedScatteredMmteFlag) {
            const disputedScatteredMmteToUpdate = this.scenarioContext.getVariable<string>('disputedScatteredMmteToUpdate') || '';
            if (disputedScatteredMmteToUpdate) {
                await this.verifyDisputedScatteredMmteChanges(changeLogResultSet, disputedScatteredMmteToUpdate, oldScatteredMmtesList, newScatteredMmtesList, currentDate);
            }
        }

        // Step 6: Verify UpdateDisputedStartDateFlag
        const updateDisputedStartDateFlag = this.scenarioContext.getVariable<boolean>('updateDisputedStartDateFlag');
        if (updateDisputedStartDateFlag) {
            const disputedStartDateToUpdate = this.scenarioContext.getVariable<string>('disputedStartDateToUpdate') || '';
            if (disputedStartDateToUpdate) {
                await this.verifyDisputedStartDateChanges(changeLogResultSet, disputedStartDateToUpdate, oldScatteredMmtesList, newScatteredMmtesList, currentDate);
            }
        }

        // Step 7: Verify FFXOrderUpdateFlag
        const ffxOrderUpdateFlag = this.scenarioContext.getVariable<boolean>('ffxOrderUpdateFlag');
        if (ffxOrderUpdateFlag) {
            const ffxOrderToUpdate = this.scenarioContext.getVariable<string>('ffxOrderToUpdate') || '';
            if (ffxOrderToUpdate) {
                await this.verifyFfxOrderChanges(changeLogResultSet, ffxOrderToUpdate, oldScatteredMmtesList, newScatteredMmtesList, currentDate);
            }
        }

        CSReporter.pass('All database change log verifications passed');
    }

    // ===================================================================
    // PRIVATE HELPER METHODS FOR DATABASE VERIFICATION
    // ===================================================================

    private async verifySketchmarkFlagChange(changeLog: ChangeLogRow[], sketchmarkFlagToUpdate: string, currentDate: string): Promise<void> {
        // Normalize flag value
        const valueToVerify = this.normalizeBooleanFlag(sketchmarkFlagToUpdate) ? 'true' : 'false';

        for (const row of changeLog) {
            if (row.fieldName === 'Sketchmark Replacement') {
                const strDBNewValue = row.newValue;
                const strDBAction = row.action;
                const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                if (strDBNewValue.toLowerCase() === valueToVerify && strDBAction === 'UPDATE' && strDBUpdatedDt === currentDate) {
                    CSReporter.pass(`Sketchmark Replacement verified: NewValue=${strDBNewValue}, Action=${strDBAction}, Date=${strDBUpdatedDt}`);
                    return;
                }
            }
        }
        throw new Error(`Sketchmark Replacement change not found or mismatch. Expected: NewValue=${valueToVerify}, Action=UPDATE, Date=${currentDate}`);
    }

    private async verifyOutputTtcalcChange(changeLog: ChangeLogRow[], ffxFileInductorTypeToUpdate: string, currentDate: string): Promise<void> {
        for (const row of changeLog) {
            if (row.fieldName === 'Output Ttcalc') {
                const strDBNewValue = row.newValue;
                const strDBAction = row.action;
                const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                if (strDBNewValue === ffxFileInductorTypeToUpdate && strDBAction === 'UPDATE' && strDBUpdatedDt === currentDate) {
                    CSReporter.pass(`Output Ttcalc verified: NewValue=${strDBNewValue}, Action=${strDBAction}, Date=${strDBUpdatedDt}`);
                    return;
                }
            }
        }
        throw new Error(`Output Ttcalc change not found or mismatch. Expected: NewValue=${ffxFileInductorTypeToUpdate}, Action=UPDATE, Date=${currentDate}`);
    }

    private async verifyRemovedScatteredMmtes(changeLog: ChangeLogRow[], oldScatteredMmtesList: string[], currentDate: string): Promise<void> {
        for (const oldMmte of oldScatteredMmtesList) {
            let found = false;
            for (const row of changeLog) {
                if (row.fieldName === 'Remove Scattered Mmte') {
                    const strDBOldValue = row.oldValue;
                    const strDBAction = row.action;
                    const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                    if (strDBOldValue === oldMmte && strDBAction === 'DELETE' && strDBUpdatedDt === currentDate) {
                        CSReporter.pass(`Remove Scattered Mmte verified: OldValue=${strDBOldValue}, Action=${strDBAction}, Date=${strDBUpdatedDt}`);
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                throw new Error(`Remove Scattered Mmte change not found for: ${oldMmte}. Expected: Action=DELETE, Date=${currentDate}`);
            }
        }
    }

    private async verifyAddedScatteredMmtes(changeLog: ChangeLogRow[], newScatteredMmtesList: string[], currentDate: string): Promise<void> {
        for (const newMmte of newScatteredMmtesList) {
            let found = false;
            for (const row of changeLog) {
                if (row.fieldName === 'Add Scattered Mmte') {
                    const strDBNewValue = row.newValue;
                    const strDBAction = row.action;
                    const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                    if (strDBNewValue === newMmte && strDBAction === 'ADD' && strDBUpdatedDt === currentDate) {
                        CSReporter.pass(`Add Scattered Mmte verified: NewValue=${strDBNewValue}, Action=${strDBAction}, Date=${strDBUpdatedDt}`);
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                throw new Error(`Add Scattered Mmte change not found for: ${newMmte}. Expected: Action=ADD, Date=${currentDate}`);
            }
        }
    }

    private async verifyDisputedScatteredMmteChanges(changeLog: ChangeLogRow[], disputedScatteredMmteToUpdate: string, oldScatteredMmtesList: string[], newScatteredMmtesList: string[], currentDate: string): Promise<void> {
        const listDisputedScatteredMmteToUpdate = disputedScatteredMmteToUpdate.split(';').filter(p => p.trim());

        for (const item of listDisputedScatteredMmteToUpdate) {
            const subItems = item.split('||');
            if (subItems.length < 2) continue;

            const refMmteName = subItems[0].trim();
            const disputedMmteName = subItems[1].trim();

            // Case 1: Scattered mmte is in oldScatteredMmtesList (UPDATE action on DisputedScatteredMmte)
            if (oldScatteredMmtesList.includes(refMmteName)) {
                let found = false;
                for (const row of changeLog) {
                    if (row.fieldName === 'DisputedScatteredMmte' && row.scatteredMmteName === refMmteName) {
                        const strDBNewValue = row.newValue;
                        const strDBAction = row.action;
                        const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                        if (strDBNewValue === disputedMmteName && strDBAction === 'UPDATE' && strDBUpdatedDt === currentDate) {
                            CSReporter.pass(`DisputedScatteredMmte UPDATE verified for ${refMmteName}: NewValue=${strDBNewValue}`);
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    throw new Error(`DisputedScatteredMmte UPDATE not found for: ${refMmteName}. Expected: NewValue=${disputedMmteName}`);
                }
            }
            // Case 2: Scattered mmte is in newScatteredMmtesList (ADD action includes disputed)
            else if (newScatteredMmtesList.includes(refMmteName)) {
                let found = false;
                for (const row of changeLog) {
                    if (row.fieldName === 'Add Scattered Mmte' && row.newValue === refMmteName) {
                        const strDBDisputedScatteredMmteName = row.disputedScatteredMmteName;
                        const strDBAction = row.action;
                        const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                        if (strDBDisputedScatteredMmteName === disputedMmteName && strDBAction === 'ADD' && strDBUpdatedDt === currentDate) {
                            CSReporter.pass(`Add Scattered Mmte with Disputed verified for ${refMmteName}: Disputed=${strDBDisputedScatteredMmteName}`);
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    throw new Error(`Add Scattered Mmte with Disputed not found for: ${refMmteName}. Expected: Disputed=${disputedMmteName}`);
                }
            }
        }
    }

    private async verifyDisputedStartDateChanges(changeLog: ChangeLogRow[], disputedStartDateToUpdate: string, oldScatteredMmtesList: string[], newScatteredMmtesList: string[], currentDate: string): Promise<void> {
        const listDisputedStartDateToUpdate = disputedStartDateToUpdate.split(';').filter(p => p.trim());

        for (const item of listDisputedStartDateToUpdate) {
            const subItems = item.split('||');
            if (subItems.length < 2) continue;

            const refMmteName = subItems[0].trim();
            const disputedStartDate = subItems[1].trim();

            // Case 1: Scattered mmte is in oldScatteredMmtesList (UPDATE action on DisputedDate)
            if (oldScatteredMmtesList.includes(refMmteName)) {
                let found = false;
                for (const row of changeLog) {
                    if (row.fieldName === 'DisputedDate' && row.scatteredMmteName === refMmteName) {
                        const strDBNewValue = row.newValue;
                        const strDBAction = row.action;
                        const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                        if (strDBNewValue === disputedStartDate && strDBAction === 'UPDATE' && strDBUpdatedDt === currentDate) {
                            CSReporter.pass(`DisputedDate UPDATE verified for ${refMmteName}: NewValue=${strDBNewValue}`);
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    throw new Error(`DisputedDate UPDATE not found for: ${refMmteName}. Expected: NewValue=${disputedStartDate}`);
                }
            }
            // Case 2: Scattered mmte is in newScatteredMmtesList (ADD action includes disputed start date)
            else if (newScatteredMmtesList.includes(refMmteName)) {
                let found = false;
                for (const row of changeLog) {
                    if (row.fieldName === 'Add Scattered Mmte' && row.newValue === refMmteName) {
                        const strDBDisputedStartDate = row.disputedStartDate;
                        const strDBAction = row.action;
                        const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                        if (strDBDisputedStartDate === disputedStartDate && strDBAction === 'ADD' && strDBUpdatedDt === currentDate) {
                            CSReporter.pass(`Add Scattered Mmte with DisputedStartDate verified for ${refMmteName}: Date=${strDBDisputedStartDate}`);
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    throw new Error(`Add Scattered Mmte with DisputedStartDate not found for: ${refMmteName}. Expected: Date=${disputedStartDate}`);
                }
            }
        }
    }

    private async verifyFfxOrderChanges(changeLog: ChangeLogRow[], ffxOrderToUpdate: string, oldScatteredMmtesList: string[], newScatteredMmtesList: string[], currentDate: string): Promise<void> {
        const listFfxOrderToUpdate = ffxOrderToUpdate.split(';').filter(p => p.trim());

        for (const item of listFfxOrderToUpdate) {
            const subItems = item.split('||');
            if (subItems.length < 2) continue;

            const refMmteName = subItems[0].trim();
            const ffxOrder = subItems[1].trim();

            // Case 1: Scattered mmte is in oldScatteredMmtesList (UPDATE action on FFX Order)
            if (oldScatteredMmtesList.includes(refMmteName)) {
                let found = false;
                for (const row of changeLog) {
                    if (row.fieldName === 'FFX Order' && row.scatteredMmteName === refMmteName) {
                        const strDBNewValue = row.newValue;
                        const strDBAction = row.action;
                        const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                        if (strDBNewValue === ffxOrder && strDBAction === 'UPDATE' && strDBUpdatedDt === currentDate) {
                            CSReporter.pass(`FFX Order UPDATE verified for ${refMmteName}: NewValue=${strDBNewValue}`);
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    throw new Error(`FFX Order UPDATE not found for: ${refMmteName}. Expected: NewValue=${ffxOrder}`);
                }
            }
            // Case 2: Scattered mmte is in newScatteredMmtesList (ADD action includes ffx order)
            else if (newScatteredMmtesList.includes(refMmteName)) {
                let found = false;
                for (const row of changeLog) {
                    if (row.fieldName === 'Add Scattered Mmte' && row.newValue === refMmteName) {
                        const strDBFfxOrder = String(row.ffxOrder);
                        const strDBAction = row.action;
                        const strDBUpdatedDt = TTTFDatabaseHelper.extractDateFromOracleTimestamp(row.updatedDt);

                        if (strDBFfxOrder === ffxOrder && strDBAction === 'ADD' && strDBUpdatedDt === currentDate) {
                            CSReporter.pass(`Add Scattered Mmte with FFX Order verified for ${refMmteName}: Order=${strDBFfxOrder}`);
                            found = true;
                            break;
                        }
                    }
                }
                if (!found) {
                    throw new Error(`Add Scattered Mmte with FFX Order not found for: ${refMmteName}. Expected: Order=${ffxOrder}`);
                }
            }
        }
    }

    private normalizeBooleanFlag(value: string): boolean {
        const lowerValue = value.toLowerCase().trim();
        return lowerValue === 'yes' || lowerValue === 'y' || lowerValue === 'true';
    }

    @CSBDDStepDef('I verify zealpremisis data has updated settings')
    async verifyZealpremisisDataHasUpdatedSettings(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const zealpremisisData = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!zealpremisisData) {
            throw new Error(`Zealpremisis data not found for ID: ${zealpremisisDataId}`);
        }

        // Verify updated sketchmark flag
        const expectedSketchmarkFlag = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate');
        if (expectedSketchmarkFlag && zealpremisisData.sketchmarkReplacementFlag !== expectedSketchmarkFlag) {
            throw new Error(`Sketchmark flag mismatch: Expected=${expectedSketchmarkFlag}, Actual=${zealpremisisData.sketchmarkReplacementFlag}`);
        }

        CSReporter.pass('Zealpremisis data has updated settings');
    }

    @CSBDDStepDef('I verify Use Sketchmark Replacement shows expected updated value')
    async verifyUseSketchmarkReplacementShowsExpectedUpdatedValue(): Promise<void> {
        const sketchmarkFlagToUpdate = this.scenarioContext.getVariable<string>('sketchmarkFlagToUpdate') || 'N';
        const expectedValue = sketchmarkFlagToUpdate === 'Y' ? 'True' : 'False';
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === expectedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows expected updated value: ${actualValue}`);
        } else {
            throw new Error(`Use Sketchmark Replacement mismatch after approval: Expected=${expectedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify updated scattered mmtes in UI match database')
    async verifyUpdatedScatteredMmtesInUIMatchDatabase(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const dbMmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);
        const uiMmteCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (uiMmteCount === dbMmteData.length) {
            CSReporter.pass(`Updated scattered mmtes in UI match database: ${uiMmteCount} mmtes`);
        } else {
            throw new Error(`Scattered mmtes count mismatch: UI=${uiMmteCount}, DB=${dbMmteData.length}`);
        }
    }
