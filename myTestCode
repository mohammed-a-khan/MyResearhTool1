import { StepDefinitions, CSBDDStepDef, Page } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSBDDContext, CSScenarioContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSValueResolver } from '@mdakhan.mak/cs-playwright-test-framework/utilities';
import { CSBrowserManager } from '@mdakhan.mak/cs-playwright-test-framework/browser';

import { TTTFNavigationPage } from '../pages/TTTFNavigationPage';
import { TTTFZealPremisisPage } from '../pages/TTTFZealPremisisPage';
import { TTTFZealDetailsPage } from '../pages/TTTFZealDetailsPage';
import { TTTFScatteredMmtesModalPage } from '../pages/TTTFScatteredMmtesModalPage';
import { TTTFChangesHistoryPage } from '../pages/TTTFChangesHistoryPage';
import { TTTFPendingApprovalsPage } from '../pages/TTTFPendingApprovalsPage';
import { TTTFDatabaseHelper } from '../helpers/TTTFDatabaseHelper';

/**
 * TTTF New Zeal Setup Step Definitions
 * Source: SCENARIO_03_NewZeal_Approval.txt
 * Implements Maker-Checker workflow for new zeal setup
 */
@StepDefinitions
export class TTTFNewZealSteps {

    @Page('tttf-navigation')
    private navigationPage!: TTTFNavigationPage;

    @Page('tttf-zeal-premisis')
    private zealPremisisPage!: TTTFZealPremisisPage;

    @Page('tttf-zeal-details')
    private zealDetailsPage!: TTTFZealDetailsPage;

    @Page('tttf-scattered-mmtes-modal')
    private scatteredMmtesModalPage!: TTTFScatteredMmtesModalPage;

    @Page('tttf-changes-history')
    private changesHistoryPage!: TTTFChangesHistoryPage;

    @Page('tttf-pending-approvals')
    private pendingApprovalsPage!: TTTFPendingApprovalsPage;

    private context = CSBDDContext.getInstance();
    private scenarioContext = CSScenarioContext.getInstance();

    // ===================================================================
    // TEST DATA SETUP STEPS
    // ===================================================================

    /**
     * Comprehensive test data setup step for new zeal scenarios.
     * Follows the JSON-first, DB-disputed pattern with flat structure and delimiter format.
     *
     * JSON Structure:
     * - zealKey, zealId, zealName: if all empty, query DB
     * - sketchmarkFlag: defaults to "No" if not provided
     * - outputTtcalcFile: defaults to "No" if not provided
     * - ffxFileInductorType: if outputTtcalcFile=Yes and not provided, query DB
     * - scatteredMmtesToAdd: "Mmte1;Mmte2;Mmte3" or empty for DB lookup
     * - addDisputedScatteredMmteFlag: "true/false" to control disputed setup
     * - disputedScatteredMmteToAdd: "RefMmte||DisputedMmte;RefMmte||DisputedMmte" or empty for DB lookup
     * - addDisputedStartDateFlag: "true/false" to control disputed start date setup
     * - disputedStartDateToAdd: "DisputedMmte||mm/dd/yyyy;DisputedMmte||mm/dd/yyyy" or empty for auto-ttcalc
     */
    @CSBDDStepDef('I prepare test data for new zeal setup')
    async prepareTestDataForNewZealSetup(): Promise<void> {
        CSReporter.info('Preparing comprehensive test data for new zeal setup (flat structure with delimiter format)');

        // ===================================================================
        // STEP 1: Resolve Zeal Information
        // ===================================================================
        let zealId = this.scenarioContext.getVariable<string>('zealId');
        let zealKey = this.scenarioContext.getVariable<string>('zealKey');
        let zealName = this.scenarioContext.getVariable<string>('zealName');

        // If none provided in JSON, query DB
        if (!zealId && !zealKey && !zealName) {
            CSReporter.info('No zeal info in test data JSON, querying database...');
            const zealDetails = await TTTFDatabaseHelper.getZealForNewSetup();
            if (!zealDetails) {
                throw new Error('No zeal available for new setup in database');
            }
            zealId = zealDetails.zealId;
            zealKey = zealDetails.zealKey;
            zealName = zealDetails.zealName;

            // Store additional zeal details
            this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
            this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
            this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);
            this.scenarioContext.setVariable('premisisDescription', zealDetails.premisisDescription);
            this.scenarioContext.setVariable('calcShoolName', zealDetails.calcShoolName);
            this.scenarioContext.setVariable('administrator', zealDetails.administrator);

            CSReporter.info(`Retrieved zeal from DB: ID=${zealId}, Key=${zealKey}, Name=${zealName}`);
        } else {
            CSReporter.info(`Using zeal from JSON: ID=${zealId || 'N/A'}, Key=${zealKey || 'N/A'}, Name=${zealName || 'N/A'}`);
        }

        // Store resolved zeal info
        this.scenarioContext.setVariable('zealId', zealId);
        this.scenarioContext.setVariable('zealKey', zealKey);
        this.scenarioContext.setVariable('zealName', zealName);

        // ===================================================================
        // STEP 2: Resolve Flags with Defaults
        // ===================================================================
        let sketchmarkFlag = this.scenarioContext.getVariable<string>('sketchmarkFlag');
        if (!sketchmarkFlag) {
            sketchmarkFlag = 'No';
            CSReporter.info('sketchmarkFlag not provided, defaulting to "No"');
        }
        this.scenarioContext.setVariable('sketchmarkFlag', sketchmarkFlag);

        let outputTtcalcFile = this.scenarioContext.getVariable<string>('outputTtcalcFile');
        if (!outputTtcalcFile) {
            outputTtcalcFile = 'No';
            CSReporter.info('outputTtcalcFile not provided, defaulting to "No"');
        }
        this.scenarioContext.setVariable('outputTtcalcFile', outputTtcalcFile);

        // ===================================================================
        // STEP 3: Resolve FFX File Inductor Type (if outputTtcalcFile=Yes)
        // ===================================================================
        if (outputTtcalcFile.toLowerCase() === 'yes') {
            let ffxFileInductorType = this.scenarioContext.getVariable<string>('ffxFileInductorType');
            if (!ffxFileInductorType) {
                CSReporter.info('ffxFileInductorType not provided, querying database...');
                ffxFileInductorType = await TTTFDatabaseHelper.getFirstFfxInductorType() || 'RMBS';
                CSReporter.info(`Retrieved FFX Inductor Type from DB: ${ffxFileInductorType}`);
            } else {
                CSReporter.info(`Using FFX Inductor Type from JSON: ${ffxFileInductorType}`);
            }
            this.scenarioContext.setVariable('ffxFileInductorType', ffxFileInductorType);
        }

        // ===================================================================
        // STEP 4: Resolve Scattered Mmtes to Add (delimiter format: "Mmte1;Mmte2;Mmte3")
        // ===================================================================
        const scatteredMmtesToAddStr = this.scenarioContext.getVariable<string>('scatteredMmtesToAdd');
        let scatteredMmtesToAdd: string[] = [];

        if (scatteredMmtesToAddStr && scatteredMmtesToAddStr.trim()) {
            // Parse delimiter-sepammted string
            scatteredMmtesToAdd = scatteredMmtesToAddStr.split(';').map(s => s.trim()).filter(s => s);
            CSReporter.info(`Using ${scatteredMmtesToAdd.length} scattered mmtes from JSON: ${scatteredMmtesToAdd.join(', ')}`);

            // Get details for JSON-provided mmtes
            const scatteredMmtesDetails = [];
            for (const mmteName of scatteredMmtesToAdd) {
                const details = await TTTFDatabaseHelper.getScatteredMmteDetails(mmteName);
                if (details) {
                    scatteredMmtesDetails.push({
                        scatteredMmteName: mmteName,
                        methodologyType: details.methodologyType
                    });
                }
            }
            this.scenarioContext.setVariable('scatteredMmtesDetails', scatteredMmtesDetails);
        } else {
            CSReporter.info('scatteredMmtesToAdd not provided in JSON, querying database...');
            const scatteredMmtes = await TTTFDatabaseHelper.getScatteredMmtesToAdd();
            if (scatteredMmtes.length === 0) {
                throw new Error('No scattered mmtes available to add from database');
            }
            scatteredMmtesToAdd = scatteredMmtes.map(r => r.scatteredMmteName);
            this.scenarioContext.setVariable('scatteredMmtesDetails', scatteredMmtes);
            CSReporter.info(`Retrieved ${scatteredMmtesToAdd.length} scattered mmtes from DB: ${scatteredMmtesToAdd.join(', ')}`);
        }
        this.scenarioContext.setVariable('scatteredMmtesToAdd', scatteredMmtesToAdd);

        // ===================================================================
        // STEP 5: Resolve Disputed Scattered Mmtes (delimiter format)
        // Flag: addDisputedScatteredMmteFlag - "true/false/Yes/No"
        // Data: disputedScatteredMmteToAdd - "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
        // ===================================================================
        const addDisputedScatteredMmteFlagStr = this.scenarioContext.getVariable<string>('addDisputedScatteredMmteFlag') || 'false';
        const isDisputedEnabled = this.isYesOrTrue(addDisputedScatteredMmteFlagStr);

        if (isDisputedEnabled) {
            const disputedScatteredMmteToAddStr = this.scenarioContext.getVariable<string>('disputedScatteredMmteToAdd') || '';

            if (disputedScatteredMmteToAddStr.trim()) {
                // Parse user-provided delimiter format: "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
                CSReporter.info(`Using disputed scattered mmtes from JSON: ${disputedScatteredMmteToAddStr}`);
                this.scenarioContext.setVariable('disputedScatteredMmteToAdd', disputedScatteredMmteToAddStr);
            } else {
                // Query DB for disputed mmtes (excluding already selected scattered mmtes)
                CSReporter.info('disputedScatteredMmteToAdd not provided in JSON, querying database...');
                const disputedMmtes = await TTTFDatabaseHelper.getDisputedScatteredMmtes(scatteredMmtesToAdd);

                if (disputedMmtes.length === 0) {
                    CSReporter.warn('No disputed scattered mmtes available from database');
                    this.scenarioContext.setVariable('disputedScatteredMmteToAdd', '');
                } else {
                    // Build delimiter format: "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
                    const disputedPairs: string[] = [];
                    for (let i = 0; i < scatteredMmtesToAdd.length && i < disputedMmtes.length; i++) {
                        const refMmteName = scatteredMmtesToAdd[i];
                        const disputedMmte = disputedMmtes[i];
                        disputedPairs.push(`${refMmteName}||${disputedMmte.scatteredMmteName}`);
                        CSReporter.info(`Mapped disputed: ${refMmteName} -> ${disputedMmte.scatteredMmteName}`);
                    }
                    const disputedScatteredMmteToAdd = disputedPairs.join(';');
                    this.scenarioContext.setVariable('disputedScatteredMmteToAdd', disputedScatteredMmteToAdd);
                    CSReporter.info(`Created disputed mapping from DB: ${disputedScatteredMmteToAdd}`);
                }
            }
        } else {
            CSReporter.info('addDisputedScatteredMmteFlag is false, skipping disputed scattered mmte configuration');
            this.scenarioContext.setVariable('disputedScatteredMmteToAdd', '');
        }

        // ===================================================================
        // STEP 6: Resolve Disputed Start Dates (delimiter format)
        // Flag: addDisputedStartDateFlag - "true/false/Yes/No"
        // Data: disputedStartDateToAdd - "DisputedMmte||mm/dd/yyyy;DisputedMmte||mm/dd/yyyy"
        // ===================================================================
        const addDisputedStartDateFlagStr = this.scenarioContext.getVariable<string>('addDisputedStartDateFlag') || 'false';
        const isDisputedStartDateEnabled = this.isYesOrTrue(addDisputedStartDateFlagStr);

        if (isDisputedStartDateEnabled && isDisputedEnabled) {
            const disputedStartDateToAddStr = this.scenarioContext.getVariable<string>('disputedStartDateToAdd') || '';

            if (disputedStartDateToAddStr.trim()) {
                // Parse user-provided delimiter format: "DisputedMmte||mm/dd/yyyy;DisputedMmte||mm/dd/yyyy"
                CSReporter.info(`Using disputed start dates from JSON: ${disputedStartDateToAddStr}`);
                this.scenarioContext.setVariable('disputedStartDateToAdd', disputedStartDateToAddStr);
            } else {
                // Auto-genemmte disputed start dates based on disputed mmtes
                CSReporter.info('disputedStartDateToAdd not provided in JSON, auto-generating...');
                const disputedScatteredMmteToAdd = this.scenarioContext.getVariable<string>('disputedScatteredMmteToAdd') || '';

                if (disputedScatteredMmteToAdd) {
                    const disputedStartDate = TTTFDatabaseHelper.calculateDisputedStartDate();
                    const datePairs: string[] = [];

                    // Parse disputed mmtes and genemmte dates for each disputed mmte
                    const disputedMappings = disputedScatteredMmteToAdd.split(';').filter(s => s.trim());
                    for (const mapping of disputedMappings) {
                        const [, disputedMmte] = mapping.split('||').map(s => s.trim());
                        if (disputedMmte) {
                            datePairs.push(`${disputedMmte}||${disputedStartDate}`);
                        }
                    }

                    const disputedStartDateToAdd = datePairs.join(';');
                    this.scenarioContext.setVariable('disputedStartDateToAdd', disputedStartDateToAdd);
                    CSReporter.info(`Auto-genemmted disputed start dates: ${disputedStartDateToAdd}`);
                } else {
                    this.scenarioContext.setVariable('disputedStartDateToAdd', '');
                }
            }
        } else {
            CSReporter.info('addDisputedStartDateFlag is false or disputed not enabled, skipping disputed start date configuration');
            this.scenarioContext.setVariable('disputedStartDateToAdd', '');
        }

        // ===================================================================
        // SUMMARY
        // ===================================================================
        CSReporter.pass('Test data preparation complete:');
        CSReporter.info(`  - Zeal ID: ${this.scenarioContext.getVariable('zealId')}`);
        CSReporter.info(`  - Zeal Key: ${this.scenarioContext.getVariable('zealKey')}`);
        CSReporter.info(`  - Zeal Name: ${this.scenarioContext.getVariable('zealName')}`);
        CSReporter.info(`  - Sketchmark Flag: ${this.scenarioContext.getVariable('sketchmarkFlag')}`);
        CSReporter.info(`  - Output Ttcalc File: ${this.scenarioContext.getVariable('outputTtcalcFile')}`);
        CSReporter.info(`  - FFX File Inductor Type: ${this.scenarioContext.getVariable('ffxFileInductorType') || 'N/A'}`);
        CSReporter.info(`  - Scattered Mmtes to Add: ${(this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[])?.join(', ')}`);
        CSReporter.info(`  - Add Disputed Scattered Mmte Flag: ${addDisputedScatteredMmteFlagStr}`);
        CSReporter.info(`  - Disputed Scattered Mmte Mapping: ${this.scenarioContext.getVariable('disputedScatteredMmteToAdd') || 'N/A'}`);
        CSReporter.info(`  - Add Disputed Start Date Flag: ${addDisputedStartDateFlagStr}`);
        CSReporter.info(`  - Disputed Start Date Mapping: ${this.scenarioContext.getVariable('disputedStartDateToAdd') || 'N/A'}`);
    }

    /**
     * Helper method to check if a flag value is "Yes", "True", "Y", "true" (case insensitive)
     */
    private isYesOrTrue(value: string): boolean {
        const normalized = value?.toLowerCase().trim();
        return normalized === 'yes' || normalized === 'y' || normalized === 'true';
    }

    // Keep legacy steps for backward compatibility (they now delegate to the comprehensive step)
    @CSBDDStepDef('I get zeal for new setup from database')
    async getZealForNewSetupFromDatabase(): Promise<void> {
        CSReporter.info('Getting zeal for new setup from database');

        const zealDetails = await TTTFDatabaseHelper.getZealForNewSetup();
        if (!zealDetails) {
            throw new Error('No zeal available for new setup in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);
        this.scenarioContext.setVariable('premisisDescription', zealDetails.premisisDescription);
        this.scenarioContext.setVariable('calcShoolName', zealDetails.calcShoolName);
        this.scenarioContext.setVariable('administrator', zealDetails.administrator);

        CSReporter.pass(`Retrieved zeal for new setup: ID=${zealDetails.zealId}, Name=${zealDetails.zealName}`);
    }

    @CSBDDStepDef('I get scattered mmtes to add from database')
    async getScatteredMmtesToAddFromDatabase(): Promise<void> {
        CSReporter.info('Getting scattered mmtes to add from database');

        const scatteredMmtes = await TTTFDatabaseHelper.getScatteredMmtesToAdd();
        if (scatteredMmtes.length === 0) {
            throw new Error('No scattered mmtes available to add from database');
        }

        const mmteNames = scatteredMmtes.map(r => r.scatteredMmteName);
        this.scenarioContext.setVariable('scatteredMmtesToAdd', mmteNames);
        this.scenarioContext.setVariable('scatteredMmtesDetails', scatteredMmtes);

        CSReporter.pass(`Retrieved ${mmteNames.length} scattered mmtes to add: ${mmteNames.join(', ')}`);
    }

    // ===================================================================
    // ZEAL DETAILS PAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I should see Zeal Details page')
    async verifyZealDetailsPage(): Promise<void> {
        await this.zealDetailsPage.verifyZealDetailsPageDisplayed();
    }

    @CSBDDStepDef('I should see Edit Zeal page')
    async verifyEditZealPage(): Promise<void> {
        await this.zealDetailsPage.verifyEditZealPageDisplayed();
    }

    @CSBDDStepDef('Edit button should be enabled')
    async verifyEditButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isEditButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Edit button is enabled');
        } else {
            throw new Error('Edit button is not enabled');
        }
    }

    @CSBDDStepDef('Edit button should be disabled')
    async verifyEditButtonDisabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isEditButtonEnabled();
        if (!isEnabled) {
            CSReporter.pass('Edit button is disabled');
        } else {
            throw new Error('Edit button is not disabled');
        }
    }

    @CSBDDStepDef('I click Edit button')
    async clickEditButton(): Promise<void> {
        await this.zealDetailsPage.clickEditButton();
    }

    @CSBDDStepDef('Details tab should be selected')
    async verifyDetailsTabSelected(): Promise<void> {
        const isSelected = await this.zealDetailsPage.isDetailsTabSelected();
        if (isSelected) {
            CSReporter.pass('Details tab is selected');
        } else {
            throw new Error('Details tab is not selected');
        }
    }

    @CSBDDStepDef('I click Changes tab')
    async clickChangesTab(): Promise<void> {
        await this.zealDetailsPage.clickChangesTab();
    }

    @CSBDDStepDef('I click History tab')
    async clickHistoryTab(): Promise<void> {
        await this.zealDetailsPage.clickHistoryTab();
    }

    @CSBDDStepDef('I click Details tab')
    async clickDetailsTab(): Promise<void> {
        await this.zealDetailsPage.clickDetailsTab();
    }

    @CSBDDStepDef('Changes tab should be present')
    async verifyChangesTabPresent(): Promise<void> {
        const isPresent = await this.zealDetailsPage.isChangesTabPresent();
        if (isPresent) {
            CSReporter.pass('Changes tab is present');
        } else {
            throw new Error('Changes tab is not present');
        }
    }

    @CSBDDStepDef('History tab should be present')
    async verifyHistoryTabPresent(): Promise<void> {
        const isPresent = await this.zealDetailsPage.isHistoryTabPresent();
        if (isPresent) {
            CSReporter.pass('History tab is present');
        } else {
            throw new Error('History tab is not present');
        }
    }

    @CSBDDStepDef('Cancel button should be enabled')
    async verifyZealCancelButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isCancelButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Cancel button is enabled');
        } else {
            throw new Error('Cancel button is not enabled');
        }
    }

    @CSBDDStepDef('Use Sketchmark Replacement checkbox should be unchecked')
    async verifyUseSketchmarkReplacementUnchecked(): Promise<void> {
        const isChecked = await this.zealDetailsPage.isUseSketchmarkReplacementChecked();
        if (!isChecked) {
            CSReporter.pass('Use Sketchmark Replacement checkbox is unchecked');
        } else {
            throw new Error('Use Sketchmark Replacement checkbox should be unchecked but is checked');
        }
    }

    @CSBDDStepDef('Output Ttcalc File checkbox should be unchecked')
    async verifyOutputTtcalcFileUnchecked(): Promise<void> {
        const isChecked = await this.zealDetailsPage.isOutputTtcalcFileChecked();
        if (!isChecked) {
            CSReporter.pass('Output Ttcalc File checkbox is unchecked');
        } else {
            throw new Error('Output Ttcalc File checkbox should be unchecked but is checked');
        }
    }

    @CSBDDStepDef('Reorder button should be visible')
    async verifyReorderButtonVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isReorderButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reorder button is visible');
        } else {
            throw new Error('Reorder button is not visible');
        }
    }

    // ===================================================================
    // SUMMARY SECTION VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('Summary section should be visible')
    async verifySummaryVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.summaryHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Summary section is visible');
        } else {
            throw new Error('Summary section is not visible');
        }
    }

    @CSBDDStepDef('Zeal ID in Summary should match stored value')
    async verifyZealIdInSummary(): Promise<void> {
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealDetailsPage.getZealId();

        if (actualZealId === expectedZealId) {
            CSReporter.pass(`Zeal ID matches: ${actualZealId}`);
        } else {
            throw new Error(`Zeal ID mismatch: Expected=${expectedZealId}, Actual=${actualZealId}`);
        }
    }

    @CSBDDStepDef('Zeal Name in Summary should match stored value')
    async verifyZealNameInSummary(): Promise<void> {
        const expectedZealName = this.scenarioContext.getVariable('zealName');
        const actualZealName = await this.zealDetailsPage.getZealName();

        if (actualZealName === expectedZealName) {
            CSReporter.pass(`Zeal Name matches: ${actualZealName}`);
        } else {
            throw new Error(`Zeal Name mismatch: Expected=${expectedZealName}, Actual=${actualZealName}`);
        }
    }

    @CSBDDStepDef('Zeal Key in Summary should match stored value')
    async verifyZealKeyInSummary(): Promise<void> {
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealDetailsPage.getZealKey();

        if (actualZealKey === expectedZealKey) {
            CSReporter.pass(`Zeal Key matches: ${actualZealKey}`);
        } else {
            throw new Error(`Zeal Key mismatch: Expected=${expectedZealKey}, Actual=${actualZealKey}`);
        }
    }

    @CSBDDStepDef('Zzzt Seggregation in Summary should match stored value')
    async verifyZzztSeggregationInSummary(): Promise<void> {
        const expectedZzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');
        const actualZzztAbbrev = await this.zealDetailsPage.getZzztSeggregation();

        if (actualZzztAbbrev === expectedZzztAbbrev) {
            CSReporter.pass(`Zzzt Seggregation matches: ${actualZzztAbbrev}`);
        } else {
            throw new Error(`Zzzt Seggregation mismatch: Expected=${expectedZzztAbbrev}, Actual=${actualZzztAbbrev}`);
        }
    }

    @CSBDDStepDef('Premisis Description in Summary should match stored value')
    async verifyPremisisDescriptionInSummary(): Promise<void> {
        const expectedPremisisDesc = this.scenarioContext.getVariable('premisisDescription');
        const actualPremisisDesc = await this.zealDetailsPage.getPremisisDescription();

        if (actualPremisisDesc === expectedPremisisDesc) {
            CSReporter.pass(`Premisis Description matches: ${actualPremisisDesc}`);
        } else {
            throw new Error(`Premisis Description mismatch: Expected=${expectedPremisisDesc}, Actual=${actualPremisisDesc}`);
        }
    }

    @CSBDDStepDef('Inductor Group in Summary should match stored value')
    async verifyInductorGroupInSummary(): Promise<void> {
        const expectedInductorGroup = this.scenarioContext.getVariable('inductorGroup');
        const actualInductorGroup = await this.zealDetailsPage.getInductorGroup();

        if (actualInductorGroup === expectedInductorGroup) {
            CSReporter.pass(`Inductor Group matches: ${actualInductorGroup}`);
        } else {
            throw new Error(`Inductor Group mismatch: Expected=${expectedInductorGroup}, Actual=${actualInductorGroup}`);
        }
    }

    @CSBDDStepDef('Kindness Circle in Summary should match stored value')
    async verifyKindnessCircleInSummary(): Promise<void> {
        const expectedKindnessCircle = this.scenarioContext.getVariable('kindnessCircle');
        const actualKindnessCircle = await this.zealDetailsPage.getKindnessCircle();

        if (actualKindnessCircle === expectedKindnessCircle) {
            CSReporter.pass(`Kindness Circle matches: ${actualKindnessCircle}`);
        } else {
            throw new Error(`Kindness Circle mismatch: Expected=${expectedKindnessCircle}, Actual=${actualKindnessCircle}`);
        }
    }

    @CSBDDStepDef('Ttcalc Shool in Summary should match stored value')
    async verifyTtcalcShoolInSummary(): Promise<void> {
        const expectedCalcShool = this.scenarioContext.getVariable('calcShoolName');
        const actualCalcShool = await this.zealDetailsPage.getTtcalcShool();

        // Ttcalc Shool in UI may have additional "(CIF File Name)" suffix
        if (actualCalcShool.includes(expectedCalcShool) || actualCalcShool === expectedCalcShool) {
            CSReporter.pass(`Ttcalc Shool matches: ${actualCalcShool}`);
        } else {
            throw new Error(`Ttcalc Shool mismatch: Expected=${expectedCalcShool}, Actual=${actualCalcShool}`);
        }
    }

    @CSBDDStepDef('Account Manager in Summary should match stored value')
    async verifyAccountManagerInSummary(): Promise<void> {
        const expectedAdmin = this.scenarioContext.getVariable('administrator');
        const actualAdmin = await this.zealDetailsPage.getAdministratorValue();

        if (actualAdmin === expectedAdmin) {
            CSReporter.pass(`Account Manager matches: ${actualAdmin}`);
        } else {
            throw new Error(`Account Manager mismatch: Expected=${expectedAdmin}, Actual=${actualAdmin}`);
        }
    }

    @CSBDDStepDef('I verify all Summary fields match database values')
    async verifyAllSummaryFieldsMatchDatabase(): Promise<void> {
        CSReporter.info('Verifying all Summary section fields against database values');

        // Zeal ID
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealDetailsPage.getZealId();
        if (actualZealId !== expectedZealId) {
            throw new Error(`Zeal ID mismatch: Expected=${expectedZealId}, Actual=${actualZealId}`);
        }
        CSReporter.info(`Zeal ID verified: ${actualZealId}`);

        // Zeal Key
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealDetailsPage.getZealKey();
        if (actualZealKey !== expectedZealKey) {
            throw new Error(`Zeal Key mismatch: Expected=${expectedZealKey}, Actual=${actualZealKey}`);
        }
        CSReporter.info(`Zeal Key verified: ${actualZealKey}`);

        // Zeal Name
        const expectedZealName = this.scenarioContext.getVariable('zealName');
        const actualZealName = await this.zealDetailsPage.getZealName();
        if (actualZealName !== expectedZealName) {
            throw new Error(`Zeal Name mismatch: Expected=${expectedZealName}, Actual=${actualZealName}`);
        }
        CSReporter.info(`Zeal Name verified: ${actualZealName}`);

        // Zzzt Seggregation
        const expectedZzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');
        const actualZzztAbbrev = await this.zealDetailsPage.getZzztSeggregation();
        if (actualZzztAbbrev !== expectedZzztAbbrev) {
            throw new Error(`Zzzt Seggregation mismatch: Expected=${expectedZzztAbbrev}, Actual=${actualZzztAbbrev}`);
        }
        CSReporter.info(`Zzzt Seggregation verified: ${actualZzztAbbrev}`);

        // Premisis Description
        const expectedPremisisDesc = this.scenarioContext.getVariable('premisisDescription');
        const actualPremisisDesc = await this.zealDetailsPage.getPremisisDescription();
        if (actualPremisisDesc !== expectedPremisisDesc) {
            throw new Error(`Premisis Description mismatch: Expected=${expectedPremisisDesc}, Actual=${actualPremisisDesc}`);
        }
        CSReporter.info(`Premisis Description verified: ${actualPremisisDesc}`);

        // Inductor Group
        const expectedInductorGroup = this.scenarioContext.getVariable('inductorGroup');
        const actualInductorGroup = await this.zealDetailsPage.getInductorGroup();
        if (actualInductorGroup !== expectedInductorGroup) {
            throw new Error(`Inductor Group mismatch: Expected=${expectedInductorGroup}, Actual=${actualInductorGroup}`);
        }
        CSReporter.info(`Inductor Group verified: ${actualInductorGroup}`);

        // Kindness Circle
        const expectedKindnessCircle = this.scenarioContext.getVariable('kindnessCircle');
        const actualKindnessCircle = await this.zealDetailsPage.getKindnessCircle();
        if (actualKindnessCircle !== expectedKindnessCircle) {
            throw new Error(`Kindness Circle mismatch: Expected=${expectedKindnessCircle}, Actual=${actualKindnessCircle}`);
        }
        CSReporter.info(`Kindness Circle verified: ${actualKindnessCircle}`);

        // Ttcalc Shool
        const expectedCalcShool = this.scenarioContext.getVariable('calcShoolName');
        const actualCalcShool = await this.zealDetailsPage.getTtcalcShool();
        if (!actualCalcShool.includes(expectedCalcShool) && actualCalcShool !== expectedCalcShool) {
            throw new Error(`Ttcalc Shool mismatch: Expected=${expectedCalcShool}, Actual=${actualCalcShool}`);
        }
        CSReporter.info(`Ttcalc Shool verified: ${actualCalcShool}`);

        // Account Manager (Administrator)
        const expectedAdmin = this.scenarioContext.getVariable('administrator');
        const actualAdmin = await this.zealDetailsPage.getAdministratorValue();
        if (actualAdmin !== expectedAdmin) {
            throw new Error(`Account Manager mismatch: Expected=${expectedAdmin}, Actual=${actualAdmin}`);
        }
        CSReporter.info(`Account Manager verified: ${actualAdmin}`);

        CSReporter.pass('All Summary fields verified against database values');
    }

    // ===================================================================
    // SETTINGS SECTION STEPS
    // ===================================================================

    @CSBDDStepDef('Use Sketchmark Replacement should show {string}')
    async verifyUseSketchmarkReplacementValue(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getUseSketchmarkReplacementValue();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`Use Sketchmark Replacement shows: ${actualValue}`);
        } else {
            throw new Error(`Use Sketchmark Replacement mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('Output Ttcalc File should show {string}')
    async verifyOutputTtcalcFileValue(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getOutputTtcalcFileValue();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`Output Ttcalc File shows: ${actualValue}`);
        } else {
            throw new Error(`Output Ttcalc File mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify File Type and Inductor fields if Output Ttcalc File is enabled')
    async verifyFileTypeAndInductorIfOutputCalcEnabled(): Promise<void> {
        const outputTtcalcFile = this.scenarioContext.getVariable<string>('outputTtcalcFile');

        if (outputTtcalcFile === 'Yes') {
            CSReporter.info('Output Ttcalc File is enabled, verifying File Type and Inductor fields');

            // Verify File Type = FFX
            const fileType = await this.zealDetailsPage.getFileTypeValue();
            if (fileType !== 'FFX') {
                throw new Error(`File Type mismatch: Expected=FFX, Actual=${fileType}`);
            }
            CSReporter.pass(`File Type verified: ${fileType}`);

            // Verify Inductor = ffxFileInductorType from test data
            const expectedInductor = this.scenarioContext.getVariable<string>('ffxFileInductorType');
            const actualInductor = await this.zealDetailsPage.getInductorValue();
            if (actualInductor !== expectedInductor) {
                throw new Error(`Inductor mismatch: Expected=${expectedInductor}, Actual=${actualInductor}`);
            }
            CSReporter.pass(`Inductor verified: ${actualInductor}`);
        } else {
            CSReporter.info('Output Ttcalc File is not enabled, skipping File Type and Inductor verification');
        }
    }

    @CSBDDStepDef('I check Use Sketchmark Replacement checkbox')
    async checkUseSketchmarkReplacement(): Promise<void> {
        await this.zealDetailsPage.checkUseSketchmarkReplacement();
    }

    @CSBDDStepDef('I uncheck Use Sketchmark Replacement checkbox')
    async uncheckUseSketchmarkReplacement(): Promise<void> {
        await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
    }

    @CSBDDStepDef('I check Output Ttcalc File checkbox')
    async checkOutputTtcalcFile(): Promise<void> {
        await this.zealDetailsPage.checkOutputTtcalcFile();
    }

    @CSBDDStepDef('I uncheck Output Ttcalc File checkbox')
    async uncheckOutputTtcalcFile(): Promise<void> {
        await this.zealDetailsPage.uncheckOutputTtcalcFile();
    }

    @CSBDDStepDef('I select FFX Inductor Type {string}')
    async selectFfxInductorType(inductorType: string): Promise<void> {
        const resolvedInductorType = CSValueResolver.resolve(inductorType, this.context);
        await this.zealDetailsPage.selectFfxInductorType(resolvedInductorType);
    }

    @CSBDDStepDef('FFX Inductor Type dropdown should show {string}')
    async verifyFfxInductorTypeSelected(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.context);
        const actualValue = await this.zealDetailsPage.getSelectedFfxInductorType();

        if (actualValue === resolvedValue) {
            CSReporter.pass(`FFX Inductor Type shows: ${actualValue}`);
        } else {
            throw new Error(`FFX Inductor Type mismatch: Expected=${resolvedValue}, Actual=${actualValue}`);
        }
    }

    @CSBDDStepDef('I verify FFX Inductor Type options against database')
    async verifyFfxInductorTypeOptionsAgainstDatabase(): Promise<void> {
        const dbOptions = await TTTFDatabaseHelper.getFfxInductorOptions();
        const uiOptions = await this.zealDetailsPage.getFfxInductorTypeOptions();

        const missingInUI = dbOptions.filter(opt => !uiOptions.includes(opt));
        if (missingInUI.length > 0) {
            throw new Error(`FFX Inductor Type options missing in UI: ${missingInUI.join(', ')}`);
        }

        CSReporter.pass(`All ${dbOptions.length} FFX Inductor Type options verified`);
    }

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES STEPS
    // ===================================================================

    @CSBDDStepDef('No Scattered Mmtes message should be visible')
    async verifyNoScatteredMmtesMessage(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isNoScatteredMmtesMessageVisible();
        if (isVisible) {
            CSReporter.pass('No Scattered Mmtes message is visible');
        } else {
            throw new Error('No Scattered Mmtes message is not visible');
        }
    }

    @CSBDDStepDef('I wait for Add Remove button to be visible')
    async waitForAddRemoveButton(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isAddRemoveButtonVisible();
        if (isVisible) {
            CSReporter.pass('Add/Remove button is visible');
        } else {
            throw new Error('Add/Remove button is not visible after waiting');
        }
    }

    @CSBDDStepDef('I verify Associated Scattered Mmtes column headers')
    async verifyAssociatedScatteredMmtesColumnHeaders(): Promise<void> {
        await this.zealDetailsPage.verifyAssociatedScatteredMmtesColumnHeaders();
    }

    @CSBDDStepDef('I click Add Remove button')
    async clickAddRemoveButton(): Promise<void> {
        await this.zealDetailsPage.clickAddRemoveButton();
    }

    @CSBDDStepDef('Select Options modal should be visible')
    async verifySelectOptionsModalVisible(): Promise<void> {
        await this.scatteredMmtesModalPage.verifySelectOptionsModalDisplayed();
    }

    @CSBDDStepDef('Select items text should show {string}')
    async verifySelectItemsText(expectedText: string): Promise<void> {
        const actualText = await this.scatteredMmtesModalPage.getSelectItemsText();
        if (actualText.includes(expectedText)) {
            CSReporter.pass(`Select items text shows: ${actualText}`);
        } else {
            throw new Error(`Expected "${expectedText}", got "${actualText}"`);
        }
    }

    @CSBDDStepDef('Selected count should show {string}')
    async verifySelectedCount(expectedCount: string): Promise<void> {
        const actualCount = await this.scatteredMmtesModalPage.getSelectedCount();
        if (actualCount.includes(expectedCount)) {
            CSReporter.pass(`Selected count shows: ${actualCount}`);
        } else {
            throw new Error(`Expected "${expectedCount}", got "${actualCount}"`);
        }
    }

    @CSBDDStepDef('Find by input field should be visible')
    async verifyFindByInputVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isFindByInputVisible();
        if (isVisible) {
            CSReporter.pass('Find by input field is visible');
        } else {
            throw new Error('Find by input field is not visible');
        }
    }

    @CSBDDStepDef('Go button should be visible')
    async verifyGoButtonVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isGoButtonVisible();
        if (isVisible) {
            CSReporter.pass('Go button is visible');
        } else {
            throw new Error('Go button is not visible');
        }
    }

    @CSBDDStepDef('Reset button should be visible')
    async verifyResetButtonVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isResetButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reset button is visible');
        } else {
            throw new Error('Reset button is not visible');
        }
    }

    @CSBDDStepDef('Pagination should be visible')
    async verifyPaginationVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isPaginationVisible();
        if (isVisible) {
            CSReporter.pass('Pagination is visible');
        } else {
            throw new Error('Pagination is not visible');
        }
    }

    @CSBDDStepDef('Previous panel button should be visible')
    async verifyPreviousButtonVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isPreviousButtonVisible();
        if (isVisible) {
            CSReporter.pass('Previous panel button is visible');
        } else {
            throw new Error('Previous panel button is not visible');
        }
    }

    @CSBDDStepDef('Next panel button should be visible')
    async verifyNextButtonVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isNextButtonVisible();
        if (isVisible) {
            CSReporter.pass('Next panel button is visible');
        } else {
            throw new Error('Next panel button is not visible');
        }
    }

    @CSBDDStepDef('Scattered Mmtes table should be visible')
    async verifyScatteredMmtesTableVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isScatteredMmtesTableVisible();
        if (isVisible) {
            CSReporter.pass('Scattered Mmtes table is visible');
        } else {
            throw new Error('Scattered Mmtes table is not visible');
        }
    }

    @CSBDDStepDef('Scattered Mmte Name column should be visible in modal')
    async verifyScatteredMmteNameColumnVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isScatteredMmteNameColumnVisible();
        if (isVisible) {
            CSReporter.pass('Scattered Mmte Name column is visible');
        } else {
            throw new Error('Scattered Mmte Name column is not visible');
        }
    }

    @CSBDDStepDef('Cumulative Mmte Name column should be visible in modal')
    async verifyCumulativeMmteNameColumnVisible(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isCumulativeMmteNameColumnVisible();
        if (isVisible) {
            CSReporter.pass('Cumulative Mmte Name column is visible');
        } else {
            throw new Error('Cumulative Mmte Name column is not visible');
        }
    }

    @CSBDDStepDef('Apply button should be visible in modal')
    async verifyApplyButtonVisibleInModal(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isApplyButtonVisible();
        if (isVisible) {
            CSReporter.pass('Apply button is visible');
        } else {
            throw new Error('Apply button is not visible');
        }
    }

    @CSBDDStepDef('Cancel button should be visible in modal')
    async verifyCancelButtonVisibleInModal(): Promise<void> {
        const isVisible = await this.scatteredMmtesModalPage.isCancelButtonVisible();
        if (isVisible) {
            CSReporter.pass('Cancel button is visible');
        } else {
            throw new Error('Cancel button is not visible');
        }
    }

    @CSBDDStepDef('I select scattered mmte {string} in modal')
    async selectScatteredMmteInModal(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        await this.scatteredMmtesModalPage.selectScatteredMmte(resolvedMmteName);
    }

    @CSBDDStepDef('I select all stored scattered mmtes in modal')
    async selectAllStoredScatteredMmtesInModal(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];

        for (const mmteName of mmteNames) {
            await this.scatteredMmtesModalPage.selectScatteredMmte(mmteName);
        }

        CSReporter.pass(`Selected ${mmteNames.length} scattered mmtes in modal`);
    }

    @CSBDDStepDef('I click Apply button in modal')
    async clickApplyButtonInModal(): Promise<void> {
        await this.scatteredMmtesModalPage.clickApplyButton();
        await this.scatteredMmtesModalPage.waitForModalToClose();
    }

    @CSBDDStepDef('I click Cancel button in Scattered Mmtes modal')
    async clickCancelButtonInScatteredMmtesModal(): Promise<void> {
        await this.scatteredMmtesModalPage.clickCancelButton();
    }

    @CSBDDStepDef('Scattered mmtes should be displayed in Associated Scattered Mmtes section')
    async verifyScatteredMmtesDisplayed(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const rowCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (rowCount !== mmteNames.length) {
            throw new Error(`Scattered mmte count mismatch: Expected=${mmteNames.length}, Actual=${rowCount}`);
        }

        for (let i = 0; i < rowCount; i++) {
            const rowData = await this.zealDetailsPage.getScatteredMmteRowData(i);

            // Verify FFX Order
            if (parseInt(rowData.ffxOrder) !== i + 1) {
                throw new Error(`Row ${i} FFX Order mismatch: Expected=${i + 1}, Actual=${rowData.ffxOrder}`);
            }

            // Verify Scattered Mmte Name is in the list
            if (!mmteNames.includes(rowData.scatteredMmteName)) {
                throw new Error(`Unexpected scattered mmte: ${rowData.scatteredMmteName}`);
            }

            CSReporter.info(`Row ${i}: FFX=${rowData.ffxOrder}, Mmte=${rowData.scatteredMmteName}, Cumulative=${rowData.cumulativeMmteName}`);
        }

        CSReporter.pass(`All ${rowCount} scattered mmtes verified`);
    }

    // ===================================================================
    // DISPUTED SCATTERED MMTE STEPS
    // ===================================================================

    /**
     * Verify Disputed Scattered Mmte and Start Date using delimiter format.
     *
     * Reads from context:
     * - addDisputedScatteredMmteFlag: "true/false" to control if verification should happen
     * - disputedScatteredMmteToAdd: "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
     * - disputedStartDateToAdd: "DisputedMmte||mm/dd/yyyy;DisputedMmte||mm/dd/yyyy"
     * - scatteredMmtesToAdd: string[] of scattered mmte names
     */
    @CSBDDStepDef('I verify Disputed Scattered Mmte and Start Date if applicable')
    async verifyDisputedScatteredMmteAndStartDate(): Promise<void> {
        const addDisputedScatteredMmteFlag = this.scenarioContext.getVariable<string>('addDisputedScatteredMmteFlag') || 'false';

        if (!this.isYesOrTrue(addDisputedScatteredMmteFlag)) {
            CSReporter.info('addDisputedScatteredMmteFlag is not enabled, skipping disputed verification');
            return;
        }

        CSReporter.info('addDisputedScatteredMmteFlag is enabled, verifying disputed data');

        // Get the disputed scattered mmte data from test data (delimiter format)
        // Format: "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
        const disputedScatteredMmteToAdd = this.scenarioContext.getVariable<string>('disputedScatteredMmteToAdd') || '';
        const mmteNames = this.scenarioContext.getVariable<string[]>('scatteredMmtesToAdd') || [];

        if (!disputedScatteredMmteToAdd.trim()) {
            CSReporter.info('No disputed scattered mmte data found in context');
            return;
        }

        // Parse delimiter format into lookup map: { RefMmte: DisputedMmte }
        const disputedLookup: Record<string, string> = {};
        const disputedMappings = disputedScatteredMmteToAdd.split(';').filter(s => s.trim());
        for (const mapping of disputedMappings) {
            const [refMmte, disputedMmte] = mapping.split('||').map(s => s.trim());
            if (refMmte && disputedMmte) {
                disputedLookup[refMmte] = disputedMmte;
            }
        }

        // Get the disputed start dates data from test data (delimiter format)
        // Format: "DisputedMmte||mm/dd/yyyy;DisputedMmte||mm/dd/yyyy"
        const disputedStartDateToAdd = this.scenarioContext.getVariable<string>('disputedStartDateToAdd') || '';
        const dateLookup: Record<string, string> = {};
        if (disputedStartDateToAdd.trim()) {
            const dateMappings = disputedStartDateToAdd.split(';').filter(s => s.trim());
            for (const mapping of dateMappings) {
                const [disputedMmte, date] = mapping.split('||').map(s => s.trim());
                if (disputedMmte && date) {
                    dateLookup[disputedMmte] = date;
                }
            }
        }

        for (let i = 0; i < mmteNames.length; i++) {
            const mmteName = mmteNames[i];
            const expectedDisputedMmteName = disputedLookup[mmteName];

            if (!expectedDisputedMmteName) {
                CSReporter.info(`No disputed data for scattered mmte: ${mmteName}, skipping`);
                continue;
            }

            const rowIndex = i; // 0-based index (page method handles xpath indexing)
            const expectedDisputedStartDate = dateLookup[expectedDisputedMmteName];

            // Verify Disputed Scattered Mmte
            const actualDisputedMmteName = await this.zealDetailsPage.getDisputedScatteredMmteValue(rowIndex);
            if (actualDisputedMmteName !== expectedDisputedMmteName) {
                throw new Error(`Row ${rowIndex} Disputed Scattered Mmte mismatch: Expected=${expectedDisputedMmteName}, Actual=${actualDisputedMmteName}`);
            }
            CSReporter.pass(`Row ${rowIndex} Disputed Scattered Mmte verified: ${actualDisputedMmteName}`);

            // Verify Disputed Start Date (if we have expected date)
            if (expectedDisputedStartDate) {
                const actualDisputedStartDate = await this.zealDetailsPage.getDisputedStartDateValue(rowIndex);
                if (actualDisputedStartDate !== expectedDisputedStartDate) {
                    throw new Error(`Row ${rowIndex} Disputed Start Date mismatch: Expected=${expectedDisputedStartDate}, Actual=${actualDisputedStartDate}`);
                }
                CSReporter.pass(`Row ${rowIndex} Disputed Start Date verified: ${actualDisputedStartDate}`);
            }
        }
    }

    @CSBDDStepDef('I click Disputed Select button for row {int}')
    async clickDisputedSelectButton(rowIndex: number): Promise<void> {
        await this.zealDetailsPage.clickDisputedSelectButton(rowIndex);
    }

    @CSBDDStepDef('Add Scattered Mmtes modal should be visible')
    async verifyAddScatteredMmtesModalVisible(): Promise<void> {
        await this.scatteredMmtesModalPage.verifyAddScatteredMmtesModalDisplayed();
    }

    @CSBDDStepDef('I select disputed scattered mmte {string} in modal')
    async selectDisputedScatteredMmteInModal(mmteName: string): Promise<void> {
        const resolvedMmteName = CSValueResolver.resolve(mmteName, this.context);
        await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(resolvedMmteName);
    }

    @CSBDDStepDef('I enter disputed start date {string} for row {int}')
    async enterDisputedStartDate(date: string, rowIndex: number): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(date, this.context);
        await this.zealDetailsPage.enterDisputedStartDate(rowIndex, resolvedDate);
    }

    /**
     * Configure disputed scattered mmtes if required (using delimiter format).
     *
     * Reads from context:
     * - addDisputedScatteredMmteFlag: "true/false" to control if disputed should be configured
     * - disputedScatteredMmteToAdd: "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
     * - disputedStartDateToAdd: "DisputedMmte||mm/dd/yyyy;DisputedMmte||mm/dd/yyyy"
     * - scatteredMmtesToAdd: string[] of scattered mmte names
     */
    @CSBDDStepDef('I configure disputed scattered mmtes if required')
    async configureDisputedScatteredMmtesIfRequired(): Promise<void> {
        CSReporter.info('Checking if disputed scattered mmtes need to be configured');

        // Get addDisputedScatteredMmteFlag from test data
        const addDisputedScatteredMmteFlag = this.scenarioContext.getVariable<string>('addDisputedScatteredMmteFlag') || 'false';

        if (!this.isYesOrTrue(addDisputedScatteredMmteFlag)) {
            CSReporter.info('addDisputedScatteredMmteFlag is false, skipping disputed configuration');
            return;
        }

        CSReporter.info('Disputed scattered mmtes required, processing...');

        // Get the disputed scattered mmtes data from test data (delimiter format)
        // Format: "RefMmte||DisputedMmte;RefMmte||DisputedMmte"
        const disputedScatteredMmteToAdd = this.scenarioContext.getVariable<string>('disputedScatteredMmteToAdd') || '';

        if (!disputedScatteredMmteToAdd.trim()) {
            CSReporter.warn('No disputed scattered mmte data found in test data');
            return;
        }

        // Parse delimiter format into lookup map: { RefMmte: DisputedMmte }
        const disputedLookup: Record<string, string> = {};
        const disputedMappings = disputedScatteredMmteToAdd.split(';').filter(s => s.trim());
        for (const mapping of disputedMappings) {
            const [refMmte, disputedMmte] = mapping.split('||').map(s => s.trim());
            if (refMmte && disputedMmte) {
                disputedLookup[refMmte] = disputedMmte;
            }
        }

        CSReporter.info(`Disputed lookup built with ${Object.keys(disputedLookup).length} entries: ${JSON.stringify(disputedLookup)}`);

        // Get the disputed start dates data from test data (delimiter format)
        // Format: "DisputedMmte||mm/dd/yyyy;DisputedMmte||mm/dd/yyyy"
        const disputedStartDateToAdd = this.scenarioContext.getVariable<string>('disputedStartDateToAdd') || '';
        const dateLookup: Record<string, string> = {};
        if (disputedStartDateToAdd.trim()) {
            const dateMappings = disputedStartDateToAdd.split(';').filter(s => s.trim());
            for (const mapping of dateMappings) {
                const [disputedMmte, date] = mapping.split('||').map(s => s.trim());
                if (disputedMmte && date) {
                    dateLookup[disputedMmte] = date;
                }
            }
            CSReporter.info(`Date lookup built with ${Object.keys(dateLookup).length} entries: ${JSON.stringify(dateLookup)}`);
        }

        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[] || [];
        let rowIndex = 0; // 0-based index for page methods

        for (const mmteName of mmteNames) {
            const disputedMmteName = disputedLookup[mmteName];

            if (disputedMmteName) {
                CSReporter.info(`Configuring disputed for row ${rowIndex}: ${mmteName} -> ${disputedMmteName}`);

                // Click Disputed Select button for this row
                await this.zealDetailsPage.clickDisputedSelectButton(rowIndex);

                // Verify Add Scattered Mmtes modal is displayed
                await this.scatteredMmtesModalPage.verifyAddScatteredMmtesModalDisplayed();

                // Select the disputed scattered mmte
                await this.scatteredMmtesModalPage.selectDisputedScatteredMmte(disputedMmteName);

                // Click Apply button
                await this.scatteredMmtesModalPage.clickApplyButton();
                await this.scatteredMmtesModalPage.waitForModalToClose();

                // Enter disputed start date if provided
                const disputedStartDate = dateLookup[disputedMmteName];
                if (disputedStartDate) {
                    await this.zealDetailsPage.enterDisputedStartDate(rowIndex, disputedStartDate);
                }

                CSReporter.pass(`Configured disputed for row ${rowIndex}: ${disputedMmteName}, Date: ${disputedStartDate || 'N/A'}`);
            } else {
                CSReporter.info(`No disputed config found for scattered mmte: ${mmteName}, skipping`);
            }

            rowIndex++;
        }

        CSReporter.pass('Disputed scattered mmtes configuration complete');
    }

    @CSBDDStepDef('I verify disputed scattered mmtes are displayed correctly')
    async verifyDisputedScatteredMmtesDisplayed(): Promise<void> {
        CSReporter.info('Verifying disputed scattered mmtes are displayed correctly');

        const hasDisputedScatteredMmte = this.scenarioContext.getVariable('hasDisputedScatteredMmte');

        if (!hasDisputedScatteredMmte || hasDisputedScatteredMmte === 'false' || hasDisputedScatteredMmte === false) {
            CSReporter.info('No disputed scattered mmtes to verify');
            return;
        }

        const disputedMmtesData = this.scenarioContext.getVariable('disputedScatteredMmtes');
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[] || [];
        let rowIndex = 0;

        for (const mmteName of mmteNames) {
            const disputedData = disputedMmtesData?.[mmteName];

            if (disputedData && disputedData.disputedMmteName) {
                const rowData = await this.zealDetailsPage.getScatteredMmteRowData(rowIndex);

                // Verify disputed scattered mmte name
                if (!rowData.disputedScatteredMmte.includes(disputedData.disputedMmteName)) {
                    throw new Error(`Row ${rowIndex}: Disputed mmte mismatch. Expected to contain: ${disputedData.disputedMmteName}, Actual: ${rowData.disputedScatteredMmte}`);
                }

                // Verify disputed start date if provided
                if (disputedData.disputedStartDate && rowData.disputedStartDate !== disputedData.disputedStartDate) {
                    throw new Error(`Row ${rowIndex}: Disputed date mismatch. Expected: ${disputedData.disputedStartDate}, Actual: ${rowData.disputedStartDate}`);
                }

                CSReporter.info(`Row ${rowIndex}: Disputed verified - ${rowData.disputedScatteredMmte}, ${rowData.disputedStartDate}`);
            }

            rowIndex++;
        }

        CSReporter.pass('All disputed scattered mmtes verified');
    }

    // ===================================================================
    // ACTION BUTTON STEPS
    // ===================================================================

    @CSBDDStepDef('Zeal Save button should be enabled')
    async verifyZealSaveButtonEnabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isSaveButtonEnabled();
        if (isEnabled) {
            CSReporter.pass('Zeal Save button is enabled');
        } else {
            throw new Error('Zeal Save button is not enabled');
        }
    }

    @CSBDDStepDef('Save button should be disabled')
    async verifySaveButtonDisabled(): Promise<void> {
        const isEnabled = await this.zealDetailsPage.isSaveButtonEnabled();
        if (!isEnabled) {
            CSReporter.pass('Save button is disabled');
        } else {
            throw new Error('Save button is not disabled');
        }
    }

    @CSBDDStepDef('I click Save button')
    async clickSaveButton(): Promise<void> {
        await this.zealDetailsPage.clickSaveButton();
    }

    @CSBDDStepDef('I should see save success message')
    async verifySaveSuccessMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        const zealId = this.scenarioContext.getVariable('zealId');

        if (messageText.includes('saved') || messageText.includes(zealId)) {
            CSReporter.pass(`Save success message: ${messageText}`);
        } else {
            throw new Error(`Expected save success message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I click anywhere on page to dismiss message')
    async clickAnywhereOnPageToDismissMessage(): Promise<void> {
        await this.zealDetailsPage.clickOnPageBody();
        await this.zealDetailsPage.wait(500);
        CSReporter.pass('Clicked on page to dismiss message');
    }

    @CSBDDStepDef('I should see pending approval alert')
    async verifyPendingApprovalAlert(): Promise<void> {
        const feedbackText = await this.zealDetailsPage.getFeedbackMessageText();

        if (feedbackText.includes('pending approval')) {
            CSReporter.pass(`Pending approval alert: ${feedbackText}`);
        } else {
            throw new Error(`Expected pending approval alert, got: ${feedbackText}`);
        }
    }

    @CSBDDStepDef('View Changes link should be visible')
    async verifyViewChangesLinkVisible(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isViewChangesLinkVisible();
        if (isVisible) {
            CSReporter.pass('View Changes link is visible');
        } else {
            throw new Error('View Changes link is not visible');
        }
    }

    @CSBDDStepDef('I click View Changes link')
    async clickViewChangesLink(): Promise<void> {
        await this.zealDetailsPage.clickViewChangesLink();
    }

    // ===================================================================
    // CHANGES TAB STEPS
    // ===================================================================

    @CSBDDStepDef('Changes section should be visible')
    async verifyChangesSectionVisible(): Promise<void> {
        await this.changesHistoryPage.verifyChangesHeaderDisplayed();
    }

    @CSBDDStepDef('I verify Changes table column headers')
    async verifyChangesTableColumnHeaders(): Promise<void> {
        await this.changesHistoryPage.verifyChangesTableColumnHeaders();
    }

    @CSBDDStepDef('Changes table should show pending changes')
    async verifyChangesTableHasData(): Promise<void> {
        const rowCount = await this.changesHistoryPage.getChangesRowCount();
        if (rowCount > 0) {
            CSReporter.pass(`Changes table has ${rowCount} rows`);
        } else {
            throw new Error('Changes table is empty');
        }
    }

    @CSBDDStepDef('I verify changes data matches added scattered mmtes')
    async verifyChangesDataMatchesScatteredMmtes(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const changesData = await this.changesHistoryPage.getAllChangesData();

        for (const change of changesData) {
            if (change.description !== 'Add Scattered Mmte') {
                throw new Error(`Unexpected change description: ${change.description}`);
            }

            if (!mmteNames.includes(change.newValue)) {
                throw new Error(`Unexpected scattered mmte in changes: ${change.newValue}`);
            }

            CSReporter.info(`Change: ${change.description} - ${change.newValue}, Modified By: ${change.modifiedBy}`);
        }

        CSReporter.pass(`All ${changesData.length} changes verified`);
    }

    @CSBDDStepDef('Cancel Changes button should be visible')
    async verifyCancelChangesButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isCancelChangesButtonVisible();
        if (isVisible) {
            CSReporter.pass('Cancel Changes button is visible');
        } else {
            throw new Error('Cancel Changes button is not visible');
        }
    }

    @CSBDDStepDef('Approve button should be visible')
    async verifyApproveButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isApproveButtonVisible();
        if (isVisible) {
            CSReporter.pass('Approve button is visible');
        } else {
            throw new Error('Approve button is not visible');
        }
    }

    @CSBDDStepDef('Reject button should be visible')
    async verifyRejectButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isRejectButtonVisible();
        if (isVisible) {
            CSReporter.pass('Reject button is visible');
        } else {
            throw new Error('Reject button is not visible');
        }
    }

    @CSBDDStepDef('I click Approve button')
    async clickApproveButton(): Promise<void> {
        await this.changesHistoryPage.clickApproveButton();
    }

    @CSBDDStepDef('I click Reject button')
    async clickRejectButton(): Promise<void> {
        await this.changesHistoryPage.clickRejectButton();
    }

    @CSBDDStepDef('Changes table should be empty after approval')
    async verifyChangesTableEmpty(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after approval');
        } else {
            throw new Error('Changes table is not empty after approval');
        }
    }

    // ===================================================================
    // HISTORY TAB STEPS
    // ===================================================================

    @CSBDDStepDef('History section should be visible')
    async verifyHistorySectionVisible(): Promise<void> {
        await this.changesHistoryPage.verifyHistoryHeaderDisplayed();
    }

    @CSBDDStepDef('History pagination previous button should be visible')
    async verifyHistoryPaginationPreviousButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isHistoryPaginationPreviousButtonVisible();
        if (isVisible) {
            CSReporter.pass('History pagination previous button is visible');
        } else {
            throw new Error('History pagination previous button is not visible');
        }
    }

    @CSBDDStepDef('History pagination next button should be visible')
    async verifyHistoryPaginationNextButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isHistoryPaginationNextButtonVisible();
        if (isVisible) {
            CSReporter.pass('History pagination next button is visible');
        } else {
            throw new Error('History pagination next button is not visible');
        }
    }

    @CSBDDStepDef('History table should be visible')
    async verifyHistoryTableVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isHistoryTableVisible();
        if (isVisible) {
            CSReporter.pass('History table is visible');
        } else {
            throw new Error('History table is not visible');
        }
    }

    @CSBDDStepDef('I verify History table column headers')
    async verifyHistoryTableColumnHeaders(): Promise<void> {
        await this.changesHistoryPage.verifyHistoryTableColumnHeaders();
    }

    @CSBDDStepDef('History table should show approved changes')
    async verifyHistoryTableHasData(): Promise<void> {
        const rowCount = await this.changesHistoryPage.getHistoryRowCount();
        if (rowCount > 0) {
            CSReporter.pass(`History table has ${rowCount} rows`);
        } else {
            throw new Error('History table is empty');
        }
    }

    @CSBDDStepDef('I verify history data matches approved scattered mmtes')
    async verifyHistoryDataMatchesScatteredMmtes(): Promise<void> {
        const mmteNames = this.scenarioContext.getVariable('scatteredMmtesToAdd') as string[];
        const historyData = await this.changesHistoryPage.getAllHistoryData();

        for (const history of historyData) {
            if (history.description !== 'Add Scattered Mmte') {
                throw new Error(`Unexpected history description: ${history.description}`);
            }

            if (!mmteNames.includes(history.newValue)) {
                throw new Error(`Unexpected scattered mmte in history: ${history.newValue}`);
            }

            CSReporter.info(`History: ${history.description} - ${history.newValue}, Approved By: ${history.approvedBy}`);
        }

        CSReporter.pass(`All ${historyData.length} history entries verified`);
    }

    // ===================================================================
    // BROWSER CONTEXT / RE-AUTHENTICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I clear browser context for re-authentication')
    async clearBrowserContextForReauth(): Promise<void> {
        CSReporter.info('Clearing browser context for re-authentication (switching user)');
        const browserManager = CSBrowserManager.getInstance();
        await browserManager.clearContextAndReauthenticate();
        CSReporter.pass('Browser context cleared, ready for new user login');
    }

    // ===================================================================
    // PENDING APPROVALS PAGE STEPS
    // ===================================================================

    @CSBDDStepDef('I navigate to Pending Approvals page')
    async navigateToPendingApprovalsPage(): Promise<void> {
        await this.navigationPage.clickPendingApprovalsMenu();
        await this.pendingApprovalsPage.verifyPageDisplayed();
    }

    @CSBDDStepDef('Pending Approvals page should be displayed')
    async verifyPendingApprovalsPageDisplayed(): Promise<void> {
        await this.pendingApprovalsPage.verifyPageDisplayed();
    }

    @CSBDDStepDef('I find and click View link for stored zeal')
    async findAndClickViewForStoredZeal(): Promise<void> {
        const zealName = this.scenarioContext.getVariable('zealName');
        await this.pendingApprovalsPage.clickViewLinkByZealName(zealName);
    }

    // ===================================================================
    // DATABASE VERIFICATION STEPS
    // ===================================================================

    @CSBDDStepDef('I verify zeal data record exists in database')
    async verifyZealDataRecordExists(): Promise<void> {
        const zealId = this.scenarioContext.getVariable('zealId');
        const zealData = await TTTFDatabaseHelper.getZealDataByZealId(zealId);

        if (!zealData) {
            throw new Error(`Zeal data record not found for zeal ID: ${zealId}`);
        }

        this.scenarioContext.setVariable('zealpremisisDataId', zealData.zealpremisisDataId);
        CSReporter.pass(`Zeal data record exists: zealpremisisDataId=${zealData.zealpremisisDataId}`);
    }

    @CSBDDStepDef('I verify zealpremisis data has correct settings')
    async verifyZealpremisisDataSettings(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const details = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!details) {
            throw new Error(`Zealpremisis data details not found for ID: ${zealpremisisDataId}`);
        }

        CSReporter.info(`Zealpremisis data: sketchmarkFlag=${details.sketchmarkReplacementFlag}, inductorCode=${details.inductorCode}`);
        CSReporter.pass('Zealpremisis data settings verified');
    }

    @CSBDDStepDef('I verify status log shows {string} status')
    async verifyStatusLogStatus(expectedStatus: string): Promise<void> {
        const resolvedStatus = CSValueResolver.resolve(expectedStatus, this.context) as 'AWAITING' | 'APPROVED' | 'REJECTED';
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');

        const isCorrect = await TTTFDatabaseHelper.verifyStatusLogStatus(zealpremisisDataId, resolvedStatus);

        if (isCorrect) {
            CSReporter.pass(`Status log shows ${resolvedStatus} status`);
        } else {
            throw new Error(`Status log does not show ${resolvedStatus} status`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data exists after approval')
    async verifyZealpremisisMmteDataExists(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            throw new Error('No zealpremisis mmte data found after approval');
        }

        CSReporter.pass(`Zealpremisis mmte data exists: ${mmteData.length} records`);
    }

    // ===================================================================
    // PREMISIS-SPECIFIC STEPS
    // ===================================================================

    @CSBDDStepDef('I get premisis for new setup from database')
    async getPremisisForNewSetupFromDatabase(): Promise<void> {
        CSReporter.info('Getting premisis for new setup from database');

        const premisisDetails = await TTTFDatabaseHelper.getPremisisForNewSetup();
        if (!premisisDetails) {
            throw new Error('No premisis available for new setup in database');
        }

        this.scenarioContext.setVariable('zealId', premisisDetails.zealId);
        this.scenarioContext.setVariable('zealKey', premisisDetails.zealKey);
        this.scenarioContext.setVariable('zealName', premisisDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', premisisDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', premisisDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', premisisDetails.zzztSeggregation);
        this.scenarioContext.setVariable('premisisDescription', premisisDetails.premisisDescription);
        this.scenarioContext.setVariable('calcShoolName', premisisDetails.calcShoolName);
        this.scenarioContext.setVariable('administrator', premisisDetails.administrator);
        this.scenarioContext.setVariable('zzztId', premisisDetails.zzztId);

        CSReporter.pass(`Retrieved premisis for new setup: ID=${premisisDetails.zealId}, Zzzt Abbrev=${premisisDetails.zzztSeggregation}`);
    }

    @CSBDDStepDef('I should see Premisis Details page')
    async verifyPremisisDetailsPage(): Promise<void> {
        await this.zealDetailsPage.verifyPremisisDetailsPageDisplayed();
    }

    @CSBDDStepDef('I should see Edit Premisis page')
    async verifyEditPremisisPage(): Promise<void> {
        await this.zealDetailsPage.verifyEditPremisisPageDisplayed();
    }

    @CSBDDStepDef('Output Ttcalc File checkbox should be disabled for Premisis')
    async verifyOutputCalcFileDisabledForPremisis(): Promise<void> {
        const isDisabled = await this.zealDetailsPage.isOutputTtcalcFileCheckboxDisabled();
        if (isDisabled) {
            CSReporter.pass('Output Ttcalc File checkbox is disabled for Premisis');
        } else {
            throw new Error('Output Ttcalc File checkbox should be disabled for Premisis');
        }
    }

    @CSBDDStepDef('FFX Inductor Type dropdown should be disabled for Premisis')
    async verifyFfxInductorTypeDisabledForPremisis(): Promise<void> {
        const isDisabled = await this.zealDetailsPage.isFfxInductorTypeDropdownDisabled();
        if (isDisabled) {
            CSReporter.pass('FFX Inductor Type dropdown is disabled for Premisis');
        } else {
            throw new Error('FFX Inductor Type dropdown should be disabled for Premisis');
        }
    }

    @CSBDDStepDef('I should see save success message for Premisis')
    async verifySaveSuccessMessageForPremisis(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        const zzztAbbrev = this.scenarioContext.getVariable('zzztSeggregation');

        if (messageText.includes('saved') || messageText.includes(zzztAbbrev)) {
            CSReporter.pass(`Save success message for Premisis: ${messageText}`);
        } else {
            throw new Error(`Expected save success message for Premisis, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I verify zzzt data record exists in database')
    async verifyZzztDataRecordExists(): Promise<void> {
        const zzztId = this.scenarioContext.getVariable('zzztId') || this.scenarioContext.getVariable('zealId');
        const zzztData = await TTTFDatabaseHelper.getZzztDataByZzztId(zzztId);

        if (!zzztData) {
            throw new Error(`Zzzt data record not found for zzzt ID: ${zzztId}`);
        }

        this.scenarioContext.setVariable('zealpremisisDataId', zzztData.zealpremisisDataId);
        CSReporter.pass(`Zzzt data record exists: zealpremisisDataId=${zzztData.zealpremisisDataId}`);
    }

    @CSBDDStepDef('I verify zealpremisis data has correct settings for Premisis')
    async verifyZealpremisisDataSettingsForPremisis(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const details = await TTTFDatabaseHelper.getZealpremisisDataDetails(zealpremisisDataId);

        if (!details) {
            throw new Error(`Zealpremisis data details not found for ID: ${zealpremisisDataId}`);
        }

        // For Premisis, Output Ttcalc File should be disabled (null/empty inductor code)
        CSReporter.info(`Premisis zealpremisis data: sketchmarkFlag=${details.sketchmarkReplacementFlag}, inductorCode=${details.inductorCode || 'N/A'}`);
        CSReporter.pass('Premisis zealpremisis data settings verified');
    }

    // ===================================================================
    // REJECTION FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('Review Reject Email modal should be visible')
    async verifyRejectEmailModalVisible(): Promise<void> {
        await this.changesHistoryPage.verifyRejectEmailModalDisplayed();
    }

    @CSBDDStepDef('Reject comment textarea should be visible')
    async verifyRejectCommentTextareaVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isRejectCommentTextareaVisible();
        if (isVisible) {
            CSReporter.pass('Reject comment textarea is visible');
        } else {
            throw new Error('Reject comment textarea is not visible');
        }
    }

    @CSBDDStepDef('Send button should be visible')
    async verifySendButtonVisible(): Promise<void> {
        const isVisible = await this.changesHistoryPage.isSendButtonVisible();
        if (isVisible) {
            CSReporter.pass('Send button is visible');
        } else {
            throw new Error('Send button is not visible');
        }
    }

    @CSBDDStepDef('I enter rejection comment {string}')
    async enterRejectionComment(comment: string): Promise<void> {
        const resolvedComment = CSValueResolver.resolve(comment, this.context);
        await this.changesHistoryPage.enterRejectComment(resolvedComment);
    }

    @CSBDDStepDef('I click Send button in Reject modal')
    async clickSendButtonInRejectModal(): Promise<void> {
        await this.changesHistoryPage.clickSendButton();
    }

    @CSBDDStepDef('Rejection email sent message should be displayed')
    async verifyRejectionEmailSentMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Rejection') && messageText.includes('sent')) {
            CSReporter.pass(`Rejection email sent message: ${messageText}`);
        } else {
            throw new Error(`Expected rejection email sent message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('Changes table should be empty after rejection')
    async verifyChangesTableEmptyAfterRejection(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after rejection');
        } else {
            throw new Error('Changes table is not empty after rejection');
        }
    }

    @CSBDDStepDef('History table should show no data')
    async verifyHistoryTableNoData(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isHistoryNoDataVisible();
        if (isNoData) {
            CSReporter.pass('History table shows no data');
        } else {
            throw new Error('History table should show no data');
        }
    }

    @CSBDDStepDef('I verify status log is cleared after rejection')
    async verifyStatusLogClearedAfterRejection(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const statusLog = await TTTFDatabaseHelper.getZealpremisisStatusLog(zealpremisisDataId);

        if (statusLog.length === 0) {
            CSReporter.pass('Status log is cleared after rejection');
        } else {
            throw new Error(`Status log should be empty after rejection, found ${statusLog.length} records`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data does not exist after rejection')
    async verifyZealpremisisMmteDataNotExistsAfterRejection(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            CSReporter.pass('No zealpremisis mmte data exists after rejection');
        } else {
            throw new Error(`Zealpremisis mmte data should not exist after rejection, found ${mmteData.length} records`);
        }
    }

    // ===================================================================
    // CANCEL FLOW STEPS
    // ===================================================================

    @CSBDDStepDef('I click Cancel Changes button')
    async clickCancelChangesButton(): Promise<void> {
        await this.changesHistoryPage.clickCancelChangesButton();
    }

    @CSBDDStepDef('Cancel changes success message should be displayed')
    async verifyCancelChangesSuccessMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Cancelled') || messageText.includes('cancelled')) {
            CSReporter.pass(`Cancel changes success message: ${messageText}`);
        } else {
            throw new Error(`Expected cancel changes success message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('Changes table should be empty after cancel')
    async verifyChangesTableEmptyAfterCancel(): Promise<void> {
        const isNoData = await this.changesHistoryPage.isChangesNoDataVisible();
        if (isNoData) {
            CSReporter.pass('Changes table is empty after cancel');
        } else {
            throw new Error('Changes table is not empty after cancel');
        }
    }

    @CSBDDStepDef('I verify status log is cleared after cancel')
    async verifyStatusLogClearedAfterCancel(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const statusLog = await TTTFDatabaseHelper.getZealpremisisStatusLog(zealpremisisDataId);

        if (statusLog.length === 0) {
            CSReporter.pass('Status log is cleared after cancel');
        } else {
            throw new Error(`Status log should be empty after cancel, found ${statusLog.length} records`);
        }
    }

    @CSBDDStepDef('I verify zealpremisis mmte data does not exist after cancel')
    async verifyZealpremisisMmteDataNotExistsAfterCancel(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);

        if (mmteData.length === 0) {
            CSReporter.pass('No zealpremisis mmte data exists after cancel');
        } else {
            throw new Error(`Zealpremisis mmte data should not exist after cancel, found ${mmteData.length} records`);
        }
    }

    // ===================================================================
    // EDIT NAVIGATION STEPS (SCENARIO_08, 09A)
    // ===================================================================

    @CSBDDStepDef('I get zeal for edit navigation from database')
    async getZealForEditNavigationFromDatabase(): Promise<void> {
        CSReporter.info('Getting zeal for edit navigation from database');

        const zealDetails = await TTTFDatabaseHelper.getZealForEditNavigation();
        if (!zealDetails) {
            throw new Error('No zeal available for edit navigation in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);

        CSReporter.pass(`Retrieved zeal for edit navigation: ID=${zealDetails.zealId}, Key=${zealDetails.zealKey}`);
    }

    @CSBDDStepDef('I get premisis for edit navigation from database')
    async getPremisisForEditNavigationFromDatabase(): Promise<void> {
        CSReporter.info('Getting premisis for edit navigation from database');

        const premisisDetails = await TTTFDatabaseHelper.getPremisisForEditNavigation();
        if (!premisisDetails) {
            throw new Error('No premisis available for edit navigation in database');
        }

        this.scenarioContext.setVariable('zealId', premisisDetails.zealId);
        this.scenarioContext.setVariable('zealKey', premisisDetails.zealKey);
        this.scenarioContext.setVariable('zealName', premisisDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', premisisDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', premisisDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', premisisDetails.zzztSeggregation);
        this.scenarioContext.setVariable('zzztId', premisisDetails.zzztId);

        CSReporter.pass(`Retrieved premisis for edit navigation: ID=${premisisDetails.zealId}, ZzztAbbrev=${premisisDetails.zzztSeggregation}`);
    }

    @CSBDDStepDef('I uncheck Include Premisis in results checkbox')
    async uncheckIncludePremisisInResultsCheckbox(): Promise<void> {
        await this.zealPremisisPage.uncheckIncludePremisisCheckbox();
    }

    @CSBDDStepDef('Search results should show type {string}')
    async verifySearchResultsType(expectedType: string): Promise<void> {
        const resolvedType = CSValueResolver.resolve(expectedType, this.context);
        const actualType = await this.zealPremisisPage.getSearchResultTypeValue(1);

        if (actualType === resolvedType) {
            CSReporter.pass(`Search results show correct type: ${actualType}`);
        } else {
            throw new Error(`Expected type "${resolvedType}", got "${actualType}"`);
        }
    }

    @CSBDDStepDef('Search results should show stored zeal ID')
    async verifySearchResultsShowStoredZealId(): Promise<void> {
        const expectedZealId = this.scenarioContext.getVariable('zealId');
        const actualZealId = await this.zealPremisisPage.getSearchResultZealIdValue(1);

        if (actualZealId === expectedZealId) {
            CSReporter.pass(`Search results show correct zeal ID: ${actualZealId}`);
        } else {
            throw new Error(`Expected zeal ID "${expectedZealId}", got "${actualZealId}"`);
        }
    }

    @CSBDDStepDef('Search results should show stored zeal key')
    async verifySearchResultsShowStoredZealKey(): Promise<void> {
        const expectedZealKey = this.scenarioContext.getVariable('zealKey');
        const actualZealKey = await this.zealPremisisPage.getSearchResultZealKeyValue(1);

        if (actualZealKey === expectedZealKey) {
            CSReporter.pass(`Search results show correct zeal key: ${actualZealKey}`);
        } else {
            throw new Error(`Expected zeal key "${expectedZealKey}", got "${actualZealKey}"`);
        }
    }

    @CSBDDStepDef('I click Cancel button')
    async clickCancelButton(): Promise<void> {
        await this.zealDetailsPage.clickCancelButton();
    }

    @CSBDDStepDef('Warning popup should be displayed')
    async verifyWarningPopupDisplayed(): Promise<void> {
        await this.zealDetailsPage.verifyWarningPopupDisplayed();
    }

    @CSBDDStepDef('Warning popup should show unsaved changes message')
    async verifyWarningPopupUnsavedChangesMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getWarningPopupMessage();
        if (messageText.includes('changes are not saved') || messageText.includes('save before')) {
            CSReporter.pass(`Warning popup shows unsaved changes message: ${messageText}`);
        } else {
            throw new Error(`Expected unsaved changes warning, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('OK button should be visible in warning popup')
    async verifyOkButtonVisibleInWarningPopup(): Promise<void> {
        const isVisible = await this.zealDetailsPage.isWarningPopupOkButtonVisible();
        if (isVisible) {
            CSReporter.pass('OK button is visible in warning popup');
        } else {
            throw new Error('OK button is not visible in warning popup');
        }
    }

    @CSBDDStepDef('I click OK button in warning popup')
    async clickOkButtonInWarningPopup(): Promise<void> {
        await this.zealDetailsPage.clickWarningPopupOkButton();
    }

    @CSBDDStepDef('I click Edit link in Action column for row {int}')
    async clickEditLinkInActionColumn(rowIndex: number): Promise<void> {
        await this.zealPremisisPage.clickEditLinkInActionColumn(rowIndex);
    }

    @CSBDDStepDef('I should see Edit Zeal page directly')
    async verifyEditZealPageDirectly(): Promise<void> {
        await this.zealDetailsPage.verifyEditZealPageDisplayed();
        CSReporter.pass('Navigated directly to Edit Zeal page via Action column');
    }

    @CSBDDStepDef('I should see Edit Premisis page directly')
    async verifyEditPremisisPageDirectly(): Promise<void> {
        await this.zealDetailsPage.verifyEditPremisisPageDisplayed();
        CSReporter.pass('Navigated directly to Edit Premisis page via Action column');
    }

    // ===================================================================
    // EXISTING ZEAL UPDATE STEPS (SCENARIO_09B)
    // ===================================================================

    @CSBDDStepDef('I get existing zeal with scattered mmtes from database')
    async getExistingZealWithScatteredMmtes(): Promise<void> {
        CSReporter.info('Getting existing zeal with scattered mmtes from database');

        const zealDetails = await TTTFDatabaseHelper.getExistingZealWithScatteredMmtes();
        if (!zealDetails) {
            throw new Error('No existing zeal with scattered mmtes found in database');
        }

        this.scenarioContext.setVariable('zealId', zealDetails.zealId);
        this.scenarioContext.setVariable('zealKey', zealDetails.zealKey);
        this.scenarioContext.setVariable('zealName', zealDetails.zealName);
        this.scenarioContext.setVariable('inductorGroup', zealDetails.inductorGroup);
        this.scenarioContext.setVariable('kindnessCircle', zealDetails.kindnessCircle);
        this.scenarioContext.setVariable('zzztSeggregation', zealDetails.zzztSeggregation);
        this.scenarioContext.setVariable('sketchmarkFlag', zealDetails.sketchmarkFlag);
        this.scenarioContext.setVariable('inductorCode', zealDetails.inductorCode);
        this.scenarioContext.setVariable('existingScatteredMmtes', zealDetails.scatteredMmtes);

        CSReporter.pass(`Retrieved existing zeal: ID=${zealDetails.zealId}, Mmtes=${zealDetails.scatteredMmtes?.length || 0}`);
    }

    @CSBDDStepDef('I get replacement scattered mmtes from database')
    async getReplacementScatteredMmtes(): Promise<void> {
        CSReporter.info('Getting replacement scattered mmtes from database');

        const existingMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];
        const existingMmteNames = existingMmtes.map((r: any) => r.scatteredMmteName);

        const replacementMmtes = await TTTFDatabaseHelper.getReplacementScatteredMmtes(existingMmteNames);
        if (!replacementMmtes || replacementMmtes.length === 0) {
            throw new Error('No replacement scattered mmtes found in database');
        }

        this.scenarioContext.setVariable('replacementScatteredMmtes', replacementMmtes);
        CSReporter.pass(`Retrieved ${replacementMmtes.length} replacement scattered mmtes`);
    }

    @CSBDDStepDef('I verify existing scattered mmtes match database')
    async verifyExistingScatteredMmtesMatchDatabase(): Promise<void> {
        const expectedMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];
        const actualCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (actualCount === expectedMmtes.length) {
            CSReporter.pass(`Existing scattered mmtes match database: ${actualCount} mmtes`);
        } else {
            throw new Error(`Expected ${expectedMmtes.length} scattered mmtes, found ${actualCount}`);
        }
    }

    @CSBDDStepDef('I toggle Use Sketchmark Replacement checkbox')
    async toggleUseSketchmarkReplacementCheckbox(): Promise<void> {
        const currentFlag = this.scenarioContext.getVariable('sketchmarkFlag');
        if (currentFlag === 'Y') {
            await this.zealDetailsPage.uncheckUseSketchmarkReplacement();
        } else {
            await this.zealDetailsPage.checkUseSketchmarkReplacement();
        }
        CSReporter.pass('Toggled Use Sketchmark Replacement checkbox');
    }

    @CSBDDStepDef('I update FFX Inductor Type to different value')
    async updateFfxInductorTypeToDifferentValue(): Promise<void> {
        const currentInductorCode = this.scenarioContext.getVariable('inductorCode');
        const newInductorType = await TTTFDatabaseHelper.getDifferentFfxInductorType(currentInductorCode);

        if (newInductorType) {
            await this.zealDetailsPage.checkOutputTtcalcFile();
            await this.zealDetailsPage.selectFfxInductorType(newInductorType);
            this.scenarioContext.setVariable('newInductorCode', newInductorType);
            CSReporter.pass(`Updated FFX Inductor Type to: ${newInductorType}`);
        } else {
            CSReporter.info('No different FFX Inductor Type available, skipping update');
        }
    }

    @CSBDDStepDef('I unselect existing scattered mmtes in modal')
    async unselectExistingScatteredMmtesInModal(): Promise<void> {
        const existingMmtes = this.scenarioContext.getVariable('existingScatteredMmtes') || [];

        for (const mmte of existingMmtes) {
            await this.scatteredMmtesModalPage.searchScatteredMmte(mmte.scatteredMmteName);
            await this.scatteredMmtesModalPage.unselectScatteredMmte(mmte.scatteredMmteName);
        }

        CSReporter.pass(`Unselected ${existingMmtes.length} existing scattered mmtes`);
    }

    @CSBDDStepDef('I select replacement scattered mmtes in modal')
    async selectReplacementScatteredMmtesInModal(): Promise<void> {
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];

        for (const mmte of replacementMmtes) {
            await this.scatteredMmtesModalPage.searchScatteredMmte(mmte.scatteredMmteName);
            await this.scatteredMmtesModalPage.selectScatteredMmte(mmte.scatteredMmteName);
        }

        CSReporter.pass(`Selected ${replacementMmtes.length} replacement scattered mmtes`);
    }

    @CSBDDStepDef('Updated scattered mmtes should be displayed in Associated Scattered Mmtes section')
    async verifyUpdatedScatteredMmtesDisplayed(): Promise<void> {
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];
        const actualCount = await this.zealDetailsPage.getScatteredMmteRowCount();

        if (actualCount === replacementMmtes.length) {
            CSReporter.pass(`Updated scattered mmtes displayed: ${actualCount} mmtes`);
        } else {
            throw new Error(`Expected ${replacementMmtes.length} scattered mmtes, found ${actualCount}`);
        }
    }

    @CSBDDStepDef('Changes table should show update changes')
    async verifyChangesTableShowsUpdateChanges(): Promise<void> {
        const changesData = await this.changesHistoryPage.getAllChangesData();

        if (changesData.length > 0) {
            CSReporter.pass(`Changes table shows ${changesData.length} update changes`);
        } else {
            throw new Error('Changes table should show update changes');
        }
    }

    @CSBDDStepDef('Approve Email modal should be visible')
    async verifyApproveEmailModalVisible(): Promise<void> {
        await this.changesHistoryPage.verifyApproveEmailModalDisplayed();
    }

    @CSBDDStepDef('I click Send button in Approve modal')
    async clickSendButtonInApproveModal(): Promise<void> {
        await this.changesHistoryPage.clickSendButtonInApproveModal();
    }

    @CSBDDStepDef('Approval email sent message should be displayed')
    async verifyApprovalEmailSentMessage(): Promise<void> {
        const messageText = await this.zealDetailsPage.getMessageBarText();
        if (messageText.includes('Approval') && messageText.includes('sent')) {
            CSReporter.pass(`Approval email sent message: ${messageText}`);
        } else {
            throw new Error(`Expected approval email sent message, got: ${messageText}`);
        }
    }

    @CSBDDStepDef('I verify updated scattered mmtes in database')
    async verifyUpdatedScatteredMmtesInDatabase(): Promise<void> {
        const zealpremisisDataId = this.scenarioContext.getVariable('zealpremisisDataId');
        const mmteData = await TTTFDatabaseHelper.getZealpremisisMmteData(zealpremisisDataId);
        const replacementMmtes = this.scenarioContext.getVariable('replacementScatteredMmtes') || [];

        if (mmteData.length === replacementMmtes.length) {
            CSReporter.pass(`Updated scattered mmtes verified in database: ${mmteData.length} mmtes`);
        } else {
            throw new Error(`Expected ${replacementMmtes.length} mmtes in database, found ${mmteData.length}`);
        }
    }
}

export default TTTFNewZealSteps;


--------------------------------------------------------------------------------------------------------

/**
 * TTTF Database Helper
 *
 * Encapsulates all database operations for TTTF modules:
 * - Cumulative Mmtes (config/tttf/common/tttf-cumulative-mmtes-db-queries.env)
 * - Zeals/Premisis (config/tttf/common/tttf-zeals-premisis-db-queries.env)
 *
 * All queries are prefixed with DB_QUERY_ in the env files.
 * CSDBUtils automatically resolves query names without the prefix.
 *
 * Usage: Call these methods from step definitions to perform database operations
 * without exposing SQL queries or database details in feature files.
 */

import { CSDBUtils } from '@mdakhan.mak/cs-playwright-test-framework/database-utils';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { CSDateTimeUtility } from '@mdakhan.mak/cs-playwright-test-framework/utilities';

// ==============================================================================
// CUMULATIVE MMTES INTERFACES
// ==============================================================================

export interface CumulativeMmteRecord {
    rrrrrrrrDate: string;
    mmte: string;
    cumulativeMmteName: string;
    source: string;
    publicationDate: string;
    activeFlag?: string;
}

// ==============================================================================
// ZEALS/PREMISIS INTERFACES
// ==============================================================================

export interface ZealPremisisSearchResult {
    type: string;
    zealId: string;
    zealKey: string;
    zealName: string;
    inductorGroup: string;
    zzztSeggregation: string;
    ttcalcShool: string;
    associatedMmtes?: number;
}

export interface ZealDetails {
    zealId: string;
    zealKey: string;
    zealName: string;
    inductorGroup: string;
    kindnessCircle: string;
    zzztSeggregation: string;
    premisisDescription: string;
    calcShoolName: string;
    administrator: string;
}

export interface ScatteredMmteAssociation {
    ffxOrder: number;
    scatteredMmteName: string;
    cumulativeMmteName: string;
    methodologyType: string;
    disputedMmteName: string;
    disputedStartDate: string;
}

export interface PendingApproval {
    approvalId: string;
    entityType: string;
    entityId: string;
    changeType: string;
    requestedBy: string;
    requestedDate: string;
    status: string;
}

export class TTTFDatabaseHelper {
    private static readonly DB_ALIAS = 'TTTF_ORACLE';

    // ===================================================================
    // HELPER: NORMALIZE ROW KEYS TO LOWERCASE (Oracle returns UPPERCASE)
    // ===================================================================

    /**
     * Normalize row object keys to lowercase
     * Oracle returns column names in UPPERCASE by default, but our code uses lowercase
     * This helper converts all keys to lowercase for consistent access
     */
    private static normalizeRow(row: any): any {
        if (!row) return row;
        const normalized: any = {};
        for (const key of Object.keys(row)) {
            normalized[key.toLowerCase()] = row[key];
        }
        return normalized;
    }

    /**
     * Normalize all rows in a result set to lowercase keys
     */
    private static normalizeRows(rows: any[]): any[] {
        if (!rows) return rows;
        return rows.map(row => this.normalizeRow(row));
    }

    // ===================================================================
    // CUMULATIVE MMTE NAME RESOLUTION
    // ===================================================================

    /**
     * Get first active cumulative mmte name from database
     * Query: DB_QUERY_GET_FIRST_ACTIVE_CUMULATIVE_MMTE
     */
    public static async getFirstActiveCumulativeMmteName(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_FIRST_ACTIVE_CUMULATIVE_MMTE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No active cumulative mmte names found in database');
        }

        const mmteName = this.normalizeRow(result.rows[0]).cumulative_mmte_name;
        CSReporter.debug(`Retrieved first active cumulative mmte name: ${mmteName}`);
        return mmteName;
    }

    /**
     * Get all active cumulative mmte names from database
     * Query: DB_QUERY_GET_ACTIVE_CUMULATIVE_MMTES
     */
    public static async getAllActiveCumulativeMmteNames(): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ACTIVE_CUMULATIVE_MMTES'
        );

        const names = this.normalizeRows(result.rows).map((row: any) => row.cumulative_mmte_name);
        CSReporter.debug(`Retrieved ${names.length} active cumulative mmte names`);
        return names;
    }

    // ===================================================================
    // RRRRRRRR DATE RESOLUTION
    // ===================================================================

    /**
     * Get rrrrrrrr date for MANUAL source records at least 5 months old
     * Used for Edit scenarios (EXT07, EXT08, EXT09)
     * Query: DB_QUERY_GET_CUMULATIVE_MMTE_FOR_EDIT (returns rrrrrrrr_dt)
     */
    public static async getManualSourceRrrrrrrrDate(cumulativeMmteName: string): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_CUMULATIVE_MMTE_FOR_EDIT',
            [cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error(`No MANUAL source records at least 5 months old found for: ${cumulativeMmteName}`);
        }

        const rrrrrrrrDate = this.normalizeRow(result.rows[0]).rrrrrrrr_dt;
        CSReporter.debug(`Retrieved MANUAL source rrrrrrrr date: ${rrrrrrrrDate}`);
        return rrrrrrrrDate;
    }

    /**
     * Get existing rrrrrrrr date with daily mmte for a mmte name
     * Query: DB_QUERY_GET_EXISTING_DATE_WITH_DAILY_MMTE
     */
    public static async getExistingRrrrrrrrDate(cumulativeMmteName: string): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EXISTING_DATE_WITH_DAILY_MMTE',
            [cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error(`No existing rrrrrrrr date found for: ${cumulativeMmteName}`);
        }

        const rrrrrrrrDate = this.normalizeRow(result.rows[0]).rrrrrrrr_dt;
        CSReporter.debug(`Retrieved existing rrrrrrrr date: ${rrrrrrrrDate}`);
        return rrrrrrrrDate;
    }

    /**
     * Get non-existing rrrrrrrr date (5 months ago from sysdate)
     * Used when we need a date that doesn't have a daily mmte
     * Query: DB_QUERY_GET_NON_EXISTING_RRRRRRRR_DATE
     */
    public static async getNonExistingRrrrrrrrDate(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_NON_EXISTING_RRRRRRRR_DATE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('Could not get non-existing rrrrrrrr date from database');
        }

        const rrrrrrrrDate = this.normalizeRow(result.rows[0]).rrrrrrrr_dt;
        CSReporter.debug(`Retrieved non-existing rrrrrrrr date: ${rrrrrrrrDate}`);
        return rrrrrrrrDate;
    }

    /**
     * Get MANUAL source record for delete (at least 5 months old)
     * Query: DB_QUERY_GET_MANUAL_RECORD_FOR_DELETE
     */
    public static async getManualRecordForDelete(cumulativeMmteName: string): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_MANUAL_RECORD_FOR_DELETE',
            [cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error(`No MANUAL source records for delete found for: ${cumulativeMmteName}`);
        }

        const rrrrrrrrDate = this.normalizeRow(result.rows[0]).rrrrrrrr_dt;
        CSReporter.debug(`Retrieved MANUAL record for delete: ${rrrrrrrrDate}`);
        return rrrrrrrrDate;
    }

    /**
     * Calculate kindness days ago using framework utility
     */
    public static calculateKindnessDaysAgo(days: number): string {
        const dateObj = CSDateTimeUtility.addKindnessDays(CSDateTimeUtility.now(), -days);
        return CSDateTimeUtility.toUSDateString(dateObj);
    }

    // ===================================================================
    // SEARCH RESULT VERIFICATION
    // ===================================================================

    /**
     * Get cumulative mmtes by name for verification
     * Query: DB_QUERY_SEARCH_CUMULATIVE_DAILY_MMTES_BY_NAME
     */
    public static async getCumulativeMmtesByName(cumulativeMmteName: string): Promise<CumulativeMmteRecord[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_CUMULATIVE_DAILY_MMTES_BY_NAME',
            [cumulativeMmteName]
        );

        return this.normalizeRows(result.rows).map((row: any) => ({
            rrrrrrrrDate: row.rrrrrrrr_dt,
            mmte: row.mmte,
            cumulativeMmteName: row.cumulative_mmte_name,
            source: row.cumulative_mmte_source_cd,
            publicationDate: row.publication_dt || ''
        }));
    }

    /**
     * Get cumulative mmtes by date range for verification
     * Query: DB_QUERY_SEARCH_CUMULATIVE_DAILY_MMTES_BY_DATE
     */
    public static async getCumulativeMmtesByDateRange(startDate: string, endDate: string): Promise<CumulativeMmteRecord[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_CUMULATIVE_DAILY_MMTES_BY_DATE',
            [startDate, endDate]
        );

        return this.normalizeRows(result.rows).map((row: any) => ({
            rrrrrrrrDate: row.rrrrrrrr_dt,
            mmte: row.mmte,
            cumulativeMmteName: row.cumulative_mmte_name,
            source: row.cumulative_mmte_source_cd,
            publicationDate: row.publication_dt || ''
        }));
    }

    /**
     * Get cumulative mmtes by name and date range for verification
     * Query: DB_QUERY_SEARCH_CUMULATIVE_DAILY_MMTES_BY_NAME_AND_DATE
     */
    public static async getCumulativeMmtesByNameAndDateRange(
        cumulativeMmteName: string,
        startDate: string,
        endDate: string
    ): Promise<CumulativeMmteRecord[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_CUMULATIVE_DAILY_MMTES_BY_NAME_AND_DATE',
            [cumulativeMmteName, startDate, endDate]
        );

        return this.normalizeRows(result.rows).map((row: any) => ({
            rrrrrrrrDate: row.rrrrrrrr_dt,
            mmte: row.mmte,
            cumulativeMmteName: row.cumulative_mmte_name,
            source: row.cumulative_mmte_source_cd,
            publicationDate: row.publication_dt || ''
        }));
    }

    /**
     * Get total count of cumulative mmtes matching criteria
     */
    public static async getCumulativeMmtesCount(
        cumulativeMmteName?: string,
        startDate?: string,
        endDate?: string
    ): Promise<number> {
        let records: CumulativeMmteRecord[];

        if (cumulativeMmteName && startDate && endDate) {
            records = await this.getCumulativeMmtesByNameAndDateRange(cumulativeMmteName, startDate, endDate);
        } else if (cumulativeMmteName) {
            records = await this.getCumulativeMmtesByName(cumulativeMmteName);
        } else if (startDate && endDate) {
            records = await this.getCumulativeMmtesByDateRange(startDate, endDate);
        } else {
            throw new Error('At least one search parameter required');
        }

        return records.length;
    }

    // ===================================================================
    // RECORD EXISTENCE VERIFICATION
    // ===================================================================

    /**
     * Check if cumulative mmte record exists (active)
     * Query: DB_QUERY_CHECK_INSTANCE_EXISTS
     */
    public static async recordExists(cumulativeMmteName: string, rrrrrrrrDate: string): Promise<boolean> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'CHECK_INSTANCE_EXISTS',
            [cumulativeMmteName, rrrrrrrrDate]
        );

        if (!result.rows || result.rows.length === 0) {
            return false;
        }

        return parseInt(this.normalizeRow(result.rows[0]).instance_count) > 0;
    }

    /**
     * Verify record was soft deleted (active_flag = 'N')
     * Query: DB_QUERY_VERIFY_SOFT_DELETE
     */
    public static async verifyRecordSoftDeleted(cumulativeMmteName: string, rrrrrrrrDate: string): Promise<boolean> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'VERIFY_SOFT_DELETE',
            [cumulativeMmteName, rrrrrrrrDate]
        );

        if (!result.rows || result.rows.length === 0) {
            return false;
        }

        return this.normalizeRow(result.rows[0]).active_flag === 'N';
    }

    /**
     * Get record details including active flag
     * Query: DB_QUERY_GET_INSTANCE_DETAILS
     */
    public static async getRecordDetails(cumulativeMmteName: string, rrrrrrrrDate: string): Promise<CumulativeMmteRecord | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_INSTANCE_DETAILS',
            [cumulativeMmteName, rrrrrrrrDate]
        );

        if (!result.rows || result.rows.length === 0) {
            return null;
        }

        const row = result.rows[0];
        return {
            rrrrrrrrDate: row.rrrrrrrr_dt,
            mmte: row.mmte,
            cumulativeMmteName: row.cumulative_mmte_name,
            source: row.cumulative_mmte_source_cd,
            publicationDate: row.publication_dt || '',
            activeFlag: row.active_flag
        };
    }

    /**
     * Verify old record was removed after update
     * Query: DB_QUERY_VERIFY_OLD_RECORD_REMOVED
     */
    public static async verifyOldRecordRemoved(cumulativeMmteName: string, rrrrrrrrDate: string): Promise<boolean> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'VERIFY_OLD_RECORD_REMOVED',
            [rrrrrrrrDate, cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            return true; // No result means record doesn't exist
        }

        return parseInt(this.normalizeRow(result.rows[0]).record_count) === 0;
    }

    /**
     * Verify new record was created with updated date
     * Query: DB_QUERY_VERIFY_NEW_RECORD_WITH_UPDATED_DATE
     */
    public static async verifyNewRecordWithUpdatedDate(cumulativeMmteName: string, rrrrrrrrDate: string): Promise<CumulativeMmteRecord | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'VERIFY_NEW_RECORD_WITH_UPDATED_DATE',
            [rrrrrrrrDate, cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            return null;
        }

        const row = result.rows[0];
        return {
            rrrrrrrrDate: row.rrrrrrrr_dt,
            mmte: row.mmte,
            cumulativeMmteName: row.cumulative_mmte_name,
            source: row.cumulative_mmte_source_cd,
            publicationDate: ''
        };
    }

    /**
     * Verify mmte was updated for existing record
     * Query: DB_QUERY_VERIFY_MMTE_UPDATED
     */
    public static async verifyMmteUpdated(cumulativeMmteName: string, rrrrrrrrDate: string, expectedMmte: string): Promise<boolean> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'VERIFY_MMTE_UPDATED',
            [rrrrrrrrDate, cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            return false;
        }

        return this.compareMmtes(this.normalizeRow(result.rows[0]).mmte, expectedMmte);
    }

    // ===================================================================
    // ADD/EDIT VALIDATION HELPERS
    // ===================================================================

    /**
     * Get cumulative mmte name without daily mmte for a specific date (for Add Instance)
     * Query: DB_QUERY_GET_MMTE_WITHOUT_DAILY_FOR_DATE
     */
    public static async getCumulativeMmteWithoutDailyMmte(rrrrrrrrDate: string): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_MMTE_WITHOUT_DAILY_FOR_DATE',
            [rrrrrrrrDate]
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error(`No cumulative mmte without daily mmte found for date: ${rrrrrrrrDate}`);
        }

        const mmteName = this.normalizeRow(result.rows[0]).cumulative_mmte_name;
        CSReporter.debug(`Found cumulative mmte without daily mmte: ${mmteName}`);
        return mmteName;
    }

    /**
     * Get different cumulative mmte name that has daily mmte on same date (for duplicate validation)
     * Query: DB_QUERY_GET_DIFFERENT_MMTE_SAME_DATE
     */
    public static async getDifferentMmteWithSameDate(rrrrrrrrDate: string, excludeMmteName: string): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_DIFFERENT_MMTE_SAME_DATE',
            [rrrrrrrrDate, excludeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error(`No different mmte with same date found: ${rrrrrrrrDate}`);
        }

        const mmteName = this.normalizeRow(result.rows[0]).cumulative_mmte_name;
        CSReporter.debug(`Found different mmte with same date: ${mmteName}`);
        return mmteName;
    }

    /**
     * Get existing rrrrrrrr date that has daily mmte for cumulative mmte (for duplicate validation)
     * Query: DB_QUERY_GET_EXISTING_RRRRRRRR_DATE
     */
    public static async getExistingDateWithDailyMmte(cumulativeMmteName: string, excludeDate: string): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EXISTING_RRRRRRRR_DATE',
            [cumulativeMmteName, excludeDate]
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error(`No existing date with daily mmte found for: ${cumulativeMmteName}`);
        }

        const rrrrrrrrDate = this.normalizeRow(result.rows[0]).rrrrrrrr_dt;
        CSReporter.debug(`Found existing date with daily mmte: ${rrrrrrrrDate}`);
        return rrrrrrrrDate;
    }

    /**
     * Verify instance was removed (count = 0)
     * Query: DB_QUERY_VERIFY_INSTANCE_REMOVED
     */
    public static async verifyInstanceRemoved(cumulativeMmteName: string, rrrrrrrrDate: string): Promise<boolean> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'VERIFY_INSTANCE_REMOVED',
            [cumulativeMmteName, rrrrrrrrDate]
        );

        if (!result.rows || result.rows.length === 0) {
            return true;
        }

        return parseInt(this.normalizeRow(result.rows[0]).instance_count) === 0;
    }

    // ===================================================================
    // MMTE VALUE VERIFICATION
    // ===================================================================

    /**
     * Get mmte value for a specific record
     */
    public static async getMmteValue(cumulativeMmteName: string, rrrrrrrrDate: string): Promise<string> {
        const record = await this.getRecordDetails(cumulativeMmteName, rrrrrrrrDate);
        return record?.mmte || '';
    }

    /**
     * Get source value for a specific record
     */
    public static async getSourceValue(cumulativeMmteName: string, rrrrrrrrDate: string): Promise<string> {
        const record = await this.getRecordDetails(cumulativeMmteName, rrrrrrrrDate);
        return record?.source || '';
    }

    /**
     * Check if publication date is blank for a record
     */
    public static async isPublicationDateBlank(cumulativeMmteName: string, rrrrrrrrDate: string): Promise<boolean> {
        const record = await this.getRecordDetails(cumulativeMmteName, rrrrrrrrDate);
        return !record?.publicationDate || record.publicationDate.trim() === '';
    }

    // ===================================================================
    // COMPARISON HELPERS
    // ===================================================================

    /**
     * Compare UI data with database data
     */
    public static compareRecords(uiRecord: CumulativeMmteRecord, dbRecord: CumulativeMmteRecord): boolean {
        return (
            uiRecord.rrrrrrrrDate === dbRecord.rrrrrrrrDate &&
            uiRecord.cumulativeMmteName === dbRecord.cumulativeMmteName &&
            uiRecord.source === dbRecord.source &&
            Math.abs(parseFloat(uiRecord.mmte) - parseFloat(dbRecord.mmte)) < 0.01
        );
    }

    /**
     * Compare mmte values with tolerance
     */
    public static compareMmtes(mmte1: string, mmte2: string, tolerance: number = 0.01): boolean {
        return Math.abs(parseFloat(mmte1) - parseFloat(mmte2)) < tolerance;
    }

    // ===================================================================
    // ZEALS/PREMISIS - DROPDOWN OPTIONS
    // ===================================================================

    /**
     * Get all active cumulative mmte names for Scattered Mmte/Disputed Mmte search dropdowns
     * Query: DB_QUERY_GET_CUMULATIVE_MMTE_OPTIONS
     */
    public static async getCumulativeMmteOptions(): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_CUMULATIVE_MMTE_OPTIONS'
        );

        const rows = this.normalizeRows(result.rows);
        const options = rows.map((row: any) => row.cumulative_mmte_name);
        CSReporter.debug(`Retrieved ${options.length} cumulative mmte options`);
        return options;
    }

    /**
     * Get all distinct inductor groups for Inductor Group search dropdown
     * Query: DB_QUERY_GET_INDUCTOR_GROUP_OPTIONS
     */
    public static async getInductorGroupOptions(): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_INDUCTOR_GROUP_OPTIONS'
        );

        const rows = this.normalizeRows(result.rows);
        const options = rows.map((row: any) => row.inductor_group);
        CSReporter.debug(`Retrieved ${options.length} inductor group options`);
        return options;
    }

    /**
     * Get all distinct kindness circles for Kindness Circle search dropdown
     * Query: DB_QUERY_GET_KINDNESS_CIRCLE_OPTIONS
     */
    public static async getKindnessCircleOptions(): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_KINDNESS_CIRCLE_OPTIONS'
        );

        const rows = this.normalizeRows(result.rows);
        const options = rows.map((row: any) => row.kindness_circle);
        CSReporter.debug(`Retrieved ${options.length} kindness circle options`);
        return options;
    }

    /**
     * Get available scattered mmtes for adding to a zeal
     * Query: DB_QUERY_GET_AVAILABLE_SCATTERED_MMTES
     */
    public static async getAvailableScatteredMmtes(): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_AVAILABLE_SCATTERED_MMTES'
        );

        const rows = this.normalizeRows(result.rows);
        const mmtes = rows.map((row: any) => row.scattered_mmte_name);
        CSReporter.debug(`Retrieved ${mmtes.length} available scattered mmtes`);
        return mmtes;
    }

    // ===================================================================
    // ZEALS/PREMISIS - ZEAL SEARCHES
    // ===================================================================

    /**
     * Search Zeal by Name
     * Query: DB_QUERY_SEARCH_ZEAL_BY_NAME or DB_QUERY_SEARCH_ZEAL_BY_NAME_WITH_PREMISIS
     */
    public static async searchZealByName(
        zealName: string,
        includePremisis: boolean = false
    ): Promise<ZealPremisisSearchResult[]> {
        const queryName = includePremisis
            ? 'SEARCH_ZEAL_BY_NAME_WITH_PREMISIS'
            : 'SEARCH_ZEAL_BY_NAME';

        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            queryName,
            [zealName]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search Zeal by ID
     * Query: DB_QUERY_SEARCH_ZEAL_BY_ID or DB_QUERY_SEARCH_ZEAL_BY_ID_WITH_PREMISIS
     */
    public static async searchZealById(
        zealId: string,
        includePremisis: boolean = false
    ): Promise<ZealPremisisSearchResult[]> {
        const queryName = includePremisis
            ? 'SEARCH_ZEAL_BY_ID_WITH_PREMISIS'
            : 'SEARCH_ZEAL_BY_ID';

        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            queryName,
            [zealId]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search Zeal by Key
     * Query: DB_QUERY_SEARCH_ZEAL_BY_KEY
     */
    public static async searchZealByKey(zealKey: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_ZEAL_BY_KEY',
            [zealKey]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    // ===================================================================
    // ZEALS/PREMISIS - PREMISIS SEARCHES
    // ===================================================================

    /**
     * Search Premisis by Description
     * Query: DB_QUERY_SEARCH_PREMISIS_BY_DESCRIPTION
     */
    public static async searchPremisisByDescription(description: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_PREMISIS_BY_DESCRIPTION',
            [description]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search Premisis by Zzzt Seggregation
     * Query: DB_QUERY_SEARCH_PREMISIS_BY_ZZZT_ABBR
     */
    public static async searchPremisisByZzztSeggregation(zzztAbbr: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_PREMISIS_BY_ZZZT_ABBR',
            [zzztAbbr]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    // ===================================================================
    // ZEALS/PREMISIS - SCATTERED MMTE SEARCHES
    // ===================================================================

    /**
     * Search by Scattered Mmte Name
     * Query: DB_QUERY_SEARCH_BY_SCATTERED_MMTE_NAME
     */
    public static async searchByScatteredMmteName(mmteName: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_SCATTERED_MMTE_NAME',
            [mmteName]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search by Scattered Mmte Cumulative Mmte
     * Query: DB_QUERY_SEARCH_BY_SCATTERED_MMTE_CUMULATIVE
     */
    public static async searchByScatteredMmteCumulative(cumulativeMmteName: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_SCATTERED_MMTE_CUMULATIVE',
            [cumulativeMmteName]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search by Scattered Mmte Has Disputed
     * Query: DB_QUERY_SEARCH_BY_SCATTERED_MMTE_HAS_DISPUTED
     */
    public static async searchByScatteredMmteHasDisputed(): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_SCATTERED_MMTE_HAS_DISPUTED'
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    // ===================================================================
    // ZEALS/PREMISIS - DISPUTED MMTE SEARCHES
    // ===================================================================

    /**
     * Search by Disputed Mmte Name
     * Query: DB_QUERY_SEARCH_BY_DISPUTED_MMTE_NAME
     */
    public static async searchByDisputedMmteName(mmteName: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_DISPUTED_MMTE_NAME',
            [mmteName]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search by Disputed Date
     * Query: DB_QUERY_SEARCH_BY_DISPUTED_DATE
     */
    public static async searchByDisputedDate(disputedDate: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_DISPUTED_DATE',
            [disputedDate]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search by Disputed Mmte Cumulative Mmte
     * Query: DB_QUERY_SEARCH_BY_DISPUTED_CUMULATIVE
     */
    public static async searchByDisputedCumulative(cumulativeMmteName: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_DISPUTED_CUMULATIVE',
            [cumulativeMmteName]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    // ===================================================================
    // ZEALS/PREMISIS - OTHER SEARCH TYPES
    // ===================================================================

    /**
     * Search by Inductor Group
     * Query: DB_QUERY_SEARCH_BY_INDUCTOR_GROUP
     */
    public static async searchByInductorGroup(inductorGroup: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_INDUCTOR_GROUP',
            [inductorGroup]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search by Kindness Circle
     * Query: DB_QUERY_SEARCH_BY_KINDNESS_CIRCLE
     */
    public static async searchByKindnessCircle(kindnessCircle: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_KINDNESS_CIRCLE',
            [kindnessCircle]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search by Sketchmark Flag
     * Query: DB_QUERY_SEARCH_BY_SKETCHMARK
     */
    public static async searchBySketchmark(hasSketchmark: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_SKETCHMARK',
            [hasSketchmark === 'Yes' ? 'Y' : 'N']
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search by Administrator Name
     * Query: DB_QUERY_SEARCH_BY_ADMINISTRATOR_NAME
     */
    public static async searchByAdministratorName(adminName: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_ADMINISTRATOR_NAME',
            [adminName]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search by Administrator Email
     * Query: DB_QUERY_SEARCH_BY_ADMINISTRATOR_EMAIL
     */
    public static async searchByAdministratorEmail(email: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_ADMINISTRATOR_EMAIL',
            [email]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    /**
     * Search by GGG Name (Calc Shool Name)
     * Query: DB_QUERY_SEARCH_BY_GGG_NAME
     */
    public static async searchByGGGName(gggName: string): Promise<ZealPremisisSearchResult[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'SEARCH_BY_GGG_NAME',
            [gggName]
        );

        return this.mapZealPremisisSearchResults(result.rows);
    }

    // ===================================================================
    // ZEALS/PREMISIS - ZEAL DETAILS
    // ===================================================================

    /**
     * Get zeal details by zeal ID
     * Query: DB_QUERY_GET_ZEAL_DETAILS
     */
    public static async getZealDetails(zealId: string): Promise<ZealDetails | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEAL_DETAILS',
            [zealId]
        );

        if (!result.rows || result.rows.length === 0) {
            return null;
        }

        const row = result.rows[0];
        return {
            zealId: row.zeal_id,
            zealKey: row.zeal_key,
            zealName: row.zeal_name,
            inductorGroup: row.inductor_group || '',
            kindnessCircle: row.kindness_circle || '',
            zzztSeggregation: row.zzzt_seggregation || '',
            premisisDescription: row.premisis_description || '',
            calcShoolName: row.calc_shool_name || '',
            administrator: row.acct_manager || ''
        };
    }

    /**
     * Get zeal with no scattered mmtes (for new zeal setup)
     * Query: DB_QUERY_GET_ZEAL_WITHOUT_SCATTERED_MMTES
     */
    public static async getZealWithoutScatteredMmtes(): Promise<ZealDetails | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEAL_WITHOUT_SCATTERED_MMTES'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No zeal found without scattered mmtes');
            return null;
        }

        const row = result.rows[0];
        CSReporter.debug(`Found zeal without scattered mmtes: ${row.zeal_id}`);
        return {
            zealId: row.zeal_id,
            zealKey: row.zeal_key,
            zealName: row.zeal_name,
            inductorGroup: '',
            kindnessCircle: '',
            zzztSeggregation: '',
            premisisDescription: '',
            calcShoolName: '',
            administrator: ''
        };
    }

    /**
     * Get associated scattered mmtes for a zeal
     * Query: DB_QUERY_GET_ZEAL_SCATTERED_MMTES
     */
    public static async getZealScatteredMmtes(zealId: string): Promise<ScatteredMmteAssociation[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEAL_SCATTERED_MMTES',
            [zealId]
        );

        return this.normalizeRows(result.rows).map((row: any) => ({
            ffxOrder: parseInt(row.ffx_order) || 0,
            scatteredMmteName: row.scattered_mmte_name || '',
            cumulativeMmteName: row.cumulative_mmte_name || '',
            methodologyType: row.methodology_type || '',
            disputedMmteName: row.disputed_mmte_name || '',
            disputedStartDate: row.disputed_start_date || ''
        }));
    }

    // ===================================================================
    // ZEALS/PREMISIS - VERIFICATION METHODS
    // ===================================================================

    /**
     * Verify scattered mmte was added to zeal
     * Query: DB_QUERY_VERIFY_SCATTERED_MMTE_ADDED
     */
    public static async verifyScatteredMmteAdded(
        zealId: string,
        scatteredMmteName: string
    ): Promise<boolean> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'VERIFY_SCATTERED_MMTE_ADDED',
            [zealId, scatteredMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            return false;
        }

        const count = parseInt(this.normalizeRow(result.rows[0]).count) || 0;
        return count > 0;
    }

    /**
     * Get pending approvals for a zeal
     * Query: DB_QUERY_GET_PENDING_APPROVALS
     */
    public static async getPendingApprovals(zealId: string): Promise<PendingApproval[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_PENDING_APPROVALS',
            [zealId]
        );

        return this.normalizeRows(result.rows).map((row: any) => ({
            approvalId: row.approval_id,
            entityType: row.entity_type,
            entityId: row.entity_id,
            changeType: row.change_type,
            requestedBy: row.requested_by,
            requestedDate: row.requested_date,
            status: row.status
        }));
    }

    /**
     * Verify approval was completed
     * Query: DB_QUERY_VERIFY_APPROVAL_COMPLETED
     */
    public static async verifyApprovalCompleted(approvalId: string): Promise<boolean> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'VERIFY_APPROVAL_COMPLETED',
            [approvalId]
        );

        if (!result.rows || result.rows.length === 0) {
            return false;
        }

        return this.normalizeRow(result.rows[0]).status === 'APPROVED';
    }

    // ===================================================================
    // ZEALS/PREMISIS - COMPARISON HELPERS
    // ===================================================================

    /**
     * Compare UI search results with database results
     * Compares by matching records using zealKey + type (order-independent)
     * Same zeal can appear as both ZEAL and PREMISIS types
     * Compares all fields: Type, Zeal ID, Zeal Key, Zeal Name, Inductor Group,
     * Zzzt Seggregation, Ttcalc Shool, Associated Mmtes
     */
    public static compareZealPremisisSearchResults(
        uiResults: ZealPremisisSearchResult[],
        dbResults: ZealPremisisSearchResult[]
    ): { match: boolean; differences: string[] } {
        const differences: string[] = [];

        if (uiResults.length !== dbResults.length) {
            differences.push(`Row count mismatch: UI=${uiResults.length}, DB=${dbResults.length}`);
        }

        // Check each UI record exists in DB results (order-independent)
        // Match by zealKey + type since same zeal can appear as ZEAL and PREMISIS
        for (const ui of uiResults) {
            const db = dbResults.find(d => d.zealKey === ui.zealKey && d.type === ui.type);

            if (!db) {
                differences.push(`UI record [${ui.type}] Zeal Key '${ui.zealKey}' not found in database results`);
                continue;
            }

            // Compare all fields
            if (ui.zealId !== db.zealId) {
                differences.push(`[${ui.type}] Zeal Key '${ui.zealKey}' Zeal ID mismatch: UI='${ui.zealId}', DB='${db.zealId}'`);
            }
            if (ui.zealName !== db.zealName) {
                differences.push(`[${ui.type}] Zeal Key '${ui.zealKey}' Zeal Name mismatch: UI='${ui.zealName}', DB='${db.zealName}'`);
            }
            if (ui.inductorGroup !== db.inductorGroup) {
                differences.push(`[${ui.type}] Zeal Key '${ui.zealKey}' Inductor Group mismatch: UI='${ui.inductorGroup}', DB='${db.inductorGroup}'`);
            }
            if (ui.zzztSeggregation !== db.zzztSeggregation) {
                differences.push(`[${ui.type}] Zeal Key '${ui.zealKey}' Zzzt Seggregation mismatch: UI='${ui.zzztSeggregation}', DB='${db.zzztSeggregation}'`);
            }
            if (ui.ttcalcShool !== db.ttcalcShool) {
                differences.push(`[${ui.type}] Zeal Key '${ui.zealKey}' Ttcalc Shool mismatch: UI='${ui.ttcalcShool}', DB='${db.ttcalcShool}'`);
            }
            if (ui.associatedMmtes !== db.associatedMmtes) {
                differences.push(`[${ui.type}] Zeal Key '${ui.zealKey}' Associated Mmtes mismatch: UI='${ui.associatedMmtes}', DB='${db.associatedMmtes}'`);
            }
        }

        // Check for DB records not in UI
        for (const db of dbResults) {
            const ui = uiResults.find(u => u.zealKey === db.zealKey && u.type === db.type);
            if (!ui) {
                differences.push(`DB record [${db.type}] Zeal Key '${db.zealKey}' not found in UI results`);
            }
        }

        return {
            match: differences.length === 0,
            differences
        };
    }

    // ===================================================================
    // NEW ZEAL SETUP - TEST DATA RETRIEVAL
    // ===================================================================

    /**
     * Get a zeal with no scattered mmtes associated (for new zeal setup)
     * Query: DB_QUERY_GET_ZEAL_FOR_NEW_SETUP
     */
    public static async getZealForNewSetup(): Promise<ZealDetails | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEAL_FOR_NEW_SETUP'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No zeal found for new setup');
            return null;
        }

        const row = result.rows[0];
        CSReporter.debug(`Found zeal for new setup: ${row.zeal_id}`);
        return {
            zealId: String(row.zeal_id),
            zealKey: row.zeal_key || '',
            zealName: row.zeal_name || '',
            inductorGroup: row.inductor_group || '',
            kindnessCircle: row.kindness_circle || '',
            zzztSeggregation: row.zzzt_seggregation || '',
            premisisDescription: row.premisis_description || '',
            calcShoolName: row.calc_shool_name || '',
            administrator: row.acct_manager || ''
        };
    }

    /**
     * Get scattered mmtes to add (one from each methodology type)
     * Query: DB_QUERY_GET_SCATTERED_MMTES_TO_ADD
     */
    public static async getScatteredMmtesToAdd(): Promise<Array<{ scatteredMmteName: string; methodologyType: string }>> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SCATTERED_MMTES_TO_ADD'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No scattered mmtes available to add');
            return [];
        }

        return this.normalizeRows(result.rows).map((row: any) => ({
            scatteredMmteName: row.scattered_mmte_name,
            methodologyType: row.methodology_type
        }));
    }

    /**
     * Get FFX Inductor Type options
     * Query: DB_QUERY_GET_FFX_INDUCTOR_OPTIONS
     */
    public static async getFfxInductorOptions(): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_FFX_INDUCTOR_OPTIONS'
        );

        const options = this.normalizeRows(result.rows).map((row: any) => row.code);
        CSReporter.debug(`Retrieved ${options.length} FFX inductor options`);
        return options;
    }

    /**
     * Get scattered mmte details (cumulative mmte name, methodology type)
     * Query: DB_QUERY_GET_SCATTERED_MMTE_DETAILS
     */
    public static async getScatteredMmteDetails(scatteredMmteName: string): Promise<{
        cumulativeMmteName: string;
        methodologyType: string;
    } | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SCATTERED_MMTE_DETAILS',
            [scatteredMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            return null;
        }

        const row = result.rows[0];
        return {
            cumulativeMmteName: row.cumulative_mmte_name || '',
            methodologyType: row.methodology_type || ''
        };
    }

    // ===================================================================
    // NEW ZEAL SETUP - VERIFICATION METHODS
    // ===================================================================

    /**
     * Verify zeal data record exists
     * Query: DB_QUERY_GET_ZEAL_DATA_BY_ZEAL_ID
     */
    public static async getZealDataByZealId(zealId: string): Promise<{
        zealpremisisDataId: string;
        zealId: string;
    } | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEAL_DATA_BY_ZEAL_ID',
            [zealId]
        );

        if (!result.rows || result.rows.length === 0) {
            return null;
        }

        const row = result.rows[0];
        return {
            zealpremisisDataId: String(row.zealpremisis_data_id),
            zealId: String(row.zeal_id)
        };
    }

    /**
     * Get zealpremisis data record details
     * Query: DB_QUERY_GET_ZEALPREMISIS_DATA_DETAILS
     */
    public static async getZealpremisisDataDetails(zealpremisisDataId: string): Promise<{
        sketchmarkReplacementFlag: string;
        inductorCode: string;
    } | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEALPREMISIS_DATA_DETAILS',
            [zealpremisisDataId]
        );

        if (!result.rows || result.rows.length === 0) {
            return null;
        }

        const row = result.rows[0];
        return {
            sketchmarkReplacementFlag: row.sketchmark_replacement_flag || '',
            inductorCode: row.inductor_code || ''
        };
    }

    /**
     * Get zealpremisis data status log (pending changes)
     * Query: DB_QUERY_GET_ZEALPREMISIS_STATUS_LOG
     */
    public static async getZealpremisisStatusLog(zealpremisisDataId: string): Promise<Array<{
        fieldName: string;
        oldValue: string;
        newValue: string;
        action: string;
        insertedDt: string;
        zealpremisisStatusCd: string;
        ffxOrder: number;
        disputedScatteredMmteName: string;
        disputedStartDate: string;
    }>> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEALPREMISIS_STATUS_LOG',
            [zealpremisisDataId]
        );

        if (!result.rows || result.rows.length === 0) {
            return [];
        }

        return this.normalizeRows(result.rows).map((row: any) => ({
            fieldName: row.field_name || '',
            oldValue: row.old_value || '',
            newValue: row.new_value || '',
            action: row.action || '',
            insertedDt: row.inserted_dt || '',
            zealpremisisStatusCd: row.zealpremisis_status_cd || '',
            ffxOrder: parseInt(row.ffx_order) || 0,
            disputedScatteredMmteName: row.disputed_scattered_mmte_name || '',
            disputedStartDate: row.disputed_start_date || ''
        }));
    }

    /**
     * Get zealpremisis mmte data (after approval)
     * Query: DB_QUERY_GET_ZEALPREMISIS_MMTE_DATA
     */
    public static async getZealpremisisMmteData(zealpremisisDataId: string): Promise<Array<{
        scatteredMmteName: string;
        disputedScatteredMmteName: string;
        disputedDate: string;
        ffxOrder: number;
    }>> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEALPREMISIS_MMTE_DATA',
            [zealpremisisDataId]
        );

        if (!result.rows || result.rows.length === 0) {
            return [];
        }

        return this.normalizeRows(result.rows).map((row: any) => ({
            scatteredMmteName: row.scattered_mmte_name || '',
            disputedScatteredMmteName: row.disputed_scattered_mmte_name || '',
            disputedDate: row.disputed_date || '',
            ffxOrder: parseInt(row.ffx_order) || 0
        }));
    }

    /**
     * Verify status log has expected status
     */
    public static async verifyStatusLogStatus(
        zealpremisisDataId: string,
        expectedStatus: 'AWAITING' | 'APPROVED' | 'REJECTED'
    ): Promise<boolean> {
        const statusLog = await this.getZealpremisisStatusLog(zealpremisisDataId);

        if (statusLog.length === 0) {
            return false;
        }

        return statusLog.every(log => log.zealpremisisStatusCd === expectedStatus);
    }

    // ===================================================================
    // PREMISIS-SPECIFIC METHODS
    // ===================================================================

    /**
     * Get a premisis with no scattered mmtes associated (for new premisis setup)
     * Query: DB_QUERY_GET_PREMISIS_FOR_NEW_SETUP
     */
    public static async getPremisisForNewSetup(): Promise<(ZealDetails & { zzztId: string }) | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_PREMISIS_FOR_NEW_SETUP'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No premisis found for new setup');
            return null;
        }

        const row = result.rows[0];
        CSReporter.debug(`Found premisis for new setup: ${row.zzzt_id}, ZzztAbbrev=${row.zzzt_seggregation}`);
        return {
            zealId: String(row.zeal_id || row.zzzt_id),
            zealKey: row.zeal_key || '',
            zealName: row.zeal_name || '',
            inductorGroup: row.inductor_group || '',
            kindnessCircle: row.kindness_circle || '',
            zzztSeggregation: row.zzzt_seggregation || '',
            premisisDescription: row.premisis_description || '',
            calcShoolName: row.calc_shool_name || '',
            administrator: row.acct_manager || '',
            zzztId: String(row.zzzt_id || '')
        };
    }

    /**
     * Verify zzzt data record exists (for Premisis)
     * Query: DB_QUERY_GET_ZZZT_DATA_BY_ZZZT_ID
     */
    public static async getZzztDataByZzztId(zzztId: string): Promise<{
        zealpremisisDataId: string;
        zzztId: string;
    } | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZZZT_DATA_BY_ZZZT_ID',
            [zzztId]
        );

        if (!result.rows || result.rows.length === 0) {
            return null;
        }

        const row = result.rows[0];
        return {
            zealpremisisDataId: String(row.zealpremisis_data_id),
            zzztId: String(row.zzzt_id)
        };
    }

    // ===================================================================
    // EDIT NAVIGATION METHODS (SCENARIO_08, 09A)
    // ===================================================================

    /**
     * Get a zeal for edit navigation testing
     * Query: DB_QUERY_GET_ZEAL_FOR_EDIT_NAVIGATION
     */
    public static async getZealForEditNavigation(): Promise<ZealDetails | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ZEAL_FOR_EDIT_NAVIGATION'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No zeal found for edit navigation');
            return null;
        }

        const row = result.rows[0];
        CSReporter.debug(`Found zeal for edit navigation: ${row.zeal_id}`);
        return {
            zealId: String(row.zeal_id),
            zealKey: row.zeal_key || '',
            zealName: row.zeal_name || '',
            inductorGroup: row.inductor_group || '',
            kindnessCircle: row.kindness_circle || '',
            zzztSeggregation: row.zzzt_seggregation || '',
            premisisDescription: row.premisis_description || '',
            calcShoolName: row.calc_shool_name || '',
            administrator: row.acct_manager || ''
        };
    }

    /**
     * Get a premisis for edit navigation testing
     * Query: DB_QUERY_GET_PREMISIS_FOR_EDIT_NAVIGATION
     */
    public static async getPremisisForEditNavigation(): Promise<(ZealDetails & { zzztId: string }) | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_PREMISIS_FOR_EDIT_NAVIGATION'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No premisis found for edit navigation');
            return null;
        }

        const row = result.rows[0];
        CSReporter.debug(`Found premisis for edit navigation: ${row.zeal_id}, ZzztAbbrev=${row.zzzt_seggregation}`);
        return {
            zealId: String(row.zeal_id || row.zzzt_id),
            zealKey: row.zeal_key || '',
            zealName: row.zeal_name || '',
            inductorGroup: row.inductor_group || '',
            kindnessCircle: row.kindness_circle || '',
            zzztSeggregation: row.zzzt_seggregation || '',
            premisisDescription: row.premisis_description || '',
            calcShoolName: row.calc_shool_name || '',
            administrator: row.acct_manager || '',
            zzztId: String(row.zzzt_id || '')
        };
    }

    // ===================================================================
    // EXISTING ZEAL UPDATE METHODS (SCENARIO_09B)
    // ===================================================================

    /**
     * Get an existing zeal that already has scattered mmtes
     * Query: DB_QUERY_GET_EXISTING_ZEAL_WITH_SCATTERED_MMTES
     */
    public static async getExistingZealWithScatteredMmtes(): Promise<{
        zealId: string;
        zealKey: string;
        zealName: string;
        inductorGroup: string;
        kindnessCircle: string;
        zzztSeggregation: string;
        sketchmarkFlag: string;
        inductorCode: string;
        scatteredMmtes: Array<{ scatteredMmteName: string; methodologyType: string }>;
    } | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EXISTING_ZEAL_WITH_SCATTERED_MMTES'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No existing zeal with scattered mmtes found');
            return null;
        }

        // First row has zeal info, all rows have scattered mmte info
        const firstRow = result.rows[0];
        const scatteredMmtes = this.normalizeRows(result.rows).map((row: any) => ({
            scatteredMmteName: row.scattered_mmte_name,
            methodologyType: row.methodology_type || ''
        }));

        CSReporter.debug(`Found existing zeal: ${firstRow.zeal_id} with ${scatteredMmtes.length} scattered mmtes`);
        return {
            zealId: String(firstRow.zeal_id),
            zealKey: firstRow.zeal_key || '',
            zealName: firstRow.zeal_name || '',
            inductorGroup: firstRow.inductor_group || '',
            kindnessCircle: firstRow.kindness_circle || '',
            zzztSeggregation: firstRow.zzzt_seggregation || '',
            sketchmarkFlag: firstRow.sketchmark_replacement_flag || 'N',
            inductorCode: firstRow.inductor_code || '',
            scatteredMmtes: scatteredMmtes
        };
    }

    /**
     * Get replacement scattered mmtes (excluding existing ones)
     * Query: DB_QUERY_GET_REPLACEMENT_SCATTERED_MMTES
     */
    public static async getReplacementScatteredMmtes(
        existingMmteNames: string[]
    ): Promise<Array<{ scatteredMmteName: string; methodologyType: string }>> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_REPLACEMENT_SCATTERED_MMTES',
            [existingMmteNames.join(',')]
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No replacement scattered mmtes available');
            return [];
        }

        return this.normalizeRows(result.rows).map((row: any) => ({
            scatteredMmteName: row.scattered_mmte_name,
            methodologyType: row.methodology_type
        }));
    }

    /**
     * Get a different FFX Inductor Type than the current one
     * Query: DB_QUERY_GET_DIFFERENT_FFX_INDUCTOR_TYPE
     */
    public static async getDifferentFfxInductorType(currentInductorCode: string): Promise<string | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_DIFFERENT_FFX_INDUCTOR_TYPE',
            [currentInductorCode]
        );

        if (!result.rows || result.rows.length === 0) {
            return null;
        }

        return this.normalizeRow(result.rows[0]).inductor_code;
    }

    // ===================================================================
    // COMPREHENSIVE TEST DATA SETUP METHODS
    // ===================================================================

    /**
     * Get disputed scattered mmtes (excluding already selected scattered mmtes)
     * Query: DB_QUERY_GET_DISPUTED_SCATTERED_MMTES
     * @param excludeMmteNames - Array of scattered mmte names to exclude
     */
    public static async getDisputedScatteredMmtes(
        excludeMmteNames: string[]
    ): Promise<Array<{ scatteredMmteName: string; methodologyType: string }>> {
        const excludeList = excludeMmteNames.join(',');
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_DISPUTED_SCATTERED_MMTES',
            [excludeList, excludeList]
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No disputed scattered mmtes available');
            return [];
        }

        const mmtes = this.normalizeRows(result.rows).map((row: any) => ({
            scatteredMmteName: row.scattered_mmte_name,
            methodologyType: row.methodology_type
        }));

        CSReporter.debug(`Retrieved ${mmtes.length} disputed scattered mmtes (excluding: ${excludeList})`);
        return mmtes;
    }

    /**
     * Get first available FFX Inductor Type
     * Query: DB_QUERY_GET_FIRST_FFX_INDUCTOR_TYPE
     */
    public static async getFirstFfxInductorType(): Promise<string | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_FIRST_FFX_INDUCTOR_TYPE'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No FFX Inductor Type available');
            return null;
        }

        const inductorCode = this.normalizeRow(result.rows[0]).inductor_code;
        CSReporter.debug(`Retrieved first FFX Inductor Type: ${inductorCode}`);
        return inductorCode;
    }

    /**
     * Calculate disputed start date (15 kindness days ago)
     * Returns date in MM/DD/YYYY format, skipping weekends
     */
    public static calculateDisputedStartDate(): string {
        const dateObj = CSDateTimeUtility.addKindnessDays(CSDateTimeUtility.now(), -15);
        return CSDateTimeUtility.toUSDateString(dateObj);
    }

    // ===================================================================
    // PRIVATE HELPERS
    // ===================================================================

    /**
     * Map database rows to ZealPremisisSearchResult array
     */
    private static mapZealPremisisSearchResults(rows: any[]): ZealPremisisSearchResult[] {
        if (!rows || rows.length === 0) {
            return [];
        }

        return rows.map((row: any) => ({
            type: row.Type || row.type || '',
            zealId: String(row['Zeal ID'] || row.zeal_id || ''),
            zealKey: row['Zeal Key'] || row.zeal_key || '',
            zealName: row['Zeal Name'] || row.zeal_name || '',
            inductorGroup: row['Inductor Group'] || row.inductor_group || '',
            zzztSeggregation: row['Zzzt Seggregation'] || row.zzzt_seggregation || '',
            ttcalcShool: row['Ttcalc Shool'] || row.ttcalc_shool || '',
            associatedMmtes: parseInt(row['Associated Mmtes'] || row.associated_mmtes || '0')
        }));
    }
}

export default TTTFDatabaseHelper;

-----------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Zeal Details Page
 * Source: SCENARIO_03_NewZeal_Approval.txt
 * Handles Zeal Details view/edit mode, Settings, Associated Scattered Mmtes
 */
@CSPage('tttf-zeal-details')
export class TTTFZealDetailsPage extends CSBasePage {

    // ===================================================================
    // PAGE HEADER ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h1[text()="Zeal Details"]',
        description: 'Zeal Details page header',
        waitForVisible: true,
        alternativeLocators: ['text:Zeal Details']
    })
    public zealDetailsHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//h1[text()="Edit Zeal"]',
        description: 'Edit Zeal page header (edit mode)',
        waitForVisible: true,
        alternativeLocators: ['text:Edit Zeal']
    })
    public editZealHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and text()='Edit']/parent::button",
        description: 'Edit button',
        waitForEnabled: true
    })
    public editButton!: CSWebElement;

    // ===================================================================
    // TAB ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and text()='Details']/parent::button",
        description: 'Details tab button',
        waitForVisible: true
    })
    public detailsTab!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and contains(text(),'Changes:')]/parent::button",
        description: 'Changes tab button',
        waitForVisible: true
    })
    public changesTab!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-button__label' and text()='History']/parent::button",
        description: 'History tab button',
        waitForVisible: true
    })
    public historyTab!: CSWebElement;

    // ===================================================================
    // SUMMARY SECTION ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Summary"]',
        description: 'Summary section header',
        waitForVisible: true
    })
    public summaryHeader!: CSWebElement;

    // ===================================================================
    // SETTINGS SECTION ELEMENTS (VIEW MODE)
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Settings"]',
        description: 'Settings section header',
        waitForVisible: true
    })
    public settingsHeader!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//strong[text()='Use Sketchmark Replacement']/parent::div/following-sibling::div[1]",
        description: 'Use Sketchmark Replacement value (view mode)',
        waitForVisible: true
    })
    public useSketchmarkReplacementValue!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//strong[text()='Output Ttcalc File']/ancestor::div[@class='flex'][1]/following-sibling::div[1]",
        description: 'Output Ttcalc File value (view mode)',
        waitForVisible: true
    })
    public outputTtcalcFileValue!: CSWebElement;

    // ===================================================================
    // SETTINGS SECTION ELEMENTS (EDIT MODE)
    // ===================================================================

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@role='checkbox' and @aria-label='Use Sketchmark Replacement']",
        description: 'Use Sketchmark Replacement checkbox (edit mode)',
        waitForVisible: true
    })
    public useSketchmarkReplacementCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@role='checkbox' and @aria-label='Output Ttcalc File']",
        description: 'Output Ttcalc File checkbox (edit mode)',
        waitForVisible: true
    })
    public outputTtcalcFileCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: "//button[@name='inductorType']",
        description: 'FFX File Inductor Type dropdown button',
        waitForEnabled: true
    })
    public ffxInductorTypeDropdown!: CSWebElement;

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES SECTION
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[text()="Associated Scattered Mmtes"]',
        description: 'Associated Scattered Mmtes section header',
        waitForVisible: true
    })
    public associatedScatteredMmtesHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[text()="No Scattered Mmte Associations Found."]',
        description: 'No Scattered Mmtes message',
        waitForVisible: true
    })
    public noScatteredMmtesMessage!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@class='sssss-button__label' and text()='Add / Remove']/parent::button",
        description: 'Add / Remove button',
        waitForEnabled: true
    })
    public addRemoveButton!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//span[@class='sssss-button__label' and text()='Reorder']/parent::button",
        description: 'Reorder button',
        waitForEnabled: true
    })
    public reorderButton!: CSWebElement;

    // ===================================================================
    // ACTION BUTTONS
    // ===================================================================

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//div[@class='button-bar-container']//span[text()='Save']/parent::button",
        description: 'Save button',
        waitForEnabled: true
    })
    public saveButton!: CSWebElement;

    @CSGetElement({
        xpath: "//form[@class='sssss-form']//div[@class='button-bar-container']//span[text()='Cancel']/parent::button",
        description: 'Cancel button',
        waitForEnabled: true
    })
    public cancelButton!: CSWebElement;

    // ===================================================================
    // MESSAGE ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: "//div[contains(@class, 'sssss-message-bar__messages')]",
        description: 'Message bar (success/error messages)',
        waitForVisible: true
    })
    public messageBar!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-feedback__messages']//li",
        description: 'Feedback message (pending approval alert)',
        waitForVisible: true
    })
    public feedbackMessage!: CSWebElement;

    @CSGetElement({
        xpath: "//span[@class='sssss-feedback__messages']//li//span[text()='View Changes']/parent::button",
        description: 'View Changes link in feedback',
        waitForVisible: true
    })
    public viewChangesLink!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFZealDetailsPage elements initialized');
    }

    // ===================================================================
    // PAGE VERIFICATION METHODS
    // ===================================================================

    public async verifyZealDetailsPageDisplayed(): Promise<void> {
        await this.zealDetailsHeader.waitForVisible(15000);
        const isVisible = await this.zealDetailsHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Zeal Details page is displayed');
        } else {
            throw new Error('Zeal Details page header not found');
        }
    }

    public async verifyEditZealPageDisplayed(): Promise<void> {
        await this.editZealHeader.waitForVisible(15000);
        const isVisible = await this.editZealHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Edit Zeal page is displayed');
        } else {
            throw new Error('Edit Zeal page header not found');
        }
    }

    public async isEditButtonEnabled(): Promise<boolean> {
        return await this.editButton.isEnabledWithTimeout(5000);
    }

    public async clickEditButton(): Promise<void> {
        await this.editButton.waitForVisible(10000);
        await this.editButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Edit button');
    }

    // ===================================================================
    // TAB METHODS
    // ===================================================================

    public async isDetailsTabSelected(): Promise<boolean> {
        const ariaSelected = await this.detailsTab.getAttributeWithTimeout('aria-selected', 5000);
        return ariaSelected === 'true';
    }

    public async isChangesTabSelected(): Promise<boolean> {
        const ariaSelected = await this.changesTab.getAttributeWithTimeout('aria-selected', 5000);
        return ariaSelected === 'true';
    }

    public async isHistoryTabSelected(): Promise<boolean> {
        const ariaSelected = await this.historyTab.getAttributeWithTimeout('aria-selected', 5000);
        return ariaSelected === 'true';
    }

    public async clickDetailsTab(): Promise<void> {
        await this.detailsTab.clickWithTimeout(10000);
        CSReporter.info('Clicked Details tab');
    }

    public async clickChangesTab(): Promise<void> {
        await this.changesTab.clickWithTimeout(10000);
        CSReporter.info('Clicked Changes tab');
    }

    public async clickHistoryTab(): Promise<void> {
        await this.historyTab.clickWithTimeout(10000);
        CSReporter.info('Clicked History tab');
    }

    public async isChangesTabPresent(): Promise<boolean> {
        return await this.changesTab.isVisibleWithTimeout(5000);
    }

    public async isHistoryTabPresent(): Promise<boolean> {
        return await this.historyTab.isVisibleWithTimeout(5000);
    }

    public async isReorderButtonVisible(): Promise<boolean> {
        const reorderButton = CSElementFactory.createByXPath(
            "//form[@class='sssss-form']//span[@class='sssss-button__label' and text()='Reorder']/parent::button",
            'Reorder button',
            this.page
        );
        return await reorderButton.isVisibleWithTimeout(5000);
    }

    public async clickOnPageBody(): Promise<void> {
        const bodyElement = CSElementFactory.createByXPath(
            "//body",
            'Page body',
            this.page
        );
        await bodyElement.clickWithTimeout(5000);
        CSReporter.info('Clicked on page body to dismiss message');
    }

    // ===================================================================
    // SUMMARY FIELD METHODS
    // ===================================================================

    public async getSummaryFieldValue(fieldName: string): Promise<string> {
        const fieldElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='${fieldName}']/following-sibling::div`,
            `Summary field: ${fieldName}`,
            this.page
        );
        const value = await fieldElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getAdministratorValue(): Promise<string> {
        const adminElement = CSElementFactory.createByXPath(
            `//div[@class='horizontal-list-item']/div[text()='Administrator']/following-sibling::div/span[@class='sssss-button__label']`,
            'Administrator field value',
            this.page
        );
        const value = await adminElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getZealId(): Promise<string> {
        return await this.getSummaryFieldValue('Zeal ID');
    }

    public async getZealKey(): Promise<string> {
        return await this.getSummaryFieldValue('Zeal Key');
    }

    public async getZealName(): Promise<string> {
        return await this.getSummaryFieldValue('Zeal Name');
    }

    public async getZzztSeggregation(): Promise<string> {
        return await this.getSummaryFieldValue('Zzzt Seggregation');
    }

    public async getPremisisDescription(): Promise<string> {
        return await this.getSummaryFieldValue('Premisis Description');
    }

    public async getInductorGroup(): Promise<string> {
        return await this.getSummaryFieldValue('Inductor Group');
    }

    public async getKindnessCircle(): Promise<string> {
        return await this.getSummaryFieldValue('Kindness Circle');
    }

    public async getTtcalcShool(): Promise<string> {
        return await this.getSummaryFieldValue('Ttcalc Shool');
    }

    // ===================================================================
    // SETTINGS METHODS (VIEW MODE)
    // ===================================================================

    public async getUseSketchmarkReplacementValue(): Promise<string> {
        const value = await this.useSketchmarkReplacementValue.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getOutputTtcalcFileValue(): Promise<string> {
        const value = await this.outputTtcalcFileValue.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getFileTypeValue(): Promise<string> {
        const fileTypeElement = CSElementFactory.createByXPath(
            "//strong[text()='File Type']/parent::div[1]",
            'File Type field',
            this.page
        );
        const text = await fileTypeElement.textContentWithTimeout(5000);
        // Remove the label "File Type" from the text
        return text?.replace('File Type', '').trim() || '';
    }

    public async getInductorValue(): Promise<string> {
        const inductorElement = CSElementFactory.createByXPath(
            "//strong[text()='Inductor']/parent::div[1]",
            'Inductor field',
            this.page
        );
        const text = await inductorElement.textContentWithTimeout(5000);
        // Remove the label "Inductor" from the text
        return text?.replace('Inductor', '').trim() || '';
    }

    // ===================================================================
    // SETTINGS METHODS (EDIT MODE)
    // ===================================================================

    public async isUseSketchmarkReplacementChecked(): Promise<boolean> {
        const ariaChecked = await this.useSketchmarkReplacementCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        return ariaChecked === 'true';
    }

    public async isUseSketchmarkReplacementEnabled(): Promise<boolean> {
        const ariaDisabled = await this.useSketchmarkReplacementCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'false';
    }

    public async checkUseSketchmarkReplacement(): Promise<void> {
        const isChecked = await this.isUseSketchmarkReplacementChecked();
        if (!isChecked) {
            await this.useSketchmarkReplacementCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Checked Use Sketchmark Replacement checkbox');
        } else {
            CSReporter.info('Use Sketchmark Replacement already checked');
        }
    }

    public async uncheckUseSketchmarkReplacement(): Promise<void> {
        const isChecked = await this.isUseSketchmarkReplacementChecked();
        if (isChecked) {
            await this.useSketchmarkReplacementCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Unchecked Use Sketchmark Replacement checkbox');
        } else {
            CSReporter.info('Use Sketchmark Replacement already unchecked');
        }
    }

    public async isOutputTtcalcFileChecked(): Promise<boolean> {
        const ariaChecked = await this.outputTtcalcFileCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        return ariaChecked === 'true';
    }

    public async isOutputTtcalcFileEnabled(): Promise<boolean> {
        const ariaDisabled = await this.outputTtcalcFileCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'false';
    }

    public async checkOutputTtcalcFile(): Promise<void> {
        const isChecked = await this.isOutputTtcalcFileChecked();
        if (!isChecked) {
            await this.outputTtcalcFileCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Checked Output Ttcalc File checkbox');
        } else {
            CSReporter.info('Output Ttcalc File already checked');
        }
    }

    public async uncheckOutputTtcalcFile(): Promise<void> {
        const isChecked = await this.isOutputTtcalcFileChecked();
        if (isChecked) {
            await this.outputTtcalcFileCheckbox.clickWithTimeout(5000);
            CSReporter.pass('Unchecked Output Ttcalc File checkbox');
        } else {
            CSReporter.info('Output Ttcalc File already unchecked');
        }
    }

    // ===================================================================
    // FFX INDUCTOR TYPE DROPDOWN METHODS
    // ===================================================================

    public async isFfxInductorTypeDropdownEnabled(): Promise<boolean> {
        return await this.ffxInductorTypeDropdown.isEnabledWithTimeout(5000);
    }

    public async clickFfxInductorTypeDropdown(): Promise<void> {
        await this.ffxInductorTypeDropdown.waitForVisible(10000);
        await this.ffxInductorTypeDropdown.clickWithTimeout(10000);
        CSReporter.info('Clicked FFX Inductor Type dropdown');
    }

    public async selectFfxInductorType(inductorType: string): Promise<void> {
        await this.clickFfxInductorTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']`,
            'FFX Inductor Type listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const option = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']//li[@role='option']//span[text()='${inductorType}']/ancestor::li[@role='option'][1]`,
            `FFX Inductor Type option: ${inductorType}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);
        // Wait for dropdown to close and UI to update after selection
        await this.page.waitForTimeout(500);
        CSReporter.pass(`Selected FFX Inductor Type: ${inductorType}`);
    }

    public async getSelectedFfxInductorType(): Promise<string> {
        const labelElement = CSElementFactory.createByXPath(
            `//button[@name='inductorType']//span[@class='sssss-button__label']`,
            'Selected FFX Inductor Type',
            this.page
        );
        const value = await labelElement.textContentWithTimeout(5000);
        return value?.trim() || '';
    }

    public async getFfxInductorTypeOptions(): Promise<string[]> {
        await this.clickFfxInductorTypeDropdown();

        const listbox = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']`,
            'FFX Inductor Type listbox',
            this.page
        );
        await listbox.waitForVisible(5000);

        const optionsElement = CSElementFactory.createByXPath(
            `//button[@name='inductorType']/ancestor::div[@class='sssss-select'][1]//ul[@role='listbox']//li[@role='option']//span`,
            'FFX Inductor Type options',
            this.page
        );
        const options = await optionsElement.allTextContents();

        // Close dropdown by clicking header
        await this.settingsHeader.clickWithTimeout(2000);
        return options.map(opt => opt.trim()).filter(opt => opt.length > 0);
    }

    // ===================================================================
    // ASSOCIATED SCATTERED MMTES METHODS
    // ===================================================================

    public async isNoScatteredMmtesMessageVisible(): Promise<boolean> {
        return await this.noScatteredMmtesMessage.isVisibleWithTimeout(3000);
    }

    public async clickAddRemoveButton(): Promise<void> {
        await this.addRemoveButton.waitForVisible(60000);
        await this.addRemoveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Add/Remove button');
    }

    public async isAddRemoveButtonVisible(): Promise<boolean> {
        return await this.addRemoveButton.isVisibleWithTimeout(60000);
    }

    public async clickReorderButton(): Promise<void> {
        await this.reorderButton.waitForVisible(10000);
        await this.reorderButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Reorder button');
    }

    /**
     * Verify Associated Scattered Mmtes table column headers
     * Source: Requirement Doc Circles 789-794
     * Columns: FFX Order, Scattered Mmte Name, Cumulative Mmte Name, Methodology Type, Disputed Scattered Mmte, Disputed Start Date
     */
    public async verifyAssociatedScatteredMmtesColumnHeaders(): Promise<void> {
        CSReporter.info('Verifying Associated Scattered Mmtes column headers');

        const expectedColumns = [
            'FFX Order',
            'Scattered Mmte Name',
            'Cumulative Mmte Name',
            'Methodology Type',
            'Disputed Scattered Mmte',
            'Disputed Start Date'
        ];
        const missingColumns: string[] = [];

        for (const columnName of expectedColumns) {
            const columnHeader = CSElementFactory.createByXPath(
                `//form[@class='sssss-form']//strong[text()='${columnName}']`,
                `Associated Scattered Mmtes column: ${columnName}`,
                this.page
            );

            if (await columnHeader.isVisibleWithTimeout(3000)) {
                CSReporter.info(`Column verified: ${columnName}`);
            } else {
                missingColumns.push(columnName);
            }
        }

        if (missingColumns.length > 0) {
            throw new Error(`Missing Associated Scattered Mmtes columns: ${missingColumns.join(', ')}`);
        }

        CSReporter.pass('All Associated Scattered Mmtes column headers verified');
    }

    public async getScatteredMmteRowCount(): Promise<number> {
        const rows = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')]`,
            'Scattered mmte rows',
            this.page
        );
        const count = await rows.count();
        // Subtract 1 for header row
        return Math.max(0, count - 1);
    }

    public async getScatteredMmteRowData(rowIndex: number): Promise<{
        ffxOrder: string;
        scatteredMmteName: string;
        cumulativeMmteName: string;
        methodologyType: string;
        disputedScatteredMmte: string;
        disputedStartDate: string;
    }> {
        const counter = rowIndex + 1; // 1-based for XPath

        const ffxOrderElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][1]`,
            `Row ${rowIndex} FFX Order`,
            this.page
        );
        const ffxOrder = (await ffxOrderElement.textContentWithTimeout(5000))?.trim() || '';

        const refMmteNameElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][2]//span[@class='sssss-button__label']`,
            `Row ${rowIndex} Scattered Mmte Name`,
            this.page
        );
        const scatteredMmteName = (await refMmteNameElement.textContentWithTimeout(5000))?.trim() || '';

        const extMmteNameElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][3]`,
            `Row ${rowIndex} Cumulative Mmte Name`,
            this.page
        );
        const cumulativeMmteName = (await extMmteNameElement.textContentWithTimeout(5000))?.trim() || '';

        const methodologyElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][4]`,
            `Row ${rowIndex} Methodology Type`,
            this.page
        );
        const methodologyType = (await methodologyElement.textContentWithTimeout(5000))?.trim() || '';

        let disputedScatteredMmte = '';
        try {
            const disputedRefMmteElement = CSElementFactory.createByXPath(
                `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][5]//span[@class='sssss-button__label']`,
                `Row ${rowIndex} Disputed Scattered Mmte`,
                this.page
            );
            if (await disputedRefMmteElement.isVisibleWithTimeout(2000)) {
                disputedScatteredMmte = (await disputedRefMmteElement.textContentWithTimeout(5000))?.trim() || '';
            }
        } catch {
            // No disputed scattered mmte configured for this row
        }

        let disputedStartDate = '';
        try {
            const disputedDateElement = CSElementFactory.createByXPath(
                `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class,'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][6]`,
                `Row ${rowIndex} Disputed Start Date`,
                this.page
            );
            if (await disputedDateElement.isVisibleWithTimeout(2000)) {
                disputedStartDate = (await disputedDateElement.textContentWithTimeout(5000))?.trim() || '';
            }
        } catch {
            // No disputed start date configured for this row
        }

        return {
            ffxOrder,
            scatteredMmteName,
            cumulativeMmteName,
            methodologyType,
            disputedScatteredMmte,
            disputedStartDate
        };
    }

    /**
     * Get Disputed Scattered Mmte value for a specific row in Associated Scattered Mmtes section
     * @param rowIndex - 0-based row index
     * @returns The disputed scattered mmte name or empty string if not set
     */
    public async getDisputedScatteredMmteValue(rowIndex: number): Promise<string> {
        try {
            const counter = rowIndex + 1;
            const disputedRefMmteElement = CSElementFactory.createByXPath(
                `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][5]//span[@class='sssss-button__label']`,
                `Row ${rowIndex} Disputed Scattered Mmte`,
                this.page
            );
            if (await disputedRefMmteElement.isVisibleWithTimeout(3000)) {
                const value = await disputedRefMmteElement.textContentWithTimeout(5000);
                return value?.trim() || '';
            }
            return '';
        } catch {
            CSReporter.info(`No disputed scattered mmte element found for row ${rowIndex}`);
            return '';
        }
    }

    /**
     * Get Disputed Start Date value for a specific row in Associated Scattered Mmtes section
     * @param rowIndex - 0-based row index
     * @returns The disputed start date or empty string if not set
     */
    public async getDisputedStartDateValue(rowIndex: number): Promise<string> {
        try {
            const counter = rowIndex + 1;
            const disputedDateElement = CSElementFactory.createByXPath(
                `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class,'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][6]`,
                `Row ${rowIndex} Disputed Start Date`,
                this.page
            );
            if (await disputedDateElement.isVisibleWithTimeout(3000)) {
                const value = await disputedDateElement.textContentWithTimeout(5000);
                return value?.trim() || '';
            }
            return '';
        } catch {
            CSReporter.info(`No disputed start date element found for row ${rowIndex}`);
            return '';
        }
    }

    public async clickDisputedSelectButton(rowIndex: number): Promise<void> {
        const counter = rowIndex + 1;
        const selectButton = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][5]//span[text()='Select']/parent::button`,
            `Row ${rowIndex} Disputed Select button`,
            this.page
        );
        await selectButton.waitForVisible(10000);
        await selectButton.clickWithTimeout(10000);
        CSReporter.info(`Clicked Disputed Select button for row ${rowIndex}`);
    }

    public async enterDisputedStartDate(rowIndex: number, date: string): Promise<void> {
        const counter = rowIndex + 1;
        const dateInput = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//h2[text()='Associated Scattered Mmtes']/following-sibling::div[contains(@class, 'sssss-row--padding')][${counter + 1}]/div[contains(@class,'sssss-col')][6]//div[@class='sssss-field__content-button-wrapper']/input`,
            `Row ${rowIndex} Disputed Start Date input`,
            this.page
        );
        await dateInput.waitForVisible(10000);
        await dateInput.clearWithTimeout(5000);
        await dateInput.fillWithTimeout(date, 5000);
        CSReporter.pass(`Entered Disputed Start Date: ${date} for row ${rowIndex}`);
    }

    // ===================================================================
    // ACTION BUTTON METHODS
    // ===================================================================

    public async isSaveButtonEnabled(): Promise<boolean> {
        return await this.saveButton.isEnabledWithTimeout(5000);
    }

    public async clickSaveButton(): Promise<void> {
        await this.saveButton.waitForVisible(10000);
        await this.saveButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Save button');
        await this.waitForPageLoad();
    }

    public async isCancelButtonEnabled(): Promise<boolean> {
        return await this.cancelButton.isEnabledWithTimeout(5000);
    }

    public async clickCancelButton(): Promise<void> {
        await this.cancelButton.waitForVisible(10000);
        await this.cancelButton.clickWithTimeout(10000);
        CSReporter.info('Clicked Cancel button');
    }

    // ===================================================================
    // MESSAGE METHODS
    // ===================================================================

    public async getMessageBarText(): Promise<string> {
        await this.messageBar.waitForVisible(10000);
        const text = await this.messageBar.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async getFeedbackMessageText(): Promise<string> {
        await this.feedbackMessage.waitForVisible(10000);
        const text = await this.feedbackMessage.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async clickViewChangesLink(): Promise<void> {
        await this.viewChangesLink.waitForVisible(10000);
        await this.viewChangesLink.clickWithTimeout(10000);
        CSReporter.info('Clicked View Changes link');
    }

    public async isViewChangesLinkVisible(): Promise<boolean> {
        return await this.viewChangesLink.isVisibleWithTimeout(5000);
    }

    // ===================================================================
    // PREMISIS-SPECIFIC METHODS
    // ===================================================================

    public async verifyPremisisDetailsPageDisplayed(): Promise<void> {
        const premisisHeader = CSElementFactory.createByXPath(
            '//h1[text()="Premisis Details"]',
            'Premisis Details page header',
            this.page
        );
        await premisisHeader.waitForVisible(15000);
        const isVisible = await premisisHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Premisis Details page is displayed');
        } else {
            throw new Error('Premisis Details page header not found');
        }
    }

    public async verifyEditPremisisPageDisplayed(): Promise<void> {
        const editPremisisHeader = CSElementFactory.createByXPath(
            '//h1[text()="Edit Premisis"]',
            'Edit Premisis page header',
            this.page
        );
        await editPremisisHeader.waitForVisible(15000);
        const isVisible = await editPremisisHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Edit Premisis page is displayed');
        } else {
            throw new Error('Edit Premisis page header not found');
        }
    }

    public async isOutputTtcalcFileCheckboxDisabled(): Promise<boolean> {
        const ariaDisabled = await this.outputTtcalcFileCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'true';
    }

    public async isFfxInductorTypeDropdownDisabled(): Promise<boolean> {
        const isEnabled = await this.ffxInductorTypeDropdown.isEnabledWithTimeout(5000);
        return !isEnabled;
    }

    // ===================================================================
    // WARNING POPUP METHODS (SCENARIO_08)
    // ===================================================================

    public async verifyWarningPopupDisplayed(): Promise<void> {
        const warningHeader = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//h5[text()='Warning']",
            'Warning popup header',
            this.page
        );
        await warningHeader.waitForVisible(10000);
        const isVisible = await warningHeader.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.pass('Warning popup is displayed');
        } else {
            throw new Error('Warning popup not found');
        }
    }

    public async getWarningPopupMessage(): Promise<string> {
        const messageElement = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//div[contains(@class,'sssss-message-box__text')]",
            'Warning popup message',
            this.page
        );
        const text = await messageElement.textContentWithTimeout(5000);
        return text?.trim() || '';
    }

    public async isWarningPopupOkButtonVisible(): Promise<boolean> {
        const okButton = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//div[@class='sssss-panel__footer']//span[text()='OK']/parent::button",
            'Warning popup OK button',
            this.page
        );
        return await okButton.isVisibleWithTimeout(5000);
    }

    public async clickWarningPopupOkButton(): Promise<void> {
        const okButton = CSElementFactory.createByXPath(
            "//div[@id='sssss-modal-portal']//div[@class='sssss-panel__footer']//span[text()='OK']/parent::button",
            'Warning popup OK button',
            this.page
        );
        await okButton.waitForVisible(10000);
        await okButton.clickWithTimeout(10000);
        CSReporter.info('Clicked OK button in Warning popup');
        await this.waitForPageLoad();
    }
}

export default TTTFZealDetailsPage;
