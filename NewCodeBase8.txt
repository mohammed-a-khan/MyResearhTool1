CSPageFactory.ts
---------------------------

import { WebDriver, WebElement } from 'selenium-webdriver';
import { CSBasePage } from './CSBasePage';
import { CSLocatorProcessor } from '../annotations/CSLocatorProcessor';
import { CSLogger } from '../../core/utils/CSLogger';
import { InitializationException } from '../../core/exceptions/InitializationException';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';

/**
 * Factory class for creating and initializing page objects.
 * Automatically processes @CSFindBy annotations.
 */
export class CSPageFactory {
    /**
     * Cache of initialized page objects.
     */
    private static pageCache = new Map<string, CSBasePage>();
    
    /**
     * Mapping of page class to WebDriver instance.
     */
    private static driverMap = new Map<any, WebDriver>();
    
    /**
     * Default timeout for element lookups.
     */
    private static defaultTimeout: number = 10000;
    
    /**
     * Whether to enable caching of page objects.
     */
    private static cachingEnabled: boolean = true;
    
    /**
     * Creates and initializes a page object.
     * 
     * @param pageClass The page class constructor
     * @param driver The WebDriver instance
     * @param args Optional arguments for the page constructor
     * @returns Promise resolving to the initialized page object
     * @throws InitializationException if initialization fails
     */
    public static async initElements<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        driver: WebDriver,
        ...args: any[]
    ): Promise<T> {
        try {
            // Check if caching is enabled and if the page is already cached
            if (this.cachingEnabled) {
                const cacheKey = this.getCacheKey(pageClass, args);
                
                if (this.pageCache.has(cacheKey)) {
                    const cachedPage = this.pageCache.get(cacheKey) as T;
                    
                    // Update the driver if it's different
                    if (cachedPage.getDriver() !== driver) {
                        cachedPage['driver'] = driver;
                    }
                    
                    return cachedPage;
                }
            }
            
            // Create a new instance of the page class
            const page = new pageClass(driver, ...args);
            
            // Store the driver for this page class
            this.driverMap.set(pageClass, driver);
            
            // Get the page name
            const pageName = pageClass.name;
            
            CSLogger.debug(`Initializing page object: ${pageName}`);
            
            // Process @CSFindBy annotations
            const processor = new CSLocatorProcessor(driver);
            processor.setDefaultTimeout(this.defaultTimeout);
            
            // Initialize the page object
            const initializedPage = await processor.initializePageObject(page);
            
            // Cache the page object if caching is enabled
            if (this.cachingEnabled) {
                const cacheKey = this.getCacheKey(pageClass, args);
                this.pageCache.set(cacheKey, initializedPage);
                CSLogger.debug(`Page object cached: ${pageName}`);
            }
            
            return initializedPage;
        } catch (error) {
            throw new InitializationException(
                `Failed to initialize page object: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Creates and initializes a page component.
     * 
     * @param componentClass The component class constructor
     * @param driver The WebDriver instance
     * @param rootElement The root element for the component
     * @param args Optional arguments for the component constructor
     * @returns Promise resolving to the initialized component
     * @throws InitializationException if initialization fails
     */
    public static async initComponent<T extends CSBasePage>(
        componentClass: new (driver: WebDriver, rootElement: WebElement, ...args: any[]) => T,
        driver: WebDriver,
        rootElement: WebElement,
        ...args: any[]
    ): Promise<T> {
        try {
            // Create a new instance of the component class
            const component = new componentClass(driver, rootElement, ...args);
            
            // Get the component name
            const componentName = componentClass.name;
            
            CSLogger.debug(`Initializing component: ${componentName}`);
            
            // Process @CSFindBy annotations
            const processor = new CSLocatorProcessor(driver);
            processor.setDefaultTimeout(this.defaultTimeout);
            processor.setRootElement(rootElement);
            
            // Initialize the component
            const initializedComponent = await processor.initializePageObject(component);
            
            return initializedComponent;
        } catch (error) {
            throw new InitializationException(
                `Failed to initialize component: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Creates and initializes a page component using a locator.
     * 
     * @param componentClass The component class constructor
     * @param driver The WebDriver instance
     * @param locator The locator for the root element
     * @param args Optional arguments for the component constructor
     * @returns Promise resolving to the initialized component
     * @throws InitializationException if initialization fails
     */
    public static async initComponentWithLocator<T extends CSBasePage>(
        componentClass: new (driver: WebDriver, rootElement: WebElement, ...args: any[]) => T,
        driver: WebDriver,
        locator: any,
        ...args: any[]
    ): Promise<T> {
        try {
            // Find the root element
            const rootElement = await driver.findElement(locator);
            
            // Initialize the component
            return await this.initComponent(componentClass, driver, rootElement, ...args);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new InitializationException(
                `Failed to initialize component with locator: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Opens a page and initializes it.
     * 
     * @param pageClass The page class constructor
     * @param driver The WebDriver instance
     * @param args Optional arguments for the page constructor
     * @returns Promise resolving to the initialized page object
     * @throws InitializationException if initialization fails
     */
    public static async openPage<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        driver: WebDriver,
        ...args: any[]
    ): Promise<T> {
        try {
            // Initialize the page object
            const page = await this.initElements(pageClass, driver, ...args);
            
            // Open the page
            await page.open();
            
            return page;
        } catch (error) {
            throw new InitializationException(
                `Failed to open page: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Creates a page object using its parent page.
     * 
     * @param pageClass The page class constructor
     * @param parentPage The parent page object
     * @param args Optional arguments for the page constructor
     * @returns Promise resolving to the initialized page object
     * @throws InitializationException if initialization fails
     */
    public static async createPageFromParent<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        parentPage: CSBasePage,
        ...args: any[]
    ): Promise<T> {
        // Get the driver from the parent page
        const driver = parentPage.getDriver();
        
        // Initialize the page object
        const page = await this.initElements(pageClass, driver, ...args);
        
        // Set the parent page
        page.setParentPage(parentPage);
        
        return page;
    }
    
    /**
     * Gets a page object from the cache.
     * 
     * @param pageClass The page class constructor
     * @param args Optional arguments that were used to create the page
     * @returns The cached page object or null if not found
     */
    public static getFromCache<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        ...args: any[]
    ): T | null {
        if (!this.cachingEnabled) {
            return null;
        }
        
        const cacheKey = this.getCacheKey(pageClass, args);
        const cachedPage = this.pageCache.get(cacheKey) as T;
        
        return cachedPage || null;
    }
    
    /**
     * Removes a page object from the cache.
     * 
     * @param pageClass The page class constructor
     * @param args Optional arguments that were used to create the page
     * @returns Whether the page was removed
     */
    public static removeFromCache<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        ...args: any[]
    ): boolean {
        const cacheKey = this.getCacheKey(pageClass, args);
        return this.pageCache.delete(cacheKey);
    }
    
    /**
     * Clears the page cache.
     */
    public static clearCache(): void {
        CSLogger.debug(`Clearing page object cache. ${this.pageCache.size} entries will be removed.`);
        this.pageCache.clear();
    }

    /**
     * Sets the default timeout for element lookups.
     * 
     * @param timeout The timeout in milliseconds
     */
    public static setDefaultTimeout(timeout: number): void {
        if (timeout <= 0) {
            throw new Error('Timeout must be a positive number');
        }
        
        CSLogger.debug(`Setting default element lookup timeout to ${timeout}ms`);
        this.defaultTimeout = timeout;
    }

    /**
     * Gets the default timeout for element lookups.
     * 
     * @returns The default timeout in milliseconds
     */
    public static getDefaultTimeout(): number {
        return this.defaultTimeout;
    }

    /**
     * Enables or disables page object caching.
     * 
     * @param enabled Whether to enable caching
     */
    public static setCachingEnabled(enabled: boolean): void {
        CSLogger.debug(`${enabled ? 'Enabling' : 'Disabling'} page object caching`);
        this.cachingEnabled = enabled;
        
        // Clear the cache if disabling
        if (!enabled) {
            this.clearCache();
        }
    }

    /**
     * Gets whether page object caching is enabled.
     * 
     * @returns Whether caching is enabled
     */
    public static isCachingEnabled(): boolean {
        return this.cachingEnabled;
    }

    /**
     * Refreshes a page object by reinitializing its elements.
     * 
     * @param page The page object to refresh
     * @returns Promise resolving to the refreshed page object
     * @throws InitializationException if refreshing fails
     */
    public static async refreshPage<T extends CSBasePage>(page: T): Promise<T> {
        try {
            const driver = page.getDriver();
            const pageClass = page.constructor as new (driver: WebDriver, ...args: any[]) => T;
            
            // Remove from cache if present
            const cacheKey = this.getCacheKey(pageClass, []);
            this.pageCache.delete(cacheKey);
            
            // Process @CSFindBy annotations again
            const processor = new CSLocatorProcessor(driver);
            processor.setDefaultTimeout(this.defaultTimeout);
            
            // Reinitialize the page object
            const refreshedPage = await processor.initializePageObject(page);
            
            // Update cache if caching is enabled
            if (this.cachingEnabled) {
                this.pageCache.set(cacheKey, refreshedPage);
            }
            
            CSLogger.debug(`Refreshed page object: ${pageClass.name}`);
            
            return refreshedPage;
        } catch (error) {
            throw new InitializationException(
                `Failed to refresh page object: ${error.message}`,
                error
            );
        }
    }

    /**
     * Refreshes all page objects in the cache.
     * 
     * @returns Promise resolving when all pages have been refreshed
     * @throws InitializationException if refreshing any page fails
     */
    public static async refreshAllPages(): Promise<void> {
        if (!this.cachingEnabled || this.pageCache.size === 0) {
            return;
        }
        
        try {
            const refreshPromises: Promise<CSBasePage>[] = [];
            
            // Create a copy of the cache entries to avoid modification during iteration
            const pageEntries = Array.from(this.pageCache.entries());
            
            for (const [cacheKey, page] of pageEntries) {
                refreshPromises.push(this.refreshPage(page));
            }
            
            await Promise.all(refreshPromises);
            
            CSLogger.debug(`Refreshed ${refreshPromises.length} page objects`);
        } catch (error) {
            throw new InitializationException(
                `Failed to refresh all page objects: ${error.message}`,
                error
            );
        }
    }

    /**
     * Validates a page object's structure.
     * 
     * @param pageClass The page class to validate
     * @returns Promise resolving to validation results
     */
    public static async validatePageStructure<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T
    ): Promise<{isValid: boolean, issues: string[]}> {
        const issues: string[] = [];
        
        try {
            // Get a driver for validation
            let driver: WebDriver | undefined;
            
            // Try to get a driver from the driver map
            for (const [cls, drv] of this.driverMap.entries()) {
                driver = drv;
                break;
            }
            
            if (!driver) {
                issues.push('Cannot validate page structure: No WebDriver instance available');
                return { isValid: false, issues };
            }
            
            // Create a temporary instance
            const tempPage = new pageClass(driver);
            
            // Use reflection to validate the page structure
            const processor = new CSLocatorProcessor(driver);
            const validationResult = await processor.validatePageObject(tempPage);
            
            return validationResult;
        } catch (error) {
            issues.push(`Validation error: ${error.message}`);
            return { isValid: false, issues };
        }
    }

    /**
     * Creates a unique cache key for a page class and arguments.
     * 
     * @param pageClass The page class constructor
     * @param args Arguments used for page creation
     * @returns A unique cache key
     */
    private static getCacheKey<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        args: any[]
    ): string {
        // Use class name as the base key
        const baseKey = pageClass.name;
        
        // If no args, just return the class name
        if (!args || args.length === 0) {
            return baseKey;
        }
        
        // Otherwise, append a hash of the arguments
        const argsHash = this.hashArgs(args);
        return `${baseKey}_${argsHash}`;
    }

    /**
     * Creates a simple hash of arguments for cache keys.
     * 
     * @param args The arguments to hash
     * @returns A string hash of the arguments
     */
    private static hashArgs(args: any[]): string {
        if (!args || args.length === 0) {
            return '0';
        }
        
        try {
            // Convert args to JSON and calculate a hash
            const argsJson = JSON.stringify(args, (key, value) => {
                // Handle circular references and functions
                if (typeof value === 'function') {
                    return value.toString();
                }
                if (typeof value === 'object' && value !== null) {
                    if (value instanceof WebElement) {
                        return 'WebElement';
                    }
                    if (value instanceof WebDriver) {
                        return 'WebDriver';
                    }
                }
                return value;
            });
            
            // Simple hash function
            let hash = 0;
            for (let i = 0; i < argsJson.length; i++) {
                const char = argsJson.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            
            return hash.toString(16);
        } catch (error) {
            // Fallback for unhashable args
            return Date.now().toString(16);
        }
    }

    /**
     * Checks if a page object is correctly initialized.
     * 
     * @param page The page object to check
     * @returns Whether the page object is properly initialized
     */
    public static isPageInitialized(page: CSBasePage): boolean {
        if (!page) {
            return false;
        }
        
        try {
            // Check if the driver is available
            const driver = page.getDriver();
            if (!driver) {
                return false;
            }
            
            // Check if the page has a URL (optional)
            try {
                const url = page.getUrl();
                // URL may be undefined for component pages, that's fine
            } catch (error) {
                // Ignore errors here, not all pages have URLs
            }
            
            return true;
        } catch (error) {
            return false;
        }
    }

    /**
     * Gets the WebDriver associated with a page class.
     * 
     * @param pageClass The page class
     * @returns The WebDriver instance or undefined if not found
     */
    public static getDriverForPageClass(pageClass: any): WebDriver | undefined {
        return this.driverMap.get(pageClass);
    }

    /**
     * Sets a WebDriver for a page class without initializing a page.
     * 
     * @param pageClass The page class
     * @param driver The WebDriver instance
     */
    public static setDriverForPageClass(pageClass: any, driver: WebDriver): void {
        this.driverMap.set(pageClass, driver);
    }

    /**
     * Registers an already initialized page in the cache.
     * 
     * @param page The page object to register
     * @returns The registered page
     */
    public static registerPage<T extends CSBasePage>(page: T): T {
        if (!this.cachingEnabled) {
            return page;
        }
        
        try {
            const pageClass = page.constructor as new (driver: WebDriver, ...args: any[]) => T;
            const cacheKey = this.getCacheKey(pageClass, []);
            
            this.pageCache.set(cacheKey, page);
            CSLogger.debug(`Registered page object in cache: ${pageClass.name}`);
            
            return page;
        } catch (error) {
            CSLogger.warn(`Failed to register page object in cache: ${error.message}`);
            return page;
        }
    }

    /**
     * Lists all page objects in the cache.
     * 
     * @returns Array of page class names and counts
     */
    public static getCacheStatus(): Array<{className: string, count: number}> {
        const result: {[key: string]: number} = {};
        
        for (const [key, page] of this.pageCache.entries()) {
            const className = page.constructor.name;
            
            if (!result[className]) {
                result[className] = 0;
            }
            
            result[className]++;
        }
        
        return Object.entries(result).map(([className, count]) => ({
            className,
            count
        }));
    }

    /**
     * Handles WebDriver session termination by cleaning up page objects.
     * 
     * @param driver The WebDriver instance that is being terminated
     */
    public static handleSessionTermination(driver: WebDriver): void {
        try {
            // Find and remove cached pages using this driver
            for (const [key, page] of this.pageCache.entries()) {
                if (page.getDriver() === driver) {
                    this.pageCache.delete(key);
                }
            }
            
            // Remove driver from driver map
            for (const [cls, drv] of this.driverMap.entries()) {
                if (drv === driver) {
                    this.driverMap.delete(cls);
                }
            }
            
            CSLogger.debug('Cleaned up page objects for terminated WebDriver session');
        } catch (error) {
            CSLogger.warn(`Error during session termination cleanup: ${error.message}`);
        }
    }
}



CSBaseStepDef.ts
----------------------------

import { WebDriver, WebElement, By, until } from 'selenium-webdriver';
import { CSBasePage } from './CSBasePage';
import { CSPageFactory } from './CSPageFactory';
import { CSWaitStrategy } from '../wait/CSWaitStrategy';
import { CSVisibilityWait } from '../wait/CSVisibilityWait';
import { CSClickableWait } from '../wait/CSClickableWait';
import { CSPresenceWait } from '../wait/CSPresenceWait';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';
import { CSConstants } from '../../core/utils/CSConstants';
import { CSTestForgeDataProviderProcessor } from '../../core/data/CSDataProviderProcessor';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { StepExecutionException } from '../../core/exceptions/StepExecutionException';
import { CSReporter } from '../../core/reporting/CSReporter';
import { CSTestStatus } from '../../core/reporting/CSTestStatus';
import { ConfigurationManager } from '../../core/config/ConfigurationManager';

/**
 * Base class for BDD step definitions providing common functionality.
 * This class integrates Selenium WebDriver with Cucumber step definitions.
 */
export abstract class CSBaseStepDef {
    /**
     * The WebDriver instance.
     */
    protected driver: WebDriver;

    /**
     * The reporter instance for test reporting.
     */
    protected reporter: CSReporter;

    /**
     * Map of currently initialized pages.
     */
    protected pages: Map<string, CSBasePage> = new Map<string, CSBasePage>();

    /**
     * Current scenario context for sharing data between steps.
     */
    protected scenarioContext: Map<string, any> = new Map<string, any>();

    /**
     * Default wait timeout in milliseconds.
     */
    protected waitTimeout: number = 30000;

    /**
     * Default polling interval in milliseconds.
     */
    protected pollingInterval: number = 500;

    /**
     * Whether to take screenshots on step failure.
     */
    protected screenshotOnFailure: boolean = true;

    /**
     * Whether to take screenshots for each step.
     */
    protected screenshotOnEachStep: boolean = false;

    /**
     * Default timeout when searching for elements.
     */
    protected elementSearchTimeout: number = 10000;

    /**
     * The screenshot manager instance.
     */
    protected screenshotManager: CSScreenshotManager;

    /**
     * Data provider processor.
     */
    protected dataProviderProcessor: CSTestForgeDataProviderProcessor;

    /**
     * Creates a new CSBaseStepDef instance.
     * 
     * @param driver The WebDriver instance
     * @param reporter The reporter instance (optional)
     */
    constructor(driver: WebDriver, reporter?: CSReporter) {
        this.driver = driver;
        this.reporter = reporter || CSReporter.getInstance();
        this.screenshotManager = new CSScreenshotManager(driver);
        this.dataProviderProcessor = new CSTestForgeDataProviderProcessor();
        this.initializeConfiguration();
    }

    /**
     * Initializes configuration settings from the configuration manager.
     */
    protected initializeConfiguration(): void {
        const config = ConfigurationManager.getInstance();
        
        this.waitTimeout = config.getNumber('selenium.wait.timeout', this.waitTimeout);
        this.pollingInterval = config.getNumber('selenium.wait.pollingInterval', this.pollingInterval);
        this.screenshotOnFailure = config.getBoolean('selenium.screenshot.onFailure', this.screenshotOnFailure);
        this.screenshotOnEachStep = config.getBoolean('selenium.screenshot.onEachStep', this.screenshotOnEachStep);
        this.elementSearchTimeout = config.getNumber('selenium.element.searchTimeout', this.elementSearchTimeout);
        
        CSLogger.debug(`CSBaseStepDef configured with waitTimeout=${this.waitTimeout}ms, ` +
            `pollingInterval=${this.pollingInterval}ms, screenshotOnFailure=${this.screenshotOnFailure}, ` +
            `screenshotOnEachStep=${this.screenshotOnEachStep}, elementSearchTimeout=${this.elementSearchTimeout}ms`);
    }

    /**
     * Gets the WebDriver instance.
     * 
     * @returns The WebDriver instance
     */
    public getDriver(): WebDriver {
        return this.driver;
    }

    /**
     * Sets the WebDriver instance.
     * 
     * @param driver The WebDriver instance
     */
    public setDriver(driver: WebDriver): void {
        this.driver = driver;
    }

    /**
     * Gets the reporter instance.
     * 
     * @returns The reporter instance
     */
    public getReporter(): CSReporter {
        return this.reporter;
    }

    /**
     * Sets the reporter instance.
     * 
     * @param reporter The reporter instance
     */
    public setReporter(reporter: CSReporter): void {
        this.reporter = reporter;
    }

    /**
     * Initializes a page object.
     * 
     * @param pageClass The page class to initialize
     * @param args Optional arguments for the page constructor
     * @returns Promise resolving to the initialized page object
     */
    public async initPage<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        ...args: any[]
    ): Promise<T> {
        try {
            const page = await CSPageFactory.initElements(pageClass, this.driver, ...args);
            
            // Store in the pages map
            this.pages.set(pageClass.name, page);
            
            return page;
        } catch (error) {
            this.reportStepFailure('Failed to initialize page', error);
            throw new StepExecutionException(`Failed to initialize page ${pageClass.name}`, error);
        }
    }

    /**
     * Gets a page from the pages map or initializes it if not present.
     * 
     * @param pageClass The page class to get
     * @param args Optional arguments for the page constructor
     * @returns Promise resolving to the page object
     */
    public async getPage<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        ...args: any[]
    ): Promise<T> {
        const pageName = pageClass.name;
        
        if (this.pages.has(pageName)) {
            return this.pages.get(pageName) as T;
        }
        
        return this.initPage(pageClass, ...args);
    }

    /**
     * Opens a page and initializes it.
     * 
     * @param pageClass The page class to open
     * @param args Optional arguments for the page constructor
     * @returns Promise resolving to the initialized page object
     */
    public async openPage<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        ...args: any[]
    ): Promise<T> {
        try {
            this.reportStepInfo(`Opening page ${pageClass.name}`);
            
            const page = await CSPageFactory.openPage(pageClass, this.driver, ...args);
            
            // Store in the pages map
            this.pages.set(pageClass.name, page);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`Page_${pageClass.name}_Opened`);
            }
            
            return page;
        } catch (error) {
            this.reportStepFailure('Failed to open page', error);
            throw new StepExecutionException(`Failed to open page ${pageClass.name}`, error);
        }
    }

    /**
     * Creates a wait strategy.
     * 
     * @param strategy The wait strategy type
     * @param timeout Optional timeout in milliseconds
     * @param pollingInterval Optional polling interval in milliseconds
     * @returns The wait strategy
     */
    public createWaitStrategy(
        strategy: 'visible' | 'clickable' | 'present',
        timeout?: number,
        pollingInterval?: number
    ): CSWaitStrategy {
        timeout = timeout || this.waitTimeout;
        pollingInterval = pollingInterval || this.pollingInterval;
        
        switch (strategy) {
            case 'visible':
                return new CSVisibilityWait(this.driver, timeout, pollingInterval);
            case 'clickable':
                return new CSClickableWait(this.driver, timeout, pollingInterval);
            case 'present':
                return new CSPresenceWait(this.driver, timeout, pollingInterval);
            default:
                return new CSVisibilityWait(this.driver, timeout, pollingInterval);
        }
    }

    /**
     * Waits for an element to meet a condition.
     * 
     * @param locator The element locator
     * @param strategy The wait strategy
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving to the element
     */
    public async waitForElement(
        locator: By,
        strategy: 'visible' | 'clickable' | 'present' = 'visible',
        timeout?: number
    ): Promise<WebElement> {
        try {
            const waitStrategy = this.createWaitStrategy(strategy, timeout);
            return await waitStrategy.waitForElement(locator);
        } catch (error) {
            this.reportStepFailure(`Failed to wait for element with strategy ${strategy}`, error);
            throw new ElementNotFoundException(`Failed to wait for element with strategy ${strategy}: ${error.message}`, error);
        }
    }

    /**
     * Sets a value in the scenario context.
     * 
     * @param key The key
     * @param value The value
     */
    public setContext(key: string, value: any): void {
        this.scenarioContext.set(key, value);
    }

    /**
     * Gets a value from the scenario context.
     * 
     * @param key The key
     * @returns The value
     */
    public getContext<T>(key: string): T | undefined {
        return this.scenarioContext.get(key) as T;
    }

    /**
     * Gets a required value from the scenario context. Throws an error if not found.
     * 
     * @param key The key
     * @returns The value
     * @throws Error if the value is not found
     */
    public getRequiredContext<T>(key: string): T {
        const value = this.getContext<T>(key);
        
        if (value === undefined) {
            throw new Error(`Required context value not found for key: ${key}`);
        }
        
        return value;
    }

    /**
     * Clears the scenario context.
     */
    public clearContext(): void {
        this.scenarioContext.clear();
    }

    /**
     * Takes a screenshot.
     * 
     * @param name The screenshot name
     * @returns Promise resolving to the screenshot path
     */
    public async takeScreenshot(name: string): Promise<string> {
        try {
            const screenshotPath = await this.screenshotManager.takeScreenshot(name);
            this.reporter.addScreenshot(screenshotPath);
            return screenshotPath;
        } catch (error) {
            CSLogger.warn(`Failed to take screenshot: ${error.message}`);
            return '';
        }
    }

    /**
     * Reports step information.
     * 
     * @param message The message
     * @param details Optional details
     */
    public reportStepInfo(message: string, details?: any): void {
        this.reporter.logStep(message, CSTestStatus.PASS, details);
        CSLogger.info(message);
    }

    /**
     * Reports step failure.
     * 
     * @param message The message
     * @param error Optional error
     */
    public async reportStepFailure(message: string, error?: any): Promise<void> {
        const errorMessage = error ? `${message}: ${error.message}` : message;
        
        this.reporter.logStep(errorMessage, CSTestStatus.FAIL, error);
        CSLogger.error(errorMessage);
        
        if (this.screenshotOnFailure) {
            await this.takeScreenshot(`StepFailure_${Date.now()}`);
        }
    }

    /**
     * Reports step warning.
     * 
     * @param message The message
     * @param details Optional details
     */
    public reportStepWarning(message: string, details?: any): void {
        this.reporter.logStep(message, CSTestStatus.WARNING, details);
        CSLogger.warn(message);
    }

    /**
     * Executes a function and reports any errors.
     * 
     * @param stepDescription The step description
     * @param action The function to execute
     * @returns Promise resolving to the function result
     */
    public async executeStep<T>(stepDescription: string, action: () => Promise<T>): Promise<T> {
        try {
            this.reportStepInfo(`Step: ${stepDescription}`);
            
            const result = await action();
            
            if (this.screenshotOnEachStep) {
                const screenshotName = stepDescription
                    .replace(/[^a-z0-9]/gi, '_')
                    .replace(/_+/g, '_')
                    .substring(0, 50);
                
                await this.takeScreenshot(`Step_${screenshotName}`);
            }
            
            return result;
        } catch (error) {
            await this.reportStepFailure(`Step failed: ${stepDescription}`, error);
            throw new StepExecutionException(`Step failed: ${stepDescription}`, error);
        }
    }

    /**
     * Processes data from a data provider.
     * 
     * @param dataKey The data key
     * @param parameters Parameters for data transformation
     * @returns Promise resolving to the processed data
     */
    public async getDataFromProvider(dataKey: string, parameters?: any): Promise<any> {
        try {
            return await this.dataProviderProcessor.processData(dataKey, parameters);
        } catch (error) {
            this.reportStepFailure(`Failed to get data from provider: ${dataKey}`, error);
            throw new StepExecutionException(`Failed to get data from provider: ${dataKey}`, error);
        }
    }

    /**
     * Performs cleanup after scenario execution.
     */
    public async afterScenario(): Promise<void> {
        try {
            // Clear the pages map
            this.pages.clear();
            
            // Clear the scenario context
            this.clearContext();
            
            // Take a final screenshot if configured
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot('ScenarioEnd');
            }
            
            CSLogger.debug('Scenario cleanup completed');
        } catch (error) {
            CSLogger.warn(`Error during scenario cleanup: ${error.message}`);
        }
    }

    /**
     * Gets a data table from a string.
     * Useful for transforming Cucumber data tables.
     * 
     * @param dataTable The data table string
     * @returns Parsed data table as array of arrays
     */
    public parseDataTable(dataTable: string): Array<Array<string>> {
        try {
            return dataTable
                .trim()
                .split('\n')
                .map(row => row.trim().split('|').map(cell => cell.trim()).filter(cell => cell !== ''));
        } catch (error) {
            this.reportStepFailure('Failed to parse data table', error);
            throw new StepExecutionException('Failed to parse data table', error);
        }
    }

    /**
     * Converts a data table to an object array.
     * 
     * @param dataTable The data table
     * @returns Array of objects
     */
    public dataTableToObjects(dataTable: Array<Array<string>>): Array<{[key: string]: string}> {
        if (!dataTable || dataTable.length < 2) {
            return [];
        }
        
        try {
            const headers = dataTable[0];
            const rows = dataTable.slice(1);
            
            return rows.map(row => {
                const obj: {[key: string]: string} = {};
                
                row.forEach((cell, index) => {
                    if (index < headers.length) {
                        obj[headers[index]] = cell;
                    }
                });
                
                return obj;
            });
        } catch (error) {
            this.reportStepFailure('Failed to convert data table to objects', error);
            throw new StepExecutionException('Failed to convert data table to objects', error);
        }
    }

    /**
     * Pauses execution for the specified duration.
     * 
     * @param milliseconds The duration in milliseconds
     * @returns Promise resolving when the pause is complete
     */
    public async pause(milliseconds: number): Promise<void> {
        return new Promise<void>(resolve => {
            setTimeout(resolve, milliseconds);
        });
    }

    /**
     * Navigates to a URL.
     * 
     * @param url The URL to navigate to
     * @returns Promise resolving when navigation is complete
     */
    public async navigateTo(url: string): Promise<void> {
        try {
            this.reportStepInfo(`Navigating to URL: ${url}`);
            await this.driver.get(url);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`Navigation_${new URL(url).hostname}`);
            }
        } catch (error) {
            await this.reportStepFailure(`Failed to navigate to URL: ${url}`, error);
            throw new StepExecutionException(`Failed to navigate to URL: ${url}`, error);
        }
    }

    /**
     * Clicks an element.
     * 
     * @param locator The element locator
     * @param waitStrategy The wait strategy
     * @returns Promise resolving when the click is complete
     */
    public async clickElement(
        locator: By,
        waitStrategy: 'visible' | 'clickable' | 'present' = 'clickable'
    ): Promise<void> {
        try {
            const element = await this.waitForElement(locator, waitStrategy);
            await element.click();
            
            this.reportStepInfo(`Clicked element: ${locator}`);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`Click_${Date.now()}`);
            }
        } catch (error) {
            await this.reportStepFailure(`Failed to click element: ${locator}`, error);
            throw new StepExecutionException(`Failed to click element: ${locator}`, error);
        }
    }

    /**
     * Enters text into an element.
     * 
     * @param locator The element locator
     * @param text The text to enter
     * @param clearFirst Whether to clear the element first
     * @returns Promise resolving when text entry is complete
     */
    public async enterText(
        locator: By,
        text: string,
        clearFirst: boolean = true
    ): Promise<void> {
        try {
            const element = await this.waitForElement(locator, 'visible');
            
            if (clearFirst) {
                await element.clear();
            }
            
            await element.sendKeys(text);
            
            // Mask sensitive data in logs
            const logText = this.isSensitiveData(text) ? '********' : text;
            this.reportStepInfo(`Entered text '${logText}' into element: ${locator}`);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`TextEntry_${Date.now()}`);
            }
        } catch (error) {
            await this.reportStepFailure(`Failed to enter text into element: ${locator}`, error);
            throw new StepExecutionException(`Failed to enter text into element: ${locator}`, error);
        }
    }
    
    /**
     * Checks if a string contains sensitive data.
     * 
     * @param text The text to check
     * @returns Whether the text contains sensitive data
     */
    protected isSensitiveData(text: string): boolean {
        // Basic patterns for sensitive data
        const patterns = [
            /password/i,      // Password fields
            /passwd/i,        // Password fields (abbreviated)
            /social.*security/i, // Social Security Number fields
            /credit.*card/i,  // Credit card number fields
            /card.*number/i,  // Credit card number fields
            /cvv/i,           // CVV fields
            /ssn/i,           // SSN fields
            /secret/i,        // Secret fields
            /token/i,         // Token fields
            /api.*key/i       // API key fields
        ];
        
        // Get the current element attribute (if available from context)
        const currentElement = this.getContext<WebElement>('currentElement');
        if (currentElement) {
            try {
                // Check if field is password type or has sensitive attributes
                const type = currentElement.getAttribute('type');
                const name = currentElement.getAttribute('name');
                const id = currentElement.getAttribute('id');
                
                if (type === 'password') {
                    return true;
                }
                
                if (name && patterns.some(pattern => pattern.test(name))) {
                    return true;
                }
                
                if (id && patterns.some(pattern => pattern.test(id))) {
                    return true;
                }
            } catch (error) {
                // Ignore errors when checking attributes
            }
        }
        
        return false;
    }

    /**
     * Selects an option from a select element by visible text.
     * 
     * @param locator The select element locator
     * @param text The option text
     * @returns Promise resolving when selection is complete
     */
    public async selectByVisibleText(locator: By, text: string): Promise<void> {
        try {
            const element = await this.waitForElement(locator, 'visible');
            
            // Get all options
            const options = await element.findElements(By.tagName('option'));
            let selected = false;
            
            // Find and click the option with matching text
            for (const option of options) {
                const optionText = await option.getText();
                
                if (optionText.trim() === text.trim()) {
                    await option.click();
                    selected = true;
                    break;
                }
            }
            
            if (!selected) {
                throw new Error(`Option with text '${text}' not found in select element`);
            }
            
            this.reportStepInfo(`Selected option '${text}' from select element: ${locator}`);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`Select_${Date.now()}`);
            }
        } catch (error) {
            await this.reportStepFailure(`Failed to select option from select element: ${locator}`, error);
            throw new StepExecutionException(`Failed to select option from select element: ${locator}`, error);
        }
    }

    /**
     * Selects an option from a select element by value.
     * 
     * @param locator The select element locator
     * @param value The option value
     * @returns Promise resolving when selection is complete
     */
    public async selectByValue(locator: By, value: string): Promise<void> {
        try {
            const element = await this.waitForElement(locator, 'visible');
            
            // Get all options
            const options = await element.findElements(By.tagName('option'));
            let selected = false;
            
            // Find and click the option with matching value
            for (const option of options) {
                const optionValue = await option.getAttribute('value');
                
                if (optionValue.trim() === value.trim()) {
                    await option.click();
                    selected = true;
                    break;
                }
            }
            
            if (!selected) {
                throw new Error(`Option with value '${value}' not found in select element`);
            }
            
            this.reportStepInfo(`Selected option with value '${value}' from select element: ${locator}`);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`Select_${Date.now()}`);
            }
        } catch (error) {
            await this.reportStepFailure(`Failed to select option from select element: ${locator}`, error);
            throw new StepExecutionException(`Failed to select option from select element: ${locator}`, error);
        }
    }

    /**
     * Gets text from an element.
     * 
     * @param locator The element locator
     * @returns Promise resolving to the element text
     */
    public async getElementText(locator: By): Promise<string> {
        try {
            const element = await this.waitForElement(locator, 'visible');
            const text = await element.getText();
            
            this.reportStepInfo(`Got text from element: ${locator}. Text: ${text}`);
            
            return text;
        } catch (error) {
            await this.reportStepFailure(`Failed to get text from element: ${locator}`, error);
            throw new StepExecutionException(`Failed to get text from element: ${locator}`, error);
        }
    }

    /**
     * Gets an attribute value from an element.
     * 
     * @param locator The element locator
     * @param attributeName The attribute name
     * @returns Promise resolving to the attribute value
     */
    public async getElementAttribute(locator: By, attributeName: string): Promise<string> {
        try {
            const element = await this.waitForElement(locator, 'present');
            const value = await element.getAttribute(attributeName);
            
            this.reportStepInfo(`Got attribute '${attributeName}' from element: ${locator}. Value: ${value}`);
            
            return value;
        } catch (error) {
            await this.reportStepFailure(`Failed to get attribute '${attributeName}' from element: ${locator}`, error);
            throw new StepExecutionException(`Failed to get attribute '${attributeName}' from element: ${locator}`, error);
        }
    }

    /**
     * Checks if an element exists.
     * 
     * @param locator The element locator
     * @returns Promise resolving to true if the element exists, false otherwise
     */
    public async elementExists(locator: By): Promise<boolean> {
        try {
            const elements = await this.driver.findElements(locator);
            const exists = elements.length > 0;
            
            this.reportStepInfo(`Element ${locator} ${exists ? 'exists' : 'does not exist'}`);
            
            return exists;
        } catch (error) {
            this.reportStepWarning(`Error checking if element exists: ${locator}`, error);
            return false;
        }
    }

    /**
     * Checks if an element is displayed.
     * 
     * @param locator The element locator
     * @returns Promise resolving to true if the element is displayed, false otherwise
     */
    public async elementIsDisplayed(locator: By): Promise<boolean> {
        try {
            const elements = await this.driver.findElements(locator);
            
            if (elements.length === 0) {
                this.reportStepInfo(`Element ${locator} does not exist`);
                return false;
            }
            
            const isDisplayed = await elements[0].isDisplayed();
            
            this.reportStepInfo(`Element ${locator} is ${isDisplayed ? 'displayed' : 'not displayed'}`);
            
            return isDisplayed;
        } catch (error) {
            this.reportStepWarning(`Error checking if element is displayed: ${locator}`, error);
            return false;
        }
    }

    /**
     * Checks if an element is enabled.
     * 
     * @param locator The element locator
     * @returns Promise resolving to true if the element is enabled, false otherwise
     */
    public async elementIsEnabled(locator: By): Promise<boolean> {
        try {
            const element = await this.waitForElement(locator, 'present');
            const isEnabled = await element.isEnabled();
            
            this.reportStepInfo(`Element ${locator} is ${isEnabled ? 'enabled' : 'disabled'}`);
            
            return isEnabled;
        } catch (error) {
            this.reportStepWarning(`Error checking if element is enabled: ${locator}`, error);
            return false;
        }
    }

    /**
     * Checks if an element is selected.
     * 
     * @param locator The element locator
     * @returns Promise resolving to true if the element is selected, false otherwise
     */
    public async elementIsSelected(locator: By): Promise<boolean> {
        try {
            const element = await this.waitForElement(locator, 'present');
            const isSelected = await element.isSelected();
            
            this.reportStepInfo(`Element ${locator} is ${isSelected ? 'selected' : 'not selected'}`);
            
            return isSelected;
        } catch (error) {
            this.reportStepWarning(`Error checking if element is selected: ${locator}`, error);
            return false;
        }
    }

    /**
     * Executes JavaScript in the browser.
     * 
     * @param script The script to execute
     * @param args Optional arguments
     * @returns Promise resolving to the script result
     */
    public async executeScript<T>(script: string, ...args: any[]): Promise<T> {
        try {
            return await this.driver.executeScript<T>(script, ...args);
        } catch (error) {
            this.reportStepFailure('Failed to execute JavaScript', error);
            throw new StepExecutionException('Failed to execute JavaScript', error);
        }
    }

    /**
     * Scrolls to an element.
     * 
     * @param locator The element locator
     * @returns Promise resolving when scrolling is complete
     */
    public async scrollToElement(locator: By): Promise<void> {
        try {
            const element = await this.waitForElement(locator, 'present');
            
            await this.executeScript(
                'arguments[0].scrollIntoView({behavior: "smooth", block: "center"});',
                element
            );
            
            // Wait for smooth scrolling to complete
            await this.pause(500);
            
            this.reportStepInfo(`Scrolled to element: ${locator}`);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`Scroll_${Date.now()}`);
            }
        } catch (error) {
            await this.reportStepFailure(`Failed to scroll to element: ${locator}`, error);
            throw new StepExecutionException(`Failed to scroll to element: ${locator}`, error);
        }
    }

    /**
     * Hovers over an element.
     * 
     * @param locator The element locator
     * @returns Promise resolving when hovering is complete
     */
    public async hoverElement(locator: By): Promise<void> {
        try {
            const element = await this.waitForElement(locator, 'visible');
            
            const actions = this.driver.actions({async: true});
            await actions.move({origin: element}).perform();
            
            this.reportStepInfo(`Hovered over element: ${locator}`);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`Hover_${Date.now()}`);
            }
        } catch (error) {
            await this.reportStepFailure(`Failed to hover over element: ${locator}`, error);
            throw new StepExecutionException(`Failed to hover over element: ${locator}`, error);
        }
    }

    /**
     * Submits a form.
     * 
     * @param locator The form element locator
     * @returns Promise resolving when submission is complete
     */
    public async submitForm(locator: By): Promise<void> {
        try {
            const element = await this.waitForElement(locator, 'present');
            await element.submit();
            
            this.reportStepInfo(`Submitted form: ${locator}`);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`FormSubmit_${Date.now()}`);
            }
        } catch (error) {
            await this.reportStepFailure(`Failed to submit form: ${locator}`, error);
            throw new StepExecutionException(`Failed to submit form: ${locator}`, error);
        }
    }

    /**
     * Uploads a file.
     * 
     * @param fileInputLocator The file input element locator
     * @param filePath The absolute path to the file
     * @returns Promise resolving when upload is complete
     */
    public async uploadFile(fileInputLocator: By, filePath: string): Promise<void> {
        try {
            const fileInput = await this.waitForElement(fileInputLocator, 'present');
            await fileInput.sendKeys(filePath);
            
            this.reportStepInfo(`Uploaded file '${filePath}' to: ${fileInputLocator}`);
            
            if (this.screenshotOnEachStep) {
                await this.takeScreenshot(`FileUpload_${Date.now()}`);
            }
        } catch (error) {
            await this.reportStepFailure(`Failed to upload file: ${filePath}`, error);
            throw new StepExecutionException(`Failed to upload file: ${filePath}`, error);
        }
    }

    /**
     * Gets all cookies from the browser.
     * 
     * @returns Promise resolving to the cookies
     */
    public async getAllCookies(): Promise<any[]> {
        try {
            return await this.driver.manage().getCookies();
        } catch (error) {
            this.reportStepFailure('Failed to get cookies', error);
            throw new StepExecutionException('Failed to get cookies', error);
        }
    }

    /**
     * Gets a cookie by name.
     * 
     * @param name The cookie name
     * @returns Promise resolving to the cookie
     */
    public async getCookie(name: string): Promise<any> {
        try {
            return await this.driver.manage().getCookie(name);
        } catch (error) {
            this.reportStepFailure(`Failed to get cookie: ${name}`, error);
            throw new StepExecutionException(`Failed to get cookie: ${name}`, error);
        }
    }

    /**
     * Sets a cookie.
     * 
     * @param name The cookie name
     * @param value The cookie value
     * @param options Optional cookie options
     * @returns Promise resolving when the cookie is set
     */
    public async setCookie(name: string, value: string, options?: any): Promise<void> {
        try {
            const cookie = {
                name,
                value,
                ...options
            };
            
            await this.driver.manage().addCookie(cookie);
            
            this.reportStepInfo(`Set cookie: ${name}=${value}`);
        } catch (error) {
            this.reportStepFailure(`Failed to set cookie: ${name}`, error);
            throw new StepExecutionException(`Failed to set cookie: ${name}`, error);
        }
    }

    /**
     * Deletes a cookie.
     * 
     * @param name The cookie name
     * @returns Promise resolving when the cookie is deleted
     */
    public async deleteCookie(name: string): Promise<void> {
        try {
            await this.driver.manage().deleteCookie(name);
            
            this.reportStepInfo(`Deleted cookie: ${name}`);
        } catch (error) {
            this.reportStepFailure(`Failed to delete cookie: ${name}`, error);
            throw new StepExecutionException(`Failed to delete cookie: ${name}`, error);
        }
    }

    /**
     * Deletes all cookies.
     * 
     * @returns Promise resolving when all cookies are deleted
     */
    public async deleteAllCookies(): Promise<void> {
        try {
            await this.driver.manage().deleteAllCookies();
            
            this.reportStepInfo('Deleted all cookies');
        } catch (error) {
            this.reportStepFailure('Failed to delete all cookies', error);
            throw new StepExecutionException('Failed to delete all cookies', error);
        }
    }

    /**
     * Takes a screenshot.
     * 
     * @returns Promise resolving to the screenshot as a base64 string
     */
    public async takeScreenshotAsBase64(): Promise<string> {
        try {
            return await this.driver.takeScreenshot();
        } catch (error) {
            this.reportStepFailure('Failed to take screenshot', error);
            throw new StepExecutionException('Failed to take screenshot', error);
        }
    }

    /**
     * Gets the browser logs.
     * 
     * @param logType The log type
     * @returns Promise resolving to the logs
     */
    public async getBrowserLogs(logType: string = 'browser'): Promise<any[]> {
        try {
            return await this.driver.manage().logs().get(logType);
        } catch (error) {
            this.reportStepWarning(`Failed to get browser logs of type ${logType}`, error);
            return [];
        }
    }
}




CSTestStepDef.ts
--------------------------

import 'reflect-metadata';
import { CSReporter } from '../../core/reporting/CSReporter';
import { CSTestStatus } from '../../core/reporting/CSTestStatus';
import { CSLogger } from '../../core/utils/CSLogger';
import { ConfigurationManager } from '../../core/config/ConfigurationManager';

// Symbol keys for storing metadata
const STEP_METADATA_KEY = Symbol('cs:step');
const BEFORE_STEP_METADATA_KEY = Symbol('cs:beforeStep');
const AFTER_STEP_METADATA_KEY = Symbol('cs:afterStep');
const PARAMETER_METADATA_KEY = Symbol('cs:parameter');
const STEP_EXECUTION_ORDER = Symbol('cs:stepOrder');

// Parameter source types
export enum ParameterSourceType {
    DATATABLE = 'DATATABLE',
    DOCSTRING = 'DOCSTRING',
    CONTEXT = 'CONTEXT',
    REGEX_GROUP = 'REGEX_GROUP',
    CUSTOM = 'CUSTOM'
}

/**
 * Interface for step definition metadata
 */
export interface StepDefinitionMetadata {
    pattern: RegExp | string;
    name?: string;
    description?: string;
    tags?: string[];
    order?: number;
    timeout?: number;
    screenshotAfter?: boolean;
    screenshotBefore?: boolean;
    skipInReport?: boolean;
    group?: string;
}

/**
 * Interface for parameter metadata
 */
export interface ParameterMetadata {
    index: number;
    name?: string;
    sourceType: ParameterSourceType;
    source?: string;
    optional?: boolean;
    defaultValue?: any;
    transformer?: (value: any) => any;
}

/**
 * Interface for before/after step metadata
 */
export interface HookMetadata {
    name?: string;
    order?: number;
    condition?: (metadata: StepDefinitionMetadata) => boolean;
    tags?: string[];
}

/**
 * Metadata registry for storing and retrieving step metadata
 */
export class StepMetadataRegistry {
    private static instance: StepMetadataRegistry;
    private stepDefinitions: Map<string, StepDefinitionMetadata[]> = new Map();
    private beforeStepHooks: Map<string, HookMetadata[]> = new Map();
    private afterStepHooks: Map<string, HookMetadata[]> = new Map();
    private parameterMetadata: Map<string, Map<string | number, ParameterMetadata[]>> = new Map();
    
    private constructor() {
        // Private constructor for singleton
    }
    
    public static getInstance(): StepMetadataRegistry {
        if (!StepMetadataRegistry.instance) {
            StepMetadataRegistry.instance = new StepMetadataRegistry();
        }
        
        return StepMetadataRegistry.instance;
    }
    
    /**
     * Registers step definition metadata
     * 
     * @param target The class prototype
     * @param methodName The method name
     * @param metadata The step definition metadata
     */
    public registerStepDefinition(
        target: Object,
        methodName: string | symbol,
        metadata: StepDefinitionMetadata
    ): void {
        const className = target.constructor.name;
        
        if (!this.stepDefinitions.has(className)) {
            this.stepDefinitions.set(className, []);
        }
        
        const steps = this.stepDefinitions.get(className)!;
        const stepName = methodName.toString();
        
        // Remove existing step definition with the same name
        const existingIndex = steps.findIndex(step => step.name === stepName);
        if (existingIndex !== -1) {
            steps.splice(existingIndex, 1);
        }
        
        // Add the new step definition
        steps.push({
            ...metadata,
            name: stepName
        });
        
        CSLogger.debug(`Registered step definition ${className}.${stepName} with pattern "${metadata.pattern}"`);
    }
    
    /**
     * Registers a before step hook
     * 
     * @param target The class prototype
     * @param methodName The method name
     * @param metadata The hook metadata
     */
    public registerBeforeStepHook(
        target: Object,
        methodName: string | symbol,
        metadata: HookMetadata
    ): void {
        const className = target.constructor.name;
        
        if (!this.beforeStepHooks.has(className)) {
            this.beforeStepHooks.set(className, []);
        }
        
        const hooks = this.beforeStepHooks.get(className)!;
        const hookName = methodName.toString();
        
        // Remove existing hook with the same name
        const existingIndex = hooks.findIndex(hook => hook.name === hookName);
        if (existingIndex !== -1) {
            hooks.splice(existingIndex, 1);
        }
        
        // Add the new hook
        hooks.push({
            ...metadata,
            name: hookName
        });
        
        // Sort hooks by order
        hooks.sort((a, b) => (a.order || 0) - (b.order || 0));
        
        CSLogger.debug(`Registered before step hook ${className}.${hookName}`);
    }
    
    /**
     * Registers an after step hook
     * 
     * @param target The class prototype
     * @param methodName The method name
     * @param metadata The hook metadata
     */
    public registerAfterStepHook(
        target: Object,
        methodName: string | symbol,
        metadata: HookMetadata
    ): void {
        const className = target.constructor.name;
        
        if (!this.afterStepHooks.has(className)) {
            this.afterStepHooks.set(className, []);
        }
        
        const hooks = this.afterStepHooks.get(className)!;
        const hookName = methodName.toString();
        
        // Remove existing hook with the same name
        const existingIndex = hooks.findIndex(hook => hook.name === hookName);
        if (existingIndex !== -1) {
            hooks.splice(existingIndex, 1);
        }
        
        // Add the new hook
        hooks.push({
            ...metadata,
            name: hookName
        });
        
        // Sort hooks by order
        hooks.sort((a, b) => (a.order || 0) - (b.order || 0));
        
        CSLogger.debug(`Registered after step hook ${className}.${hookName}`);
    }
    
    /**
     * Registers parameter metadata
     * 
     * @param target The class prototype
     * @param methodName The method name
     * @param paramIndex The parameter index
     * @param metadata The parameter metadata
     */
    public registerParameterMetadata(
        target: Object,
        methodName: string | symbol,
        paramIndex: number,
        metadata: ParameterMetadata
    ): void {
        const className = target.constructor.name;
        
        if (!this.parameterMetadata.has(className)) {
            this.parameterMetadata.set(className, new Map());
        }
        
        const classMethods = this.parameterMetadata.get(className)!;
        const methodKey = methodName.toString();
        
        if (!classMethods.has(methodKey)) {
            classMethods.set(methodKey, []);
        }
        
        const params = classMethods.get(methodKey)!;
        
        // Remove existing parameter metadata with the same index
        const existingIndex = params.findIndex(param => param.index === paramIndex);
        if (existingIndex !== -1) {
            params.splice(existingIndex, 1);
        }
        
        // Add the new parameter metadata
        params.push({
            ...metadata,
            index: paramIndex
        });
        
        // Sort parameters by index
        params.sort((a, b) => a.index - b.index);
        
        CSLogger.debug(`Registered parameter metadata for ${className}.${methodKey}[${paramIndex}]`);
    }
    
    /**
     * Gets step definitions for a class
     * 
     * @param className The class name
     * @returns Array of step definition metadata
     */
    public getStepDefinitions(className: string): StepDefinitionMetadata[] {
        return this.stepDefinitions.get(className) || [];
    }
    
    /**
     * Gets before step hooks for a class
     * 
     * @param className The class name
     * @returns Array of hook metadata
     */
    public getBeforeStepHooks(className: string): HookMetadata[] {
        return this.beforeStepHooks.get(className) || [];
    }
    
    /**
     * Gets after step hooks for a class
     * 
     * @param className The class name
     * @returns Array of hook metadata
     */
    public getAfterStepHooks(className: string): HookMetadata[] {
        return this.afterStepHooks.get(className) || [];
    }
    
    /**
     * Gets parameter metadata for a method
     * 
     * @param className The class name
     * @param methodName The method name
     * @returns Array of parameter metadata
     */
    public getParameterMetadata(className: string, methodName: string): ParameterMetadata[] {
        const classMethods = this.parameterMetadata.get(className);
        
        if (!classMethods) {
            return [];
        }
        
        return classMethods.get(methodName) || [];
    }
    
    /**
     * Finds a step definition matching a step text
     * 
     * @param stepText The step text
     * @returns The matching step definition or undefined
     */
    public findMatchingStepDefinition(stepText: string): {
        className: string;
        metadata: StepDefinitionMetadata;
        match: RegExpMatchArray | null;
    } | undefined {
        for (const [className, steps] of this.stepDefinitions.entries()) {
            for (const step of steps) {
                if (typeof step.pattern === 'string') {
                    // Convert string pattern to RegExp
                    const regExp = new RegExp(`^${step.pattern}$`);
                    const match = stepText.match(regExp);
                    
                    if (match) {
                        return { className, metadata: step, match };
                    }
                } else if (step.pattern instanceof RegExp) {
                    const match = stepText.match(step.pattern);
                    
                    if (match) {
                        return { className, metadata: step, match };
                    }
                }
            }
        }
        
        return undefined;
    }
}

/**
 * Decorator for step definitions
 * 
 * @param pattern The step pattern (string or RegExp)
 * @param options Additional options
 * @returns Method decorator
 */
export function Step(
    pattern: RegExp | string,
    options: Partial<StepDefinitionMetadata> = {}
): MethodDecorator {
    return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) => {
        const metadata: StepDefinitionMetadata = {
            pattern,
            ...options
        };
        
        // Store execution order if not specified
        if (metadata.order === undefined) {
            const currentOrder = Reflect.getMetadata(STEP_EXECUTION_ORDER, target.constructor) || 0;
            metadata.order = currentOrder;
            Reflect.defineMetadata(STEP_EXECUTION_ORDER, currentOrder + 1, target.constructor);
        }
        
        // Store the metadata
        const existingSteps = Reflect.getMetadata(STEP_METADATA_KEY, target, propertyKey) || [];
        Reflect.defineMetadata(STEP_METADATA_KEY, [...existingSteps, metadata], target, propertyKey);
        
        // Register with the registry
        StepMetadataRegistry.getInstance().registerStepDefinition(target, propertyKey, metadata);
        
        // Wrap the original method to include step reporting
        const originalMethod = descriptor.value;
        
        descriptor.value = async function(...args: any[]) {
            const reporter = CSReporter.getInstance();
            const config = ConfigurationManager.getInstance();
            const defaultTimeout = config.getNumber('cucumber.step.defaultTimeout', 60000);
            const timeout = metadata.timeout || defaultTimeout;
            const stepName = metadata.name || propertyKey.toString();
            
            // Create stepText from the pattern and arguments
            let stepText = '';
            if (typeof pattern === 'string') {
                stepText = pattern;
            } else if (pattern instanceof RegExp) {
                stepText = pattern.toString();
                // Replace regex with actual values if provided
                if (args.length > 0 && metadata.pattern instanceof RegExp) {
                    const match = args[0].match(metadata.pattern);
                    if (match) {
                        stepText = args[0];
                    }
                }
            }
            
            // Log step start
            CSLogger.info(`Executing step: ${stepText}`);
            reporter.logStep(`Step: ${stepText}`, CSTestStatus.INFO);
            
            // Take screenshot before step if configured
            if (metadata.screenshotBefore && this.takeScreenshot) {
                try {
                    await this.takeScreenshot(`Before_${stepName}_${Date.now()}`);
                } catch (error) {
                    CSLogger.warn(`Failed to take screenshot before step: ${error.message}`);
                }
            }
            
            try {
                // Execute before step hooks
                await this.executeBeforeStepHooks(metadata);
                
                // Execute step with timeout
                const result = await Promise.race([
                    originalMethod.apply(this, args),
                    new Promise((_, reject) => setTimeout(() => reject(new Error(`Step execution timed out after ${timeout}ms`)), timeout))
                ]);
                
                // Take screenshot after step if configured
                if (metadata.screenshotAfter && this.takeScreenshot) {
                    try {
                        await this.takeScreenshot(`After_${stepName}_${Date.now()}`);
                    } catch (error) {
                        CSLogger.warn(`Failed to take screenshot after step: ${error.message}`);
                    }
                }
                
                // Execute after step hooks
                await this.executeAfterStepHooks(metadata, null);
                
                // Log step success
                CSLogger.info(`Step executed successfully: ${stepText}`);
                reporter.logStep(`Step executed successfully: ${stepText}`, CSTestStatus.PASS);
                
                return result;
            } catch (error) {
                // Log step failure
                CSLogger.error(`Step failed: ${stepText}. Error: ${error.message}`);
                reporter.logStep(`Step failed: ${stepText}. Error: ${error.message}`, CSTestStatus.FAIL, error);
                
                // Take screenshot on failure if not already configured
                if (!metadata.screenshotAfter && this.takeScreenshot) {
                    try {
                        await this.takeScreenshot(`Failed_${stepName}_${Date.now()}`);
                    } catch (screenshotError) {
                        CSLogger.warn(`Failed to take failure screenshot: ${screenshotError.message}`);
                    }
                }
                
                // Execute after step hooks with error
                await this.executeAfterStepHooks(metadata, error);
                
                throw error;
            }
        };
        
        // Ensure the resulting function has the same name as the original
        Object.defineProperty(descriptor.value, 'name', { value: propertyKey.toString() });
        
        return descriptor;
    };
}

/**
 * Decorator for Given steps
 * 
 * @param pattern The step pattern (string or RegExp)
 * @param options Additional options
 * @returns Method decorator
 */
export function Given(
    pattern: RegExp | string,
    options: Partial<StepDefinitionMetadata> = {}
): MethodDecorator {
    return Step(pattern, { ...options, group: 'Given' });
}

/**
 * Decorator for When steps
 * 
 * @param pattern The step pattern (string or RegExp)
 * @param options Additional options
 * @returns Method decorator
 */
export function When(
    pattern: RegExp | string,
    options: Partial<StepDefinitionMetadata> = {}
): MethodDecorator {
    return Step(pattern, { ...options, group: 'When' });
}

/**
 * Decorator for Then steps
 * 
 * @param pattern The step pattern (string or RegExp)
 * @param options Additional options
 * @returns Method decorator
 */
export function Then(
    pattern: RegExp | string,
    options: Partial<StepDefinitionMetadata> = {}
): MethodDecorator {
    return Step(pattern, { ...options, group: 'Then' });
}

/**
 * Decorator for And steps
 * 
 * @param pattern The step pattern (string or RegExp)
 * @param options Additional options
 * @returns Method decorator
 */
export function And(
    pattern: RegExp | string,
    options: Partial<StepDefinitionMetadata> = {}
): MethodDecorator {
    return Step(pattern, { ...options, group: 'And' });
}

/**
 * Decorator for But steps
 * 
 * @param pattern The step pattern (string or RegExp)
 * @param options Additional options
 * @returns Method decorator
 */
export function But(
    pattern: RegExp | string,
    options: Partial<StepDefinitionMetadata> = {}
): MethodDecorator {
    return Step(pattern, { ...options, group: 'But' });
}

/**
 * Decorator for before step hooks
 * 
 * @param options Hook options
 * @returns Method decorator
 */
export function BeforeStep(options: Partial<HookMetadata> = {}): MethodDecorator {
    return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) => {
        const metadata: HookMetadata = {
            ...options,
            name: propertyKey.toString()
        };
        
        // Store the metadata
        const existingHooks = Reflect.getMetadata(BEFORE_STEP_METADATA_KEY, target, propertyKey) || [];
        Reflect.defineMetadata(BEFORE_STEP_METADATA_KEY, [...existingHooks, metadata], target, propertyKey);
        
        // Register with the registry
        StepMetadataRegistry.getInstance().registerBeforeStepHook(target, propertyKey, metadata);
        
        return descriptor;
    };
}

/**
 * Decorator for after step hooks
 * 
 * @param options Hook options
 * @returns Method decorator
 */
export function AfterStep(options: Partial<HookMetadata> = {}): MethodDecorator {
    return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) => {
        const metadata: HookMetadata = {
            ...options,
            name: propertyKey.toString()
        };
        
        // Store the metadata
        const existingHooks = Reflect.getMetadata(AFTER_STEP_METADATA_KEY, target, propertyKey) || [];
        Reflect.defineMetadata(AFTER_STEP_METADATA_KEY, [...existingHooks, metadata], target, propertyKey);
        
        // Register with the registry
        StepMetadataRegistry.getInstance().registerAfterStepHook(target, propertyKey, metadata);
        
        return descriptor;
    };
}

/**
 * Decorator for data table parameters
 * 
 * @param options Parameter options
 * @returns Parameter decorator
 */
export function DataTable(options: Partial<Omit<ParameterMetadata, 'index' | 'sourceType'>> = {}): ParameterDecorator {
    return (target: Object, propertyKey: string | symbol, parameterIndex: number) => {
        const metadata: ParameterMetadata = {
            index: parameterIndex,
            sourceType: ParameterSourceType.DATATABLE,
            ...options
        };
        
        // Store the metadata
        const existingParams = Reflect.getMetadata(PARAMETER_METADATA_KEY, target, propertyKey) || [];
        Reflect.defineMetadata(PARAMETER_METADATA_KEY, [...existingParams, metadata], target, propertyKey);
        
        // Register with the registry
        StepMetadataRegistry.getInstance().registerParameterMetadata(target, propertyKey, parameterIndex, metadata);
    };
}

/**
 * Decorator for doc string parameters
 * 
 * @param options Parameter options
 * @returns Parameter decorator
 */
export function DocString(options: Partial<Omit<ParameterMetadata, 'index' | 'sourceType'>> = {}): ParameterDecorator {
    return (target: Object, propertyKey: string | symbol, parameterIndex: number) => {
        const metadata: ParameterMetadata = {
            index: parameterIndex,
            sourceType: ParameterSourceType.DOCSTRING,
            ...options
        };
        
        // Store the metadata
        const existingParams = Reflect.getMetadata(PARAMETER_METADATA_KEY, target, propertyKey) || [];
        Reflect.defineMetadata(PARAMETER_METADATA_KEY, [...existingParams, metadata], target, propertyKey);
        
        // Register with the registry
        StepMetadataRegistry.getInstance().registerParameterMetadata(target, propertyKey, parameterIndex, metadata);
    };
}

/**
 * Decorator for context parameters
 * 
 * @param contextKey The context key
 * @param options Parameter options
 * @returns Parameter decorator
 */
export function Context(contextKey: string, options: Partial<Omit<ParameterMetadata, 'index' | 'sourceType' | 'source'>> = {}): ParameterDecorator {
    return (target: Object, propertyKey: string | symbol, parameterIndex: number) => {
        const metadata: ParameterMetadata = {
            index: parameterIndex,
            sourceType: ParameterSourceType.CONTEXT,
            source: contextKey,
            ...options
        };
        
        // Store the metadata
        const existingParams = Reflect.getMetadata(PARAMETER_METADATA_KEY, target, propertyKey) || [];
        Reflect.defineMetadata(PARAMETER_METADATA_KEY, [...existingParams, metadata], target, propertyKey);
        
        // Register with the registry
        StepMetadataRegistry.getInstance().registerParameterMetadata(target, propertyKey, parameterIndex, metadata);
    };
}

/**
 * Decorator for regex group parameters
 * 
 * @param groupIndex The regex group index
 * @param options Parameter options
 * @returns Parameter decorator
 */
export function RegexGroup(groupIndex: number, options: Partial<Omit<ParameterMetadata, 'index' | 'sourceType' | 'source'>> = {}): ParameterDecorator {
    return (target: Object, propertyKey: string | symbol, parameterIndex: number) => {
        const metadata: ParameterMetadata = {
            index: parameterIndex,
            sourceType: ParameterSourceType.REGEX_GROUP,
            source: groupIndex.toString(),
            ...options
        };
        
        // Store the metadata
        const existingParams = Reflect.getMetadata(PARAMETER_METADATA_KEY, target, propertyKey) || [];
        Reflect.defineMetadata(PARAMETER_METADATA_KEY, [...existingParams, metadata], target, propertyKey);
        
        // Register with the registry
        StepMetadataRegistry.getInstance().registerParameterMetadata(target, propertyKey, parameterIndex, metadata);
    };
}

/**
 * Decorator for custom parameter sources
 * 
 * @param sourceName The source name or function
 * @param options Parameter options
 * @returns Parameter decorator
 */
export function CustomParameter(
    sourceName: string | ((context: any) => any),
    options: Partial<Omit<ParameterMetadata, 'index' | 'sourceType' | 'source'>> = {}
): ParameterDecorator {
    return (target: Object, propertyKey: string | symbol, parameterIndex: number) => {
        const metadata: ParameterMetadata = {
            index: parameterIndex,
            sourceType: ParameterSourceType.CUSTOM,
            source: typeof sourceName === 'string' ? sourceName : sourceName.toString(),
            ...options
        };
        
        // Store the metadata
        const existingParams = Reflect.getMetadata(PARAMETER_METADATA_KEY, target, propertyKey) || [];
        Reflect.defineMetadata(PARAMETER_METADATA_KEY, [...existingParams, metadata], target, propertyKey);
        
        // Register with the registry
        StepMetadataRegistry.getInstance().registerParameterMetadata(target, propertyKey, parameterIndex, metadata);
        
        // Store the function if provided
        if (typeof sourceName === 'function') {
            Reflect.defineMetadata(`${PARAMETER_METADATA_KEY}:${parameterIndex}:function`, sourceName, target, propertyKey);
        }
    };
}

/**
 * Executes before step hooks
 * 
 * @param instance The instance
 * @param stepMetadata The step metadata
 * @returns Promise resolving when all hooks have been executed
 */
async function executeBeforeStepHooks(instance: any, stepMetadata: StepDefinitionMetadata): Promise<void> {
    const className = instance.constructor.name;
    const registry = StepMetadataRegistry.getInstance();
    const hooks = registry.getBeforeStepHooks(className);
    
    // Filter hooks by conditions and tags
    const applicableHooks = hooks.filter(hook => {
        // Check condition
        if (hook.condition && !hook.condition(stepMetadata)) {
            return false;
        }
        
        // Check tags
        if (hook.tags && hook.tags.length > 0 && stepMetadata.tags) {
            const hasMatchingTag = hook.tags.some(tag => stepMetadata.tags!.includes(tag));
            if (!hasMatchingTag) {
                return false;
            }
        }
        
        return true;
    });
    
    // Execute hooks in order
    for (const hook of applicableHooks) {
        const hookMethod = instance[hook.name!];
        
        if (typeof hookMethod === 'function') {
            await hookMethod.call(instance, stepMetadata);
        }
    }
}

/**
 * Executes after step hooks
 * 
 * @param instance The instance
 * @param stepMetadata The step metadata
 * @param error Error object or null if no error occurred
 * @returns Promise resolving when all hooks have been executed
 */
async function executeAfterStepHooks(
    instance: any,
    stepMetadata: StepDefinitionMetadata,
    error: Error | null
): Promise<void> {
    const className = instance.constructor.name;
    const registry = StepMetadataRegistry.getInstance();
    const hooks = registry.getAfterStepHooks(className);
    
    // Filter hooks by conditions and tags
    const applicableHooks = hooks.filter(hook => {
        // Check condition
        if (hook.condition && !hook.condition(stepMetadata)) {
            return false;
        }
        
        // Check tags
        if (hook.tags && hook.tags.length > 0 && stepMetadata.tags) {
            const hasMatchingTag = hook.tags.some(tag => stepMetadata.tags!.includes(tag));
            if (!hasMatchingTag) {
                return false;
            }
        }
        
        return true;
    });
    
    // Execute hooks in order
    for (const hook of applicableHooks) {
        const hookMethod = instance[hook.name!];
        
        if (typeof hookMethod === 'function') {
            try {
                await hookMethod.call(instance, stepMetadata, error);
            } catch (hookError) {
                CSLogger.warn(`Error in after step hook ${hook.name}: ${hookError.message}`);
                // Continue executing other hooks even if one fails
            }
        }
    }
}

/**
 * Utility class for step definitions with helper methods
 */
export class StepUtils {
    /**
     * Transforms a table string into a 2D array
     * 
     * @param tableString The table string
     * @returns The parsed table as a 2D array
     */
    public static parseTable(tableString: string): string[][] {
        if (!tableString || typeof tableString !== 'string') {
            return [];
        }
        
        return tableString
            .trim()
            .split('\n')
            .map(line => line
                .trim()
                .split('|')
                .map(cell => cell.trim())
                .filter(cell => cell !== '')
            );
    }
    
    /**
     * Transforms a table array into an array of objects
     * 
     * @param tableData The table data
     * @returns The table as an array of objects
     */
    public static tableToObjects(tableData: string[][]): Record<string, string>[] {
        if (!tableData || tableData.length < 2) {
            return [];
        }
        
        const [headerRow, ...dataRows] = tableData;
        
        return dataRows.map(row => {
            const obj: Record<string, string> = {};
            
            row.forEach((cell, index) => {
                if (index < headerRow.length) {
                    obj[headerRow[index]] = cell;
                }
            });
            
            return obj;
        });
    }
    
    /**
     * Extracts parameters for a step method based on parameter metadata
     * 
     * @param className The class name
     * @param methodName The method name
     * @param match The regex match result
     * @param dataTable Optional data table
     * @param docString Optional doc string
     * @param context Optional scenario context
     * @returns The parameters array
     */
    public static extractParameters(
        className: string,
        methodName: string,
        match: RegExpMatchArray | null,
        dataTable?: string | string[][],
        docString?: string,
        context?: Map<string, any>
    ): any[] {
        const registry = StepMetadataRegistry.getInstance();
        const paramMetadata = registry.getParameterMetadata(className, methodName);
        
        if (!paramMetadata || paramMetadata.length === 0) {
            return match ? Array.from(match).slice(1) : [];
        }
        
        const result = new Array(paramMetadata.length);
        
        // Parse data table if it's a string
        let parsedDataTable: string[][] | undefined;
        if (typeof dataTable === 'string') {
            parsedDataTable = this.parseTable(dataTable);
        } else if (Array.isArray(dataTable)) {
            parsedDataTable = dataTable;
        }
        
        // Process each parameter based on its metadata
        for (const metadata of paramMetadata) {
            let value: any = undefined;
            
            switch (metadata.sourceType) {
                case ParameterSourceType.DATATABLE:
                    value = parsedDataTable;
                    break;
                    
                case ParameterSourceType.DOCSTRING:
                    value = docString;
                    break;
                    
                case ParameterSourceType.CONTEXT:
                    if (context && metadata.source) {
                        value = context.get(metadata.source);
                    }
                    break;
                    
                case ParameterSourceType.REGEX_GROUP:
                    if (match && metadata.source) {
                        const groupIndex = parseInt(metadata.source, 10);
                        if (!isNaN(groupIndex) && match[groupIndex]) {
                            value = match[groupIndex];
                        }
                    }
                    break;
                    
                case ParameterSourceType.CUSTOM:
                    // Custom parameter source will be handled by the decorator
                    break;
            }
            
            // Apply transformer if provided
            if (metadata.transformer && value !== undefined) {
                try {
                    value = metadata.transformer(value);
                } catch (error) {
                    CSLogger.warn(`Error transforming parameter ${metadata.index}: ${error.message}`);
                }
            }
            
            // Use default value if value is undefined and parameter is not required
            if (value === undefined && metadata.optional && metadata.defaultValue !== undefined) {
                value = metadata.defaultValue;
            }
            
            // Check if required parameter is missing
            if (value === undefined && !metadata.optional) {
                throw new Error(`Required parameter at index ${metadata.index} is missing`);
            }
            
            result[metadata.index] = value;
        }
        
        return result;
    }
    
    /**
     * Gets the step text from a step pattern
     * 
     * @param pattern The step pattern
     * @param args The arguments
     * @returns The step text
     */
    public static getStepText(pattern: RegExp | string, args: any[]): string {
        if (typeof pattern === 'string') {
            let text = pattern;
            
            // Replace placeholders with arguments
            const placeholders = pattern.match(/\{(\d+)\}/g);
            
            if (placeholders) {
                for (const placeholder of placeholders) {
                    const index = parseInt(placeholder.substring(1, placeholder.length - 1), 10);
                    if (!isNaN(index) && index < args.length) {
                        text = text.replace(placeholder, args[index]?.toString() || '');
                    }
                }
            }
            
            return text;
        } else if (pattern instanceof RegExp) {
            if (args.length > 0 && typeof args[0] === 'string') {
                return args[0];
            }
            
            return pattern.toString();
        }
        
        return '';
    }
    
    /**
     * Determines if a step should be executed based on tags
     * 
     * @param stepTags The step tags
     * @param includeTags Tags to include
     * @param excludeTags Tags to exclude
     * @returns Whether the step should be executed
     */
    public static shouldExecuteStep(
        stepTags: string[] | undefined,
        includeTags: string[] = [],
        excludeTags: string[] = []
    ): boolean {
        // If no step tags, then include if no includeTags specified
        if (!stepTags || stepTags.length === 0) {
            return includeTags.length === 0;
        }
        
        // Check exclude tags first
        if (excludeTags.length > 0) {
            for (const tag of stepTags) {
                if (excludeTags.includes(tag)) {
                    return false;
                }
            }
        }
        
        // If include tags specified, at least one must match
        if (includeTags.length > 0) {
            return stepTags.some(tag => includeTags.includes(tag));
        }
        
        // No include tags specified, all non-excluded steps are included
        return true;
    }
}

/**
 * Step definition runner for executing steps
 */
export class StepRunner {
    private registry: StepMetadataRegistry;
    private stepInstances: Map<string, any> = new Map();
    
    /**
     * Creates a new StepRunner instance
     */
    constructor() {
        this.registry = StepMetadataRegistry.getInstance();
    }
    
    /**
     * Registers a step definition instance
     * 
     * @param instance The step definition instance
     */
    public registerStepInstance(instance: any): void {
        const className = instance.constructor.name;
        this.stepInstances.set(className, instance);
    }
    
    /**
     * Executes a step by text
     * 
     * @param stepText The step text
     * @param dataTable Optional data table
     * @param docString Optional doc string
     * @returns Promise resolving to the step result
     */
    public async executeStep(
        stepText: string,
        dataTable?: string | string[][],
        docString?: string
    ): Promise<any> {
        // Find matching step definition
        const matchingStep = this.registry.findMatchingStepDefinition(stepText);
        
        if (!matchingStep) {
            throw new Error(`No matching step definition found for: ${stepText}`);
        }
        
        const { className, metadata, match } = matchingStep;
        
        // Get instance
        const instance = this.stepInstances.get(className);
        
        if (!instance) {
            throw new Error(`Step definition instance not found for class: ${className}`);
        }
        
        // Execute before step hooks
        await executeBeforeStepHooks(instance, metadata);
        
        // Extract parameters
        const methodName = metadata.name || '';
        const context = instance.scenarioContext instanceof Map ? instance.scenarioContext : new Map();
        
        const params = StepUtils.extractParameters(
            className,
            methodName,
            match,
            dataTable,
            docString,
            context
        );
        
        // Execute the step
        let error: Error | null = null;
        let result: any;
        
        try {
            result = await instance[methodName].apply(instance, params);
        } catch (e) {
            error = e instanceof Error ? e : new Error(String(e));
            throw error;
        } finally {
            // Execute after step hooks
            await executeAfterStepHooks(instance, metadata, error);
        }
        
        return result;
    }
    
    /**
     * Gets all registered step definitions
     * 
     * @returns Array of step definitions with class names
     */
    public getAllStepDefinitions(): Array<{className: string, steps: StepDefinitionMetadata[]}> {
        const result: Array<{className: string, steps: StepDefinitionMetadata[]}> = [];
        
        for (const className of this.stepInstances.keys()) {
            const steps = this.registry.getStepDefinitions(className);
            
            if (steps.length > 0) {
                result.push({
                    className,
                    steps
                });
            }
        }
        
        return result;
    }
    
    /**
     * Gets step definition patterns as strings
     * 
     * @returns Array of step patterns
     */
    public getStepPatterns(): string[] {
        const allSteps = this.getAllStepDefinitions();
        const patterns: string[] = [];
        
        for (const { steps } of allSteps) {
            for (const step of steps) {
                if (typeof step.pattern === 'string') {
                    patterns.push(step.pattern);
                } else if (step.pattern instanceof RegExp) {
                    patterns.push(step.pattern.toString());
                }
            }
        }
        
        return patterns;
    }
    
    /**
     * Gets step definitions matching a partial text
     * 
     * @param partialText The partial step text
     * @returns Array of matching step definitions
     */
    public findMatchingStepDefinitions(partialText: string): Array<{
        className: string,
        metadata: StepDefinitionMetadata,
        pattern: string
    }> {
        const allSteps = this.getAllStepDefinitions();
        const result: Array<{className: string, metadata: StepDefinitionMetadata, pattern: string}> = [];
        
        for (const { className, steps } of allSteps) {
            for (const step of steps) {
                const patternStr = typeof step.pattern === 'string' 
                    ? step.pattern 
                    : step.pattern.toString();
                
                // Simple matching by checking if pattern contains the partial text
                // or if the partial text contains the pattern (ignoring regex symbols)
                const normalizedPattern = patternStr
                    .replace(/\(\?\:.*?\)/g, '')  // Remove non-capturing groups
                    .replace(/[\[\]\(\)\{\}\.\*\+\?\|\\\^\$]/g, ''); // Remove regex special chars
                
                if (normalizedPattern.toLowerCase().includes(partialText.toLowerCase()) ||
                    partialText.toLowerCase().includes(normalizedPattern.toLowerCase())) {
                    result.push({
                        className,
                        metadata: step,
                        pattern: patternStr
                    });
                }
            }
        }
        
        return result;
    }
    
    /**
     * Clears all registered step instances
     */
    public clear(): void {
        this.stepInstances.clear();
    }
}

/**
 * Cucumber integration adapter for running Cucumber tests with CSTestForge
 */
export class CucumberAdapter {
    private stepRunner: StepRunner;
    
    /**
     * Creates a new CucumberAdapter instance
     */
    constructor() {
        this.stepRunner = new StepRunner();
    }
    
    /**
     * Registers step definition instances
     * 
     * @param instances The step definition instances
     */
    public registerStepDefinitions(instances: any[]): void {
        for (const instance of instances) {
            this.stepRunner.registerStepInstance(instance);
        }
    }
    
    /**
     * Gets the step definitions function for Cucumber
     * 
     * @returns The step definitions function
     */
    public getStepDefinitionsFunction(): Function {
        return (cucumber: any) => {
            const { Given, When, Then, DataTable, DocString } = cucumber;
            
            // Register all step patterns with Cucumber
            const allSteps = this.stepRunner.getAllStepDefinitions();
            
            for (const { className, steps } of allSteps) {
                for (const step of steps) {
                    const pattern = step.pattern;
                    const group = step.group || '';
                    const methodName = step.name || '';
                    
                    // Define step definition based on group
                    let defineStep;
                    switch (group.toLowerCase()) {
                        case 'given':
                            defineStep = Given;
                            break;
                        case 'when':
                            defineStep = When;
                            break;
                        case 'then':
                            defineStep = Then;
                            break;
                        default:
                            defineStep = cucumber.defineStep;
                    }
                    
                    // Register with Cucumber
                    defineStep(pattern, async function(this: any, ...args: any[]) {
                        // Extract data table and doc string from args
                        let dataTable: any;
                        let docString: string | undefined;
                        
                        for (const arg of args) {
                            if (arg && arg.constructor && arg.constructor.name === 'DataTable') {
                                dataTable = arg;
                            } else if (typeof arg === 'string' && args[0] !== arg) {
                                docString = arg;
                            }
                        }
                        
                        // Convert Cucumber DataTable to string[][] if present
                        let tableData: string[][] | undefined;
                        if (dataTable) {
                            try {
                                tableData = dataTable.rawTable || dataTable.rows().map((row: any) => row.map((cell: any) => cell));
                            } catch (error) {
                                CSLogger.warn(`Error converting Cucumber DataTable: ${error.message}`);
                            }
                        }
                        
                        // Execute step
                        try {
                            return await this.stepRunner.executeStep(args[0], tableData, docString);
                        } catch (error) {
                            // Capture screenshot if possible
                            try {
                                const instance = this.stepRunner.getStepInstances().get(className);
                                if (instance && typeof instance.takeScreenshot === 'function') {
                                    await instance.takeScreenshot(`Failed_${methodName}_${Date.now()}`);
                                }
                            } catch (screenshotError) {
                                CSLogger.warn(`Failed to take failure screenshot: ${screenshotError.message}`);
                            }
                            
                            throw error;
                        }
                    });
                }
            }
        };
    }
    
    /**
     * Gets the step runner instance
     * 
     * @returns The step runner
     */
    public getStepRunner(): StepRunner {
        return this.stepRunner;
    }
}

// Add a method to StepRunner to support CucumberAdapter
StepRunner.prototype.getStepInstances = function(): Map<string, any> {
    return this.stepInstances;
};



CSPage.ts
----------------------

import 'reflect-metadata';
import { CSBasePage } from '../base/CSBasePage';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSElement } from '../element/CSElement';
import { CSElement as CSElementType } from '../../types/element';

// Symbol keys for metadata
const PAGE_METADATA_KEY = Symbol('cs:page');
const PAGE_URL_KEY = Symbol('cs:page:url');
const PAGE_TITLE_KEY = Symbol('cs:page:title');
const PAGE_VERIFICATION_ELEMENT_KEY = Symbol('cs:page:verificationElement');
const PAGE_VERIFICATION_TIMEOUT_KEY = Symbol('cs:page:verificationTimeout');
const PAGE_WAIT_FOR_LOAD_KEY = Symbol('cs:page:waitForLoad');
const PAGE_CUSTOM_VERIFICATION_KEY = Symbol('cs:page:customVerification');
const PAGE_SECTION_KEY = Symbol('cs:page:section');
const PAGE_SECTION_ROOT_KEY = Symbol('cs:page:sectionRoot');
const PAGE_PARAMETERS_KEY = Symbol('cs:page:parameters');
const PAGE_ALIASES_KEY = Symbol('cs:page:aliases');
const PAGE_DESCRIPTION_KEY = Symbol('cs:page:description');
const PAGE_TAGS_KEY = Symbol('cs:page:tags');
const PAGE_LOCALIZED_KEY = Symbol('cs:page:localized');

/**
 * Interface for page metadata
 */
export interface PageMetadata {
    /**
     * The page URL or URL pattern.
     * Can include placeholders like {param} which will be replaced when opening the page.
     */
    url?: string;
    
    /**
     * Expected page title or title pattern.
     * Used for verification.
     */
    title?: string | RegExp;
    
    /**
     * Element selector used to verify the page is loaded.
     */
    verificationElement?: string;
    
    /**
     * Timeout for verification in milliseconds.
     */
    verificationTimeout?: number;
    
    /**
     * Whether to wait for page load before considering navigation complete.
     */
    waitForLoad?: boolean;
    
    /**
     * Name of a method in the page class to use for custom verification.
     * Method should return a boolean or Promise<boolean>.
     */
    customVerification?: string;
    
    /**
     * Whether this is a page section rather than a full page.
     */
    isSection?: boolean;
    
    /**
     * Selector for the root element if this is a section.
     */
    sectionRoot?: string;
    
    /**
     * URL parameters for the page.
     */
    parameters?: Record<string, string | (() => string)>;
    
    /**
     * Alternative identifiers for the page.
     */
    aliases?: string[];
    
    /**
     * Human-readable description of the page.
     */
    description?: string;
    
    /**
     * Tags for grouping and filtering pages.
     */
    tags?: string[];
    
    /**
     * Whether the page is localized with different URLs per locale.
     */
    isLocalized?: boolean;
    
    /**
     * Any additional custom metadata.
     */
    [key: string]: any;
}

/**
 * Registry for page metadata
 */
export class PageRegistry {
    private static instance: PageRegistry;
    private pageMetadata: Map<string, PageMetadata> = new Map();
    private pageClasses: Map<string, any> = new Map();
    
    private constructor() {
        // Private constructor for singleton
    }
    
    /**
     * Gets the singleton instance of the registry
     * 
     * @returns The PageRegistry instance
     */
    public static getInstance(): PageRegistry {
        if (!PageRegistry.instance) {
            PageRegistry.instance = new PageRegistry();
        }
        
        return PageRegistry.instance;
    }
    
    /**
     * Registers page metadata
     * 
     * @param className The page class name
     * @param metadata The page metadata
     * @param pageClass The page class constructor
     */
    public registerPage(
        className: string,
        metadata: PageMetadata,
        pageClass: any
    ): void {
        this.pageMetadata.set(className, metadata);
        this.pageClasses.set(className, pageClass);
        
        // Register by aliases if provided
        if (metadata.aliases && metadata.aliases.length > 0) {
            for (const alias of metadata.aliases) {
                this.pageClasses.set(alias, pageClass);
            }
        }
        
        CSLogger.debug(`Registered page ${className} with URL ${metadata.url || 'unspecified'}`);
    }
    
    /**
     * Gets page metadata
     * 
     * @param className The page class name
     * @returns The page metadata or undefined if not found
     */
    public getMetadata(className: string): PageMetadata | undefined {
        return this.pageMetadata.get(className);
    }
    
    /**
     * Gets a page class by name or alias
     * 
     * @param nameOrAlias The class name or alias
     * @returns The page class or undefined if not found
     */
    public getPageClass(nameOrAlias: string): any {
        return this.pageClasses.get(nameOrAlias);
    }
    
    /**
     * Gets all registered page classes
     * 
     * @returns Map of class names to page classes
     */
    public getAllPageClasses(): Map<string, any> {
        return new Map(this.pageClasses);
    }
    
    /**
     * Gets all page metadata
     * 
     * @returns Map of class names to metadata
     */
    public getAllMetadata(): Map<string, PageMetadata> {
        return new Map(this.pageMetadata);
    }
    
    /**
     * Finds pages matching criteria
     * 
     * @param criteria The criteria to match
     * @returns Array of matching page classes
     */
    public findPages(criteria: Partial<PageMetadata>): any[] {
        const result: any[] = [];
        
        for (const [className, metadata] of this.pageMetadata.entries()) {
            let matches = true;
            
            for (const [key, value] of Object.entries(criteria)) {
                if (metadata[key] !== value) {
                    matches = false;
                    break;
                }
            }
            
            if (matches) {
                const pageClass = this.pageClasses.get(className);
                if (pageClass) {
                    result.push(pageClass);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Finds a page by URL pattern
     * 
     * @param url The URL to match
     * @returns The matching page class or undefined if not found
     */
    public findPageByUrl(url: string): any | undefined {
        for (const [className, metadata] of this.pageMetadata.entries()) {
            if (!metadata.url) {
                continue;
            }
            
            // Convert URL pattern to regex
            const pattern = metadata.url
                .replace(/\{[^{}]+\}/g, '([^/]+)')  // Replace {param} with capture group
                .replace(/\//g, '\\/');             // Escape forward slashes
            
            const regex = new RegExp(`^${pattern}$`);
            
            if (regex.test(url)) {
                return this.pageClasses.get(className);
            }
        }
        
        return undefined;
    }
}

/**
 * Decorator for page classes
 * 
 * @param metadata The page metadata
 * @returns Class decorator
 */
export function CSPage(metadata: PageMetadata): ClassDecorator {
    return (target: any) => {
        // Store metadata on the class
        Reflect.defineMetadata(PAGE_METADATA_KEY, metadata, target);
        
        if (metadata.url) {
            Reflect.defineMetadata(PAGE_URL_KEY, metadata.url, target);
        }
        
        if (metadata.title) {
            Reflect.defineMetadata(PAGE_TITLE_KEY, metadata.title, target);
        }
        
        if (metadata.verificationElement) {
            Reflect.defineMetadata(PAGE_VERIFICATION_ELEMENT_KEY, metadata.verificationElement, target);
        }
        
        if (metadata.verificationTimeout) {
            Reflect.defineMetadata(PAGE_VERIFICATION_TIMEOUT_KEY, metadata.verificationTimeout, target);
        }
        
        if (metadata.waitForLoad !== undefined) {
            Reflect.defineMetadata(PAGE_WAIT_FOR_LOAD_KEY, metadata.waitForLoad, target);
        }
        
        if (metadata.customVerification) {
            Reflect.defineMetadata(PAGE_CUSTOM_VERIFICATION_KEY, metadata.customVerification, target);
        }
        
        if (metadata.isSection) {
            Reflect.defineMetadata(PAGE_SECTION_KEY, true, target);
        }
        
        if (metadata.sectionRoot) {
            Reflect.defineMetadata(PAGE_SECTION_ROOT_KEY, metadata.sectionRoot, target);
        }
        
        if (metadata.parameters) {
            Reflect.defineMetadata(PAGE_PARAMETERS_KEY, metadata.parameters, target);
        }
        
        if (metadata.aliases) {
            Reflect.defineMetadata(PAGE_ALIASES_KEY, metadata.aliases, target);
        }
        
        if (metadata.description) {
            Reflect.defineMetadata(PAGE_DESCRIPTION_KEY, metadata.description, target);
        }
        
        if (metadata.tags) {
            Reflect.defineMetadata(PAGE_TAGS_KEY, metadata.tags, target);
        }
        
        if (metadata.isLocalized) {
            Reflect.defineMetadata(PAGE_LOCALIZED_KEY, true, target);
        }
        
        // Register with the registry
        PageRegistry.getInstance().registerPage(target.name, metadata, target);
        
        // Add metadata getters to the class prototype
        if (!target.prototype.getPageUrl && metadata.url) {
            target.prototype.getPageUrl = function(): string {
                const url = Reflect.getMetadata(PAGE_URL_KEY, this.constructor);
                
                if (!url) {
                    return '';
                }
                
                // Replace parameters in URL
                let resultUrl = url;
                const parameters = Reflect.getMetadata(PAGE_PARAMETERS_KEY, this.constructor) || {};
                
                for (const [key, value] of Object.entries(parameters)) {
                    const paramValue = typeof value === 'function' ? value() : value;
                    resultUrl = resultUrl.replace(`{${key}}`, encodeURIComponent(paramValue));
                }
                
                // Replace any remaining placeholders with empty strings
                resultUrl = resultUrl.replace(/\{[^{}]+\}/g, '');
                
                return resultUrl;
            };
        }
        
        if (!target.prototype.getPageTitle && metadata.title) {
            target.prototype.getPageTitle = function(): string | RegExp {
                return Reflect.getMetadata(PAGE_TITLE_KEY, this.constructor);
            };
        }
        
        if (!target.prototype.getVerificationElement && metadata.verificationElement) {
            target.prototype.getVerificationElement = function(): string {
                return Reflect.getMetadata(PAGE_VERIFICATION_ELEMENT_KEY, this.constructor);
            };
        }
        
        if (!target.prototype.getVerificationTimeout && metadata.verificationTimeout) {
            target.prototype.getVerificationTimeout = function(): number {
                return Reflect.getMetadata(PAGE_VERIFICATION_TIMEOUT_KEY, this.constructor);
            };
        }
        
        if (!target.prototype.shouldWaitForLoad && metadata.waitForLoad !== undefined) {
            target.prototype.shouldWaitForLoad = function(): boolean {
                return Reflect.getMetadata(PAGE_WAIT_FOR_LOAD_KEY, this.constructor);
            };
        }
        
        if (!target.prototype.isPageSection && metadata.isSection !== undefined) {
            target.prototype.isPageSection = function(): boolean {
                return Reflect.getMetadata(PAGE_SECTION_KEY, this.constructor) || false;
            };
        }
        
        if (!target.prototype.getSectionRoot && metadata.sectionRoot) {
            target.prototype.getSectionRoot = function(): string {
                return Reflect.getMetadata(PAGE_SECTION_ROOT_KEY, this.constructor);
            };
        }
        
        if (!target.prototype.getPageMetadata) {
            target.prototype.getPageMetadata = function(): PageMetadata {
                return Reflect.getMetadata(PAGE_METADATA_KEY, this.constructor) || {};
            };
        }
        
        // Enhance the 'open' method if it follows the base class pattern
        const originalOpen = target.prototype.open;
        
        if (originalOpen && typeof originalOpen === 'function') {
            target.prototype.open = async function(...args: any[]): Promise<any> {
                try {
                    const url = this.getPageUrl();
                    
                    if (!url) {
                        throw new Error('Page URL is not defined');
                    }
                    
                    CSLogger.debug(`Opening page ${this.constructor.name} at URL: ${url}`);
                    
                    // Let the original open method handle the actual navigation
                    const result = await originalOpen.apply(this, [url, ...args]);
                    
                    // Perform verification
                    await this.verifyPage();
                    
                    return result;
                } catch (error) {
                    CSLogger.error(`Failed to open page ${this.constructor.name}: ${error.message}`);
                    throw error;
                }
            };
        }
        
        // Enhance the 'verifyPage' method if it follows the base class pattern
        const originalVerify = target.prototype.verifyPage;
        
        if (originalVerify && typeof originalVerify === 'function') {
            target.prototype.verifyPage = async function(): Promise<boolean> {
                try {
                    // If custom verification method is specified, use it
                    const customMethod = Reflect.getMetadata(PAGE_CUSTOM_VERIFICATION_KEY, this.constructor);
                    
                    if (customMethod && typeof this[customMethod] === 'function') {
                        return await this[customMethod]();
                    }
                    
                    // Let the original verify method handle the verification
                    return await originalVerify.apply(this);
                } catch (error) {
                    CSLogger.error(`Failed to verify page ${this.constructor.name}: ${error.message}`);
                    return false;
                }
            };
        }
        
        return target;
    };
}

/**
 * Decorator for page sections
 * 
 * @param rootSelector The root element selector
 * @param options Additional section options
 * @returns Class decorator
 */
export function CSSection(
    rootSelector: string,
    options: Omit<PageMetadata, 'isSection' | 'sectionRoot'> = {}
): ClassDecorator {
    return CSPage({
        ...options,
        isSection: true,
        sectionRoot: rootSelector
    });
}

/**
 * Utility for working with pages
 */
export class CSPageUtils {
    /**
     * Gets metadata for a page class
     * 
     * @param pageClass The page class
     * @returns The page metadata
     */
    public static getPageMetadata(pageClass: any): PageMetadata {
        return Reflect.getMetadata(PAGE_METADATA_KEY, pageClass) || {};
    }
    
    /**
     * Gets the URL for a page
     * 
     * @param pageClass The page class
     * @param parameters Optional URL parameters
     * @returns The page URL with parameters substituted
     */
    public static getPageUrl(
        pageClass: any,
        parameters?: Record<string, string>
    ): string {
        const url = Reflect.getMetadata(PAGE_URL_KEY, pageClass);
        
        if (!url) {
            return '';
        }
        
        // Combine default parameters with provided ones
        const defaultParams = Reflect.getMetadata(PAGE_PARAMETERS_KEY, pageClass) || {};
        const allParams = { ...defaultParams, ...parameters };
        
        // Replace parameters in URL
        let resultUrl = url;
        
        for (const [key, value] of Object.entries(allParams)) {
            const paramValue = typeof value === 'function' ? value() : value;
            resultUrl = resultUrl.replace(`{${key}}`, encodeURIComponent(paramValue));
        }
        
        // Replace any remaining placeholders with empty strings
        resultUrl = resultUrl.replace(/\{[^{}]+\}/g, '');
        
        return resultUrl;
    }
    
    /**
     * Finds a page class by URL
     * 
     * @param url The URL to match
     * @returns The matching page class or undefined
     */
    public static findPageClassByUrl(url: string): any | undefined {
        return PageRegistry.getInstance().findPageByUrl(url);
    }
    
    /**
     * Finds page classes by tags
     * 
     * @param tags The tags to match
     * @param matchAll Whether all tags must match (default: false)
     * @returns Array of matching page classes
     */
    public static findPageClassesByTags(tags: string[], matchAll: boolean = false): any[] {
        const allPages = PageRegistry.getInstance().getAllMetadata();
        const result: any[] = [];
        
        for (const [className, metadata] of allPages.entries()) {
            if (!metadata.tags || metadata.tags.length === 0) {
                continue;
            }
            
            const pageTags = metadata.tags;
            
            if (matchAll) {
                // All specified tags must be present
                const allTagsPresent = tags.every(tag => pageTags.includes(tag));
                
                if (allTagsPresent) {
                    const pageClass = PageRegistry.getInstance().getPageClass(className);
                    if (pageClass) {
                        result.push(pageClass);
                    }
                }
            } else {
                // At least one tag must be present
                const anyTagPresent = tags.some(tag => pageTags.includes(tag));
                
                if (anyTagPresent) {
                    const pageClass = PageRegistry.getInstance().getPageClass(className);
                    if (pageClass) {
                        result.push(pageClass);
                    }
                }
            }
        }
        
        return result;
    }
    
    /**
     * Creates a verification function for a page
     * 
     * @param pageClass The page class
     * @returns A function that verifies the page is loaded
     */
    public static createVerificationFunction(pageClass: any): (page: CSBasePage) => Promise<boolean> {
        const metadata = this.getPageMetadata(pageClass);
        
        return async (page: CSBasePage): Promise<boolean> => {
            // If custom verification method is specified
            if (metadata.customVerification && typeof page[metadata.customVerification] === 'function') {
                try {
                    return await page[metadata.customVerification]();
                } catch (error) {
                    CSLogger.error(`Custom verification failed: ${error.message}`);
                    return false;
                }
            }
            
            try {
                // Title verification
                if (metadata.title) {
                    const actualTitle = await page.getDriver().getTitle();
                    
                    if (typeof metadata.title === 'string') {
                        if (actualTitle !== metadata.title) {
                            CSLogger.debug(`Title verification failed. Expected: ${metadata.title}, Actual: ${actualTitle}`);
                            return false;
                        }
                    } else if (metadata.title instanceof RegExp) {
                        if (!metadata.title.test(actualTitle)) {
                            CSLogger.debug(`Title verification failed. Expected pattern: ${metadata.title}, Actual: ${actualTitle}`);
                            return false;
                        }
                    }
                }
                
                // Verification element check
                if (metadata.verificationElement) {
                    const timeout = metadata.verificationTimeout || 10000;
                    
                    try {
                        const element: CSElementType = await page.waitForElement(
                            metadata.verificationElement,
                            timeout
                        );
                        
                        return element !== null && element !== undefined;
                    } catch (error) {
                        CSLogger.debug(`Verification element check failed: ${error.message}`);
                        return false;
                    }
                }
                
                // If no specific verification criteria are defined, assume the page is loaded
                return true;
            } catch (error) {
                CSLogger.error(`Page verification failed: ${error.message}`);
                return false;
            }
        };
    }
    
    /**
     * Gets all registered pages
     * 
     * @returns Map of page names to classes
     */
    public static getAllPages(): Map<string, any> {
        return PageRegistry.getInstance().getAllPageClasses();
    }
}



CSTextWait.ts
----------------------

import { WebDriver, WebElement, By, until, Condition } from 'selenium-webdriver';
import { CSWaitStrategy } from './CSWaitStrategy';
import { CSAbstractWaitStrategy } from './CSAbstractWaitStrategy';
import { CSLogger } from '../../core/utils/CSLogger';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { WaitTimeoutException } from '../../core/exceptions/WaitTimeoutException';

/**
 * Wait strategy for waiting until an element contains specific text.
 * Supports exact match, partial match, regex pattern match, and case-insensitive options.
 */
export class CSTextWait extends CSAbstractWaitStrategy implements CSWaitStrategy {
    /**
     * The expected text for exact match.
     */
    private exactText?: string;

    /**
     * The expected text for partial match.
     */
    private partialText?: string;

    /**
     * The regex pattern for pattern match.
     */
    private textPattern?: RegExp;

    /**
     * Whether the match should be case-insensitive.
     */
    private caseInsensitive: boolean = false;

    /**
     * Whether to trim the text before comparison.
     */
    private trimText: boolean = true;

    /**
     * Whether to normalize whitespace in the text before comparison.
     */
    private normalizeWhitespace: boolean = false;

    /**
     * Whether to wait for text to be present or absent.
     */
    private waitForAbsence: boolean = false;

    /**
     * Creates a new CSTextWait instance.
     * 
     * @param driver The WebDriver instance
     * @param timeout The timeout in milliseconds
     * @param pollingInterval The polling interval in milliseconds
     */
    constructor(driver: WebDriver, timeout: number = 30000, pollingInterval: number = 500) {
        super(driver, timeout, pollingInterval);
    }

    /**
     * Sets the exact text to wait for.
     * 
     * @param text The exact text
     * @returns This wait strategy for method chaining
     */
    public withExactText(text: string): CSTextWait {
        this.exactText = text;
        this.partialText = undefined;
        this.textPattern = undefined;
        return this;
    }

    /**
     * Sets the partial text to wait for.
     * 
     * @param text The partial text
     * @returns This wait strategy for method chaining
     */
    public withPartialText(text: string): CSTextWait {
        this.partialText = text;
        this.exactText = undefined;
        this.textPattern = undefined;
        return this;
    }

    /**
     * Sets the text pattern to wait for.
     * 
     * @param pattern The regex pattern
     * @returns This wait strategy for method chaining
     */
    public withTextPattern(pattern: RegExp): CSTextWait {
        this.textPattern = pattern;
        this.exactText = undefined;
        this.partialText = undefined;
        return this;
    }

    /**
     * Sets whether the match should be case-insensitive.
     * 
     * @param caseInsensitive Whether the match should be case-insensitive
     * @returns This wait strategy for method chaining
     */
    public setCaseInsensitive(caseInsensitive: boolean = true): CSTextWait {
        this.caseInsensitive = caseInsensitive;
        return this;
    }

    /**
     * Sets whether to trim the text before comparison.
     * 
     * @param trimText Whether to trim the text
     * @returns This wait strategy for method chaining
     */
    public setTrimText(trimText: boolean = true): CSTextWait {
        this.trimText = trimText;
        return this;
    }

    /**
     * Sets whether to normalize whitespace in the text before comparison.
     * 
     * @param normalizeWhitespace Whether to normalize whitespace
     * @returns This wait strategy for method chaining
     */
    public setNormalizeWhitespace(normalizeWhitespace: boolean = true): CSTextWait {
        this.normalizeWhitespace = normalizeWhitespace;
        return this;
    }

    /**
     * Sets whether to wait for text to be present or absent.
     * 
     * @param waitForAbsence Whether to wait for text to be absent
     * @returns This wait strategy for method chaining
     */
    public setWaitForAbsence(waitForAbsence: boolean = true): CSTextWait {
        this.waitForAbsence = waitForAbsence;
        return this;
    }

    /**
     * Waits for an element's text to meet the specified condition.
     * 
     * @param locator The element locator
     * @returns Promise resolving to the element
     * @throws ElementNotFoundException if the element is not found
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForElement(locator: By): Promise<WebElement> {
        if (!this.exactText && !this.partialText && !this.textPattern) {
            throw new Error('No text condition specified. Call withExactText, withPartialText, or withTextPattern first.');
        }

        try {
            // First, wait for element to be present in the DOM
            const element = await this.waitForElementPresence(locator);

            // Then, wait for text condition
            await this.waitUntil(async () => {
                try {
                    const text = await element.getText();
                    return this.checkTextCondition(text);
                } catch (error) {
                    CSLogger.debug(`Error while checking text: ${error.message}`);
                    return false;
                }
            }, `Element text condition: ${this.getTextConditionDescription()}`);

            return element;
        } catch (error) {
            if (error instanceof WaitTimeoutException) {
                throw new WaitTimeoutException(
                    `Timed out waiting for element text condition: ${this.getTextConditionDescription()}`,
                    error
                );
            }
            
            throw error;
        }
    }

    /**
     * Waits for an element's text to meet the specified condition.
     * 
     * @param element The WebElement
     * @returns Promise resolving to the element
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForElementText(element: WebElement): Promise<WebElement> {
        if (!this.exactText && !this.partialText && !this.textPattern) {
            throw new Error('No text condition specified. Call withExactText, withPartialText, or withTextPattern first.');
        }

        try {
            await this.waitUntil(async () => {
                try {
                    const text = await element.getText();
                    return this.checkTextCondition(text);
                } catch (error) {
                    CSLogger.debug(`Error while checking text: ${error.message}`);
                    return false;
                }
            }, `Element text condition: ${this.getTextConditionDescription()}`);

            return element;
        } catch (error) {
            throw new WaitTimeoutException(
                `Timed out waiting for element text condition: ${this.getTextConditionDescription()}`,
                error
            );
        }
    }

    /**
     * Waits for an element's text to meet the specified condition, using a custom text retrieval function.
     * 
     * @param element The WebElement
     * @param textRetriever Function to retrieve text (useful for getting text from specific attributes)
     * @returns Promise resolving to the element
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForElementTextWithRetriever(
        element: WebElement,
        textRetriever: (element: WebElement) => Promise<string>
    ): Promise<WebElement> {
        if (!this.exactText && !this.partialText && !this.textPattern) {
            throw new Error('No text condition specified. Call withExactText, withPartialText, or withTextPattern first.');
        }

        try {
            await this.waitUntil(async () => {
                try {
                    const text = await textRetriever(element);
                    return this.checkTextCondition(text);
                } catch (error) {
                    CSLogger.debug(`Error while checking text with custom retriever: ${error.message}`);
                    return false;
                }
            }, `Element text condition with custom retriever: ${this.getTextConditionDescription()}`);

            return element;
        } catch (error) {
            throw new WaitTimeoutException(
                `Timed out waiting for element text condition with custom retriever: ${this.getTextConditionDescription()}`,
                error instanceof Error ? error : new Error(String(error))
            );
        }
    }

    /**
     * Waits for an element's attribute to meet the specified text condition.
     * 
     * @param locator The element locator
     * @param attributeName The attribute name
     * @returns Promise resolving to the element
     * @throws ElementNotFoundException if the element is not found
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForElementAttribute(locator: By, attributeName: string): Promise<WebElement> {
        if (!this.exactText && !this.partialText && !this.textPattern) {
            throw new Error('No text condition specified. Call withExactText, withPartialText, or withTextPattern first.');
        }

        try {
            // First, wait for element to be present in the DOM
            const element = await this.waitForElementPresence(locator);

            // Then, wait for attribute text condition
            await this.waitUntil(async () => {
                try {
                    const attributeValue = await element.getAttribute(attributeName);
                    
                    if (attributeValue === null) {
                        return this.waitForAbsence; // If waiting for absence, null is a match
                    }

                    return this.checkTextCondition(attributeValue);
                } catch (error) {
                    CSLogger.debug(`Error while checking attribute text: ${error.message}`);
                    return false;
                }
            }, `Element attribute '${attributeName}' text condition: ${this.getTextConditionDescription()}`);

            return element;
        } catch (error) {
            if (error instanceof WaitTimeoutException) {
                throw new WaitTimeoutException(
                    `Timed out waiting for element attribute '${attributeName}' text condition: ${this.getTextConditionDescription()}`,
                    error
                );
            }
            
            throw error;
        }
    }

    /**
     * Waits for an element's property to meet the specified text condition.
     * 
     * @param locator The element locator
     * @param propertyName The property name
     * @returns Promise resolving to the element
     * @throws ElementNotFoundException if the element is not found
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForElementProperty(locator: By, propertyName: string): Promise<WebElement> {
        if (!this.exactText && !this.partialText && !this.textPattern) {
            throw new Error('No text condition specified. Call withExactText, withPartialText, or withTextPattern first.');
        }

        try {
            // First, wait for element to be present in the DOM
            const element = await this.waitForElementPresence(locator);

            // Then, wait for property text condition
            await this.waitUntil(async () => {
                try {
                    const propertyValue = await this.driver.executeScript(
                        `return arguments[0].${propertyName}`,
                        element
                    );
                    
                    if (propertyValue === null || propertyValue === undefined) {
                        return this.waitForAbsence; // If waiting for absence, null/undefined is a match
                    }

                    return this.checkTextCondition(String(propertyValue));
                } catch (error) {
                    CSLogger.debug(`Error while checking property text: ${error.message}`);
                    return false;
                }
            }, `Element property '${propertyName}' text condition: ${this.getTextConditionDescription()}`);

            return element;
        } catch (error) {
            if (error instanceof WaitTimeoutException) {
                throw new WaitTimeoutException(
                    `Timed out waiting for element property '${propertyName}' text condition: ${this.getTextConditionDescription()}`,
                    error
                );
            }
            
            throw error;
        }
    }

    /**
     * Waits for a page's title to meet the specified text condition.
     * 
     * @returns Promise resolving to true when the condition is met
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForPageTitle(): Promise<boolean> {
        if (!this.exactText && !this.partialText && !this.textPattern) {
            throw new Error('No text condition specified. Call withExactText, withPartialText, or withTextPattern first.');
        }

        try {
            return await this.waitUntil(async () => {
                try {
                    const title = await this.driver.getTitle();
                    return this.checkTextCondition(title);
                } catch (error) {
                    CSLogger.debug(`Error while checking page title: ${error.message}`);
                    return false;
                }
            }, `Page title condition: ${this.getTextConditionDescription()}`);
        } catch (error) {
            throw new WaitTimeoutException(
                `Timed out waiting for page title condition: ${this.getTextConditionDescription()}`,
                error instanceof Error ? error : new Error(String(error))
            );
        }
    }

    /**
     * Waits for a page's URL to meet the specified text condition.
     * 
     * @returns Promise resolving to true when the condition is met
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForPageUrl(): Promise<boolean> {
        if (!this.exactText && !this.partialText && !this.textPattern) {
            throw new Error('No text condition specified. Call withExactText, withPartialText, or withTextPattern first.');
        }

        try {
            return await this.waitUntil(async () => {
                try {
                    const url = await this.driver.getCurrentUrl();
                    return this.checkTextCondition(url);
                } catch (error) {
                    CSLogger.debug(`Error while checking page URL: ${error.message}`);
                    return false;
                }
            }, `Page URL condition: ${this.getTextConditionDescription()}`);
        } catch (error) {
            throw new WaitTimeoutException(
                `Timed out waiting for page URL condition: ${this.getTextConditionDescription()}`,
                error instanceof Error ? error : new Error(String(error))
            );
        }
    }

    /**
     * Creates a Selenium Condition for text waiting.
     * 
     * @returns The Selenium Condition
     */
    public toSeleniumCondition(): Condition<boolean> {
        return new Condition<boolean>(
            this.getTextConditionDescription(),
            async (driver: WebDriver) => {
                if (this.element) {
                    try {
                        const text = await this.element.getText();
                        return this.checkTextCondition(text);
                    } catch (error) {
                        return false;
                    }
                } else if (this.locator) {
                    try {
                        const elements = await driver.findElements(this.locator);
                        
                        if (elements.length === 0) {
                            return false;
                        }
                        
                        const text = await elements[0].getText();
                        return this.checkTextCondition(text);
                    } catch (error) {
                        return false;
                    }
                }
                
                return false;
            }
        );
    }

    /**
     * Checks if a text meets the specified condition.
     * 
     * @param text The text to check
     * @returns Whether the text meets the condition
     */
    private checkTextCondition(text: string): boolean {
        if (!text && this.waitForAbsence) {
            return true; // Empty text satisfies "absence" condition
        }

        // Prepare the text according to settings
        let preparedText = text;
        
        if (this.trimText) {
            preparedText = preparedText.trim();
        }
        
        if (this.normalizeWhitespace) {
            preparedText = preparedText.replace(/\s+/g, ' ');
        }
        
        if (this.caseInsensitive) {
            preparedText = preparedText.toLowerCase();
        }

        let conditionMet = false;

        // Check the condition
        if (this.exactText !== undefined) {
            let expectedText = this.exactText;
            
            if (this.caseInsensitive) {
                expectedText = expectedText.toLowerCase();
            }
            
            conditionMet = preparedText === expectedText;
        } else if (this.partialText !== undefined) {
            let expectedText = this.partialText;
            
            if (this.caseInsensitive) {
                expectedText = expectedText.toLowerCase();
            }
            
            conditionMet = preparedText.includes(expectedText);
        } else if (this.textPattern !== undefined) {
            conditionMet = this.textPattern.test(preparedText);
        }

        // If waiting for absence, invert the result
        return this.waitForAbsence ? !conditionMet : conditionMet;
    }

    /**
     * Gets a description of the text condition for logging.
     * 
     * @returns The text condition description
     */
    private getTextConditionDescription(): string {
        const conditions: string[] = [];

        if (this.exactText !== undefined) {
            conditions.push(`exact text "${this.exactText}"`);
        } else if (this.partialText !== undefined) {
            conditions.push(`contains text "${this.partialText}"`);
        } else if (this.textPattern !== undefined) {
            conditions.push(`matches pattern ${this.textPattern}`);
        }

        if (this.caseInsensitive) {
            conditions.push('case-insensitive');
        }

        if (this.trimText) {
            conditions.push('trimmed');
        }

        if (this.normalizeWhitespace) {
            conditions.push('normalized whitespace');
        }

        if (this.waitForAbsence) {
            return `does not have ${conditions.join(', ')}`;
        }

        return `has ${conditions.join(', ')}`;
    }

    /**
     * Waits for an element to be present in the DOM.
     * 
     * @param locator The element locator
     * @returns Promise resolving to the element
     * @throws ElementNotFoundException if the element is not found
     */
    private async waitForElementPresence(locator: By): Promise<WebElement> {
        try {
            // We use Selenium's built-in mechanism first to efficiently wait for presence
            return await this.driver.wait(
                until.elementLocated(locator),
                this.timeout,
                `Element not found with locator: ${locator}`
            );
        } catch (error) {
            throw new ElementNotFoundException(
                `Element not found with locator: ${locator}`,
                error instanceof Error ? error : new Error(String(error))
            );
        }
    }
}



PlaywrightManager.ts
------------------------------------------

import * as playwright from 'playwright';
import { Browser, BrowserType, BrowserContext, Page, LaunchOptions, BrowserContextOptions, chromium, firefox, webkit } from 'playwright';
import { CSLogger } from '../../core/utils/CSLogger';
import { ConfigurationManager } from '../../core/config/ConfigurationManager';
import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';
import { CSFileUtils } from '../../core/utils/CSFileUtils';
import { CSPathUtils } from '../../core/utils/CSPathUtils';
import { CSDateUtils } from '../../core/utils/CSDateUtils';
import { BrowserManager } from './BrowserManager';
import { BrowserContextManager } from './BrowserContextManager';
import { PageManager } from './PageManager';
import { LaunchOptionsManager } from './LaunchOptionsManager';
import { InitializationException } from '../../core/exceptions/InitializationException';
import { BrowserNotFoundException } from '../../core/exceptions/BrowserNotFoundException';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import path from 'path';

/**
 * Browser types supported by the framework
 */
export enum BrowserTypes {
    CHROMIUM = 'chromium',
    FIREFOX = 'firefox',
    WEBKIT = 'webkit'
}

/**
 * Interface for browser and context management options
 */
export interface PlaywrightOptions {
    /**
     * Browser type to use
     */
    browserType: BrowserTypes;
    
    /**
     * Launch options for the browser
     */
    launchOptions?: LaunchOptions;
    
    /**
     * Browser context options
     */
    contextOptions?: BrowserContextOptions;
    
    /**
     * Path where traces should be saved
     */
    tracesDir?: string;
    
    /**
     * Path where videos should be saved
     */
    videosDir?: string;
    
    /**
     * Path where screenshots should be saved
     */
    screenshotsDir?: string;
    
    /**
     * Whether to record video
     */
    recordVideo?: boolean;
    
    /**
     * Whether to record traces
     */
    recordTraces?: boolean;
    
    /**
     * Whether to take screenshots on failure
     */
    screenshotOnFailure?: boolean;
    
    /**
     * Default timeout for navigation
     */
    navigationTimeout?: number;
    
    /**
     * Default timeout for actions
     */
    actionTimeout?: number;
    
    /**
     * Default timeout for assertions
     */
    assertionTimeout?: number;
    
    /**
     * Automatic viewport settings
     */
    viewport?: { width: number; height: number };
    
    /**
     * Custom HTTP headers for all requests
     */
    extraHTTPHeaders?: Record<string, string>;
    
    /**
     * Base URL to use for relative URLs
     */
    baseURL?: string;
    
    /**
     * Whether to ignore HTTPS errors
     */
    ignoreHTTPSErrors?: boolean;
    
    /**
     * Device to emulate
     */
    deviceName?: string;
    
    /**
     * Locale to use
     */
    locale?: string;
    
    /**
     * Timezone to use
     */
    timezoneId?: string;
    
    /**
     * Geolocation to use
     */
    geolocation?: { latitude: number; longitude: number; accuracy?: number };
    
    /**
     * User agent to use
     */
    userAgent?: string;
    
    /**
     * Whether to run in headless mode
     */
    headless?: boolean;
    
    /**
     * Directory for downloads
     */
    downloadsPath?: string;
    
    /**
     * Whether to automatically accept downloads
     */
    acceptDownloads?: boolean;
    
    /**
     * Whether to enable JavaScript
     */
    javaScriptEnabled?: boolean;
    
    /**
     * Whether to bypass CSP (Content Security Policy)
     */
    bypassCSP?: boolean;
    
    /**
     * Whether to enable request interception
     */
    interceptRequests?: boolean;
    
    /**
     * Custom environment variables
     */
    env?: Record<string, string>;
    
    /**
     * Slowdown factor for test execution (1 = normal speed)
     */
    slowMo?: number;
}

/**
 * Manager class for Playwright browsers, contexts, and pages
 */
export class PlaywrightManager implements BrowserManager {
    /**
     * Singleton instance
     */
    private static instance: PlaywrightManager;
    
    /**
     * Configuration manager
     */
    private configManager: ConfigurationManager;
    
    /**
     * Active browser instances
     */
    private browsers: Map<string, Browser> = new Map();
    
    /**
     * Active browser contexts
     */
    private contexts: Map<string, BrowserContext> = new Map();
    
    /**
     * Active pages
     */
    private pages: Map<string, Page> = new Map();
    
    /**
     * Current default browser ID
     */
    private defaultBrowserId: string | null = null;
    
    /**
     * Current default context ID
     */
    private defaultContextId: string | null = null;
    
    /**
     * Current default page ID
     */
    private defaultPageId: string | null = null;
    
    /**
     * Browser context manager
     */
    private browserContextManager: BrowserContextManager;
    
    /**
     * Page manager
     */
    private pageManager: PageManager;
    
    /**
     * Launch options manager
     */
    private launchOptionsManager: LaunchOptionsManager;
    
    /**
     * Recording state for traces
     */
    private traceRecording: boolean = false;
    
    /**
     * Current browser options
     */
    private currentOptions: PlaywrightOptions;
    
    /**
     * Private constructor for singleton pattern
     */
    private constructor() {
        this.configManager = ConfigurationManager.getInstance();
        this.currentOptions = this.loadDefaultOptions();
        this.browserContextManager = new BrowserContextManager(this);
        this.pageManager = new PageManager(this);
        this.launchOptionsManager = new LaunchOptionsManager();
        
        CSLogger.debug('PlaywrightManager initialized');
    }
    
    /**
     * Gets the singleton instance
     * 
     * @returns The PlaywrightManager instance
     */
    public static getInstance(): PlaywrightManager {
        if (!PlaywrightManager.instance) {
            PlaywrightManager.instance = new PlaywrightManager();
        }
        
        return PlaywrightManager.instance;
    }
    
    /**
     * Loads default options from configuration
     * 
     * @returns Default PlaywrightOptions
     */
    private loadDefaultOptions(): PlaywrightOptions {
        const config = this.configManager;
        
        return {
            browserType: config.getString('playwright.browser.type', 'chromium') as BrowserTypes,
            headless: config.getBoolean('playwright.browser.headless', true),
            recordVideo: config.getBoolean('playwright.recording.video', false),
            recordTraces: config.getBoolean('playwright.recording.traces', false),
            screenshotOnFailure: config.getBoolean('playwright.screenshot.onFailure', true),
            navigationTimeout: config.getNumber('playwright.timeout.navigation', 30000),
            actionTimeout: config.getNumber('playwright.timeout.action', 10000),
            assertionTimeout: config.getNumber('playwright.timeout.assertion', 5000),
            viewport: {
                width: config.getNumber('playwright.viewport.width', 1280),
                height: config.getNumber('playwright.viewport.height', 720)
            },
            tracesDir: config.getString('playwright.dir.traces', './traces'),
            videosDir: config.getString('playwright.dir.videos', './videos'),
            screenshotsDir: config.getString('playwright.dir.screenshots', './screenshots'),
            slowMo: config.getNumber('playwright.slowMo', 0),
            ignoreHTTPSErrors: config.getBoolean('playwright.ignoreHTTPSErrors', true),
            acceptDownloads: config.getBoolean('playwright.acceptDownloads', true),
            locale: config.getString('playwright.locale', 'en-US'),
            timezoneId: config.getString('playwright.timezoneId', 'UTC'),
            bypassCSP: config.getBoolean('playwright.bypassCSP', false),
            javaScriptEnabled: config.getBoolean('playwright.javaScriptEnabled', true)
        };
    }
    
    /**
     * Launches a new browser instance
     * 
     * @param options Browser options
     * @param browserId Optional browser ID
     * @returns Promise resolving to the browser ID
     * @throws InitializationException if browser launch fails
     */
    public async launchBrowser(options: Partial<PlaywrightOptions> = {}, browserId?: string): Promise<string> {
        try {
            // Generate browser ID if not provided
            const id = browserId || `browser_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
            
            // Merge provided options with defaults
            const mergedOptions: PlaywrightOptions = {
                ...this.currentOptions,
                ...options,
                launchOptions: {
                    ...this.currentOptions.launchOptions,
                    ...options.launchOptions
                },
                contextOptions: {
                    ...this.currentOptions.contextOptions,
                    ...options.contextOptions
                }
            };
            
            // Prepare launch options
            const launchOptions = this.launchOptionsManager.prepareLaunchOptions(mergedOptions);
            
            // Get browser type
            const browserType = this.getBrowserType(mergedOptions.browserType);
            
            // Launch browser
            CSLogger.info(`Launching ${mergedOptions.browserType} browser`);
            const browser = await browserType.launch(launchOptions);
            
            // Store browser
            this.browsers.set(id, browser);
            
            // Set as default if no default exists
            if (this.defaultBrowserId === null) {
                this.defaultBrowserId = id;
            }
            
            CSLogger.info(`Browser launched with ID: ${id}`);
            
            // Create default context
            const contextId = await this.createBrowserContext({
                ...mergedOptions,
                browserType: mergedOptions.browserType
            }, id);
            
            // Return browser ID
            return id;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.error(`Failed to launch browser: ${errorMessage}`);
            throw new InitializationException(`Failed to launch browser: ${errorMessage}`, error instanceof Error ? error : new Error(errorMessage));
        }
    }
    
    /**
     * Creates a new browser context
     * 
     * @param options Context options
     * @param browserId Browser ID (uses default if not provided)
     * @param contextId Optional context ID
     * @returns Promise resolving to the context ID
     * @throws BrowserNotFoundException if the browser is not found
     * @throws InitializationException if context creation fails
     */
    public async createBrowserContext(
        options: Partial<PlaywrightOptions> = {},
        browserId?: string,
        contextId?: string
    ): Promise<string> {
        try {
            // Get browser ID
            const bid = browserId || this.defaultBrowserId;
            
            if (!bid) {
                throw new BrowserNotFoundException('No browser available. Launch a browser first.');
            }
            
            // Get browser
            const browser = this.browsers.get(bid);
            
            if (!browser) {
                throw new BrowserNotFoundException(`Browser with ID '${bid}' not found`);
            }
            
            // Generate context ID if not provided
            const id = contextId || `context_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
            
            // Merge provided options with defaults
            const mergedOptions: PlaywrightOptions = {
                ...this.currentOptions,
                ...options,
                contextOptions: {
                    ...this.currentOptions.contextOptions,
                    ...options.contextOptions
                }
            };
            
            // Prepare context options
            const contextOptions = this.browserContextManager.prepareContextOptions(mergedOptions);
            
            // Create context
            CSLogger.info(`Creating browser context with ID: ${id}`);
            const context = await browser.newContext(contextOptions);
            
            // Configure timeouts
            if (mergedOptions.navigationTimeout) {
                context.setDefaultNavigationTimeout(mergedOptions.navigationTimeout);
            }
            
            if (mergedOptions.actionTimeout) {
                context.setDefaultTimeout(mergedOptions.actionTimeout);
            }
            
            // Store context
            this.contexts.set(id, context);
            
            // Set as default if no default exists
            if (this.defaultContextId === null) {
                this.defaultContextId = id;
            }
            
            // Start tracing if enabled
            if (mergedOptions.recordTraces) {
                const tracesDir = mergedOptions.tracesDir || './traces';
                const traceFileName = `trace_${CSDateUtils.getCurrentTimeFormatted()}.zip`;
                const tracePath = path.join(tracesDir, traceFileName);
                
                // Ensure directory exists
                await CSFileUtils.ensureDirectoryExists(tracesDir);
                
                await context.tracing.start({
                    screenshots: true,
                    snapshots: true,
                    sources: true,
                    title: `Trace_${CSDateUtils.getCurrentDateFormatted()}`
                });
                
                this.traceRecording = true;
                
                CSLogger.info(`Started trace recording to ${tracePath}`);
            }
            
            // Create default page
            const pageId = await this.createPage({}, id);
            
            return id;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.error(`Failed to create browser context: ${errorMessage}`);
            
            if (error instanceof BrowserNotFoundException) {
                throw error;
            }
            
            throw new InitializationException(`Failed to create browser context: ${errorMessage}`, error instanceof Error ? error : new Error(errorMessage));
        }
    }
    
    /**
     * Creates a new page
     * 
     * @param options Page options
     * @param contextId Context ID (uses default if not provided)
     * @param pageId Optional page ID
     * @returns Promise resolving to the page ID
     * @throws BrowserNotFoundException if the context is not found
     * @throws InitializationException if page creation fails
     */
    public async createPage(
        options: Partial<PlaywrightOptions> = {},
        contextId?: string,
        pageId?: string
    ): Promise<string> {
        try {
            // Get context ID
            const cid = contextId || this.defaultContextId;
            
            if (!cid) {
                throw new BrowserNotFoundException('No browser context available. Create a context first.');
            }
            
            // Get context
            const context = this.contexts.get(cid);
            
            if (!context) {
                throw new BrowserNotFoundException(`Browser context with ID '${cid}' not found`);
            }
            
            // Generate page ID if not provided
            const id = pageId || `page_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
            
            // Merge provided options with defaults
            const mergedOptions: PlaywrightOptions = {
                ...this.currentOptions,
                ...options
            };
            
            // Create page
            CSLogger.info(`Creating page with ID: ${id}`);
            const page = await context.newPage();
            
            // Configure timeouts
            if (mergedOptions.navigationTimeout) {
                page.setDefaultNavigationTimeout(mergedOptions.navigationTimeout);
            }
            
            if (mergedOptions.actionTimeout) {
                page.setDefaultTimeout(mergedOptions.actionTimeout);
            }
            
            // Add event listeners for error handling and logging
            page.on('console', message => {
                const type = message.type();
                const text = message.text();
                
                switch (type) {
                    case 'error':
                        CSLogger.error(`Browser console error: ${text}`);
                        break;
                    case 'warning':
                        CSLogger.warn(`Browser console warning: ${text}`);
                        break;
                    default:
                        CSLogger.debug(`Browser console [${type}]: ${text}`);
                        break;
                }
            });
            
            page.on('pageerror', error => {
                CSLogger.error(`Page error: ${error.message}`);
            });
            
            page.on('crash', () => {
                CSLogger.error(`Page crashed: ${id}`);
            });
            
            page.on('requestfailed', request => {
                CSLogger.warn(`Request failed: ${request.url()}, ${request.failure()?.errorText || 'unknown error'}`);
            });
            
            // Store page
            this.pages.set(id, page);
            
            // Set as default if no default exists
            if (this.defaultPageId === null) {
                this.defaultPageId = id;
            }
            
            return id;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.error(`Failed to create page: ${errorMessage}`);
            
            if (error instanceof BrowserNotFoundException) {
                throw error;
            }
            
            throw new InitializationException(`Failed to create page: ${errorMessage}`, error instanceof Error ? error : new Error(errorMessage));
        }
    }
    
    /**
     * Gets a browser instance by ID
     * 
     * @param browserId Browser ID (uses default if not provided)
     * @returns The browser instance
     * @throws BrowserNotFoundException if the browser is not found
     */
    public getBrowser(browserId?: string): Browser {
        const id = browserId || this.defaultBrowserId;
        
        if (!id) {
            throw new BrowserNotFoundException('No browser available. Launch a browser first.');
        }
        
        const browser = this.browsers.get(id);
        
        if (!browser) {
            throw new BrowserNotFoundException(`Browser with ID '${id}' not found`);
        }
        
        return browser;
    }
    
    /**
     * Gets a browser context by ID
     * 
     * @param contextId Context ID (uses default if not provided)
     * @returns The browser context
     * @throws BrowserNotFoundException if the context is not found
     */
    public getBrowserContext(contextId?: string): BrowserContext {
        const id = contextId || this.defaultContextId;
        
        if (!id) {
            throw new BrowserNotFoundException('No browser context available. Create a context first.');
        }
        
        const context = this.contexts.get(id);
        
        if (!context) {
            throw new BrowserNotFoundException(`Browser context with ID '${id}' not found`);
        }
        
        return context;
    }
    
    /**
     * Gets a page by ID
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns The page
     * @throws BrowserNotFoundException if the page is not found
     */
    public getPage(pageId?: string): Page {
        const id = pageId || this.defaultPageId;
        
        if (!id) {
            throw new BrowserNotFoundException('No page available. Create a page first.');
        }
        
        const page = this.pages.get(id);
        
        if (!page) {
            throw new BrowserNotFoundException(`Page with ID '${id}' not found`);
        }
        
        return page;
    }
    
    /**
     * Navigates to a URL
     * 
     * @param url The URL to navigate to
     * @param options Navigation options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the navigation response
     * @throws BrowserNotFoundException if the page is not found
     */
    public async navigate(
        url: string,
        options?: playwright.Page.GotoOptions,
        pageId?: string
    ): Promise<playwright.Response | null> {
        try {
            const page = this.getPage(pageId);
            
            CSLogger.info(`Navigating to: ${url}`);
            return await page.goto(url, options);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.error(`Failed to navigate to ${url}: ${errorMessage}`);
            
            if (error instanceof BrowserNotFoundException) {
                throw error;
            }
            
            throw new Error(`Failed to navigate to ${url}: ${errorMessage}`);
        }
    }
    
    /**
     * Closes a page
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when the page is closed
     */
    public async closePage(pageId?: string): Promise<void> {
        try {
            const id = pageId || this.defaultPageId;
            
            if (!id) {
                return;
            }
            
            const page = this.pages.get(id);
            
            if (!page) {
                return;
            }
            
            // Close page
            CSLogger.info(`Closing page: ${id}`);
            await page.close();
            
            // Remove from pages map
            this.pages.delete(id);
            
            // Update default page ID if needed
            if (id === this.defaultPageId) {
                this.defaultPageId = this.pages.size > 0 ? Array.from(this.pages.keys())[0] : null;
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.warn(`Error closing page: ${errorMessage}`);
        }
    }
    
    /**
     * Closes a browser context
     * 
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when the context is closed
     */
    public async closeBrowserContext(contextId?: string): Promise<void> {
        try {
            const id = contextId || this.defaultContextId;
            
            if (!id) {
                return;
            }
            
            const context = this.contexts.get(id);
            
            if (!context) {
                return;
            }
            
            // Save trace if tracing is enabled
            if (this.traceRecording) {
                try {
                    const tracesDir = this.currentOptions.tracesDir || './traces';
                    const traceFileName = `trace_${CSDateUtils.getCurrentTimeFormatted()}.zip`;
                    const tracePath = path.join(tracesDir, traceFileName);
                    
                    // Ensure directory exists
                    await CSFileUtils.ensureDirectoryExists(tracesDir);
                    
                    await context.tracing.stop({ path: tracePath });
                    CSLogger.info(`Trace saved to: ${tracePath}`);
                } catch (traceError) {
                    CSLogger.warn(`Failed to save trace: ${traceError.message}`);
                }
                
                this.traceRecording = false;
            }
            
            // Close all pages associated with this context
            for (const [pageId, page] of this.pages.entries()) {
                if (page.context() === context) {
                    await this.closePage(pageId);
                }
            }
            
            // Close context
            CSLogger.info(`Closing browser context: ${id}`);
            await context.close();
            
            // Remove from contexts map
            this.contexts.delete(id);
            
            // Update default context ID if needed
            if (id === this.defaultContextId) {
                this.defaultContextId = this.contexts.size > 0 ? Array.from(this.contexts.keys())[0] : null;
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.warn(`Error closing browser context: ${errorMessage}`);
        }
    }
    
    /**
     * Closes a browser
     * 
     * @param browserId Browser ID (uses default if not provided)
     * @returns Promise resolving when the browser is closed
     */
    public async closeBrowser(browserId?: string): Promise<void> {
        try {
            const id = browserId || this.defaultBrowserId;
            
            if (!id) {
                return;
            }
            
            const browser = this.browsers.get(id);
            
            if (!browser) {
                return;
            }
            
            // Close all contexts associated with this browser
            for (const [contextId, context] of this.contexts.entries()) {
                if (context.browser() === browser) {
                    await this.closeBrowserContext(contextId);
                }
            }
            
            // Close browser
            CSLogger.info(`Closing browser: ${id}`);
            await browser.close();
            
            // Remove from browsers map
            this.browsers.delete(id);
            
            // Update default browser ID if needed
            if (id === this.defaultBrowserId) {
                this.defaultBrowserId = this.browsers.size > 0 ? Array.from(this.browsers.keys())[0] : null;
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.warn(`Error closing browser: ${errorMessage}`);
        }
    }
    
    /**
     * Closes all browsers, contexts, and pages
     * 
     * @returns Promise resolving when all browsers are closed
     */
    public async closeAll(): Promise<void> {
        try {
            // Close all browsers
            for (const browserId of this.browsers.keys()) {
                await this.closeBrowser(browserId);
            }
            
            // Clear all maps and default IDs
            this.browsers.clear();
            this.contexts.clear();
            this.pages.clear();
            this.defaultBrowserId = null;
            this.defaultContextId = null;
            this.defaultPageId = null;
            
            CSLogger.info('All browsers, contexts, and pages closed');
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.warn(`Error closing all browsers: ${errorMessage}`);
        }
    }
    
    /**
     * Takes a screenshot
     * 
     * @param name Screenshot name (optional)
     * @param options Screenshot options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the screenshot path
     * @throws BrowserNotFoundException if the page is not found
     */
    public async takeScreenshot(
        name?: string,
        options?: playwright.Page.ScreenshotOptions,
        pageId?: string
    ): Promise<string> {
        try {
            const page = this.getPage(pageId);
            
            // Generate screenshot name if not provided
            const screenshotName = name || `screenshot_${CSDateUtils.getCurrentTimeFormatted()}`;
            
            // Ensure screenshots directory exists
            const screenshotsDir = this.currentOptions.screenshotsDir || './screenshots';
            await CSFileUtils.ensureDirectoryExists(screenshotsDir);
            
            // Generate screenshot path
            const screenshotPath = path.join(
                screenshotsDir,
                `${screenshotName}.png`
            );
            
            // Take screenshot
            CSLogger.info(`Taking screenshot: ${screenshotPath}`);
            await page.screenshot({
                path: screenshotPath,
                fullPage: true,
                ...options
            });
            
            return screenshotPath;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.error(`Failed to take screenshot: ${errorMessage}`);
            
            if (error instanceof BrowserNotFoundException) {
                throw error;
            }
            
            throw new Error(`Failed to take screenshot: ${errorMessage}`);
        }
    }
    
    /**
     * Sets the default browser
     * 
     * @param browserId Browser ID
     * @throws BrowserNotFoundException if the browser is not found
     */
    public setDefaultBrowser(browserId: string): void {
        if (!this.browsers.has(browserId)) {
            throw new BrowserNotFoundException(`Browser with ID '${browserId}' not found`);
        }
        
        this.defaultBrowserId = browserId;
    }
    
    /**
     * Sets the default browser context
     * 
     * @param contextId Context ID
     * @throws BrowserNotFoundException if the context is not found
     */
    public setDefaultBrowserContext(contextId: string): void {
        if (!this.contexts.has(contextId)) {
            throw new BrowserNotFoundException(`Browser context with ID '${contextId}' not found`);
        }
        
        this.defaultContextId = contextId;
    }
    
    /**
     * Sets the default page
     * 
     * @param pageId Page ID
     * @throws BrowserNotFoundException if the page is not found
     */
    public setDefaultPage(pageId: string): void {
        if (!this.pages.has(pageId)) {
            throw new BrowserNotFoundException(`Page with ID '${pageId}' not found`);
        }
        
        this.defaultPageId = pageId;
    }
    
    /**
     * Sets browser options
     * 
     * @param options Browser options
     */
    public setOptions(options: Partial<PlaywrightOptions>): void {
        this.currentOptions = {
            ...this.currentOptions,
            ...options,
            launchOptions: {
                ...this.currentOptions.launchOptions,
                ...options.launchOptions
            },
            contextOptions: {
                ...this.currentOptions.contextOptions,
                ...options.contextOptions
            }
        };
    }
    
    /**
     * Gets current browser options
     * 
     * @returns Current browser options
     */
    public getOptions(): PlaywrightOptions {
        return { ...this.currentOptions };
    }
    
    /**
     * Gets browser IDs
     * 
     * @returns Array of browser IDs
     */
    public getBrowserIds(): string[] {
        return Array.from(this.browsers.keys());
    }
    
    /**
     * Gets context IDs
     * 
     * @returns Array of context IDs
     */
    public getContextIds(): string[] {
        return Array.from(this.contexts.keys());
    }
    
    /**
     * Gets page IDs
     * 
     * @returns Array of page IDs
     */
    public getPageIds(): string[] {
        return Array.from(this.pages.keys());
    }
    
    /**
     * Gets Playwright browser type
     * 
     * @param type Browser type
     * @returns Playwright browser type
     */
    private getBrowserType(type: BrowserTypes): BrowserType {
        switch (type) {
            case BrowserTypes.CHROMIUM:
                return chromium;
            case BrowserTypes.FIREFOX:
                return firefox;
            case BrowserTypes.WEBKIT:
                return webkit;
            default:
                return chromium;
        }
    }
    
    /**
     * Starts recording a trace
     * 
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when recording starts
     * @throws BrowserNotFoundException if the context is not found
     */
    public async startTraceRecording(contextId?: string): Promise<void> {
        try {
            const context = this.getBrowserContext(contextId);
            const tracesDir = this.currentOptions.tracesDir || './traces';
            
            // Ensure directory exists
            await CSFileUtils.ensureDirectoryExists(tracesDir);
            
            await context.tracing.start({
                screenshots: true,
                snapshots: true,
                sources: true,
                title: `Trace_${CSDateUtils.getCurrentDateFormatted()}`
            });
            
            this.traceRecording = true;
            
            CSLogger.info('Started trace recording');
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.error(`Failed to start trace recording: ${errorMessage}`);
            
            if (error instanceof BrowserNotFoundException) {
                throw error;
            }
            
            throw new Error(`Failed to start trace recording: ${errorMessage}`);
        }
    }
    
    /**
     * Stops recording a trace
     * 
     * @param name Trace name (optional)
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving to the trace path
     * @throws BrowserNotFoundException if the context is not found
     */
    public async stopTraceRecording(name?: string, contextId?: string): Promise<string> {
        try {
            const context = this.getBrowserContext(contextId);
            
            // Generate trace name if not provided
            const traceName = name || `trace_${CSDateUtils.getCurrentTimeFormatted()}`;
            
            // Ensure traces directory exists
            const tracesDir = this.currentOptions.tracesDir || './traces';
            await CSFileUtils.ensureDirectoryExists(tracesDir);
            
            // Generate trace path
            const tracePath = path.join(
                tracesDir,
                `${traceName}.zip`
            );
            
            // Stop trace recording
            await context.tracing.stop({ path: tracePath });
            
            this.traceRecording = false;
            
            CSLogger.info(`Trace saved to: ${tracePath}`);
            
            return tracePath;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.error(`Failed to stop trace recording: ${errorMessage}`);
            
            if (error instanceof BrowserNotFoundException) {
                throw error;
            }
            
            throw new Error(`Failed to stop trace recording: ${errorMessage}`);
        }
    }
    
    /**
     * Executes a callback with a browser, context, and page
     * 
     * @param callback The callback to execute
     * @param options Browser options
     * @returns Promise resolving to the callback result
     */
    public async withBrowser<T>(
        callback: (page: Page, context: BrowserContext, browser: Browser) => Promise<T>,
        options: Partial<PlaywrightOptions> = {}
    ): Promise<T> {
        let browserId: string | null = null;
        
        try {
            // Launch browser
            browserId = await this.launchBrowser(options);
            
            // Get browser, context, and page
            const browser = this.getBrowser(browserId);
            const contextId = this.getContextIds().find(id => {
                const context = this.contexts.get(id);
                return context && context.browser() === browser;
            });
            
            if (!contextId) {
                throw new BrowserNotFoundException('No context found for browser');
            }
            
            const context = this.getBrowserContext(contextId);
            
            const pageId = this.getPageIds().find(id => {
                const page = this.pages.get(id);
                return page && page.context() === context;
            });
            
            if (!pageId) {
                throw new BrowserNotFoundException('No page found for context');
            }
            
            const page = this.getPage(pageId);
            
            // Execute callback
            return await callback(page, context, browser);
        } finally {
            // Close browser
            if (browserId) {
                await this.closeBrowser(browserId);
            }
        }
    }
    
    /**
     * Gets the browserContextManager instance
     * 
     * @returns The browserContextManager instance
     */
    public getBrowserContextManager(): BrowserContextManager {
        return this.browserContextManager;
    }
    
    /**
     * Gets the pageManager instance
     * 
     * @returns The pageManager instance
     */
    public getPageManager(): PageManager {
        return this.pageManager;
    }
    
    /**
     * Gets the launchOptionsManager instance
     * 
     * @returns The launchOptionsManager instance
     */
    public getLaunchOptionsManager(): LaunchOptionsManager {
        return this.launchOptionsManager;
    }
    
    /**
     * Creates a device context with specific device emulation
     * 
     * @param deviceName Device name from playwright devices
     * @param options Additional options
     * @param browserId Browser ID (uses default if not provided)
     * @returns Promise resolving to the context ID
     */
    public async createDeviceContext(
        deviceName: string,
        options: Partial<PlaywrightOptions> = {},
        browserId?: string
    ): Promise<string> {
        try {
            // Get browser ID
            const bid = browserId || this.defaultBrowserId;
            
            if (!bid) {
                throw new BrowserNotFoundException('No browser available. Launch a browser first.');
            }
            
            // Get browser
            const browser = this.browsers.get(bid);
            
            if (!browser) {
                throw new BrowserNotFoundException(`Browser with ID '${bid}' not found`);
            }
            
            // Get device
            const devices = playwright.devices;
            const device = devices[deviceName];
            
            if (!device) {
                throw new Error(`Device '${deviceName}' not found in Playwright devices`);
            }
            
            // Generate context ID
            const id = `context_${deviceName}_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
            
            // Merge device options with provided options
            const mergedOptions: playwright.BrowserContextOptions = {
                ...device,
                ...options.contextOptions
            };
            
            // Create context
            CSLogger.info(`Creating device context for '${deviceName}' with ID: ${id}`);
            const context = await browser.newContext(mergedOptions);
            
            // Configure timeouts
            if (options.navigationTimeout) {
                context.setDefaultNavigationTimeout(options.navigationTimeout);
            }
            
            if (options.actionTimeout) {
                context.setDefaultTimeout(options.actionTimeout);
            }
            
            // Store context
            this.contexts.set(id, context);
            
            // Set as default
            this.defaultContextId = id;
            
            // Create default page
            const pageId = await this.createPage({}, id);
            
            return id;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            CSLogger.error(`Failed to create device context: ${errorMessage}`);
            
            if (error instanceof BrowserNotFoundException) {
                throw error;
            }
            
            throw new InitializationException(`Failed to create device context: ${errorMessage}`, error instanceof Error ? error : new Error(errorMessage));
        }
    }
}




BrowserContextManager.ts
-------------------------------------

import { BrowserContext, BrowserContextOptions, devices } from 'playwright';
import { PlaywrightOptions, BrowserTypes } from './PlaywrightManager';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSFileUtils } from '../../core/utils/CSFileUtils';
import { ConfigurationManager } from '../../core/config/ConfigurationManager';
import path from 'path';

/**
 * Manager class for Playwright browser contexts
 */
export class BrowserContextManager {
    /**
     * The parent PlaywrightManager instance
     */
    private playwrightManager: any; // Using any to avoid circular dependency
    
    /**
     * Configuration manager
     */
    private configManager: ConfigurationManager;
    
    /**
     * Device profiles from Playwright
     */
    private deviceProfiles: Record<string, any> = devices;
    
    /**
     * Creates a new BrowserContextManager instance
     * 
     * @param playwrightManager The parent PlaywrightManager instance
     */
    constructor(playwrightManager: any) {
        this.playwrightManager = playwrightManager;
        this.configManager = ConfigurationManager.getInstance();
        
        CSLogger.debug('BrowserContextManager initialized');
    }
    
    /**
     * Prepares browser context options from PlaywrightOptions
     * 
     * @param options PlaywrightOptions
     * @returns BrowserContextOptions
     */
    public prepareContextOptions(options: PlaywrightOptions): BrowserContextOptions {
        // Start with base options from PlaywrightOptions.contextOptions
        const contextOptions: BrowserContextOptions = {
            ...(options.contextOptions || {})
        };
        
        // Add viewport settings if provided
        if (options.viewport) {
            contextOptions.viewport = options.viewport;
        }
        
        // Add locale if provided
        if (options.locale) {
            contextOptions.locale = options.locale;
        }
        
        // Add timezone if provided
        if (options.timezoneId) {
            contextOptions.timezoneId = options.timezoneId;
        }
        
        // Add geolocation if provided
        if (options.geolocation) {
            contextOptions.geolocation = options.geolocation;
        }
        
        // Add user agent if provided
        if (options.userAgent) {
            contextOptions.userAgent = options.userAgent;
        }
        
        // Add HTTP headers if provided
        if (options.extraHTTPHeaders) {
            contextOptions.extraHTTPHeaders = options.extraHTTPHeaders;
        }
        
        // Add ignore HTTPS errors if provided
        if (options.ignoreHTTPSErrors !== undefined) {
            contextOptions.ignoreHTTPSErrors = options.ignoreHTTPSErrors;
        }
        
        // Add JavaScript enabled if provided
        if (options.javaScriptEnabled !== undefined) {
            contextOptions.javaScriptEnabled = options.javaScriptEnabled;
        }
        
        // Add bypassCSP if provided
        if (options.bypassCSP !== undefined) {
            contextOptions.bypassCSP = options.bypassCSP;
        }
        
        // Add base URL if provided
        if (options.baseURL) {
            contextOptions.baseURL = options.baseURL;
        }
        
        // Configure video recording if enabled
        if (options.recordVideo) {
            const videosDir = options.videosDir || './videos';
            
            contextOptions.recordVideo = {
                dir: videosDir,
                size: options.viewport || { width: 1280, height: 720 }
            };
            
            // Ensure videos directory exists
            CSFileUtils.ensureDirectoryExists(videosDir)
                .catch(error => CSLogger.warn(`Failed to create videos directory: ${error.message}`));
        }
        
        // Configure downloads path if provided
        if (options.downloadsPath) {
            contextOptions.acceptDownloads = options.acceptDownloads !== false;
            contextOptions.recordHar = { path: path.join(options.downloadsPath, 'har_recording.har') };
        } else if (options.acceptDownloads !== undefined) {
            contextOptions.acceptDownloads = options.acceptDownloads;
        }
        
        // If a device name is provided, use device emulation
        if (options.deviceName && this.deviceProfiles[options.deviceName]) {
            const deviceOptions = this.deviceProfiles[options.deviceName];
            
            // Merge device options with custom options (custom options take precedence)
            return {
                ...deviceOptions,
                ...contextOptions
            };
        }
        
        return contextOptions;
    }
    
    /**
     * Creates a new browser context
     * 
     * @param options PlaywrightOptions
     * @param browserId Browser ID
     * @param contextId Optional context ID
     * @returns Promise resolving to the context ID
     */
    public async createContext(
        options: Partial<PlaywrightOptions> = {},
        browserId?: string,
        contextId?: string
    ): Promise<string> {
        return await this.playwrightManager.createBrowserContext(options, browserId, contextId);
    }
    
    /**
     * Closes a browser context
     * 
     * @param contextId Context ID
     * @returns Promise resolving when the context is closed
     */
    public async closeContext(contextId: string): Promise<void> {
        return await this.playwrightManager.closeBrowserContext(contextId);
    }
    
    /**
     * Gets a browser context
     * 
     * @param contextId Context ID
     * @returns The browser context
     */
    public getContext(contextId: string): BrowserContext {
        return this.playwrightManager.getBrowserContext(contextId);
    }
    
    /**
     * Sets the default browser context
     * 
     * @param contextId Context ID
     */
    public setDefaultContext(contextId: string): void {
        this.playwrightManager.setDefaultBrowserContext(contextId);
    }
    
    /**
     * Gets all context IDs
     * 
     * @returns Array of context IDs
     */
    public getContextIds(): string[] {
        return this.playwrightManager.getContextIds();
    }
    
    /**
     * Creates a context with a specific device emulation
     * 
     * @param deviceName Device name
     * @param options Additional context options
     * @param browserId Browser ID
     * @returns Promise resolving to the context ID
     */
    public async createDeviceContext(
        deviceName: string,
        options: Partial<PlaywrightOptions> = {},
        browserId?: string
    ): Promise<string> {
        if (!this.deviceProfiles[deviceName]) {
            throw new Error(`Device profile '${deviceName}' not found. Available devices: ${Object.keys(this.deviceProfiles).join(', ')}`);
        }
        
        return await this.playwrightManager.createDeviceContext(deviceName, options, browserId);
    }
    
    /**
     * Lists all available device profiles
     * 
     * @returns Object with device categories and devices
     */
    public listDeviceProfiles(): Record<string, string[]> {
        const categories: Record<string, string[]> = {
            'Desktop': [],
            'Mobile': [],
            'Tablet': [],
            'Other': []
        };
        
        // Categorize devices
        for (const deviceName of Object.keys(this.deviceProfiles)) {
            const device = this.deviceProfiles[deviceName];
            
            if (deviceName.includes('Desktop')) {
                categories['Desktop'].push(deviceName);
            } else if (deviceName.includes('iPhone') || deviceName.includes('Pixel') || 
                      deviceName.includes('Galaxy') || deviceName.includes('Mobile')) {
                categories['Mobile'].push(deviceName);
            } else if (deviceName.includes('iPad') || deviceName.includes('Tablet')) {
                categories['Tablet'].push(deviceName);
            } else {
                categories['Other'].push(deviceName);
            }
        }
        
        return categories;
    }
    
    /**
     * Gets information about a specific device profile
     * 
     * @param deviceName Device name
     * @returns The device information or null if not found
     */
    public getDeviceInfo(deviceName: string): any {
        return this.deviceProfiles[deviceName] || null;
    }
    
    /**
     * Adds a custom device profile
     * 
     * @param name Device name
     * @param profile Device profile
     * @returns The added device profile
     */
    public addCustomDeviceProfile(name: string, profile: any): any {
        if (this.deviceProfiles[name]) {
            CSLogger.warn(`Overriding existing device profile: ${name}`);
        }
        
        this.deviceProfiles[name] = profile;
        return profile;
    }
    
    /**
     * Adds a persistent context (for authenticated sessions)
     * 
     * @param userDataDir User data directory
     * @param options Additional context options
     * @param browserType Browser type
     * @returns Promise resolving to the context ID and browser ID
     */
    public async createPersistentContext(
        userDataDir: string,
        options: Partial<PlaywrightOptions> = {},
        browserType: BrowserTypes = BrowserTypes.CHROMIUM
    ): Promise<{ contextId: string, browserId: string }> {
        // Ensure user data directory exists
        await CSFileUtils.ensureDirectoryExists(userDataDir);
        
        // Launch browser with persistent context
        const browserId = await this.playwrightManager.launchBrowser({
            ...options,
            browserType,
            launchOptions: {
                ...options.launchOptions,
                userDataDir
            }
        });
        
        // Get context
        const browser = this.playwrightManager.getBrowser(browserId);
        const contexts = browser.contexts();
        
        if (contexts.length === 0) {
            throw new Error('Failed to create persistent context');
        }
        
        // Register the context
        const contextId = `persistent_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
        const context = contexts[0];
        
        // Store context in PlaywrightManager
        this.playwrightManager['contexts'].set(contextId, context);
        
        // Set as default
        this.playwrightManager.setDefaultBrowserContext(contextId);
        
        return { contextId, browserId };
    }
    
    /**
     * Grants permissions to a context
     * 
     * @param permissions Permissions to grant
     * @param origin Origin to grant permissions to (optional)
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when permissions are granted
     */
    public async grantPermissions(
        permissions: string[],
        origin?: string,
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        await context.grantPermissions(permissions, { origin });
        CSLogger.debug(`Granted permissions: ${permissions.join(', ')}${origin ? ` for origin ${origin}` : ''}`);
    }
    
    /**
     * Clears permissions from a context
     * 
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when permissions are cleared
     */
    public async clearPermissions(contextId?: string): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        await context.clearPermissions();
        CSLogger.debug('Cleared permissions');
    }
    
    /**
     * Adds cookies to a context
     * 
     * @param cookies Cookies to add
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when cookies are added
     */
    public async addCookies(cookies: any[], contextId?: string): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        await context.addCookies(cookies);
        CSLogger.debug(`Added ${cookies.length} cookies`);
    }
    
    /**
     * Gets cookies from a context
     * 
     * @param urls URLs to get cookies for (optional)
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving to the cookies
     */
    public async getCookies(urls?: string | string[], contextId?: string): Promise<any[]> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        return await context.cookies(urls);
    }
    
    /**
     * Clears cookies from a context
     * 
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when cookies are cleared
     */
    public async clearCookies(contextId?: string): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        await context.clearCookies();
        CSLogger.debug('Cleared cookies');
    }
    
    /**
     * Sets offline mode for a context
     * 
     * @param offline Whether to enable offline mode
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when offline mode is set
     */
    public async setOffline(offline: boolean, contextId?: string): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        await context.setOffline(offline);
        CSLogger.debug(`Set offline mode: ${offline}`);
    }
    
    /**
     * Sets HTTP credentials for a context
     * 
     * @param username Username
     * @param password Password
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when credentials are set
     */
    public async setHTTPCredentials(
        username: string,
        password: string,
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        await context.setHTTPCredentials({ username, password });
        CSLogger.debug(`Set HTTP credentials for user: ${username}`);
    }
    
    /**
     * Sets extra HTTP headers for a context
     * 
     * @param headers HTTP headers
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when headers are set
     */
    public async setExtraHTTPHeaders(
        headers: Record<string, string>,
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        await context.setExtraHTTPHeaders(headers);
        CSLogger.debug(`Set extra HTTP headers: ${Object.keys(headers).join(', ')}`);
    }
    
    /**
     * Starts tracing for a context
     * 
     * @param options Tracing options
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when tracing starts
     */
    public async startTracing(
        options?: { screenshots?: boolean; snapshots?: boolean; sources?: boolean },
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        await context.tracing.start({
            screenshots: options?.screenshots !== false,
            snapshots: options?.snapshots !== false,
            sources: options?.sources !== false
        });
        
        CSLogger.debug('Started tracing');
    }
    
    /**
     * Stops tracing for a context
     * 
     * @param path Path to save the trace to
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when tracing stops
     */
    public async stopTracing(path: string, contextId?: string): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        // Ensure directory exists
        const dir = path.substring(0, path.lastIndexOf('/'));
        await CSFileUtils.ensureDirectoryExists(dir);
        
        await context.tracing.stop({ path });
        CSLogger.debug(`Stopped tracing, saved to: ${path}`);
    }
    
    /**
     * Creates a context with network interception
     * 
     * @param options PlaywrightOptions
     * @param browserId Browser ID
     * @returns Promise resolving to the context ID
     */
    public async createInterceptingContext(
        options: Partial<PlaywrightOptions> = {},
        browserId?: string
    ): Promise<string> {
        // Create a context with request interception
        const contextId = await this.playwrightManager.createBrowserContext({
            ...options,
            interceptRequests: true
        }, browserId);
        
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        // Set up a route for all requests
        await context.route('**/*', route => {
            // Continue by default
            route.continue();
        });
        
        return contextId;
    }
    
    /**
     * Adds a route for network interception
     * 
     * @param url URL pattern to intercept
     * @param handler Route handler
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when the route is added
     */
    public async addRoute(
        url: string | RegExp,
        handler: Function,
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        await context.route(url, async (route: any, request: any) => {
            try {
                await handler(route, request);
            } catch (error) {
                CSLogger.error(`Error in route handler: ${error.message}`);
                await route.continue();
            }
        });
        
        CSLogger.debug(`Added route for: ${url}`);
    }
    
    /**
     * Removes a route for network interception
     * 
     * @param url URL pattern to remove
     * @param handler Route handler
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when the route is removed
     */
    public async removeRoute(
        url: string | RegExp,
        handler: Function,
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        await context.unroute(url, handler);
        CSLogger.debug(`Removed route for: ${url}`);
    }
    
    /**
     * Blocks URLs matching a pattern
     * 
     * @param urlPattern URL pattern to block
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when the URLs are blocked
     */
    public async blockUrls(urlPattern: string | RegExp, contextId?: string): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        await context.route(urlPattern, route => route.abort());
        
        CSLogger.debug(`Blocked URLs matching: ${urlPattern}`);
    }
    
    /**
     * Mocks a response for a specific URL pattern
     * 
     * @param urlPattern URL pattern to mock
     * @param response Response to mock
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when the response is mocked
     */
    public async mockResponse(
        urlPattern: string | RegExp,
        response: { status?: number; headers?: Record<string, string>; body?: string },
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        await context.route(urlPattern, route => {
            route.fulfill({
                status: response.status || 200,
                headers: response.headers || {},
                body: response.body || ''
            });
        });
        
        CSLogger.debug(`Mocked response for: ${urlPattern}`);
    }
    
    /**
     * Changes user agent for a specific URL pattern
     * 
     * @param urlPattern URL pattern to change user agent for
     * @param userAgent User agent to set
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when the user agent is changed
     */
    public async setUserAgentForUrl(
        urlPattern: string | RegExp,
        userAgent: string,
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        await context.route(urlPattern, async route => {
            const headers = await route.request().allHeaders();
            headers['User-Agent'] = userAgent;
            
            await route.continue({ headers });
        });
        
        CSLogger.debug(`Set user agent for ${urlPattern}: ${userAgent}`);
    }
    
    /**
     * Adds request event handlers to a context
     * 
     * @param options Event handlers
     * @param contextId Context ID (uses default if not provided)
     * @returns Object with functions to remove the event handlers
     */
    public addRequestHandlers(
        options: {
            onRequest?: (request: any) => void;
            onResponse?: (response: any) => void;
            onRequestFailed?: (request: any) => void;
            onRequestFinished?: (request: any) => void;
        },
        contextId?: string
    ): { removeAll: () => Promise<void> } {
        const context = this.playwrightManager.getBrowserContext(contextId);
        const handlers: { event: string; handler: Function }[] = [];
        
        if (options.onRequest) {
            const handler = (request: any) => options.onRequest!(request);
            context.on('request', handler);
            handlers.push({ event: 'request', handler });
        }
        
        if (options.onResponse) {
            const handler = (response: any) => options.onResponse!(response);
            context.on('response', handler);
            handlers.push({ event: 'response', handler });
        }
        
        if (options.onRequestFailed) {
            const handler = (request: any) => options.onRequestFailed!(request);
            context.on('requestfailed', handler);
            handlers.push({ event: 'requestfailed', handler });
        }
        
        if (options.onRequestFinished) {
            const handler = (request: any) => options.onRequestFinished!(request);
            context.on('requestfinished', handler);
            handlers.push({ event: 'requestfinished', handler });
        }
        
        return {
            removeAll: async () => {
                for (const { event, handler } of handlers) {
                    context.removeListener(event, handler);
                }
                
                CSLogger.debug('Removed all request handlers');
            }
        };
    }
    
    /**
     * Adds page event handlers to a context
     * 
     * @param options Event handlers
     * @param contextId Context ID (uses default if not provided)
     * @returns Object with functions to remove the event handlers
     */
    public addPageEventHandlers(
        options: {
            onPageCreated?: (page: any) => void;
            onPageClosed?: (page: any) => void;
            onDialog?: (dialog: any, page: any) => void;
            onConsole?: (message: any, page: any) => void;
            onPageError?: (error: Error, page: any) => void;
            onPageCrashed?: (page: any) => void;
            onPopup?: (page: any) => void;
        },
        contextId?: string
    ): { removeAll: () => Promise<void> } {
        const context = this.playwrightManager.getBrowserContext(contextId);
        const handlers: { event: string; handler: Function; page?: any }[] = [];
        
        if (options.onPageCreated) {
            const handler = (page: any) => options.onPageCreated!(page);
            context.on('page', handler);
            handlers.push({ event: 'page', handler });
            
            // Also handle existing pages
            context.pages().forEach(page => {
                options.onPageCreated!(page);
            });
        }
        
        // Handle events that require listeners on each page
        const setupPageEvents = (page: any) => {
            if (options.onPageClosed) {
                const handler = () => options.onPageClosed!(page);
                page.on('close', handler);
                handlers.push({ event: 'close', handler, page });
            }
            
            if (options.onDialog) {
                const handler = (dialog: any) => options.onDialog!(dialog, page);
                page.on('dialog', handler);
                handlers.push({ event: 'dialog', handler, page });
            }
            
            if (options.onConsole) {
                const handler = (message: any) => options.onConsole!(message, page);
                page.on('console', handler);
                handlers.push({ event: 'console', handler, page });
            }
            
            if (options.onPageError) {
                const handler = (error: Error) => options.onPageError!(error, page);
                page.on('pageerror', handler);
                handlers.push({ event: 'pageerror', handler, page });
            }
            
            if (options.onPageCrashed) {
                const handler = () => options.onPageCrashed!(page);
                page.on('crash', handler);
                handlers.push({ event: 'crash', handler, page });
            }
            
            if (options.onPopup) {
                const handler = (popup: any) => options.onPopup!(popup);
                page.on('popup', handler);
                handlers.push({ event: 'popup', handler, page });
            }
        };
        
        // Add listeners to all existing pages
        context.pages().forEach(setupPageEvents);
        
        // Add listener for new pages
        if (options.onPageClosed || options.onDialog || options.onConsole || 
            options.onPageError || options.onPageCrashed || options.onPopup) {
            const pageHandler = (page: any) => {
                setupPageEvents(page);
            };
            
            context.on('page', pageHandler);
            handlers.push({ event: 'page', handler: pageHandler });
        }
        
        return {
            removeAll: async () => {
                for (const { event, handler, page } of handlers) {
                    if (page) {
                        // Check if the page is still connected before trying to remove listeners
                        try {
                            if (!page.isClosed()) {
                                page.removeListener(event, handler);
                            }
                        } catch (error) {
                            // Ignore errors for closed pages
                        }
                    } else {
                        context.removeListener(event, handler);
                    }
                }
                
                CSLogger.debug('Removed all page event handlers');
            }
        };
    }
    
    /**
     * Sets a storage state for a context (for session restoration)
     * 
     * @param state Storage state or path to a file
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when the storage state is set
     */
    public async setStorageState(
        state: string | { cookies: any[]; origins: any[] },
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        if (typeof state === 'string') {
            // Assume it's a path to a file
            await context.storageState({ path: state });
            CSLogger.debug(`Set storage state from file: ${state}`);
        } else {
            // Assume it's a state object
            await context.addCookies(state.cookies);
            
            // Set localStorage and sessionStorage for each origin
            for (const origin of state.origins) {
                const page = await context.newPage();
                
                try {
                    // Navigate to the origin
                    await page.goto(origin.origin);
                    
                    // Set localStorage
                    if (origin.localStorage && origin.localStorage.length > 0) {
                        await page.evaluate((storageItems: any[]) => {
                            for (const item of storageItems) {
                                window.localStorage.setItem(item.name, item.value);
                            }
                        }, origin.localStorage);
                    }
                    
                    // Set sessionStorage
                    if (origin.sessionStorage && origin.sessionStorage.length > 0) {
                        await page.evaluate((storageItems: any[]) => {
                            for (const item of storageItems) {
                                window.sessionStorage.setItem(item.name, item.value);
                            }
                        }, origin.sessionStorage);
                    }
                } finally {
                    await page.close();
                }
            }
            
            CSLogger.debug('Set storage state from object');
        }
    }
    
    /**
     * Gets the storage state of a context
     * 
     * @param options Options for getting storage state
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving to the storage state
     */
    public async getStorageState(
        options?: { path?: string },
        contextId?: string
    ): Promise<{ cookies: any[]; origins: any[] }> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        if (options?.path) {
            return await context.storageState({ path: options.path });
        } else {
            return await context.storageState();
        }
    }
    
    /**
     * Creates a cloned context based on another context
     * 
     * @param sourceContextId Context ID to clone
     * @param additionalOptions Additional options to apply to the clone
     * @returns Promise resolving to the new context ID
     */
    public async cloneContext(
        sourceContextId: string,
        additionalOptions: Partial<PlaywrightOptions> = {}
    ): Promise<string> {
        const sourceContext = this.playwrightManager.getBrowserContext(sourceContextId);
        const browser = sourceContext.browser();
        
        if (!browser) {
            throw new Error('Source context is not attached to a browser');
        }
        
        // Get browser ID
        let browserId: string | undefined;
        
        for (const [id, br] of Object.entries(this.playwrightManager['browsers'])) {
            if (br === browser) {
                browserId = id;
                break;
            }
        }
        
        if (!browserId) {
            throw new Error('Could not find browser ID for the source context');
        }
        
        // Get storage state from the source context
        const storageState = await sourceContext.storageState();
        
        // Create a new context with the same options plus the storage state
        const newContextId = await this.playwrightManager.createBrowserContext({
            ...additionalOptions,
            contextOptions: {
                ...additionalOptions.contextOptions,
                storageState
            }
        }, browserId);
        
        CSLogger.debug(`Cloned context ${sourceContextId} to ${newContextId}`);
        
        return newContextId;
    }
    
    /**
     * Gets detailed information about a context
     * 
     * @param contextId Context ID (uses default if not provided)
     * @returns Detailed information about the context
     */
    public async getContextInfo(contextId?: string): Promise<any> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        const browser = context.browser();
        
        // Get browser ID
        let browserId: string | undefined;
        
        for (const [id, br] of Object.entries(this.playwrightManager['browsers'])) {
            if (br === browser) {
                browserId = id;
                break;
            }
        }
        
        // Get pages
        const pages = context.pages();
        const pageIds: string[] = [];
        
        for (const page of pages) {
            for (const [id, p] of Object.entries(this.playwrightManager['pages'])) {
                if (p === page) {
                    pageIds.push(id);
                    break;
                }
            }
        }
        
        // Get cookies
        const cookies = await context.cookies();
        
        // Get storage state
        const storageState = await context.storageState();
        
        return {
            id: contextId,
            browserId,
            browser: {
                name: browser?.browserType().name(),
                version: await browser?.version(),
                userAgent: await pages[0]?.evaluate(() => navigator.userAgent)
            },
            pages: {
                count: pages.length,
                ids: pageIds,
                urls: await Promise.all(pages.map(async p => {
                    try {
                        return await p.url();
                    } catch (error) {
                        return 'unknown';
                    }
                }))
            },
            cookies: {
                count: cookies.length,
                domains: Array.from(new Set(cookies.map(c => c.domain)))
            },
            storage: {
                origins: storageState.origins.length
            },
            isDefault: contextId === this.playwrightManager['defaultContextId']
        };
    }
    
    /**
     * Resets all contexts
     * 
     * @returns Promise resolving when all contexts are reset
     */
    public async resetAllContexts(): Promise<void> {
        // Get all context IDs
        const contextIds = this.playwrightManager.getContextIds();
        
        // Close all contexts
        for (const id of contextIds) {
            await this.playwrightManager.closeBrowserContext(id);
        }
        
        CSLogger.debug('Reset all contexts');
    }
    
    /**
     * Applies a network condition preset to a context
     * 
     * @param preset Preset name or custom settings
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving when the network conditions are applied
     */
    public async applyNetworkConditions(
        preset: 'offline' | 'slow3g' | 'fast3g' | 'dsl' | 'wifi' | {
            offline?: boolean;
            downloadThroughput?: number;
            uploadThroughput?: number;
            latency?: number;
        },
        contextId?: string
    ): Promise<void> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        const page = context.pages()[0];
        
        if (!page) {
            throw new Error('No page available in the context');
        }
        
        // Define presets
        const presets: Record<string, any> = {
            offline: { offline: true },
            slow3g: {
                offline: false,
                downloadThroughput: 500 * 1024 / 8, // 500 kbps
                uploadThroughput: 500 * 1024 / 8,   // 500 kbps
                latency: 400                        // 400 ms
            },
            fast3g: {
                offline: false,
                downloadThroughput: 1.5 * 1024 * 1024 / 8, // 1.5 Mbps
                uploadThroughput: 750 * 1024 / 8,          // 750 kbps
                latency: 150                               // 150 ms
            },
            dsl: {
                offline: false,
                downloadThroughput: 2 * 1024 * 1024 / 8, // 2 Mbps
                uploadThroughput: 1 * 1024 * 1024 / 8,   // 1 Mbps
                latency: 50                              // 50 ms
            },
            wifi: {
                offline: false,
                downloadThroughput: 30 * 1024 * 1024 / 8, // 30 Mbps
                uploadThroughput: 15 * 1024 * 1024 / 8,   // 15 Mbps
                latency: 5                                // 5 ms
            }
        };
        
        // Get conditions based on preset or custom settings
        const conditions = typeof preset === 'string' ? presets[preset] : preset;
        
        if (conditions.offline !== undefined) {
            await context.setOffline(conditions.offline);
        }
        
        if (page._cdpSession) {
            // Use CDP to emulate network conditions (Chromium only)
            try {
                await page._cdpSession.send('Network.emulateNetworkConditions', {
                    offline: conditions.offline || false,
                    latency: conditions.latency || 0,
                    downloadThroughput: conditions.downloadThroughput || -1,
                    uploadThroughput: conditions.uploadThroughput || -1
                });
                
                CSLogger.debug(`Applied network conditions: ${JSON.stringify(conditions)}`);
            } catch (error) {
                CSLogger.warn(`Failed to apply network conditions: ${error.message}`);
                
                // Fallback to offline only if CDP is not available
                if (conditions.offline !== undefined) {
                    await context.setOffline(conditions.offline);
                    CSLogger.debug(`Applied offline mode: ${conditions.offline}`);
                }
            }
        } else {
            // Fallback to offline only if CDP is not available
            if (conditions.offline !== undefined) {
                await context.setOffline(conditions.offline);
                CSLogger.debug(`Applied offline mode: ${conditions.offline}`);
            }
        }
    }
    
    /**
     * Exports a context for future use
     * 
     * @param path Path to save the context
     * @param contextId Context ID (uses default if not provided)
     * @returns Promise resolving to the path
     */
    public async exportContext(path: string, contextId?: string): Promise<string> {
        const context = this.playwrightManager.getBrowserContext(contextId);
        
        // Get storage state
        const storageState = await context.storageState({ path });
        
        // Get current options
        const currentOptions = this.playwrightManager.getOptions();
        
        // Create metadata
        const metadata = {
            exportedAt: new Date().toISOString(),
            browserType: currentOptions.browserType,
            version: 1,
            playwrightVersion: require('playwright').version
        };
        
        // Write metadata
        const metadataPath = path.replace(/\.json$/, '') + '.metadata.json';
        await CSFileUtils.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
        
        CSLogger.debug(`Exported context to: ${path}`);
        
        return path;
    }
    
    /**
     * Loads a previously exported context
     * 
     * @param path Path to the exported context
     * @param options Additional options
     * @param browserId Browser ID (uses default if not provided)
     * @returns Promise resolving to the context ID
     */
    public async loadExportedContext(
        path: string,
        options: Partial<PlaywrightOptions> = {},
        browserId?: string
    ): Promise<string> {
        // Create a context with the exported storage state
        const contextId = await this.playwrightManager.createBrowserContext({
            ...options,
            contextOptions: {
                ...options.contextOptions,
                storageState: path
            }
        }, browserId);
        
        CSLogger.debug(`Loaded context from: ${path}`);
        
        return contextId;
    }
}


PageManager.ts
----------------------------

import { Page, BrowserContext, PageScreenshotOptions, Response, FileChooser, Route, Request, Dialog, Frame, Video, Mouse, Keyboard, Touchscreen, Download, Worker, Locator, ElementHandle } from 'playwright';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';
import { CSFileUtils } from '../../core/utils/CSFileUtils';
import { CSDateUtils } from '../../core/utils/CSDateUtils';
import { PlaywrightOptions } from './PlaywrightManager';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { WaitTimeoutException } from '../../core/exceptions/WaitTimeoutException';
import { NavigationTimeoutException } from '../../core/exceptions/NavigationTimeoutException';
import { InitializationException } from '../../core/exceptions/InitializationException';
import path from 'path';

/**
 * Navigation options for page navigation
 */
export interface CSNavigationOptions {
    /**
     * Page timeout in milliseconds
     */
    timeout?: number;
    
    /**
     * Whether to wait for page load state
     */
    waitUntil?: 'load' | 'domcontentloaded' | 'networkidle' | 'commit';
    
    /**
     * HTTP method to use for navigation
     */
    method?: string;
    
    /**
     * HTTP headers to send
     */
    headers?: Record<string, string>;
    
    /**
     * Request body
     */
    body?: string | Buffer | Object;
    
    /**
     * Whether to bypass page cache
     */
    noCache?: boolean;
    
    /**
     * Whether to automatically take a screenshot after navigation
     */
    screenshotAfter?: boolean;
    
    /**
     * Custom wait function after navigation
     */
    waitAfter?: (page: Page) => Promise<void>;
}

/**
 * Manager class for Playwright pages
 */
export class PageManager {
    /**
     * The parent PlaywrightManager instance
     */
    private playwrightManager: any; // Using any to avoid circular dependency
    
    /**
     * Screenshot manager
     */
    private screenshotManager: CSScreenshotManager;
    
    /**
     * Default navigation options
     */
    private defaultNavigationOptions: CSNavigationOptions = {
        waitUntil: 'load',
        timeout: 30000
    };
    
    /**
     * Creates a new PageManager instance
     * 
     * @param playwrightManager The parent PlaywrightManager instance
     */
    constructor(playwrightManager: any) {
        this.playwrightManager = playwrightManager;
        
        // Create a dummy page for screenshot manager initialization
        // This will be replaced with actual pages when needed
        const dummyPage = {} as Page;
        this.screenshotManager = new CSScreenshotManager(dummyPage);
        
        CSLogger.debug('PageManager initialized');
    }
    
    /**
     * Creates a new page
     * 
     * @param options Page options
     * @param contextId Context ID (uses default if not provided)
     * @param pageId Optional page ID
     * @returns Promise resolving to the page ID
     */
    public async createPage(
        options: Partial<PlaywrightOptions> = {},
        contextId?: string,
        pageId?: string
    ): Promise<string> {
        return await this.playwrightManager.createPage(options, contextId, pageId);
    }
    
    /**
     * Gets a page by ID
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns The page
     */
    public getPage(pageId?: string): Page {
        return this.playwrightManager.getPage(pageId);
    }
    
    /**
     * Sets the default page
     * 
     * @param pageId Page ID
     */
    public setDefaultPage(pageId: string): void {
        this.playwrightManager.setDefaultPage(pageId);
    }
    
    /**
     * Closes a page
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when the page is closed
     */
    public async closePage(pageId?: string): Promise<void> {
        return await this.playwrightManager.closePage(pageId);
    }
    
    /**
     * Navigates to a URL
     * 
     * @param url The URL to navigate to
     * @param options Navigation options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the navigation response
     * @throws NavigationTimeoutException if navigation times out
     */
    public async navigate(
        url: string,
        options: CSNavigationOptions = {},
        pageId?: string
    ): Promise<Response | null> {
        const page = this.getPage(pageId);
        
        // Set the screenshot manager page
        this.screenshotManager = new CSScreenshotManager(page);
        
        // Merge with default options
        const mergedOptions = {
            ...this.defaultNavigationOptions,
            ...options
        };
        
        try {
            // Prepare navigation options for Playwright
            const playwrightOptions: any = {
                timeout: mergedOptions.timeout,
                waitUntil: mergedOptions.waitUntil
            };
            
            if (mergedOptions.method) {
                playwrightOptions.method = mergedOptions.method;
            }
            
            if (mergedOptions.headers) {
                playwrightOptions.headers = mergedOptions.headers;
            }
            
            if (mergedOptions.body !== undefined) {
                playwrightOptions.data = mergedOptions.body;
            }
            
            // Disable cache if requested
            if (mergedOptions.noCache) {
                const client = await this.getCDPSession(page);
                if (client) {
                    await client.send('Network.setCacheDisabled', { cacheDisabled: true });
                }
            }
            
            // Log navigation
            CSLogger.info(`Navigating to: ${url}`);
            
            // Perform navigation
            const response = await page.goto(url, playwrightOptions);
            
            // Execute custom wait function if provided
            if (mergedOptions.waitAfter) {
                await mergedOptions.waitAfter(page);
            }
            
            // Take screenshot if requested
            if (mergedOptions.screenshotAfter) {
                await this.takeScreenshot(`Navigation_${new URL(url).hostname.replace(/\./g, '_')}`, {}, pageId);
            }
            
            return response;
        } catch (error) {
            // Check if it's a timeout error
            if (error instanceof Error && error.message.includes('timeout')) {
                CSLogger.error(`Navigation to ${url} timed out after ${mergedOptions.timeout}ms`);
                
                // Take failure screenshot
                try {
                    await this.takeScreenshot(`NavigationTimeout_${Date.now()}`, {}, pageId);
                } catch (screenshotError) {
                    CSLogger.warn(`Failed to take timeout screenshot: ${screenshotError.message}`);
                }
                
                throw new NavigationTimeoutException(
                    `Navigation to ${url} timed out after ${mergedOptions.timeout}ms`,
                    error
                );
            }
            
            // Other errors
            CSLogger.error(`Failed to navigate to ${url}: ${error.message}`);
            throw error;
        } finally {
            // Re-enable cache if it was disabled
            if (mergedOptions.noCache) {
                try {
                    const client = await this.getCDPSession(page);
                    if (client) {
                        await client.send('Network.setCacheDisabled', { cacheDisabled: false });
                    }
                } catch (error) {
                    CSLogger.warn(`Failed to re-enable cache: ${error.message}`);
                }
            }
        }
    }
    
    /**
     * Takes a screenshot
     * 
     * @param name Screenshot name (optional)
     * @param options Screenshot options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the screenshot path
     */
    public async takeScreenshot(
        name?: string,
        options: PageScreenshotOptions = {},
        pageId?: string
    ): Promise<string> {
        const page = this.getPage(pageId);
        
        // Update screenshot manager with current page
        this.screenshotManager = new CSScreenshotManager(page);
        
        // Generate screenshot name if not provided
        const screenshotName = name || `screenshot_${CSDateUtils.getCurrentTimeFormatted()}`;
        
        // Get screenshot directory from options
        const playwrightOptions = this.playwrightManager.getOptions();
        const screenshotsDir = playwrightOptions.screenshotsDir || './screenshots';
        
        // Ensure screenshots directory exists
        await CSFileUtils.ensureDirectoryExists(screenshotsDir);
        
        // Generate screenshot path
        const screenshotPath = path.join(
            screenshotsDir,
            `${screenshotName}.png`
        );
        
        // Merge default options with provided options
        const mergedOptions: PageScreenshotOptions = {
            path: screenshotPath,
            fullPage: true,
            ...options
        };
        
        // Take screenshot
        CSLogger.debug(`Taking screenshot: ${screenshotPath}`);
        await page.screenshot(mergedOptions);
        
        return screenshotPath;
    }
    
    /**
     * Waits for a condition
     * 
     * @param condition Condition to wait for
     * @param options Wait options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when the condition is met
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForCondition(
        condition: (page: Page) => Promise<boolean>,
        options: { timeout?: number; message?: string; pollInterval?: number } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        // Get default timeout from options
        const playwrightOptions = this.playwrightManager.getOptions();
        const defaultTimeout = playwrightOptions.actionTimeout || 10000;
        
        // Merge with default options
        const mergedOptions = {
            timeout: options.timeout || defaultTimeout,
            message: options.message || 'Condition not met',
            pollInterval: options.pollInterval || 100
        };
        
        try {
            const startTime = Date.now();
            let lastError: Error | null = null;
            
            while (Date.now() - startTime < mergedOptions.timeout) {
                try {
                    if (await condition(page)) {
                        return; // Condition met
                    }
                } catch (error) {
                    lastError = error;
                    CSLogger.debug(`Error in wait condition: ${error.message}`);
                }
                
                // Wait for poll interval
                await new Promise(resolve => setTimeout(resolve, mergedOptions.pollInterval));
            }
            
            // Timeout
            throw new WaitTimeoutException(
                `${mergedOptions.message} (timeout: ${mergedOptions.timeout}ms)`,
                lastError || new Error(`Timeout waiting for condition: ${mergedOptions.message}`)
            );
        } catch (error) {
            if (error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new WaitTimeoutException(
                `${mergedOptions.message} (timeout: ${mergedOptions.timeout}ms)`,
                error
            );
        }
    }
    
    /**
     * Waits for an element
     * 
     * @param selector Element selector
     * @param options Wait options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the element
     * @throws ElementNotFoundException if the element is not found
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForElement(
        selector: string,
        options: { timeout?: number; state?: 'visible' | 'hidden' | 'attached' | 'detached' } = {},
        pageId?: string
    ): Promise<Locator> {
        const page = this.getPage(pageId);
        
        // Get default timeout from options
        const playwrightOptions = this.playwrightManager.getOptions();
        const defaultTimeout = playwrightOptions.actionTimeout || 10000;
        
        // Merge with default options
        const mergedOptions = {
            timeout: options.timeout || defaultTimeout,
            state: options.state || 'visible'
        };
        
        try {
            // Get element locator
            const locator = page.locator(selector);
            
            // Wait for element based on state
            switch (mergedOptions.state) {
                case 'visible':
                    await locator.waitFor({
                        state: 'visible',
                        timeout: mergedOptions.timeout
                    });
                    break;
                    
                case 'hidden':
                    await locator.waitFor({
                        state: 'hidden',
                        timeout: mergedOptions.timeout
                    });
                    break;
                    
                case 'attached':
                    await locator.waitFor({
                        state: 'attached',
                        timeout: mergedOptions.timeout
                    });
                    break;
                    
                case 'detached':
                    await locator.waitFor({
                        state: 'detached',
                        timeout: mergedOptions.timeout
                    });
                    break;
            }
            
            return locator;
        } catch (error) {
            CSLogger.error(`Failed to wait for element ${selector}: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`ElementWaitFailure_${selector.replace(/[^\w]/g, '_')}_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take element wait failure screenshot: ${screenshotError.message}`);
            }
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(
                    `Timed out waiting for element ${selector} to be ${mergedOptions.state} after ${mergedOptions.timeout}ms`,
                    error
                );
            }
            
            throw new ElementNotFoundException(
                `Element not found: ${selector}`,
                error
            );
        }
    }
    
    /**
     * Clicks an element
     * 
     * @param selector Element selector
     * @param options Click options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when the click is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async click(
        selector: string,
        options: { timeout?: number; button?: 'left' | 'right' | 'middle'; modifiers?: Array<'Alt' | 'Control' | 'Meta' | 'Shift'>; position?: { x: number; y: number }; force?: boolean; noWaitAfter?: boolean; trial?: boolean } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element to be visible
            const element = await this.waitForElement(selector, { timeout: options.timeout }, pageId);
            
            // Click the element
            await element.click(options);
            
            CSLogger.debug(`Clicked element: ${selector}`);
        } catch (error) {
            CSLogger.error(`Failed to click element ${selector}: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`ClickFailure_${selector.replace(/[^\w]/g, '_')}_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take click failure screenshot: ${screenshotError.message}`);
            }
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to click element ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Types text into an element
     * 
     * @param selector Element selector
     * @param text Text to type
     * @param options Type options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when typing is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async type(
        selector: string,
        text: string,
        options: { timeout?: number; delay?: number; noWaitAfter?: boolean; clear?: boolean } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element to be visible
            const element = await this.waitForElement(selector, { timeout: options.timeout }, pageId);
            
            // Clear the input if requested
            if (options.clear) {
                await element.clear();
            }
            
            // Type the text
            await element.type(text, {
                delay: options.delay,
                noWaitAfter: options.noWaitAfter
            });
            
            // Mask sensitive data in logs
            const logText = this.isSensitiveData(selector) ? '********' : text;
            CSLogger.debug(`Typed text '${logText}' into element: ${selector}`);
        } catch (error) {
            CSLogger.error(`Failed to type into element ${selector}: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`TypeFailure_${selector.replace(/[^\w]/g, '_')}_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take type failure screenshot: ${screenshotError.message}`);
            }
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to type into element ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Fills a form field
     * 
     * @param selector Element selector
     * @param value Value to fill
     * @param options Fill options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when filling is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async fill(
        selector: string,
        value: string,
        options: { timeout?: number; noWaitAfter?: boolean; force?: boolean } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element to be visible
            const element = await this.waitForElement(selector, { timeout: options.timeout }, pageId);
            
            // Fill the element
            await element.fill(value, {
                noWaitAfter: options.noWaitAfter,
                force: options.force
            });
            
            // Mask sensitive data in logs
            const logValue = this.isSensitiveData(selector) ? '********' : value;
            CSLogger.debug(`Filled element ${selector} with value '${logValue}'`);
        } catch (error) {
            CSLogger.error(`Failed to fill element ${selector}: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`FillFailure_${selector.replace(/[^\w]/g, '_')}_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take fill failure screenshot: ${screenshotError.message}`);
            }
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to fill element ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Selects an option from a select element
     * 
     * @param selector Element selector
     * @param values Values to select
     * @param options Select options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when selection is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async select(
        selector: string,
        values: string | string[] | { value?: string; label?: string; index?: number } | Array<{ value?: string; label?: string; index?: number }>,
        options: { timeout?: number; noWaitAfter?: boolean; force?: boolean } = {},
        pageId?: string
    ): Promise<string[]> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element to be visible
            const element = await this.waitForElement(selector, { timeout: options.timeout }, pageId);
            
            // Select options
            const selectedValues = await element.selectOption(values as any, {
                noWaitAfter: options.noWaitAfter,
                force: options.force
            });
            
            CSLogger.debug(`Selected options in element ${selector}`);
            
            return selectedValues;
        } catch (error) {
            CSLogger.error(`Failed to select options in element ${selector}: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`SelectFailure_${selector.replace(/[^\w]/g, '_')}_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take select failure screenshot: ${screenshotError.message}`);
            }
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to select options in element ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Gets text from an element
     * 
     * @param selector Element selector
     * @param options Text options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the element text
     * @throws ElementNotFoundException if the element is not found
     */
    public async getText(
        selector: string,
        options: { timeout?: number; trim?: boolean } = {},
        pageId?: string
    ): Promise<string> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element to be visible
            const element = await this.waitForElement(selector, { timeout: options.timeout }, pageId);
            
            // Get element text
            let text = await element.innerText();
            
            // Trim text if requested
            if (options.trim !== false) {
                text = text.trim();
            }
            
            CSLogger.debug(`Got text from element ${selector}: ${text}`);
            
            return text;
        } catch (error) {
            CSLogger.error(`Failed to get text from element ${selector}: ${error.message}`);
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to get text from element ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Gets attribute value from an element
     * 
     * @param selector Element selector
     * @param attributeName Attribute name
     * @param options Attribute options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the attribute value
     * @throws ElementNotFoundException if the element is not found
     */
    public async getAttribute(
        selector: string,
        attributeName: string,
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<string | null> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element to be visible
            const element = await this.waitForElement(selector, { timeout: options.timeout, state: 'attached' }, pageId);
            
            // Get attribute value
            const value = await element.getAttribute(attributeName);
            
            CSLogger.debug(`Got attribute ${attributeName} from element ${selector}: ${value}`);
            
            return value;
        } catch (error) {
            CSLogger.error(`Failed to get attribute ${attributeName} from element ${selector}: ${error.message}`);
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to get attribute ${attributeName} from element ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Checks if an element is visible
     * 
     * @param selector Element selector
     * @param options Visibility options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to true if the element is visible
     */
    public async isVisible(
        selector: string,
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<boolean> {
        const page = this.getPage(pageId);
        
        try {
            // Set zero timeout for element check
            const locator = page.locator(selector);
            
            // Check if element is visible
            return await locator.isVisible({ timeout: options.timeout || 1000 });
        } catch (error) {
            CSLogger.debug(`Error checking visibility of element ${selector}: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Checks if an element exists
     * 
     * @param selector Element selector
     * @param options Existence options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to true if the element exists
     */
    public async exists(
        selector: string,
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<boolean> {
        const page = this.getPage(pageId);
        
        try {
            // Get element with minimal timeout
            const timeout = options.timeout || 1000;
            const locator = page.locator(selector);
            
            // Check if at least one element exists
            const count = await locator.count();
            return count > 0;
        } catch (error) {
            CSLogger.debug(`Error checking existence of element ${selector}: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Executes JavaScript in the browser
     * 
     * @param script JavaScript to execute
     * @param args Arguments to pass to the script
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the script result
     */
    public async evaluate<T>(
        script: string | Function,
        args: any[] = [],
        pageId?: string
    ): Promise<T> {
        const page = this.getPage(pageId);
        
        try {
            // Execute script
            return await page.evaluate(script, ...args);
        } catch (error) {
            CSLogger.error(`Failed to execute script: ${error.message}`);
            throw new Error(`Failed to execute script: ${error.message}`);
        }
    }
    
    /**
     * Executes JavaScript in the browser within the context of an element
     * 
     * @param selector Element selector
     * @param script JavaScript to execute
     * @param args Arguments to pass to the script
     * @param options Evaluation options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the script result
     * @throws ElementNotFoundException if the element is not found
     */
    public async evaluateOnElement<T>(
        selector: string,
        script: string | Function,
        args: any[] = [],
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<T> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element to be visible
            const element = await this.waitForElement(selector, { timeout: options.timeout, state: 'attached' }, pageId);
            
            // Execute script on element
            return await element.evaluate(script as any, ...args);
        } catch (error) {
            CSLogger.error(`Failed to execute script on element ${selector}: ${error.message}`);
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to execute script on element ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Waits for page load
     * 
     * @param state Page load state
     * @param options Wait options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when page is loaded
     */
    public async waitForLoad(
        state: 'load' | 'domcontentloaded' | 'networkidle' = 'load',
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        // Get default timeout from options
        const playwrightOptions = this.playwrightManager.getOptions();
        const defaultTimeout = playwrightOptions.navigationTimeout || 30000;
        
        try {
            await page.waitForLoadState(state, { timeout: options.timeout || defaultTimeout });
            CSLogger.debug(`Page load state ${state} reached`);
        } catch (error) {
            CSLogger.error(`Failed to wait for page load state ${state}: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`LoadStateFailure_${state}_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take load state failure screenshot: ${screenshotError.message}`);
            }
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(
                    `Timed out waiting for page load state ${state} after ${options.timeout || defaultTimeout}ms`,
                    error
                );
            }
            
            throw new Error(`Failed to wait for page load state ${state}: ${error.message}`);
        }
    }
    
    /**
     * Gets the current page URL
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns The current page URL
     */
    public async getUrl(pageId?: string): Promise<string> {
        const page = this.getPage(pageId);
        return await page.url();
    }
    
    /**
     * Gets the current page title
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns The current page title
     */
    public async getTitle(pageId?: string): Promise<string> {
        const page = this.getPage(pageId);
        return await page.title();
    }
    
    /**
     * Checks if a string contains sensitive data
     * 
     * @param selector Element selector or text
     * @returns Whether the text contains sensitive data
     */
    private isSensitiveData(selector: string): boolean {
        // Basic patterns for sensitive data
        const patterns = [
            /password/i,      // Password fields
            /passwd/i,        // Password fields (abbreviated)
            /social.*security/i, // Social Security Number fields
            /credit.*card/i,  // Credit card number fields
            /card.*number/i,  // Credit card number fields
            /cvv/i,           // CVV fields
            /ssn/i,           // SSN fields
            /secret/i,        // Secret fields
            /token/i,         // Token fields
            /api.*key/i       // API key fields
        ];
        
        return patterns.some(pattern => pattern.test(selector));
    }
    
    /**
     * Gets a Playwright CDP session
     * 
     * @param page The page
     * @returns Promise resolving to the CDP client or null if not available
     */
    private async getCDPSession(page: Page): Promise<any | null> {
        try {
            return await (page as any)._channel?.newCDPSession();
        } catch (error) {
            CSLogger.debug(`Failed to get CDP session: ${error.message}`);
            return null;
        }
    }
    
    /**
     * Sets default navigation options
     * 
     * @param options Default navigation options
     */
    public setDefaultNavigationOptions(options: CSNavigationOptions): void {
        this.defaultNavigationOptions = {
            ...this.defaultNavigationOptions,
            ...options
        };
    }
    
    /**
     * Gets default navigation options
     * 
     * @returns Default navigation options
     */
    public getDefaultNavigationOptions(): CSNavigationOptions {
        return { ...this.defaultNavigationOptions };
    }
    
    /**
     * Refreshes the current page
     * 
     * @param options Refresh options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the refresh response
     */
    public async refresh(
        options: CSNavigationOptions = {},
        pageId?: string
    ): Promise<Response | null> {
        const page = this.getPage(pageId);
        
        // Merge with default options
        const mergedOptions = {
            ...this.defaultNavigationOptions,
            ...options
        };
        
        try {
            CSLogger.info('Refreshing page');
            
            // Refresh page
            const response = await page.reload({
                timeout: mergedOptions.timeout,
                waitUntil: mergedOptions.waitUntil
            });
            
            // Execute custom wait function if provided
            if (mergedOptions.waitAfter) {
                await mergedOptions.waitAfter(page);
            }
            
            // Take screenshot if requested
            if (mergedOptions.screenshotAfter) {
                await this.takeScreenshot(`Refresh_${Date.now()}`, {}, pageId);
            }
            
            return response;
        } catch (error) {
            CSLogger.error(`Failed to refresh page: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`RefreshFailure_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take refresh failure screenshot: ${screenshotError.message}`);
            }
            
            throw new Error(`Failed to refresh page: ${error.message}`);
        }
    }
    
    /**
     * Goes back in history
     * 
     * @param options Back options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the back response
     */
    public async goBack(
        options: CSNavigationOptions = {},
        pageId?: string
    ): Promise<Response | null> {
        const page = this.getPage(pageId);
        
        // Merge with default options
        const mergedOptions = {
            ...this.defaultNavigationOptions,
            ...options
        };
        
        try {
            CSLogger.info('Going back in history');
            
            // Go back
            const response = await page.goBack({
                timeout: mergedOptions.timeout,
                waitUntil: mergedOptions.waitUntil
            });
            
            // Execute custom wait function if provided
            if (mergedOptions.waitAfter) {
                await mergedOptions.waitAfter(page);
            }
            
            // Take screenshot if requested
            if (mergedOptions.screenshotAfter) {
                await this.takeScreenshot(`GoBack_${Date.now()}`, {}, pageId);
            }
            
            return response;
        } catch (error) {
            CSLogger.error(`Failed to go back in history: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`GoBackFailure_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take go back failure screenshot: ${screenshotError.message}`);
            }
            
            throw new Error(`Failed to go back in history: ${error.message}`);
        }
    }
    
    /**
     * Goes forward in history
     * 
     * @param options Forward options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the forward response
     */
    public async goForward(
        options: CSNavigationOptions = {},
        pageId?: string
    ): Promise<Response | null> {
        const page = this.getPage(pageId);
        
        // Merge with default options
        const mergedOptions = {
            ...this.defaultNavigationOptions,
            ...options
        };
        
        try {
            CSLogger.info('Going forward in history');
            
            // Go forward
            const response = await page.goForward({
                timeout: mergedOptions.timeout,
                waitUntil: mergedOptions.waitUntil
            });
            
            // Execute custom wait function if provided
            if (mergedOptions.waitAfter) {
                await mergedOptions.waitAfter(page);
            }
            
            // Take screenshot if requested
            if (mergedOptions.screenshotAfter) {
                await this.takeScreenshot(`GoForward_${Date.now()}`, {}, pageId);
            }
            
            return response;
        } catch (error) {
            CSLogger.error(`Failed to go forward in history: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`GoForwardFailure_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take go forward failure screenshot: ${screenshotError.message}`);
            }
            
            throw new Error(`Failed to go forward in history: ${error.message}`);
        }
    }
    
    /**
     * Handles a dialog
     * 
     * @param action Dialog action
     * @param text Dialog text (for prompt dialogs)
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when dialog handler is set
     */
    public async handleDialog(
        action: 'accept' | 'dismiss',
        text?: string,
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        // Set dialog handler
        page.once('dialog', async dialog => {
            try {
                // Log dialog
                CSLogger.info(`Handling dialog: ${dialog.type()} - ${dialog.message()}`);
                
                // Handle dialog
                if (action === 'accept') {
                    await dialog.accept(text);
                } else {
                    await dialog.dismiss();
                }
                
                CSLogger.debug(`Dialog ${action}ed`);
            } catch (error) {
                CSLogger.error(`Failed to handle dialog: ${error.message}`);
            }
        });
        
        CSLogger.debug(`Dialog handler set to ${action}`);
    }
    
    /**
     * Sets automatic dialog handler
     * 
     * @param handler Dialog handler
     * @param pageId Page ID (uses default if not provided)
     * @returns Function to remove the handler
     */
    public setDialogHandler(
        handler: 'accept' | 'dismiss' | ((dialog: Dialog) => Promise<void>),
        pageId?: string
    ): () => void {
        const page = this.getPage(pageId);
        
        // Create handler function
        const handlerFn = typeof handler === 'function' 
            ? handler 
            : async (dialog: Dialog) => {
                if (handler === 'accept') {
                    await dialog.accept();
                } else {
                    await dialog.dismiss();
                }
            };
        
        // Set dialog handler
        page.on('dialog', handlerFn);
        
        // Return function to remove handler
        return () => {
            page.off('dialog', handlerFn);
        };
    }
    
    /**
     * Waits for a file chooser
     * 
     * @param options Wait options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the file chooser
     */
    public async waitForFileChooser(
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<FileChooser> {
        const page = this.getPage(pageId);
        
        // Get default timeout from options
        const playwrightOptions = this.playwrightManager.getOptions();
        const defaultTimeout = playwrightOptions.actionTimeout || 10000;
        
        try {
            return await page.waitForEvent('filechooser', { timeout: options.timeout || defaultTimeout });
        } catch (error) {
            CSLogger.error(`Failed to wait for file chooser: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`FileChooserWaitFailure_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take file chooser wait failure screenshot: ${screenshotError.message}`);
            }
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(
                    `Timed out waiting for file chooser after ${options.timeout || defaultTimeout}ms`,
                    error
                );
            }
            
            throw new Error(`Failed to wait for file chooser: ${error.message}`);
        }
    }
    
    /**
     * Uploads a file
     * 
     * @param selector Element selector
     * @param filePaths File paths to upload
     * @param options Upload options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when upload is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async uploadFile(
        selector: string,
        filePaths: string | string[],
        options: { timeout?: number; noWaitAfter?: boolean } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element to be visible
            const element = await this.waitForElement(selector, { timeout: options.timeout }, pageId);
            
            // Upload file
            await element.setInputFiles(filePaths, {
                noWaitAfter: options.noWaitAfter
            });
            
            CSLogger.debug(`Uploaded file(s) to element: ${selector}`);
        } catch (error) {
            CSLogger.error(`Failed to upload file to element ${selector}: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`UploadFailure_${selector.replace(/[^\w]/g, '_')}_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take upload failure screenshot: ${screenshotError.message}`);
            }
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to upload file to element ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Gets page cookies
     * 
     * @param urls URLs to get cookies for
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the cookies
     */
    public async getCookies(
        urls?: string | string[],
        pageId?: string
    ): Promise<any[]> {
        const page = this.getPage(pageId);
        
        try {
            // Get context for the page
            const context = page.context();
            
            // Get cookies
            return await context.cookies(urls);
        } catch (error) {
            CSLogger.error(`Failed to get cookies: ${error.message}`);
            throw new Error(`Failed to get cookies: ${error.message}`);
        }
    }
    
    /**
     * Sets page cookies
     * 
     * @param cookies Cookies to set
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when cookies are set
     */
    public async setCookies(
        cookies: Array<{
            name: string;
            value: string;
            url?: string;
            domain?: string;
            path?: string;
            expires?: number;
            httpOnly?: boolean;
            secure?: boolean;
            sameSite?: 'Strict' | 'Lax' | 'None';
        }>,
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Get context for the page
            const context = page.context();
            
            // Set cookies
            await context.addCookies(cookies);
            
            CSLogger.debug(`Set ${cookies.length} cookies`);
        } catch (error) {
            CSLogger.error(`Failed to set cookies: ${error.message}`);
            throw new Error(`Failed to set cookies: ${error.message}`);
        }
    }
    
    /**
     * Clears page cookies
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when cookies are cleared
     */
    public async clearCookies(pageId?: string): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Get context for the page
            const context = page.context();
            
            // Clear cookies
            await context.clearCookies();
            
            CSLogger.debug('Cleared cookies');
        } catch (error) {
            CSLogger.error(`Failed to clear cookies: ${error.message}`);
            throw new Error(`Failed to clear cookies: ${error.message}`);
        }
    }
    
    /**
     * Deletes specific cookie
     * 
     * @param name Cookie name
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when cookie is deleted
     */
    public async deleteCookie(
        name: string,
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Get all cookies
            const cookies = await this.getCookies(undefined, pageId);
            
            // Filter out the cookie to delete
            const filteredCookies = cookies.filter(cookie => cookie.name !== name);
            
            // Get context for the page
            const context = page.context();
            
            // Clear all cookies
            await context.clearCookies();
            
            // Set filtered cookies
            if (filteredCookies.length > 0) {
                await context.addCookies(filteredCookies);
            }
            
            CSLogger.debug(`Deleted cookie: ${name}`);
        } catch (error) {
            CSLogger.error(`Failed to delete cookie ${name}: ${error.message}`);
            throw new Error(`Failed to delete cookie ${name}: ${error.message}`);
        }
    }
    
    /**
     * Waits for a network request
     * 
     * @param urlOrPredicate URL pattern or predicate function
     * @param options Wait options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the request
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForRequest(
        urlOrPredicate: string | RegExp | ((request: Request) => boolean | Promise<boolean>),
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<Request> {
        const page = this.getPage(pageId);
        
        // Get default timeout from options
        const playwrightOptions = this.playwrightManager.getOptions();
        const defaultTimeout = playwrightOptions.actionTimeout || 10000;
        
        try {
            return await page.waitForRequest(urlOrPredicate as any, { 
                timeout: options.timeout || defaultTimeout 
            });
        } catch (error) {
            CSLogger.error(`Failed to wait for request: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(
                    `Timed out waiting for request after ${options.timeout || defaultTimeout}ms`,
                    error
                );
            }
            
            throw new Error(`Failed to wait for request: ${error.message}`);
        }
    }
    
    /**
     * Waits for a network response
     * 
     * @param urlOrPredicate URL pattern or predicate function
     * @param options Wait options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the response
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForResponse(
        urlOrPredicate: string | RegExp | ((response: Response) => boolean | Promise<boolean>),
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<Response> {
        const page = this.getPage(pageId);
        
        // Get default timeout from options
        const playwrightOptions = this.playwrightManager.getOptions();
        const defaultTimeout = playwrightOptions.actionTimeout || 10000;
        
        try {
            return await page.waitForResponse(urlOrPredicate as any, { 
                timeout: options.timeout || defaultTimeout 
            });
        } catch (error) {
            CSLogger.error(`Failed to wait for response: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(
                    `Timed out waiting for response after ${options.timeout || defaultTimeout}ms`,
                    error
                );
            }
            
            throw new Error(`Failed to wait for response: ${error.message}`);
        }
    }
    
    /**
     * Blocks URLs matching a pattern
     * 
     * @param urlPatterns URL patterns to block
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when the URLs are blocked
     */
    public async blockUrls(
        urlPatterns: string | RegExp | Array<string | RegExp>,
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Get context for the page
            const context = page.context();
            
            // Convert single pattern to array
            const patterns = Array.isArray(urlPatterns) ? urlPatterns : [urlPatterns];
            
            // Block each pattern
            for (const pattern of patterns) {
                await context.route(pattern, route => route.abort());
                CSLogger.debug(`Blocked URLs matching: ${pattern}`);
            }
        } catch (error) {
            CSLogger.error(`Failed to block URLs: ${error.message}`);
            throw new Error(`Failed to block URLs: ${error.message}`);
        }
    }
    
    /**
     * Mocks a response for a URL pattern
     * 
     * @param urlPattern URL pattern to mock
     * @param response Response to return
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when the response is mocked
     */
    public async mockResponse(
        urlPattern: string | RegExp,
        response: {
            status?: number;
            headers?: Record<string, string>;
            contentType?: string;
            body?: string | Buffer | Object;
        },
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Get context for the page
            const context = page.context();
            
            // Prepare response
            const mockResponse: any = {
                status: response.status || 200,
                headers: {
                    ...response.headers
                }
            };
            
            // Add content type if specified
            if (response.contentType) {
                mockResponse.headers['content-type'] = response.contentType;
            }
            
            // Add body if specified
            if (response.body !== undefined) {
                // Convert object to JSON string if needed
                if (typeof response.body === 'object' && !(response.body instanceof Buffer)) {
                    mockResponse.body = JSON.stringify(response.body);
                    
                    // Set content type to JSON if not specified
                    if (!mockResponse.headers['content-type']) {
                        mockResponse.headers['content-type'] = 'application/json';
                    }
                } else {
                    mockResponse.body = response.body;
                }
            }
            
            // Mock response
            await context.route(urlPattern, route => route.fulfill(mockResponse));
            
            CSLogger.debug(`Mocked response for: ${urlPattern}`);
        } catch (error) {
            CSLogger.error(`Failed to mock response: ${error.message}`);
            throw new Error(`Failed to mock response: ${error.message}`);
        }
    }
    
    /**
     * Gets all frames on the page
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Array of frames
     */
    public getFrames(pageId?: string): Frame[] {
        const page = this.getPage(pageId);
        return page.frames();
    }
    
    /**
     * Gets a frame by name or URL
     * 
     * @param nameOrUrl Frame name or URL
     * @param pageId Page ID (uses default if not provided)
     * @returns The frame or null if not found
     */
    public getFrame(nameOrUrl: string, pageId?: string): Frame | null {
        const page = this.getPage(pageId);
        
        // Try to find by name
        let frame = page.frame({ name: nameOrUrl });
        
        // If not found, try to find by URL
        if (!frame) {
            frame = page.frame({ url: nameOrUrl });
        }
        
        return frame;
    }
    
    /**
     * Gets the main frame
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns The main frame
     */
    public getMainFrame(pageId?: string): Frame {
        const page = this.getPage(pageId);
        return page.mainFrame();
    }
    
    /**
     * Adds a script tag to the page
     * 
     * @param options Script options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the added tag
     */
    public async addScriptTag(
        options: { url?: string; path?: string; content?: string; type?: string },
        pageId?: string
    ): Promise<ElementHandle<HTMLElement>> {
        const page = this.getPage(pageId);
        
        try {
            return await page.addScriptTag(options as any);
        } catch (error) {
            CSLogger.error(`Failed to add script tag: ${error.message}`);
            throw new Error(`Failed to add script tag: ${error.message}`);
        }
    }
    
    /**
     * Adds a style tag to the page
     * 
     * @param options Style options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the added tag
     */
    public async addStyleTag(
        options: { url?: string; path?: string; content?: string },
        pageId?: string
    ): Promise<ElementHandle<HTMLElement>> {
        const page = this.getPage(pageId);
        
        try {
            return await page.addStyleTag(options as any);
        } catch (error) {
            CSLogger.error(`Failed to add style tag: ${error.message}`);
            throw new Error(`Failed to add style tag: ${error.message}`);
        }
    }
    
    /**
     * Brings page to front
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when the page is brought to front
     */
    public async bringToFront(pageId?: string): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            await page.bringToFront();
            CSLogger.debug('Brought page to front');
        } catch (error) {
            CSLogger.error(`Failed to bring page to front: ${error.message}`);
            throw new Error(`Failed to bring page to front: ${error.message}`);
        }
    }
    
    /**
     * Gets the mouse object for the page
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns The mouse object
     */
    public getMouse(pageId?: string): Mouse {
        const page = this.getPage(pageId);
        return page.mouse;
    }
    
    /**
     * Gets the keyboard object for the page
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns The keyboard object
     */
    public getKeyboard(pageId?: string): Keyboard {
        const page = this.getPage(pageId);
        return page.keyboard;
    }
    
    /**
     * Gets the touchscreen object for the page
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns The touchscreen object
     */
    public getTouchscreen(pageId?: string): Touchscreen {
        const page = this.getPage(pageId);
        return page.touchscreen;
    }
    
    /**
     * Gets page metrics
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the page metrics
     */
    public async getMetrics(pageId?: string): Promise<Record<string, number>> {
        const page = this.getPage(pageId);
        
        try {
            // Use CDP session to get metrics (Chromium only)
            const client = await this.getCDPSession(page);
            
            if (client) {
                const metrics = await client.send('Performance.getMetrics');
                return metrics.metrics.reduce((acc: Record<string, number>, metric: any) => {
                    acc[metric.name] = metric.value;
                    return acc;
                }, {});
            }
            
            // Fallback to basic metrics
            return {
                timestamp: Date.now(),
                documents: await page.evaluate(() => document.querySelectorAll('*').length),
                jsHeapSize: await page.evaluate(() => performance.memory?.usedJSHeapSize || 0)
            };
        } catch (error) {
            CSLogger.error(`Failed to get page metrics: ${error.message}`);
            
            // Fallback to basic metrics
            return {
                timestamp: Date.now()
            };
        }
    }
    
    /**
     * Gets page performance timing
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the performance timing
     */
    public async getPerformanceTiming(pageId?: string): Promise<Record<string, number>> {
        const page = this.getPage(pageId);
        
        try {
            return await page.evaluate(() => {
                const timing = performance.timing.toJSON();
                const navigationTiming = performance.getEntriesByType('navigation')[0];
                
                return {
                    ...timing,
                    ...(navigationTiming ? navigationTiming.toJSON() : {})
                };
            });
        } catch (error) {
            CSLogger.error(`Failed to get performance timing: ${error.message}`);
            throw new Error(`Failed to get performance timing: ${error.message}`);
        }
    }
    
    /**
     * Gets page viewport size
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the viewport size
     */
    public async getViewportSize(pageId?: string): Promise<{ width: number; height: number }> {
        const page = this.getPage(pageId);
        return await page.viewportSize() || { width: 0, height: 0 };
    }
    
    /**
     * Sets page viewport size
     * 
     * @param width Viewport width
     * @param height Viewport height
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when the viewport is set
     */
    public async setViewportSize(
        width: number,
        height: number,
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            await page.setViewportSize({ width, height });
            CSLogger.debug(`Set viewport size to ${width}x${height}`);
        } catch (error) {
            CSLogger.error(`Failed to set viewport size: ${error.message}`);
            throw new Error(`Failed to set viewport size: ${error.message}`);
        }
    }
    
    /**
     * Emulates media
     * 
     * @param options Media options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when media is emulated
     */
    public async emulateMedia(
        options: { media?: 'screen' | 'print' | null; colorScheme?: 'dark' | 'light' | 'no-preference' | null; reducedMotion?: 'reduce' | 'no-preference' | null; forcedColors?: 'active' | 'none' | null },
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            await page.emulateMedia(options);
            CSLogger.debug(`Emulated media: ${JSON.stringify(options)}`);
        } catch (error) {
            CSLogger.error(`Failed to emulate media: ${error.message}`);
            throw new Error(`Failed to emulate media: ${error.message}`);
        }
    }
    
    /**
     * Gets the PDF of the page
     * 
     * @param options PDF options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the PDF buffer
     */
    public async pdf(
        options: {
            path?: string;
            format?: 'Letter' | 'Legal' | 'Tabloid' | 'Ledger' | 'A0' | 'A1' | 'A2' | 'A3' | 'A4' | 'A5' | 'A6';
            width?: string | number;
            height?: string | number;
            margin?: { top?: string | number; right?: string | number; bottom?: string | number; left?: string | number };
            printBackground?: boolean;
            preferCSSPageSize?: boolean;
            scale?: number;
            landscape?: boolean;
            pageRanges?: string;
            headerTemplate?: string;
            footerTemplate?: string;
            displayHeaderFooter?: boolean;
        },
        pageId?: string
    ): Promise<Buffer> {
        const page = this.getPage(pageId);
        
        try {
            // PDF is only supported in headless Chromium
            return await page.pdf(options);
        } catch (error) {
            CSLogger.error(`Failed to generate PDF: ${error.message}`);
            throw new Error(`Failed to generate PDF: ${error.message}`);
        }
    }
    
    /**
     * Gets the page content
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the page content
     */
    public async getContent(pageId?: string): Promise<string> {
        const page = this.getPage(pageId);
        
        try {
            return await page.content();
        } catch (error) {
            CSLogger.error(`Failed to get page content: ${error.message}`);
            throw new Error(`Failed to get page content: ${error.message}`);
        }
    }
    
    /**
     * Sets the page content
     * 
     * @param html HTML content
     * @param options Navigation options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when content is set
     */
    public async setContent(
        html: string,
        options: { timeout?: number; waitUntil?: 'load' | 'domcontentloaded' | 'networkidle' | 'commit' } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Get default timeout from options
            const playwrightOptions = this.playwrightManager.getOptions();
            const defaultTimeout = playwrightOptions.navigationTimeout || 30000;
            
            // Set content
            await page.setContent(html, {
                timeout: options.timeout || defaultTimeout,
                waitUntil: options.waitUntil || 'load'
            });
            
            CSLogger.debug('Set page content');
        } catch (error) {
            CSLogger.error(`Failed to set page content: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`SetContentFailure_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take set content failure screenshot: ${screenshotError.message}`);
            }
            
            throw new Error(`Failed to set page content: ${error.message}`);
        }
    }
    
    /**
     * Gets all elements matching a selector
     * 
     * @param selector Element selector
     * @param options Element options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the elements
     */
    public async getElements(
        selector: string,
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<Locator> {
        const page = this.getPage(pageId);
        
        try {
            return page.locator(selector);
        } catch (error) {
            CSLogger.error(`Failed to get elements ${selector}: ${error.message}`);
            throw new Error(`Failed to get elements ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Counts elements matching a selector
     * 
     * @param selector Element selector
     * @param options Count options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the element count
     */
    public async countElements(
        selector: string,
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<number> {
        const page = this.getPage(pageId);
        
        try {
            const locator = page.locator(selector);
            return await locator.count();
        } catch (error) {
            CSLogger.error(`Failed to count elements ${selector}: ${error.message}`);
            return 0;
        }
    }
    
    /**
     * Drags and drops an element
     * 
     * @param sourceSelector Source element selector
     * @param targetSelector Target element selector
     * @param options Drag options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when drag is complete
     */
    public async dragAndDrop(
        sourceSelector: string,
        targetSelector: string,
        options: { force?: boolean; timeout?: number; sourcePosition?: { x: number; y: number }; targetPosition?: { x: number; y: number } } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for source and target elements
            const source = await this.waitForElement(sourceSelector, { timeout: options.timeout }, pageId);
            const target = await this.waitForElement(targetSelector, { timeout: options.timeout }, pageId);
            
            // Drag and drop
            await source.dragTo(target, {
                force: options.force,
                sourcePosition: options.sourcePosition,
                targetPosition: options.targetPosition
            });
            
            CSLogger.debug(`Dragged ${sourceSelector} to ${targetSelector}`);
        } catch (error) {
            CSLogger.error(`Failed to drag and drop: ${error.message}`);
            
            // Take failure screenshot
            try {
                await this.takeScreenshot(`DragAndDropFailure_${Date.now()}`, {}, pageId);
            } catch (screenshotError) {
                CSLogger.warn(`Failed to take drag and drop failure screenshot: ${screenshotError.message}`);
            }
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to drag and drop: ${error.message}`);
        }
    }
    
    /**
     * Hovers over an element
     * 
     * @param selector Element selector
     * @param options Hover options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when hover is complete
     */
    public async hover(
        selector: string,
        options: { position?: { x: number; y: number }; force?: boolean; timeout?: number } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element
            const element = await this.waitForElement(selector, { timeout: options.timeout }, pageId);
            
            // Hover over element
            await element.hover({
                position: options.position,
                force: options.force
            });
            
            CSLogger.debug(`Hovered over ${selector}`);
        } catch (error) {
            CSLogger.error(`Failed to hover over ${selector}: ${error.message}`);
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to hover over ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Focuses an element
     * 
     * @param selector Element selector
     * @param options Focus options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when focus is complete
     */
    public async focus(
        selector: string,
        options: { timeout?: number } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            // Wait for element
            const element = await this.waitForElement(selector, { timeout: options.timeout }, pageId);
            
            // Focus element
            await element.focus();
            
            CSLogger.debug(`Focused on ${selector}`);
        } catch (error) {
            CSLogger.error(`Failed to focus on ${selector}: ${error.message}`);
            
            if (error instanceof ElementNotFoundException || error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new Error(`Failed to focus on ${selector}: ${error.message}`);
        }
    }
    
    /**
     * Presses a key on the keyboard
     * 
     * @param key Key to press
     * @param options Press options
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving when key press is complete
     */
    public async press(
        key: string,
        options: { delay?: number } = {},
        pageId?: string
    ): Promise<void> {
        const page = this.getPage(pageId);
        
        try {
            await page.keyboard.press(key, { delay: options.delay });
            CSLogger.debug(`Pressed key: ${key}`);
        } catch (error) {
            CSLogger.error(`Failed to press key ${key}: ${error.message}`);
            throw new Error(`Failed to press key ${key}: ${error.message}`);
        }
    }
    
    /**
     * Gets a locator that points to an element matching the specified selector
     * 
     * @param selector Element selector
     * @param options Locator options
     * @param pageId Page ID (uses default if not provided)
     * @returns The locator
     */
    public getLocator(
        selector: string,
        options: { hasText?: string | RegExp; has?: Locator } = {},
        pageId?: string
    ): Locator {
        const page = this.getPage(pageId);
        
        let locator = page.locator(selector);
        
        // Apply filters if provided
        if (options.hasText) {
            locator = locator.filter({ hasText: options.hasText });
        }
        
        if (options.has) {
            locator = locator.filter({ has: options.has });
        }
        
        return locator;
    }
    
    /**
     * Gets page info
     * 
     * @param pageId Page ID (uses default if not provided)
     * @returns Promise resolving to the page info
     */
    public async getPageInfo(pageId?: string): Promise<Record<string, any>> {
        const page = this.getPage(pageId);
        
        try {
            // Get page URL and title
            const url = await page.url();
            const title = await page.title();
            
            // Get viewport size
            const viewportSize = await this.getViewportSize(pageId);
            
            // Get context for the page
            const context = page.context();
            const browser = context.browser();
            
            // Get browser name and version
            const browserName = browser?.browserType().name() || 'unknown';
            const browserVersion = await browser?.version() || 'unknown';
            
            // Get page metrics
            const metrics = await this.getMetrics(pageId);
            
            // Get performance timing
            let timing: Record<string, any> = {};
            
            try {
                timing = await this.getPerformanceTiming(pageId);
            } catch (error) {
                CSLogger.debug(`Failed to get performance timing: ${error.message}`);
            }
            
            // Get cookies
            const cookies = await this.getCookies(url, pageId);
            
            // Get local storage
            let localStorage: Record<string, string> = {};
            
            try {
                localStorage = await page.evaluate(() => {
                    const storage: Record<string, string> = {};
                    for (let i = 0; i < window.localStorage.length; i++) {
                        const key = window.localStorage.key(i);
                        if (key) {
                            storage[key] = window.localStorage.getItem(key) || '';
                        }
                    }
                    return storage;
                });
            } catch (error) {
                CSLogger.debug(`Failed to get local storage: ${error.message}`);
            }
            
            // Get session storage
            let sessionStorage: Record<string, string> = {};
            
            try {
                sessionStorage = await page.evaluate(() => {
                    const storage: Record<string, string> = {};
                    for (let i = 0; i < window.sessionStorage.length; i++) {
                        const key = window.sessionStorage.key(i);
                        if (key) {
                            storage[key] = window.sessionStorage.getItem(key) || '';
                        }
                    }
                    return storage;
                });
            } catch (error) {
                CSLogger.debug(`Failed to get session storage: ${error.message}`);
            }
            
            return {
                id: pageId,
                url,
                title,
                viewport: viewportSize,
                browser: {
                    name: browserName,
                    version: browserVersion
                },
                metrics,
                timing,
                storage: {
                    cookies: cookies.length,
                    localStorage: Object.keys(localStorage).length,
                    sessionStorage: Object.keys(sessionStorage).length
                },
                frames: page.frames().length,
                isDefault: pageId === this.playwrightManager['defaultPageId']
            };
        } catch (error) {
            CSLogger.error(`Failed to get page info: ${error.message}`);
            
            return {
                id: pageId,
                error: error.message
            };
        }
    }
    
    /**
     * Creates a locator with text
     * 
     * @param text Text to find
     * @param options Text options
     * @param pageId Page ID (uses default if not provided)
     * @returns The locator
     */
    public getByText(
        text: string | RegExp,
        options: { exact?: boolean } = {},
        pageId?: string
    ): Locator {
        const page = this.getPage(pageId);
        return page.getByText(text, { exact: options.exact });
    }
    
    /**
     * Creates a locator with role
     * 
     * @param role Role to find
     * @param options Role options
     * @param pageId Page ID (uses default if not provided)
     * @returns The locator
     */
    public getByRole(
        role: 'alert' | 'alertdialog' | 'application' | 'article' | 'banner' | 'blockquote' | 'button' | 'caption' | 'cell' | 'checkbox' | 'code' | 'columnheader' | 'combobox' | 'complementary' | 'contentinfo' | 'definition' | 'deletion' | 'dialog' | 'directory' | 'document' | 'emphasis' | 'feed' | 'figure' | 'form' | 'generic' | 'grid' | 'gridcell' | 'group' | 'heading' | 'img' | 'insertion' | 'link' | 'list' | 'listbox' | 'listitem' | 'log' | 'main' | 'marquee' | 'math' | 'meter' | 'menu' | 'menubar' | 'menuitem' | 'menuitemcheckbox' | 'menuitemradio' | 'navigation' | 'none' | 'note' | 'option' | 'paragraph' | 'presentation' | 'progressbar' | 'radio' | 'radiogroup' | 'region' | 'row' | 'rowgroup' | 'rowheader' | 'scrollbar' | 'search' | 'searchbox' | 'separator' | 'slider' | 'spinbutton' | 'status' | 'strong' | 'subscript' | 'superscript' | 'switch' | 'tab' | 'table' | 'tablist' | 'tabpanel' | 'term' | 'textbox' | 'time' | 'timer' | 'toolbar' | 'tooltip' | 'tree' | 'treegrid' | 'treeitem',
        options: { exact?: boolean; name?: string | RegExp; checked?: boolean; disabled?: boolean; expanded?: boolean; includeHidden?: boolean; level?: number; pressed?: boolean; selected?: boolean } = {},
        pageId?: string
    ): Locator {
        const page = this.getPage(pageId);
        return page.getByRole(role, options);
    }
    
    /**
     * Creates a locator with label
     * 
     * @param text Label text to find
     * @param options Label options
     * @param pageId Page ID (uses default if not provided)
     * @returns The locator
     */
    public getByLabel(
        text: string | RegExp,
        options: { exact?: boolean } = {},
        pageId?: string
    ): Locator {
        const page = this.getPage(pageId);
        return page.getByLabel(text, { exact: options.exact });
    }
    
    /**
     * Creates a locator with placeholder
     * 
     * @param text Placeholder text to find
     * @param options Placeholder options
     * @param pageId Page ID (uses default if not provided)
     * @returns The locator
     */
    public getByPlaceholder(
        text: string | RegExp,
        options: { exact?: boolean } = {},
        pageId?: string
    ): Locator {
        const page = this.getPage(pageId);
        return page.getByPlaceholder(text, { exact: options.exact });
    }
    
    /**
     * Creates a locator with alt text
     * 
     * @param text Alt text to find
     * @param options Alt text options
     * @param pageId Page ID (uses default if not provided)
     * @returns The locator
     */
    public getByAltText(
        text: string | RegExp,
        options: { exact?: boolean } = {},
        pageId?: string
    ): Locator {
        const page = this.getPage(pageId);
        return page.getByAltText(text, { exact: options.exact });
    }
    
    /**
     * Creates a locator with title
     * 
     * @param text Title text to find
     * @param options Title options
     * @param pageId Page ID (uses default if not provided)
     * @returns The locator
     */
    public getByTitle(
        text: string | RegExp,
        options: { exact?: boolean } = {},
        pageId?: string
    ): Locator {
        const page = this.getPage(pageId);
        return page.getByTitle(text, { exact: options.exact });
    }
    
    /**
     * Creates a locator with test ID
     * 
     * @param testId Test ID to find
     * @param pageId Page ID (uses default if not provided)
     * @returns The locator
     */
    public getByTestId(
        testId: string | RegExp,
        pageId?: string
    ): Locator {
        const page = this.getPage(pageId);
        return page.getByTestId(testId);
    }
}



LaunchOptionsManager.ts
----------------------------------

import { LaunchOptions, BrowserType } from 'playwright';
import { PlaywrightOptions, BrowserTypes } from './PlaywrightManager';
import { CSLogger } from '../../core/utils/CSLogger';
import { ConfigurationManager } from '../../core/config/ConfigurationManager';
import path from 'path';
import os from 'os';

/**
 * Manager class for Playwright browser launch options
 */
export class LaunchOptionsManager {
    /**
     * Configuration manager
     */
    private configManager: ConfigurationManager;
    
    /**
     * Default browser executable paths by platform and browser type
     */
    private readonly defaultBrowserPaths: Record<string, Record<string, string>> = {
        win32: {
            chromium: path.join(process.env.PROGRAMFILES || 'C:\\Program Files', 'Google\\Chrome\\Application\\chrome.exe'),
            firefox: path.join(process.env.PROGRAMFILES || 'C:\\Program Files', 'Mozilla Firefox\\firefox.exe'),
            webkit: ''
        },
        darwin: {
            chromium: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
            firefox: '/Applications/Firefox.app/Contents/MacOS/firefox',
            webkit: '/Applications/Safari.app/Contents/MacOS/Safari'
        },
        linux: {
            chromium: '/usr/bin/google-chrome',
            firefox: '/usr/bin/firefox',
            webkit: ''
        }
    };
    
    /**
     * Browser type mappings
     */
    private readonly browserTypeMappings: Record<string, string[]> = {
        chromium: ['chrome', 'edge', 'brave', 'vivaldi', 'opera'],
        firefox: ['mozilla'],
        webkit: ['safari']
    };
    
    /**
     * Default browser arguments by browser type
     */
    private readonly defaultBrowserArgs: Record<string, string[]> = {
        chromium: [
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-breakpad',
            '--disable-component-extensions-with-background-pages',
            '--disable-dev-shm-usage',
            '--disable-extensions',
            '--disable-features=TranslateUI,BlinkGenPropertyTrees',
            '--disable-ipc-flooding-protection',
            '--disable-renderer-backgrounding',
            '--enable-automation',
            '--password-store=basic',
            '--use-mock-keychain'
        ],
        firefox: [
            '-wait-for-browser',
            '-foreground',
            '-no-remote',
            '-silent'
        ],
        webkit: []
    };
    
    /**
     * Default channel by browser type
     */
    private readonly defaultChannels: Record<string, string> = {
        chromium: 'chrome',
        firefox: '',
        webkit: ''
    };
    
    /**
     * Creates a new LaunchOptionsManager instance
     */
    constructor() {
        this.configManager = ConfigurationManager.getInstance();
        CSLogger.debug('LaunchOptionsManager initialized');
    }
    
    /**
     * Prepares browser launch options from PlaywrightOptions
     * 
     * @param options PlaywrightOptions
     * @returns LaunchOptions
     */
    public prepareLaunchOptions(options: PlaywrightOptions): LaunchOptions {
        // Start with base options from PlaywrightOptions.launchOptions
        const launchOptions: LaunchOptions = {
            ...(options.launchOptions || {})
        };
        
        // Set headless mode if provided
        if (options.headless !== undefined) {
            launchOptions.headless = options.headless;
        } else {
            // Default to headless from config
            launchOptions.headless = this.configManager.getBoolean('playwright.browser.headless', true);
        }
        
        // Set slow motion if provided
        if (options.slowMo !== undefined) {
            launchOptions.slowMo = options.slowMo;
        }
        
        // Set environment variables if provided
        if (options.env) {
            launchOptions.env = options.env;
        }
        
        // Set channel if not already set
        if (!launchOptions.channel) {
            launchOptions.channel = this.getDefaultChannel(options.browserType);
        }
        
        // Set executable path if not already set
        if (!launchOptions.executablePath) {
            const executablePath = this.getExecutablePath(options.browserType);
            
            if (executablePath) {
                launchOptions.executablePath = executablePath;
            }
        }
        
        // Set default browser arguments if not already set
        if (!launchOptions.args) {
            launchOptions.args = this.getDefaultArgs(options.browserType);
        }
        
        // Set log-related options
        const devtoolsLogging = this.configManager.getBoolean('playwright.browser.devtoolsLogging', false);
        
        if (devtoolsLogging) {
            if (options.browserType === BrowserTypes.CHROMIUM) {
                if (!launchOptions.args) {
                    launchOptions.args = [];
                }
                
                if (!launchOptions.args.some(arg => arg.startsWith('--enable-logging'))) {
                    launchOptions.args.push('--enable-logging=stderr');
                    launchOptions.args.push('--v=1');
                }
            }
        }
        
        // Set screen recording options for Chromium
        if (options.recordVideo && options.browserType === BrowserTypes.CHROMIUM) {
            if (!launchOptions.args) {
                launchOptions.args = [];
            }
            
            // Add screen recording arguments if not already present
            if (!launchOptions.args.some(arg => arg.includes('--use-fake-ui-for-media-stream'))) {
                launchOptions.args.push('--use-fake-ui-for-media-stream');
            }
            
            if (!launchOptions.args.some(arg => arg.includes('--use-fake-device-for-media-stream'))) {
                launchOptions.args.push('--use-fake-device-for-media-stream');
            }
        }
        
        // Set browser viewport if provided
        if (options.viewport) {
            if (!launchOptions.args) {
                launchOptions.args = [];
            }
            
            // Add viewport arguments if not already present
            if (options.browserType === BrowserTypes.CHROMIUM && !launchOptions.args.some(arg => arg.includes('--window-size'))) {
                launchOptions.args.push(`--window-size=${options.viewport.width},${options.viewport.height}`);
            }
        }
        
        // Set downloads path
        if (options.downloadsPath && options.browserType === BrowserTypes.CHROMIUM) {
            if (!launchOptions.args) {
                launchOptions.args = [];
            }
            
            // Add downloads path argument if not already present
            if (!launchOptions.args.some(arg => arg.includes('--download-default-directory'))) {
                launchOptions.args.push(`--download-default-directory=${options.downloadsPath}`);
            }
        }
        
        // Set proxy options if configured
        const proxyEnabled = this.configManager.getBoolean('playwright.proxy.enabled', false);
        
        if (proxyEnabled && !launchOptions.proxy) {
            const proxyServer = this.configManager.getString('playwright.proxy.server', '');
            
            if (proxyServer) {
                launchOptions.proxy = {
                    server: proxyServer,
                    bypass: this.configManager.getString('playwright.proxy.bypass', ''),
                    username: this.configManager.getString('playwright.proxy.username', ''),
                    password: this.configManager.getString('playwright.proxy.password', '')
                };
            }
        }
        
        // Log launch options
        CSLogger.debug(`Prepared launch options for ${options.browserType}: ${JSON.stringify({
            ...launchOptions,
            // Mask sensitive data
            proxy: launchOptions.proxy ? {
                ...launchOptions.proxy,
                password: launchOptions.proxy.password ? '******' : undefined
            } : undefined
        })}`);
        
        return launchOptions;
    }
    
    /**
     * Gets default browser arguments by browser type
     * 
     * @param browserType Browser type
     * @returns Default browser arguments
     */
    public getDefaultArgs(browserType: BrowserTypes): string[] {
        return [...this.defaultBrowserArgs[browserType] || []];
    }
    
    /**
     * Gets default browser channel by browser type
     * 
     * @param browserType Browser type
     * @returns Default browser channel
     */
    public getDefaultChannel(browserType: BrowserTypes): string {
        return this.defaultChannels[browserType] || '';
    }
    
    /**
     * Gets browser executable path
     * 
     * @param browserType Browser type
     * @returns Browser executable path
     */
    public getExecutablePath(browserType: BrowserTypes): string {
        // Try to get from configuration
        const configPath = this.configManager.getString(`playwright.browser.${browserType}.executablePath`, '');
        
        if (configPath) {
            return configPath;
        }
        
        // Get platform
        const platform = os.platform();
        
        // Get default path for platform and browser type
        return this.defaultBrowserPaths[platform]?.[browserType] || '';
    }
    
    /**
     * Resolves a browser type string to BrowserTypes enum
     * 
     * @param browserType Browser type string
     * @returns BrowserTypes enum value
     */
    public resolveBrowserType(browserType: string): BrowserTypes {
        // Direct match
        if (Object.values(BrowserTypes).includes(browserType as BrowserTypes)) {
            return browserType as BrowserTypes;
        }
        
        // Check mappings
        const normalizedType = browserType.toLowerCase();
        
        for (const [type, aliases] of Object.entries(this.browserTypeMappings)) {
            if (aliases.includes(normalizedType)) {
                return type as BrowserTypes;
            }
        }
        
        // Default to Chromium
        CSLogger.warn(`Unknown browser type ${browserType}, defaulting to Chromium`);
        return BrowserTypes.CHROMIUM;
    }
    
    /**
     * Prepares and returns connect options for remote browsers
     * 
     * @param options Remote browser options
     * @returns Connect options
     */
    public prepareConnectOptions(
        options: {
            wsEndpoint?: string;
            browserWSEndpoint?: string;
            browserURL?: string;
            timeout?: number;
            headers?: Record<string, string>;
            slowMo?: number;
        }
    ): Record<string, any> {
        // Start with provided options
        const connectOptions: Record<string, any> = { ...options };
        
        // Set default timeout if not provided
        if (!connectOptions.timeout) {
            connectOptions.timeout = this.configManager.getNumber('playwright.connect.timeout', 30000);
        }
        
        // Log connect options
        CSLogger.debug(`Prepared connect options: ${JSON.stringify({
            ...connectOptions,
            // Mask sensitive headers
            headers: connectOptions.headers ? '******' : undefined
        })}`);
        
        return connectOptions;
    }
    
    /**
     * Gets launch options for a specific browser type and configuration
     * 
     * @param browserType Browser type
     * @param profile Browser profile name (e.g., 'default', 'headless', 'default-with-extensions')
     * @returns Launch options
     */
    public getLaunchOptionsForProfile(
        browserType: BrowserTypes,
        profile: string = 'default'
    ): LaunchOptions {
        // Get base options for browser type
        const baseOptions: PlaywrightOptions = {
            browserType,
            headless: this.configManager.getBoolean('playwright.browser.headless', true),
            slowMo: this.configManager.getNumber('playwright.slowMo', 0)
        };
        
        // Modify based on profile
        switch (profile) {
            case 'headless':
                baseOptions.headless = true;
                break;
                
            case 'headed':
                baseOptions.headless = false;
                break;
                
            case 'debug':
                baseOptions.headless = false;
                baseOptions.slowMo = 100;
                baseOptions.env = { ...baseOptions.env, PWDEBUG: '1' };
                break;
                
            case 'default-with-extensions':
                baseOptions.headless = false;
                
                // Allow extensions for Chromium
                if (browserType === BrowserTypes.CHROMIUM) {
                    baseOptions.launchOptions = {
                        ...baseOptions.launchOptions,
                        args: this.getDefaultArgs(browserType).filter(arg => arg !== '--disable-extensions')
                    };
                }
                break;
                
            case 'incognito':
                // Incognito mode is handled at the context level, not launch options
                baseOptions.contextOptions = {
                    ...baseOptions.contextOptions
                };
                break;

            case 'performance':
                // Configure for performance testing
                baseOptions.headless = true;
                baseOptions.launchOptions = {
                    ...baseOptions.launchOptions,
                    args: [
                        ...(this.getDefaultArgs(browserType)),
                        '--disable-gpu',
                        '--disable-dev-shm-usage',
                        '--no-sandbox',
                        '--disable-setuid-sandbox',
                        '--js-flags=--expose-gc'
                    ]
                };
                break;
                
            case 'mobile-emulation':
                // Mobile emulation is handled at the context level with device descriptors
                baseOptions.headless = false;
                baseOptions.deviceName = 'Pixel 5'; // Will be applied in context options
                break;
                
            default:
                // Use default configuration
                break;
        }
        
        // Prepare and return launch options
        return this.prepareLaunchOptions(baseOptions);
    }
    
    /**
     * Modifies launch options to add debugging capabilities
     * 
     * @param options Launch options to modify
     * @returns Modified launch options
     */
    public addDebuggingOptions(options: LaunchOptions): LaunchOptions {
        const modifiedOptions = { ...options };
        
        // Enable debug logging
        modifiedOptions.env = {
            ...(modifiedOptions.env || {}),
            PWDEBUG: '1'
        };
        
        // Ensure we're not in headless mode for debugging
        modifiedOptions.headless = false;
        
        // Add debug port for Chrome DevTools Protocol
        if (!modifiedOptions.args) {
            modifiedOptions.args = [];
        }
        
        // Generate random port between 9222 and 9999 to avoid conflicts
        const debugPort = Math.floor(Math.random() * (9999 - 9222 + 1)) + 9222;
        
        // Add debug port if not already present
        if (!modifiedOptions.args.some(arg => arg.includes('--remote-debugging-port'))) {
            modifiedOptions.args.push(`--remote-debugging-port=${debugPort}`);
        }
        
        // Add slow motion for easier debugging
        if (modifiedOptions.slowMo === undefined) {
            modifiedOptions.slowMo = 100;
        }
        
        return modifiedOptions;
    }
    
    /**
     * Modifies launch options to add trace recording capabilities
     * 
     * @param options Launch options to modify
     * @returns Modified launch options
     */
    public addTraceOptions(options: LaunchOptions): LaunchOptions {
        const modifiedOptions = { ...options };
        
        // Set environment variables for tracing
        modifiedOptions.env = {
            ...(modifiedOptions.env || {}),
            PLAYWRIGHT_TRACE: '1'
        };
        
        // No additional args needed for tracing as it's handled by the context
        
        return modifiedOptions;
    }
    
    /**
     * Modifies launch options to optimize for CI environments
     * 
     * @param options Launch options to modify
     * @returns Modified launch options
     */
    public optimizeForCI(options: LaunchOptions): LaunchOptions {
        const modifiedOptions = { ...options };
        
        // Ensure headless mode
        modifiedOptions.headless = true;
        
        // Add arguments for CI environment
        if (!modifiedOptions.args) {
            modifiedOptions.args = [];
        }
        
        // Add CI-specific arguments if not already present
        const ciArgs = [
            '--disable-gpu',
            '--disable-dev-shm-usage',
            '--no-sandbox',
            '--disable-setuid-sandbox'
        ];
        
        for (const arg of ciArgs) {
            if (!modifiedOptions.args.includes(arg)) {
                modifiedOptions.args.push(arg);
            }
        }
        
        return modifiedOptions;
    }
    
    /**
     * Modifies launch options to use a specific user data directory
     * 
     * @param options Launch options to modify
     * @param userDataDir User data directory path
     * @returns Modified launch options
     */
    public useUserDataDir(options: LaunchOptions, userDataDir: string): LaunchOptions {
        const modifiedOptions = { ...options };
        
        // Add user data directory argument
        if (!modifiedOptions.args) {
            modifiedOptions.args = [];
        }
        
        // Remove any existing user data directory arguments
        modifiedOptions.args = modifiedOptions.args.filter(arg => !arg.includes('--user-data-dir'));
        
        // Add new user data directory argument
        modifiedOptions.args.push(`--user-data-dir=${userDataDir}`);
        
        return modifiedOptions;
    }
    
    /**
     * Gets optimal launch options for the current environment
     * 
     * @param browserType Browser type
     * @returns Launch options
     */
    public getOptimalLaunchOptions(browserType: BrowserTypes): LaunchOptions {
        // Start with default options
        const baseOptions: PlaywrightOptions = {
            browserType,
            headless: this.configManager.getBoolean('playwright.browser.headless', true),
            slowMo: this.configManager.getNumber('playwright.slowMo', 0)
        };
        
        // Detect environment
        const isCI = process.env.CI === 'true' || process.env.CONTINUOUS_INTEGRATION === 'true';
        const isDocker = this.isRunningInDocker();
        const isLowMemory = this.isLowMemoryEnvironment();
        const isMobile = this.isMobileDevice();
        
        // Optimize based on environment
        if (isCI || isDocker) {
            // CI/Docker optimizations
            baseOptions.headless = true;
            baseOptions.launchOptions = {
                args: [
                    ...(this.getDefaultArgs(browserType)),
                    '--disable-gpu',
                    '--disable-dev-shm-usage',
                    '--no-sandbox',
                    '--disable-setuid-sandbox'
                ]
            };
        } else if (isLowMemory) {
            // Low memory optimizations
            baseOptions.headless = true;
            baseOptions.launchOptions = {
                args: [
                    ...(this.getDefaultArgs(browserType)),
                    '--disable-gpu',
                    '--disable-dev-shm-usage',
                    '--disable-extensions',
                    '--disable-component-extensions-with-background-pages'
                ]
            };
        } else if (isMobile) {
            // Mobile device optimizations
            baseOptions.headless = true;
            baseOptions.launchOptions = {
                args: [
                    ...(this.getDefaultArgs(browserType)),
                    '--disable-gpu',
                    '--disable-dev-shm-usage'
                ]
            };
        }
        
        // Prepare and return launch options
        return this.prepareLaunchOptions(baseOptions);
    }
    
    /**
     * Checks if the environment is running in Docker
     * 
     * @returns Whether the environment is running in Docker
     */
    private isRunningInDocker(): boolean {
        try {
            // Check for .dockerenv file
            const fs = require('fs');
            if (fs.existsSync('/.dockerenv')) {
                return true;
            }
            
            // Check for Docker in cgroup
            const cgroupContent = fs.readFileSync('/proc/1/cgroup', 'utf8');
            return cgroupContent.includes('docker');
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Checks if the environment has low memory
     * 
     * @returns Whether the environment has low memory
     */
    private isLowMemoryEnvironment(): boolean {
        try {
            const totalMemory = os.totalmem();
            const memoryInGB = totalMemory / (1024 * 1024 * 1024);
            
            // Consider environments with less than 4GB RAM as low memory
            return memoryInGB < 4;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Checks if the device is a mobile device
     * 
     * @returns Whether the device is a mobile device
     */
    private isMobileDevice(): boolean {
        // This is a simplified check, as in most cases, we won't be running on actual mobile devices
        // but rather emulating them. We're checking based on memory constraints.
        try {
            const totalMemory = os.totalmem();
            const memoryInGB = totalMemory / (1024 * 1024 * 1024);
            
            // Consider environments with less than 2GB RAM as potentially mobile
            return memoryInGB < 2;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Modifies launch options to use a custom browser executable
     * 
     * @param options Launch options to modify
     * @param executablePath Path to the browser executable
     * @returns Modified launch options
     */
    public useCustomExecutable(options: LaunchOptions, executablePath: string): LaunchOptions {
        const modifiedOptions = { ...options };
        
        // Set executable path
        modifiedOptions.executablePath = executablePath;
        
        return modifiedOptions;
    }
    
    /**
     * Creates launch options for running in headless mode
     * 
     * @param browserType Browser type
     * @returns Launch options
     */
    public createHeadlessOptions(browserType: BrowserTypes): LaunchOptions {
        return this.prepareLaunchOptions({
            browserType,
            headless: true
        });
    }
    
    /**
     * Creates launch options for running in headed mode
     * 
     * @param browserType Browser type
     * @returns Launch options
     */
    public createHeadedOptions(browserType: BrowserTypes): LaunchOptions {
        return this.prepareLaunchOptions({
            browserType,
            headless: false
        });
    }
    
    /**
     * Creates launch options for using a specific browser channel
     * 
     * @param browserType Browser type
     * @param channel Browser channel
     * @returns Launch options
     */
    public createChannelOptions(browserType: BrowserTypes, channel: string): LaunchOptions {
        return this.prepareLaunchOptions({
            browserType,
            launchOptions: {
                channel
            }
        });
    }
    
    /**
     * Creates launch options for using a persistent context
     * 
     * @param browserType Browser type
     * @param userDataDir User data directory path
     * @returns Launch options
     */
    public createPersistentContextOptions(browserType: BrowserTypes, userDataDir: string): LaunchOptions {
        const options = this.prepareLaunchOptions({
            browserType,
            headless: false // Persistent contexts typically need headed mode
        });
        
        return this.useUserDataDir(options, userDataDir);
    }
    
    /**
     * Validates launch options and reports any issues
     * 
     * @param options Launch options to validate
     * @param browserType Browser type
     * @returns Validation result
     */
    public validateLaunchOptions(options: LaunchOptions, browserType: BrowserTypes): { valid: boolean; issues: string[] } {
        const issues: string[] = [];
        
        // Check executablePath if provided
        if (options.executablePath) {
            const fs = require('fs');
            if (!fs.existsSync(options.executablePath)) {
                issues.push(`Executable path does not exist: ${options.executablePath}`);
            }
        }
        
        // Check for incompatible arguments
        if (options.args) {
            // Check for conflicting headless arguments
            const hasHeadlessArg = options.args.some(arg => arg.includes('--headless'));
            if (hasHeadlessArg && options.headless === false) {
                issues.push('Conflicting headless settings: options.headless is false but args includes --headless');
            }
            
            // Check for device emulation with non-Chrome browsers
            const hasDeviceEmulation = options.args.some(arg => arg.includes('--emulate'));
            if (hasDeviceEmulation && browserType !== BrowserTypes.CHROMIUM) {
                issues.push(`Device emulation via command line is only supported in Chromium, not ${browserType}`);
            }
            
            // Check for conflicting GPU arguments
            const hasEnableGpu = options.args.some(arg => arg === '--enable-gpu');
            const hasDisableGpu = options.args.some(arg => arg === '--disable-gpu');
            if (hasEnableGpu && hasDisableGpu) {
                issues.push('Conflicting GPU settings: both --enable-gpu and --disable-gpu are specified');
            }
        }
        
        // Check channel compatibility
        if (options.channel) {
            if (browserType === BrowserTypes.WEBKIT && options.channel) {
                issues.push('Channel option is not supported for WebKit');
            }
            
            if (browserType === BrowserTypes.FIREFOX && options.channel && options.channel !== 'firefox' && options.channel !== 'nightly') {
                issues.push(`Unsupported Firefox channel: ${options.channel}. Supported channels are 'firefox' and 'nightly'`);
            }
            
            if (browserType === BrowserTypes.CHROMIUM && options.channel) {
                const supportedChannels = ['chrome', 'chrome-beta', 'chrome-dev', 'chrome-canary', 'msedge', 'msedge-beta', 'msedge-dev', 'msedge-canary'];
                if (!supportedChannels.includes(options.channel)) {
                    issues.push(`Unsupported Chromium channel: ${options.channel}. Supported channels are: ${supportedChannels.join(', ')}`);
                }
            }
        }
        
        // Check proxy configuration
        if (options.proxy) {
            if (!options.proxy.server) {
                issues.push('Proxy configuration is missing the server property');
            }
        }
        
        // Check for incompatible options with headless mode
        if (options.headless && options.devtools) {
            issues.push('DevTools can only be used in headed mode, not with headless: true');
        }
        
        // Check for sandboxing issues
        const hasSandbox = options.args && options.args.some(arg => arg === '--no-sandbox');
        if (hasSandbox && process.platform !== 'linux') {
            issues.push('--no-sandbox argument is typically only needed on Linux');
        }
        
        return {
            valid: issues.length === 0,
            issues
        };
    }
    
    /**
     * Creates optimized launch options for specific testing scenarios
     * 
     * @param browserType Browser type
     * @param scenario Testing scenario
     * @returns Launch options
     */
    public createScenarioOptions(
        browserType: BrowserTypes,
        scenario: 'regression' | 'performance' | 'visual' | 'accessibility' | 'security'
    ): LaunchOptions {
        switch (scenario) {
            case 'regression':
                // Regular regression testing - stable, predictable environment
                return this.prepareLaunchOptions({
                    browserType,
                    headless: true,
                    launchOptions: {
                        args: [
                            ...(this.getDefaultArgs(browserType)),
                            '--disable-gpu',
                            '--disable-dev-shm-usage'
                        ]
                    }
                });
                
            case 'performance':
                // Performance testing - minimize overhead
                return this.prepareLaunchOptions({
                    browserType,
                    headless: true,
                    launchOptions: {
                        args: [
                            ...(this.getDefaultArgs(browserType)),
                            '--disable-gpu',
                            '--disable-dev-shm-usage',
                            '--disable-extensions',
                            '--js-flags=--expose-gc'
                        ]
                    }
                });
                
            case 'visual':
                // Visual testing - consistent rendering environment
                return this.prepareLaunchOptions({
                    browserType,
                    headless: true,
                    launchOptions: {
                        args: [
                            ...(this.getDefaultArgs(browserType)),
                            '--force-device-scale-factor=1',
                            '--disable-font-subpixel-positioning',
                            '--disable-lcd-text'
                        ]
                    }
                });
                
            case 'accessibility':
                // Accessibility testing - with screen reader support
                return this.prepareLaunchOptions({
                    browserType,
                    headless: false, // Headed mode for accessibility tools
                    launchOptions: {
                        args: [
                            ...(this.getDefaultArgs(browserType)),
                            '--force-renderer-accessibility'
                        ]
                    }
                });
                
            case 'security':
                // Security testing - tightened security settings
                return this.prepareLaunchOptions({
                    browserType,
                    headless: true,
                    launchOptions: {
                        args: [
                            ...(this.getDefaultArgs(browserType)),
                            '--disable-web-security=false',
                            '--disable-site-isolation-trials=false',
                            '--disable-features=IsolateOrigins,site-per-process',
                            '--disable-extensions'
                        ]
                    }
                });
                
            default:
                return this.prepareLaunchOptions({ browserType });
        }
    }
}



CSElement.ts
-------------------------------

import { Locator, Page, ElementHandle, Frame, BoundingBox, JSHandle } from 'playwright';
import { CSLogger } from '../../core/utils/CSLogger';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { WaitTimeoutException } from '../../core/exceptions/WaitTimeoutException';
import { CSElement as CSElementType } from '../../types/element';

/**
 * Enhanced wrapper for Playwright Locator/ElementHandle with additional functionality.
 * This class provides a common API between Selenium and Playwright elements.
 */
export class CSElement implements CSElementType {
    /**
     * The Playwright Locator for this element
     */
    private locator: Locator;
    
    /**
     * The Playwright Page instance
     */
    private page: Page;
    
    /**
     * The Frame containing this element (if applicable)
     */
    private frame?: Frame;
    
    /**
     * The element selector
     */
    private selector: string;
    
    /**
     * Default timeout for element operations in milliseconds
     */
    private defaultTimeout: number = 30000;
    
    /**
     * Whether to highlight elements during interactions
     */
    private highlightOnInteraction: boolean = false;
    
    /**
     * The parent CSElement (if any)
     */
    private parent?: CSElement;
    
    /**
     * Cache for the element handle (to reduce lookups)
     */
    private elementHandleCache?: ElementHandle;
    
    /**
     * Time when the element handle cache was last updated
     */
    private elementHandleCacheTime: number = 0;
    
    /**
     * Maximum age of the element handle cache in milliseconds
     */
    private elementHandleCacheMaxAge: number = 1000; // 1 second
    
    /**
     * Creates a new CSElement instance
     * 
     * @param locatorOrSelector Playwright Locator or selector string
     * @param page Playwright Page instance
     * @param frame Optional frame containing the element
     */
    constructor(
        locatorOrSelector: Locator | string,
        page: Page,
        frame?: Frame
    ) {
        this.page = page;
        this.frame = frame;
        
        // If a string selector is provided, create a locator
        if (typeof locatorOrSelector === 'string') {
            this.selector = locatorOrSelector;
            this.locator = frame ? frame.locator(locatorOrSelector) : page.locator(locatorOrSelector);
        } else {
            // Otherwise use the provided locator
            this.locator = locatorOrSelector;
            
            // Try to get the selector from the locator
            try {
                // This is an approximation as Playwright doesn't expose the selector directly
                this.selector = String(locatorOrSelector);
            } catch (error) {
                this.selector = 'unknown';
            }
        }
        
        CSLogger.debug(`Created CSElement for selector: ${this.selector}`);
    }
    
    /**
     * Gets the underlying Playwright Locator
     * 
     * @returns The Playwright Locator
     */
    public getLocator(): Locator {
        return this.locator;
    }
    
    /**
     * Gets the Playwright Page instance
     * 
     * @returns The Playwright Page
     */
    public getPage(): Page {
        return this.page;
    }
    
    /**
     * Gets the element selector
     * 
     * @returns The element selector
     */
    public getSelector(): string {
        return this.selector;
    }
    
    /**
     * Sets the default timeout for element operations
     * 
     * @param timeout Timeout in milliseconds
     */
    public setDefaultTimeout(timeout: number): void {
        this.defaultTimeout = timeout;
    }
    
    /**
     * Gets the default timeout for element operations
     * 
     * @returns Timeout in milliseconds
     */
    public getDefaultTimeout(): number {
        return this.defaultTimeout;
    }
    
    /**
     * Enables or disables element highlighting during interactions
     * 
     * @param enable Whether to enable highlighting
     */
    public setHighlightOnInteraction(enable: boolean): void {
        this.highlightOnInteraction = enable;
    }
    
    /**
     * Sets the parent CSElement
     * 
     * @param parent Parent CSElement
     */
    public setParent(parent: CSElement): void {
        this.parent = parent;
    }
    
    /**
     * Gets the parent CSElement
     * 
     * @returns Parent CSElement or undefined if none
     */
    public getParent(): CSElement | undefined {
        return this.parent;
    }
    
    /**
     * Clicks the element
     * 
     * @param options Click options
     * @returns Promise resolving when the click is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async click(
        options: {
            button?: 'left' | 'right' | 'middle';
            clickCount?: number;
            delay?: number;
            position?: { x: number; y: number };
            force?: boolean;
            timeout?: number;
            noWaitAfter?: boolean;
            trial?: boolean;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Click the element
            await this.locator.click({
                button: options.button,
                clickCount: options.clickCount,
                delay: options.delay,
                position: options.position,
                force: options.force,
                timeout,
                noWaitAfter: options.noWaitAfter,
                trial: options.trial
            });
            
            CSLogger.debug(`Clicked element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to click element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to click element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to click element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Double-clicks the element
     * 
     * @param options Double-click options
     * @returns Promise resolving when the double-click is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async doubleClick(
        options: {
            button?: 'left' | 'right' | 'middle';
            delay?: number;
            position?: { x: number; y: number };
            force?: boolean;
            timeout?: number;
            noWaitAfter?: boolean;
            trial?: boolean;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Double-click the element
            await this.locator.dblclick({
                button: options.button,
                delay: options.delay,
                position: options.position,
                force: options.force,
                timeout,
                noWaitAfter: options.noWaitAfter,
                trial: options.trial
            });
            
            CSLogger.debug(`Double-clicked element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to double-click element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to double-click element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to double-click element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Right-clicks the element
     * 
     * @param options Right-click options
     * @returns Promise resolving when the right-click is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async rightClick(
        options: {
            delay?: number;
            position?: { x: number; y: number };
            force?: boolean;
            timeout?: number;
            noWaitAfter?: boolean;
            trial?: boolean;
        } = {}
    ): Promise<void> {
        // Use the click method with right button
        return this.click({
            ...options,
            button: 'right'
        });
    }
    
    /**
     * Types text into the element
     * 
     * @param text Text to type
     * @param options Type options
     * @returns Promise resolving when typing is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async type(
        text: string,
        options: {
            delay?: number;
            noWaitAfter?: boolean;
            timeout?: number;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Type into the element
            await this.locator.type(text, {
                delay: options.delay,
                noWaitAfter: options.noWaitAfter,
                timeout
            });
            
            CSLogger.debug(`Typed text into element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to type text into element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to type into element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to type text into element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Fills the element with text (clearing existing content)
     * 
     * @param text Text to fill
     * @param options Fill options
     * @returns Promise resolving when filling is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async fill(
        text: string,
        options: {
            force?: boolean;
            noWaitAfter?: boolean;
            timeout?: number;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Fill the element
            await this.locator.fill(text, {
                force: options.force,
                noWaitAfter: options.noWaitAfter,
                timeout
            });
            
            CSLogger.debug(`Filled element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to fill element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to fill element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to fill element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Clears the element's content
     * 
     * @param options Clear options
     * @returns Promise resolving when clearing is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async clear(
        options: {
            force?: boolean;
            noWaitAfter?: boolean;
            timeout?: number;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Clear the element
            await this.locator.clear({
                force: options.force,
                noWaitAfter: options.noWaitAfter,
                timeout
            });
            
            CSLogger.debug(`Cleared element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to clear element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to clear element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to clear element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets text content of the element
     * 
     * @param options Text options
     * @returns Promise resolving to the element's text
     * @throws ElementNotFoundException if the element is not found
     */
    public async getText(
        options: {
            timeout?: number;
            trim?: boolean;
        } = {}
    ): Promise<string> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get text content
            const textContent = await this.locator.textContent({ timeout });
            
            // Process text based on options
            const text = textContent || '';
            return options.trim !== false ? text.trim() : text;
        } catch (error) {
            CSLogger.error(`Failed to get text from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get text from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get text from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets inner text of the element
     * 
     * @param options Text options
     * @returns Promise resolving to the element's inner text
     * @throws ElementNotFoundException if the element is not found
     */
    public async getInnerText(
        options: {
            timeout?: number;
            trim?: boolean;
        } = {}
    ): Promise<string> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get inner text
            const innerText = await this.locator.innerText({ timeout });
            
            // Process text based on options
            return options.trim !== false ? innerText.trim() : innerText;
        } catch (error) {
            CSLogger.error(`Failed to get inner text from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get inner text from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get inner text from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the value of an attribute
     * 
     * @param attributeName Attribute name
     * @param options Attribute options
     * @returns Promise resolving to the attribute value
     * @throws ElementNotFoundException if the element is not found
     */
    public async getAttribute(
        attributeName: string,
        options: {
            timeout?: number;
        } = {}
    ): Promise<string | null> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get attribute value
            return await this.locator.getAttribute(attributeName, { timeout });
        } catch (error) {
            CSLogger.error(`Failed to get attribute ${attributeName} from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get attribute ${attributeName} from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get attribute ${attributeName} from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the value of a property
     * 
     * @param propertyName Property name
     * @param options Property options
     * @returns Promise resolving to the property value
     * @throws ElementNotFoundException if the element is not found
     */
    public async getProperty<T>(
        propertyName: string,
        options: {
            timeout?: number;
        } = {}
    ): Promise<T | null> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Get property
            const propertyHandle = await elementHandle.getProperty(propertyName);
            
            // Get property value
            const value = await propertyHandle.jsonValue() as T;
            
            // Release the handle
            await propertyHandle.dispose();
            
            return value;
        } catch (error) {
            CSLogger.error(`Failed to get property ${propertyName} from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get property ${propertyName} from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get property ${propertyName} from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Checks if the element is displayed (visible)
     * 
     * @param options Visibility options
     * @returns Promise resolving to whether the element is displayed
     */
    public async isDisplayed(
        options: {
            timeout?: number;
        } = {}
    ): Promise<boolean> {
        try {
            // Check if element is visible
            return await this.locator.isVisible({
                timeout: options.timeout || 1000 // Short timeout for visibility check
            });
        } catch (error) {
            CSLogger.debug(`Error checking if element ${this.selector} is displayed: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Checks if the element is enabled
     * 
     * @param options Enabled options
     * @returns Promise resolving to whether the element is enabled
     */
    public async isEnabled(
        options: {
            timeout?: number;
        } = {}
    ): Promise<boolean> {
        try {
            // Check if element is enabled
            return await this.locator.isEnabled({
                timeout: options.timeout || 1000 // Short timeout for enabled check
            });
        } catch (error) {
            CSLogger.debug(`Error checking if element ${this.selector} is enabled: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Checks if the element is selected (for checkboxes, radio buttons, and options)
     * 
     * @param options Selected options
     * @returns Promise resolving to whether the element is selected
     */
    public async isSelected(
        options: {
            timeout?: number;
        } = {}
    ): Promise<boolean> {
        try {
            // Check if element is checked
            return await this.locator.isChecked({
                timeout: options.timeout || 1000 // Short timeout for selected check
            });
        } catch (error) {
            CSLogger.debug(`Error checking if element ${this.selector} is selected: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Checks if the element has a specific CSS class
     * 
     * @param className CSS class name
     * @param options Class options
     * @returns Promise resolving to whether the element has the class
     */
    public async hasClass(
        className: string,
        options: {
            timeout?: number;
        } = {}
    ): Promise<boolean> {
        try {
            // Get the class attribute
            const classAttribute = await this.getAttribute('class', options);
            
            // Check if class is present
            if (!classAttribute) {
                return false;
            }
            
            // Split classes and check if the specified class is present
            const classes = classAttribute.split(/\s+/);
            return classes.includes(className);
        } catch (error) {
            CSLogger.debug(`Error checking if element ${this.selector} has class ${className}: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Gets the element's bounding box
     * 
     * @param options Bounding box options
     * @returns Promise resolving to the bounding box
     * @throws ElementNotFoundException if the element is not found
     */
    public async getBoundingBox(
        options: {
            timeout?: number;
        } = {}
    ): Promise<BoundingBox | null> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get element bounding box
            return await this.locator.boundingBox({ timeout });
        } catch (error) {
            CSLogger.error(`Failed to get bounding box for element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get bounding box for element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get bounding box for element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Hovers over the element
     * 
     * @param options Hover options
     * @returns Promise resolving when hover is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async hover(
        options: {
            force?: boolean;
            position?: { x: number; y: number };
            timeout?: number;
            noWaitAfter?: boolean;
            trial?: boolean;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Hover over element
            await this.locator.hover({
                force: options.force,
                position: options.position,
                timeout,
                noWaitAfter: options.noWaitAfter,
                trial: options.trial
            });
            
            CSLogger.debug(`Hovered over element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to hover over element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to hover over element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to hover over element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Drags the element to a target element
     * 
     * @param target Target element
     * @param options Drag options
     * @returns Promise resolving when drag is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async dragTo(
        target: CSElement,
        options: {
            force?: boolean;
            sourcePosition?: { x: number; y: number };
            targetPosition?: { x: number; y: number };
            timeout?: number;
            noWaitAfter?: boolean;
            trial?: boolean;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight elements if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
                await target.highlight();
            }
            
            // Drag element to target
            await this.locator.dragTo(target.getLocator(), {
                force: options.force,
                sourcePosition: options.sourcePosition,
                targetPosition: options.targetPosition,
                timeout,
                noWaitAfter: options.noWaitAfter,
                trial: options.trial
            });
            
            CSLogger.debug(`Dragged element ${this.selector} to ${target.getSelector()}`);
        } catch (error) {
            CSLogger.error(`Failed to drag element ${this.selector} to ${target.getSelector()}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to drag element ${this.selector} to ${target.getSelector()}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to drag element ${this.selector} to ${target.getSelector()}: ${error.message}`, error);
        }
    }
    
    /**
     * Selects an option from a select element
     * 
     * @param values Values to select
     * @param options Select options
     * @returns Promise resolving to the selected values
     * @throws ElementNotFoundException if the element is not found
     */
    public async selectOption(
        values: string | string[] | { value?: string; label?: string; index?: number } | Array<{ value?: string; label?: string; index?: number }>,
        options: {
            force?: boolean;
            timeout?: number;
            noWaitAfter?: boolean;
        } = {}
    ): Promise<string[]> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Select options
            const selectedValues = await this.locator.selectOption(values as any, {
                force: options.force,
                timeout,
                noWaitAfter: options.noWaitAfter
            });
            
            CSLogger.debug(`Selected options in element: ${this.selector}`);
            
            return selectedValues;
        } catch (error) {
            CSLogger.error(`Failed to select options in element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to select options in element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to select options in element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Uploads files to the element
     * 
     * @param filePaths File paths to upload
     * @param options Upload options
     * @returns Promise resolving when upload is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async uploadFiles(
        filePaths: string | string[],
        options: {
            timeout?: number;
            noWaitAfter?: boolean;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Upload files
            await this.locator.setInputFiles(filePaths, {
                timeout,
                noWaitAfter: options.noWaitAfter
            });
            
            CSLogger.debug(`Uploaded files to element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to upload files to element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to upload files to element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to upload files to element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Presses a key while the element is focused
     * 
     * @param key Key to press
     * @param options Press options
     * @returns Promise resolving when key press is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async press(
        key: string,
        options: {
            delay?: number;
            timeout?: number;
            noWaitAfter?: boolean;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Press key on element
            await this.locator.press(key, {
                delay: options.delay,
                timeout,
                noWaitAfter: options.noWaitAfter
            });
            
            CSLogger.debug(`Pressed key ${key} on element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to press key ${key} on element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to press key ${key} on element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to press key ${key} on element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Checks or unchecks the element (checkbox, radio)
     * 
     * @param checked Whether to check or uncheck
     * @param options Check options
     * @returns Promise resolving when check is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async setChecked(
        checked: boolean,
        options: {
            force?: boolean;
            position?: { x: number; y: number };
            timeout?: number;
            noWaitAfter?: boolean;
            trial?: boolean;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Set checked state
            await this.locator.setChecked(checked, {
                force: options.force,
                position: options.position,
                timeout,
                noWaitAfter: options.noWaitAfter,
                trial: options.trial
            });
            
            CSLogger.debug(`Set element ${this.selector} checked state to ${checked}`);
        } catch (error) {
            CSLogger.error(`Failed to set element ${this.selector} checked state to ${checked}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to set element ${this.selector} checked state to ${checked}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to set element ${this.selector} checked state to ${checked}: ${error.message}`, error);
        }
    }
    
    /**
     * Focuses the element
     * 
     * @param options Focus options
     * @returns Promise resolving when focus is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async focus(
        options: {
            timeout?: number;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
            
            // Focus element
            await this.locator.focus({ timeout });
            
            CSLogger.debug(`Focused element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to focus element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to focus element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to focus element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Scrolls the element into view
     * 
     * @param options Scroll options
     * @returns Promise resolving when scroll is complete
     * @throws ElementNotFoundException if the element is not found
     */
    public async scrollIntoView(
        options: {
            timeout?: number;
            behavior?: 'auto' | 'smooth';
            block?: 'start' | 'center' | 'end' | 'nearest';
            inline?: 'start' | 'center' | 'end' | 'nearest';
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Scroll element into view
            await elementHandle.scrollIntoViewIfNeeded();
            
            // If specific scroll options are provided, use them
            if (options.behavior || options.block || options.inline) {
                await this.page.evaluate(
                    ([element, scrollOptions]) => {
                        element.scrollIntoView(scrollOptions);
                    },
                    [elementHandle, {
                        behavior: options.behavior || 'auto',
                        block: options.block || 'center',
                        inline: options.inline || 'nearest'
                    }]
                );
            }
            
            CSLogger.debug(`Scrolled element into view: ${this.selector}`);
            
            // Highlight element if enabled
            if (this.highlightOnInteraction) {
                await this.highlight();
            }
        } catch (error) {
            CSLogger.error(`Failed to scroll element ${this.selector} into view: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to scroll element ${this.selector} into view`, error);
            }
            
            throw new ElementNotFoundException(`Failed to scroll element ${this.selector} into view: ${error.message}`, error);
        }
    }
    
    /**
     * Evaluates a function in the browser with the element as the first argument
     * 
     * @param fn Function to evaluate
     * @param args Arguments to pass to the function
     * @param options Evaluation options
     * @returns Promise resolving to the function result
     * @throws ElementNotFoundException if the element is not found
     */
    public async evaluate<T>(
        fn: (element: HTMLElement, ...args: any[]) => T | Promise<T>,
        args: any[] = [],
        options: {
            timeout?: number;
        } = {}
    ): Promise<T> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Evaluate function on element
            return await this.locator.evaluate(fn as any, args, { timeout });
        } catch (error) {
            CSLogger.error(`Failed to evaluate function on element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to evaluate function on element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to evaluate function on element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Evaluates a function in the browser and returns a JSHandle
     * 
     * @param fn Function to evaluate
     * @param args Arguments to pass to the function
     * @param options Evaluation options
     * @returns Promise resolving to the JSHandle
     * @throws ElementNotFoundException if the element is not found
     */
    public async evaluateHandle<T extends JSHandle>(
        fn: (element: HTMLElement, ...args: any[]) => any,
        args: any[] = [],
        options: {
            timeout?: number;
        } = {}
    ): Promise<T> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Evaluate function on element and return handle
            return await this.page.evaluateHandle(
                ([element, fn, args]) => {
                    return (fn as any)(element, ...args);
                },
                [elementHandle, fn, args]
            ) as T;
        } catch (error) {
            CSLogger.error(`Failed to evaluate handle function on element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to evaluate handle function on element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to evaluate handle function on element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Highlights the element by adding a border
     * 
     * @param options Highlight options
     * @returns Promise resolving when highlighting is complete
     */
    public async highlight(
        options: {
            color?: string;
            duration?: number;
            timeout?: number;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        const color = options.color || '#FF69B4'; // Hot pink
        const duration = options.duration || 200; // milliseconds
        
        try {
            // Add border to highlight element
            await this.evaluate(
                (element, { color, duration }) => {
                    const originalOutline = element.style.outline;
                    const originalOutlineOffset = element.style.outlineOffset;
                    
                    element.style.outline = `2px solid ${color}`;
                    element.style.outlineOffset = '2px';
                    
                    if (duration > 0) {
                        setTimeout(() => {
                            element.style.outline = originalOutline;
                            element.style.outlineOffset = originalOutlineOffset;
                        }, duration);
                    }
                },
                [{ color, duration }],
                { timeout }
            );
        } catch (error) {
            // Don't throw on highlight errors, just log
            CSLogger.debug(`Failed to highlight element ${this.selector}: ${error.message}`);
        }
    }
    
    /**
     * Waits for the element to be visible
     * 
     * @param options Wait options
     * @returns Promise resolving to the element
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForVisible(
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            await this.locator.waitFor({
                state: 'visible',
                timeout
            });
            
            return this;
        } catch (error) {
            CSLogger.error(`Timeout waiting for element ${this.selector} to be visible: ${error.message}`);
            
            throw new WaitTimeoutException(`Timeout waiting for element ${this.selector} to be visible after ${timeout}ms`, error);
        }
    }
    
    /**
     * Waits for the element to be hidden
     * 
     * @param options Wait options
     * @returns Promise resolving to the element
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForHidden(
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            await this.locator.waitFor({
                state: 'hidden',
                timeout
            });
            
            return this;
        } catch (error) {
            CSLogger.error(`Timeout waiting for element ${this.selector} to be hidden: ${error.message}`);
            
            throw new WaitTimeoutException(`Timeout waiting for element ${this.selector} to be hidden after ${timeout}ms`, error);
        }
    }
    
    /**
     * Waits for the element to be attached to the DOM
     * 
     * @param options Wait options
     * @returns Promise resolving to the element
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForAttached(
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            await this.locator.waitFor({
                state: 'attached',
                timeout
            });
            
            return this;
        } catch (error) {
            CSLogger.error(`Timeout waiting for element ${this.selector} to be attached: ${error.message}`);
            
            throw new WaitTimeoutException(`Timeout waiting for element ${this.selector} to be attached after ${timeout}ms`, error);
        }
    }
    
    /**
     * Waits for the element to be detached from the DOM
     * 
     * @param options Wait options
     * @returns Promise resolving to the element
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForDetached(
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            await this.locator.waitFor({
                state: 'detached',
                timeout
            });
            
            return this;
        } catch (error) {
            CSLogger.error(`Timeout waiting for element ${this.selector} to be detached: ${error.message}`);
            
            throw new WaitTimeoutException(`Timeout waiting for element ${this.selector} to be detached after ${timeout}ms`, error);
        }
    }
    
    /**
     * Waits for the element to be enabled
     * 
     * @param options Wait options
     * @returns Promise resolving to the element
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForEnabled(
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            await this.locator.waitFor({
                state: 'visible',
                timeout
            });
            
            // Check if element is enabled
            const isEnabled = await this.isEnabled({ timeout: 1000 });
            
            if (!isEnabled) {
                throw new Error('Element is visible but not enabled');
            }
            
            return this;
        } catch (error) {
            CSLogger.error(`Timeout waiting for element ${this.selector} to be enabled: ${error.message}`);
            
            throw new WaitTimeoutException(`Timeout waiting for element ${this.selector} to be enabled after ${timeout}ms`, error);
        }
    }
    
    /**
     * Waits for the element to have specific text
     * 
     * @param text Text to wait for
     * @param options Wait options
     * @returns Promise resolving to the element
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForText(
        text: string | RegExp,
        options: {
            timeout?: number;
            useInnerText?: boolean;
        } = {}
    ): Promise<CSElement> {
        const timeout = options.timeout || this.defaultTimeout;
        const useInnerText = options.useInnerText !== false;
        
        try {
            // Wait for element to be visible
            await this.locator.waitFor({
                state: 'visible',
                timeout
            });
            
            // Wait for specific text
            const startTime = Date.now();
            let lastError: Error | null = null;
            
            while (Date.now() - startTime < timeout) {
                try {
                    // Get text based on options
                    const elementText = useInnerText 
                        ? await this.getInnerText({ timeout: 1000 })
                        : await this.getText({ timeout: 1000 });
                    
                    // Check if text matches
                    if (typeof text === 'string') {
                        if (elementText.includes(text)) {
                            return this;
                        }
                    } else if (text instanceof RegExp) {
                        if (text.test(elementText)) {
                            return this;
                        }
                    }
                    
                    // Wait before checking again
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    lastError = error as Error;
                    // Wait before trying again
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            throw new Error(`Element text doesn't match expected text after ${timeout}ms`);
        } catch (error) {
            CSLogger.error(`Timeout waiting for element ${this.selector} to have text: ${error.message}`);
            
            throw new WaitTimeoutException(`Timeout waiting for element ${this.selector} to have expected text after ${timeout}ms`, error);
        }
    }
    
    /**
     * Gets the ElementHandle representing this element
     * 
     * @param timeout Timeout in milliseconds
     * @returns Promise resolving to the ElementHandle
     * @throws ElementNotFoundException if the element is not found
     */
    private async getElementHandle(timeout: number): Promise<ElementHandle> {
        // Check if we have a cached handle that's still fresh
        if (this.elementHandleCache && 
            Date.now() - this.elementHandleCacheTime < this.elementHandleCacheMaxAge) {
            try {
                // Check if the handle is still attached
                await this.elementHandleCache.getAttribute('dummy-attr');
                
                // Return cached handle if it's still valid
                return this.elementHandleCache;
            } catch (error) {
                // Handle is detached, clear cache and continue
                this.elementHandleCache = undefined;
            }
        }
        
        try {
            // Get element handle
            const handle = await this.locator.elementHandle({ timeout });
            
            if (!handle) {
                throw new ElementNotFoundException(`Element not found: ${this.selector}`);
            }
            
            // Cache the handle
            this.elementHandleCache = handle;
            this.elementHandleCacheTime = Date.now();
            
            return handle;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get element handle for ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Finds child elements matching a selector
     * 
     * @param selector Child element selector
     * @param options Find options
     * @returns Promise resolving to an array of child elements
     */
    public async findElements(
        selector: string,
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement[]> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get element handles for all matching child elements
            const childLocator = this.locator.locator(selector);
            const count = await childLocator.count();
            const elements: CSElement[] = [];
            
            // Create CSElement for each child element
            for (let i = 0; i < count; i++) {
                const childElement = new CSElement(childLocator.nth(i), this.page, this.frame);
                childElement.setParent(this);
                elements.push(childElement);
            }
            
            return elements;
        } catch (error) {
            CSLogger.error(`Failed to find child elements ${selector} of ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Finds the first child element matching a selector
     * 
     * @param selector Child element selector
     * @param options Find options
     * @returns Promise resolving to the child element or null if not found
     */
    public async findElement(
        selector: string,
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement | null> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get first element handle matching the selector
            const childLocator = this.locator.locator(selector).first();
            
            // Check if element exists
            const exists = await childLocator.count() > 0;
            
            if (!exists) {
                return null;
            }
            
            // Create CSElement for the child element
            const childElement = new CSElement(childLocator, this.page, this.frame);
            childElement.setParent(this);
            
            return childElement;
        } catch (error) {
            CSLogger.error(`Failed to find child element ${selector} of ${this.selector}: ${error.message}`);
            return null;
        }
    }
    
    /**
     * Waits for a child element to be visible
     * 
     * @param selector Child element selector
     * @param options Wait options
     * @returns Promise resolving to the child element
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForChildVisible(
        selector: string,
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get child locator
            const childLocator = this.locator.locator(selector);
            
            // Wait for child to be visible
            await childLocator.waitFor({
                state: 'visible',
                timeout
            });
            
            // Create CSElement for the child element
            const childElement = new CSElement(childLocator, this.page, this.frame);
            childElement.setParent(this);
            
            return childElement;
        } catch (error) {
            CSLogger.error(`Timeout waiting for child element ${selector} of ${this.selector} to be visible: ${error.message}`);
            
            throw new WaitTimeoutException(`Timeout waiting for child element ${selector} of ${this.selector} to be visible after ${timeout}ms`, error);
        }
    }
    
    /**
     * Gets the count of elements matching this locator
     * 
     * @param options Count options
     * @returns Promise resolving to the element count
     */
    public async count(
        options: {
            timeout?: number;
        } = {}
    ): Promise<number> {
        try {
            return await this.locator.count();
        } catch (error) {
            CSLogger.error(`Failed to get count of elements ${this.selector}: ${error.message}`);
            return 0;
        }
    }
    
    /**
     * Gets the inner HTML of the element
     * 
     * @param options HTML options
     * @returns Promise resolving to the inner HTML
     * @throws ElementNotFoundException if the element is not found
     */
    public async getInnerHTML(
        options: {
            timeout?: number;
        } = {}
    ): Promise<string> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            return await this.locator.innerHTML({ timeout });
        } catch (error) {
            CSLogger.error(`Failed to get inner HTML from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get inner HTML from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get inner HTML from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the outer HTML of the element
     * 
     * @param options HTML options
     * @returns Promise resolving to the outer HTML
     * @throws ElementNotFoundException if the element is not found
     */
    public async getOuterHTML(
        options: {
            timeout?: number;
        } = {}
    ): Promise<string> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Get outer HTML
            return await this.page.evaluate(element => element.outerHTML, elementHandle);
        } catch (error) {
            CSLogger.error(`Failed to get outer HTML from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get outer HTML from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get outer HTML from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets all attribute names and values of the element
     * 
     * @param options Attributes options
     * @returns Promise resolving to an object of attribute names and values
     * @throws ElementNotFoundException if the element is not found
     */
    public async getAllAttributes(
        options: {
            timeout?: number;
        } = {}
    ): Promise<Record<string, string>> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Get all attributes
            return await this.page.evaluate(element => {
                const result: Record<string, string> = {};
                
                for (const attr of element.attributes) {
                    result[attr.name] = attr.value;
                }
                
                return result;
            }, elementHandle);
        } catch (error) {
            CSLogger.error(`Failed to get all attributes from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get all attributes from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get all attributes from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the computed style value of the element
     * 
     * @param propertyName CSS property name
     * @param options Style options
     * @returns Promise resolving to the computed style value
     * @throws ElementNotFoundException if the element is not found
     */
    public async getComputedStyle(
        propertyName: string,
        options: {
            timeout?: number;
            pseudoElement?: string;
        } = {}
    ): Promise<string> {
        const timeout = options.timeout || this.defaultTimeout;
        const pseudoElement = options.pseudoElement || '';
        
        try {
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Get computed style
            return await this.page.evaluate(
                ([element, propertyName, pseudoElement]) => {
                    return window.getComputedStyle(element, pseudoElement).getPropertyValue(propertyName);
                },
                [elementHandle, propertyName, pseudoElement]
            );
        } catch (error) {
            CSLogger.error(`Failed to get computed style ${propertyName} from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get computed style ${propertyName} from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get computed style ${propertyName} from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets multiple computed style values of the element
     * 
     * @param propertyNames CSS property names
     * @param options Style options
     * @returns Promise resolving to an object of property names and values
     * @throws ElementNotFoundException if the element is not found
     */
    public async getComputedStyles(
        propertyNames: string[],
        options: {
            timeout?: number;
            pseudoElement?: string;
        } = {}
    ): Promise<Record<string, string>> {
        const timeout = options.timeout || this.defaultTimeout;
        const pseudoElement = options.pseudoElement || '';
        
        try {
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Get computed styles
            return await this.page.evaluate(
                ([element, propertyNames, pseudoElement]) => {
                    const result: Record<string, string> = {};
                    const computedStyle = window.getComputedStyle(element, pseudoElement);
                    
                    for (const propertyName of propertyNames) {
                        result[propertyName] = computedStyle.getPropertyValue(propertyName);
                    }
                    
                    return result;
                },
                [elementHandle, propertyNames, pseudoElement]
            );
        } catch (error) {
            CSLogger.error(`Failed to get computed styles from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get computed styles from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get computed styles from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Dispatches an event on the element
     * 
     * @param eventType Event type
     * @param eventInit Event initialization properties
     * @param options Dispatch options
     * @returns Promise resolving when the event is dispatched
     * @throws ElementNotFoundException if the element is not found
     */
    public async dispatchEvent(
        eventType: string,
        eventInit: Record<string, any> = {},
        options: {
            timeout?: number;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Dispatch event
            await this.locator.dispatchEvent(eventType, eventInit, { timeout });
            
            CSLogger.debug(`Dispatched ${eventType} event on element: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to dispatch ${eventType} event on element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to dispatch ${eventType} event on element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to dispatch ${eventType} event on element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets a screenshot of the element
     * 
     * @param options Screenshot options
     * @returns Promise resolving to the screenshot buffer
     * @throws ElementNotFoundException if the element is not found
     */
    public async screenshot(
        options: {
            path?: string;
            type?: 'png' | 'jpeg';
            quality?: number;
            omitBackground?: boolean;
            timeout?: number;
        } = {}
    ): Promise<Buffer> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Take screenshot
            return await this.locator.screenshot({
                path: options.path,
                type: options.type,
                quality: options.quality,
                omitBackground: options.omitBackground,
                timeout
            });
        } catch (error) {
            CSLogger.error(`Failed to take screenshot of element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to take screenshot of element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to take screenshot of element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets a new CSElement representing an alternative locator for the same element
     * 
     * @param alternativeSelector Alternative selector
     * @returns New CSElement with the alternative locator
     */
    public getAlternativeLocator(alternativeSelector: string): CSElement {
        return new CSElement(alternativeSelector, this.page, this.frame);
    }
    
    /**
     * Gets CSElements for all elements matching this selector
     * 
     * @param options All options
     * @returns Promise resolving to an array of CSElements
     */
    public async getAll(
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement[]> {
        try {
            const count = await this.locator.count();
            const elements: CSElement[] = [];
            
            for (let i = 0; i < count; i++) {
                elements.push(new CSElement(this.locator.nth(i), this.page, this.frame));
            }
            
            return elements;
        } catch (error) {
            CSLogger.error(`Failed to get all elements matching ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Gets the nth element matching this selector
     * 
     * @param index Element index (0-based)
     * @returns New CSElement for the nth element
     */
    public nth(index: number): CSElement {
        return new CSElement(this.locator.nth(index), this.page, this.frame);
    }
    
    /**
     * Gets the first element matching this selector
     * 
     * @returns New CSElement for the first element
     */
    public first(): CSElement {
        return new CSElement(this.locator.first(), this.page, this.frame);
    }
    
    /**
     * Gets the last element matching this selector
     * 
     * @returns New CSElement for the last element
     */
    public last(): CSElement {
        return new CSElement(this.locator.last(), this.page, this.frame);
    }
    
    /**
     * Filters elements by text content
     * 
     * @param text Text to filter by
     * @param options Filter options
     * @returns New CSElement with the filtered locator
     */
    public filter(
        text: string | RegExp,
        options: {
            exact?: boolean;
        } = {}
    ): CSElement {
        return new CSElement(
            this.locator.filter({
                hasText: text,
                ...(options.exact !== undefined ? { exact: options.exact } : {})
            }),
            this.page,
            this.frame
        );
    }
    
    /**
     * Filters elements that contain another element
     * 
     * @param innerSelector Selector for inner element
     * @returns New CSElement with the filtered locator
     */
    public filterHas(innerSelector: string): CSElement {
        const innerLocator = this.frame 
            ? this.frame.locator(innerSelector)
            : this.page.locator(innerSelector);
            
        return new CSElement(
            this.locator.filter({
                has: innerLocator
            }),
            this.page,
            this.frame
        );
    }
    
    /**
     * Gets elements matching a specific role
     * 
     * @param role ARIA role
     * @param options Role options
     * @returns New CSElement with the role locator
     */
    public getByRole(
        role: string,
        options: {
            checked?: boolean;
            disabled?: boolean;
            exact?: boolean;
            expanded?: boolean;
            includeHidden?: boolean;
            level?: number;
            name?: string | RegExp;
            pressed?: boolean;
            selected?: boolean;
        } = {}
    ): CSElement {
        return new CSElement(
            this.locator.getByRole(role as any, options),
            this.page,
            this.frame
        );
    }
    
    /**
     * Gets elements with specific text
     * 
     * @param text Text to find
     * @param options Text options
     * @returns New CSElement with the text locator
     */
    public getByText(
        text: string | RegExp,
        options: {
            exact?: boolean;
        } = {}
    ): CSElement {
        return new CSElement(
            this.locator.getByText(text, options),
            this.page,
            this.frame
        );
    }
    
    /**
     * Gets elements with specific test ID
     * 
     * @param testId Test ID to find
     * @returns New CSElement with the test ID locator
     */
    public getByTestId(testId: string | RegExp): CSElement {
        return new CSElement(
            this.locator.getByTestId(testId),
            this.page,
            this.frame
        );
    }
    
    /**
     * Gets input elements with a specific placeholder
     * 
     * @param placeholder Placeholder text
     * @param options Placeholder options
     * @returns New CSElement with the placeholder locator
     */
    public getByPlaceholder(
        placeholder: string | RegExp,
        options: {
            exact?: boolean;
        } = {}
    ): CSElement {
        return new CSElement(
            this.locator.getByPlaceholder(placeholder, options),
            this.page,
            this.frame
        );
    }
    
    /**
     * Gets elements with a specific label
     * 
     * @param label Label text
     * @param options Label options
     * @returns New CSElement with the label locator
     */
    public getByLabel(
        label: string | RegExp,
        options: {
            exact?: boolean;
        } = {}
    ): CSElement {
        return new CSElement(
            this.locator.getByLabel(label, options),
            this.page,
            this.frame
        );
    }
    
    /**
     * Gets elements with specific alt text
     * 
     * @param alt Alt text
     * @param options Alt text options
     * @returns New CSElement with the alt text locator
     */
    public getByAltText(
        alt: string | RegExp,
        options: {
            exact?: boolean;
        } = {}
    ): CSElement {
        return new CSElement(
            this.locator.getByAltText(alt, options),
            this.page,
            this.frame
        );
    }
    
    /**
     * Gets elements with a specific title
     * 
     * @param title Title text
     * @param options Title options
     * @returns New CSElement with the title locator
     */
    public getByTitle(
        title: string | RegExp,
        options: {
            exact?: boolean;
        } = {}
    ): CSElement {
        return new CSElement(
            this.locator.getByTitle(title, options),
            this.page,
            this.frame
        );
    }
    
    /**
     * Submits a form element
     * 
     * @param options Submit options
     * @returns Promise resolving when the form is submitted
     * @throws ElementNotFoundException if the element is not found
     */
    public async submit(
        options: {
            timeout?: number;
            noWaitAfter?: boolean;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Submit the form
            await this.page.evaluate(
                ([element, options]) => {
                    if (element instanceof HTMLFormElement) {
                        element.submit();
                    } else {
                        // Find the closest form and submit it
                        const form = element.closest('form');
                        if (form) {
                            form.submit();
                        } else {
                            throw new Error('Element is not a form and is not inside a form');
                        }
                    }
                },
                [elementHandle, options]
            );
            
            // Wait for navigation if not specified otherwise
            if (!options.noWaitAfter) {
                await this.page.waitForLoadState('networkidle', { timeout });
            }
            
            CSLogger.debug(`Submitted form: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to submit form ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to submit form ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to submit form ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets all text from the element and its children
     * 
     * @param options Text options
     * @returns Promise resolving to the all text
     * @throws ElementNotFoundException if the element is not found
     */
    public async getAllText(
        options: {
            timeout?: number;
            includeHidden?: boolean;
        } = {}
    ): Promise<string> {
        const timeout = options.timeout || this.defaultTimeout;
        const includeHidden = options.includeHidden || false;
        
        try {
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Get all text including hidden text if requested
            return await this.page.evaluate(
                ([element, includeHidden]) => {
                    // Helper function to get all text nodes
                    function getAllTextNodes(node: Node): string {
                        let text = '';
                        
                        // If this is a text node, get its content
                        if (node.nodeType === Node.TEXT_NODE) {
                            text += node.textContent || '';
                        } else {
                            // Skip hidden elements unless includeHidden is true
                            const element = node as HTMLElement;
                            if (node.nodeType === Node.ELEMENT_NODE && 
                                !includeHidden && 
                                element.style && 
                                (element.style.display === 'none' || element.style.visibility === 'hidden')) {
                                return '';
                            }
                            
                            // Process child nodes
                            for (const child of Array.from(node.childNodes)) {
                                text += getAllTextNodes(child);
                            }
                        }
                        
                        return text;
                    }
                    
                    return getAllTextNodes(element).trim();
                },
                [elementHandle, includeHidden]
            );
        } catch (error) {
            CSLogger.error(`Failed to get all text from element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get all text from element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get all text from element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the frame containing this element
     * 
     * @returns The frame or undefined if in main frame
     */
    public getFrame(): Frame | undefined {
        return this.frame;
    }
    
    /**
     * Gets a locator for a shadow DOM element
     * 
     * @param selector Shadow DOM selector
     * @returns New CSElement for the shadow DOM element
     */
    public shadowLocator(selector: string): CSElement {
        // Create a locator that looks for elements in the shadow DOM
        const shadowLocator = this.locator.locator(selector);
        return new CSElement(shadowLocator, this.page, this.frame);
    }
    
    /**
     * Gets the shadow root of the element
     * 
     * @param options Shadow root options
     * @returns Promise resolving to a CSElement for the shadow root or null if none
     * @throws ElementNotFoundException if the element is not found
     */
    public async getShadowRoot(
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElement | null> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Check if element has a shadow root
            const hasShadowRoot = await this.evaluate(
                element => !!element.shadowRoot,
                [],
                { timeout }
            );
            
            if (!hasShadowRoot) {
                return null;
            }
            
            // Create a locator for the shadow root
            return new CSElement(this.locator.locator('*'), this.page, this.frame);
        } catch (error) {
            CSLogger.error(`Failed to get shadow root for element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get shadow root for element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get shadow root for element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Checks if the element is an iframe
     * 
     * @param options Check options
     * @returns Promise resolving to whether the element is an iframe
     */
    public async isIframe(
        options: {
            timeout?: number;
        } = {}
    ): Promise<boolean> {
        try {
            const tagName = await this.evaluate(
                element => element.tagName.toLowerCase(),
                [],
                options
            );
            
            return tagName === 'iframe';
        } catch (error) {
            CSLogger.debug(`Error checking if element ${this.selector} is an iframe: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Gets the iframe content frame if the element is an iframe
     * 
     * @param options Frame options
     * @returns Promise resolving to the frame or null if not an iframe
     * @throws ElementNotFoundException if the element is not found
     */
    public async getContentFrame(
        options: {
            timeout?: number;
        } = {}
    ): Promise<Frame | null> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            // Check if element is an iframe
            const isIframe = await this.isIframe({ timeout });
            
            if (!isIframe) {
                return null;
            }
            
            // Get element handle
            const elementHandle = await this.getElementHandle(timeout);
            
            // Get the frame
            return await elementHandle.contentFrame();
        } catch (error) {
            CSLogger.error(`Failed to get content frame for element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get content frame for element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get content frame for element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the tab index of the element
     * 
     * @param options Tab index options
     * @returns Promise resolving to the tab index
     * @throws ElementNotFoundException if the element is not found
     */
    public async getTabIndex(
        options: {
            timeout?: number;
        } = {}
    ): Promise<number> {
        try {
            return await this.evaluate<number>(
                element => element.tabIndex,
                [],
                options
            );
        } catch (error) {
            CSLogger.error(`Failed to get tab index for element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get tab index for element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get tab index for element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the tag name of the element
     * 
     * @param options Tag name options
     * @returns Promise resolving to the tag name
     * @throws ElementNotFoundException if the element is not found
     */
    public async getTagName(
        options: {
            timeout?: number;
        } = {}
    ): Promise<string> {
        try {
            return await this.evaluate<string>(
                element => element.tagName.toLowerCase(),
                [],
                options
            );
        } catch (error) {
            CSLogger.error(`Failed to get tag name for element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get tag name for element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get tag name for element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the element's accessible name
     * 
     * @param options Accessible name options
     * @returns Promise resolving to the accessible name
     * @throws ElementNotFoundException if the element is not found
     */
    public async getAccessibleName(
        options: {
            timeout?: number;
        } = {}
    ): Promise<string> {
        try {
            return await this.evaluate<string>(
                element => element.getAttribute('aria-label') || 
                           element.getAttribute('alt') || 
                           element.getAttribute('title') || 
                           element.textContent || '',
                [],
                options
            );
        } catch (error) {
            CSLogger.error(`Failed to get accessible name for element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get accessible name for element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get accessible name for element ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the element's accessible role
     * 
     * @param options Accessible role options
     * @returns Promise resolving to the accessible role
     * @throws ElementNotFoundException if the element is not found
     */
    public async getAccessibleRole(
        options: {
            timeout?: number;
        } = {}
    ): Promise<string> {
        try {
            return await this.evaluate<string>(
                element => element.getAttribute('role') || '',
                [],
                options
            );
        } catch (error) {
            CSLogger.error(`Failed to get accessible role for element ${this.selector}: ${error.message}`);
            
            if (error instanceof Error && error.message.includes('timeout')) {
                throw new WaitTimeoutException(`Timeout waiting to get accessible role for element ${this.selector}`, error);
            }
            
            throw new ElementNotFoundException(`Failed to get accessible role for element ${this.selector}: ${error.message}`, error);
        }
    }
}



CSElementList.ts
------------------------------

import { Locator, Page, Frame } from 'playwright';
import { CSElement } from './CSElement';
import { CSLogger } from '../../core/utils/CSLogger';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { WaitTimeoutException } from '../../core/exceptions/WaitTimeoutException';

/**
 * Enhanced wrapper for a collection of Playwright Locators/Elements with additional functionality.
 * This class provides a common API between Selenium and Playwright element lists.
 */
export class CSElementList implements Iterable<CSElement> {
    /**
     * The base Playwright Locator for this element list
     */
    private locator: Locator;
    
    /**
     * The Playwright Page instance
     */
    private page: Page;
    
    /**
     * The Frame containing these elements (if applicable)
     */
    private frame?: Frame;
    
    /**
     * The element selector
     */
    private selector: string;
    
    /**
     * Default timeout for element operations in milliseconds
     */
    private defaultTimeout: number = 30000;
    
    /**
     * Whether to highlight elements during interactions
     */
    private highlightOnInteraction: boolean = false;
    
    /**
     * The parent CSElement (if any)
     */
    private parent?: CSElement;
    
    /**
     * Cache for CSElements already created
     */
    private elementCache: Map<number, CSElement> = new Map();
    
    /**
     * Time when the element count was last updated
     */
    private countCacheTime: number = 0;
    
    /**
     * Cached element count
     */
    private countCache: number = -1;
    
    /**
     * Maximum age of the count cache in milliseconds
     */
    private countCacheMaxAge: number = 500; // 500 milliseconds
    
    /**
     * Creates a new CSElementList instance
     * 
     * @param locatorOrSelector Playwright Locator or selector string
     * @param page Playwright Page instance
     * @param frame Optional frame containing the elements
     */
    constructor(
        locatorOrSelector: Locator | string,
        page: Page,
        frame?: Frame
    ) {
        this.page = page;
        this.frame = frame;
        
        // If a string selector is provided, create a locator
        if (typeof locatorOrSelector === 'string') {
            this.selector = locatorOrSelector;
            this.locator = frame ? frame.locator(locatorOrSelector) : page.locator(locatorOrSelector);
        } else {
            // Otherwise use the provided locator
            this.locator = locatorOrSelector;
            
            // Try to get the selector from the locator
            try {
                // This is an approximation as Playwright doesn't expose the selector directly
                this.selector = String(locatorOrSelector);
            } catch (error) {
                this.selector = 'unknown';
            }
        }
        
        CSLogger.debug(`Created CSElementList for selector: ${this.selector}`);
    }
    
    /**
     * Gets the underlying Playwright Locator
     * 
     * @returns The Playwright Locator
     */
    public getLocator(): Locator {
        return this.locator;
    }
    
    /**
     * Gets the Playwright Page instance
     * 
     * @returns The Playwright Page
     */
    public getPage(): Page {
        return this.page;
    }
    
    /**
     * Gets the element selector
     * 
     * @returns The element selector
     */
    public getSelector(): string {
        return this.selector;
    }
    
    /**
     * Sets the default timeout for element operations
     * 
     * @param timeout Timeout in milliseconds
     */
    public setDefaultTimeout(timeout: number): void {
        this.defaultTimeout = timeout;
    }
    
    /**
     * Gets the default timeout for element operations
     * 
     * @returns Timeout in milliseconds
     */
    public getDefaultTimeout(): number {
        return this.defaultTimeout;
    }
    
    /**
     * Enables or disables element highlighting during interactions
     * 
     * @param enable Whether to enable highlighting
     */
    public setHighlightOnInteraction(enable: boolean): void {
        this.highlightOnInteraction = enable;
    }
    
    /**
     * Sets the parent CSElement
     * 
     * @param parent Parent CSElement
     */
    public setParent(parent: CSElement): void {
        this.parent = parent;
    }
    
    /**
     * Gets the parent CSElement
     * 
     * @returns Parent CSElement or undefined if none
     */
    public getParent(): CSElement | undefined {
        return this.parent;
    }
    
    /**
     * Gets the count of elements in the list
     * 
     * @param refresh Whether to force a refresh of the count
     * @returns Promise resolving to the element count
     */
    public async count(refresh: boolean = false): Promise<number> {
        // Check if we have a fresh count in the cache
        if (!refresh && 
            this.countCache >= 0 && 
            Date.now() - this.countCacheTime < this.countCacheMaxAge) {
            return this.countCache;
        }
        
        try {
            // Get count from locator
            const count = await this.locator.count();
            
            // Update cache
            this.countCache = count;
            this.countCacheTime = Date.now();
            
            return count;
        } catch (error) {
            CSLogger.error(`Failed to get count of elements ${this.selector}: ${error.message}`);
            return 0;
        }
    }
    
    /**
     * Gets the element at the specified index
     * 
     * @param index Element index (0-based)
     * @returns Promise resolving to the element at the index
     * @throws ElementNotFoundException if the element is not found
     */
    public async get(index: number): Promise<CSElement> {
        try {
            // Get count of elements
            const count = await this.count();
            
            if (index < 0 || index >= count) {
                throw new ElementNotFoundException(`Index out of bounds: ${index} (count: ${count})`);
            }
            
            // Check if the element is already in the cache
            if (this.elementCache.has(index)) {
                return this.elementCache.get(index)!;
            }
            
            // Create a new CSElement for the nth element
            const element = new CSElement(this.locator.nth(index), this.page, this.frame);
            
            // Use the same timeout and highlight settings
            element.setDefaultTimeout(this.defaultTimeout);
            element.setHighlightOnInteraction(this.highlightOnInteraction);
            
            // Set parent if available
            if (this.parent) {
                element.setParent(this.parent);
            }
            
            // Add to cache
            this.elementCache.set(index, element);
            
            return element;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            CSLogger.error(`Failed to get element at index ${index} from ${this.selector}: ${error.message}`);
            throw new ElementNotFoundException(`Failed to get element at index ${index} from ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the first element in the list
     * 
     * @returns Promise resolving to the first element
     * @throws ElementNotFoundException if no elements are found
     */
    public async first(): Promise<CSElement> {
        try {
            const count = await this.count();
            
            if (count === 0) {
                throw new ElementNotFoundException(`No elements found for selector: ${this.selector}`);
            }
            
            return this.get(0);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            CSLogger.error(`Failed to get first element from ${this.selector}: ${error.message}`);
            throw new ElementNotFoundException(`Failed to get first element from ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the last element in the list
     * 
     * @returns Promise resolving to the last element
     * @throws ElementNotFoundException if no elements are found
     */
    public async last(): Promise<CSElement> {
        try {
            const count = await this.count();
            
            if (count === 0) {
                throw new ElementNotFoundException(`No elements found for selector: ${this.selector}`);
            }
            
            return this.get(count - 1);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            CSLogger.error(`Failed to get last element from ${this.selector}: ${error.message}`);
            throw new ElementNotFoundException(`Failed to get last element from ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets all elements in the list
     * 
     * @returns Promise resolving to an array of all elements
     */
    public async getAll(): Promise<CSElement[]> {
        try {
            const count = await this.count();
            const elements: CSElement[] = [];
            
            for (let i = 0; i < count; i++) {
                elements.push(await this.get(i));
            }
            
            return elements;
        } catch (error) {
            CSLogger.error(`Failed to get all elements from ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Filters elements by text content
     * 
     * @param text Text to filter by
     * @param options Filter options
     * @returns New CSElementList with the filtered locator
     */
    public filter(
        text: string | RegExp,
        options: {
            exact?: boolean;
        } = {}
    ): CSElementList {
        return new CSElementList(
            this.locator.filter({
                hasText: text,
                ...(options.exact !== undefined ? { exact: options.exact } : {})
            }),
            this.page,
            this.frame
        );
    }
    
    /**
     * Filters elements that contain another element
     * 
     * @param innerSelector Selector for inner element
     * @returns New CSElementList with the filtered locator
     */
    public filterHas(innerSelector: string): CSElementList {
        const innerLocator = this.frame 
            ? this.frame.locator(innerSelector)
            : this.page.locator(innerSelector);
            
        return new CSElementList(
            this.locator.filter({
                has: innerLocator
            }),
            this.page,
            this.frame
        );
    }
    
    /**
     * Filters elements that have a specific CSS class
     * 
     * @param className CSS class name
     * @returns Promise resolving to a new CSElementList with filtered elements
     */
    public async filterByClass(className: string): Promise<CSElementList> {
        // Create a selector that includes the class
        const classSelector = `${this.selector}.${className}`;
        
        // Create a new CSElementList with the class selector
        return new CSElementList(classSelector, this.page, this.frame);
    }
    
    /**
     * Filters elements with a specific attribute value
     * 
     * @param attributeName Attribute name
     * @param attributeValue Attribute value
     * @returns Promise resolving to a new CSElementList with filtered elements
     */
    public async filterByAttribute(attributeName: string, attributeValue: string): Promise<CSElementList> {
        // Create a selector that includes the attribute
        const attributeSelector = `${this.selector}[${attributeName}="${attributeValue}"]`;
        
        // Create a new CSElementList with the attribute selector
        return new CSElementList(attributeSelector, this.page, this.frame);
    }
    
    /**
     * Maps each element to a property or attribute value
     * 
     * @param property Property or attribute name
     * @param isAttribute Whether the property is an attribute
     * @returns Promise resolving to an array of property values
     */
    public async mapProperty<T>(property: string, isAttribute: boolean = false): Promise<T[]> {
        try {
            const elements = await this.getAll();
            const values: T[] = [];
            
            for (const element of elements) {
                try {
                    let value: any;
                    
                    if (isAttribute) {
                        value = await element.getAttribute(property);
                    } else {
                        value = await element.getProperty<T>(property);
                    }
                    
                    values.push(value as T);
                } catch (error) {
                    CSLogger.warn(`Failed to get ${isAttribute ? 'attribute' : 'property'} ${property} from element: ${error.message}`);
                    values.push(null as any);
                }
            }
            
            return values;
        } catch (error) {
            CSLogger.error(`Failed to map property ${property} from elements ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Gets text content from all elements
     * 
     * @returns Promise resolving to an array of text content
     */
    public async getAllText(): Promise<string[]> {
        try {
            const elements = await this.getAll();
            const texts: string[] = [];
            
            for (const element of elements) {
                try {
                    const text = await element.getText();
                    texts.push(text);
                } catch (error) {
                    CSLogger.warn(`Failed to get text from element: ${error.message}`);
                    texts.push('');
                }
            }
            
            return texts;
        } catch (error) {
            CSLogger.error(`Failed to get text from elements ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Gets attribute values from all elements
     * 
     * @param attributeName Attribute name
     * @returns Promise resolving to an array of attribute values
     */
    public async getAllAttributes(attributeName: string): Promise<(string | null)[]> {
        return this.mapProperty<string | null>(attributeName, true);
    }
    
    /**
     * Finds the first element that matches a predicate
     * 
     * @param predicate Function that tests each element
     * @returns Promise resolving to the first matching element or null if none match
     */
    public async find(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<CSElement | null> {
        try {
            const elements = await this.getAll();
            
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                
                if (await predicate(element, i)) {
                    return element;
                }
            }
            
            return null;
        } catch (error) {
            CSLogger.error(`Failed to find element in ${this.selector}: ${error.message}`);
            return null;
        }
    }
    
    /**
     * Filters elements that match a predicate
     * 
     * @param predicate Function that tests each element
     * @returns Promise resolving to an array of matching elements
     */
    public async findAll(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<CSElement[]> {
        try {
            const elements = await this.getAll();
            const result: CSElement[] = [];
            
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                
                if (await predicate(element, i)) {
                    result.push(element);
                }
            }
            
            return result;
        } catch (error) {
            CSLogger.error(`Failed to find all elements in ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Finds the index of the first element that matches a predicate
     * 
     * @param predicate Function that tests each element
     * @returns Promise resolving to the index of the first matching element or -1 if none match
     */
    public async findIndex(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<number> {
        try {
            const elements = await this.getAll();
            
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                
                if (await predicate(element, i)) {
                    return i;
                }
            }
            
            return -1;
        } catch (error) {
            CSLogger.error(`Failed to find index in ${this.selector}: ${error.message}`);
            return -1;
        }
    }
    
    /**
     * Checks if any elements match a predicate
     * 
     * @param predicate Function that tests each element
     * @returns Promise resolving to whether any elements match
     */
    public async some(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<boolean> {
        return (await this.findIndex(predicate)) !== -1;
    }
    
    /**
     * Checks if all elements match a predicate
     * 
     * @param predicate Function that tests each element
     * @returns Promise resolving to whether all elements match
     */
    public async every(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<boolean> {
        try {
            const elements = await this.getAll();
            
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                
                if (!await predicate(element, i)) {
                    return false;
                }
            }
            
            return elements.length > 0;
        } catch (error) {
            CSLogger.error(`Failed to check every element in ${this.selector}: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Applies a function to each element
     * 
     * @param callback Function to apply to each element
     * @returns Promise resolving when all callbacks have been executed
     */
    public async forEach(callback: (element: CSElement, index: number) => Promise<void>): Promise<void> {
        try {
            const elements = await this.getAll();
            
            for (let i = 0; i < elements.length; i++) {
                await callback(elements[i], i);
            }
        } catch (error) {
            CSLogger.error(`Failed to execute forEach on ${this.selector}: ${error.message}`);
            throw error;
        }
    }
    
    /**
     * Maps each element using a function
     * 
     * @param callback Function to map each element
     * @returns Promise resolving to an array of mapped values
     */
    public async map<T>(callback: (element: CSElement, index: number) => Promise<T>): Promise<T[]> {
        try {
            const elements = await this.getAll();
            const result: T[] = [];
            
            for (let i = 0; i < elements.length; i++) {
                result.push(await callback(elements[i], i));
            }
            
            return result;
        } catch (error) {
            CSLogger.error(`Failed to execute map on ${this.selector}: ${error.message}`);
            throw error;
        }
    }
    
    /**
     * Waits for the count of elements to meet a condition
     * 
     * @param condition Condition to check the count against
     * @param options Wait options
     * @returns Promise resolving to the element list
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForCount(
        condition: (count: number) => boolean,
        options: {
            timeout?: number;
            pollInterval?: number;
            message?: string;
        } = {}
    ): Promise<CSElementList> {
        const timeout = options.timeout || this.defaultTimeout;
        const pollInterval = options.pollInterval || 100;
        const message = options.message || `Element count condition not met for ${this.selector}`;
        
        try {
            const startTime = Date.now();
            
            while (Date.now() - startTime < timeout) {
                // Clear the count cache to ensure a fresh count
                this.countCache = -1;
                
                const count = await this.count(true);
                
                if (condition(count)) {
                    return this;
                }
                
                // Wait before checking again
                await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            throw new Error(`Timeout waiting for count condition: ${message}`);
        } catch (error) {
            CSLogger.error(`Failed to wait for count condition on ${this.selector}: ${error.message}`);
            
            throw new WaitTimeoutException(`Timeout waiting for count condition: ${message}`, error);
        }
    }
    
    /**
     * Waits for elements to exist
     * 
     * @param options Wait options
     * @returns Promise resolving to the element list
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForElements(
        options: {
            timeout?: number;
            count?: number;
            atLeast?: number;
        } = {}
    ): Promise<CSElementList> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            if (options.count !== undefined) {
                // Wait for exact count
                return await this.waitForCount(
                    count => count === options.count,
                    {
                        timeout,
                        message: `Expected exactly ${options.count} elements for ${this.selector}`
                    }
                );
            } else if (options.atLeast !== undefined) {
                // Wait for at least count
                return await this.waitForCount(
                    count => count >= options.atLeast!,
                    {
                        timeout,
                        message: `Expected at least ${options.atLeast} elements for ${this.selector}`
                    }
                );
            } else {
                // Wait for at least one element
                return await this.waitForCount(
                    count => count > 0,
                    {
                        timeout,
                        message: `Expected at least one element for ${this.selector}`
                    }
                );
            }
        } catch (error) {
            if (error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new WaitTimeoutException(`Failed to wait for elements ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Waits for elements to disappear
     * 
     * @param options Wait options
     * @returns Promise resolving to the element list
     * @throws WaitTimeoutException if the wait times out
     */
    public async waitForElementsToDisappear(
        options: {
            timeout?: number;
        } = {}
    ): Promise<CSElementList> {
        const timeout = options.timeout || this.defaultTimeout;
        
        try {
            return await this.waitForCount(
                count => count === 0,
                {
                    timeout,
                    message: `Expected no elements for ${this.selector}`
                }
            );
        } catch (error) {
            if (error instanceof WaitTimeoutException) {
                throw error;
            }
            
            throw new WaitTimeoutException(`Failed to wait for elements to disappear ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Clicks all elements
     * 
     * @param options Click options
     * @returns Promise resolving when all elements have been clicked
     */
    public async clickAll(
        options: {
            timeout?: number;
            force?: boolean;
            sequential?: boolean;
            delay?: number;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        const sequential = options.sequential !== false;
        const delay = options.delay || 0;
        
        try {
            const elements = await this.getAll();
            
            if (sequential) {
                // Click elements one by one
                for (const element of elements) {
                    await element.click({
                        timeout,
                        force: options.force
                    });
                    
                    if (delay > 0) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            } else {
                // Click all elements in parallel
                await Promise.all(elements.map(element => 
                    element.click({
                        timeout,
                        force: options.force
                    })
                ));
            }
            
            CSLogger.debug(`Clicked all elements: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to click all elements ${this.selector}: ${error.message}`);
            throw error;
        }
    }
    
    /**
     * Fills all elements with text
     * 
     * @param text Text to fill
     * @param options Fill options
     * @returns Promise resolving when all elements have been filled
     */
    public async fillAll(
        text: string,
        options: {
            timeout?: number;
            force?: boolean;
            sequential?: boolean;
            delay?: number;
        } = {}
    ): Promise<void> {
        const timeout = options.timeout || this.defaultTimeout;
        const sequential = options.sequential !== false;
        const delay = options.delay || 0;
        
        try {
            const elements = await this.getAll();
            
            if (sequential) {
                // Fill elements one by one
                for (const element of elements) {
                    await element.fill(text, {
                        timeout,
                        force: options.force
                    });
                    
                    if (delay > 0) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            } else {
                // Fill all elements in parallel
                await Promise.all(elements.map(element => 
                    element.fill(text, {
                        timeout,
                        force: options.force
                    })
                ));
            }
            
            CSLogger.debug(`Filled all elements: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to fill all elements ${this.selector}: ${error.message}`);
            throw error;
        }
    }
    
    /**
     * Highlights all elements
     * 
     * @param options Highlight options
     * @returns Promise resolving when all elements have been highlighted
     */
    public async highlightAll(
        options: {
            color?: string;
            duration?: number;
            sequential?: boolean;
            delay?: number;
        } = {}
    ): Promise<void> {
        const sequential = options.sequential !== false;
        const delay = options.delay || 0;
        
        try {
            const elements = await this.getAll();
            
            if (sequential) {
                // Highlight elements one by one
                for (const element of elements) {
                    await element.highlight(options);
                    
                    if (delay > 0) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            } else {
                // Highlight all elements in parallel
                await Promise.all(elements.map(element => 
                    element.highlight(options)
                ));
            }
            
            CSLogger.debug(`Highlighted all elements: ${this.selector}`);
        } catch (error) {
            CSLogger.error(`Failed to highlight all elements ${this.selector}: ${error.message}`);
            // Don't throw on highlight errors
        }
    }
    
    /**
     * Gets an iterator for the element list
     * 
     * @returns An async iterator for the elements
     */
    public async *[Symbol.iterator](): AsyncIterableIterator<CSElement> {
        const count = await this.count();
        
        for (let i = 0; i < count; i++) {
            yield await this.get(i);
        }
    }
    
    /**
     * Gets an array with the elements
     * 
     * @returns Promise resolving to an array of elements
     */
    public async toArray(): Promise<CSElement[]> {
        return this.getAll();
    }
    
    /**
     * Gets a random element from the list
     * 
     * @returns Promise resolving to a random element
     * @throws ElementNotFoundException if no elements are found
     */
    public async random(): Promise<CSElement> {
        try {
            const count = await this.count();
            
            if (count === 0) {
                throw new ElementNotFoundException(`No elements found for selector: ${this.selector}`);
            }
            
            const randomIndex = Math.floor(Math.random() * count);
            return this.get(randomIndex);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            CSLogger.error(`Failed to get random element from ${this.selector}: ${error.message}`);
            throw new ElementNotFoundException(`Failed to get random element from ${this.selector}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets a slice of the element list
     * 
     * @param start Start index
     * @param end End index (exclusive)
     * @returns Promise resolving to a new CSElementList with the sliced elements
     */
    public async slice(start: number, end?: number): Promise<CSElement[]> {
        try {
            const count = await this.count();
            
            // Adjust negative indices
            if (start < 0) {
                start = Math.max(0, count + start);
            }
            
            if (end !== undefined && end < 0) {
                end = Math.max(0, count + end);
            }
            
            // Ensure end is within bounds
            if (end === undefined || end > count) {
                end = count;
            }
            
            // Get elements in the slice
            const elements: CSElement[] = [];
            
            for (let i = start; i < end; i++) {
                elements.push(await this.get(i));
            }
            
            return elements;
        } catch (error) {
            CSLogger.error(`Failed to slice elements ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Gets the CSS selector for the list
     * 
     * @returns The CSS selector
     */
    public toString(): string {
        return this.selector;
    }
    
    /**
     * Creates a new CSElementList with a different selector
     * 
     * @param selector New selector
     * @returns New CSElementList
     */
    public with(selector: string): CSElementList {
      return new CSElementList(selector, this.page, this.frame);
    }
    
    /**
     * Checks if the list is empty
     * 
     * @returns Promise resolving to whether the list is empty
     */
    public async isEmpty(): Promise<boolean> {
        return (await this.count()) === 0;
    }
    
    /**
     * Checks if the list has exactly one element
     * 
     * @returns Promise resolving to whether the list has exactly one element
     */
    public async hasSingleElement(): Promise<boolean> {
        return (await this.count()) === 1;
    }
    
    /**
     * Checks if the list has multiple elements
     * 
     * @returns Promise resolving to whether the list has multiple elements
     */
    public async hasMultipleElements(): Promise<boolean> {
        return (await this.count()) > 1;
    }
    
    /**
     * Sorts elements by a property or function
     * 
     * @param propertyOrFn Property name or function to compare elements
     * @param direction Sort direction
     * @returns Promise resolving to sorted elements
     */
    public async sortBy<T>(
        propertyOrFn: string | ((element: CSElement) => Promise<T>),
        direction: 'asc' | 'desc' = 'asc'
    ): Promise<CSElement[]> {
        try {
            const elements = await this.getAll();
            
            // Get values to sort by
            const valuesMap = new Map<CSElement, T>();
            
            for (const element of elements) {
                let value: T;
                
                if (typeof propertyOrFn === 'string') {
                    // Property name
                    try {
                        const isAttribute = propertyOrFn.startsWith('@');
                        const propName = isAttribute ? propertyOrFn.substring(1) : propertyOrFn;
                        
                        if (isAttribute) {
                            value = await element.getAttribute(propName) as unknown as T;
                        } else {
                            value = await element.getProperty<T>(propName);
                        }
                    } catch (error) {
                        CSLogger.warn(`Failed to get property ${propertyOrFn} from element: ${error.message}`);
                        value = null as unknown as T;
                    }
                } else {
                    // Function
                    value = await propertyOrFn(element);
                }
                
                valuesMap.set(element, value);
            }
            
            // Sort elements
            const sortedElements = [...elements].sort((a, b) => {
                const aValue = valuesMap.get(a);
                const bValue = valuesMap.get(b);
                
                if (aValue === bValue) return 0;
                if (aValue === null || aValue === undefined) return direction === 'asc' ? -1 : 1;
                if (bValue === null || bValue === undefined) return direction === 'asc' ? 1 : -1;
                
                if (aValue < bValue) return direction === 'asc' ? -1 : 1;
                if (aValue > bValue) return direction === 'asc' ? 1 : -1;
                
                return 0;
            });
            
            return sortedElements;
        } catch (error) {
            CSLogger.error(`Failed to sort elements ${this.selector}: ${error.message}`);
            return this.getAll();
        }
    }
    
    /**
     * Sorts elements by text content
     * 
     * @param direction Sort direction
     * @returns Promise resolving to sorted elements
     */
    public async sortByText(direction: 'asc' | 'desc' = 'asc'): Promise<CSElement[]> {
        return this.sortBy(async (element) => {
            try {
                return await element.getText();
            } catch (error) {
                return '';
            }
        }, direction);
    }
    
    /**
     * Sorts elements by attribute value
     * 
     * @param attributeName Attribute name
     * @param direction Sort direction
     * @returns Promise resolving to sorted elements
     */
    public async sortByAttribute(
        attributeName: string,
        direction: 'asc' | 'desc' = 'asc'
    ): Promise<CSElement[]> {
        return this.sortBy(`@${attributeName}`, direction);
    }
    
    /**
     * Gets elements that are currently visible
     * 
     * @returns Promise resolving to visible elements
     */
    public async getVisibleElements(): Promise<CSElement[]> {
        return this.findAll(async (element) => {
            try {
                return await element.isDisplayed();
            } catch (error) {
                return false;
            }
        });
    }
    
    /**
     * Gets elements that are currently enabled
     * 
     * @returns Promise resolving to enabled elements
     */
    public async getEnabledElements(): Promise<CSElement[]> {
        return this.findAll(async (element) => {
            try {
                return await element.isEnabled();
            } catch (error) {
                return false;
            }
        });
    }
    
    /**
     * Gets elements that are currently selected
     * 
     * @returns Promise resolving to selected elements
     */
    public async getSelectedElements(): Promise<CSElement[]> {
        return this.findAll(async (element) => {
            try {
                return await element.isSelected();
            } catch (error) {
                return false;
            }
        });
    }
    
    /**
     * Gets elements with a specific text
     * 
     * @param text Text to match
     * @param options Text options
     * @returns Promise resolving to matching elements
     */
    public async getElementsWithText(
        text: string | RegExp,
        options: {
            exact?: boolean;
            ignoreCase?: boolean;
        } = {}
    ): Promise<CSElement[]> {
        const exact = options.exact || false;
        const ignoreCase = options.ignoreCase !== false;
        
        return this.findAll(async (element) => {
            try {
                let elementText = await element.getText();
                
                if (ignoreCase && typeof text === 'string') {
                    elementText = elementText.toLowerCase();
                    text = text.toLowerCase();
                }
                
                if (exact) {
                    if (typeof text === 'string') {
                        return elementText === text;
                    } else {
                        return text.test(elementText);
                    }
                } else {
                    if (typeof text === 'string') {
                        return elementText.includes(text);
                    } else {
                        return text.test(elementText);
                    }
                }
            } catch (error) {
                return false;
            }
        });
    }
    
    /**
     * Gets elements with a specific attribute value
     * 
     * @param attributeName Attribute name
     * @param attributeValue Attribute value
     * @param options Attribute options
     * @returns Promise resolving to matching elements
     */
    public async getElementsWithAttribute(
        attributeName: string,
        attributeValue: string | RegExp,
        options: {
            exact?: boolean;
            ignoreCase?: boolean;
        } = {}
    ): Promise<CSElement[]> {
        const exact = options.exact || false;
        const ignoreCase = options.ignoreCase !== false;
        
        return this.findAll(async (element) => {
            try {
                let value = await element.getAttribute(attributeName);
                
                if (!value) {
                    return false;
                }
                
                if (ignoreCase && typeof attributeValue === 'string') {
                    value = value.toLowerCase();
                    attributeValue = attributeValue.toLowerCase();
                }
                
                if (exact) {
                    if (typeof attributeValue === 'string') {
                        return value === attributeValue;
                    } else {
                        return attributeValue.test(value);
                    }
                } else {
                    if (typeof attributeValue === 'string') {
                        return value.includes(attributeValue);
                    } else {
                        return attributeValue.test(value);
                    }
                }
            } catch (error) {
                return false;
            }
        });
    }
    
    /**
     * Gets elements with a specific CSS class
     * 
     * @param className CSS class name
     * @returns Promise resolving to matching elements
     */
    public async getElementsWithClass(className: string): Promise<CSElement[]> {
        return this.findAll(async (element) => {
            try {
                return await element.hasClass(className);
            } catch (error) {
                return false;
            }
        });
    }
    
    /**
     * Sums a numeric property across all elements
     * 
     * @param propertyOrFn Property name or function to get values
     * @returns Promise resolving to the sum
     */
    public async sum(
        propertyOrFn: string | ((element: CSElement) => Promise<number>)
    ): Promise<number> {
        try {
            const elements = await this.getAll();
            let sum = 0;
            
            for (const element of elements) {
                try {
                    let value: number;
                    
                    if (typeof propertyOrFn === 'string') {
                        // Property name
                        const isAttribute = propertyOrFn.startsWith('@');
                        const propName = isAttribute ? propertyOrFn.substring(1) : propertyOrFn;
                        
                        if (isAttribute) {
                            const attrValue = await element.getAttribute(propName);
                            value = attrValue ? parseFloat(attrValue) : 0;
                        } else {
                            value = await element.getProperty<number>(propName);
                        }
                    } else {
                        // Function
                        value = await propertyOrFn(element);
                    }
                    
                    if (!isNaN(value)) {
                        sum += value;
                    }
                } catch (error) {
                    CSLogger.warn(`Failed to get value from element: ${error.message}`);
                }
            }
            
            return sum;
        } catch (error) {
            CSLogger.error(`Failed to sum property for elements ${this.selector}: ${error.message}`);
            return 0;
        }
    }
    
    /**
     * Gets the minimum value of a numeric property across all elements
     * 
     * @param propertyOrFn Property name or function to get values
     * @returns Promise resolving to the minimum value
     */
    public async min(
        propertyOrFn: string | ((element: CSElement) => Promise<number>)
    ): Promise<number | null> {
        try {
            const elements = await this.getAll();
            let min: number | null = null;
            
            for (const element of elements) {
                try {
                    let value: number;
                    
                    if (typeof propertyOrFn === 'string') {
                        // Property name
                        const isAttribute = propertyOrFn.startsWith('@');
                        const propName = isAttribute ? propertyOrFn.substring(1) : propertyOrFn;
                        
                        if (isAttribute) {
                            const attrValue = await element.getAttribute(propName);
                            value = attrValue ? parseFloat(attrValue) : NaN;
                        } else {
                            value = await element.getProperty<number>(propName);
                        }
                    } else {
                        // Function
                        value = await propertyOrFn(element);
                    }
                    
                    if (!isNaN(value) && (min === null || value < min)) {
                        min = value;
                    }
                } catch (error) {
                    CSLogger.warn(`Failed to get value from element: ${error.message}`);
                }
            }
            
            return min;
        } catch (error) {
            CSLogger.error(`Failed to get minimum property for elements ${this.selector}: ${error.message}`);
            return null;
        }
    }
    
    /**
     * Gets the maximum value of a numeric property across all elements
     * 
     * @param propertyOrFn Property name or function to get values
     * @returns Promise resolving to the maximum value
     */
    public async max(
        propertyOrFn: string | ((element: CSElement) => Promise<number>)
    ): Promise<number | null> {
        try {
            const elements = await this.getAll();
            let max: number | null = null;
            
            for (const element of elements) {
                try {
                    let value: number;
                    
                    if (typeof propertyOrFn === 'string') {
                        // Property name
                        const isAttribute = propertyOrFn.startsWith('@');
                        const propName = isAttribute ? propertyOrFn.substring(1) : propertyOrFn;
                        
                        if (isAttribute) {
                            const attrValue = await element.getAttribute(propName);
                            value = attrValue ? parseFloat(attrValue) : NaN;
                        } else {
                            value = await element.getProperty<number>(propName);
                        }
                    } else {
                        // Function
                        value = await propertyOrFn(element);
                    }
                    
                    if (!isNaN(value) && (max === null || value > max)) {
                        max = value;
                    }
                } catch (error) {
                    CSLogger.warn(`Failed to get value from element: ${error.message}`);
                }
            }
            
            return max;
        } catch (error) {
            CSLogger.error(`Failed to get maximum property for elements ${this.selector}: ${error.message}`);
            return null;
        }
    }
    
    /**
     * Gets the average value of a numeric property across all elements
     * 
     * @param propertyOrFn Property name or function to get values
     * @returns Promise resolving to the average value
     */
    public async average(
        propertyOrFn: string | ((element: CSElement) => Promise<number>)
    ): Promise<number | null> {
        try {
            const elements = await this.getAll();
            let sum = 0;
            let count = 0;
            
            for (const element of elements) {
                try {
                    let value: number;
                    
                    if (typeof propertyOrFn === 'string') {
                        // Property name
                        const isAttribute = propertyOrFn.startsWith('@');
                        const propName = isAttribute ? propertyOrFn.substring(1) : propertyOrFn;
                        
                        if (isAttribute) {
                            const attrValue = await element.getAttribute(propName);
                            value = attrValue ? parseFloat(attrValue) : NaN;
                        } else {
                            value = await element.getProperty<number>(propName);
                        }
                    } else {
                        // Function
                        value = await propertyOrFn(element);
                    }
                    
                    if (!isNaN(value)) {
                        sum += value;
                        count++;
                    }
                } catch (error) {
                    CSLogger.warn(`Failed to get value from element: ${error.message}`);
                }
            }
            
            if (count === 0) {
                return null;
            }
            
            return sum / count;
        } catch (error) {
            CSLogger.error(`Failed to get average property for elements ${this.selector}: ${error.message}`);
            return null;
        }
    }
    
    /**
     * Gets the unique values of a property across all elements
     * 
     * @param propertyOrFn Property name or function to get values
     * @returns Promise resolving to an array of unique values
     */
    public async unique<T>(
        propertyOrFn: string | ((element: CSElement) => Promise<T>)
    ): Promise<T[]> {
        try {
            const elements = await this.getAll();
            const values = new Set<T>();
            
            for (const element of elements) {
                try {
                    let value: T;
                    
                    if (typeof propertyOrFn === 'string') {
                        // Property name
                        const isAttribute = propertyOrFn.startsWith('@');
                        const propName = isAttribute ? propertyOrFn.substring(1) : propertyOrFn;
                        
                        if (isAttribute) {
                            value = await element.getAttribute(propName) as unknown as T;
                        } else {
                            value = await element.getProperty<T>(propName);
                        }
                    } else {
                        // Function
                        value = await propertyOrFn(element);
                    }
                    
                    if (value !== null && value !== undefined) {
                        values.add(value);
                    }
                } catch (error) {
                    CSLogger.warn(`Failed to get value from element: ${error.message}`);
                }
            }
            
            return Array.from(values);
        } catch (error) {
            CSLogger.error(`Failed to get unique properties for elements ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Groups elements by a property value
     * 
     * @param propertyOrFn Property name or function to get values
     * @returns Promise resolving to a map of property values to elements
     */
    public async groupBy<T>(
        propertyOrFn: string | ((element: CSElement) => Promise<T>)
    ): Promise<Map<T, CSElement[]>> {
        try {
            const elements = await this.getAll();
            const groups = new Map<T, CSElement[]>();
            
            for (const element of elements) {
                try {
                    let value: T;
                    
                    if (typeof propertyOrFn === 'string') {
                        // Property name
                        const isAttribute = propertyOrFn.startsWith('@');
                        const propName = isAttribute ? propertyOrFn.substring(1) : propertyOrFn;
                        
                        if (isAttribute) {
                            value = await element.getAttribute(propName) as unknown as T;
                        } else {
                            value = await element.getProperty<T>(propName);
                        }
                    } else {
                        // Function
                        value = await propertyOrFn(element);
                    }
                    
                    if (value !== null && value !== undefined) {
                        if (!groups.has(value)) {
                            groups.set(value, []);
                        }
                        
                        groups.get(value)!.push(element);
                    }
                } catch (error) {
                    CSLogger.warn(`Failed to get value from element: ${error.message}`);
                }
            }
            
            return groups;
        } catch (error) {
            CSLogger.error(`Failed to group elements ${this.selector}: ${error.message}`);
            return new Map();
        }
    }
    
    /**
     * Gets the first N elements
     * 
     * @param n Number of elements to take
     * @returns Promise resolving to the first N elements
     */
    public async take(n: number): Promise<CSElement[]> {
        return this.slice(0, n);
    }
    
    /**
     * Gets elements that satisfy a predicate until a condition is met
     * 
     * @param predicate Function that tests each element
     * @returns Promise resolving to elements until the condition is not met
     */
    public async takeWhile(
        predicate: (element: CSElement, index: number) => Promise<boolean>
    ): Promise<CSElement[]> {
        try {
            const elements = await this.getAll();
            const result: CSElement[] = [];
            
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                
                if (await predicate(element, i)) {
                    result.push(element);
                } else {
                    break;
                }
            }
            
            return result;
        } catch (error) {
            CSLogger.error(`Failed to take while for elements ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Skips the first N elements
     * 
     * @param n Number of elements to skip
     * @returns Promise resolving to elements after skipping N
     */
    public async skip(n: number): Promise<CSElement[]> {
        const count = await this.count();
        return this.slice(Math.min(n, count));
    }
    
    /**
     * Skips elements that satisfy a predicate until a condition is not met
     * 
     * @param predicate Function that tests each element
     * @returns Promise resolving to elements after skipping
     */
    public async skipWhile(
        predicate: (element: CSElement, index: number) => Promise<boolean>
    ): Promise<CSElement[]> {
        try {
            const elements = await this.getAll();
            let skipCount = 0;
            
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                
                if (await predicate(element, i)) {
                    skipCount++;
                } else {
                    break;
                }
            }
            
            return elements.slice(skipCount);
        } catch (error) {
            CSLogger.error(`Failed to skip while for elements ${this.selector}: ${error.message}`);
            return [];
        }
    }
    
    /**
     * Creates a new CSElementList from filtered elements
     * 
     * @param selector Selector for the new list
     * @param elements Elements to include
     * @returns New CSElementList
     */
    public async createFromElements(
        selector: string,
        elements: CSElement[]
    ): Promise<CSElementList> {
        // Create a new CSElementList with the specified selector
        const newList = new CSElementList(selector, this.page, this.frame);
        
        // Set the same timeout and highlight settings
        newList.setDefaultTimeout(this.defaultTimeout);
        newList.setHighlightOnInteraction(this.highlightOnInteraction);
        
        // Manually set element cache
        for (let i = 0; i < elements.length; i++) {
            (newList as any).elementCache.set(i, elements[i]);
        }
        
        // Update count cache
        (newList as any).countCache = elements.length;
        (newList as any).countCacheTime = Date.now();
        
        return newList;
    }
}



