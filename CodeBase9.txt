RecorderController.java
-------------------------------------

  package com.cstestforge.controller;

import com.cstestforge.model.recorder.RecordingSession;
import com.cstestforge.model.recorder.RecordingEvent;
import com.cstestforge.model.recorder.RecordingAction;
import com.cstestforge.model.recorder.ElementInfo;
import com.cstestforge.model.recorder.BrowserInfo;
import com.cstestforge.service.recorder.RecorderService;
import com.cstestforge.service.recorder.RecorderServiceFactory;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSDateUtils;
import com.cstestforge.framework.core.utils.CSEncryptionUtils;
import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.service.storage.FileSystemStorageService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.io.IOException;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.stream.Collectors;
import javax.annotation.PreDestroy;

/**
 * Controller for handling test recording operations.
 * This controller provides endpoints for starting/stopping recording sessions
 * and processing recording events.
 */
@RestController
@RequestMapping("/api/recorder")
public class RecorderController {
    
    private static final CSLogger LOGGER = new CSLogger(RecorderController.class);
    
    private final RecorderServiceFactory recorderServiceFactory;
    private final Map<String, RecorderService> activeRecorderSessions = new ConcurrentHashMap<>();
    private final FileSystemStorageService storageService;
    
    @Autowired
    public RecorderController(RecorderServiceFactory recorderServiceFactory, 
                             FileSystemStorageService storageService) {
        this.recorderServiceFactory = recorderServiceFactory;
        this.storageService = storageService;
    }
    
    /**
     * Start a new recording session.
     * 
     * @param recordingSession Session configuration details
     * @return ResponseEntity with the session ID
     */
    @PostMapping("/start")
    public ResponseEntity<Map<String, String>> startRecording(@RequestBody RecordingSession recordingSession) {
        LOGGER.info("Starting new recording session for framework: {} and language: {}", 
                recordingSession.getFrameworkType(), recordingSession.getLanguageType());
        
        try {
            // Generate a unique session ID
            String sessionId = UUID.randomUUID().toString();
            recordingSession.setSessionId(sessionId);
            
            // Record start time
            recordingSession.setStartTime(CSDateUtils.getCurrentTimestamp());
            
            // Create and initialize the appropriate recorder service based on framework and language
            RecorderService recorderService = recorderServiceFactory.createRecorderService(
                    recordingSession.getFrameworkType(), 
                    recordingSession.getLanguageType(),
                    recordingSession.getTestType());
            
            // Initialize the recorder
            recorderService.initializeRecorder(recordingSession);
            
            // Store the active recorder session
            activeRecorderSessions.put(sessionId, recorderService);
            
            // Persist session data to storage
            storageService.saveRecordingSession(recordingSession);
            
            Map<String, String> response = new HashMap<>();
            response.put("sessionId", sessionId);
            response.put("status", "STARTED");
            response.put("timestamp", CSDateUtils.formatTimestamp(recordingSession.getStartTime()));
            
            LOGGER.info("Recording session started with ID: {}", sessionId);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            LOGGER.error("Failed to start recording session", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to start recording: " + e.getMessage()));
        }
    }
    
    /**
     * Stop an active recording session.
     * 
     * @param sessionId ID of the recording session to stop
     * @return ResponseEntity with the result
     */
    @PostMapping("/stop/{sessionId}")
    public ResponseEntity<Map<String, Object>> stopRecording(@PathVariable String sessionId) {
        LOGGER.info("Stopping recording session: {}", sessionId);
        
        RecorderService recorderService = activeRecorderSessions.get(sessionId);
        if (recorderService == null) {
            LOGGER.warn("No active recording session found with ID: {}", sessionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Recording session not found"));
        }
        
        try {
            // Stop the recorder
            RecordingSession session = recorderService.getRecordingSession();
            session.setEndTime(CSDateUtils.getCurrentTimestamp());
            session.setStatus("COMPLETED");
            
            // Finalize recording and get the recorded actions
            List<RecordingAction> recordedActions = recorderService.finalizeRecording();
            
            // Generate code based on recorded actions
            String generatedCode = recorderService.generateCode(recordedActions);
            
            // Save results to storage
            storageService.saveRecordingActions(sessionId, recordedActions);
            storageService.saveGeneratedCode(sessionId, generatedCode);
            storageService.updateRecordingSession(session);
            
            // Remove from active sessions
            activeRecorderSessions.remove(sessionId);
            
            Map<String, Object> response = new HashMap<>();
            response.put("sessionId", sessionId);
            response.put("status", "STOPPED");
            response.put("timestamp", CSDateUtils.formatTimestamp(session.getEndTime()));
            response.put("actionCount", recordedActions.size());
            response.put("duration", CSDateUtils.calculateDuration(session.getStartTime(), session.getEndTime()));
            response.put("generatedCode", generatedCode);
            
            LOGGER.info("Recording session stopped: {}", sessionId);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            LOGGER.error("Failed to stop recording session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to stop recording: " + e.getMessage()));
        }
    }
    
    /**
     * Process a recording event from the browser.
     * 
     * @param sessionId ID of the recording session
     * @param recordingEvent The event to process
     * @return ResponseEntity with the result
     */
    @PostMapping("/event/{sessionId}")
    public ResponseEntity<Map<String, Object>> processEvent(
            @PathVariable String sessionId,
            @RequestBody RecordingEvent recordingEvent) {
        
        LOGGER.debug("Processing recording event for session: {}, event type: {}", 
                sessionId, recordingEvent.getEventType());
        
        RecorderService recorderService = activeRecorderSessions.get(sessionId);
        if (recorderService == null) {
            LOGGER.warn("No active recording session found with ID: {}", sessionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Recording session not found"));
        }
        
        try {
            // Process the event
            RecordingAction action = recorderService.processEvent(recordingEvent);
            
            // If the event generated an action, save it
            if (action != null) {
                LOGGER.debug("Event processed into action: {}", action.getActionType());
                recorderService.addAction(action);
                storageService.saveRecordingAction(sessionId, action);
                
                return ResponseEntity.ok(Map.of(
                        "status", "SUCCESS",
                        "actionGenerated", true,
                        "actionType", action.getActionType(),
                        "actionId", action.getActionId()
                ));
            } else {
                // Some events don't generate actions (like mouse moves)
                return ResponseEntity.ok(Map.of(
                        "status", "SUCCESS",
                        "actionGenerated", false
                ));
            }
        } catch (Exception e) {
            LOGGER.error("Failed to process recording event for session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to process event: " + e.getMessage()));
        }
    }
    
    /**
     * Update an existing recorded action.
     * 
     * @param sessionId ID of the recording session
     * @param actionId ID of the action to update
     * @param action Updated action data
     * @return ResponseEntity with the result
     */
    @PutMapping("/action/{sessionId}/{actionId}")
    public ResponseEntity<Map<String, Object>> updateAction(
            @PathVariable String sessionId,
            @PathVariable String actionId,
            @RequestBody RecordingAction action) {
        
        LOGGER.info("Updating action {} in session {}", actionId, sessionId);
        
        RecorderService recorderService = activeRecorderSessions.get(sessionId);
        if (recorderService == null) {
            LOGGER.warn("No active recording session found with ID: {}", sessionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Recording session not found"));
        }
        
        try {
            // Ensure the action ID in the path matches the action ID in the body
            if (!actionId.equals(action.getActionId())) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of("error", "Action ID in path does not match action ID in body"));
            }
            
            boolean updated = recorderService.updateAction(action);
            if (updated) {
                // Update in storage
                storageService.updateRecordingAction(sessionId, action);
                
                return ResponseEntity.ok(Map.of(
                        "status", "SUCCESS",
                        "message", "Action updated successfully"
                ));
            } else {
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                        .body(Map.of("error", "Action not found in session"));
            }
        } catch (Exception e) {
            LOGGER.error("Failed to update action {} in session {}", actionId, sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to update action: " + e.getMessage()));
        }
    }
    
    /**
     * Delete an existing recorded action.
     * 
     * @param sessionId ID of the recording session
     * @param actionId ID of the action to delete
     * @return ResponseEntity with the result
     */
    @DeleteMapping("/action/{sessionId}/{actionId}")
    public ResponseEntity<Map<String, Object>> deleteAction(
            @PathVariable String sessionId,
            @PathVariable String actionId) {
        
        LOGGER.info("Deleting action {} from session {}", actionId, sessionId);
        
        RecorderService recorderService = activeRecorderSessions.get(sessionId);
        if (recorderService == null) {
            LOGGER.warn("No active recording session found with ID: {}", sessionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Recording session not found"));
        }
        
        try {
            boolean deleted = recorderService.deleteAction(actionId);
            if (deleted) {
                // Delete from storage
                storageService.deleteRecordingAction(sessionId, actionId);
                
                return ResponseEntity.ok(Map.of(
                        "status", "SUCCESS",
                        "message", "Action deleted successfully"
                ));
            } else {
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                        .body(Map.of("error", "Action not found in session"));
            }
        } catch (Exception e) {
            LOGGER.error("Failed to delete action {} from session {}", actionId, sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to delete action: " + e.getMessage()));
        }
    }
    
    /**
     * Add a custom action to the recording session.
     * 
     * @param sessionId ID of the recording session
     * @param action The custom action to add
     * @return ResponseEntity with the result
     */
    @PostMapping("/action/{sessionId}")
    public ResponseEntity<Map<String, Object>> addCustomAction(
            @PathVariable String sessionId,
            @RequestBody RecordingAction action) {
        
        LOGGER.info("Adding custom action to session {}: {}", sessionId, action.getActionType());
        
        RecorderService recorderService = activeRecorderSessions.get(sessionId);
        if (recorderService == null) {
            LOGGER.warn("No active recording session found with ID: {}", sessionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Recording session not found"));
        }
        
        try {
            // Generate an ID if not provided
            if (action.getActionId() == null || action.getActionId().isEmpty()) {
                action.setActionId(UUID.randomUUID().toString());
            }
            
            // Add timestamp
            action.setTimestamp(CSDateUtils.getCurrentTimestamp());
            
            // Add to recorder
            recorderService.addAction(action);
            
            // Save to storage
            storageService.saveRecordingAction(sessionId, action);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(Map.of(
                    "status", "SUCCESS",
                    "actionId", action.getActionId(),
                    "message", "Custom action added successfully"
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to add custom action to session {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to add custom action: " + e.getMessage()));
        }
    }
    
    /**
     * Reorder actions in a recording session.
     * 
     * @param sessionId ID of the recording session
     * @param actionIds Ordered list of action IDs
     * @return ResponseEntity with the result
     */
    @PostMapping("/reorder/{sessionId}")
    public ResponseEntity<Map<String, Object>> reorderActions(
            @PathVariable String sessionId,
            @RequestBody List<String> actionIds) {
        
        LOGGER.info("Reordering actions in session {}", sessionId);
        
        RecorderService recorderService = activeRecorderSessions.get(sessionId);
        if (recorderService == null) {
            LOGGER.warn("No active recording session found with ID: {}", sessionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Recording session not found"));
        }
        
        try {
            boolean reordered = recorderService.reorderActions(actionIds);
            if (reordered) {
                // Update storage with new order
                List<RecordingAction> actions = recorderService.getRecordedActions();
                storageService.updateRecordingActionsOrder(sessionId, actions);
                
                return ResponseEntity.ok(Map.of(
                        "status", "SUCCESS",
                        "message", "Actions reordered successfully"
                ));
            } else {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of("error", "Invalid action IDs or reordering failed"));
            }
        } catch (Exception e) {
            LOGGER.error("Failed to reorder actions in session {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to reorder actions: " + e.getMessage()));
        }
    }
    
    /**
     * Get all recording sessions.
     * 
     * @return ResponseEntity with the list of sessions
     */
    @GetMapping("/sessions")
    public ResponseEntity<List<RecordingSession>> getAllSessions() {
        LOGGER.info("Getting all recording sessions");
        
        try {
            List<RecordingSession> sessions = storageService.getAllRecordingSessions();
            return ResponseEntity.ok(sessions);
        } catch (Exception e) {
            LOGGER.error("Failed to get recording sessions", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get a specific recording session by ID.
     * 
     * @param sessionId ID of the recording session
     * @return ResponseEntity with the session details
     */
    @GetMapping("/session/{sessionId}")
    public ResponseEntity<RecordingSession> getSession(@PathVariable String sessionId) {
        LOGGER.info("Getting recording session: {}", sessionId);
        
        try {
            RecordingSession session = storageService.getRecordingSession(sessionId);
            if (session != null) {
                return ResponseEntity.ok(session);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get recording session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get all actions for a specific recording session.
     * 
     * @param sessionId ID of the recording session
     * @return ResponseEntity with the list of actions
     */
    @GetMapping("/actions/{sessionId}")
    public ResponseEntity<List<RecordingAction>> getSessionActions(@PathVariable String sessionId) {
        LOGGER.info("Getting actions for recording session: {}", sessionId);
        
        try {
            List<RecordingAction> actions;
            
            // First check if this is an active session
            RecorderService recorderService = activeRecorderSessions.get(sessionId);
            if (recorderService != null) {
                actions = recorderService.getRecordedActions();
            } else {
                // Otherwise load from storage
                actions = storageService.getRecordingActions(sessionId);
            }
            
            if (actions != null) {
                return ResponseEntity.ok(actions);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get actions for recording session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Generate code for a specific recording session.
     * 
     * @param sessionId ID of the recording session
     * @return ResponseEntity with the generated code
     */
    @GetMapping("/generateCode/{sessionId}")
    public ResponseEntity<Map<String, String>> generateCode(@PathVariable String sessionId) {
        LOGGER.info("Generating code for recording session: {}", sessionId);
        
        try {
            List<RecordingAction> actions;
            String generatedCode;
            
            // First check if this is an active session
            RecorderService recorderService = activeRecorderSessions.get(sessionId);
            if (recorderService != null) {
                actions = recorderService.getRecordedActions();
                generatedCode = recorderService.generateCode(actions);
            } else {
                // Otherwise load from storage and create a temporary recorder
                RecordingSession session = storageService.getRecordingSession(sessionId);
                if (session == null) {
                    return ResponseEntity.notFound().build();
                }
                
                actions = storageService.getRecordingActions(sessionId);
                
                RecorderService tempRecorderService = recorderServiceFactory.createRecorderService(
                        session.getFrameworkType(), 
                        session.getLanguageType(),
                        session.getTestType());
                
                generatedCode = tempRecorderService.generateCode(actions);
            }
            
            // Save the generated code
            storageService.saveGeneratedCode(sessionId, generatedCode);
            
            return ResponseEntity.ok(Map.of("code", generatedCode));
        } catch (Exception e) {
            LOGGER.error("Failed to generate code for recording session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to generate code: " + e.getMessage()));
        }
    }
    
    /**
     * Pause an active recording session.
     * 
     * @param sessionId ID of the recording session
     * @return ResponseEntity with the result
     */
    @PostMapping("/pause/{sessionId}")
    public ResponseEntity<Map<String, Object>> pauseRecording(@PathVariable String sessionId) {
        LOGGER.info("Pausing recording session: {}", sessionId);
        
        RecorderService recorderService = activeRecorderSessions.get(sessionId);
        if (recorderService == null) {
            LOGGER.warn("No active recording session found with ID: {}", sessionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Recording session not found"));
        }
        
        try {
            RecordingSession session = recorderService.getRecordingSession();
            session.setStatus("PAUSED");
            session.setPauseTime(CSDateUtils.getCurrentTimestamp());
            
            // Update in storage
            storageService.updateRecordingSession(session);
            
            return ResponseEntity.ok(Map.of(
                    "status", "PAUSED",
                    "message", "Recording session paused successfully",
                    "timestamp", CSDateUtils.formatTimestamp(session.getPauseTime())
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to pause recording session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to pause recording: " + e.getMessage()));
        }
    }
    
    /**
     * Resume a paused recording session.
     * 
     * @param sessionId ID of the recording session
     * @return ResponseEntity with the result
     */
    @PostMapping("/resume/{sessionId}")
    public ResponseEntity<Map<String, Object>> resumeRecording(@PathVariable String sessionId) {
        LOGGER.info("Resuming recording session: {}", sessionId);
        
        RecorderService recorderService = activeRecorderSessions.get(sessionId);
        if (recorderService == null) {
            LOGGER.warn("No active recording session found with ID: {}", sessionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Recording session not found"));
        }
        
        try {
            RecordingSession session = recorderService.getRecordingSession();
            session.setStatus("RECORDING");
            session.setResumeTime(CSDateUtils.getCurrentTimestamp());
            
            // Calculate total pause time
            long pauseDurationMs = CSDateUtils.calculateDurationInMillis(
                    session.getPauseTime(), session.getResumeTime());
            session.setTotalPauseDuration(
                    (session.getTotalPauseDuration() != null ? session.getTotalPauseDuration() : 0) 
                    + pauseDurationMs);
            
            // Update in storage
            storageService.updateRecordingSession(session);
            
            return ResponseEntity.ok(Map.of(
                    "status", "RECORDING",
                    "message", "Recording session resumed successfully",
                    "timestamp", CSDateUtils.formatTimestamp(session.getResumeTime())
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to resume recording session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to resume recording: " + e.getMessage()));
        }
    }
    
    /**
     * Check if a URL can be used for recording.
     * 
     * @param url The URL to validate
     * @return ResponseEntity with the validation result
     */
    @GetMapping("/validate-url")
    public ResponseEntity<Map<String, Object>> validateUrl(@RequestParam String url) {
        LOGGER.info("Validating URL for recording: {}", url);
        
        try {
            // Validate URL format
            if (!url.startsWith("http://") && !url.startsWith("https://")) {
                return ResponseEntity.badRequest().body(Map.of(
                        "valid", false,
                        "message", "URL must start with http:// or https://"
                ));
            }
            
            // Perform a basic connectivity check
            boolean isAccessible = CSFileUtils.isUrlAccessible(url);
            
            if (isAccessible) {
                return ResponseEntity.ok(Map.of(
                        "valid", true,
                        "message", "URL is valid and accessible"
                ));
            } else {
                return ResponseEntity.ok(Map.of(
                        "valid", false,
                        "message", "URL is not accessible"
                ));
            }
        } catch (Exception e) {
            LOGGER.error("Failed to validate URL: {}", url, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "valid", false,
                            "message", "Error validating URL: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get element locator suggestions for a given element.
     * 
     * @param sessionId ID of the recording session
     * @param elementInfo Information about the element
     * @return ResponseEntity with locator suggestions
     */
    @PostMapping("/locator-suggestions/{sessionId}")
    public ResponseEntity<Map<String, Object>> getLocatorSuggestions(
            @PathVariable String sessionId,
            @RequestBody ElementInfo elementInfo) {
        
        LOGGER.info("Getting locator suggestions for element in session {}", sessionId);
        
        RecorderService recorderService = activeRecorderSessions.get(sessionId);
        if (recorderService == null) {
            LOGGER.warn("No active recording session found with ID: {}", sessionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Recording session not found"));
        }
        
        try {
            Map<String, String> suggestions = recorderService.generateLocatorSuggestions(elementInfo);
            
            if (suggestions != null && !suggestions.isEmpty()) {
                return ResponseEntity.ok(Map.of(
                        "suggestions", suggestions,
                        "elementInfo", elementInfo
                ));
            } else {
                return ResponseEntity.ok(Map.of(
                        "message", "No locator suggestions available for this element",
                        "elementInfo", elementInfo
                ));
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get locator suggestions for session {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to generate locator suggestions: " + e.getMessage()));
        }
    }
    
    /**
     * Get details of active recording sessions.
     * 
     * @return ResponseEntity with active sessions
     */
    @GetMapping("/active-sessions")
    public ResponseEntity<List<Map<String, Object>>> getActiveSessions() {
        LOGGER.info("Getting active recording sessions");
        
        try {
            List<Map<String, Object>> activeSessions = activeRecorderSessions.entrySet().stream()
                    .map(entry -> {
                        RecordingSession session = entry.getValue().getRecordingSession();
                        Map<String, Object> sessionMap = new HashMap<>();
                        sessionMap.put("sessionId", session.getSessionId());
                        sessionMap.put("framework", session.getFrameworkType());
                        sessionMap.put("language", session.getLanguageType());
                        sessionMap.put("testType", session.getTestType());
                        sessionMap.put("status", session.getStatus());
                        sessionMap.put("startTime", CSDateUtils.formatTimestamp(session.getStartTime()));
                        sessionMap.put("actionCount", entry.getValue().getRecordedActions().size());
                        return sessionMap;
                    })
                    .collect(Collectors.toList());
            
            return ResponseEntity.ok(activeSessions);
        } catch (Exception e) {
            LOGGER.error("Failed to get active recording sessions", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Clean up resources when the application is shutting down.
     */
    @PreDestroy
    public void cleanup() {
        LOGGER.info("Cleaning up recorder resources...");
        
        for (Map.Entry<String, RecorderService> entry : activeRecorderSessions.entrySet()) {
            try {
                String sessionId = entry.getKey();
                RecorderService recorderService = entry.getValue();
                
                LOGGER.info("Finalizing recording session: {}", sessionId);
                
                // Update session status
                RecordingSession session = recorderService.getRecordingSession();
                session.setStatus("INTERRUPTED");
                session.setEndTime(CSDateUtils.getCurrentTimestamp());
                
                // Save to storage
                List<RecordingAction> actions = recorderService.getRecordedActions();
                storageService.saveRecordingActions(sessionId, actions);
                storageService.updateRecordingSession(session);
                
                // Generate and save code if there are actions
                if (!actions.isEmpty()) {
                    String generatedCode = recorderService.generateCode(actions);
                    storageService.saveGeneratedCode(sessionId, generatedCode);
                }
            } catch (Exception e) {
                LOGGER.error("Error during cleanup of recording session: {}", entry.getKey(), e);
            }
        }
        
        // Clear the map
        activeRecorderSessions.clear();
        
        LOGGER.info("Recorder resources cleanup completed");
    }
}


TestExecutionController.java
--------------------------------------------------

  package com.cstestforge.controller;

import com.cstestforge.model.execution.TestExecutionRequest;
import com.cstestforge.model.execution.TestExecutionResult;
import com.cstestforge.model.execution.TestStatus;
import com.cstestforge.model.execution.TestLog;
import com.cstestforge.model.execution.ParallelExecutionConfig;
import com.cstestforge.model.execution.DistributedExecutionConfig;
import com.cstestforge.model.execution.ExecutionEnvironment;
import com.cstestforge.model.execution.BrowserConfig;
import com.cstestforge.service.test.TestExecutionService;
import com.cstestforge.service.test.TestExecutionServiceFactory;
import com.cstestforge.service.storage.FileSystemStorageService;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSDateUtils;
import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.service.realtime.LiveExecutionService;
import com.cstestforge.service.realtime.ResourceMonitorService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Optional;
import java.io.IOException;
import javax.annotation.PreDestroy;

/**
 * Controller for handling test execution operations.
 * This controller provides endpoints for executing tests, managing test runs,
 * and retrieving test results.
 */
@RestController
@RequestMapping("/api/execution")
public class TestExecutionController {

    private static final CSLogger LOGGER = new CSLogger(TestExecutionController.class);
    
    private final TestExecutionServiceFactory testExecutionServiceFactory;
    private final FileSystemStorageService storageService;
    private final LiveExecutionService liveExecutionService;
    private final ResourceMonitorService resourceMonitorService;
    private final Map<String, TestExecutionService> activeExecutions = new ConcurrentHashMap<>();
    private final ExecutorService executorService = Executors.newCachedThreadPool();
    
    @Autowired
    public TestExecutionController(
            TestExecutionServiceFactory testExecutionServiceFactory,
            FileSystemStorageService storageService,
            LiveExecutionService liveExecutionService,
            ResourceMonitorService resourceMonitorService) {
        this.testExecutionServiceFactory = testExecutionServiceFactory;
        this.storageService = storageService;
        this.liveExecutionService = liveExecutionService;
        this.resourceMonitorService = resourceMonitorService;
    }
    
    /**
     * Start test execution.
     * 
     * @param testExecutionRequest Test execution configuration
     * @return ResponseEntity with execution details
     */
    @PostMapping("/start")
    public ResponseEntity<Map<String, Object>> startExecution(
            @RequestBody TestExecutionRequest testExecutionRequest) {
        
        LOGGER.info("Starting test execution for framework: {} and language: {}",
                testExecutionRequest.getFrameworkType(), testExecutionRequest.getLanguageType());
        
        try {
            // Generate execution ID
            String executionId = UUID.randomUUID().toString();
            testExecutionRequest.setExecutionId(executionId);
            testExecutionRequest.setStartTime(CSDateUtils.getCurrentTimestamp());
            testExecutionRequest.setStatus(TestStatus.INITIALIZING);
            
            // Create execution service based on framework and language
            TestExecutionService executionService = testExecutionServiceFactory.createExecutionService(
                    testExecutionRequest.getFrameworkType(),
                    testExecutionRequest.getLanguageType(),
                    testExecutionRequest.getTestType());
            
            // Initialize test execution
            executionService.initialize(testExecutionRequest);
            
            // Store in active executions
            activeExecutions.put(executionId, executionService);
            
            // Save execution request to storage
            storageService.saveTestExecutionRequest(testExecutionRequest);
            
            // Start execution in a separate thread
            executorService.submit(() -> {
                try {
                    LOGGER.info("Executing tests for execution ID: {}", executionId);
                    
                    // Update status
                    testExecutionRequest.setStatus(TestStatus.RUNNING);
                    storageService.updateTestExecutionRequest(testExecutionRequest);
                    
                    // Notify subscribers
                    liveExecutionService.broadcastExecutionStatus(executionId, TestStatus.RUNNING);
                    
                    // Start resource monitoring
                    resourceMonitorService.startMonitoring(executionId);
                    
                    // Execute tests
                    List<TestExecutionResult> results = executionService.executeTests();
                    
                    // Update status
                    boolean allPassed = results.stream()
                            .allMatch(result -> result.getStatus() == TestStatus.PASSED);
                    
                    TestStatus finalStatus = allPassed ? TestStatus.COMPLETED : TestStatus.COMPLETED_WITH_FAILURES;
                    testExecutionRequest.setStatus(finalStatus);
                    testExecutionRequest.setEndTime(CSDateUtils.getCurrentTimestamp());
                    
                    // Calculate execution metrics
                    long totalDuration = results.stream()
                            .mapToLong(result -> result.getDurationInMillis())
                            .sum();
                    
                    int passedCount = (int) results.stream()
                            .filter(result -> result.getStatus() == TestStatus.PASSED)
                            .count();
                    
                    int failedCount = (int) results.stream()
                            .filter(result -> result.getStatus() == TestStatus.FAILED)
                            .count();
                    
                    int skippedCount = (int) results.stream()
                            .filter(result -> result.getStatus() == TestStatus.SKIPPED)
                            .count();
                    
                    testExecutionRequest.setTotalDuration(totalDuration);
                    testExecutionRequest.setPassedCount(passedCount);
                    testExecutionRequest.setFailedCount(failedCount);
                    testExecutionRequest.setSkippedCount(skippedCount);
                    
                    // Save results and update request
                    storageService.saveTestExecutionResults(executionId, results);
                    storageService.updateTestExecutionRequest(testExecutionRequest);
                    
                    // Notify subscribers
                    liveExecutionService.broadcastExecutionStatus(executionId, finalStatus);
                    liveExecutionService.broadcastExecutionComplete(executionId, results);
                    
                    // Stop resource monitoring
                    resourceMonitorService.stopMonitoring(executionId);
                    
                    // Remove from active executions
                    activeExecutions.remove(executionId);
                    
                    LOGGER.info("Test execution completed for execution ID: {}, status: {}", 
                            executionId, finalStatus);
                    
                } catch (Exception e) {
                    LOGGER.error("Error during test execution for ID: {}", executionId, e);
                    
                    // Update status to ERROR
                    testExecutionRequest.setStatus(TestStatus.ERROR);
                    testExecutionRequest.setEndTime(CSDateUtils.getCurrentTimestamp());
                    testExecutionRequest.setErrorMessage(e.getMessage());
                    
                    // Save updated request
                    storageService.updateTestExecutionRequest(testExecutionRequest);
                    
                    // Notify subscribers
                    liveExecutionService.broadcastExecutionStatus(executionId, TestStatus.ERROR);
                    liveExecutionService.broadcastExecutionError(executionId, e.getMessage());
                    
                    // Stop resource monitoring
                    resourceMonitorService.stopMonitoring(executionId);
                    
                    // Remove from active executions
                    activeExecutions.remove(executionId);
                }
            });
            
            // Return response with execution details
            Map<String, Object> response = new HashMap<>();
            response.put("executionId", executionId);
            response.put("status", TestStatus.INITIALIZING.name());
            response.put("message", "Test execution started");
            response.put("startTime", CSDateUtils.formatTimestamp(testExecutionRequest.getStartTime()));
            response.put("testCount", testExecutionRequest.getTestList().size());
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            LOGGER.error("Failed to start test execution", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to start test execution: " + e.getMessage()));
        }
    }
    
    /**
     * Stop an active test execution.
     * 
     * @param executionId ID of the test execution to stop
     * @return ResponseEntity with the result
     */
    @PostMapping("/stop/{executionId}")
    public ResponseEntity<Map<String, Object>> stopExecution(@PathVariable String executionId) {
        LOGGER.info("Stopping test execution: {}", executionId);
        
        TestExecutionService executionService = activeExecutions.get(executionId);
        if (executionService == null) {
            LOGGER.warn("No active test execution found with ID: {}", executionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Test execution not found"));
        }
        
        try {
            // Stop the execution
            executionService.stopExecution();
            
            // Update the execution request
            TestExecutionRequest request = storageService.getTestExecutionRequest(executionId);
            if (request != null) {
                request.setStatus(TestStatus.STOPPED);
                request.setEndTime(CSDateUtils.getCurrentTimestamp());
                storageService.updateTestExecutionRequest(request);
            }
            
            // Notify subscribers
            liveExecutionService.broadcastExecutionStatus(executionId, TestStatus.STOPPED);
            
            // Stop resource monitoring
            resourceMonitorService.stopMonitoring(executionId);
            
            // Remove from active executions
            activeExecutions.remove(executionId);
            
            return ResponseEntity.ok(Map.of(
                    "executionId", executionId,
                    "status", TestStatus.STOPPED.name(),
                    "message", "Test execution stopped successfully"
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to stop test execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to stop test execution: " + e.getMessage()));
        }
    }
    
    /**
     * Pause an active test execution.
     * 
     * @param executionId ID of the test execution to pause
     * @return ResponseEntity with the result
     */
    @PostMapping("/pause/{executionId}")
    public ResponseEntity<Map<String, Object>> pauseExecution(@PathVariable String executionId) {
        LOGGER.info("Pausing test execution: {}", executionId);
        
        TestExecutionService executionService = activeExecutions.get(executionId);
        if (executionService == null) {
            LOGGER.warn("No active test execution found with ID: {}", executionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Test execution not found"));
        }
        
        try {
            // Check if the service supports pausing
            if (!executionService.supportsPause()) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of("error", "This test execution does not support pausing"));
            }
            
            // Pause the execution
            executionService.pauseExecution();
            
            // Update the execution request
            TestExecutionRequest request = storageService.getTestExecutionRequest(executionId);
            if (request != null) {
                request.setStatus(TestStatus.PAUSED);
                request.setPauseTime(CSDateUtils.getCurrentTimestamp());
                storageService.updateTestExecutionRequest(request);
            }
            
            // Notify subscribers
            liveExecutionService.broadcastExecutionStatus(executionId, TestStatus.PAUSED);
            
            return ResponseEntity.ok(Map.of(
                    "executionId", executionId,
                    "status", TestStatus.PAUSED.name(),
                    "message", "Test execution paused successfully"
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to pause test execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to pause test execution: " + e.getMessage()));
        }
    }
    
    /**
     * Resume a paused test execution.
     * 
     * @param executionId ID of the test execution to resume
     * @return ResponseEntity with the result
     */
    @PostMapping("/resume/{executionId}")
    public ResponseEntity<Map<String, Object>> resumeExecution(@PathVariable String executionId) {
        LOGGER.info("Resuming test execution: {}", executionId);
        
        TestExecutionService executionService = activeExecutions.get(executionId);
        if (executionService == null) {
            LOGGER.warn("No active test execution found with ID: {}", executionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Test execution not found"));
        }
        
        try {
            // Check if the service supports resuming
            if (!executionService.supportsPause()) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of("error", "This test execution does not support resuming"));
            }
            
            // Resume the execution
            executionService.resumeExecution();
            
            // Update the execution request
            TestExecutionRequest request = storageService.getTestExecutionRequest(executionId);
            if (request != null) {
                request.setStatus(TestStatus.RUNNING);
                request.setResumeTime(CSDateUtils.getCurrentTimestamp());
                
                // Calculate pause duration
                if (request.getPauseTime() != null) {
                    long pauseDurationMs = CSDateUtils.calculateDurationInMillis(
                            request.getPauseTime(), request.getResumeTime());
                    request.setTotalPauseDuration(
                            (request.getTotalPauseDuration() != null ? request.getTotalPauseDuration() : 0)
                            + pauseDurationMs);
                }
                
                storageService.updateTestExecutionRequest(request);
            }
            
            // Notify subscribers
            liveExecutionService.broadcastExecutionStatus(executionId, TestStatus.RUNNING);
            
            return ResponseEntity.ok(Map.of(
                    "executionId", executionId,
                    "status", TestStatus.RUNNING.name(),
                    "message", "Test execution resumed successfully"
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to resume test execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to resume test execution: " + e.getMessage()));
        }
    }
    
    /**
     * Get test execution results.
     * 
     * @param executionId ID of the test execution
     * @return ResponseEntity with the test results
     */
    @GetMapping("/results/{executionId}")
    public ResponseEntity<List<TestExecutionResult>> getExecutionResults(@PathVariable String executionId) {
        LOGGER.info("Getting test results for execution: {}", executionId);
        
        try {
            // Check if execution is active
            TestExecutionService executionService = activeExecutions.get(executionId);
            if (executionService != null) {
                // Get live results from the execution service
                List<TestExecutionResult> results = executionService.getCurrentResults();
                return ResponseEntity.ok(results);
            }
            
            // Otherwise, load from storage
            List<TestExecutionResult> results = storageService.getTestExecutionResults(executionId);
            if (results != null && !results.isEmpty()) {
                return ResponseEntity.ok(results);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get test results for execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get test execution status.
     * 
     * @param executionId ID of the test execution
     * @return ResponseEntity with the execution status
     */
    @GetMapping("/status/{executionId}")
    public ResponseEntity<Map<String, Object>> getExecutionStatus(@PathVariable String executionId) {
        LOGGER.info("Getting status for test execution: {}", executionId);
        
        try {
            // Check if execution is active
            TestExecutionService executionService = activeExecutions.get(executionId);
            if (executionService != null) {
                // Get live status
                TestStatus status = executionService.getCurrentStatus();
                
                Map<String, Object> statusInfo = new HashMap<>();
                statusInfo.put("executionId", executionId);
                statusInfo.put("status", status.name());
                statusInfo.put("active", true);
                statusInfo.put("progress", executionService.getExecutionProgress());
                statusInfo.put("currentTest", executionService.getCurrentTestName());
                
                return ResponseEntity.ok(statusInfo);
            }
            
            // Otherwise, load from storage
            TestExecutionRequest request = storageService.getTestExecutionRequest(executionId);
            if (request != null) {
                Map<String, Object> statusInfo = new HashMap<>();
                statusInfo.put("executionId", executionId);
                statusInfo.put("status", request.getStatus().name());
                statusInfo.put("active", false);
                statusInfo.put("startTime", CSDateUtils.formatTimestamp(request.getStartTime()));
                
                if (request.getEndTime() != null) {
                    statusInfo.put("endTime", CSDateUtils.formatTimestamp(request.getEndTime()));
                    statusInfo.put("duration", CSDateUtils.calculateDuration(
                            request.getStartTime(), request.getEndTime()));
                }
                
                statusInfo.put("passedCount", request.getPassedCount());
                statusInfo.put("failedCount", request.getFailedCount());
                statusInfo.put("skippedCount", request.getSkippedCount());
                
                return ResponseEntity.ok(statusInfo);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get status for test execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get test logs for a specific test.
     * 
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @return ResponseEntity with the test logs
     */
    @GetMapping("/logs/{executionId}/{testId}")
    public ResponseEntity<List<TestLog>> getTestLogs(
            @PathVariable String executionId,
            @PathVariable String testId) {
        
        LOGGER.info("Getting logs for test {} in execution {}", testId, executionId);
        
        try {
            // Check if execution is active
            TestExecutionService executionService = activeExecutions.get(executionId);
            if (executionService != null) {
                // Get live logs
                List<TestLog> logs = executionService.getTestLogs(testId);
                return ResponseEntity.ok(logs);
            }
            
            // Otherwise, load from storage
            List<TestLog> logs = storageService.getTestLogs(executionId, testId);
            if (logs != null) {
                return ResponseEntity.ok(logs);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get logs for test {} in execution {}", 
                    testId, executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Subscribe to live execution updates.
     * 
     * @param executionId ID of the test execution
     * @return SseEmitter for streaming updates
     */
    @GetMapping("/live/{executionId}")
    public SseEmitter subscribeLiveUpdates(@PathVariable String executionId) {
        LOGGER.info("Client subscribing to live updates for execution: {}", executionId);
        
        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
        
        try {
            // Register emitter with live execution service
            liveExecutionService.registerClient(executionId, emitter);
            
            // Set completion callback
            emitter.onCompletion(() -> {
                LOGGER.info("Client unsubscribed from live updates for execution: {}", executionId);
                liveExecutionService.unregisterClient(executionId, emitter);
            });
            
            // Set timeout callback
            emitter.onTimeout(() -> {
                LOGGER.info("Subscription timed out for execution: {}", executionId);
                liveExecutionService.unregisterClient(executionId, emitter);
                emitter.complete();
            });
            
            // Set error callback
            emitter.onError(e -> {
                LOGGER.error("Error in live updates for execution: {}", executionId, e);
                liveExecutionService.unregisterClient(executionId, emitter);
                emitter.completeWithError(e);
            });
            
            // Send initial status
            TestExecutionService executionService = activeExecutions.get(executionId);
            if (executionService != null) {
                // Send current status for active execution
                TestStatus status = executionService.getCurrentStatus();
                liveExecutionService.sendStatusUpdate(emitter, executionId, status);
                
                // Send current progress
                double progress = executionService.getExecutionProgress();
                liveExecutionService.sendProgressUpdate(emitter, executionId, progress);
                
                // Send current results if available
                List<TestExecutionResult> results = executionService.getCurrentResults();
                if (results != null && !results.isEmpty()) {
                    liveExecutionService.sendResultsUpdate(emitter, executionId, results);
                }
            } else {
                // Check if execution exists
                TestExecutionRequest request = storageService.getTestExecutionRequest(executionId);
                if (request != null) {
                    // Send stored status
                    liveExecutionService.sendStatusUpdate(emitter, executionId, request.getStatus());
                    
                    // Send stored results if completed
                    if (request.getStatus() == TestStatus.COMPLETED || 
                            request.getStatus() == TestStatus.COMPLETED_WITH_FAILURES ||
                            request.getStatus() == TestStatus.ERROR ||
                            request.getStatus() == TestStatus.STOPPED) {
                        
                        List<TestExecutionResult> results = storageService.getTestExecutionResults(executionId);
                        if (results != null && !results.isEmpty()) {
                            liveExecutionService.sendResultsUpdate(emitter, executionId, results);
                        }
                    }
                } else {
                    // If execution doesn't exist, send error and complete
                    liveExecutionService.sendErrorUpdate(emitter, executionId, "Execution not found");
                    emitter.complete();
                }
            }
            
            return emitter;
        } catch (Exception e) {
            LOGGER.error("Failed to set up live updates for execution: {}", executionId, e);
            emitter.completeWithError(e);
            return emitter;
        }
    }
    
    /**
     * Subscribe to resource monitoring updates.
     * 
     * @param executionId ID of the test execution
     * @return SseEmitter for streaming resource updates
     */
    @GetMapping("/resources/{executionId}")
    public SseEmitter subscribeResourceUpdates(@PathVariable String executionId) {
        LOGGER.info("Client subscribing to resource updates for execution: {}", executionId);
        
        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
        
        try {
            // Register emitter with resource monitor service
            resourceMonitorService.registerClient(executionId, emitter);
            
            // Set completion callback
            emitter.onCompletion(() -> {
                LOGGER.info("Client unsubscribed from resource updates for execution: {}", executionId);
                resourceMonitorService.unregisterClient(executionId, emitter);
            });
            
            // Set timeout callback
            emitter.onTimeout(() -> {
                LOGGER.info("Resource subscription timed out for execution: {}", executionId);
                resourceMonitorService.unregisterClient(executionId, emitter);
                emitter.complete();
            });
            
            // Set error callback
            emitter.onError(e -> {
                LOGGER.error("Error in resource updates for execution: {}", executionId, e);
                resourceMonitorService.unregisterClient(executionId, emitter);
                emitter.completeWithError(e);
            });
            
            // If monitoring is active, send initial metrics
            if (resourceMonitorService.isMonitoring(executionId)) {
                resourceMonitorService.sendCurrentMetrics(executionId, emitter);
            } else {
                // If monitoring is not active, just notify
                resourceMonitorService.sendNotification(emitter, "Resource monitoring not active for this execution");
            }
            
            return emitter;
        } catch (Exception e) {
            LOGGER.error("Failed to set up resource updates for execution: {}", executionId, e);
            emitter.completeWithError(e);
            return emitter;
        }
    }
    
    /**
     * Get all test executions.
     * 
     * @return ResponseEntity with the list of executions
     */
    @GetMapping("/executions")
    public ResponseEntity<List<Map<String, Object>>> getAllExecutions() {
        LOGGER.info("Getting all test executions");
        
        try {
            List<TestExecutionRequest> executions = storageService.getAllTestExecutionRequests();
            
            List<Map<String, Object>> executionSummaries = executions.stream()
                    .map(exec -> {
                        Map<String, Object> summary = new HashMap<>();
                        summary.put("executionId", exec.getExecutionId());
                        summary.put("framework", exec.getFrameworkType());
                        summary.put("language", exec.getLanguageType());
                        summary.put("testType", exec.getTestType());
                        summary.put("status", exec.getStatus().name());
                        summary.put("startTime", CSDateUtils.formatTimestamp(exec.getStartTime()));
                        
                        if (exec.getEndTime() != null) {
                            summary.put("endTime", CSDateUtils.formatTimestamp(exec.getEndTime()));
                            summary.put("duration", CSDateUtils.calculateDuration(
                                    exec.getStartTime(), exec.getEndTime()));
                        }
                        
                        summary.put("testCount", exec.getTestList().size());
                        summary.put("passedCount", exec.getPassedCount());
                        summary.put("failedCount", exec.getFailedCount());
                        summary.put("skippedCount", exec.getSkippedCount());
                        
                        return summary;
                    })
                    .collect(Collectors.toList());
            
            return ResponseEntity.ok(executionSummaries);
        } catch (Exception e) {
            LOGGER.error("Failed to get all test executions", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get specific test execution details.
     * 
     * @param executionId ID of the test execution
     * @return ResponseEntity with the execution details
     */
    @GetMapping("/execution/{executionId}")
    public ResponseEntity<TestExecutionRequest> getExecution(@PathVariable String executionId) {
        LOGGER.info("Getting details for test execution: {}", executionId);
        
        try {
            TestExecutionRequest execution = storageService.getTestExecutionRequest(executionId);
            if (execution != null) {
                return ResponseEntity.ok(execution);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get details for test execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Configure parallel test execution.
     * 
     * @param executionId ID of the test execution
     * @param config Parallel execution configuration
     * @return ResponseEntity with the result
     */
    @PostMapping("/parallel/{executionId}")
    public ResponseEntity<Map<String, Object>> configureParallelExecution(
            @PathVariable String executionId,
            @RequestBody ParallelExecutionConfig config) {
        
        LOGGER.info("Configuring parallel execution for: {}", executionId);
        
        TestExecutionService executionService = activeExecutions.get(executionId);
        if (executionService == null) {
            LOGGER.warn("No active test execution found with ID: {}", executionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Test execution not found"));
        }
        
        try {
            // Check if parallel execution is supported
            if (!executionService.supportsParallelExecution()) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of("error", "This test execution does not support parallel execution"));
            }
            
            // Configure parallel execution
            executionService.configureParallelExecution(config);
            
            // Update the execution request
            TestExecutionRequest request = storageService.getTestExecutionRequest(executionId);
            if (request != null) {
                request.setParallelExecutionConfig(config);
                storageService.updateTestExecutionRequest(request);
            }
            
            return ResponseEntity.ok(Map.of(
                    "executionId", executionId,
                    "message", "Parallel execution configured successfully",
                    "threadCount", config.getThreadCount(),
                    "strategy", config.getDistributionStrategy()
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to configure parallel execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to configure parallel execution: " + e.getMessage()));
        }
    }
    
    /**
     * Configure distributed test execution.
     * 
     * @param executionId ID of the test execution
     * @param config Distributed execution configuration
     * @return ResponseEntity with the result
     */
    @PostMapping("/distributed/{executionId}")
    public ResponseEntity<Map<String, Object>> configureDistributedExecution(
            @PathVariable String executionId,
            @RequestBody DistributedExecutionConfig config) {
        
        LOGGER.info("Configuring distributed execution for: {}", executionId);
        
        TestExecutionService executionService = activeExecutions.get(executionId);
        if (executionService == null) {
            LOGGER.warn("No active test execution found with ID: {}", executionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Test execution not found"));
        }
        
        try {
            // Check if distributed execution is supported
            if (!executionService.supportsDistributedExecution()) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of("error", "This test execution does not support distributed execution"));
            }
            
            // Validate node configurations
            if (config.getNodes() == null || config.getNodes().isEmpty()) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of("error", "At least one execution node must be specified"));
            }
            
            // Configure distributed execution
            executionService.configureDistributedExecution(config);
            
            // Update the execution request
            TestExecutionRequest request = storageService.getTestExecutionRequest(executionId);
            if (request != null) {
                request.setDistributedExecutionConfig(config);
                storageService.updateTestExecutionRequest(request);
            }
            
            return ResponseEntity.ok(Map.of(
                    "executionId", executionId,
                    "message", "Distributed execution configured successfully",
                    "nodeCount", config.getNodes().size(),
                    "strategy", config.getDistributionStrategy()
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to configure distributed execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to configure distributed execution: " + e.getMessage()));
        }
    }
    
    /**
     * Configure execution environment.
     * 
     * @param executionId ID of the test execution
     * @param environment Execution environment configuration
     * @return ResponseEntity with the result
     */
    @PostMapping("/environment/{executionId}")
    public ResponseEntity<Map<String, Object>> configureEnvironment(
            @PathVariable String executionId,
            @RequestBody ExecutionEnvironment environment) {
        
        LOGGER.info("Configuring environment for execution: {}", executionId);
        
        TestExecutionService executionService = activeExecutions.get(executionId);
        if (executionService == null) {
            LOGGER.warn("No active test execution found with ID: {}", executionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Test execution not found"));
        }
        
        try {
            // Configure environment
            executionService.configureEnvironment(environment);
            
            // Update the execution request
            TestExecutionRequest request = storageService.getTestExecutionRequest(executionId);
            if (request != null) {
                request.setEnvironment(environment);
                storageService.updateTestExecutionRequest(request);
            }
            
            return ResponseEntity.ok(Map.of(
                    "executionId", executionId,
                    "message", "Environment configured successfully",
                    "name", environment.getName(),
                    "baseUrl", environment.getBaseUrl()
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to configure environment: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to configure environment: " + e.getMessage()));
        }
    }
    
    /**
     * Configure browser settings.
     * 
     * @param executionId ID of the test execution
     * @param browserConfig Browser configuration
     * @return ResponseEntity with the result
     */
    @PostMapping("/browser/{executionId}")
    public ResponseEntity<Map<String, Object>> configureBrowser(
            @PathVariable String executionId,
            @RequestBody BrowserConfig browserConfig) {
        
        LOGGER.info("Configuring browser for execution: {}", executionId);
        
        TestExecutionService executionService = activeExecutions.get(executionId);
        if (executionService == null) {
            LOGGER.warn("No active test execution found with ID: {}", executionId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "Test execution not found"));
        }
        
        try {
            // Configure browser
            executionService.configureBrowser(browserConfig);
            
            // Update the execution request
            TestExecutionRequest request = storageService.getTestExecutionRequest(executionId);
            if (request != null) {
                request.setBrowserConfig(browserConfig);
                storageService.updateTestExecutionRequest(request);
            }
            
            return ResponseEntity.ok(Map.of(
                    "executionId", executionId,
                    "message", "Browser configured successfully",
                    "browserType", browserConfig.getBrowserType(),
                    "headless", browserConfig.isHeadless()
            ));
        } catch (Exception e) {
            LOGGER.error("Failed to configure browser: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to configure browser: " + e.getMessage()));
        }
    }
    
    /**
     * Get active test executions.
     * 
     * @return ResponseEntity with the list of active executions
     */
    @GetMapping("/active")
    public ResponseEntity<List<Map<String, Object>>> getActiveExecutions() {
        LOGGER.info("Getting active test executions");
        
        try {
            List<Map<String, Object>> activeExecutionsInfo = activeExecutions.entrySet().stream()
                    .map(entry -> {
                        String id = entry.getKey();
                        TestExecutionService service = entry.getValue();
                        TestExecutionRequest request = service.getExecutionRequest();
                        
                        Map<String, Object> executionInfo = new HashMap<>();
                        executionInfo.put("executionId", id);
                        executionInfo.put("framework", request.getFrameworkType());
                        executionInfo.put("language", request.getLanguageType());
                        executionInfo.put("testType", request.getTestType());
                        executionInfo.put("status", service.getCurrentStatus().name());
                        executionInfo.put("progress", service.getExecutionProgress());
                        executionInfo.put("currentTest", service.getCurrentTestName());
                        executionInfo.put("startTime", CSDateUtils.formatTimestamp(request.getStartTime()));
                        executionInfo.put("testCount", request.getTestList().size());
                        
                        // Add current results
                        List<TestExecutionResult> results = service.getCurrentResults();
                        if (results != null) {
                            executionInfo.put("completedCount", results.size());
                            executionInfo.put("passedCount", results.stream()
                                    .filter(r -> r.getStatus() == TestStatus.PASSED)
                                    .count());
                            executionInfo.put("failedCount", results.stream()
                                    .filter(r -> r.getStatus() == TestStatus.FAILED)
                                    .count());
                            executionInfo.put("skippedCount", results.stream()
                                    .filter(r -> r.getStatus() == TestStatus.SKIPPED)
                                    .count());
                        }
                        
                        return executionInfo;
                    })
                    .collect(Collectors.toList());
            
            return ResponseEntity.ok(activeExecutionsInfo);
        } catch (Exception e) {
            LOGGER.error("Failed to get active test executions", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Clean up resources when the application is shutting down.
     */
    @PreDestroy
    public void cleanup() {
        LOGGER.info("Cleaning up test execution resources...");
        
        for (Map.Entry<String, TestExecutionService> entry : activeExecutions.entrySet()) {
            try {
                String executionId = entry.getKey();
                TestExecutionService executionService = entry.getValue();
                
                LOGGER.info("Stopping test execution: {}", executionId);
                
                // Stop the execution
                executionService.stopExecution();
                
                // Update the execution request
                TestExecutionRequest request = executionService.getExecutionRequest();
                request.setStatus(TestStatus.INTERRUPTED);
                request.setEndTime(CSDateUtils.getCurrentTimestamp());
                
                // Save results if any
                List<TestExecutionResult> results = executionService.getCurrentResults();
                if (results != null && !results.isEmpty()) {
                    storageService.saveTestExecutionResults(executionId, results);
                }
                
                // Save updated request
                storageService.updateTestExecutionRequest(request);
                
                // Notify subscribers if possible
                try {
                    liveExecutionService.broadcastExecutionStatus(executionId, TestStatus.INTERRUPTED);
                } catch (Exception e) {
                    LOGGER.warn("Failed to broadcast execution status during cleanup", e);
                }
                
                // Stop resource monitoring if active
                try {
                    resourceMonitorService.stopMonitoring(executionId);
                } catch (Exception e) {
                    LOGGER.warn("Failed to stop resource monitoring during cleanup", e);
                }
            } catch (Exception e) {
                LOGGER.error("Error during cleanup of test execution: {}", entry.getKey(), e);
            }
        }
        
        // Shutdown executor service
        executorService.shutdownNow();
        
        // Clear the map
        activeExecutions.clear();
        
        LOGGER.info("Test execution resources cleanup completed");
    }
}


ProjectController.java
-------------------------------------------------------

  package com.cstestforge.controller;

import com.cstestforge.model.project.Project;
import com.cstestforge.model.project.TestSuite;
import com.cstestforge.model.project.TestCase;
import com.cstestforge.model.project.ProjectConfig;
import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;
import com.cstestforge.service.project.ProjectService;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSDateUtils;
import com.cstestforge.framework.core.utils.CSFileUtils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.stream.Collectors;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Files;

/**
 * Controller for project management operations.
 * Handles project creation, updating, and retrieval.
 */
@RestController
@RequestMapping("/api/project")
public class ProjectController {

    private static final CSLogger LOGGER = new CSLogger(ProjectController.class);
    
    private final ProjectService projectService;
    
    @Autowired
    public ProjectController(ProjectService projectService) {
        this.projectService = projectService;
    }
    
    /**
     * Create a new project.
     * 
     * @param project The project to create
     * @return ResponseEntity with the created project
     */
    @PostMapping
    public ResponseEntity<Project> createProject(@RequestBody Project project) {
        LOGGER.info("Creating new project: {}", project.getName());
        
        try {
            // Validate required fields
            if (project.getName() == null || project.getName().trim().isEmpty()) {
                return ResponseEntity.badRequest().build();
            }
            
            // Set creation time if not set
            if (project.getCreationTime() == null) {
                project.setCreationTime(CSDateUtils.getCurrentTimestamp());
            }
            
            // Set last modified time
            project.setLastModifiedTime(CSDateUtils.getCurrentTimestamp());
            
            // Create project
            Project createdProject = projectService.createProject(project);
            
            LOGGER.info("Project created with ID: {}", createdProject.getProjectId());
            return ResponseEntity.status(HttpStatus.CREATED).body(createdProject);
        } catch (Exception e) {
            LOGGER.error("Failed to create project", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get all projects.
     * 
     * @return ResponseEntity with the list of projects
     */
    @GetMapping
    public ResponseEntity<List<Project>> getAllProjects() {
        LOGGER.info("Getting all projects");
        
        try {
            List<Project> projects = projectService.getAllProjects();
            return ResponseEntity.ok(projects);
        } catch (Exception e) {
            LOGGER.error("Failed to get all projects", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get a specific project by ID.
     * 
     * @param projectId ID of the project to retrieve
     * @return ResponseEntity with the project
     */
    @GetMapping("/{projectId}")
    public ResponseEntity<Project> getProjectById(@PathVariable String projectId) {
        LOGGER.info("Getting project by ID: {}", projectId);
        
        try {
            Project project = projectService.getProjectById(projectId);
            if (project != null) {
                return ResponseEntity.ok(project);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get project by ID: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Update an existing project.
     * 
     * @param projectId ID of the project to update
     * @param project Updated project data
     * @return ResponseEntity with the updated project
     */
    @PutMapping("/{projectId}")
    public ResponseEntity<Project> updateProject(
            @PathVariable String projectId,
            @RequestBody Project project) {
        
        LOGGER.info("Updating project: {}", projectId);
        
        try {
            // Ensure the project ID in the path matches the project ID in the body
            if (!projectId.equals(project.getProjectId())) {
                return ResponseEntity.badRequest().build();
            }
            
            // Update last modified time
            project.setLastModifiedTime(CSDateUtils.getCurrentTimestamp());
            
            // Update project
            Project updatedProject = projectService.updateProject(project);
            if (updatedProject != null) {
                LOGGER.info("Project updated: {}", projectId);
                return ResponseEntity.ok(updatedProject);
            } else {
                LOGGER.warn("Project not found: {}", projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to update project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Delete a project.
     * 
     * @param projectId ID of the project to delete
     * @return ResponseEntity with the result
     */
    @DeleteMapping("/{projectId}")
    public ResponseEntity<Map<String, Object>> deleteProject(@PathVariable String projectId) {
        LOGGER.info("Deleting project: {}", projectId);
        
        try {
            boolean deleted = projectService.deleteProject(projectId);
            if (deleted) {
                LOGGER.info("Project deleted: {}", projectId);
                return ResponseEntity.ok(Map.of(
                        "projectId", projectId,
                        "deleted", true,
                        "message", "Project deleted successfully"
                ));
            } else {
                LOGGER.warn("Project not found: {}", projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to delete project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "projectId", projectId,
                            "deleted", false,
                            "error", "Failed to delete project: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Create a new test suite in a project.
     * 
     * @param projectId ID of the project
     * @param testSuite The test suite to create
     * @return ResponseEntity with the created test suite
     */
    @PostMapping("/{projectId}/suite")
    public ResponseEntity<TestSuite> createTestSuite(
            @PathVariable String projectId,
            @RequestBody TestSuite testSuite) {
        
        LOGGER.info("Creating test suite in project {}: {}", projectId, testSuite.getName());
        
        try {
            // Validate required fields
            if (testSuite.getName() == null || testSuite.getName().trim().isEmpty()) {
                return ResponseEntity.badRequest().build();
            }
            
            // Set creation time if not set
            if (testSuite.getCreationTime() == null) {
                testSuite.setCreationTime(CSDateUtils.getCurrentTimestamp());
            }
            
            // Set last modified time
            testSuite.setLastModifiedTime(CSDateUtils.getCurrentTimestamp());
            
            // Create test suite
            TestSuite createdSuite = projectService.createTestSuite(projectId, testSuite);
            if (createdSuite != null) {
                LOGGER.info("Test suite created with ID: {}", createdSuite.getSuiteId());
                return ResponseEntity.status(HttpStatus.CREATED).body(createdSuite);
            } else {
                LOGGER.warn("Project not found: {}", projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to create test suite in project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get all test suites in a project.
     * 
     * @param projectId ID of the project
     * @return ResponseEntity with the list of test suites
     */
    @GetMapping("/{projectId}/suite")
    public ResponseEntity<List<TestSuite>> getTestSuites(@PathVariable String projectId) {
        LOGGER.info("Getting all test suites in project: {}", projectId);
        
        try {
            List<TestSuite> suites = projectService.getTestSuites(projectId);
            if (suites != null) {
                return ResponseEntity.ok(suites);
            } else {
                LOGGER.warn("Project not found: {}", projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get test suites for project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get a specific test suite.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @return ResponseEntity with the test suite
     */
    @GetMapping("/{projectId}/suite/{suiteId}")
    public ResponseEntity<TestSuite> getTestSuite(
            @PathVariable String projectId,
            @PathVariable String suiteId) {
        
        LOGGER.info("Getting test suite {} in project {}", suiteId, projectId);
        
        try {
            TestSuite suite = projectService.getTestSuite(projectId, suiteId);
            if (suite != null) {
                return ResponseEntity.ok(suite);
            } else {
                LOGGER.warn("Test suite not found: {} in project {}", suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get test suite {} in project {}", suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Update a test suite.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @param testSuite Updated test suite data
     * @return ResponseEntity with the updated test suite
     */
    @PutMapping("/{projectId}/suite/{suiteId}")
    public ResponseEntity<TestSuite> updateTestSuite(
            @PathVariable String projectId,
            @PathVariable String suiteId,
            @RequestBody TestSuite testSuite) {
        
        LOGGER.info("Updating test suite {} in project {}", suiteId, projectId);
        
        try {
            // Ensure the suite ID in the path matches the suite ID in the body
            if (!suiteId.equals(testSuite.getSuiteId())) {
                return ResponseEntity.badRequest().build();
            }
            
            // Update last modified time
            testSuite.setLastModifiedTime(CSDateUtils.getCurrentTimestamp());
            
            // Update test suite
            TestSuite updatedSuite = projectService.updateTestSuite(projectId, testSuite);
            if (updatedSuite != null) {
                LOGGER.info("Test suite updated: {} in project {}", suiteId, projectId);
                return ResponseEntity.ok(updatedSuite);
            } else {
                LOGGER.warn("Test suite not found: {} in project {}", suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to update test suite {} in project {}", suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Delete a test suite.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @return ResponseEntity with the result
     */
    @DeleteMapping("/{projectId}/suite/{suiteId}")
    public ResponseEntity<Map<String, Object>> deleteTestSuite(
            @PathVariable String projectId,
            @PathVariable String suiteId) {
        
        LOGGER.info("Deleting test suite {} in project {}", suiteId, projectId);
        
        try {
            boolean deleted = projectService.deleteTestSuite(projectId, suiteId);
            if (deleted) {
                LOGGER.info("Test suite deleted: {} in project {}", suiteId, projectId);
                return ResponseEntity.ok(Map.of(
                        "projectId", projectId,
                        "suiteId", suiteId,
                        "deleted", true,
                        "message", "Test suite deleted successfully"
                ));
            } else {
                LOGGER.warn("Test suite not found: {} in project {}", suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to delete test suite {} in project {}", suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "projectId", projectId,
                            "suiteId", suiteId,
                            "deleted", false,
                            "error", "Failed to delete test suite: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Create a new test case in a test suite.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @param testCase The test case to create
     * @return ResponseEntity with the created test case
     */
    @PostMapping("/{projectId}/suite/{suiteId}/case")
    public ResponseEntity<TestCase> createTestCase(
            @PathVariable String projectId,
            @PathVariable String suiteId,
            @RequestBody TestCase testCase) {
        
        LOGGER.info("Creating test case in suite {} in project {}: {}", 
                suiteId, projectId, testCase.getName());
        
        try {
            // Validate required fields
            if (testCase.getName() == null || testCase.getName().trim().isEmpty()) {
                return ResponseEntity.badRequest().build();
            }
            
            // Set creation time if not set
            if (testCase.getCreationTime() == null) {
                testCase.setCreationTime(CSDateUtils.getCurrentTimestamp());
            }
            
            // Set last modified time
            testCase.setLastModifiedTime(CSDateUtils.getCurrentTimestamp());
            
            // Create test case
            TestCase createdCase = projectService.createTestCase(projectId, suiteId, testCase);
            if (createdCase != null) {
                LOGGER.info("Test case created with ID: {}", createdCase.getCaseId());
                return ResponseEntity.status(HttpStatus.CREATED).body(createdCase);
            } else {
                LOGGER.warn("Test suite not found: {} in project {}", suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to create test case in suite {} in project {}", 
                    suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get all test cases in a test suite.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @return ResponseEntity with the list of test cases
     */
    @GetMapping("/{projectId}/suite/{suiteId}/case")
    public ResponseEntity<List<TestCase>> getTestCases(
            @PathVariable String projectId,
            @PathVariable String suiteId) {
        
        LOGGER.info("Getting all test cases in suite {} in project {}", suiteId, projectId);
        
        try {
            List<TestCase> cases = projectService.getTestCases(projectId, suiteId);
            if (cases != null) {
                return ResponseEntity.ok(cases);
            } else {
                LOGGER.warn("Test suite not found: {} in project {}", suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get test cases for suite {} in project {}", 
                    suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get a specific test case.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @param caseId ID of the test case
     * @return ResponseEntity with the test case
     */
    @GetMapping("/{projectId}/suite/{suiteId}/case/{caseId}")
    public ResponseEntity<TestCase> getTestCase(
            @PathVariable String projectId,
            @PathVariable String suiteId,
            @PathVariable String caseId) {
        
        LOGGER.info("Getting test case {} in suite {} in project {}", 
                caseId, suiteId, projectId);
        
        try {
            TestCase testCase = projectService.getTestCase(projectId, suiteId, caseId);
            if (testCase != null) {
                return ResponseEntity.ok(testCase);
            } else {
                LOGGER.warn("Test case not found: {} in suite {} in project {}", 
                        caseId, suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get test case {} in suite {} in project {}", 
                    caseId, suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Update a test case.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @param caseId ID of the test case
     * @param testCase Updated test case data
     * @return ResponseEntity with the updated test case
     */
    @PutMapping("/{projectId}/suite/{suiteId}/case/{caseId}")
    public ResponseEntity<TestCase> updateTestCase(
            @PathVariable String projectId,
            @PathVariable String suiteId,
            @PathVariable String caseId,
            @RequestBody TestCase testCase) {
        
        LOGGER.info("Updating test case {} in suite {} in project {}", 
                caseId, suiteId, projectId);
        
        try {
            // Ensure the case ID in the path matches the case ID in the body
            if (!caseId.equals(testCase.getCaseId())) {
                return ResponseEntity.badRequest().build();
            }
            
            // Update last modified time
            testCase.setLastModifiedTime(CSDateUtils.getCurrentTimestamp());
            
            // Update test case
            TestCase updatedCase = projectService.updateTestCase(projectId, suiteId, testCase);
            if (updatedCase != null) {
                LOGGER.info("Test case updated: {} in suite {} in project {}", 
                        caseId, suiteId, projectId);
                return ResponseEntity.ok(updatedCase);
            } else {
                LOGGER.warn("Test case not found: {} in suite {} in project {}", 
                        caseId, suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to update test case {} in suite {} in project {}", 
                    caseId, suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Delete a test case.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @param caseId ID of the test case
     * @return ResponseEntity with the result
     */
    @DeleteMapping("/{projectId}/suite/{suiteId}/case/{caseId}")
    public ResponseEntity<Map<String, Object>> deleteTestCase(
            @PathVariable String projectId,
            @PathVariable String suiteId,
            @PathVariable String caseId) {
        
        LOGGER.info("Deleting test case {} in suite {} in project {}", 
                caseId, suiteId, projectId);
        
        try {
            boolean deleted = projectService.deleteTestCase(projectId, suiteId, caseId);
            if (deleted) {
                LOGGER.info("Test case deleted: {} in suite {} in project {}", 
                        caseId, suiteId, projectId);
                return ResponseEntity.ok(Map.of(
                        "projectId", projectId,
                        "suiteId", suiteId,
                        "caseId", caseId,
                        "deleted", true,
                        "message", "Test case deleted successfully"
                ));
            } else {
                LOGGER.warn("Test case not found: {} in suite {} in project {}", 
                        caseId, suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to delete test case {} in suite {} in project {}", 
                    caseId, suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "projectId", projectId,
                            "suiteId", suiteId,
                            "caseId", caseId,
                            "deleted", false,
                            "error", "Failed to delete test case: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get project configuration.
     * 
     * @param projectId ID of the project
     * @return ResponseEntity with the project configuration
     */
    @GetMapping("/{projectId}/config")
    public ResponseEntity<ProjectConfig> getProjectConfig(@PathVariable String projectId) {
        LOGGER.info("Getting configuration for project: {}", projectId);
        
        try {
            ProjectConfig config = projectService.getProjectConfig(projectId);
            if (config != null) {
                return ResponseEntity.ok(config);
            } else {
                LOGGER.warn("Project not found: {}", projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get configuration for project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Update project configuration.
     * 
     * @param projectId ID of the project
     * @param config Updated project configuration
     * @return ResponseEntity with the updated configuration
     */
    @PutMapping("/{projectId}/config")
    public ResponseEntity<ProjectConfig> updateProjectConfig(
            @PathVariable String projectId,
            @RequestBody ProjectConfig config) {
        
        LOGGER.info("Updating configuration for project: {}", projectId);
        
        try {
            // Ensure the project ID in the path matches the project ID in the config
            if (!projectId.equals(config.getProjectId())) {
                return ResponseEntity.badRequest().build();
            }
            
            // Update last modified time
            config.setLastModifiedTime(CSDateUtils.getCurrentTimestamp());
            
            // Update project configuration
            ProjectConfig updatedConfig = projectService.updateProjectConfig(projectId, config);
            if (updatedConfig != null) {
                LOGGER.info("Configuration updated for project: {}", projectId);
                return ResponseEntity.ok(updatedConfig);
            } else {
                LOGGER.warn("Project not found: {}", projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to update configuration for project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Import test cases from a file.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @param file File containing test cases
     * @param format Format of the file (CSV, Excel, JSON)
     * @return ResponseEntity with the imported test cases
     */
    @PostMapping("/{projectId}/suite/{suiteId}/import")
    public ResponseEntity<Map<String, Object>> importTestCases(
            @PathVariable String projectId,
            @PathVariable String suiteId,
            @RequestParam("file") MultipartFile file,
            @RequestParam("format") String format) {
        
        LOGGER.info("Importing test cases to suite {} in project {} from {} file", 
                suiteId, projectId, format);
        
        try {
            if (file.isEmpty()) {
                return ResponseEntity.badRequest()
                        .body(Map.of("error", "File is empty"));
            }
            
            // Validate format
            if (!isValidImportFormat(format)) {
                return ResponseEntity.badRequest()
                        .body(Map.of("error", "Invalid format. Supported formats: CSV, Excel, JSON"));
            }
            
            // Create temporary file
            Path tempFile = Files.createTempFile("import-", "." + getFileExtension(format));
            file.transferTo(tempFile.toFile());
            
            // Import test cases
            List<TestCase> importedCases = projectService.importTestCases(
                    projectId, suiteId, tempFile.toString(), format);
            
            // Delete temporary file
            Files.delete(tempFile);
            
            if (importedCases != null) {
                LOGGER.info("{} test cases imported to suite {} in project {}", 
                        importedCases.size(), suiteId, projectId);
                
                return ResponseEntity.ok(Map.of(
                        "projectId", projectId,
                        "suiteId", suiteId,
                        "importedCount", importedCases.size(),
                        "message", "Test cases imported successfully",
                        "testCases", importedCases
                ));
            } else {
                LOGGER.warn("Test suite not found: {} in project {}", suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to import test cases to suite {} in project {}", 
                    suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "projectId", projectId,
                            "suiteId", suiteId,
                            "error", "Failed to import test cases: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Export test cases to a file.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @param format Format of the output file (CSV, Excel, JSON)
     * @return ResponseEntity with the exported file
     */
    @GetMapping("/{projectId}/suite/{suiteId}/export")
    public ResponseEntity<byte[]> exportTestCases(
            @PathVariable String projectId,
            @PathVariable String suiteId,
            @RequestParam("format") String format) {
        
        LOGGER.info("Exporting test cases from suite {} in project {} to {} format", 
                suiteId, projectId, format);
        
        try {
            // Validate format
            if (!isValidExportFormat(format)) {
                return ResponseEntity.badRequest().build();
            }
            
            // Export test cases
            byte[] exportedData = projectService.exportTestCases(projectId, suiteId, format);
            
            if (exportedData != null) {
                LOGGER.info("Test cases exported from suite {} in project {} to {} format", 
                        suiteId, projectId, format);
                
                // Prepare response headers
                return ResponseEntity.ok()
                        .header("Content-Disposition", "attachment; filename=test_cases." + getFileExtension(format))
                        .header("Content-Type", getContentType(format))
                        .body(exportedData);
            } else {
                LOGGER.warn("Test suite not found: {} in project {}", suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to export test cases from suite {} in project {}", 
                    suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Duplicate a test case.
     * 
     * @param projectId ID of the project
     * @param suiteId ID of the test suite
     * @param caseId ID of the test case to duplicate
     * @param newName Name for the duplicated test case
     * @return ResponseEntity with the duplicated test case
     */
    @PostMapping("/{projectId}/suite/{suiteId}/case/{caseId}/duplicate")
    public ResponseEntity<TestCase> duplicateTestCase(
            @PathVariable String projectId,
            @PathVariable String suiteId,
            @PathVariable String caseId,
            @RequestParam("newName") String newName) {
        
        LOGGER.info("Duplicating test case {} in suite {} in project {} with name {}", 
                caseId, suiteId, projectId, newName);
        
        try {
            // Validate new name
            if (newName == null || newName.trim().isEmpty()) {
                return ResponseEntity.badRequest()
                        .body(null);
            }
            
            // Duplicate test case
            TestCase duplicatedCase = projectService.duplicateTestCase(
                    projectId, suiteId, caseId, newName);
            
            if (duplicatedCase != null) {
                LOGGER.info("Test case duplicated: {} -> {} in suite {} in project {}", 
                        caseId, duplicatedCase.getCaseId(), suiteId, projectId);
                return ResponseEntity.status(HttpStatus.CREATED).body(duplicatedCase);
            } else {
                LOGGER.warn("Test case not found: {} in suite {} in project {}", 
                        caseId, suiteId, projectId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to duplicate test case {} in suite {} in project {}", 
                    caseId, suiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Move a test case to another suite.
     * 
     * @param projectId ID of the project
     * @param sourceSuiteId ID of the source test suite
     * @param caseId ID of the test case to move
     * @param targetSuiteId ID of the target test suite
     * @return ResponseEntity with the result
     */
    @PostMapping("/{projectId}/suite/{sourceSuiteId}/case/{caseId}/move")
    public ResponseEntity<Map<String, Object>> moveTestCase(
            @PathVariable String projectId,
            @PathVariable String sourceSuiteId,
            @PathVariable String caseId,
            @RequestParam("targetSuiteId") String targetSuiteId) {
        
        LOGGER.info("Moving test case {} from suite {} to suite {} in project {}", 
                caseId, sourceSuiteId, targetSuiteId, projectId);
        
        try {
            // Validate that source and target are different
            if (sourceSuiteId.equals(targetSuiteId)) {
                return ResponseEntity.badRequest()
                        .body(Map.of("error", "Source and target suites are the same"));
            }
            
            // Move test case
            boolean moved = projectService.moveTestCase(
                    projectId, sourceSuiteId, caseId, targetSuiteId);
            
            if (moved) {
                LOGGER.info("Test case moved: {} from suite {} to suite {} in project {}", 
                        caseId, sourceSuiteId, targetSuiteId, projectId);
                return ResponseEntity.ok(Map.of(
                        "projectId", projectId,
                        "sourceSuiteId", sourceSuiteId,
                        "targetSuiteId", targetSuiteId,
                        "caseId", caseId,
                        "moved", true,
                        "message", "Test case moved successfully"
                ));
            } else {
                LOGGER.warn("Failed to move test case: source or target not found");
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to move test case {} from suite {} to suite {} in project {}", 
                    caseId, sourceSuiteId, targetSuiteId, projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "projectId", projectId,
                            "sourceSuiteId", sourceSuiteId,
                            "targetSuiteId", targetSuiteId,
                            "caseId", caseId,
                            "moved", false,
                            "error", "Failed to move test case: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get framework types supported by the project.
     * 
     * @return ResponseEntity with the list of framework types
     */
    @GetMapping("/frameworks")
    public ResponseEntity<List<Map<String, Object>>> getFrameworkTypes() {
        LOGGER.info("Getting supported framework types");
        
        try {
            List<Map<String, Object>> frameworkInfo = new ArrayList<>();
            
            for (FrameworkType type : FrameworkType.values()) {
                Map<String, Object> info = new HashMap<>();
                info.put("id", type.name());
                info.put("name", getFrameworkDisplayName(type));
                info.put("description", getFrameworkDescription(type));
                info.put("supportedLanguages", getSupportedLanguagesForFramework(type));
                
                frameworkInfo.add(info);
            }
            
            return ResponseEntity.ok(frameworkInfo);
        } catch (Exception e) {
            LOGGER.error("Failed to get framework types", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get language types supported by the project.
     * 
     * @return ResponseEntity with the list of language types
     */
    @GetMapping("/languages")
    public ResponseEntity<List<Map<String, Object>>> getLanguageTypes() {
        LOGGER.info("Getting supported language types");
        
        try {
            List<Map<String, Object>> languageInfo = new ArrayList<>();
            
            for (LanguageType type : LanguageType.values()) {
                Map<String, Object> info = new HashMap<>();
                info.put("id", type.name());
                info.put("name", getLanguageDisplayName(type));
                info.put("description", getLanguageDescription(type));
                info.put("supportedFrameworks", getSupportedFrameworksForLanguage(type));
                
                languageInfo.add(info);
            }
            
            return ResponseEntity.ok(languageInfo);
        } catch (Exception e) {
            LOGGER.error("Failed to get language types", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get test types supported by the project.
     * 
     * @return ResponseEntity with the list of test types
     */
    @GetMapping("/testtypes")
    public ResponseEntity<List<Map<String, Object>>> getTestTypes() {
        LOGGER.info("Getting supported test types");
        
        try {
            List<Map<String, Object>> testTypeInfo = new ArrayList<>();
            
            for (TestType type : TestType.values()) {
                Map<String, Object> info = new HashMap<>();
                info.put("id", type.name());
                info.put("name", getTestTypeDisplayName(type));
                info.put("description", getTestTypeDescription(type));
                
                testTypeInfo.add(info);
            }
            
            return ResponseEntity.ok(testTypeInfo);
        } catch (Exception e) {
            LOGGER.error("Failed to get test types", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Create a default project with sample test suites and cases.
     * 
     * @param frameworkType Framework type for the project
     * @param languageType Language type for the project
     * @param testType Test type for the project
     * @return ResponseEntity with the created project
     */
    @PostMapping("/template")
    public ResponseEntity<Project> createProjectFromTemplate(
            @RequestParam("frameworkType") FrameworkType frameworkType,
            @RequestParam("languageType") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Creating project from template with framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            // Create project from template
            Project project = projectService.createProjectFromTemplate(frameworkType, languageType, testType);
            
            if (project != null) {
                LOGGER.info("Project created from template with ID: {}", project.getProjectId());
                return ResponseEntity.status(HttpStatus.CREATED).body(project);
            } else {
                LOGGER.warn("Failed to create project from template");
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to create project from template", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Search for projects.
     * 
     * @param query Search query
     * @param frameworkType Optional framework type filter
     * @param languageType Optional language type filter
     * @param testType Optional test type filter
     * @return ResponseEntity with the search results
     */
    @GetMapping("/search")
    public ResponseEntity<List<Project>> searchProjects(
            @RequestParam("query") String query,
            @RequestParam(value = "framework", required = false) FrameworkType frameworkType,
            @RequestParam(value = "language", required = false) LanguageType languageType,
            @RequestParam(value = "testType", required = false) TestType testType) {
        
        LOGGER.info("Searching for projects with query: {}, framework: {}, language: {}, test type: {}", 
                query, frameworkType, languageType, testType);
        
        try {
            List<Project> searchResults = projectService.searchProjects(query, frameworkType, languageType, testType);
            
            LOGGER.info("Found {} projects matching search criteria", searchResults.size());
            return ResponseEntity.ok(searchResults);
        } catch (Exception e) {
            LOGGER.error("Failed to search for projects", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Check if a given import format is valid.
     * 
     * @param format Format to validate
     * @return True if the format is valid, false otherwise
     */
    private boolean isValidImportFormat(String format) {
        if (format == null) {
            return false;
        }
        
        String normalizedFormat = format.trim().toLowerCase();
        return normalizedFormat.equals("csv") || 
               normalizedFormat.equals("excel") || 
               normalizedFormat.equals("json");
    }
    
    /**
     * Check if a given export format is valid.
     * 
     * @param format Format to validate
     * @return True if the format is valid, false otherwise
     */
    private boolean isValidExportFormat(String format) {
        if (format == null) {
            return false;
        }
        
        String normalizedFormat = format.trim().toLowerCase();
        return normalizedFormat.equals("csv") || 
               normalizedFormat.equals("excel") || 
               normalizedFormat.equals("json");
    }
    
    /**
     * Get file extension for a given format.
     * 
     * @param format Format
     * @return File extension
     */
    private String getFileExtension(String format) {
        String normalizedFormat = format.trim().toLowerCase();
        switch (normalizedFormat) {
            case "csv":
                return "csv";
            case "excel":
                return "xlsx";
            case "json":
                return "json";
            default:
                return "txt";
        }
    }
    
    /**
     * Get content type for a given format.
     * 
     * @param format Format
     * @return Content type
     */
    private String getContentType(String format) {
        String normalizedFormat = format.trim().toLowerCase();
        switch (normalizedFormat) {
            case "csv":
                return "text/csv";
            case "excel":
                return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            case "json":
                return "application/json";
            default:
                return "text/plain";
        }
    }
    
    /**
     * Get display name for a framework type.
     * 
     * @param frameworkType Framework type
     * @return Display name
     */
    private String getFrameworkDisplayName(FrameworkType frameworkType) {
        switch (frameworkType) {
            case SELENIUM:
                return "Selenium";
            case PLAYWRIGHT:
                return "Playwright";
            default:
                return frameworkType.name();
        }
    }
    
    /**
     * Get description for a framework type.
     * 
     * @param frameworkType Framework type
     * @return Description
     */
    private String getFrameworkDescription(FrameworkType frameworkType) {
        switch (frameworkType) {
            case SELENIUM:
                return "Selenium WebDriver automation framework for browser testing";
            case PLAYWRIGHT:
                return "Playwright automation framework for modern browser testing";
            default:
                return "Unknown framework";
        }
    }
    
    /**
     * Get supported languages for a framework type.
     * 
     * @param frameworkType Framework type
     * @return List of supported language types
     */
    private List<LanguageType> getSupportedLanguagesForFramework(FrameworkType frameworkType) {
        List<LanguageType> supportedLanguages = new ArrayList<>();
        
        switch (frameworkType) {
            case SELENIUM:
            case PLAYWRIGHT:
                // Both Selenium and Playwright support Java and TypeScript
                supportedLanguages.add(LanguageType.JAVA);
                supportedLanguages.add(LanguageType.TYPESCRIPT);
                break;
        }
        
        return supportedLanguages;
    }
    
    /**
     * Get display name for a language type.
     * 
     * @param languageType Language type
     * @return Display name
     */
    private String getLanguageDisplayName(LanguageType languageType) {
        switch (languageType) {
            case JAVA:
                return "Java";
            case TYPESCRIPT:
                return "TypeScript";
            default:
                return languageType.name();
        }
    }
    
    /**
     * Get description for a language type.
     * 
     * @param languageType Language type
     * @return Description
     */
    private String getLanguageDescription(LanguageType languageType) {
        switch (languageType) {
            case JAVA:
                return "Java programming language with TestNG and Cucumber support";
            case TYPESCRIPT:
                return "TypeScript programming language with Mocha/Jest and Cucumber support";
            default:
                return "Unknown language";
        }
    }
    
    /**
     * Get supported frameworks for a language type.
     * 
     * @param languageType Language type
     * @return List of supported framework types
     */
    private List<FrameworkType> getSupportedFrameworksForLanguage(LanguageType languageType) {
        List<FrameworkType> supportedFrameworks = new ArrayList<>();
        
        switch (languageType) {
            case JAVA:
            case TYPESCRIPT:
                // Both Java and TypeScript support Selenium and Playwright
                supportedFrameworks.add(FrameworkType.SELENIUM);
                supportedFrameworks.add(FrameworkType.PLAYWRIGHT);
                break;
        }
        
        return supportedFrameworks;
    }
    
    /**
     * Get display name for a test type.
     * 
     * @param testType Test type
     * @return Display name
     */
    private String getTestTypeDisplayName(TestType testType) {
        switch (testType) {
            case TESTNG:
                return "TestNG";
            case BDD:
                return "BDD";
            default:
                return testType.name();
        }
    }
    
    /**
     * Get description for a test type.
     * 
     * @param testType Test type
     * @return Description
     */
    private String getTestTypeDescription(TestType testType) {
        switch (testType) {
            case TESTNG:
                return "Traditional TestNG-based testing approach";
            case BDD:
                return "Behavior-Driven Development with Cucumber";
            default:
                return "Unknown test type";
        }
    }
}


ReportController.java
---------------------------------------------

  package com.cstestforge.controller;

import com.cstestforge.model.report.TestReport;
import com.cstestforge.model.report.TestResult;
import com.cstestforge.model.report.TestStep;
import com.cstestforge.model.report.TestScreenshot;
import com.cstestforge.model.report.ReportConfig;
import com.cstestforge.model.report.ReportFormat;
import com.cstestforge.model.report.MetricType;
import com.cstestforge.model.report.ChartType;
import com.cstestforge.model.report.TimeRange;
import com.cstestforge.service.report.ReportService;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSDateUtils;
import com.cstestforge.framework.core.utils.CSFileUtils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.stream.Collectors;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.UUID;

/**
 * Controller for report generation and management.
 * This controller provides endpoints for creating, retrieving, and exporting test reports.
 */
@RestController
@RequestMapping("/api/report")
public class ReportController {

    private static final CSLogger LOGGER = new CSLogger(ReportController.class);
    
    private final ReportService reportService;
    
    @Autowired
    public ReportController(ReportService reportService) {
        this.reportService = reportService;
    }
    
    /**
     * Get all test reports.
     * 
     * @return ResponseEntity with the list of reports
     */
    @GetMapping
    public ResponseEntity<List<TestReport>> getAllReports() {
        LOGGER.info("Getting all test reports");
        
        try {
            List<TestReport> reports = reportService.getAllReports();
            return ResponseEntity.ok(reports);
        } catch (Exception e) {
            LOGGER.error("Failed to get all test reports", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get a specific test report by ID.
     * 
     * @param reportId ID of the report to retrieve
     * @return ResponseEntity with the report
     */
    @GetMapping("/{reportId}")
    public ResponseEntity<TestReport> getReportById(@PathVariable String reportId) {
        LOGGER.info("Getting test report by ID: {}", reportId);
        
        try {
            TestReport report = reportService.getReportById(reportId);
            if (report != null) {
                return ResponseEntity.ok(report);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get test report by ID: {}", reportId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Generate a test report from a test execution.
     * 
     * @param executionId ID of the test execution
     * @param config Report configuration
     * @return ResponseEntity with the generated report
     */
    @PostMapping("/generate/execution/{executionId}")
    public ResponseEntity<TestReport> generateReportFromExecution(
            @PathVariable String executionId,
            @RequestBody(required = false) ReportConfig config) {
        
        LOGGER.info("Generating report for test execution: {}", executionId);
        
        try {
            // If config is not provided, use default configuration
            if (config == null) {
                config = new ReportConfig();
                config.setTitle("Test Execution Report - " + executionId);
                config.setIncludeScreenshots(true);
                config.setIncludeLogs(true);
                config.setIncludeCharts(true);
                config.setIncludeMetrics(true);
            }
            
            // Generate report
            TestReport report = reportService.generateReportFromExecution(executionId, config);
            
            if (report != null) {
                LOGGER.info("Report generated with ID: {}", report.getReportId());
                return ResponseEntity.status(HttpStatus.CREATED).body(report);
            } else {
                LOGGER.warn("Failed to generate report for execution: {}", executionId);
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(null);
            }
        } catch (Exception e) {
            LOGGER.error("Failed to generate report for execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Generate a test report from a project.
     * 
     * @param projectId ID of the project
     * @param config Report configuration
     * @return ResponseEntity with the generated report
     */
    @PostMapping("/generate/project/{projectId}")
    public ResponseEntity<TestReport> generateReportFromProject(
            @PathVariable String projectId,
            @RequestBody(required = false) ReportConfig config) {
        
        LOGGER.info("Generating report for project: {}", projectId);
        
        try {
            // If config is not provided, use default configuration
            if (config == null) {
                config = new ReportConfig();
                config.setTitle("Project Report - " + projectId);
                config.setIncludeScreenshots(true);
                config.setIncludeLogs(true);
                config.setIncludeCharts(true);
                config.setIncludeMetrics(true);
                
                // Default to last week's results
                config.setTimeRange(TimeRange.LAST_WEEK);
            }
            
            // Generate report
            TestReport report = reportService.generateReportFromProject(projectId, config);
            
            if (report != null) {
                LOGGER.info("Report generated with ID: {}", report.getReportId());
                return ResponseEntity.status(HttpStatus.CREATED).body(report);
            } else {
                LOGGER.warn("Failed to generate report for project: {}", projectId);
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(null);
            }
        } catch (Exception e) {
            LOGGER.error("Failed to generate report for project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Export a report in the specified format.
     * 
     * @param reportId ID of the report to export
     * @param format Format of the export (HTML, PDF, Excel, etc.)
     * @return ResponseEntity with the exported report file
     */
    @GetMapping("/{reportId}/export")
    public ResponseEntity<Resource> exportReport(
            @PathVariable String reportId,
            @RequestParam("format") ReportFormat format) {
        
        LOGGER.info("Exporting report {} in {} format", reportId, format);
        
        try {
            // Export report
            byte[] exportedReport = reportService.exportReport(reportId, format);
            
            if (exportedReport != null) {
                // Prepare file name
                String fileName = "report_" + reportId + getFileExtension(format);
                
                // Prepare headers
                HttpHeaders headers = new HttpHeaders();
                headers.add(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + fileName);
                headers.add(HttpHeaders.CACHE_CONTROL, "no-cache, no-store, must-revalidate");
                headers.add(HttpHeaders.PRAGMA, "no-cache");
                headers.add(HttpHeaders.EXPIRES, "0");
                
                // Set content type
                MediaType mediaType = getMediaType(format);
                
                // Return file
                ByteArrayResource resource = new ByteArrayResource(exportedReport);
                
                return ResponseEntity.ok()
                        .headers(headers)
                        .contentLength(exportedReport.length)
                        .contentType(mediaType)
                        .body(resource);
            } else {
                LOGGER.warn("Report not found or export failed: {}", reportId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to export report: {}", reportId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get test results for a report.
     * 
     * @param reportId ID of the report
     * @return ResponseEntity with the test results
     */
    @GetMapping("/{reportId}/results")
    public ResponseEntity<List<TestResult>> getReportResults(@PathVariable String reportId) {
        LOGGER.info("Getting test results for report: {}", reportId);
        
        try {
            List<TestResult> results = reportService.getReportResults(reportId);
            
            if (results != null) {
                return ResponseEntity.ok(results);
            } else {
                LOGGER.warn("Report not found: {}", reportId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get test results for report: {}", reportId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get test steps for a specific test result in a report.
     * 
     * @param reportId ID of the report
     * @param testResultId ID of the test result
     * @return ResponseEntity with the test steps
     */
    @GetMapping("/{reportId}/results/{testResultId}/steps")
    public ResponseEntity<List<TestStep>> getTestResultSteps(
            @PathVariable String reportId,
            @PathVariable String testResultId) {
        
        LOGGER.info("Getting test steps for result {} in report {}", testResultId, reportId);
        
        try {
            List<TestStep> steps = reportService.getTestResultSteps(reportId, testResultId);
            
            if (steps != null) {
                return ResponseEntity.ok(steps);
            } else {
                LOGGER.warn("Report or test result not found: {}/{}", reportId, testResultId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get test steps for result {} in report {}", 
                    testResultId, reportId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get screenshots for a specific test result in a report.
     * 
     * @param reportId ID of the report
     * @param testResultId ID of the test result
     * @return ResponseEntity with the screenshots
     */
    @GetMapping("/{reportId}/results/{testResultId}/screenshots")
    public ResponseEntity<List<TestScreenshot>> getTestResultScreenshots(
            @PathVariable String reportId,
            @PathVariable String testResultId) {
        
        LOGGER.info("Getting screenshots for result {} in report {}", testResultId, reportId);
        
        try {
            List<TestScreenshot> screenshots = reportService.getTestResultScreenshots(reportId, testResultId);
            
            if (screenshots != null) {
                return ResponseEntity.ok(screenshots);
            } else {
                LOGGER.warn("Report or test result not found: {}/{}", reportId, testResultId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get screenshots for result {} in report {}", 
                    testResultId, reportId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get a specific screenshot image.
     * 
     * @param reportId ID of the report
     * @param screenshotId ID of the screenshot
     * @return ResponseEntity with the screenshot image
     */
    @GetMapping("/{reportId}/screenshots/{screenshotId}")
    public ResponseEntity<Resource> getScreenshotImage(
            @PathVariable String reportId,
            @PathVariable String screenshotId) {
        
        LOGGER.info("Getting screenshot image {} in report {}", screenshotId, reportId);
        
        try {
            byte[] screenshotData = reportService.getScreenshotImage(reportId, screenshotId);
            
            if (screenshotData != null) {
                // Prepare headers
                HttpHeaders headers = new HttpHeaders();
                headers.add(HttpHeaders.CONTENT_DISPOSITION, 
                        "inline; filename=screenshot_" + screenshotId + ".png");
                headers.add(HttpHeaders.CACHE_CONTROL, "max-age=86400");
                
                // Return image
                ByteArrayResource resource = new ByteArrayResource(screenshotData);
                
                return ResponseEntity.ok()
                        .headers(headers)
                        .contentLength(screenshotData.length)
                        .contentType(MediaType.IMAGE_PNG)
                        .body(resource);
            } else {
                LOGGER.warn("Screenshot not found: {} in report {}", screenshotId, reportId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get screenshot image {} in report {}", 
                    screenshotId, reportId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get metrics for a report.
     * 
     * @param reportId ID of the report
     * @return ResponseEntity with the metrics
     */
    @GetMapping("/{reportId}/metrics")
    public ResponseEntity<Map<MetricType, Double>> getReportMetrics(@PathVariable String reportId) {
        LOGGER.info("Getting metrics for report: {}", reportId);
        
        try {
            Map<MetricType, Double> metrics = reportService.getReportMetrics(reportId);
            
            if (metrics != null) {
                return ResponseEntity.ok(metrics);
            } else {
                LOGGER.warn("Report not found: {}", reportId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get metrics for report: {}", reportId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get chart data for a report.
     * 
     * @param reportId ID of the report
     * @param chartType Type of chart to generate
     * @return ResponseEntity with the chart data
     */
    @GetMapping("/{reportId}/charts/{chartType}")
    public ResponseEntity<Map<String, Object>> getChartData(
            @PathVariable String reportId,
            @PathVariable ChartType chartType) {
        
        LOGGER.info("Getting {} chart data for report: {}", chartType, reportId);
        
        try {
            Map<String, Object> chartData = reportService.getChartData(reportId, chartType);
            
            if (chartData != null) {
                return ResponseEntity.ok(chartData);
            } else {
                LOGGER.warn("Report not found or chart data not available: {}/{}", reportId, chartType);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get {} chart data for report: {}", chartType, reportId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Generate a comparison report between two test executions.
     * 
     * @param executionId1 ID of the first test execution
     * @param executionId2 ID of the second test execution
     * @param config Report configuration
     * @return ResponseEntity with the generated comparison report
     */
    @PostMapping("/generate/compare")
    public ResponseEntity<TestReport> generateComparisonReport(
            @RequestParam("execution1") String executionId1,
            @RequestParam("execution2") String executionId2,
            @RequestBody(required = false) ReportConfig config) {
        
        LOGGER.info("Generating comparison report for executions: {} and {}", 
                executionId1, executionId2);
        
        try {
            // If config is not provided, use default configuration
            if (config == null) {
                config = new ReportConfig();
                config.setTitle("Comparison Report - " + executionId1 + " vs " + executionId2);
                config.setIncludeScreenshots(true);
                config.setIncludeLogs(false);  // Logs usually not helpful in comparisons
                config.setIncludeCharts(true);
                config.setIncludeMetrics(true);
            }
            
            // Generate comparison report
            TestReport report = reportService.generateComparisonReport(executionId1, executionId2, config);
            
            if (report != null) {
                LOGGER.info("Comparison report generated with ID: {}", report.getReportId());
                return ResponseEntity.status(HttpStatus.CREATED).body(report);
            } else {
                LOGGER.warn("Failed to generate comparison report for executions: {} and {}", 
                        executionId1, executionId2);
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(null);
            }
        } catch (Exception e) {
            LOGGER.error("Failed to generate comparison report for executions: {} and {}", 
                    executionId1, executionId2, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Delete a report.
     * 
     * @param reportId ID of the report to delete
     * @return ResponseEntity with the result
     */
    @DeleteMapping("/{reportId}")
    public ResponseEntity<Map<String, Object>> deleteReport(@PathVariable String reportId) {
        LOGGER.info("Deleting report: {}", reportId);
        
        try {
            boolean deleted = reportService.deleteReport(reportId);
            
            if (deleted) {
                LOGGER.info("Report deleted: {}", reportId);
                return ResponseEntity.ok(Map.of(
                        "reportId", reportId,
                        "deleted", true,
                        "message", "Report deleted successfully"
                ));
            } else {
                LOGGER.warn("Report not found: {}", reportId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to delete report: {}", reportId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "reportId", reportId,
                            "deleted", false,
                            "error", "Failed to delete report: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Generate a time-based trend report for a project.
     * 
     * @param projectId ID of the project
     * @param timeRange Time range for the trend analysis
     * @param config Report configuration
     * @return ResponseEntity with the generated trend report
     */
    @PostMapping("/generate/trend/{projectId}")
    public ResponseEntity<TestReport> generateTrendReport(
            @PathVariable String projectId,
            @RequestParam("timeRange") TimeRange timeRange,
            @RequestBody(required = false) ReportConfig config) {
        
        LOGGER.info("Generating trend report for project: {} over {}", projectId, timeRange);
        
        try {
            // If config is not provided, use default configuration
            if (config == null) {
                config = new ReportConfig();
                config.setTitle("Trend Report - " + projectId + " - " + timeRange);
                config.setIncludeScreenshots(false);  // Screenshots not helpful in trend reports
                config.setIncludeLogs(false);         // Logs not helpful in trend reports
                config.setIncludeCharts(true);
                config.setIncludeMetrics(true);
                config.setTimeRange(timeRange);
            } else {
                // Ensure time range is set
                config.setTimeRange(timeRange);
            }
            
            // Generate trend report
            TestReport report = reportService.generateTrendReport(projectId, config);
            
            if (report != null) {
                LOGGER.info("Trend report generated with ID: {}", report.getReportId());
                return ResponseEntity.status(HttpStatus.CREATED).body(report);
            } else {
                LOGGER.warn("Failed to generate trend report for project: {}", projectId);
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(null);
            }
        } catch (Exception e) {
            LOGGER.error("Failed to generate trend report for project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Generate an executive summary report for a project.
     * 
     * @param projectId ID of the project
     * @param timeRange Time range for the summary
     * @param config Report configuration
     * @return ResponseEntity with the generated executive summary report
     */
    @PostMapping("/generate/executive/{projectId}")
    public ResponseEntity<TestReport> generateExecutiveSummaryReport(
            @PathVariable String projectId,
            @RequestParam("timeRange") TimeRange timeRange,
            @RequestBody(required = false) ReportConfig config) {
        
        LOGGER.info("Generating executive summary report for project: {} over {}", projectId, timeRange);
        
        try {
            // If config is not provided, use default configuration
            if (config == null) {
                config = new ReportConfig();
                config.setTitle("Executive Summary - " + projectId + " - " + timeRange);
                config.setIncludeScreenshots(false);
                config.setIncludeLogs(false);
                config.setIncludeCharts(true);
                config.setIncludeMetrics(true);
                config.setTimeRange(timeRange);
                config.setExecutiveSummary(true);
            } else {
                // Ensure time range and executive summary flags are set
                config.setTimeRange(timeRange);
                config.setExecutiveSummary(true);
            }
            
            // Generate executive summary report
            TestReport report = reportService.generateExecutiveSummaryReport(projectId, config);
            
            if (report != null) {
                LOGGER.info("Executive summary report generated with ID: {}", report.getReportId());
                return ResponseEntity.status(HttpStatus.CREATED).body(report);
            } else {
                LOGGER.warn("Failed to generate executive summary report for project: {}", projectId);
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(null);
            }
        } catch (Exception e) {
            LOGGER.error("Failed to generate executive summary report for project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get dashboard data for a project.
     * 
     * @param projectId ID of the project
     * @param timeRange Optional time range filter
     * @return ResponseEntity with the dashboard data
     */
    @GetMapping("/dashboard/{projectId}")
    public ResponseEntity<Map<String, Object>> getDashboardData(
            @PathVariable String projectId,
            @RequestParam(value = "timeRange", required = false) TimeRange timeRange) {
        
        LOGGER.info("Getting dashboard data for project: {} over {}", projectId, timeRange);
        
        try {
            // If time range not specified, default to last month
            if (timeRange == null) {
                timeRange = TimeRange.LAST_MONTH;
            }
            
            // Get dashboard data
            Map<String, Object> dashboardData = reportService.getDashboardData(projectId, timeRange);
            
            if (dashboardData != null) {
                return ResponseEntity.ok(dashboardData);
            } else {
                LOGGER.warn("Failed to get dashboard data for project: {}", projectId);
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get dashboard data for project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Schedule recurring report generation.
     * 
     * @param projectId ID of the project
     * @param config Report configuration
     * @param schedule Schedule configuration (cron expression, email recipients, etc.)
     * @return ResponseEntity with the result
     */
    @PostMapping("/schedule/{projectId}")
    public ResponseEntity<Map<String, Object>> scheduleReport(
            @PathVariable String projectId,
            @RequestBody ReportConfig config,
            @RequestParam("schedule") String schedule,
            @RequestParam("emails") List<String> emails) {
        
        LOGGER.info("Scheduling report for project: {} with schedule: {}", projectId, schedule);
        
        try {
            // Generate a unique ID for the scheduled report
            String scheduleId = UUID.randomUUID().toString();
            
            // Schedule the report
            boolean scheduled = reportService.scheduleReport(
                    scheduleId, projectId, config, schedule, emails);
            
            if (scheduled) {
                LOGGER.info("Report scheduled for project: {} with ID: {}", projectId, scheduleId);
                return ResponseEntity.ok(Map.of(
                        "scheduleId", scheduleId,
                        "projectId", projectId,
                        "schedule", schedule,
                        "emails", emails,
                        "message", "Report scheduled successfully"
                ));
            } else {
                LOGGER.warn("Failed to schedule report for project: {}", projectId);
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                        .body(Map.of(
                                "error", "Failed to schedule report"
                        ));
            }
        } catch (Exception e) {
            LOGGER.error("Failed to schedule report for project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "error", "Failed to schedule report: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get all scheduled reports.
     * 
     * @return ResponseEntity with the list of scheduled reports
     */
    @GetMapping("/schedule")
    public ResponseEntity<List<Map<String, Object>>> getScheduledReports() {
        LOGGER.info("Getting all scheduled reports");
        
        try {
            List<Map<String, Object>> scheduledReports = reportService.getScheduledReports();
            return ResponseEntity.ok(scheduledReports);
        } catch (Exception e) {
            LOGGER.error("Failed to get scheduled reports", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Delete a scheduled report.
     * 
     * @param scheduleId ID of the scheduled report
     * @return ResponseEntity with the result
     */
    @DeleteMapping("/schedule/{scheduleId}")
    public ResponseEntity<Map<String, Object>> deleteScheduledReport(@PathVariable String scheduleId) {
        LOGGER.info("Deleting scheduled report: {}", scheduleId);
        
        try {
            boolean deleted = reportService.deleteScheduledReport(scheduleId);
            
            if (deleted) {
                LOGGER.info("Scheduled report deleted: {}", scheduleId);
                return ResponseEntity.ok(Map.of(
                        "scheduleId", scheduleId,
                        "deleted", true,
                        "message", "Scheduled report deleted successfully"
                ));
            } else {
                LOGGER.warn("Scheduled report not found: {}", scheduleId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to delete scheduled report: {}", scheduleId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "scheduleId", scheduleId,
                            "deleted", false,
                            "error", "Failed to delete scheduled report: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get file extension for a report format.
     * 
     * @param format Report format
     * @return File extension
     */
    private String getFileExtension(ReportFormat format) {
        switch (format) {
            case HTML:
                return ".html";
            case PDF:
                return ".pdf";
            case EXCEL:
                return ".xlsx";
            case CSV:
                return ".csv";
            case JSON:
                return ".json";
            case XML:
                return ".xml";
            default:
                return ".txt";
        }
    }
    
    /**
     * Get media type for a report format.
     * 
     * @param format Report format
     * @return MediaType
     */
    private MediaType getMediaType(ReportFormat format) {
        switch (format) {
            case HTML:
                return MediaType.TEXT_HTML;
            case PDF:
                return MediaType.APPLICATION_PDF;
            case EXCEL:
                return MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            case CSV:
                return MediaType.parseMediaType("text/csv");
            case JSON:
                return MediaType.APPLICATION_JSON;
            case XML:
                return MediaType.APPLICATION_XML;
            default:
                return MediaType.TEXT_PLAIN;
        }
    }
}


FrameworkController.java
-------------------------------------------------------

  package com.cstestforge.controller;

import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;
import com.cstestforge.model.framework.FrameworkCapability;
import com.cstestforge.model.framework.ElementLocatorStrategy;
import com.cstestforge.model.framework.BrowserOption;
import com.cstestforge.model.framework.FrameworkConfig;
import com.cstestforge.model.framework.WaitStrategy;
import com.cstestforge.service.framework.FrameworkService;
import com.cstestforge.framework.core.utils.CSLogger;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.stream.Collectors;

/**
 * Controller for framework-related operations.
 * This controller provides endpoints for framework capabilities, 
 * configurations, and settings.
 */
@RestController
@RequestMapping("/api/framework")
public class FrameworkController {

    private static final CSLogger LOGGER = new CSLogger(FrameworkController.class);
    
    private final FrameworkService frameworkService;
    
    @Autowired
    public FrameworkController(FrameworkService frameworkService) {
        this.frameworkService = frameworkService;
    }
    
    /**
     * Get all supported framework types.
     * 
     * @return ResponseEntity with the list of framework types
     */
    @GetMapping("/types")
    public ResponseEntity<List<Map<String, Object>>> getFrameworkTypes() {
        LOGGER.info("Getting all supported framework types");
        
        try {
            List<Map<String, Object>> frameworkTypes = new ArrayList<>();
            
            for (FrameworkType type : FrameworkType.values()) {
                Map<String, Object> frameworkInfo = new HashMap<>();
                frameworkInfo.put("id", type.name());
                frameworkInfo.put("name", getFrameworkDisplayName(type));
                frameworkInfo.put("description", getFrameworkDescription(type));
                
                frameworkTypes.add(frameworkInfo);
            }
            
            return ResponseEntity.ok(frameworkTypes);
        } catch (Exception e) {
            LOGGER.error("Failed to get framework types", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get all supported language types.
     * 
     * @return ResponseEntity with the list of language types
     */
    @GetMapping("/languages")
    public ResponseEntity<List<Map<String, Object>>> getLanguageTypes() {
        LOGGER.info("Getting all supported language types");
        
        try {
            List<Map<String, Object>> languageTypes = new ArrayList<>();
            
            for (LanguageType type : LanguageType.values()) {
                Map<String, Object> languageInfo = new HashMap<>();
                languageInfo.put("id", type.name());
                languageInfo.put("name", getLanguageDisplayName(type));
                languageInfo.put("description", getLanguageDescription(type));
                
                languageTypes.add(languageInfo);
            }
            
            return ResponseEntity.ok(languageTypes);
        } catch (Exception e) {
            LOGGER.error("Failed to get language types", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get all supported test types.
     * 
     * @return ResponseEntity with the list of test types
     */
    @GetMapping("/testtypes")
    public ResponseEntity<List<Map<String, Object>>> getTestTypes() {
        LOGGER.info("Getting all supported test types");
        
        try {
            List<Map<String, Object>> testTypes = new ArrayList<>();
            
            for (TestType type : TestType.values()) {
                Map<String, Object> testTypeInfo = new HashMap<>();
                testTypeInfo.put("id", type.name());
                testTypeInfo.put("name", getTestTypeDisplayName(type));
                testTypeInfo.put("description", getTestTypeDescription(type));
                
                testTypes.add(testTypeInfo);
            }
            
            return ResponseEntity.ok(testTypes);
        } catch (Exception e) {
            LOGGER.error("Failed to get test types", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get supported language types for a specific framework.
     * 
     * @param frameworkType Framework type
     * @return ResponseEntity with the list of supported language types
     */
    @GetMapping("/languages/{frameworkType}")
    public ResponseEntity<List<Map<String, Object>>> getSupportedLanguages(
            @PathVariable FrameworkType frameworkType) {
        
        LOGGER.info("Getting supported languages for framework: {}", frameworkType);
        
        try {
            List<LanguageType> supportedLanguages = frameworkService.getSupportedLanguages(frameworkType);
            
            List<Map<String, Object>> languageInfoList = supportedLanguages.stream()
                    .map(type -> {
                        Map<String, Object> languageInfo = new HashMap<>();
                        languageInfo.put("id", type.name());
                        languageInfo.put("name", getLanguageDisplayName(type));
                        languageInfo.put("description", getLanguageDescription(type));
                        
                        return languageInfo;
                    })
                    .collect(Collectors.toList());
            
            return ResponseEntity.ok(languageInfoList);
        } catch (Exception e) {
            LOGGER.error("Failed to get supported languages for framework: {}", frameworkType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get supported test types for a specific framework and language.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ResponseEntity with the list of supported test types
     */
    @GetMapping("/testtypes/{frameworkType}/{languageType}")
    public ResponseEntity<List<Map<String, Object>>> getSupportedTestTypes(
            @PathVariable FrameworkType frameworkType,
            @PathVariable LanguageType languageType) {
        
        LOGGER.info("Getting supported test types for framework: {} and language: {}", 
                frameworkType, languageType);
        
        try {
            List<TestType> supportedTestTypes = frameworkService.getSupportedTestTypes(
                    frameworkType, languageType);
            
            List<Map<String, Object>> testTypeInfoList = supportedTestTypes.stream()
                    .map(type -> {
                        Map<String, Object> testTypeInfo = new HashMap<>();
                        testTypeInfo.put("id", type.name());
                        testTypeInfo.put("name", getTestTypeDisplayName(type));
                        testTypeInfo.put("description", getTestTypeDescription(type));
                        
                        return testTypeInfo;
                    })
                    .collect(Collectors.toList());
            
            return ResponseEntity.ok(testTypeInfoList);
        } catch (Exception e) {
            LOGGER.error("Failed to get supported test types for framework: {} and language: {}", 
                    frameworkType, languageType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get framework capabilities for a specific framework, language, and test type.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the list of framework capabilities
     */
    @GetMapping("/capabilities/{frameworkType}/{languageType}/{testType}")
    public ResponseEntity<List<FrameworkCapability>> getFrameworkCapabilities(
            @PathVariable FrameworkType frameworkType,
            @PathVariable LanguageType languageType,
            @PathVariable TestType testType) {
        
        LOGGER.info("Getting capabilities for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            List<FrameworkCapability> capabilities = frameworkService.getFrameworkCapabilities(
                    frameworkType, languageType, testType);
            
            return ResponseEntity.ok(capabilities);
        } catch (Exception e) {
            LOGGER.error("Failed to get capabilities for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get supported locator strategies for a specific framework.
     * 
     * @param frameworkType Framework type
     * @return ResponseEntity with the list of supported locator strategies
     */
    @GetMapping("/locators/{frameworkType}")
    public ResponseEntity<List<ElementLocatorStrategy>> getSupportedLocatorStrategies(
            @PathVariable FrameworkType frameworkType) {
        
        LOGGER.info("Getting supported locator strategies for framework: {}", frameworkType);
        
        try {
            List<ElementLocatorStrategy> locatorStrategies = frameworkService.getSupportedLocatorStrategies(
                    frameworkType);
            
            return ResponseEntity.ok(locatorStrategies);
        } catch (Exception e) {
            LOGGER.error("Failed to get supported locator strategies for framework: {}", 
                    frameworkType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get supported browser options for a specific framework.
     * 
     * @param frameworkType Framework type
     * @return ResponseEntity with the list of supported browser options
     */
    @GetMapping("/browser-options/{frameworkType}")
    public ResponseEntity<List<BrowserOption>> getSupportedBrowserOptions(
            @PathVariable FrameworkType frameworkType) {
        
        LOGGER.info("Getting supported browser options for framework: {}", frameworkType);
        
        try {
            List<BrowserOption> browserOptions = frameworkService.getSupportedBrowserOptions(
                    frameworkType);
            
            return ResponseEntity.ok(browserOptions);
        } catch (Exception e) {
            LOGGER.error("Failed to get supported browser options for framework: {}", 
                    frameworkType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get supported wait strategies for a specific framework.
     * 
     * @param frameworkType Framework type
     * @return ResponseEntity with the list of supported wait strategies
     */
    @GetMapping("/wait-strategies/{frameworkType}")
    public ResponseEntity<List<WaitStrategy>> getSupportedWaitStrategies(
            @PathVariable FrameworkType frameworkType) {
        
        LOGGER.info("Getting supported wait strategies for framework: {}", frameworkType);
        
        try {
            List<WaitStrategy> waitStrategies = frameworkService.getSupportedWaitStrategies(
                    frameworkType);
            
            return ResponseEntity.ok(waitStrategies);
        } catch (Exception e) {
            LOGGER.error("Failed to get supported wait strategies for framework: {}", 
                    frameworkType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get framework configuration for a specific framework, language, and test type.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the framework configuration
     */
    @GetMapping("/config/{frameworkType}/{languageType}/{testType}")
    public ResponseEntity<FrameworkConfig> getFrameworkConfig(
            @PathVariable FrameworkType frameworkType,
            @PathVariable LanguageType languageType,
            @PathVariable TestType testType) {
        
        LOGGER.info("Getting configuration for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            FrameworkConfig config = frameworkService.getFrameworkConfig(
                    frameworkType, languageType, testType);
            
            if (config != null) {
                return ResponseEntity.ok(config);
            } else {
                LOGGER.warn("Configuration not found for framework: {}, language: {}, test type: {}", 
                        frameworkType, languageType, testType);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get configuration for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Update framework configuration.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @param config Updated framework configuration
     * @return ResponseEntity with the updated framework configuration
     */
    @PutMapping("/config/{frameworkType}/{languageType}/{testType}")
    public ResponseEntity<FrameworkConfig> updateFrameworkConfig(
            @PathVariable FrameworkType frameworkType,
            @PathVariable LanguageType languageType,
            @PathVariable TestType testType,
            @RequestBody FrameworkConfig config) {
        
        LOGGER.info("Updating configuration for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            // Validate configuration matches the path parameters
            if (config.getFrameworkType() != frameworkType ||
                    config.getLanguageType() != languageType ||
                    config.getTestType() != testType) {
                
                return ResponseEntity.badRequest().build();
            }
            
            // Update configuration
            FrameworkConfig updatedConfig = frameworkService.updateFrameworkConfig(config);
            
            if (updatedConfig != null) {
                LOGGER.info("Configuration updated for framework: {}, language: {}, test type: {}", 
                        frameworkType, languageType, testType);
                return ResponseEntity.ok(updatedConfig);
            } else {
                LOGGER.warn("Configuration not found for framework: {}, language: {}, test type: {}", 
                        frameworkType, languageType, testType);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to update configuration for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Reset framework configuration to defaults.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the reset framework configuration
     */
    @PostMapping("/config/{frameworkType}/{languageType}/{testType}/reset")
    public ResponseEntity<FrameworkConfig> resetFrameworkConfig(
            @PathVariable FrameworkType frameworkType,
            @PathVariable LanguageType languageType,
            @PathVariable TestType testType) {
        
        LOGGER.info("Resetting configuration to defaults for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            // Reset configuration
            FrameworkConfig resetConfig = frameworkService.resetFrameworkConfig(
                    frameworkType, languageType, testType);
            
            if (resetConfig != null) {
                LOGGER.info("Configuration reset for framework: {}, language: {}, test type: {}", 
                        frameworkType, languageType, testType);
                return ResponseEntity.ok(resetConfig);
            } else {
                LOGGER.warn("Failed to reset configuration for framework: {}, language: {}, test type: {}", 
                        frameworkType, languageType, testType);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to reset configuration for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Check if a feature is supported by a specific framework, language, and test type.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @param featureName Name of the feature to check
     * @return ResponseEntity with the result
     */
    @GetMapping("/supports/{frameworkType}/{languageType}/{testType}/{featureName}")
    public ResponseEntity<Map<String, Object>> isFeatureSupported(
            @PathVariable FrameworkType frameworkType,
            @PathVariable LanguageType languageType,
            @PathVariable TestType testType,
            @PathVariable String featureName) {
        
        LOGGER.info("Checking if feature {} is supported by framework: {}, language: {}, test type: {}", 
                featureName, frameworkType, languageType, testType);
        
        try {
            boolean supported = frameworkService.isFeatureSupported(
                    frameworkType, languageType, testType, featureName);
            
            Map<String, Object> result = new HashMap<>();
            result.put("frameworkType", frameworkType);
            result.put("languageType", languageType);
            result.put("testType", testType);
            result.put("featureName", featureName);
            result.put("supported", supported);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            LOGGER.error("Failed to check if feature {} is supported by framework: {}, language: {}, test type: {}", 
                    featureName, frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get browser compatibility for a specific framework.
     * 
     * @param frameworkType Framework type
     * @return ResponseEntity with the browser compatibility information
     */
    @GetMapping("/browser-compatibility/{frameworkType}")
    public ResponseEntity<Map<String, Object>> getBrowserCompatibility(
            @PathVariable FrameworkType frameworkType) {
        
        LOGGER.info("Getting browser compatibility for framework: {}", frameworkType);
        
        try {
            Map<String, Object> compatibility = frameworkService.getBrowserCompatibility(frameworkType);
            
            return ResponseEntity.ok(compatibility);
        } catch (Exception e) {
            LOGGER.error("Failed to get browser compatibility for framework: {}", 
                    frameworkType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get version information for a specific framework, language, and test type.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the version information
     */
    @GetMapping("/version/{frameworkType}/{languageType}/{testType}")
    public ResponseEntity<Map<String, String>> getVersionInfo(
            @PathVariable FrameworkType frameworkType,
            @PathVariable LanguageType languageType,
            @PathVariable TestType testType) {
        
        LOGGER.info("Getting version information for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            Map<String, String> versionInfo = frameworkService.getVersionInfo(
                    frameworkType, languageType, testType);
            
            return ResponseEntity.ok(versionInfo);
        } catch (Exception e) {
            LOGGER.error("Failed to get version information for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get all frameworks as a matrix of framework types, language types, and test types.
     * 
     * @return ResponseEntity with the framework matrix
     */
    @GetMapping("/matrix")
    public ResponseEntity<List<Map<String, Object>>> getFrameworkMatrix() {
        LOGGER.info("Getting framework matrix");
        
        try {
            List<Map<String, Object>> matrix = new ArrayList<>();
            
            for (FrameworkType frameworkType : FrameworkType.values()) {
                List<LanguageType> supportedLanguages = frameworkService.getSupportedLanguages(frameworkType);
                
                for (LanguageType languageType : supportedLanguages) {
                    List<TestType> supportedTestTypes = frameworkService.getSupportedTestTypes(
                            frameworkType, languageType);
                    
                    for (TestType testType : supportedTestTypes) {
                        Map<String, Object> entry = new HashMap<>();
                        entry.put("frameworkType", frameworkType);
                        entry.put("frameworkName", getFrameworkDisplayName(frameworkType));
                        entry.put("languageType", languageType);
                        entry.put("languageName", getLanguageDisplayName(languageType));
                        entry.put("testType", testType);
                        entry.put("testTypeName", getTestTypeDisplayName(testType));
                        
                        // Get capabilities
                        List<FrameworkCapability> capabilities = frameworkService.getFrameworkCapabilities(
                                frameworkType, languageType, testType);
                        entry.put("capabilities", capabilities);
                        
                        matrix.add(entry);
                    }
                }
            }
            
            return ResponseEntity.ok(matrix);
        } catch (Exception e) {
            LOGGER.error("Failed to get framework matrix", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Check if a specific framework, language, and test type combination is valid.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the validation result
     */
    @GetMapping("/validate/{frameworkType}/{languageType}/{testType}")
    public ResponseEntity<Map<String, Object>> validateFrameworkCombination(
            @PathVariable FrameworkType frameworkType,
            @PathVariable LanguageType languageType,
            @PathVariable TestType testType) {
        
        LOGGER.info("Validating framework combination: {}, {}, {}", 
                frameworkType, languageType, testType);
        
        try {
            boolean valid = frameworkService.isValidCombination(
                    frameworkType, languageType, testType);
            
            Map<String, Object> result = new HashMap<>();
            result.put("frameworkType", frameworkType);
            result.put("languageType", languageType);
            result.put("testType", testType);
            result.put("valid", valid);
            
            if (!valid) {
                List<String> validationMessages = frameworkService.getValidationMessages(
                        frameworkType, languageType, testType);
                result.put("messages", validationMessages);
            }
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            LOGGER.error("Failed to validate framework combination: {}, {}, {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get example code for a specific framework, language, and test type.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @param exampleType Type of example (e.g., "basic", "pageObject", "dataProvider")
     * @return ResponseEntity with the example code
     */
    @GetMapping("/example/{frameworkType}/{languageType}/{testType}/{exampleType}")
    public ResponseEntity<Map<String, Object>> getExampleCode(
            @PathVariable FrameworkType frameworkType,
            @PathVariable LanguageType languageType,
            @PathVariable TestType testType,
            @PathVariable String exampleType) {
        
        LOGGER.info("Getting {} example code for framework: {}, language: {}, test type: {}", 
                exampleType, frameworkType, languageType, testType);
        
        try {
            Map<String, String> exampleCode = frameworkService.getExampleCode(
                    frameworkType, languageType, testType, exampleType);
            
            if (exampleCode != null && !exampleCode.isEmpty()) {
                Map<String, Object> response = new HashMap<>();
                response.put("frameworkType", frameworkType);
                response.put("languageType", languageType);
                response.put("testType", testType);
                response.put("exampleType", exampleType);
                response.put("files", exampleCode);
                
                return ResponseEntity.ok(response);
            } else {
                LOGGER.warn("Example code not found for framework: {}, language: {}, test type: {}, example type: {}", 
                        frameworkType, languageType, testType, exampleType);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get example code for framework: {}, language: {}, test type: {}, example type: {}", 
                    frameworkType, languageType, testType, exampleType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get display name for a framework type.
     * 
     * @param frameworkType Framework type
     * @return Display name
     */
    private String getFrameworkDisplayName(FrameworkType frameworkType) {
        switch (frameworkType) {
            case SELENIUM:
                return "Selenium";
            case PLAYWRIGHT:
                return "Playwright";
            default:
                return frameworkType.name();
        }
    }
    
    /**
     * Get description for a framework type.
     * 
     * @param frameworkType Framework type
     * @return Description
     */
    private String getFrameworkDescription(FrameworkType frameworkType) {
        switch (frameworkType) {
            case SELENIUM:
                return "Selenium WebDriver for cross-browser testing";
            case PLAYWRIGHT:
                return "Playwright for modern browser automation";
            default:
                return "Unknown framework";
        }
    }
    
    /**
     * Get display name for a language type.
     * 
     * @param languageType Language type
     * @return Display name
     */
    private String getLanguageDisplayName(LanguageType languageType) {
        switch (languageType) {
            case JAVA:
                return "Java";
            case TYPESCRIPT:
                return "TypeScript";
            default:
                return languageType.name();
        }
    }
    
    /**
     * Get description for a language type.
     * 
     * @param languageType Language type
     * @return Description
     */
    private String getLanguageDescription(LanguageType languageType) {
        switch (languageType) {
            case JAVA:
                return "Java programming language with TestNG and Cucumber support";
            case TYPESCRIPT:
                return "TypeScript programming language with Mocha/Jest and Cucumber support";
            default:
                return "Unknown language";
        }
    }
    
    /**
     * Get display name for a test type.
     * 
     * @param testType Test type
     * @return Display name
     */
    private String getTestTypeDisplayName(TestType testType) {
        switch (testType) {
            case TESTNG:
                return "TestNG";
            case BDD:
                return "BDD";
            default:
                return testType.name();
        }
    }
    
    /**
     * Get description for a test type.
     * 
     * @param testType Test type
     * @return Description
     */
    private String getTestTypeDescription(TestType testType) {
        switch (testType) {
            case TESTNG:
                return "TestNG-based traditional testing";
            case BDD:
                return "Behavior-Driven Development with Cucumber";
            default:
                return "Unknown test type";
        }
    }
}


ExportController.java
------------------------------------------

  package com.cstestforge.controller;

import com.cstestforge.model.export.ExportRequest;
import com.cstestforge.model.export.ExportResult;
import com.cstestforge.model.export.ExportTemplate;
import com.cstestforge.model.export.ExportFormat;
import com.cstestforge.model.export.PipelineType;
import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;
import com.cstestforge.service.export.ExportService;
import com.cstestforge.service.export.TemplateServiceFactory;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSDateUtils;
import com.cstestforge.framework.core.utils.CSFileUtils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Files;
import java.util.stream.Collectors;
import java.util.UUID;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import java.io.ByteArrayOutputStream;

/**
 * Controller for export operations.
 * This controller provides endpoints for exporting tests, projects, 
 * and generating pipeline configurations.
 */
@RestController
@RequestMapping("/api/export")
public class ExportController {

    private static final CSLogger LOGGER = new CSLogger(ExportController.class);
    
    private final ExportService exportService;
    private final TemplateServiceFactory templateServiceFactory;
    
    @Autowired
    public ExportController(ExportService exportService, TemplateServiceFactory templateServiceFactory) {
        this.exportService = exportService;
        this.templateServiceFactory = templateServiceFactory;
    }
    
    /**
     * Export project as a complete test project.
     * 
     * @param exportRequest Export request details
     * @return ResponseEntity with the exported project
     */
    @PostMapping("/project")
    public ResponseEntity<Resource> exportProject(@RequestBody ExportRequest exportRequest) {
        LOGGER.info("Exporting project: {} for framework: {}, language: {}, test type: {}", 
                exportRequest.getProjectId(), exportRequest.getFrameworkType(), 
                exportRequest.getLanguageType(), exportRequest.getTestType());
        
        try {
            // Validate request
            if (exportRequest.getProjectId() == null || exportRequest.getProjectId().isEmpty()) {
                return ResponseEntity.badRequest().build();
            }
            
            if (exportRequest.getFrameworkType() == null || 
                exportRequest.getLanguageType() == null ||
                exportRequest.getTestType() == null) {
                return ResponseEntity.badRequest().build();
            }
            
            // Set export ID if not provided
            if (exportRequest.getExportId() == null || exportRequest.getExportId().isEmpty()) {
                exportRequest.setExportId(UUID.randomUUID().toString());
            }
            
            // Set export time
            exportRequest.setExportTime(CSDateUtils.getCurrentTimestamp());
            
            // Export project
            ExportResult result = exportService.exportProject(exportRequest);
            
            if (result == null || result.getExportedContent() == null) {
                LOGGER.warn("Failed to export project: {}", exportRequest.getProjectId());
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=project_export_" + exportRequest.getProjectId() + ".zip");
            headers.add(HttpHeaders.CONTENT_TYPE, "application/zip");
            
            // Create resource from exported content
            ByteArrayResource resource = new ByteArrayResource(result.getExportedContent());
            
            LOGGER.info("Project exported successfully: {}", exportRequest.getProjectId());
            return ResponseEntity.ok()
                    .headers(headers)
                    .contentLength(result.getExportedContent().length)
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .body(resource);
        } catch (Exception e) {
            LOGGER.error("Failed to export project: {}", exportRequest.getProjectId(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Export test suite as a test project.
     * 
     * @param exportRequest Export request details
     * @return ResponseEntity with the exported test suite
     */
    @PostMapping("/suite")
    public ResponseEntity<Resource> exportSuite(@RequestBody ExportRequest exportRequest) {
        LOGGER.info("Exporting test suite: {} from project: {} for framework: {}, language: {}, test type: {}", 
                exportRequest.getSuiteId(), exportRequest.getProjectId(), exportRequest.getFrameworkType(), 
                exportRequest.getLanguageType(), exportRequest.getTestType());
        
        try {
            // Validate request
            if (exportRequest.getProjectId() == null || exportRequest.getProjectId().isEmpty() ||
                exportRequest.getSuiteId() == null || exportRequest.getSuiteId().isEmpty()) {
                return ResponseEntity.badRequest().build();
            }
            
            if (exportRequest.getFrameworkType() == null || 
                exportRequest.getLanguageType() == null ||
                exportRequest.getTestType() == null) {
                return ResponseEntity.badRequest().build();
            }
            
            // Set export ID if not provided
            if (exportRequest.getExportId() == null || exportRequest.getExportId().isEmpty()) {
                exportRequest.setExportId(UUID.randomUUID().toString());
            }
            
            // Set export time
            exportRequest.setExportTime(CSDateUtils.getCurrentTimestamp());
            
            // Export test suite
            ExportResult result = exportService.exportTestSuite(exportRequest);
            
            if (result == null || result.getExportedContent() == null) {
                LOGGER.warn("Failed to export test suite: {} from project: {}", 
                        exportRequest.getSuiteId(), exportRequest.getProjectId());
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=suite_export_" + exportRequest.getSuiteId() + ".zip");
            headers.add(HttpHeaders.CONTENT_TYPE, "application/zip");
            
            // Create resource from exported content
            ByteArrayResource resource = new ByteArrayResource(result.getExportedContent());
            
            LOGGER.info("Test suite exported successfully: {} from project: {}", 
                    exportRequest.getSuiteId(), exportRequest.getProjectId());
            return ResponseEntity.ok()
                    .headers(headers)
                    .contentLength(result.getExportedContent().length)
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .body(resource);
        } catch (Exception e) {
            LOGGER.error("Failed to export test suite: {} from project: {}", 
                    exportRequest.getSuiteId(), exportRequest.getProjectId(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Export test cases as a test project.
     * 
     * @param exportRequest Export request details
     * @return ResponseEntity with the exported test cases
     */
    @PostMapping("/testcases")
    public ResponseEntity<Resource> exportTestCases(@RequestBody ExportRequest exportRequest) {
        LOGGER.info("Exporting test cases from suite: {} in project: {} for framework: {}, language: {}, test type: {}", 
                exportRequest.getSuiteId(), exportRequest.getProjectId(), exportRequest.getFrameworkType(), 
                exportRequest.getLanguageType(), exportRequest.getTestType());
        
        try {
            // Validate request
            if (exportRequest.getProjectId() == null || exportRequest.getProjectId().isEmpty() ||
                exportRequest.getSuiteId() == null || exportRequest.getSuiteId().isEmpty() ||
                exportRequest.getTestCaseIds() == null || exportRequest.getTestCaseIds().isEmpty()) {
                return ResponseEntity.badRequest().build();
            }
            
            if (exportRequest.getFrameworkType() == null || 
                exportRequest.getLanguageType() == null ||
                exportRequest.getTestType() == null) {
                return ResponseEntity.badRequest().build();
            }
            
            // Set export ID if not provided
            if (exportRequest.getExportId() == null || exportRequest.getExportId().isEmpty()) {
                exportRequest.setExportId(UUID.randomUUID().toString());
            }
            
            // Set export time
            exportRequest.setExportTime(CSDateUtils.getCurrentTimestamp());
            
            // Export test cases
            ExportResult result = exportService.exportTestCases(exportRequest);
            
            if (result == null || result.getExportedContent() == null) {
                LOGGER.warn("Failed to export test cases from suite: {} in project: {}", 
                        exportRequest.getSuiteId(), exportRequest.getProjectId());
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=testcases_export_" + exportRequest.getExportId() + ".zip");
            headers.add(HttpHeaders.CONTENT_TYPE, "application/zip");
            
            // Create resource from exported content
            ByteArrayResource resource = new ByteArrayResource(result.getExportedContent());
            
            LOGGER.info("Test cases exported successfully from suite: {} in project: {}", 
                    exportRequest.getSuiteId(), exportRequest.getProjectId());
            return ResponseEntity.ok()
                    .headers(headers)
                    .contentLength(result.getExportedContent().length)
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .body(resource);
        } catch (Exception e) {
            LOGGER.error("Failed to export test cases from suite: {} in project: {}", 
                    exportRequest.getSuiteId(), exportRequest.getProjectId(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Export test execution results.
     * 
     * @param executionId ID of the test execution
     * @param format Export format
     * @return ResponseEntity with the exported test execution results
     */
    @GetMapping("/execution/{executionId}")
    public ResponseEntity<Resource> exportExecution(
            @PathVariable String executionId,
            @RequestParam(value = "format", defaultValue = "ZIP") ExportFormat format) {
        
        LOGGER.info("Exporting test execution: {} in format: {}", executionId, format);
        
        try {
            // Export test execution
            ExportResult result = exportService.exportExecution(executionId, format);
            
            if (result == null || result.getExportedContent() == null) {
                LOGGER.warn("Failed to export test execution: {}", executionId);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=execution_export_" + executionId + getFileExtension(format));
            
            // Set content type based on format
            MediaType contentType = getContentType(format);
            
            // Create resource from exported content
            ByteArrayResource resource = new ByteArrayResource(result.getExportedContent());
            
            LOGGER.info("Test execution exported successfully: {}", executionId);
            return ResponseEntity.ok()
                    .headers(headers)
                    .contentLength(result.getExportedContent().length)
                    .contentType(contentType)
                    .body(resource);
        } catch (Exception e) {
            LOGGER.error("Failed to export test execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get available export templates.
     * 
     * @param frameworkType Framework type filter
     * @param languageType Language type filter
     * @param testType Test type filter
     * @return ResponseEntity with the list of export templates
     */
    @GetMapping("/templates")
    public ResponseEntity<List<ExportTemplate>> getExportTemplates(
            @RequestParam(value = "framework", required = false) FrameworkType frameworkType,
            @RequestParam(value = "language", required = false) LanguageType languageType,
            @RequestParam(value = "testType", required = false) TestType testType) {
        
        LOGGER.info("Getting export templates for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            List<ExportTemplate> templates = exportService.getExportTemplates(
                    frameworkType, languageType, testType);
            
            return ResponseEntity.ok(templates);
        } catch (Exception e) {
            LOGGER.error("Failed to get export templates", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get a specific export template.
     * 
     * @param templateId ID of the template
     * @return ResponseEntity with the export template
     */
    @GetMapping("/templates/{templateId}")
    public ResponseEntity<ExportTemplate> getExportTemplate(@PathVariable String templateId) {
        LOGGER.info("Getting export template: {}", templateId);
        
        try {
            ExportTemplate template = exportService.getExportTemplate(templateId);
            
            if (template != null) {
                return ResponseEntity.ok(template);
            } else {
                LOGGER.warn("Export template not found: {}", templateId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get export template: {}", templateId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Create a new export template.
     * 
     * @param template The template to create
     * @return ResponseEntity with the created template
     */
    @PostMapping("/templates")
    public ResponseEntity<ExportTemplate> createExportTemplate(@RequestBody ExportTemplate template) {
        LOGGER.info("Creating export template: {}", template.getName());
        
        try {
            // Validate template
            if (template.getName() == null || template.getName().isEmpty() ||
                template.getFrameworkType() == null ||
                template.getLanguageType() == null ||
                template.getTestType() == null) {
                return ResponseEntity.badRequest().build();
            }
            
            // Set template ID if not provided
            if (template.getTemplateId() == null || template.getTemplateId().isEmpty()) {
                template.setTemplateId(UUID.randomUUID().toString());
            }
            
            // Set creation time
            template.setCreationTime(CSDateUtils.getCurrentTimestamp());
            
            // Create template
            ExportTemplate createdTemplate = exportService.createExportTemplate(template);
            
            if (createdTemplate != null) {
                LOGGER.info("Export template created with ID: {}", createdTemplate.getTemplateId());
                return ResponseEntity.status(HttpStatus.CREATED).body(createdTemplate);
            } else {
                LOGGER.warn("Failed to create export template: {}", template.getName());
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to create export template: {}", template.getName(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Update an existing export template.
     * 
     * @param templateId ID of the template to update
     * @param template Updated template data
     * @return ResponseEntity with the updated template
     */
    @PutMapping("/templates/{templateId}")
    public ResponseEntity<ExportTemplate> updateExportTemplate(
            @PathVariable String templateId,
            @RequestBody ExportTemplate template) {
        
        LOGGER.info("Updating export template: {}", templateId);
        
        try {
            // Ensure the template ID in the path matches the template ID in the body
            if (!templateId.equals(template.getTemplateId())) {
                return ResponseEntity.badRequest().build();
            }
            
            // Update the template
            ExportTemplate updatedTemplate = exportService.updateExportTemplate(template);
            
            if (updatedTemplate != null) {
                LOGGER.info("Export template updated: {}", templateId);
                return ResponseEntity.ok(updatedTemplate);
            } else {
                LOGGER.warn("Export template not found: {}", templateId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to update export template: {}", templateId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Delete an export template.
     * 
     * @param templateId ID of the template to delete
     * @return ResponseEntity with the result
     */
    @DeleteMapping("/templates/{templateId}")
    public ResponseEntity<Map<String, Object>> deleteExportTemplate(@PathVariable String templateId) {
        LOGGER.info("Deleting export template: {}", templateId);
        
        try {
            boolean deleted = exportService.deleteExportTemplate(templateId);
            
            if (deleted) {
                LOGGER.info("Export template deleted: {}", templateId);
                return ResponseEntity.ok(Map.of(
                        "templateId", templateId,
                        "deleted", true,
                        "message", "Export template deleted successfully"
                ));
            } else {
                LOGGER.warn("Export template not found: {}", templateId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to delete export template: {}", templateId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "templateId", templateId,
                            "deleted", false,
                            "error", "Failed to delete export template: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Generate pipeline configuration.
     * 
     * @param projectId ID of the project
     * @param pipelineType Type of pipeline to generate
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the generated pipeline configuration
     */
    @GetMapping("/pipeline/{projectId}")
    public ResponseEntity<Resource> generatePipeline(
            @PathVariable String projectId,
            @RequestParam("pipelineType") PipelineType pipelineType,
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Generating {} pipeline for project: {}, framework: {}, language: {}, test type: {}", 
                pipelineType, projectId, frameworkType, languageType, testType);
        
        try {
            // Generate pipeline configuration
            byte[] pipelineConfig = exportService.generatePipelineConfig(
                    projectId, pipelineType, frameworkType, languageType, testType);
            
            if (pipelineConfig == null) {
                LOGGER.warn("Failed to generate pipeline configuration for project: {}", projectId);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=" + getPipelineFileName(pipelineType, frameworkType, languageType, testType));
            
            // Create resource from pipeline configuration
            ByteArrayResource resource = new ByteArrayResource(pipelineConfig);
            
            LOGGER.info("Pipeline configuration generated successfully for project: {}", projectId);
            return ResponseEntity.ok()
                    .headers(headers)
                    .contentLength(pipelineConfig.length)
                    .contentType(getContentTypeForPipeline(pipelineType))
                    .body(resource);
        } catch (Exception e) {
            LOGGER.error("Failed to generate pipeline configuration for project: {}", projectId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Preview the structure of a project export.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @param templateId Optional template ID
     * @return ResponseEntity with the preview structure
     */
    @GetMapping("/preview/structure")
    public ResponseEntity<List<Map<String, Object>>> previewExportStructure(
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType,
            @RequestParam(value = "templateId", required = false) String templateId) {
        
        LOGGER.info("Previewing export structure for framework: {}, language: {}, test type: {}, template: {}", 
                frameworkType, languageType, testType, templateId);
        
        try {
            List<Map<String, Object>> structure = exportService.previewExportStructure(
                    frameworkType, languageType, testType, templateId);
            
            return ResponseEntity.ok(structure);
        } catch (Exception e) {
            LOGGER.error("Failed to preview export structure", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Export recorded test from a recording session.
     * 
     * @param sessionId ID of the recording session
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the exported recorded test
     */
    @GetMapping("/recording/{sessionId}")
    public ResponseEntity<Resource> exportRecordedTest(
            @PathVariable String sessionId,
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Exporting recorded test from session: {} for framework: {}, language: {}, test type: {}", 
                sessionId, frameworkType, languageType, testType);
        
        try {
            // Export recorded test
            ExportResult result = exportService.exportRecordedTest(
                    sessionId, frameworkType, languageType, testType);
            
            if (result == null || result.getExportedContent() == null) {
                LOGGER.warn("Failed to export recorded test from session: {}", sessionId);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=recorded_test_" + sessionId + ".zip");
            headers.add(HttpHeaders.CONTENT_TYPE, "application/zip");
            
            // Create resource from exported content
            ByteArrayResource resource = new ByteArrayResource(result.getExportedContent());
            
            LOGGER.info("Recorded test exported successfully from session: {}", sessionId);
            return ResponseEntity.ok()
                    .headers(headers)
                    .contentLength(result.getExportedContent().length)
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .body(resource);
        } catch (Exception e) {
            LOGGER.error("Failed to export recorded test from session: {}", sessionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Export execution environment configuration.
     * 
     * @param projectId ID of the project
     * @param environmentName Name of the environment
     * @param format Export format
     * @return ResponseEntity with the exported environment configuration
     */
    @GetMapping("/environment/{projectId}/{environmentName}")
    public ResponseEntity<Resource> exportEnvironmentConfig(
            @PathVariable String projectId,
            @PathVariable String environmentName,
            @RequestParam(value = "format", defaultValue = "JSON") ExportFormat format) {
        
        LOGGER.info("Exporting environment configuration for project: {}, environment: {}, format: {}", 
                projectId, environmentName, format);
        
        try {
            // Export environment configuration
            byte[] environmentConfig = exportService.exportEnvironmentConfig(
                    projectId, environmentName, format);
            
            if (environmentConfig == null) {
                LOGGER.warn("Failed to export environment configuration for project: {}, environment: {}", 
                        projectId, environmentName);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=environment_" + environmentName + getFileExtension(format));
            
            // Set content type based on format
            MediaType contentType = getContentType(format);
            
            // Create resource from environment configuration
            ByteArrayResource resource = new ByteArrayResource(environmentConfig);
            
            LOGGER.info("Environment configuration exported successfully for project: {}, environment: {}", 
                    projectId, environmentName);
            return ResponseEntity.ok()
                    .headers(headers)
                    .contentLength(environmentConfig.length)
                    .contentType(contentType)
                    .body(resource);
        } catch (Exception e) {
            LOGGER.error("Failed to export environment configuration for project: {}, environment: {}", 
                    projectId, environmentName, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Export as Docker container project.
     * 
     * @param exportRequest Export request details
     * @return ResponseEntity with the exported Docker container project
     */
    @PostMapping("/docker")
    public ResponseEntity<Resource> exportAsDocker(@RequestBody ExportRequest exportRequest) {
        LOGGER.info("Exporting as Docker container project for project: {}, framework: {}, language: {}, test type: {}", 
                exportRequest.getProjectId(), exportRequest.getFrameworkType(), 
                exportRequest.getLanguageType(), exportRequest.getTestType());
        
        try {
            // Validate request
            if (exportRequest.getProjectId() == null || exportRequest.getProjectId().isEmpty()) {
                return ResponseEntity.badRequest().build();
            }
            
            if (exportRequest.getFrameworkType() == null || 
                exportRequest.getLanguageType() == null ||
                exportRequest.getTestType() == null) {
                return ResponseEntity.badRequest().build();
            }
            
            // Set export ID if not provided
            if (exportRequest.getExportId() == null || exportRequest.getExportId().isEmpty()) {
                exportRequest.setExportId(UUID.randomUUID().toString());
            }
            
            // Set export time
            exportRequest.setExportTime(CSDateUtils.getCurrentTimestamp());
            
            // Export as Docker container project
            ExportResult result = exportService.exportAsDocker(exportRequest);
            
            if (result == null || result.getExportedContent() == null) {
                LOGGER.warn("Failed to export as Docker container project for project: {}", 
                        exportRequest.getProjectId());
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
            
            // Prepare headers
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=docker_export_" + exportRequest.getProjectId() + ".zip");
            headers.add(HttpHeaders.CONTENT_TYPE, "application/zip");
            
            // Create resource from exported content
            ByteArrayResource resource = new ByteArrayResource(result.getExportedContent());
            
            LOGGER.info("Docker container project exported successfully for project: {}", 
                    exportRequest.getProjectId());
            return ResponseEntity.ok()
                    .headers(headers)
                    .contentLength(result.getExportedContent().length)
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .body(resource);
        } catch (Exception e) {
            LOGGER.error("Failed to export as Docker container project for project: {}", 
                    exportRequest.getProjectId(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get file extension for a format.
     * 
     * @param format Export format
     * @return File extension
     */
    private String getFileExtension(ExportFormat format) {
        switch (format) {
            case JSON:
                return ".json";
            case XML:
                return ".xml";
            case YAML:
                return ".yaml";
            case PROPERTIES:
                return ".properties";
            case CSV:
                return ".csv";
            case EXCEL:
                return ".xlsx";
            case HTML:
                return ".html";
            case PDF:
                return ".pdf";
            case ZIP:
            default:
                return ".zip";
        }
    }
    
    /**
     * Get content type for a format.
     * 
     * @param format Export format
     * @return MediaType
     */
    private MediaType getContentType(ExportFormat format) {
        switch (format) {
            case JSON:
                return MediaType.APPLICATION_JSON;
            case XML:
                return MediaType.APPLICATION_XML;
            case YAML:
                return MediaType.parseMediaType("application/yaml");
            case PROPERTIES:
                return MediaType.TEXT_PLAIN;
            case CSV:
                return MediaType.parseMediaType("text/csv");
            case EXCEL:
                return MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            case HTML:
                return MediaType.TEXT_HTML;
            case PDF:
                return MediaType.APPLICATION_PDF;
            case ZIP:
            default:
                return MediaType.APPLICATION_OCTET_STREAM;
        }
    }
    
    /**
     * Get pipeline file name.
     * 
     * @param pipelineType Pipeline type
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return Pipeline file name
     */
    private String getPipelineFileName(
            PipelineType pipelineType,
            FrameworkType frameworkType,
            LanguageType languageType,
            TestType testType) {
        
        String frameworkName = frameworkType.name().toLowerCase();
        String languageName = languageType.name().toLowerCase();
        String testTypeName = testType.name().toLowerCase();
        
        switch (pipelineType) {
            case AZURE_DEVOPS:
                return "azure-pipelines.yml";
            case GITHUB_ACTIONS:
                return "github-workflow.yml";
            case JENKINS:
                return "Jenkinsfile";
            case GITLAB_CI:
                return "gitlab-ci.yml";
            case CIRCLE_CI:
                return "circle-ci.yml";
            case TRAVIS_CI:
                return "travis.yml";
            case BITBUCKET_PIPELINES:
                return "bitbucket-pipelines.yml";
            case TEAMCITY:
                return "teamcity-settings.kts";
            case BAMBOO:
                return "bamboo-specs.yaml";
            default:
                return String.format("pipeline-%s-%s-%s.yml", 
                        frameworkName, languageName, testTypeName);
        }
    }
    
    /**
     * Get content type for a pipeline.
     * 
     * @param pipelineType Pipeline type
     * @return MediaType
     */
    private MediaType getContentTypeForPipeline(PipelineType pipelineType) {
        switch (pipelineType) {
            case JENKINS:
                return MediaType.TEXT_PLAIN;
            case TEAMCITY:
                return MediaType.TEXT_PLAIN;
            default:
                return MediaType.parseMediaType("application/yaml");
        }
    }
}


ActionController.java
----------------------------------------------

  package com.cstestforge.controller;

import com.cstestforge.model.action.ActionType;
import com.cstestforge.model.action.ActionConfig;
import com.cstestforge.model.action.ConditionalActionConfig;
import com.cstestforge.model.action.LoopActionConfig;
import com.cstestforge.model.action.DataProviderActionConfig;
import com.cstestforge.model.action.WaitActionConfig;
import com.cstestforge.model.action.AssertionActionConfig;
import com.cstestforge.model.action.CustomActionConfig;
import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;
import com.cstestforge.service.action.ActionService;
import com.cstestforge.framework.core.utils.CSLogger;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.stream.Collectors;
import java.util.UUID;

/**
 * Controller for action operations.
 * This controller provides endpoints for action configuration and processing.
 */
@RestController
@RequestMapping("/api/action")
public class ActionController {

    private static final CSLogger LOGGER = new CSLogger(ActionController.class);
    
    private final ActionService actionService;
    
    @Autowired
    public ActionController(ActionService actionService) {
        this.actionService = actionService;
    }
    
    /**
     * Get all supported action types.
     * 
     * @param frameworkType Optional framework type filter
     * @param languageType Optional language type filter
     * @param testType Optional test type filter
     * @return ResponseEntity with the list of action types
     */
    @GetMapping("/types")
    public ResponseEntity<List<Map<String, Object>>> getActionTypes(
            @RequestParam(value = "framework", required = false) FrameworkType frameworkType,
            @RequestParam(value = "language", required = false) LanguageType languageType,
            @RequestParam(value = "testType", required = false) TestType testType) {
        
        LOGGER.info("Getting action types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            List<ActionType> actionTypes = actionService.getSupportedActionTypes(
                    frameworkType, languageType, testType);
            
            List<Map<String, Object>> actionTypeInfoList = actionTypes.stream()
                    .map(type -> {
                        Map<String, Object> actionTypeInfo = new HashMap<>();
                        actionTypeInfo.put("id", type.name());
                        actionTypeInfo.put("name", getActionTypeDisplayName(type));
                        actionTypeInfo.put("description", getActionTypeDescription(type));
                        actionTypeInfo.put("category", getActionTypeCategory(type));
                        actionTypeInfo.put("configClass", getActionConfigClass(type).getSimpleName());
                        
                        return actionTypeInfo;
                    })
                    .collect(Collectors.toList());
            
            return ResponseEntity.ok(actionTypeInfoList);
        } catch (Exception e) {
            LOGGER.error("Failed to get action types", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get action configuration schema for a specific action type.
     * 
     * @param actionType Action type
     * @return ResponseEntity with the action configuration schema
     */
    @GetMapping("/schema/{actionType}")
    public ResponseEntity<Map<String, Object>> getActionSchema(@PathVariable ActionType actionType) {
        LOGGER.info("Getting action schema for action type: {}", actionType);
        
        try {
            Map<String, Object> schema = actionService.getActionConfigSchema(actionType);
            
            return ResponseEntity.ok(schema);
        } catch (Exception e) {
            LOGGER.error("Failed to get action schema for action type: {}", actionType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Validate action configuration.
     * 
     * @param actionConfig Action configuration to validate
     * @return ResponseEntity with the validation result
     */
    @PostMapping("/validate")
    public ResponseEntity<Map<String, Object>> validateActionConfig(@RequestBody ActionConfig actionConfig) {
        LOGGER.info("Validating action configuration for action type: {}", actionConfig.getActionType());
        
        try {
            List<String> validationErrors = actionService.validateActionConfig(actionConfig);
            
            Map<String, Object> result = new HashMap<>();
            result.put("actionType", actionConfig.getActionType());
            result.put("valid", validationErrors.isEmpty());
            
            if (!validationErrors.isEmpty()) {
                result.put("errors", validationErrors);
            }
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            LOGGER.error("Failed to validate action configuration for action type: {}", 
                    actionConfig.getActionType(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "actionType", actionConfig.getActionType(),
                            "valid", false,
                            "error", "Failed to validate action configuration: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get action preview (generated code preview).
     * 
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the action preview
     */
    @PostMapping("/preview")
    public ResponseEntity<Map<String, Object>> getActionPreview(
            @RequestBody ActionConfig actionConfig,
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Getting action preview for action type: {}, framework: {}, language: {}, test type: {}", 
                actionConfig.getActionType(), frameworkType, languageType, testType);
        
        try {
            String generatedCode = actionService.generateActionCode(
                    actionConfig, frameworkType, languageType, testType);
            
            Map<String, Object> preview = new HashMap<>();
            preview.put("actionType", actionConfig.getActionType());
            preview.put("frameworkType", frameworkType);
            preview.put("languageType", languageType);
            preview.put("testType", testType);
            preview.put("generatedCode", generatedCode);
            
            return ResponseEntity.ok(preview);
        } catch (Exception e) {
            LOGGER.error("Failed to get action preview for action type: {}, framework: {}, language: {}, test type: {}", 
                    actionConfig.getActionType(), frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "actionType", actionConfig.getActionType(),
                            "error", "Failed to get action preview: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get action templates for a specific action type.
     * 
     * @param actionType Action type
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the list of action templates
     */
    @GetMapping("/templates/{actionType}")
    public ResponseEntity<List<ActionConfig>> getActionTemplates(
            @PathVariable ActionType actionType,
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Getting action templates for action type: {}, framework: {}, language: {}, test type: {}", 
                actionType, frameworkType, languageType, testType);
        
        try {
            List<ActionConfig> templates = actionService.getActionTemplates(
                    actionType, frameworkType, languageType, testType);
            
            return ResponseEntity.ok(templates);
        } catch (Exception e) {
            LOGGER.error("Failed to get action templates for action type: {}, framework: {}, language: {}, test type: {}", 
                    actionType, frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Create a custom action template.
     * 
     * @param actionConfig Action configuration template
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @param name Template name
     * @param description Template description
     * @return ResponseEntity with the created template
     */
    @PostMapping("/templates")
    public ResponseEntity<ActionConfig> createActionTemplate(
            @RequestBody ActionConfig actionConfig,
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType,
            @RequestParam("name") String name,
            @RequestParam(value = "description", required = false) String description) {
        
        LOGGER.info("Creating action template for action type: {}, framework: {}, language: {}, test type: {}, name: {}", 
                actionConfig.getActionType(), frameworkType, languageType, testType, name);
        
        try {
            // Validate template
            List<String> validationErrors = actionService.validateActionConfig(actionConfig);
            if (!validationErrors.isEmpty()) {
                LOGGER.warn("Invalid action configuration for template: {}", name);
                return ResponseEntity.badRequest().build();
            }
            
            // Set template metadata
            actionConfig.setTemplateName(name);
            actionConfig.setTemplateDescription(description);
            actionConfig.setFrameworkType(frameworkType);
            actionConfig.setLanguageType(languageType);
            actionConfig.setTestType(testType);
            
            // Create template
            ActionConfig createdTemplate = actionService.createActionTemplate(actionConfig);
            
            if (createdTemplate != null) {
                LOGGER.info("Action template created: {}", name);
                return ResponseEntity.status(HttpStatus.CREATED).body(createdTemplate);
            } else {
                LOGGER.warn("Failed to create action template: {}", name);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to create action template for action type: {}, name: {}", 
                    actionConfig.getActionType(), name, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Delete an action template.
     * 
     * @param templateId ID of the template to delete
     * @return ResponseEntity with the result
     */
    @DeleteMapping("/templates/{templateId}")
    public ResponseEntity<Map<String, Object>> deleteActionTemplate(@PathVariable String templateId) {
        LOGGER.info("Deleting action template: {}", templateId);
        
        try {
            boolean deleted = actionService.deleteActionTemplate(templateId);
            
            if (deleted) {
                LOGGER.info("Action template deleted: {}", templateId);
                return ResponseEntity.ok(Map.of(
                        "templateId", templateId,
                        "deleted", true,
                        "message", "Action template deleted successfully"
                ));
            } else {
                LOGGER.warn("Action template not found: {}", templateId);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to delete action template: {}", templateId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "templateId", templateId,
                            "deleted", false,
                            "error", "Failed to delete action template: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get available assertion types.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the list of assertion types
     */
    @GetMapping("/assertions")
    public ResponseEntity<List<Map<String, Object>>> getAssertionTypes(
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Getting assertion types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            List<Map<String, Object>> assertionTypes = actionService.getAssertionTypes(
                    frameworkType, languageType, testType);
            
            return ResponseEntity.ok(assertionTypes);
        } catch (Exception e) {
            LOGGER.error("Failed to get assertion types for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get available wait strategies.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the list of wait strategies
     */
    @GetMapping("/waitstrategies")
    public ResponseEntity<List<Map<String, Object>>> getWaitStrategies(
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Getting wait strategies for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            List<Map<String, Object>> waitStrategies = actionService.getWaitStrategies(
                    frameworkType, languageType, testType);
            
            return ResponseEntity.ok(waitStrategies);
        } catch (Exception e) {
            LOGGER.error("Failed to get wait strategies for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Execute a custom JavaScript action.
     * 
     * @param executionId ID of the test execution
     * @param script JavaScript code to execute
     * @return ResponseEntity with the execution result
     */
    @PostMapping("/execute/javascript/{executionId}")
    public ResponseEntity<Map<String, Object>> executeJavaScript(
            @PathVariable String executionId,
            @RequestBody String script) {
        
        LOGGER.info("Executing JavaScript in test execution: {}", executionId);
        
        try {
            Map<String, Object> result = actionService.executeJavaScript(executionId, script);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            LOGGER.error("Failed to execute JavaScript in test execution: {}", executionId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "executionId", executionId,
                            "error", "Failed to execute JavaScript: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get available data provider types.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the list of data provider types
     */
    @GetMapping("/dataproviders")
    public ResponseEntity<List<Map<String, Object>>> getDataProviderTypes(
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Getting data provider types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            List<Map<String, Object>> dataProviderTypes = actionService.getDataProviderTypes(
                    frameworkType, languageType, testType);
            
            return ResponseEntity.ok(dataProviderTypes);
        } catch (Exception e) {
            LOGGER.error("Failed to get data provider types for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Preview data from a data provider configuration.
     * 
     * @param dataProviderConfig Data provider configuration
     * @return ResponseEntity with the data preview
     */
    @PostMapping("/dataprovider/preview")
    public ResponseEntity<Map<String, Object>> previewDataProvider(
            @RequestBody DataProviderActionConfig dataProviderConfig) {
        
        LOGGER.info("Previewing data provider: {}", dataProviderConfig.getDataSourceType());
        
        try {
            List<Map<String, Object>> dataPreview = actionService.previewDataProvider(dataProviderConfig);
            
            Map<String, Object> result = new HashMap<>();
            result.put("dataSourceType", dataProviderConfig.getDataSourceType());
            result.put("dataPreview", dataPreview);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            LOGGER.error("Failed to preview data provider: {}", dataProviderConfig.getDataSourceType(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "dataSourceType", dataProviderConfig.getDataSourceType(),
                            "error", "Failed to preview data provider: " + e.getMessage()
                    ));
        }
    }
    
    /**
     * Get action code snippet for an action configuration.
     * 
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the code snippet
     */
    @PostMapping("/snippet")
    public ResponseEntity<Map<String, String>> getActionCodeSnippet(
            @RequestBody ActionConfig actionConfig,
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Getting code snippet for action type: {}, framework: {}, language: {}, test type: {}", 
                actionConfig.getActionType(), frameworkType, languageType, testType);
        
        try {
            String codeSnippet = actionService.generateActionCode(
                    actionConfig, frameworkType, languageType, testType);
            
            return ResponseEntity.ok(Map.of("code", codeSnippet));
        } catch (Exception e) {
            LOGGER.error("Failed to get code snippet for action type: {}, framework: {}, language: {}, test type: {}", 
                    actionConfig.getActionType(), frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to get code snippet: " + e.getMessage()));
        }
    }
    
    /**
     * Get supported conditional operators.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the list of conditional operators
     */
    @GetMapping("/conditionals/operators")
    public ResponseEntity<List<Map<String, Object>>> getConditionalOperators(
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Getting conditional operators for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            List<Map<String, Object>> operators = actionService.getConditionalOperators(
                    frameworkType, languageType, testType);
            
            return ResponseEntity.ok(operators);
        } catch (Exception e) {
            LOGGER.error("Failed to get conditional operators for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get supported loop types.
     * 
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ResponseEntity with the list of loop types
     */
    @GetMapping("/loops/types")
    public ResponseEntity<List<Map<String, Object>>> getLoopTypes(
            @RequestParam("framework") FrameworkType frameworkType,
            @RequestParam("language") LanguageType languageType,
            @RequestParam("testType") TestType testType) {
        
        LOGGER.info("Getting loop types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        try {
            List<Map<String, Object>> loopTypes = actionService.getLoopTypes(
                    frameworkType, languageType, testType);
            
            return ResponseEntity.ok(loopTypes);
        } catch (Exception e) {
            LOGGER.error("Failed to get loop types for framework: {}, language: {}, test type: {}", 
                    frameworkType, languageType, testType, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Get display name for an action type.
     * 
     * @param actionType Action type
     * @return Display name
     */
    private String getActionTypeDisplayName(ActionType actionType) {
        switch (actionType) {
            case CLICK:
                return "Click";
            case TYPE:
                return "Type Text";
            case SELECT:
                return "Select Option";
            case ASSERT:
                return "Assertion";
            case WAIT:
                return "Wait";
            case NAVIGATE:
                return "Navigate";
            case CONDITIONAL:
                return "Conditional";
            case LOOP:
                return "Loop";
            case DATA_PROVIDER:
                return "Data Provider";
            case CUSTOM:
                return "Custom Action";
            case VARIABLE:
                return "Variable";
            case SCREENSHOT:
                return "Screenshot";
            case HOVER:
                return "Hover";
            case DRAG_DROP:
                return "Drag and Drop";
            case SWITCH_FRAME:
                return "Switch Frame";
            case SWITCH_WINDOW:
                return "Switch Window";
            case EXECUTE_SCRIPT:
                return "Execute Script";
            case FILE_UPLOAD:
                return "File Upload";
            case KEY_PRESS:
                return "Key Press";
            case SCROLL:
                return "Scroll";
            default:
                return actionType.name();
        }
    }
    
    /**
     * Get description for an action type.
     * 
     * @param actionType Action type
     * @return Description
     */
    private String getActionTypeDescription(ActionType actionType) {
        switch (actionType) {
            case CLICK:
                return "Click on an element";
            case TYPE:
                return "Type text into an input field";
            case SELECT:
                return "Select an option from a dropdown";
            case ASSERT:
                return "Verify conditions or element states";
            case WAIT:
                return "Wait for a condition to be met";
            case NAVIGATE:
                return "Navigate to a URL";
            case CONDITIONAL:
                return "Execute actions conditionally";
            case LOOP:
                return "Repeat actions multiple times";
            case DATA_PROVIDER:
                return "Supply test data from external sources";
            case CUSTOM:
                return "Execute custom code";
            case VARIABLE:
                return "Define and manipulate variables";
            case SCREENSHOT:
                return "Capture screenshot";
            case HOVER:
                return "Mouse over an element";
            case DRAG_DROP:
                return "Drag and drop elements";
            case SWITCH_FRAME:
                return "Switch to a different frame or iframe";
            case SWITCH_WINDOW:
                return "Switch to a different window or tab";
            case EXECUTE_SCRIPT:
                return "Execute JavaScript code";
            case FILE_UPLOAD:
                return "Upload a file";
            case KEY_PRESS:
                return "Press keyboard keys";
            case SCROLL:
                return "Scroll the page or within an element";
            default:
                return "Unknown action type";
        }
    }
    
    /**
     * Get category for an action type.
     * 
     * @param actionType Action type
     * @return Category
     */
    private String getActionTypeCategory(ActionType actionType) {
        switch (actionType) {
            case CLICK:
            case TYPE:
            case SELECT:
            case HOVER:
            case DRAG_DROP:
            case KEY_PRESS:
            case SCROLL:
            case FILE_UPLOAD:
                return "Interaction";
            case ASSERT:
                return "Verification";
            case WAIT:
                return "Synchronization";
            case NAVIGATE:
            case SWITCH_FRAME:
            case SWITCH_WINDOW:
                return "Navigation";
            case CONDITIONAL:
            case LOOP:
            case VARIABLE:
                return "Control Flow";
            case DATA_PROVIDER:
                return "Data Management";
            case CUSTOM:
            case EXECUTE_SCRIPT:
                return "Advanced";
            case SCREENSHOT:
                return "Utility";
            default:
                return "Other";
        }
    }
    
    /**
     * Get configuration class for an action type.
     * 
     * @param actionType Action type
     * @return Configuration class
     */
    private Class<? extends ActionConfig> getActionConfigClass(ActionType actionType) {
        switch (actionType) {
            case CONDITIONAL:
                return ConditionalActionConfig.class;
            case LOOP:
                return LoopActionConfig.class;
            case DATA_PROVIDER:
                return DataProviderActionConfig.class;
            case WAIT:
                return WaitActionConfig.class;
            case ASSERT:
                return AssertionActionConfig.class;
            case CUSTOM:
                return CustomActionConfig.class;
            default:
                return ActionConfig.class;
        }
    }
}



WebSocketConfig.java
---------------------------------------------------

  package com.cstestforge.service.websocket;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
import org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean;
import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;

import com.cstestforge.framework.core.utils.CSLogger;

/**
 * WebSocket configuration for real-time communication.
 * This class configures WebSocket endpoints, handlers, and settings
 * for the CSTestForge framework's real-time features.
 */
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    private static final CSLogger LOGGER = new CSLogger(WebSocketConfig.class);
    
    @Value("${cstestforge.websocket.max-text-message-size:65536}")
    private int maxTextMessageSize;
    
    @Value("${cstestforge.websocket.max-binary-message-size:1048576}")
    private int maxBinaryMessageSize;
    
    @Value("${cstestforge.websocket.idle-timeout:600000}")
    private int idleTimeout;
    
    @Value("${cstestforge.websocket.async-send-timeout:30000}")
    private int asyncSendTimeout;
    
    private final com.cstestforge.service.websocket.WebSocketHandler webSocketHandler;
    private final AuthenticationHandler authenticationHandler;
    
    @Autowired
    public WebSocketConfig(
            com.cstestforge.service.websocket.WebSocketHandler webSocketHandler,
            AuthenticationHandler authenticationHandler) {
        this.webSocketHandler = webSocketHandler;
        this.authenticationHandler = authenticationHandler;
    }
    
    /**
     * Register WebSocket handlers with their respective endpoints.
     * 
     * @param registry WebSocket handler registry
     */
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        LOGGER.info("Registering WebSocket handlers");
        
        // Register handler for execution updates
        registry.addHandler(webSocketHandler, "/ws/execution")
                .addInterceptors(new HttpSessionHandshakeInterceptor())
                .addInterceptors(authenticationHandler)
                .setAllowedOrigins("*");
        
        // Register handler for recorder updates
        registry.addHandler(webSocketHandler, "/ws/recorder")
                .addInterceptors(new HttpSessionHandshakeInterceptor())
                .addInterceptors(authenticationHandler)
                .setAllowedOrigins("*");
        
        // Register handler for resource monitoring
        registry.addHandler(webSocketHandler, "/ws/resources")
                .addInterceptors(new HttpSessionHandshakeInterceptor())
                .addInterceptors(authenticationHandler)
                .setAllowedOrigins("*");
        
        // Register handler for notifications
        registry.addHandler(webSocketHandler, "/ws/notifications")
                .addInterceptors(new HttpSessionHandshakeInterceptor())
                .addInterceptors(authenticationHandler)
                .setAllowedOrigins("*");
        
        LOGGER.info("WebSocket handlers registered");
    }
    
    /**
     * Configure WebSocket container settings.
     * 
     * @return ServletServerContainerFactoryBean with configured settings
     */
    @Bean
    public ServletServerContainerFactoryBean createWebSocketContainer() {
        LOGGER.info("Configuring WebSocket container with: maxTextMessageSize={}, maxBinaryMessageSize={}, idleTimeout={}, asyncSendTimeout={}",
                maxTextMessageSize, maxBinaryMessageSize, idleTimeout, asyncSendTimeout);
        
        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
        
        // Set maximum text message buffer size
        container.setMaxTextMessageBufferSize(maxTextMessageSize);
        
        // Set maximum binary message buffer size
        container.setMaxBinaryMessageBufferSize(maxBinaryMessageSize);
        
        // Set idle timeout for WebSocket connections
        container.setMaxSessionIdleTimeout(idleTimeout);
        
        // Set asynchronous send timeout
        container.setAsyncSendTimeout(asyncSendTimeout);
        
        return container;
    }
    
    /**
     * Configure heartbeat service for keeping WebSocket connections alive.
     * 
     * @return HeartbeatService bean
     */
    @Bean
    public HeartbeatService heartbeatService() {
        LOGGER.info("Initializing heartbeat service");
        return new HeartbeatServiceImpl();
    }
    
    /**
     * Configure session registry for tracking active WebSocket sessions.
     * 
     * @return SessionRegistry bean
     */
    @Bean
    public SessionRegistry sessionRegistry() {
        LOGGER.info("Initializing session registry");
        return new SessionRegistryImpl();
    }
    
    /**
     * Configure message publisher for sending messages to clients.
     * 
     * @param sessionRegistry Session registry for tracking active sessions
     * @return MessagePublisher bean
     */
    @Bean
    public MessagePublisher messagePublisher(SessionRegistry sessionRegistry) {
        LOGGER.info("Initializing message publisher");
        return new MessagePublisherImpl(sessionRegistry);
    }
    
    /**
     * Configure binary message handler for processing binary WebSocket messages.
     * 
     * @return BinaryMessageHandler bean
     */
    @Bean
    public BinaryMessageHandler binaryMessageHandler() {
        LOGGER.info("Initializing binary message handler");
        return new BinaryMessageHandlerImpl();
    }
    
    /**
     * Configure text message handler for processing text WebSocket messages.
     * 
     * @return TextMessageHandler bean
     */
    @Bean
    public TextMessageHandler textMessageHandler() {
        LOGGER.info("Initializing text message handler");
        return new TextMessageHandlerImpl();
    }
    
    /**
     * Configure message serializer for serializing messages for transmission.
     * 
     * @return MessageSerializer bean
     */
    @Bean
    public MessageSerializer messageSerializer() {
        LOGGER.info("Initializing message serializer");
        return new MessageSerializerImpl();
    }
    
    /**
     * Configure message deserializer for deserializing received messages.
     * 
     * @return MessageDeserializer bean
     */
    @Bean
    public MessageDeserializer messageDeserializer() {
        LOGGER.info("Initializing message deserializer");
        return new MessageDeserializerImpl();
    }
    
    /**
     * Configure message router for routing messages to appropriate handlers.
     * 
     * @param messageHandlers List of message handlers
     * @return MessageRouter bean
     */
    @Bean
    public MessageRouter messageRouter(List<MessageHandler> messageHandlers) {
        LOGGER.info("Initializing message router with {} message handlers", messageHandlers.size());
        return new MessageRouterImpl(messageHandlers);
    }
}



WebSocketHandler.java
-----------------------------------

  package com.cstestforge.service.websocket;

import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.BinaryMessage;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.AbstractWebSocketHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;

/**
 * Handler for WebSocket connections and messages.
 * This class manages WebSocket sessions and handles incoming messages.
 */
@Component
public class WebSocketHandler extends AbstractWebSocketHandler {

    private static final CSLogger LOGGER = new CSLogger(WebSocketHandler.class);
    
    private final SessionRegistry sessionRegistry;
    private final MessagePublisher messagePublisher;
    private final TextMessageHandler textMessageHandler;
    private final BinaryMessageHandler binaryMessageHandler;
    private final MessageDeserializer messageDeserializer;
    private final MessageRouter messageRouter;
    private final HeartbeatService heartbeatService;
    
    @Autowired
    public WebSocketHandler(
            SessionRegistry sessionRegistry,
            MessagePublisher messagePublisher,
            TextMessageHandler textMessageHandler,
            BinaryMessageHandler binaryMessageHandler,
            MessageDeserializer messageDeserializer,
            MessageRouter messageRouter,
            HeartbeatService heartbeatService) {
        
        this.sessionRegistry = sessionRegistry;
        this.messagePublisher = messagePublisher;
        this.textMessageHandler = textMessageHandler;
        this.binaryMessageHandler = binaryMessageHandler;
        this.messageDeserializer = messageDeserializer;
        this.messageRouter = messageRouter;
        this.heartbeatService = heartbeatService;
    }
    
    /**
     * Handle connection established event.
     * 
     * @param session WebSocket session
     * @throws Exception if an error occurs
     */
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        String sessionId = session.getId();
        String requestUri = session.getUri().getPath();
        
        LOGGER.info("WebSocket connection established: sessionId={}, uri={}, remoteAddress={}", 
                sessionId, requestUri, session.getRemoteAddress());
        
        // Extract topic from URI path
        String topic = extractTopicFromUri(requestUri);
        
        // Register session
        sessionRegistry.registerSession(sessionId, session, topic);
        
        // Send connection confirmation message
        sendConnectionConfirmation(session, topic);
        
        // Start heartbeat for this session
        heartbeatService.startHeartbeat(sessionId);
        
        // Log active connections count
        LOGGER.info("Active WebSocket connections: {}", sessionRegistry.getSessionCount());
    }
    
    /**
     * Handle text message received event.
     * 
     * @param session WebSocket session
     * @param message Text message
     * @throws Exception if an error occurs
     */
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String sessionId = session.getId();
        String payload = message.getPayload();
        
        LOGGER.debug("Text message received from session {}: {} bytes", sessionId, payload.length());
        
        try {
            // Deserialize message
            WebSocketMessage socketMessage = messageDeserializer.deserializeTextMessage(payload);
            
            // Handle heartbeat response
            if (socketMessage.getType() == MessageType.HEARTBEAT_RESPONSE) {
                heartbeatService.handleHeartbeatResponse(sessionId);
                return;
            }
            
            // Process message
            WebSocketMessage response = textMessageHandler.handleMessage(sessionId, socketMessage);
            
            // Route message to appropriate handler
            messageRouter.routeMessage(session, socketMessage);
            
            // Send response if available
            if (response != null) {
                messagePublisher.sendMessage(sessionId, response);
            }
        } catch (Exception e) {
            LOGGER.error("Error processing text message from session {}: {}", sessionId, e.getMessage(), e);
            sendErrorResponse(session, e.getMessage());
        }
    }
    
    /**
     * Handle binary message received event.
     * 
     * @param session WebSocket session
     * @param message Binary message
     * @throws Exception if an error occurs
     */
    @Override
    protected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) throws Exception {
        String sessionId = session.getId();
        ByteBuffer payload = message.getPayload();
        
        LOGGER.debug("Binary message received from session {}: {} bytes", sessionId, payload.remaining());
        
        try {
            // Deserialize message
            WebSocketMessage socketMessage = messageDeserializer.deserializeBinaryMessage(payload);
            
            // Process message
            WebSocketMessage response = binaryMessageHandler.handleMessage(sessionId, socketMessage, payload);
            
            // Route message to appropriate handler
            messageRouter.routeMessage(session, socketMessage);
            
            // Send response if available
            if (response != null) {
                messagePublisher.sendMessage(sessionId, response);
            }
        } catch (Exception e) {
            LOGGER.error("Error processing binary message from session {}: {}", sessionId, e.getMessage(), e);
            sendErrorResponse(session, e.getMessage());
        }
    }
    
    /**
     * Handle connection closed event.
     * 
     * @param session WebSocket session
     * @param status Close status
     * @throws Exception if an error occurs
     */
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        String sessionId = session.getId();
        
        LOGGER.info("WebSocket connection closed: sessionId={}, status={}, reason={}", 
                sessionId, status.getCode(), status.getReason());
        
        // Unregister session
        sessionRegistry.unregisterSession(sessionId);
        
        // Stop heartbeat for this session
        heartbeatService.stopHeartbeat(sessionId);
        
        // Log active connections count
        LOGGER.info("Active WebSocket connections: {}", sessionRegistry.getSessionCount());
    }
    
    /**
     * Handle transport error event.
     * 
     * @param session WebSocket session
     * @param exception Transport error
     * @throws Exception if an error occurs
     */
    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        String sessionId = session.getId();
        
        LOGGER.error("WebSocket transport error for session {}: {}", sessionId, exception.getMessage(), exception);
        
        // Check if session is still open
        if (session.isOpen()) {
            try {
                // Send error message
                sendErrorResponse(session, "Transport error: " + exception.getMessage());
                
                // Close session with error status
                session.close(CloseStatus.SERVER_ERROR);
            } catch (IOException e) {
                LOGGER.error("Error closing WebSocket session {}: {}", sessionId, e.getMessage(), e);
            }
        }
        
        // Ensure session is unregistered
        sessionRegistry.unregisterSession(sessionId);
        
        // Stop heartbeat for this session
        heartbeatService.stopHeartbeat(sessionId);
    }
    
    /**
     * Handle error with WebSocket session.
     * 
     * @param session WebSocket session
     * @param message Error message
     */
    private void sendErrorResponse(WebSocketSession session, String message) {
        try {
            WebSocketMessage errorMessage = new WebSocketMessage();
            errorMessage.setType(MessageType.ERROR);
            errorMessage.setPayload(Map.of("error", message));
            
            String serialized = messageDeserializer.serializeMessage(errorMessage);
            session.sendMessage(new TextMessage(serialized));
        } catch (IOException e) {
            LOGGER.error("Error sending error response to session {}: {}", 
                    session.getId(), e.getMessage(), e);
        }
    }
    
    /**
     * Extract topic from URI path.
     * 
     * @param uri URI path
     * @return Topic name
     */
    private String extractTopicFromUri(String uri) {
        // Extract the last part of the URI path as the topic
        String[] parts = uri.split("/");
        return parts.length > 0 ? parts[parts.length - 1] : "unknown";
    }
    
    /**
     * Send connection confirmation message.
     * 
     * @param session WebSocket session
     * @param topic Topic name
     */
    private void sendConnectionConfirmation(WebSocketSession session, String topic) {
        try {
            WebSocketMessage confirmationMessage = new WebSocketMessage();
            confirmationMessage.setType(MessageType.CONNECTION_ESTABLISHED);
            confirmationMessage.setPayload(Map.of(
                    "sessionId", session.getId(),
                    "topic", topic,
                    "timestamp", System.currentTimeMillis()
            ));
            
            String serialized = messageDeserializer.serializeMessage(confirmationMessage);
            session.sendMessage(new TextMessage(serialized));
        } catch (IOException e) {
            LOGGER.error("Error sending connection confirmation to session {}: {}", 
                    session.getId(), e.getMessage(), e);
        }
    }
}


SessionRegistry.java
--------------------------------------------

  package com.cstestforge.service.websocket;

import org.springframework.web.socket.WebSocketSession;

import java.util.Set;
import java.util.Map;

/**
 * Registry for tracking active WebSocket sessions.
 * This interface defines methods for registering, retrieving,
 * and unregistering WebSocket sessions.
 */
public interface SessionRegistry {
    
    /**
     * Register a new WebSocket session.
     * 
     * @param sessionId ID of the session
     * @param session WebSocket session
     * @param topic Topic the session is subscribed to
     */
    void registerSession(String sessionId, WebSocketSession session, String topic);
    
    /**
     * Register a new WebSocket session with a specific execution ID.
     * 
     * @param sessionId ID of the session
     * @param session WebSocket session
     * @param topic Topic the session is subscribed to
     * @param executionId ID of the test execution
     */
    void registerSession(String sessionId, WebSocketSession session, String topic, String executionId);
    
    /**
     * Unregister a WebSocket session.
     * 
     * @param sessionId ID of the session to unregister
     * @return True if the session was unregistered, false if it was not found
     */
    boolean unregisterSession(String sessionId);
    
    /**
     * Get a WebSocket session by ID.
     * 
     * @param sessionId ID of the session to retrieve
     * @return WebSocket session, or null if not found
     */
    WebSocketSession getSession(String sessionId);
    
    /**
     * Get all active WebSocket sessions.
     * 
     * @return Map of session IDs to WebSocket sessions
     */
    Map<String, WebSocketSession> getAllSessions();
    
    /**
     * Get all session IDs for sessions subscribed to a specific topic.
     * 
     * @param topic Topic to filter by
     * @return Set of session IDs subscribed to the topic
     */
    Set<String> getSessionIdsByTopic(String topic);
    
    /**
     * Get all session IDs for sessions associated with a specific execution ID.
     * 
     * @param executionId Execution ID to filter by
     * @return Set of session IDs associated with the execution ID
     */
    Set<String> getSessionIdsByExecutionId(String executionId);
    
    /**
     * Get the topic for a specific session.
     * 
     * @param sessionId ID of the session
     * @return Topic the session is subscribed to, or null if not found
     */
    String getSessionTopic(String sessionId);
    
    /**
     * Get the execution ID for a specific session.
     * 
     * @param sessionId ID of the session
     * @return Execution ID associated with the session, or null if not found
     */
    String getSessionExecutionId(String sessionId);
    
    /**
     * Get the number of active sessions.
     * 
     * @return Number of active sessions
     */
    int getSessionCount();
    
    /**
     * Get the number of active sessions for a specific topic.
     * 
     * @param topic Topic to filter by
     * @return Number of active sessions for the topic
     */
    int getSessionCountByTopic(String topic);
    
    /**
     * Get the number of active sessions for a specific execution ID.
     * 
     * @param executionId Execution ID to filter by
     * @return Number of active sessions for the execution ID
     */
    int getSessionCountByExecutionId(String executionId);
    
    /**
     * Check if a session is active.
     * 
     * @param sessionId ID of the session to check
     * @return True if the session is active, false otherwise
     */
    boolean isSessionActive(String sessionId);
    
    /**
     * Associate an execution ID with an existing session.
     * 
     * @param sessionId ID of the session
     * @param executionId Execution ID to associate with the session
     * @return True if the execution ID was associated, false if the session was not found
     */
    boolean associateExecutionId(String sessionId, String executionId);
    
    /**
     * Disassociate an execution ID from a session.
     * 
     * @param sessionId ID of the session
     * @return True if the execution ID was disassociated, false if the session was not found
     */
    boolean disassociateExecutionId(String sessionId);
}


SessionRegistryImpl.java
------------------------------------------------------

  package com.cstestforge.service.websocket;

import org.springframework.stereotype.Component;
import org.springframework.web.socket.WebSocketSession;

import com.cstestforge.framework.core.utils.CSLogger;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.util.Collections;
import java.util.HashSet;

/**
 * Implementation of the SessionRegistry interface.
 * This class provides a thread-safe implementation for tracking
 * active WebSocket sessions.
 */
@Component
public class SessionRegistryImpl implements SessionRegistry {

    private static final CSLogger LOGGER = new CSLogger(SessionRegistryImpl.class);
    
    // Map of session ID to WebSocket session
    private final Map<String, WebSocketSession> sessions = new ConcurrentHashMap<>();
    
    // Map of session ID to topic
    private final Map<String, String> sessionTopics = new ConcurrentHashMap<>();
    
    // Map of session ID to execution ID
    private final Map<String, String> sessionExecutionIds = new ConcurrentHashMap<>();
    
    // Map of topic to set of session IDs
    private final Map<String, Set<String>> topicSessions = new ConcurrentHashMap<>();
    
    // Map of execution ID to set of session IDs
    private final Map<String, Set<String>> executionSessions = new ConcurrentHashMap<>();
    
    /**
     * Register a new WebSocket session.
     * 
     * @param sessionId ID of the session
     * @param session WebSocket session
     * @param topic Topic the session is subscribed to
     */
    @Override
    public void registerSession(String sessionId, WebSocketSession session, String topic) {
        LOGGER.info("Registering WebSocket session: sessionId={}, topic={}", sessionId, topic);
        
        // Register session
        sessions.put(sessionId, session);
        
        // Associate session with topic
        sessionTopics.put(sessionId, topic);
        
        // Add session ID to topic sessions
        topicSessions.computeIfAbsent(topic, k -> ConcurrentHashMap.newKeySet()).add(sessionId);
    }
    
    /**
     * Register a new WebSocket session with a specific execution ID.
     * 
     * @param sessionId ID of the session
     * @param session WebSocket session
     * @param topic Topic the session is subscribed to
     * @param executionId ID of the test execution
     */
    @Override
    public void registerSession(String sessionId, WebSocketSession session, String topic, String executionId) {
        LOGGER.info("Registering WebSocket session: sessionId={}, topic={}, executionId={}", 
                sessionId, topic, executionId);
        
        // Register session with topic
        registerSession(sessionId, session, topic);
        
        // Associate session with execution ID
        sessionExecutionIds.put(sessionId, executionId);
        
        // Add session ID to execution sessions
        executionSessions.computeIfAbsent(executionId, k -> ConcurrentHashMap.newKeySet()).add(sessionId);
    }
    
    /**
     * Unregister a WebSocket session.
     * 
     * @param sessionId ID of the session to unregister
     * @return True if the session was unregistered, false if it was not found
     */
    @Override
    public boolean unregisterSession(String sessionId) {
        LOGGER.info("Unregistering WebSocket session: sessionId={}", sessionId);
        
        // Get topic for session
        String topic = sessionTopics.get(sessionId);
        
        // Get execution ID for session
        String executionId = sessionExecutionIds.get(sessionId);
        
        // Remove session from collections
        WebSocketSession removedSession = sessions.remove(sessionId);
        sessionTopics.remove(sessionId);
        sessionExecutionIds.remove(sessionId);
        
        // Remove session ID from topic sessions
        if (topic != null) {
            Set<String> topicSessionSet = topicSessions.get(topic);
            if (topicSessionSet != null) {
                topicSessionSet.remove(sessionId);
                
                // Remove topic if no sessions remain
                if (topicSessionSet.isEmpty()) {
                    topicSessions.remove(topic);
                }
            }
        }
        
        // Remove session ID from execution sessions
        if (executionId != null) {
            Set<String> executionSessionSet = executionSessions.get(executionId);
            if (executionSessionSet != null) {
                executionSessionSet.remove(sessionId);
                
                // Remove execution ID if no sessions remain
                if (executionSessionSet.isEmpty()) {
                    executionSessions.remove(executionId);
                }
            }
        }
        
        return removedSession != null;
    }
    
    /**
     * Get a WebSocket session by ID.
     * 
     * @param sessionId ID of the session to retrieve
     * @return WebSocket session, or null if not found
     */
    @Override
    public WebSocketSession getSession(String sessionId) {
        return sessions.get(sessionId);
    }
    
    /**
     * Get all active WebSocket sessions.
     * 
     * @return Map of session IDs to WebSocket sessions
     */
    @Override
    public Map<String, WebSocketSession> getAllSessions() {
        return Collections.unmodifiableMap(sessions);
    }
    
    /**
     * Get all session IDs for sessions subscribed to a specific topic.
     * 
     * @param topic Topic to filter by
     * @return Set of session IDs subscribed to the topic
     */
    @Override
    public Set<String> getSessionIdsByTopic(String topic) {
        Set<String> sessionIds = topicSessions.get(topic);
        return sessionIds != null ? Collections.unmodifiableSet(sessionIds) : Collections.emptySet();
    }
    
    /**
     * Get all session IDs for sessions associated with a specific execution ID.
     * 
     * @param executionId Execution ID to filter by
     * @return Set of session IDs associated with the execution ID
     */
    @Override
    public Set<String> getSessionIdsByExecutionId(String executionId) {
        Set<String> sessionIds = executionSessions.get(executionId);
        return sessionIds != null ? Collections.unmodifiableSet(sessionIds) : Collections.emptySet();
    }
    
    /**
     * Get the topic for a specific session.
     * 
     * @param sessionId ID of the session
     * @return Topic the session is subscribed to, or null if not found
     */
    @Override
    public String getSessionTopic(String sessionId) {
        return sessionTopics.get(sessionId);
    }
    
    /**
     * Get the execution ID for a specific session.
     * 
     * @param sessionId ID of the session
     * @return Execution ID associated with the session, or null if not found
     */
    @Override
    public String getSessionExecutionId(String sessionId) {
        return sessionExecutionIds.get(sessionId);
    }
    
    /**
     * Get the number of active sessions.
     * 
     * @return Number of active sessions
     */
    @Override
    public int getSessionCount() {
        return sessions.size();
    }
    
    /**
     * Get the number of active sessions for a specific topic.
     * 
     * @param topic Topic to filter by
     * @return Number of active sessions for the topic
     */
    @Override
    public int getSessionCountByTopic(String topic) {
        Set<String> sessionIds = topicSessions.get(topic);
        return sessionIds != null ? sessionIds.size() : 0;
    }
    
    /**
     * Get the number of active sessions for a specific execution ID.
     * 
     * @param executionId Execution ID to filter by
     * @return Number of active sessions for the execution ID
     */
    @Override
    public int getSessionCountByExecutionId(String executionId) {
        Set<String> sessionIds = executionSessions.get(executionId);
        return sessionIds != null ? sessionIds.size() : 0;
    }
    
    /**
     * Check if a session is active.
     * 
     * @param sessionId ID of the session to check
     * @return True if the session is active, false otherwise
     */
    @Override
    public boolean isSessionActive(String sessionId) {
        return sessions.containsKey(sessionId);
    }
    
    /**
     * Associate an execution ID with an existing session.
     * 
     * @param sessionId ID of the session
     * @param executionId Execution ID to associate with the session
     * @return True if the execution ID was associated, false if the session was not found
     */
    @Override
    public boolean associateExecutionId(String sessionId, String executionId) {
        LOGGER.info("Associating execution ID with session: sessionId={}, executionId={}", 
                sessionId, executionId);
        
        // Check if session exists
        if (!sessions.containsKey(sessionId)) {
            return false;
        }
        
        // Disassociate any existing execution ID
        disassociateExecutionId(sessionId);
        
        // Associate session with execution ID
        sessionExecutionIds.put(sessionId, executionId);
        
        // Add session ID to execution sessions
        executionSessions.computeIfAbsent(executionId, k -> ConcurrentHashMap.newKeySet()).add(sessionId);
        
        return true;
    }
    
    /**
     * Disassociate an execution ID from a session.
     * 
     * @param sessionId ID of the session
     * @return True if the execution ID was disassociated, false if the session was not found
     */
    @Override
    public boolean disassociateExecutionId(String sessionId) {
        // Check if session exists
        if (!sessions.containsKey(sessionId)) {
            return false;
        }
        
        // Get execution ID for session
        String executionId = sessionExecutionIds.get(sessionId);
        
        // If no execution ID is associated, return true
        if (executionId == null) {
            return true;
        }
        
        LOGGER.info("Disassociating execution ID from session: sessionId={}, executionId={}", 
                sessionId, executionId);
        
        // Remove session ID from execution sessions
        Set<String> executionSessionSet = executionSessions.get(executionId);
        if (executionSessionSet != null) {
            executionSessionSet.remove(sessionId);
            
            // Remove execution ID if no sessions remain
            if (executionSessionSet.isEmpty()) {
                executionSessions.remove(executionId);
            }
        }
        
        // Remove execution ID from session
        sessionExecutionIds.remove(sessionId);
        
        return true;
    }
}


MessagePublisher.java
------------------------------------------------------

  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;

import java.util.Map;
import java.util.Set;

/**
 * Publisher for sending messages to WebSocket clients.
 * This interface defines methods for sending messages to specific
 * sessions, topics, or execution IDs.
 */
public interface MessagePublisher {
    
    /**
     * Send a message to a specific session.
     * 
     * @param sessionId ID of the session to send the message to
     * @param message Message to send
     * @return True if the message was sent successfully, false otherwise
     */
    boolean sendMessage(String sessionId, WebSocketMessage message);
    
    /**
     * Send a message to a specific session.
     * 
     * @param sessionId ID of the session to send the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return True if the message was sent successfully, false otherwise
     */
    boolean sendMessage(String sessionId, String messageType, Map<String, Object> payload);
    
    /**
     * Send a message to all sessions subscribed to a specific topic.
     * 
     * @param topic Topic to broadcast the message to
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    int broadcastMessage(String topic, WebSocketMessage message);
    
    /**
     * Send a message to all sessions subscribed to a specific topic.
     * 
     * @param topic Topic to broadcast the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    int broadcastMessage(String topic, String messageType, Map<String, Object> payload);
    
    /**
     * Send a message to all sessions associated with a specific execution ID.
     * 
     * @param executionId Execution ID to send the message to
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    int sendMessageToExecution(String executionId, WebSocketMessage message);
    
    /**
     * Send a message to all sessions associated with a specific execution ID.
     * 
     * @param executionId Execution ID to send the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    int sendMessageToExecution(String executionId, String messageType, Map<String, Object> payload);
    
    /**
     * Send a message to all sessions associated with a specific execution ID and subscribed to a specific topic.
     * 
     * @param executionId Execution ID to send the message to
     * @param topic Topic to send the message to
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    int sendMessageToExecutionTopic(String executionId, String topic, WebSocketMessage message);
    
    /**
     * Send a message to all sessions associated with a specific execution ID and subscribed to a specific topic.
     * 
     * @param executionId Execution ID to send the message to
     * @param topic Topic to send the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    int sendMessageToExecutionTopic(String executionId, String topic, String messageType, Map<String, Object> payload);
    
    /**
     * Send a message to a specific set of sessions.
     * 
     * @param sessionIds Set of session IDs to send the message to
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    int sendMessageToSessions(Set<String> sessionIds, WebSocketMessage message);
    
    /**
     * Send a message to a specific set of sessions.
     * 
     * @param sessionIds Set of session IDs to send the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    int sendMessageToSessions(Set<String> sessionIds, String messageType, Map<String, Object> payload);
    
    /**
     * Send a message to all active sessions.
     * 
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    int broadcastMessageToAll(WebSocketMessage message);
    
    /**
     * Send a message to all active sessions.
     * 
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    int broadcastMessageToAll(String messageType, Map<String, Object> payload);
}


MessagePublisherImpl.java
-------------------------------------------

  package com.cstestforge.service.websocket;

import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.BinaryMessage;
import org.springframework.web.socket.WebSocketSession;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Implementation of the MessagePublisher interface.
 * This class provides methods for sending messages to WebSocket clients.
 */
@Component
public class MessagePublisherImpl implements MessagePublisher {

    private static final CSLogger LOGGER = new CSLogger(MessagePublisherImpl.class);
    
    private final SessionRegistry sessionRegistry;
    private final MessageSerializer messageSerializer;
    
    /**
     * Constructor.
     * 
     * @param sessionRegistry Registry for tracking active WebSocket sessions
     */
    public MessagePublisherImpl(SessionRegistry sessionRegistry) {
        this.sessionRegistry = sessionRegistry;
        this.messageSerializer = new MessageSerializerImpl();
    }
    
    /**
     * Send a message to a specific session.
     * 
     * @param sessionId ID of the session to send the message to
     * @param message Message to send
     * @return True if the message was sent successfully, false otherwise
     */
    @Override
    public boolean sendMessage(String sessionId, WebSocketMessage message) {
        WebSocketSession session = sessionRegistry.getSession(sessionId);
        
        if (session == null || !session.isOpen()) {
            LOGGER.warn("Cannot send message to session {}: Session not found or not open", sessionId);
            return false;
        }
        
        try {
            String serialized = messageSerializer.serializeMessage(message);
            session.sendMessage(new TextMessage(serialized));
            
            LOGGER.debug("Message sent to session {}: type={}, size={} bytes", 
                    sessionId, message.getType(), serialized.length());
            
            return true;
        } catch (IOException e) {
            LOGGER.error("Error sending message to session {}: {}", sessionId, e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Send a message to a specific session.
     * 
     * @param sessionId ID of the session to send the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return True if the message was sent successfully, false otherwise
     */
    @Override
    public boolean sendMessage(String sessionId, String messageType, Map<String, Object> payload) {
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.valueOf(messageType));
        message.setPayload(payload);
        
        return sendMessage(sessionId, message);
    }
    
    /**
     * Send a message to all sessions subscribed to a specific topic.
     * 
     * @param topic Topic to broadcast the message to
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    @Override
    public int broadcastMessage(String topic, WebSocketMessage message) {
        Set<String> sessionIds = sessionRegistry.getSessionIdsByTopic(topic);
        
        if (sessionIds.isEmpty()) {
            LOGGER.warn("No sessions found for topic: {}", topic);
            return 0;
        }
        
        return sendMessageToSessions(sessionIds, message);
    }
    
    /**
     * Send a message to all sessions subscribed to a specific topic.
     * 
     * @param topic Topic to broadcast the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    @Override
    public int broadcastMessage(String topic, String messageType, Map<String, Object> payload) {
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.valueOf(messageType));
        message.setPayload(payload);
        
        return broadcastMessage(topic, message);
    }
    
    /**
     * Send a message to all sessions associated with a specific execution ID.
     * 
     * @param executionId Execution ID to send the message to
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    @Override
    public int sendMessageToExecution(String executionId, WebSocketMessage message) {
        Set<String> sessionIds = sessionRegistry.getSessionIdsByExecutionId(executionId);
        
        if (sessionIds.isEmpty()) {
            LOGGER.warn("No sessions found for execution ID: {}", executionId);
            return 0;
        }
        
        return sendMessageToSessions(sessionIds, message);
    }
    
    /**
     * Send a message to all sessions associated with a specific execution ID.
     * 
     * @param executionId Execution ID to send the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    @Override
    public int sendMessageToExecution(String executionId, String messageType, Map<String, Object> payload) {
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.valueOf(messageType));
        message.setPayload(payload);
        
        return sendMessageToExecution(executionId, message);
    }
    
    /**
     * Send a message to all sessions associated with a specific execution ID and subscribed to a specific topic.
     * 
     * @param executionId Execution ID to send the message to
     * @param topic Topic to send the message to
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    @Override
    public int sendMessageToExecutionTopic(String executionId, String topic, WebSocketMessage message) {
        Set<String> executionSessions = sessionRegistry.getSessionIdsByExecutionId(executionId);
        Set<String> topicSessions = sessionRegistry.getSessionIdsByTopic(topic);
        
        if (executionSessions.isEmpty() || topicSessions.isEmpty()) {
            LOGGER.warn("No sessions found for execution ID: {} and topic: {}", executionId, topic);
            return 0;
        }
        
        // Get intersection of execution sessions and topic sessions
        Set<String> targetSessions = executionSessions.stream()
                .filter(topicSessions::contains)
                .collect(Collectors.toSet());
        
        if (targetSessions.isEmpty()) {
            LOGGER.warn("No sessions found for execution ID: {} and topic: {}", executionId, topic);
            return 0;
        }
        
        return sendMessageToSessions(targetSessions, message);
    }
    
    /**
     * Send a message to all sessions associated with a specific execution ID and subscribed to a specific topic.
     * 
     * @param executionId Execution ID to send the message to
     * @param topic Topic to send the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    @Override
    public int sendMessageToExecutionTopic(String executionId, String topic, String messageType, Map<String, Object> payload) {
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.valueOf(messageType));
        message.setPayload(payload);
        
        return sendMessageToExecutionTopic(executionId, topic, message);
    }
    
    /**
     * Send a message to a specific set of sessions.
     * 
     * @param sessionIds Set of session IDs to send the message to
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    @Override
    public int sendMessageToSessions(Set<String> sessionIds, WebSocketMessage message) {
        if (sessionIds.isEmpty()) {
            return 0;
        }
        
        AtomicInteger successCount = new AtomicInteger(0);
        
        // Serialize message once for all sessions
        String serialized;
        try {
            serialized = messageSerializer.serializeMessage(message);
        } catch (Exception e) {
            LOGGER.error("Error serializing message: {}", e.getMessage(), e);
            return 0;
        }
        
        TextMessage textMessage = new TextMessage(serialized);
        
        sessionIds.forEach(sessionId -> {
            WebSocketSession session = sessionRegistry.getSession(sessionId);
            
            if (session != null && session.isOpen()) {
                try {
                    session.sendMessage(textMessage);
                    successCount.incrementAndGet();
                } catch (IOException e) {
                    LOGGER.error("Error sending message to session {}: {}", sessionId, e.getMessage(), e);
                }
            }
        });
        
        LOGGER.debug("Message broadcast to {}/{} sessions: type={}", 
                successCount.get(), sessionIds.size(), message.getType());
        
        return successCount.get();
    }
    
    /**
     * Send a message to a specific set of sessions.
     * 
     * @param sessionIds Set of session IDs to send the message to
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    @Override
    public int sendMessageToSessions(Set<String> sessionIds, String messageType, Map<String, Object> payload) {
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.valueOf(messageType));
        message.setPayload(payload);
        
        return sendMessageToSessions(sessionIds, message);
    }
    
    /**
     * Send a message to all active sessions.
     * 
     * @param message Message to send
     * @return Number of sessions the message was sent to
     */
    @Override
    public int broadcastMessageToAll(WebSocketMessage message) {
        Map<String, WebSocketSession> allSessions = sessionRegistry.getAllSessions();
        
        if (allSessions.isEmpty()) {
            LOGGER.warn("No active sessions found");
            return 0;
        }
        
        return sendMessageToSessions(allSessions.keySet(), message);
    }
    
    /**
     * Send a message to all active sessions.
     * 
     * @param messageType Type of the message
     * @param payload Payload of the message
     * @return Number of sessions the message was sent to
     */
    @Override
    public int broadcastMessageToAll(String messageType, Map<String, Object> payload) {
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.valueOf(messageType));
        message.setPayload(payload);
        
        return broadcastMessageToAll(message);
    }
}


WebSocketMessage.java
-----------------------------------

  package com.cstestforge.model.websocket;

import java.util.Map;
import java.util.HashMap;
import java.util.UUID;

/**
 * Model class for WebSocket messages.
 * This class represents a message that can be sent or received over a WebSocket connection.
 */
public class WebSocketMessage {
    
    private String id;
    private MessageType type;
    private Map<String, Object> payload;
    private long timestamp;
    
    /**
     * Default constructor.
     * Initializes a new WebSocketMessage with a random ID and the current timestamp.
     */
    public WebSocketMessage() {
        this.id = UUID.randomUUID().toString();
        this.timestamp = System.currentTimeMillis();
        this.payload = new HashMap<>();
    }
    
    /**
     * Constructor with message type.
     * 
     * @param type Type of the message
     */
    public WebSocketMessage(MessageType type) {
        this();
        this.type = type;
    }
    
    /**
     * Constructor with message type and payload.
     * 
     * @param type Type of the message
     * @param payload Payload of the message
     */
    public WebSocketMessage(MessageType type, Map<String, Object> payload) {
        this(type);
        this.payload = payload != null ? payload : new HashMap<>();
    }
    
    /**
     * Get the message ID.
     * 
     * @return Message ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Set the message ID.
     * 
     * @param id Message ID
     */
    public void setId(String id) {
        this.id = id;
    }
    
    /**
     * Get the message type.
     * 
     * @return Message type
     */
    public MessageType getType() {
        return type;
    }
    
    /**
     * Set the message type.
     * 
     * @param type Message type
     */
    public void setType(MessageType type) {
        this.type = type;
    }
    
    /**
     * Get the message payload.
     * 
     * @return Message payload
     */
    public Map<String, Object> getPayload() {
        return payload;
    }
    
    /**
     * Set the message payload.
     * 
     * @param payload Message payload
     */
    public void setPayload(Map<String, Object> payload) {
        this.payload = payload != null ? payload : new HashMap<>();
    }
    
    /**
     * Get the message timestamp.
     * 
     * @return Message timestamp
     */
    public long getTimestamp() {
        return timestamp;
    }
    
    /**
     * Set the message timestamp.
     * 
     * @param timestamp Message timestamp
     */
    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
    
    /**
     * Add a payload entry.
     * 
     * @param key Key of the entry
     * @param value Value of the entry
     * @return This WebSocketMessage for method chaining
     */
    public WebSocketMessage addPayload(String key, Object value) {
        this.payload.put(key, value);
        return this;
    }
    
    /**
     * Get a payload entry.
     * 
     * @param key Key of the entry
     * @return Value of the entry, or null if not found
     */
    public Object getPayloadValue(String key) {
        return this.payload.get(key);
    }
    
    /**
     * Get a payload entry as a string.
     * 
     * @param key Key of the entry
     * @return Value of the entry as a string, or null if not found
     */
    public String getPayloadValueAsString(String key) {
        Object value = this.payload.get(key);
        return value != null ? value.toString() : null;
    }
    
    /**
     * Get a payload entry as an integer.
     * 
     * @param key Key of the entry
     * @return Value of the entry as an integer, or null if not found or not an integer
     */
    public Integer getPayloadValueAsInteger(String key) {
        Object value = this.payload.get(key);
        
        if (value instanceof Integer) {
            return (Integer) value;
        } else if (value instanceof Number) {
            return ((Number) value).intValue();
        } else if (value instanceof String) {
            try {
                return Integer.parseInt((String) value);
            } catch (NumberFormatException e) {
                return null;
            }
        }
        
        return null;
    }
    
    /**
     * Get a payload entry as a boolean.
     * 
     * @param key Key of the entry
     * @return Value of the entry as a boolean, or null if not found or not a boolean
     */
    public Boolean getPayloadValueAsBoolean(String key) {
        Object value = this.payload.get(key);
        
        if (value instanceof Boolean) {
            return (Boolean) value;
        } else if (value instanceof String) {
            return Boolean.parseBoolean((String) value);
        }
        
        return null;
    }
    
    /**
     * Get a payload entry as a map.
     * 
     * @param key Key of the entry
     * @return Value of the entry as a map, or null if not found or not a map
     */
    @SuppressWarnings("unchecked")
    public Map<String, Object> getPayloadValueAsMap(String key) {
        Object value = this.payload.get(key);
        
        if (value instanceof Map) {
            return (Map<String, Object>) value;
        }
        
        return null;
    }
    
    /**
     * Check if a payload entry exists.
     * 
     * @param key Key of the entry
     * @return True if the entry exists, false otherwise
     */
    public boolean hasPayloadValue(String key) {
        return this.payload.containsKey(key);
    }
    
    /**
     * Remove a payload entry.
     * 
     * @param key Key of the entry
     * @return This WebSocketMessage for method chaining
     */
    public WebSocketMessage removePayloadValue(String key) {
        this.payload.remove(key);
        return this;
    }
    
    /**
     * Clear the payload.
     * 
     * @return This WebSocketMessage for method chaining
     */
    public WebSocketMessage clearPayload() {
        this.payload.clear();
        return this;
    }
    
    /**
     * Create a response message for this message.
     * 
     * @param responseType Type of the response
     * @return Response message
     */
    public WebSocketMessage createResponse(MessageType responseType) {
        WebSocketMessage response = new WebSocketMessage(responseType);
        response.addPayload("requestId", this.id);
        return response;
    }
    
    /**
     * Create a response message for this message with a payload.
     * 
     * @param responseType Type of the response
     * @param responsePayload Payload of the response
     * @return Response message
     */
    public WebSocketMessage createResponse(MessageType responseType, Map<String, Object> responsePayload) {
        WebSocketMessage response = new WebSocketMessage(responseType, responsePayload);
        response.addPayload("requestId", this.id);
        return response;
    }
    
    /**
     * Create an error response message for this message.
     * 
     * @param errorMessage Error message
     * @return Error response message
     */
    public WebSocketMessage createErrorResponse(String errorMessage) {
        WebSocketMessage response = new WebSocketMessage(MessageType.ERROR);
        response.addPayload("requestId", this.id);
        response.addPayload("error", errorMessage);
        return response;
    }
    
    /**
     * Create an error response message for this message with details.
     * 
     * @param errorMessage Error message
     * @param errorDetails Error details
     * @return Error response message
     */
    public WebSocketMessage createErrorResponse(String errorMessage, Map<String, Object> errorDetails) {
        WebSocketMessage response = new WebSocketMessage(MessageType.ERROR);
        response.addPayload("requestId", this.id);
        response.addPayload("error", errorMessage);
        response.addPayload("details", errorDetails);
        return response;
    }
    
    /**
     * Create a success response message for this message.
     * 
     * @return Success response message
     */
    public WebSocketMessage createSuccessResponse() {
        WebSocketMessage response = new WebSocketMessage(MessageType.SUCCESS);
        response.addPayload("requestId", this.id);
        return response;
    }
    
    /**
     * Create a success response message for this message with a payload.
     * 
     * @param responsePayload Payload of the response
     * @return Success response message
     */
    public WebSocketMessage createSuccessResponse(Map<String, Object> responsePayload) {
        WebSocketMessage response = new WebSocketMessage(MessageType.SUCCESS, responsePayload);
        response.addPayload("requestId", this.id);
        return response;
    }
    
    /**
     * Create a heartbeat message.
     * 
     * @return Heartbeat message
     */
    public static WebSocketMessage createHeartbeat() {
        return new WebSocketMessage(MessageType.HEARTBEAT);
    }
    
    /**
     * Create a heartbeat response message.
     * 
     * @return Heartbeat response message
     */
    public static WebSocketMessage createHeartbeatResponse() {
        return new WebSocketMessage(MessageType.HEARTBEAT_RESPONSE);
    }
}


MessageType.java
------------------------------------------

  package com.cstestforge.model.websocket;

/**
 * Enum for WebSocket message types.
 * This enum defines the various types of messages that can be sent over WebSocket connections.
 */
public enum MessageType {
    
    /**
     * Connection established message.
     * Sent from server to client when a WebSocket connection is established.
     */
    CONNECTION_ESTABLISHED,
    
    /**
     * Heartbeat message.
     * Sent periodically from server to client to check connection health.
     */
    HEARTBEAT,
    
    /**
     * Heartbeat response message.
     * Sent from client to server in response to a heartbeat message.
     */
    HEARTBEAT_RESPONSE,
    
    /**
     * Error message.
     * Sent from server to client to indicate an error.
     */
    ERROR,
    
    /**
     * Success message.
     * Sent from server to client to indicate success.
     */
    SUCCESS,
    
    /**
     * Test execution started message.
     * Sent from server to client when a test execution starts.
     */
    EXECUTION_STARTED,
    
    /**
     * Test execution status update message.
     * Sent from server to client to provide updates on test execution status.
     */
    EXECUTION_STATUS_UPDATE,
    
    /**
     * Test execution completed message.
     * Sent from server to client when a test execution completes.
     */
    EXECUTION_COMPLETED,
    
    /**
     * Test execution stopped message.
     * Sent from server to client when a test execution is stopped.
     */
    EXECUTION_STOPPED,
    
    /**
     * Test execution paused message.
     * Sent from server to client when a test execution is paused.
     */
    EXECUTION_PAUSED,
    
    /**
     * Test execution resumed message.
     * Sent from server to client when a test execution is resumed.
     */
    EXECUTION_RESUMED,
    
    /**
     * Test execution error message.
     * Sent from server to client when a test execution encounters an error.
     */
    EXECUTION_ERROR,
    
    /**
     * Test result message.
     * Sent from server to client with test execution results.
     */
    TEST_RESULT,
    
    /**
     * Test log message.
     * Sent from server to client with test execution logs.
     */
    TEST_LOG,
    
    /**
     * Screenshot message.
     * Sent from server to client with a screenshot.
     */
    SCREENSHOT,
    
    /**
     * Resource metrics message.
     * Sent from server to client with resource usage metrics.
     */
    RESOURCE_METRICS,
    
    /**
     * System notification message.
     * Sent from server to client with system notifications.
     */
    SYSTEM_NOTIFICATION,
    
    /**
     * Recording started message.
     * Sent from server to client when a recording session starts.
     */
    RECORDING_STARTED,
    
    /**
     * Recording event message.
     * Sent from client to server with a recording event.
     */
    RECORDING_EVENT,
    
    /**
     * Recording action message.
     * Sent from server to client with a generated recording action.
     */
    RECORDING_ACTION,
    
    /**
     * Recording status update message.
     * Sent from server to client with recording session status updates.
     */
    RECORDING_STATUS_UPDATE,
    
    /**
     * Recording completed message.
     * Sent from server to client when a recording session completes.
     */
    RECORDING_COMPLETED,
    
    /**
     * Recording stopped message.
     * Sent from server to client when a recording session is stopped.
     */
    RECORDING_STOPPED,
    
    /**
     * Recording paused message.
     * Sent from server to client when a recording session is paused.
     */
    RECORDING_PAUSED,
    
    /**
     * Recording resumed message.
     * Sent from server to client when a recording session is resumed.
     */
    RECORDING_RESUMED,
    
    /**
     * Recording error message.
     * Sent from server to client when a recording session encounters an error.
     */
    RECORDING_ERROR,
    
    /**
     * Element located message.
     * Sent from server to client when an element is located during recording.
     */
    ELEMENT_LOCATED,
    
    /**
     * Element highlight message.
     * Sent from server to client to highlight an element during recording.
     */
    ELEMENT_HIGHLIGHT,
    
    /**
     * Locator suggestions message.
     * Sent from server to client with suggested locators for an element.
     */
    LOCATOR_SUGGESTIONS,
    
    /**
     * Code generated message.
     * Sent from server to client with generated code for recorded actions.
     */
    CODE_GENERATED,
    
    /**
     * JavaScript execution message.
     * Sent from client to server to execute JavaScript in the browser.
     */
    EXECUTE_JAVASCRIPT,
    
    /**
     * JavaScript execution result message.
     * Sent from server to client with the result of JavaScript execution.
     */
    JAVASCRIPT_EXECUTION_RESULT,
    
    /**
     * Command execution message.
     * Sent from client to server to execute a command (e.g., stop execution).
     */
    EXECUTE_COMMAND,
    
    /**
     * Command execution result message.
     * Sent from server to client with the result of command execution.
     */
    COMMAND_EXECUTION_RESULT,
    
    /**
     * Subscribe message.
     * Sent from client to server to subscribe to a topic.
     */
    SUBSCRIBE,
    
    /**
     * Unsubscribe message.
     * Sent from client to server to unsubscribe from a topic.
     */
    UNSUBSCRIBE,
    
    /**
     * Subscription confirmation message.
     * Sent from server to client to confirm subscription to a topic.
     */
    SUBSCRIPTION_CONFIRMED,
    
    /**
     * Subscription removal message.
     * Sent from server to client to confirm unsubscription from a topic.
     */
    SUBSCRIPTION_REMOVED,
    
    /**
     * Authentication message.
     * Sent from client to server for authentication.
     */
    AUTHENTICATION,
    
    /**
     * Authentication result message.
     * Sent from server to client with authentication result.
     */
    AUTHENTICATION_RESULT,
    
    /**
     * Session expired message.
     * Sent from server to client when a session expires.
     */
    SESSION_EXPIRED,
    
    /**
     * Client info message.
     * Sent from client to server with client information.
     */
    CLIENT_INFO,
    
    /**
     * Server info message.
     * Sent from server to client with server information.
     */
    SERVER_INFO,
    
    /**
     * Data update message.
     * Sent from server to client with updated data.
     */
    DATA_UPDATE,
    
    /**
     * Data request message.
     * Sent from client to server to request data.
     */
    DATA_REQUEST,
    
    /**
     * Data response message.
     * Sent from server to client with requested data.
     */
    DATA_RESPONSE,
    
    /**
     * AI recommendation message.
     * Sent from server to client with AI-generated recommendations.
     */
    AI_RECOMMENDATION,
    
    /**
     * Self-healing locator message.
     * Sent from server to client with a self-healed locator.
     */
    SELF_HEALING_LOCATOR,
    
    /**
     * Element recognition message.
     * Sent from server to client with element recognition results.
     */
    ELEMENT_RECOGNITION,
    
    /**
     * Smart locator message.
     * Sent from server to client with smart locator recommendations.
     */
    SMART_LOCATOR,
    
    /**
     * Test optimization message.
     * Sent from server to client with test optimization recommendations.
     */
    TEST_OPTIMIZATION,
    
    /**
     * Test anomaly detection message.
     * Sent from server to client with test anomaly detection results.
     */
    TEST_ANOMALY_DETECTION,
    
    /**
     * Browser control message.
     * Sent from client to server to control the browser.
     */
    BROWSER_CONTROL,
    
    /**
     * Browser status message.
     * Sent from server to client with browser status.
     */
    BROWSER_STATUS,
    
    /**
     * Page load message.
     * Sent from server to client when a page is loaded in the browser.
     */
    PAGE_LOAD,
    
    /**
     * Page navigation message.
     * Sent from server to client when a page navigation occurs.
     */
    PAGE_NAVIGATION,
    
    /**
     * DOM update message.
     * Sent from server to client when a DOM update occurs.
     */
    DOM_UPDATE,
    
    /**
     * Network request message.
     * Sent from server to client when a network request is made.
     */
    NETWORK_REQUEST,
    
    /**
     * Network response message.
     * Sent from server to client when a network response is received.
     */
    NETWORK_RESPONSE,
    
    /**
     * Console log message.
     * Sent from server to client with console log entries.
     */
    CONSOLE_LOG,
    
    /**
     * Performance metrics message.
     * Sent from server to client with performance metrics.
     */
    PERFORMANCE_METRICS,
    
    /**
     * Video stream message.
     * Sent from server to client with video stream data.
     */
    VIDEO_STREAM,
    
    /**
     * Video stream control message.
     * Sent from client to server to control video streaming.
     */
    VIDEO_STREAM_CONTROL,
    
    /**
     * Feature flag update message.
     * Sent from server to client with updated feature flag values.
     */
    FEATURE_FLAG_UPDATE,
    
    /**
     * User preference update message.
     * Sent from client to server with updated user preferences.
     */
    USER_PREFERENCE_UPDATE,
    
    /**
     * User preference sync message.
     * Sent from server to client with synchronized user preferences.
     */
    USER_PREFERENCE_SYNC,
    
    /**
     * Export started message.
     * Sent from server to client when an export operation starts.
     */
    EXPORT_STARTED,
    
    /**
     * Export progress message.
     * Sent from server to client with export progress updates.
     */
    EXPORT_PROGRESS,
    
    /**
     * Export completed message.
     * Sent from server to client when an export operation completes.
     */
    EXPORT_COMPLETED,
    
    /**
     * Export error message.
     * Sent from server to client when an export operation encounters an error.
     */
    EXPORT_ERROR,
    
    /**
     * Import started message.
     * Sent from server to client when an import operation starts.
     */
    IMPORT_STARTED,
    
    /**
     * Import progress message.
     * Sent from server to client with import progress updates.
     */
    IMPORT_PROGRESS,
    
    /**
     * Import completed message.
     * Sent from server to client when an import operation completes.
     */
    IMPORT_COMPLETED,
    
    /**
     * Import error message.
     * Sent from server to client when an import operation encounters an error.
     */
    IMPORT_ERROR,
    
    /**
     * Pipeline generation started message.
     * Sent from server to client when pipeline generation starts.
     */
    PIPELINE_GENERATION_STARTED,
    
    /**
     * Pipeline generation completed message.
     * Sent from server to client when pipeline generation completes.
     */
    PIPELINE_GENERATION_COMPLETED,
    
    /**
     * Pipeline generation error message.
     * Sent from server to client when pipeline generation encounters an error.
     */
    PIPELINE_GENERATION_ERROR,
    
    /**
     * Test scheduling message.
     * Sent from client to server to schedule a test execution.
     */
    TEST_SCHEDULING,
    
    /**
     * Test scheduling result message.
     * Sent from server to client with test scheduling result.
     */
    TEST_SCHEDULING_RESULT,
    
    /**
     * Test scheduling update message.
     * Sent from server to client with updates to scheduled tests.
     */
    TEST_SCHEDULING_UPDATE,
    
    /**
     * User activity message.
     * Sent from client to server with user activity data.
     */
    USER_ACTIVITY,
    
    /**
     * Session activity message.
     * Sent from server to client with session activity data.
     */
    SESSION_ACTIVITY,
    
    /**
     * Server event message.
     * Sent from server to client with server event data.
     */
    SERVER_EVENT,
    
    /**
     * Client event message.
     * Sent from client to server with client event data.
     */
    CLIENT_EVENT,
    
    /**
     * Custom message.
     * Used for custom message types not covered by other enum values.
     */
    CUSTOM;
    
    /**
     * Check if this message type is an execution-related message.
     * 
     * @return True if this is an execution-related message, false otherwise
     */
    public boolean isExecutionMessage() {
        return this == EXECUTION_STARTED ||
               this == EXECUTION_STATUS_UPDATE ||
               this == EXECUTION_COMPLETED ||
               this == EXECUTION_STOPPED ||
               this == EXECUTION_PAUSED ||
               this == EXECUTION_RESUMED ||
               this == EXECUTION_ERROR ||
               this == TEST_RESULT ||
               this == TEST_LOG;
    }
    
    /**
     * Check if this message type is a recording-related message.
     * 
     * @return True if this is a recording-related message, false otherwise
     */
    public boolean isRecordingMessage() {
        return this == RECORDING_STARTED ||
               this == RECORDING_EVENT ||
               this == RECORDING_ACTION ||
               this == RECORDING_STATUS_UPDATE ||
               this == RECORDING_COMPLETED ||
               this == RECORDING_STOPPED ||
               this == RECORDING_PAUSED ||
               this == RECORDING_RESUMED ||
               this == RECORDING_ERROR ||
               this == ELEMENT_LOCATED ||
               this == ELEMENT_HIGHLIGHT ||
               this == LOCATOR_SUGGESTIONS ||
               this == CODE_GENERATED;
    }
    
    /**
     * Check if this message type is a browser-related message.
     * 
     * @return True if this is a browser-related message, false otherwise
     */
    public boolean isBrowserMessage() {
        return this == BROWSER_CONTROL ||
               this == BROWSER_STATUS ||
               this == PAGE_LOAD ||
               this == PAGE_NAVIGATION ||
               this == DOM_UPDATE ||
               this == NETWORK_REQUEST ||
               this == NETWORK_RESPONSE ||
               this == CONSOLE_LOG;
    }
    
    /**
     * Check if this message type is an AI-related message.
     * 
     * @return True if this is an AI-related message, false otherwise
     */
    public boolean isAIMessage() {
        return this == AI_RECOMMENDATION ||
               this == SELF_HEALING_LOCATOR ||
               this == ELEMENT_RECOGNITION ||
               this == SMART_LOCATOR ||
               this == TEST_OPTIMIZATION ||
               this == TEST_ANOMALY_DETECTION;
    }
    
    /**
     * Check if this message type is a system message.
     * 
     * @return True if this is a system message, false otherwise
     */
    public boolean isSystemMessage() {
        return this == CONNECTION_ESTABLISHED ||
               this == HEARTBEAT ||
               this == HEARTBEAT_RESPONSE ||
               this == ERROR ||
               this == SUCCESS ||
               this == SYSTEM_NOTIFICATION ||
               this == SESSION_EXPIRED ||
               this == SERVER_INFO ||
               this == FEATURE_FLAG_UPDATE;
    }
    
    /**
     * Check if this message type is an authentication message.
     * 
     * @return True if this is an authentication message, false otherwise
     */
    public boolean isAuthenticationMessage() {
        return this == AUTHENTICATION ||
               this == AUTHENTICATION_RESULT;
    }
    
    /**
     * Check if this message type is a data-related message.
     * 
     * @return True if this is a data-related message, false otherwise
     */
    public boolean isDataMessage() {
        return this == DATA_UPDATE ||
               this == DATA_REQUEST ||
               this == DATA_RESPONSE;
    }
    
    /**
     * Check if this message type is an export-related message.
     * 
     * @return True if this is an export-related message, false otherwise
     */
    public boolean isExportMessage() {
        return this == EXPORT_STARTED ||
               this == EXPORT_PROGRESS ||
               this == EXPORT_COMPLETED ||
               this == EXPORT_ERROR;
    }
    
    /**
     * Check if this message type is an import-related message.
     * 
     * @return True if this is an import-related message, false otherwise
     */
    public boolean isImportMessage() {
        return this == IMPORT_STARTED ||
               this == IMPORT_PROGRESS ||
               this == IMPORT_COMPLETED ||
               this == IMPORT_ERROR;
    }
    
    /**
     * Check if this message type is a pipeline-related message.
     * 
     * @return True if this is a pipeline-related message, false otherwise
     */
    public boolean isPipelineMessage() {
        return this == PIPELINE_GENERATION_STARTED ||
               this == PIPELINE_GENERATION_COMPLETED ||
               this == PIPELINE_GENERATION_ERROR;
    }
    
    /**
     * Check if this message type is a scheduling-related message.
     * 
     * @return True if this is a scheduling-related message, false otherwise
     */
    public boolean isSchedulingMessage() {
        return this == TEST_SCHEDULING ||
               this == TEST_SCHEDULING_RESULT ||
               this == TEST_SCHEDULING_UPDATE;
    }
    
    /**
     * Check if this message type is an activity-related message.
     * 
     * @return True if this is an activity-related message, false otherwise
     */
    public boolean isActivityMessage() {
        return this == USER_ACTIVITY ||
               this == SESSION_ACTIVITY;
    }
    
    /**
     * Check if this message type is an event-related message.
     * 
     * @return True if this is an event-related message, false otherwise
     */
    public boolean isEventMessage() {
        return this == SERVER_EVENT ||
               this == CLIENT_EVENT;
    }
    
    /**
     * Check if this message type represents an error condition.
     * 
     * @return True if this is an error message, false otherwise
     */
    public boolean isErrorMessage() {
        return this == ERROR ||
               this == EXECUTION_ERROR ||
               this == RECORDING_ERROR ||
               this == EXPORT_ERROR ||
               this == IMPORT_ERROR ||
               this == PIPELINE_GENERATION_ERROR;
    }
    
    /**
     * Get the response message type for this message type.
     * 
     * @return Response message type, or null if there is no standard response
     */
    public MessageType getResponseType() {
        switch (this) {
            case HEARTBEAT:
                return HEARTBEAT_RESPONSE;
            case AUTHENTICATION:
                return AUTHENTICATION_RESULT;
            case DATA_REQUEST:
                return DATA_RESPONSE;
            case EXECUTE_JAVASCRIPT:
                return JAVASCRIPT_EXECUTION_RESULT;
            case EXECUTE_COMMAND:
                return COMMAND_EXECUTION_RESULT;
            case SUBSCRIBE:
                return SUBSCRIPTION_CONFIRMED;
            case UNSUBSCRIBE:
                return SUBSCRIPTION_REMOVED;
            case RECORDING_EVENT:
                return RECORDING_ACTION;
            case TEST_SCHEDULING:
                return TEST_SCHEDULING_RESULT;
            default:
                return null;
        }
    }
}


AuthenticationHandler.java
---------------------------------------

  package com.cstestforge.service.websocket;

import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.server.HandshakeInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;

import com.cstestforge.framework.core.utils.CSLogger;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Authentication handler for WebSocket connections.
 * This class intercepts WebSocket handshake requests and validates authentication.
 */
@Component
public class AuthenticationHandler implements HandshakeInterceptor {

    private static final CSLogger LOGGER = new CSLogger(AuthenticationHandler.class);
    
    @Value("${cstestforge.websocket.authentication.enabled:true}")
    private boolean authenticationEnabled;
    
    @Value("${cstestforge.websocket.authentication.header:X-CSTestForge-Auth-Token}")
    private String authHeaderName;
    
    @Value("${cstestforge.websocket.authentication.param:auth}")
    private String authParamName;
    
    @Value("${cstestforge.websocket.authentication.session.attribute:CS_AUTH_TOKEN}")
    private String sessionAuthAttributeName;
    
    // Cache of validated tokens
    private final Map<String, Long> validatedTokens = new ConcurrentHashMap<>();
    
    // Token expiration time in milliseconds (1 hour)
    private static final long TOKEN_EXPIRATION_MS = 3600000;
    
    /**
     * Constructor.
     */
    public AuthenticationHandler() {
        // Start a background thread to clean up expired tokens
        Thread cleanupThread = new Thread(this::cleanupExpiredTokens);
        cleanupThread.setDaemon(true);
        cleanupThread.setName("WebSocket-Auth-Token-Cleanup");
        cleanupThread.start();
    }
    
    /**
     * Called before the WebSocket handshake.
     * Validates authentication token provided in header, query parameter, or session.
     * 
     * @param request HTTP request
     * @param response HTTP response
     * @param wsHandler WebSocket handler
     * @param attributes Handshake attributes
     * @return True if the handshake should proceed, false otherwise
     */
    @Override
    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response,
                                 WebSocketHandler wsHandler, Map<String, Object> attributes) {
        
        if (!authenticationEnabled) {
            LOGGER.debug("WebSocket authentication is disabled");
            return true;
        }
        
        String token = extractAuthToken(request, attributes);
        
        if (token == null) {
            LOGGER.warn("WebSocket connection rejected: Missing authentication token");
            return false;
        }
        
        // Check if token is in cache
        Long expiration = validatedTokens.get(token);
        if (expiration != null && expiration > System.currentTimeMillis()) {
            // Token is valid and not expired
            LOGGER.debug("WebSocket authentication successful using cached token");
            
            // Store authentication information in attributes
            attributes.put("authenticated", true);
            attributes.put("authToken", token);
            
            // Refresh token expiration
            validatedTokens.put(token, System.currentTimeMillis() + TOKEN_EXPIRATION_MS);
            
            return true;
        }
        
        // Validate token
        boolean isValid = validateAuthToken(token);
        
        if (isValid) {
            LOGGER.debug("WebSocket authentication successful");
            
            // Store authentication information in attributes
            attributes.put("authenticated", true);
            attributes.put("authToken", token);
            
            // Cache token
            validatedTokens.put(token, System.currentTimeMillis() + TOKEN_EXPIRATION_MS);
            
            return true;
        } else {
            LOGGER.warn("WebSocket connection rejected: Invalid authentication token");
            return false;
        }
    }
    
    /**
     * Called after the WebSocket handshake.
     * Not used in this implementation.
     * 
     * @param request HTTP request
     * @param response HTTP response
     * @param wsHandler WebSocket handler
     * @param exception Exception that occurred during handshake, or null if successful
     */
    @Override
    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response,
                             WebSocketHandler wsHandler, Exception exception) {
        // No action needed after handshake
    }
    
    /**
     * Extract authentication token from request.
     * Checks header, query parameter, and session.
     * 
     * @param request HTTP request
     * @param attributes Handshake attributes
     * @return Authentication token, or null if not found
     */
    private String extractAuthToken(ServerHttpRequest request, Map<String, Object> attributes) {
        // Check header
        String headerToken = request.getHeaders().getFirst(authHeaderName);
        if (headerToken != null && !headerToken.isEmpty()) {
            return headerToken;
        }
        
        // Check query parameter
        String uri = request.getURI().toString();
        int paramIndex = uri.indexOf(authParamName + "=");
        if (paramIndex >= 0) {
            String paramValue = uri.substring(paramIndex + authParamName.length() + 1);
            int endIndex = paramValue.indexOf('&');
            return endIndex >= 0 ? paramValue.substring(0, endIndex) : paramValue;
        }
        
        // Check session
        if (request instanceof ServletServerHttpRequest) {
            HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest();
            HttpSession session = servletRequest.getSession(false);
            
            if (session != null) {
                Object sessionToken = session.getAttribute(sessionAuthAttributeName);
                if (sessionToken != null) {
                    return sessionToken.toString();
                }
            }
        }
        
        return null;
    }
    
    /**
     * Validate authentication token.
     * 
     * @param token Authentication token to validate
     * @return True if the token is valid, false otherwise
     */
    private boolean validateAuthToken(String token) {
        // In a production environment, this would validate against a secure token store
        // For now, implement a basic validation logic
        
        // Token should not be empty
        if (token == null || token.isEmpty()) {
            return false;
        }
        
        // Token should be at least 32 characters long
        if (token.length() < 32) {
            return false;
        }
        
        // Token should start with "cs_" prefix
        if (!token.startsWith("cs_")) {
            return false;
        }
        
        // Additional validation logic would be implemented here
        
        return true;
    }
    
    /**
     * Clean up expired authentication tokens.
     * Runs in a background thread.
     */
    private void cleanupExpiredTokens() {
        while (true) {
            try {
                // Sleep for 5 minutes
                Thread.sleep(300000);
                
                // Get current time
                long currentTime = System.currentTimeMillis();
                
                // Remove expired tokens
                int removedCount = 0;
                for (Map.Entry<String, Long> entry : validatedTokens.entrySet()) {
                    if (entry.getValue() < currentTime) {
                        validatedTokens.remove(entry.getKey());
                        removedCount++;
                    }
                }
                
                if (removedCount > 0) {
                    LOGGER.debug("Removed {} expired authentication tokens", removedCount);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                LOGGER.error("Token cleanup thread interrupted", e);
                break;
            } catch (Exception e) {
                LOGGER.error("Error in token cleanup thread", e);
            }
        }
    }
}


HeartbeatService.java
-------------------------------------------

  package com.cstestforge.service.websocket;

/**
 * Service for managing WebSocket heartbeats.
 * This interface defines methods for starting, stopping,
 * and handling heartbeats for WebSocket connections.
 */
public interface HeartbeatService {
    
    /**
     * Start sending heartbeats to a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    void startHeartbeat(String sessionId);
    
    /**
     * Stop sending heartbeats to a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    void stopHeartbeat(String sessionId);
    
    /**
     * Handle a heartbeat response from a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    void handleHeartbeatResponse(String sessionId);
    
    /**
     * Check if a session is responding to heartbeats.
     * 
     * @param sessionId ID of the WebSocket session
     * @return True if the session is responding, false otherwise
     */
    boolean isSessionResponding(String sessionId);
    
    /**
     * Get the last heartbeat response time for a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Timestamp of the last heartbeat response, or 0 if no response has been received
     */
    long getLastHeartbeatResponse(String sessionId);
    
    /**
     * Get the time since the last heartbeat response for a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Time in milliseconds since the last heartbeat response, or -1 if no response has been received
     */
    long getTimeSinceLastHeartbeat(String sessionId);
    
    /**
     * Get the number of consecutive missed heartbeats for a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Number of consecutive missed heartbeats, or 0 if all heartbeats have been acknowledged
     */
    int getMissedHeartbeatCount(String sessionId);
    
    /**
     * Get the total number of heartbeats sent to a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Total number of heartbeats sent
     */
    int getTotalHeartbeatCount(String sessionId);
    
    /**
     * Reset heartbeat statistics for a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    void resetHeartbeatStatistics(String sessionId);
    
    /**
     * Start the heartbeat service.
     */
    void start();
    
    /**
     * Stop the heartbeat service.
     */
    void stop();
    
    /**
     * Check if the heartbeat service is running.
     * 
     * @return True if the service is running, false otherwise
     */
    boolean isRunning();
}


HeartbeatServiceImpl.java
----------------------------------------


  package com.cstestforge.service.websocket;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.WebSocketSession;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Implementation of the HeartbeatService interface.
 * This class manages heartbeats for WebSocket connections to ensure they remain active.
 */
@Component
public class HeartbeatServiceImpl implements HeartbeatService {

    private static final CSLogger LOGGER = new CSLogger(HeartbeatServiceImpl.class);
    
    @Value("${cstestforge.websocket.heartbeat.interval:15000}")
    private long heartbeatInterval;
    
    @Value("${cstestforge.websocket.heartbeat.timeout:45000}")
    private long heartbeatTimeout;
    
    @Value("${cstestforge.websocket.heartbeat.max-missed:3}")
    private int maxMissedHeartbeats;
    
    @Value("${cstestforge.websocket.heartbeat.enabled:true}")
    private boolean heartbeatEnabled;
    
    private ScheduledExecutorService scheduler;
    private ScheduledFuture<?> heartbeatTask;
    private final AtomicBoolean running = new AtomicBoolean(false);
    
    private SessionRegistry sessionRegistry;
    private MessageSerializer messageSerializer;
    
    // Maps to track heartbeat data
    private final Map<String, Long> lastHeartbeatSent = new ConcurrentHashMap<>();
    private final Map<String, Long> lastHeartbeatResponse = new ConcurrentHashMap<>();
    private final Map<String, Integer> missedHeartbeats = new ConcurrentHashMap<>();
    private final Map<String, Integer> totalHeartbeats = new ConcurrentHashMap<>();
    
    /**
     * Constructor with autowired dependencies.
     * 
     * @param sessionRegistry Registry for tracking active WebSocket sessions
     */
    @Autowired
    public HeartbeatServiceImpl(SessionRegistry sessionRegistry) {
        this.sessionRegistry = sessionRegistry;
        this.messageSerializer = new MessageSerializerImpl();
    }
    
    /**
     * Initialize the heartbeat service.
     */
    @PostConstruct
    public void init() {
        if (heartbeatEnabled) {
            start();
        } else {
            LOGGER.info("WebSocket heartbeat service is disabled");
        }
    }
    
    /**
     * Clean up resources when the service is shutting down.
     */
    @PreDestroy
    public void cleanup() {
        stop();
    }
    
    /**
     * Start the heartbeat service.
     */
    @Override
    public void start() {
        if (running.compareAndSet(false, true)) {
            LOGGER.info("Starting WebSocket heartbeat service with interval: {} ms, timeout: {} ms, max missed: {}",
                    heartbeatInterval, heartbeatTimeout, maxMissedHeartbeats);
            
            scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
                Thread thread = new Thread(r);
                thread.setName("WebSocket-Heartbeat-Thread");
                thread.setDaemon(true);
                return thread;
            });
            
            heartbeatTask = scheduler.scheduleAtFixedRate(
                    this::sendHeartbeats,
                    heartbeatInterval,
                    heartbeatInterval,
                    TimeUnit.MILLISECONDS);
        }
    }
    
    /**
     * Stop the heartbeat service.
     */
    @Override
    public void stop() {
        if (running.compareAndSet(true, false)) {
            LOGGER.info("Stopping WebSocket heartbeat service");
            
            if (heartbeatTask != null) {
                heartbeatTask.cancel(false);
                heartbeatTask = null;
            }
            
            if (scheduler != null) {
                scheduler.shutdown();
                try {
                    if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                        scheduler.shutdownNow();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    scheduler.shutdownNow();
                }
                scheduler = null;
            }
            
            // Clear all tracking maps
            lastHeartbeatSent.clear();
            lastHeartbeatResponse.clear();
            missedHeartbeats.clear();
            totalHeartbeats.clear();
        }
    }
    
    /**
     * Check if the heartbeat service is running.
     * 
     * @return True if the service is running, false otherwise
     */
    @Override
    public boolean isRunning() {
        return running.get();
    }
    
    /**
     * Start sending heartbeats to a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    @Override
    public void startHeartbeat(String sessionId) {
        if (!heartbeatEnabled || !running.get()) {
            return;
        }
        
        LOGGER.debug("Starting heartbeats for session: {}", sessionId);
        
        // Initialize heartbeat tracking
        long currentTime = System.currentTimeMillis();
        lastHeartbeatSent.put(sessionId, currentTime);
        lastHeartbeatResponse.put(sessionId, currentTime);  // Assume initial response
        missedHeartbeats.put(sessionId, 0);
        totalHeartbeats.put(sessionId, 0);
    }
    
    /**
     * Stop sending heartbeats to a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    @Override
    public void stopHeartbeat(String sessionId) {
        LOGGER.debug("Stopping heartbeats for session: {}", sessionId);
        
        // Remove heartbeat tracking
        lastHeartbeatSent.remove(sessionId);
        lastHeartbeatResponse.remove(sessionId);
        missedHeartbeats.remove(sessionId);
        totalHeartbeats.remove(sessionId);
    }
    
    /**
     * Handle a heartbeat response from a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    @Override
    public void handleHeartbeatResponse(String sessionId) {
        if (!heartbeatEnabled || !running.get()) {
            return;
        }
        
        LOGGER.debug("Received heartbeat response from session: {}", sessionId);
        
        // Update last response time
        lastHeartbeatResponse.put(sessionId, System.currentTimeMillis());
        
        // Reset missed heartbeats
        missedHeartbeats.put(sessionId, 0);
    }
    
    /**
     * Check if a session is responding to heartbeats.
     * 
     * @param sessionId ID of the WebSocket session
     * @return True if the session is responding, false otherwise
     */
    @Override
    public boolean isSessionResponding(String sessionId) {
        if (!heartbeatEnabled || !running.get()) {
            return true;  // Assume responding if heartbeats are disabled
        }
        
        Integer missed = missedHeartbeats.get(sessionId);
        if (missed == null) {
            return false;  // Session not being tracked
        }
        
        return missed < maxMissedHeartbeats;
    }
    
    /**
     * Get the last heartbeat response time for a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Timestamp of the last heartbeat response, or 0 if no response has been received
     */
    @Override
    public long getLastHeartbeatResponse(String sessionId) {
        return lastHeartbeatResponse.getOrDefault(sessionId, 0L);
    }
    
    /**
     * Get the time since the last heartbeat response for a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Time in milliseconds since the last heartbeat response, or -1 if no response has been received
     */
    @Override
    public long getTimeSinceLastHeartbeat(String sessionId) {
        Long lastResponse = lastHeartbeatResponse.get(sessionId);
        if (lastResponse == null) {
            return -1;
        }
        
        return System.currentTimeMillis() - lastResponse;
    }
    
    /**
     * Get the number of consecutive missed heartbeats for a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Number of consecutive missed heartbeats, or 0 if all heartbeats have been acknowledged
     */
    @Override
    public int getMissedHeartbeatCount(String sessionId) {
        return missedHeartbeats.getOrDefault(sessionId, 0);
    }
    
    /**
     * Get the total number of heartbeats sent to a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Total number of heartbeats sent
     */
    @Override
    public int getTotalHeartbeatCount(String sessionId) {
        return totalHeartbeats.getOrDefault(sessionId, 0);
    }
    
    /**
     * Reset heartbeat statistics for a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    @Override
    public void resetHeartbeatStatistics(String sessionId) {
        long currentTime = System.currentTimeMillis();
        lastHeartbeatSent.put(sessionId, currentTime);
        lastHeartbeatResponse.put(sessionId, currentTime);
        missedHeartbeats.put(sessionId, 0);
        totalHeartbeats.put(sessionId, 0);
    }
    
    /**
     * Send heartbeats to all active sessions.
     * This method is called periodically by the scheduler.
     */
    private void sendHeartbeats() {
        if (!running.get()) {
            return;
        }
        
        try {
            Map<String, WebSocketSession> activeSessions = sessionRegistry.getAllSessions();
            
            if (activeSessions.isEmpty()) {
                return;
            }
            
            LOGGER.debug("Sending heartbeats to {} active sessions", activeSessions.size());
            
            long currentTime = System.currentTimeMillis();
            
            // Create heartbeat message
            WebSocketMessage heartbeatMessage = WebSocketMessage.createHeartbeat();
            String serializedMessage = messageSerializer.serializeMessage(heartbeatMessage);
            
            for (Map.Entry<String, WebSocketSession> entry : activeSessions.entrySet()) {
                String sessionId = entry.getKey();
                WebSocketSession session = entry.getValue();
                
                // Skip sessions not being tracked
                if (!lastHeartbeatSent.containsKey(sessionId)) {
                    continue;
                }
                
                try {
                    // Update tracking information
                    lastHeartbeatSent.put(sessionId, currentTime);
                    totalHeartbeats.put(sessionId, totalHeartbeats.getOrDefault(sessionId, 0) + 1);
                    
                    // Check if session has missed too many heartbeats
                    Long lastResponse = lastHeartbeatResponse.get(sessionId);
                    if (lastResponse != null && (currentTime - lastResponse) > heartbeatTimeout) {
                        int missed = missedHeartbeats.getOrDefault(sessionId, 0) + 1;
                        missedHeartbeats.put(sessionId, missed);
                        
                        LOGGER.debug("Session {} missed {} consecutive heartbeats", sessionId, missed);
                        
                        // Close session if too many heartbeats missed
                        if (missed >= maxMissedHeartbeats) {
                            LOGGER.warn("Closing unresponsive session {}: Missed {} heartbeats", sessionId, missed);
                            
                            try {
                                session.close();
                            } catch (Exception e) {
                                LOGGER.error("Error closing unresponsive session {}: {}", sessionId, e.getMessage(), e);
                            }
                            
                            continue;  // Skip sending heartbeat to this session
                        }
                    }
                    
                    // Send heartbeat
                    if (session.isOpen()) {
                        org.springframework.web.socket.TextMessage textMessage = 
                                new org.springframework.web.socket.TextMessage(serializedMessage);
                        session.sendMessage(textMessage);
                    }
                } catch (Exception e) {
                    LOGGER.error("Error sending heartbeat to session {}: {}", sessionId, e.getMessage(), e);
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error in heartbeat task: {}", e.getMessage(), e);
        }
    }
}



MessageSerializer.java
--------------------------------------

  package com.cstestforge.service.websocket;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.WebSocketSession;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Implementation of the HeartbeatService interface.
 * This class manages heartbeats for WebSocket connections to ensure they remain active.
 */
@Component
public class HeartbeatServiceImpl implements HeartbeatService {

    private static final CSLogger LOGGER = new CSLogger(HeartbeatServiceImpl.class);
    
    @Value("${cstestforge.websocket.heartbeat.interval:15000}")
    private long heartbeatInterval;
    
    @Value("${cstestforge.websocket.heartbeat.timeout:45000}")
    private long heartbeatTimeout;
    
    @Value("${cstestforge.websocket.heartbeat.max-missed:3}")
    private int maxMissedHeartbeats;
    
    @Value("${cstestforge.websocket.heartbeat.enabled:true}")
    private boolean heartbeatEnabled;
    
    private ScheduledExecutorService scheduler;
    private ScheduledFuture<?> heartbeatTask;
    private final AtomicBoolean running = new AtomicBoolean(false);
    
    private SessionRegistry sessionRegistry;
    private MessageSerializer messageSerializer;
    
    // Maps to track heartbeat data
    private final Map<String, Long> lastHeartbeatSent = new ConcurrentHashMap<>();
    private final Map<String, Long> lastHeartbeatResponse = new ConcurrentHashMap<>();
    private final Map<String, Integer> missedHeartbeats = new ConcurrentHashMap<>();
    private final Map<String, Integer> totalHeartbeats = new ConcurrentHashMap<>();
    
    /**
     * Constructor with autowired dependencies.
     * 
     * @param sessionRegistry Registry for tracking active WebSocket sessions
     */
    @Autowired
    public HeartbeatServiceImpl(SessionRegistry sessionRegistry) {
        this.sessionRegistry = sessionRegistry;
        this.messageSerializer = new MessageSerializerImpl();
    }
    
    /**
     * Initialize the heartbeat service.
     */
    @PostConstruct
    public void init() {
        if (heartbeatEnabled) {
            start();
        } else {
            LOGGER.info("WebSocket heartbeat service is disabled");
        }
    }
    
    /**
     * Clean up resources when the service is shutting down.
     */
    @PreDestroy
    public void cleanup() {
        stop();
    }
    
    /**
     * Start the heartbeat service.
     */
    @Override
    public void start() {
        if (running.compareAndSet(false, true)) {
            LOGGER.info("Starting WebSocket heartbeat service with interval: {} ms, timeout: {} ms, max missed: {}",
                    heartbeatInterval, heartbeatTimeout, maxMissedHeartbeats);
            
            scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
                Thread thread = new Thread(r);
                thread.setName("WebSocket-Heartbeat-Thread");
                thread.setDaemon(true);
                return thread;
            });
            
            heartbeatTask = scheduler.scheduleAtFixedRate(
                    this::sendHeartbeats,
                    heartbeatInterval,
                    heartbeatInterval,
                    TimeUnit.MILLISECONDS);
        }
    }
    
    /**
     * Stop the heartbeat service.
     */
    @Override
    public void stop() {
        if (running.compareAndSet(true, false)) {
            LOGGER.info("Stopping WebSocket heartbeat service");
            
            if (heartbeatTask != null) {
                heartbeatTask.cancel(false);
                heartbeatTask = null;
            }
            
            if (scheduler != null) {
                scheduler.shutdown();
                try {
                    if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                        scheduler.shutdownNow();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    scheduler.shutdownNow();
                }
                scheduler = null;
            }
            
            // Clear all tracking maps
            lastHeartbeatSent.clear();
            lastHeartbeatResponse.clear();
            missedHeartbeats.clear();
            totalHeartbeats.clear();
        }
    }
    
    /**
     * Check if the heartbeat service is running.
     * 
     * @return True if the service is running, false otherwise
     */
    @Override
    public boolean isRunning() {
        return running.get();
    }
    
    /**
     * Start sending heartbeats to a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    @Override
    public void startHeartbeat(String sessionId) {
        if (!heartbeatEnabled || !running.get()) {
            return;
        }
        
        LOGGER.debug("Starting heartbeats for session: {}", sessionId);
        
        // Initialize heartbeat tracking
        long currentTime = System.currentTimeMillis();
        lastHeartbeatSent.put(sessionId, currentTime);
        lastHeartbeatResponse.put(sessionId, currentTime);  // Assume initial response
        missedHeartbeats.put(sessionId, 0);
        totalHeartbeats.put(sessionId, 0);
    }
    
    /**
     * Stop sending heartbeats to a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    @Override
    public void stopHeartbeat(String sessionId) {
        LOGGER.debug("Stopping heartbeats for session: {}", sessionId);
        
        // Remove heartbeat tracking
        lastHeartbeatSent.remove(sessionId);
        lastHeartbeatResponse.remove(sessionId);
        missedHeartbeats.remove(sessionId);
        totalHeartbeats.remove(sessionId);
    }
    
    /**
     * Handle a heartbeat response from a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    @Override
    public void handleHeartbeatResponse(String sessionId) {
        if (!heartbeatEnabled || !running.get()) {
            return;
        }
        
        LOGGER.debug("Received heartbeat response from session: {}", sessionId);
        
        // Update last response time
        lastHeartbeatResponse.put(sessionId, System.currentTimeMillis());
        
        // Reset missed heartbeats
        missedHeartbeats.put(sessionId, 0);
    }
    
    /**
     * Check if a session is responding to heartbeats.
     * 
     * @param sessionId ID of the WebSocket session
     * @return True if the session is responding, false otherwise
     */
    @Override
    public boolean isSessionResponding(String sessionId) {
        if (!heartbeatEnabled || !running.get()) {
            return true;  // Assume responding if heartbeats are disabled
        }
        
        Integer missed = missedHeartbeats.get(sessionId);
        if (missed == null) {
            return false;  // Session not being tracked
        }
        
        return missed < maxMissedHeartbeats;
    }
    
    /**
     * Get the last heartbeat response time for a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Timestamp of the last heartbeat response, or 0 if no response has been received
     */
    @Override
    public long getLastHeartbeatResponse(String sessionId) {
        return lastHeartbeatResponse.getOrDefault(sessionId, 0L);
    }
    
    /**
     * Get the time since the last heartbeat response for a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Time in milliseconds since the last heartbeat response, or -1 if no response has been received
     */
    @Override
    public long getTimeSinceLastHeartbeat(String sessionId) {
        Long lastResponse = lastHeartbeatResponse.get(sessionId);
        if (lastResponse == null) {
            return -1;
        }
        
        return System.currentTimeMillis() - lastResponse;
    }
    
    /**
     * Get the number of consecutive missed heartbeats for a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Number of consecutive missed heartbeats, or 0 if all heartbeats have been acknowledged
     */
    @Override
    public int getMissedHeartbeatCount(String sessionId) {
        return missedHeartbeats.getOrDefault(sessionId, 0);
    }
    
    /**
     * Get the total number of heartbeats sent to a session.
     * 
     * @param sessionId ID of the WebSocket session
     * @return Total number of heartbeats sent
     */
    @Override
    public int getTotalHeartbeatCount(String sessionId) {
        return totalHeartbeats.getOrDefault(sessionId, 0);
    }
    
    /**
     * Reset heartbeat statistics for a session.
     * 
     * @param sessionId ID of the WebSocket session
     */
    @Override
    public void resetHeartbeatStatistics(String sessionId) {
        long currentTime = System.currentTimeMillis();
        lastHeartbeatSent.put(sessionId, currentTime);
        lastHeartbeatResponse.put(sessionId, currentTime);
        missedHeartbeats.put(sessionId, 0);
        totalHeartbeats.put(sessionId, 0);
    }
    
    /**
     * Send heartbeats to all active sessions.
     * This method is called periodically by the scheduler.
     */
    private void sendHeartbeats() {
        if (!running.get()) {
            return;
        }
        
        try {
            Map<String, WebSocketSession> activeSessions = sessionRegistry.getAllSessions();
            
            if (activeSessions.isEmpty()) {
                return;
            }
            
            LOGGER.debug("Sending heartbeats to {} active sessions", activeSessions.size());
            
            long currentTime = System.currentTimeMillis();
            
            // Create heartbeat message
            WebSocketMessage heartbeatMessage = WebSocketMessage.createHeartbeat();
            String serializedMessage = messageSerializer.serializeMessage(heartbeatMessage);
            
            for (Map.Entry<String, WebSocketSession> entry : activeSessions.entrySet()) {
                String sessionId = entry.getKey();
                WebSocketSession session = entry.getValue();
                
                // Skip sessions not being tracked
                if (!lastHeartbeatSent.containsKey(sessionId)) {
                    continue;
                }
                
                try {
                    // Update tracking information
                    lastHeartbeatSent.put(sessionId, currentTime);
                    totalHeartbeats.put(sessionId, totalHeartbeats.getOrDefault(sessionId, 0) + 1);
                    
                    // Check if session has missed too many heartbeats
                    Long lastResponse = lastHeartbeatResponse.get(sessionId);
                    if (lastResponse != null && (currentTime - lastResponse) > heartbeatTimeout) {
                        int missed = missedHeartbeats.getOrDefault(sessionId, 0) + 1;
                        missedHeartbeats.put(sessionId, missed);
                        
                        LOGGER.debug("Session {} missed {} consecutive heartbeats", sessionId, missed);
                        
                        // Close session if too many heartbeats missed
                        if (missed >= maxMissedHeartbeats) {
                            LOGGER.warn("Closing unresponsive session {}: Missed {} heartbeats", sessionId, missed);
                            
                            try {
                                session.close();
                            } catch (Exception e) {
                                LOGGER.error("Error closing unresponsive session {}: {}", sessionId, e.getMessage(), e);
                            }
                            
                            continue;  // Skip sending heartbeat to this session
                        }
                    }
                    
                    // Send heartbeat
                    if (session.isOpen()) {
                        org.springframework.web.socket.TextMessage textMessage = 
                                new org.springframework.web.socket.TextMessage(serializedMessage);
                        session.sendMessage(textMessage);
                    }
                } catch (Exception e) {
                    LOGGER.error("Error sending heartbeat to session {}: {}", sessionId, e.getMessage(), e);
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error in heartbeat task: {}", e.getMessage(), e);
        }
    }
}


MessageSerializerImpl.java
--------------------------------------------

  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;
import com.cstestforge.framework.core.utils.CSLogger;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.core.type.TypeReference;

import org.springframework.stereotype.Component;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import java.util.HashMap;

/**
 * Implementation of the MessageSerializer interface.
 * This class provides methods for serializing and deserializing WebSocket messages.
 */
@Component
public class MessageSerializerImpl implements MessageSerializer {

    private static final CSLogger LOGGER = new CSLogger(MessageSerializerImpl.class);
    
    private final ObjectMapper objectMapper;
    
    /**
     * Constructor.
     * Initializes the JSON object mapper with appropriate configuration.
     */
    public MessageSerializerImpl() {
        objectMapper = new ObjectMapper();
        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }
    
    /**
     * Serialize a WebSocket message to a JSON string.
     * 
     * @param message Message to serialize
     * @return Serialized JSON string
     * @throws Exception if serialization fails
     */
    @Override
    public String serializeMessage(WebSocketMessage message) throws Exception {
        try {
            Map<String, Object> jsonMap = new HashMap<>();
            jsonMap.put("id", message.getId());
            jsonMap.put("type", message.getType().name());
            jsonMap.put("timestamp", message.getTimestamp());
            jsonMap.put("payload", message.getPayload());
            
            return objectMapper.writeValueAsString(jsonMap);
        } catch (Exception e) {
            LOGGER.error("Failed to serialize WebSocket message: {}", e.getMessage(), e);
            throw new Exception("Failed to serialize WebSocket message", e);
        }
    }
    
    /**
     * Serialize a WebSocket message to a binary format.
     * 
     * @param message Message to serialize
     * @return Serialized binary data
     * @throws Exception if serialization fails
     */
    @Override
    public ByteBuffer serializeMessageBinary(WebSocketMessage message) throws Exception {
        try {
            String json = serializeMessage(message);
            return ByteBuffer.wrap(json.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            LOGGER.error("Failed to serialize WebSocket message to binary: {}", e.getMessage(), e);
            throw new Exception("Failed to serialize WebSocket message to binary", e);
        }
    }
    
    /**
     * Deserialize a JSON string to a WebSocket message.
     * 
     * @param json JSON string to deserialize
     * @return Deserialized WebSocket message
     * @throws Exception if deserialization fails
     */
    @Override
    public WebSocketMessage deserializeMessage(String json) throws Exception {
        try {
            JsonNode rootNode = objectMapper.readTree(json);
            
            WebSocketMessage message = new WebSocketMessage();
            
            // Extract ID
            if (rootNode.has("id")) {
                message.setId(rootNode.get("id").asText());
            }
            
            // Extract type
            if (rootNode.has("type")) {
                String typeStr = rootNode.get("type").asText();
                try {
                    message.setType(MessageType.valueOf(typeStr));
                } catch (IllegalArgumentException e) {
                    LOGGER.warn("Unknown message type: {}, defaulting to CUSTOM", typeStr);
                    message.setType(MessageType.CUSTOM);
                }
            }
            
            // Extract timestamp
            if (rootNode.has("timestamp")) {
                message.setTimestamp(rootNode.get("timestamp").asLong());
            }
            
            // Extract payload
            if (rootNode.has("payload") && !rootNode.get("payload").isNull()) {
                TypeReference<Map<String, Object>> typeRef = new TypeReference<>() {};
                Map<String, Object> payload = objectMapper.convertValue(rootNode.get("payload"), typeRef);
                message.setPayload(payload);
            }
            
            return message;
        } catch (Exception e) {
            LOGGER.error("Failed to deserialize WebSocket message: {}", e.getMessage(), e);
            throw new Exception("Failed to deserialize WebSocket message: " + e.getMessage(), e);
        }
    }
    
    /**
     * Deserialize binary data to a WebSocket message.
     * 
     * @param data Binary data to deserialize
     * @return Deserialized WebSocket message
     * @throws Exception if deserialization fails
     */
    @Override
    public WebSocketMessage deserializeMessageBinary(ByteBuffer data) throws Exception {
        try {
            byte[] bytes = new byte[data.remaining()];
            data.get(bytes);
            String json = new String(bytes, StandardCharsets.UTF_8);
            return deserializeMessage(json);
        } catch (Exception e) {
            LOGGER.error("Failed to deserialize binary WebSocket message: {}", e.getMessage(), e);
            throw new Exception("Failed to deserialize binary WebSocket message", e);
        }
    }
}

TextMessageHandler.java
-------------------------------------


  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;

/**
 * Interface for handling text WebSocket messages.
 * This interface defines methods for processing text WebSocket messages.
 */
public interface TextMessageHandler {
    
    /**
     * Handle a WebSocket message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Message to handle
     * @return Response message, or null if no response is needed
     * @throws Exception if message handling fails
     */
    WebSocketMessage handleMessage(String sessionId, WebSocketMessage message) throws Exception;
}


TextMessageHandlerImpl.java
--------------------------------------

  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;
import com.cstestforge.framework.core.utils.CSLogger;

import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Map;

/**
 * Implementation of the TextMessageHandler interface.
 * This class processes text WebSocket messages.
 */
@Component
public class TextMessageHandlerImpl implements TextMessageHandler {

    private static final CSLogger LOGGER = new CSLogger(TextMessageHandlerImpl.class);
    
    private final SessionRegistry sessionRegistry;
    private final MessageRouter messageRouter;
    
    /**
     * Constructor with autowired dependencies.
     * 
     * @param sessionRegistry Registry for tracking active WebSocket sessions
     * @param messageRouter Router for routing messages to appropriate handlers
     */
    @Autowired
    public TextMessageHandlerImpl(SessionRegistry sessionRegistry, MessageRouter messageRouter) {
        this.sessionRegistry = sessionRegistry;
        this.messageRouter = messageRouter;
    }
    
    /**
     * Handle a WebSocket message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Message to handle
     * @return Response message, or null if no response is needed
     * @throws Exception if message handling fails
     */
    @Override
    public WebSocketMessage handleMessage(String sessionId, WebSocketMessage message) throws Exception {
        if (message == null) {
            LOGGER.warn("Received null message from session {}", sessionId);
            return null;
        }
        
        MessageType messageType = message.getType();
        if (messageType == null) {
            LOGGER.warn("Received message with null type from session {}", sessionId);
            return message.createErrorResponse("Message type is required");
        }
        
        LOGGER.debug("Handling {} message from session {}", messageType, sessionId);
        
        // Handle heartbeat messages
        if (messageType == MessageType.HEARTBEAT) {
            return handleHeartbeat(sessionId, message);
        }
        
        // Handle subscription messages
        if (messageType == MessageType.SUBSCRIBE) {
            return handleSubscribe(sessionId, message);
        }
        
        // Handle unsubscription messages
        if (messageType == MessageType.UNSUBSCRIBE) {
            return handleUnsubscribe(sessionId, message);
        }
        
        // Handle authentication messages
        if (messageType == MessageType.AUTHENTICATION) {
            return handleAuthentication(sessionId, message);
        }
        
        // Handle client info messages
        if (messageType == MessageType.CLIENT_INFO) {
            return handleClientInfo(sessionId, message);
        }
        
        // Route message to appropriate handler
        return messageRouter.routeTextMessage(sessionId, message);
    }
    
    /**
     * Handle a heartbeat message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Heartbeat message
     * @return Heartbeat response message
     */
    private WebSocketMessage handleHeartbeat(String sessionId, WebSocketMessage message) {
        LOGGER.debug("Received heartbeat from session {}", sessionId);
        return WebSocketMessage.createHeartbeatResponse();
    }
    
    /**
     * Handle a subscription message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Subscription message
     * @return Subscription confirmation message
     */
    private WebSocketMessage handleSubscribe(String sessionId, WebSocketMessage message) {
        String topic = message.getPayloadValueAsString("topic");
        if (topic == null || topic.isEmpty()) {
            LOGGER.warn("Received subscription message without topic from session {}", sessionId);
            return message.createErrorResponse("Topic is required for subscription");
        }
        
        String executionId = message.getPayloadValueAsString("executionId");
        
        LOGGER.info("Session {} subscribing to topic: {}, executionId: {}", 
                sessionId, topic, executionId != null ? executionId : "none");
        
        // Update session registry
        if (executionId != null && !executionId.isEmpty()) {
            sessionRegistry.associateExecutionId(sessionId, executionId);
        }
        
        // Create response
        WebSocketMessage response = message.createResponse(MessageType.SUBSCRIPTION_CONFIRMED);
        response.addPayload("topic", topic);
        if (executionId != null) {
            response.addPayload("executionId", executionId);
        }
        
        return response;
    }
    
    /**
     * Handle an unsubscription message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Unsubscription message
     * @return Unsubscription confirmation message
     */
    private WebSocketMessage handleUnsubscribe(String sessionId, WebSocketMessage message) {
        String topic = message.getPayloadValueAsString("topic");
        if (topic == null || topic.isEmpty()) {
            LOGGER.warn("Received unsubscription message without topic from session {}", sessionId);
            return message.createErrorResponse("Topic is required for unsubscription");
        }
        
        String executionId = message.getPayloadValueAsString("executionId");
        
        LOGGER.info("Session {} unsubscribing from topic: {}, executionId: {}", 
                sessionId, topic, executionId != null ? executionId : "none");
        
        // Update session registry
        if (executionId != null && !executionId.isEmpty()) {
            sessionRegistry.disassociateExecutionId(sessionId);
        }
        
        // Create response
        WebSocketMessage response = message.createResponse(MessageType.SUBSCRIPTION_REMOVED);
        response.addPayload("topic", topic);
        if (executionId != null) {
            response.addPayload("executionId", executionId);
        }
        
        return response;
    }
    
    /**
     * Handle an authentication message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Authentication message
     * @return Authentication result message
     */
    private WebSocketMessage handleAuthentication(String sessionId, WebSocketMessage message) {
        String token = message.getPayloadValueAsString("token");
        if (token == null || token.isEmpty()) {
            LOGGER.warn("Received authentication message without token from session {}", sessionId);
            return message.createErrorResponse("Authentication token is required");
        }
        
        LOGGER.info("Session {} authenticating", sessionId);
        
        // In a real implementation, token would be validated against a secure store
        // For now, assume all tokens with the prefix "cs_" are valid
        boolean isValid = token.startsWith("cs_") && token.length() >= 32;
        
        // Create response
        WebSocketMessage response = message.createResponse(MessageType.AUTHENTICATION_RESULT);
        response.addPayload("authenticated", isValid);
        
        if (isValid) {
            response.addPayload("message", "Authentication successful");
        } else {
            response.addPayload("message", "Authentication failed");
        }
        
        return response;
    }
    
    /**
     * Handle a client info message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Client info message
     * @return Server info message
     */
    private WebSocketMessage handleClientInfo(String sessionId, WebSocketMessage message) {
        Map<String, Object> clientInfo = message.getPayloadValueAsMap("info");
        if (clientInfo == null || clientInfo.isEmpty()) {
            LOGGER.warn("Received client info message without info from session {}", sessionId);
            return message.createErrorResponse("Client info is required");
        }
        
        LOGGER.info("Received client info from session {}: {}", sessionId, clientInfo);
        
        // Create response with server info
        WebSocketMessage response = message.createResponse(MessageType.SERVER_INFO);
        
        Map<String, Object> serverInfo = Map.of(
                "name", "CSTestForge Server",
                "version", "1.0.0",
                "protocolVersion", "1.0",
                "features", Map.of(
                        "recording", true,
                        "execution", true,
                        "reporting", true,
                        "realtime", true,
                        "ai", true
                )
        );
        
        response.addPayload("info", serverInfo);
        
        return response;
    }
}


BinaryMessageHandler.java
------------------------------------------

  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;

import java.nio.ByteBuffer;

/**
 * Interface for handling binary WebSocket messages.
 * This interface defines methods for processing binary WebSocket messages.
 */
public interface BinaryMessageHandler {
    
    /**
     * Handle a binary WebSocket message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Deserialized message
     * @param rawData Raw binary data
     * @return Response message, or null if no response is needed
     * @throws Exception if message handling fails
     */
    WebSocketMessage handleMessage(String sessionId, WebSocketMessage message, ByteBuffer rawData) throws Exception;
}


BinaryMessageHandlerImpl.java
------------------------------------------

  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;
import com.cstestforge.framework.core.utils.CSLogger;

import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Autowired;

import java.nio.ByteBuffer;
import java.util.Map;
import java.util.HashMap;

/**
 * Implementation of the BinaryMessageHandler interface.
 * This class processes binary WebSocket messages.
 */
@Component
public class BinaryMessageHandlerImpl implements BinaryMessageHandler {

    private static final CSLogger LOGGER = new CSLogger(BinaryMessageHandlerImpl.class);
    
    private final SessionRegistry sessionRegistry;
    private final MessageRouter messageRouter;
    
    /**
     * Constructor with autowired dependencies.
     * 
     * @param sessionRegistry Registry for tracking active WebSocket sessions
     * @param messageRouter Router for routing messages to appropriate handlers
     */
    @Autowired
    public BinaryMessageHandlerImpl(SessionRegistry sessionRegistry, MessageRouter messageRouter) {
        this.sessionRegistry = sessionRegistry;
        this.messageRouter = messageRouter;
    }
    
    /**
     * Handle a binary WebSocket message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Deserialized message
     * @param rawData Raw binary data
     * @return Response message, or null if no response is needed
     * @throws Exception if message handling fails
     */
    @Override
    public WebSocketMessage handleMessage(String sessionId, WebSocketMessage message, ByteBuffer rawData) throws Exception {
        if (message == null) {
            LOGGER.warn("Received null message from session {}", sessionId);
            return null;
        }
        
        MessageType messageType = message.getType();
        if (messageType == null) {
            LOGGER.warn("Received message with null type from session {}", sessionId);
            return createErrorResponse("Message type is required");
        }
        
        LOGGER.debug("Handling binary {} message from session {}, size: {} bytes", 
                messageType, sessionId, rawData.remaining());
        
        // Handle different message types
        switch (messageType) {
            case SCREENSHOT:
                return handleScreenshot(sessionId, message, rawData);
                
            case RECORDING_EVENT:
                return handleRecordingEvent(sessionId, message, rawData);
                
            case VIDEO_STREAM:
                return handleVideoStream(sessionId, message, rawData);
                
            default:
                // Route message to appropriate handler
                return messageRouter.routeBinaryMessage(sessionId, message, rawData);
        }
    }
    
    /**
     * Handle a screenshot message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Screenshot message
     * @param rawData Raw screenshot data
     * @return Response message
     */
    private WebSocketMessage handleScreenshot(String sessionId, WebSocketMessage message, ByteBuffer rawData) {
        // Extract metadata from message
        String executionId = message.getPayloadValueAsString("executionId");
        String testId = message.getPayloadValueAsString("testId");
        String screenshotId = message.getPayloadValueAsString("screenshotId");
        String timestamp = message.getPayloadValueAsString("timestamp");
        String stepId = message.getPayloadValueAsString("stepId");
        
        // Validate required fields
        if (executionId == null || testId == null || screenshotId == null) {
            LOGGER.warn("Received screenshot message with missing required fields from session {}", sessionId);
            return createErrorResponse("executionId, testId, and screenshotId are required for screenshot messages");
        }
        
        // Get the image data from the raw data
        byte[] imageData = new byte[rawData.remaining()];
        rawData.get(imageData);
        
        LOGGER.info("Received screenshot from session {}: executionId={}, testId={}, screenshotId={}, size={} bytes",
                sessionId, executionId, testId, screenshotId, imageData.length);
        
        try {
            // Save screenshot to storage
            saveScreenshot(executionId, testId, screenshotId, imageData, timestamp, stepId);
            
            // Create response
            WebSocketMessage response = new WebSocketMessage();
            response.setType(MessageType.SUCCESS);
            response.addPayload("message", "Screenshot received and saved successfully");
            response.addPayload("executionId", executionId);
            response.addPayload("testId", testId);
            response.addPayload("screenshotId", screenshotId);
            
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to save screenshot: {}", e.getMessage(), e);
            return createErrorResponse("Failed to save screenshot: " + e.getMessage());
        }
    }
    
    /**
     * Handle a recording event message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Recording event message
     * @param rawData Raw event data
     * @return Response message
     */
    private WebSocketMessage handleRecordingEvent(String sessionId, WebSocketMessage message, ByteBuffer rawData) {
        // Extract metadata from message
        String recordingSessionId = message.getPayloadValueAsString("recordingSessionId");
        String eventType = message.getPayloadValueAsString("eventType");
        String elementId = message.getPayloadValueAsString("elementId");
        
        // Validate required fields
        if (recordingSessionId == null || eventType == null) {
            LOGGER.warn("Received recording event message with missing required fields from session {}", sessionId);
            return createErrorResponse("recordingSessionId and eventType are required for recording event messages");
        }
        
        // Get the event data from the raw data
        byte[] eventData = new byte[rawData.remaining()];
        rawData.get(eventData);
        
        LOGGER.info("Received recording event from session {}: recordingSessionId={}, eventType={}, size={} bytes",
                sessionId, recordingSessionId, eventType, eventData.length);
        
        try {
            // Process recording event
            Map<String, Object> actionData = processRecordingEvent(recordingSessionId, eventType, elementId, eventData);
            
            // Create response
            WebSocketMessage response = new WebSocketMessage();
            response.setType(MessageType.RECORDING_ACTION);
            response.addPayload("recordingSessionId", recordingSessionId);
            response.addPayload("actionData", actionData);
            
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to process recording event: {}", e.getMessage(), e);
            return createErrorResponse("Failed to process recording event: " + e.getMessage());
        }
    }
    
    /**
     * Handle a video stream message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Video stream message
     * @param rawData Raw video data
     * @return Response message
     */
    private WebSocketMessage handleVideoStream(String sessionId, WebSocketMessage message, ByteBuffer rawData) {
        // Extract metadata from message
        String executionId = message.getPayloadValueAsString("executionId");
        String testId = message.getPayloadValueAsString("testId");
        String frameId = message.getPayloadValueAsString("frameId");
        Integer frameNumber = message.getPayloadValueAsInteger("frameNumber");
        String timestamp = message.getPayloadValueAsString("timestamp");
        
        // Validate required fields
        if (executionId == null || testId == null || frameId == null || frameNumber == null) {
            LOGGER.warn("Received video stream message with missing required fields from session {}", sessionId);
            return createErrorResponse("executionId, testId, frameId, and frameNumber are required for video stream messages");
        }
        
        // Get the video frame data from the raw data
        byte[] frameData = new byte[rawData.remaining()];
        rawData.get(frameData);
        
        LOGGER.debug("Received video frame from session {}: executionId={}, testId={}, frameId={}, frameNumber={}, size={} bytes",
                sessionId, executionId, testId, frameId, frameNumber, frameData.length);
        
        try {
            // Save video frame to storage
            saveVideoFrame(executionId, testId, frameId, frameNumber, frameData, timestamp);
            
            // Create response
            WebSocketMessage response = new WebSocketMessage();
            response.setType(MessageType.SUCCESS);
            response.addPayload("message", "Video frame received and saved successfully");
            response.addPayload("executionId", executionId);
            response.addPayload("testId", testId);
            response.addPayload("frameId", frameId);
            response.addPayload("frameNumber", frameNumber);
            
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to save video frame: {}", e.getMessage(), e);
            return createErrorResponse("Failed to save video frame: " + e.getMessage());
        }
    }
    
    /**
     * Save a screenshot to storage.
     * 
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param screenshotId ID of the screenshot
     * @param imageData Screenshot image data
     * @param timestamp Timestamp of the screenshot
     * @param stepId ID of the test step (optional)
     * @throws Exception if saving fails
     */
    private void saveScreenshot(String executionId, String testId, String screenshotId, byte[] imageData, 
                              String timestamp, String stepId) throws Exception {
        // Create directory structure if it doesn't exist
        String basePath = "screenshots/" + executionId + "/" + testId;
        createDirectoryIfNotExists(basePath);
        
        // Create metadata
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("executionId", executionId);
        metadata.put("testId", testId);
        metadata.put("screenshotId", screenshotId);
        metadata.put("timestamp", timestamp != null ? timestamp : System.currentTimeMillis());
        if (stepId != null) {
            metadata.put("stepId", stepId);
        }
        
        // Save metadata
        String metadataPath = basePath + "/" + screenshotId + ".meta.json";
        saveJson(metadataPath, metadata);
        
        // Save image data
        String imagePath = basePath + "/" + screenshotId + ".png";
        saveFile(imagePath, imageData);
        
        LOGGER.debug("Saved screenshot to {}", imagePath);
    }
    
    /**
     * Process a recording event.
     * 
     * @param recordingSessionId ID of the recording session
     * @param eventType Type of the event
     * @param elementId ID of the element
     * @param eventData Event data
     * @return Generated action data
     * @throws Exception if processing fails
     */
    private Map<String, Object> processRecordingEvent(String recordingSessionId, String eventType, 
                                                   String elementId, byte[] eventData) throws Exception {
        // Parse event data
        String eventJson = new String(eventData, java.nio.charset.StandardCharsets.UTF_8);
        Map<String, Object> parsedEvent = parseJson(eventJson);
        
        // Create directory structure if it doesn't exist
        String basePath = "recordings/" + recordingSessionId;
        createDirectoryIfNotExists(basePath);
        
        // Save event data
        String eventPath = basePath + "/events/" + System.currentTimeMillis() + "_" + eventType + ".json";
        createDirectoryIfNotExists(basePath + "/events");
        saveJson(eventPath, parsedEvent);
        
        // Generate action based on event type
        Map<String, Object> action = new HashMap<>();
        action.put("timestamp", System.currentTimeMillis());
        action.put("actionId", java.util.UUID.randomUUID().toString());
        
        switch (eventType) {
            case "click":
                action.put("actionType", "CLICK");
                if (elementId != null) {
                    action.put("elementId", elementId);
                    action.put("locators", generateLocators(parsedEvent, elementId));
                }
                action.put("x", parsedEvent.get("x"));
                action.put("y", parsedEvent.get("y"));
                break;
                
            case "input":
                action.put("actionType", "TYPE");
                if (elementId != null) {
                    action.put("elementId", elementId);
                    action.put("locators", generateLocators(parsedEvent, elementId));
                }
                action.put("text", parsedEvent.get("text"));
                break;
                
            case "select":
                action.put("actionType", "SELECT");
                if (elementId != null) {
                    action.put("elementId", elementId);
                    action.put("locators", generateLocators(parsedEvent, elementId));
                }
                action.put("value", parsedEvent.get("value"));
                action.put("text", parsedEvent.get("text"));
                break;
                
            case "navigate":
                action.put("actionType", "NAVIGATE");
                action.put("url", parsedEvent.get("url"));
                break;
                
            case "mouseOver":
                action.put("actionType", "HOVER");
                if (elementId != null) {
                    action.put("elementId", elementId);
                    action.put("locators", generateLocators(parsedEvent, elementId));
                }
                action.put("x", parsedEvent.get("x"));
                action.put("y", parsedEvent.get("y"));
                break;
                
            case "keyPress":
                action.put("actionType", "KEY_PRESS");
                action.put("key", parsedEvent.get("key"));
                action.put("keyCode", parsedEvent.get("keyCode"));
                action.put("modifier", parsedEvent.get("modifier"));
                break;
                
            case "dragDrop":
                action.put("actionType", "DRAG_DROP");
                if (elementId != null) {
                    action.put("elementId", elementId);
                    action.put("locators", generateLocators(parsedEvent, elementId));
                }
                action.put("sourceX", parsedEvent.get("sourceX"));
                action.put("sourceY", parsedEvent.get("sourceY"));
                action.put("targetX", parsedEvent.get("targetX"));
                action.put("targetY", parsedEvent.get("targetY"));
                action.put("targetElementId", parsedEvent.get("targetElementId"));
                if (parsedEvent.get("targetElementId") != null) {
                    action.put("targetLocators", generateLocators(parsedEvent, (String) parsedEvent.get("targetElementId")));
                }
                break;
                
            default:
                action.put("actionType", "CUSTOM");
                action.put("eventType", eventType);
                action.put("eventData", parsedEvent);
        }
        
        // Save generated action
        String actionPath = basePath + "/actions/" + action.get("actionId") + ".json";
        createDirectoryIfNotExists(basePath + "/actions");
        saveJson(actionPath, action);
        
        LOGGER.debug("Generated {} action from {} event", action.get("actionType"), eventType);
        
        return action;
    }
    
    /**
     * Save a video frame to storage.
     * 
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param frameId ID of the video frame
     * @param frameNumber Frame number
     * @param frameData Video frame data
     * @param timestamp Timestamp of the frame
     * @throws Exception if saving fails
     */
    private void saveVideoFrame(String executionId, String testId, String frameId, int frameNumber, 
                              byte[] frameData, String timestamp) throws Exception {
        // Create directory structure if it doesn't exist
        String basePath = "videos/" + executionId + "/" + testId;
        createDirectoryIfNotExists(basePath);
        
        // Create metadata
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("executionId", executionId);
        metadata.put("testId", testId);
        metadata.put("frameId", frameId);
        metadata.put("frameNumber", frameNumber);
        metadata.put("timestamp", timestamp != null ? timestamp : System.currentTimeMillis());
        
        // Save frame data
        String framePath = basePath + "/" + String.format("%08d", frameNumber) + ".jpg";
        saveFile(framePath, frameData);
        
        // Update frame index
        String indexPath = basePath + "/index.json";
        Map<String, Object> index;
        if (fileExists(indexPath)) {
            index = loadJson(indexPath);
        } else {
            index = new HashMap<>();
            index.put("executionId", executionId);
            index.put("testId", testId);
            index.put("frames", new HashMap<String, Map<String, Object>>());
        }
        
        Map<String, Map<String, Object>> frames = (Map<String, Map<String, Object>>) index.get("frames");
        frames.put(String.valueOf(frameNumber), metadata);
        
        saveJson(indexPath, index);
        
        LOGGER.debug("Saved video frame {} to {}", frameNumber, framePath);
    }
    
    /**
     * Create a directory if it doesn't exist.
     * 
     * @param path Directory path
     * @throws Exception if directory creation fails
     */
    private void createDirectoryIfNotExists(String path) throws Exception {
        java.io.File directory = new java.io.File(path);
        if (!directory.exists()) {
            if (!directory.mkdirs()) {
                throw new Exception("Failed to create directory: " + path);
            }
        }
    }
    
    /**
     * Save a file.
     * 
     * @param path File path
     * @param data File data
     * @throws Exception if saving fails
     */
    private void saveFile(String path, byte[] data) throws Exception {
        try (java.io.FileOutputStream fos = new java.io.FileOutputStream(path)) {
            fos.write(data);
        } catch (Exception e) {
            throw new Exception("Failed to save file: " + path, e);
        }
    }
    
    /**
     * Check if a file exists.
     * 
     * @param path File path
     * @return True if the file exists, false otherwise
     */
    private boolean fileExists(String path) {
        return new java.io.File(path).exists();
    }
    
    /**
     * Save JSON data to a file.
     * 
     * @param path File path
     * @param data JSON data
     * @throws Exception if saving fails
     */
    private void saveJson(String path, Map<String, Object> data) throws Exception {
        try {
            com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
            mapper.writeValue(new java.io.File(path), data);
        } catch (Exception e) {
            throw new Exception("Failed to save JSON file: " + path, e);
        }
    }
    
    /**
     * Load JSON data from a file.
     * 
     * @param path File path
     * @return JSON data
     * @throws Exception if loading fails
     */
    private Map<String, Object> loadJson(String path) throws Exception {
        try {
            com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
            return mapper.readValue(new java.io.File(path), 
                    new com.fasterxml.jackson.core.type.TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            throw new Exception("Failed to load JSON file: " + path, e);
        }
    }
    
    /**
     * Parse JSON data.
     * 
     * @param json JSON string
     * @return Parsed JSON data
     * @throws Exception if parsing fails
     */
    private Map<String, Object> parseJson(String json) throws Exception {
        try {
            com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
            return mapper.readValue(json, 
                    new com.fasterxml.jackson.core.type.TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            throw new Exception("Failed to parse JSON", e);
        }
    }
    
    /**
     * Generate locators for an element.
     * 
     * @param eventData Event data
     * @param elementId Element ID
     * @return Map of locator types to locator values
     */
    private Map<String, String> generateLocators(Map<String, Object> eventData, String elementId) {
        Map<String, String> locators = new HashMap<>();
        
        // Extract element information from event data
        Map<String, Object> elementInfo = null;
        if (eventData.containsKey("element")) {
            elementInfo = (Map<String, Object>) eventData.get("element");
        } else if (eventData.containsKey("elements")) {
            Map<String, Object> elements = (Map<String, Object>) eventData.get("elements");
            elementInfo = (Map<String, Object>) elements.get(elementId);
        }
        
        if (elementInfo == null) {
            // If element info is not available, just use the element ID
            locators.put("id", elementId);
            return locators;
        }
        
        // Generate locators based on element attributes
        if (elementInfo.containsKey("id") && elementInfo.get("id") != null && !((String) elementInfo.get("id")).isEmpty()) {
            locators.put("id", (String) elementInfo.get("id"));
        }
        
        if (elementInfo.containsKey("name") && elementInfo.get("name") != null && !((String) elementInfo.get("name")).isEmpty()) {
            locators.put("name", (String) elementInfo.get("name"));
        }
        
        if (elementInfo.containsKey("className") && elementInfo.get("className") != null && !((String) elementInfo.get("className")).isEmpty()) {
            locators.put("className", (String) elementInfo.get("className"));
        }
        
        if (elementInfo.containsKey("tagName") && elementInfo.get("tagName") != null && !((String) elementInfo.get("tagName")).isEmpty()) {
            locators.put("tagName", (String) elementInfo.get("tagName"));
        }
        
        if (elementInfo.containsKey("xpath") && elementInfo.get("xpath") != null && !((String) elementInfo.get("xpath")).isEmpty()) {
            locators.put("xpath", (String) elementInfo.get("xpath"));
        }
        
        if (elementInfo.containsKey("cssSelector") && elementInfo.get("cssSelector") != null && !((String) elementInfo.get("cssSelector")).isEmpty()) {
            locators.put("cssSelector", (String) elementInfo.get("cssSelector"));
        }
        
        if (elementInfo.containsKey("text") && elementInfo.get("text") != null && !((String) elementInfo.get("text")).isEmpty()) {
            locators.put("linkText", (String) elementInfo.get("text"));
        }
        
        // Generate XPath locator if not already present
        if (!locators.containsKey("xpath") && elementInfo.containsKey("attributes")) {
            Map<String, Object> attributes = (Map<String, Object>) elementInfo.get("attributes");
            StringBuilder xpathBuilder = new StringBuilder("//");
            
            // Add tag name
            String tagName = (String) elementInfo.get("tagName");
            xpathBuilder.append(tagName != null ? tagName.toLowerCase() : "*");
            
            // Add attributes
            if (attributes.containsKey("id")) {
                xpathBuilder.append("[@id='").append(attributes.get("id")).append("']");
            } else if (attributes.containsKey("name")) {
                xpathBuilder.append("[@name='").append(attributes.get("name")).append("']");
            } else if (attributes.containsKey("class")) {
                xpathBuilder.append("[@class='").append(attributes.get("class")).append("']");
            } else if (elementInfo.containsKey("text") && elementInfo.get("text") != null) {
                xpathBuilder.append("[text()='").append(elementInfo.get("text")).append("']");
            }
            
            locators.put("xpath", xpathBuilder.toString());
        }
        
        return locators;
    }
    
    /**
     * Create an error response message.
     * 
     * @param errorMessage Error message
     * @return Error response message
     */
    private WebSocketMessage createErrorResponse(String errorMessage) {
        WebSocketMessage response = new WebSocketMessage();
        response.setType(MessageType.ERROR);
        response.addPayload("error", errorMessage);
        return response;
    }
}


MessageRouter.java
--------------------------------

  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;

import org.springframework.web.socket.WebSocketSession;

import java.nio.ByteBuffer;

/**
 * Interface for routing WebSocket messages to appropriate handlers.
 * This interface defines methods for routing different types of messages.
 */
public interface MessageRouter {
    
    /**
     * Route a message to the appropriate handler based on message type.
     * 
     * @param session WebSocket session
     * @param message WebSocket message to route
     * @return Response message from the handler, or null if no response is needed
     * @throws Exception if routing fails
     */
    WebSocketMessage routeMessage(WebSocketSession session, WebSocketMessage message) throws Exception;
    
    /**
     * Route a text message to the appropriate handler based on message type.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message WebSocket message to route
     * @return Response message from the handler, or null if no response is needed
     * @throws Exception if routing fails
     */
    WebSocketMessage routeTextMessage(String sessionId, WebSocketMessage message) throws Exception;
    
    /**
     * Route a binary message to the appropriate handler based on message type.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Deserialized WebSocket message
     * @param rawData Raw binary data
     * @return Response message from the handler, or null if no response is needed
     * @throws Exception if routing fails
     */
    WebSocketMessage routeBinaryMessage(String sessionId, WebSocketMessage message, ByteBuffer rawData) throws Exception;
    
    /**
     * Register a message handler for a specific message type.
     * 
     * @param messageType Type of messages to handle
     * @param handler Handler to register
     */
    void registerHandler(String messageType, MessageHandler handler);
    
    /**
     * Unregister a message handler for a specific message type.
     * 
     * @param messageType Type of messages to unhandle
     * @return True if a handler was unregistered, false otherwise
     */
    boolean unregisterHandler(String messageType);
    
    /**
     * Check if a handler is registered for a specific message type.
     * 
     * @param messageType Type of messages to check
     * @return True if a handler is registered, false otherwise
     */
    boolean hasHandlerForType(String messageType);
    
    /**
     * Get all registered message handlers.
     * 
     * @return List of registered message handlers
     */
    java.util.List<MessageHandler> getRegisteredHandlers();
}


MessageRouter.java
------------------------------------
  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;

import org.springframework.web.socket.WebSocketSession;

import java.nio.ByteBuffer;

/**
 * Interface for routing WebSocket messages to appropriate handlers.
 * This interface defines methods for routing different types of messages.
 */
public interface MessageRouter {
    
    /**
     * Route a message to the appropriate handler based on message type.
     * 
     * @param session WebSocket session
     * @param message WebSocket message to route
     * @return Response message from the handler, or null if no response is needed
     * @throws Exception if routing fails
     */
    WebSocketMessage routeMessage(WebSocketSession session, WebSocketMessage message) throws Exception;
    
    /**
     * Route a text message to the appropriate handler based on message type.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message WebSocket message to route
     * @return Response message from the handler, or null if no response is needed
     * @throws Exception if routing fails
     */
    WebSocketMessage routeTextMessage(String sessionId, WebSocketMessage message) throws Exception;
    
    /**
     * Route a binary message to the appropriate handler based on message type.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Deserialized WebSocket message
     * @param rawData Raw binary data
     * @return Response message from the handler, or null if no response is needed
     * @throws Exception if routing fails
     */
    WebSocketMessage routeBinaryMessage(String sessionId, WebSocketMessage message, ByteBuffer rawData) throws Exception;
    
    /**
     * Register a message handler for a specific message type.
     * 
     * @param messageType Type of messages to handle
     * @param handler Handler to register
     */
    void registerHandler(String messageType, MessageHandler handler);
    
    /**
     * Unregister a message handler for a specific message type.
     * 
     * @param messageType Type of messages to unhandle
     * @return True if a handler was unregistered, false otherwise
     */
    boolean unregisterHandler(String messageType);
    
    /**
     * Check if a handler is registered for a specific message type.
     * 
     * @param messageType Type of messages to check
     * @return True if a handler is registered, false otherwise
     */
    boolean hasHandlerForType(String messageType);
    
    /**
     * Get all registered message handlers.
     * 
     * @return List of registered message handlers
     */
    java.util.List<MessageHandler> getRegisteredHandlers();
}


MessageHandler.java
-------------------------------------------------------
  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;

import java.nio.ByteBuffer;
import java.util.Set;

/**
 * Interface for handling WebSocket messages.
 * This interface defines methods for processing WebSocket messages of specific types.
 */
public interface MessageHandler {
    
    /**
     * Get the message types that this handler can process.
     * 
     * @return Set of message types
     */
    Set<MessageType> getSupportedMessageTypes();
    
    /**
     * Check if this handler can process a specific message type.
     * 
     * @param messageType Message type to check
     * @return True if this handler can process the message type, false otherwise
     */
    boolean canHandle(MessageType messageType);
    
    /**
     * Handle a text WebSocket message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Message to handle
     * @return Response message, or null if no response is needed
     * @throws Exception if message handling fails
     */
    WebSocketMessage handleTextMessage(String sessionId, WebSocketMessage message) throws Exception;
    
    /**
     * Handle a binary WebSocket message.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Deserialized message
     * @param rawData Raw binary data
     * @return Response message, or null if no response is needed
     * @throws Exception if message handling fails
     */
    WebSocketMessage handleBinaryMessage(String sessionId, WebSocketMessage message, ByteBuffer rawData) throws Exception;
    
    /**
     * Get the priority of this handler.
     * Handlers with higher priority are executed first.
     * 
     * @return Handler priority
     */
    int getPriority();
    
    /**
     * Get the name of this handler.
     * 
     * @return Handler name
     */
    String getName();
}


MessageRouterImpl.java
--------------------------------------

  package com.cstestforge.service.websocket;

import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;
import com.cstestforge.framework.core.utils.CSLogger;

import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.socket.WebSocketSession;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.Comparator;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Implementation of the MessageRouter interface.
 * This class routes WebSocket messages to appropriate handlers based on message type.
 */
@Component
public class MessageRouterImpl implements MessageRouter {

    private static final CSLogger LOGGER = new CSLogger(MessageRouterImpl.class);
    
    private final List<MessageHandler> handlers = new CopyOnWriteArrayList<>();
    private final Map<MessageType, List<MessageHandler>> handlersByType = new HashMap<>();
    
    /**
     * Constructor.
     * 
     * @param handlers List of message handlers to register
     */
    @Autowired
    public MessageRouterImpl(List<MessageHandler> handlers) {
        if (handlers != null) {
            for (MessageHandler handler : handlers) {
                registerHandler(handler);
            }
        }
    }
    
    /**
     * Route a message to the appropriate handler based on message type.
     * 
     * @param session WebSocket session
     * @param message WebSocket message to route
     * @return Response message from the handler, or null if no response is needed
     * @throws Exception if routing fails
     */
    @Override
    public WebSocketMessage routeMessage(WebSocketSession session, WebSocketMessage message) throws Exception {
        if (session == null || message == null) {
            return null;
        }
        
        return routeTextMessage(session.getId(), message);
    }
    
    /**
     * Route a text message to the appropriate handler based on message type.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message WebSocket message to route
     * @return Response message from the handler, or null if no response is needed
     * @throws Exception if routing fails
     */
    @Override
    public WebSocketMessage routeTextMessage(String sessionId, WebSocketMessage message) throws Exception {
        if (message == null || message.getType() == null) {
            LOGGER.warn("Cannot route null message or message with null type for session {}", sessionId);
            return null;
        }
        
        MessageType messageType = message.getType();
        
        LOGGER.debug("Routing {} message for session {}", messageType, sessionId);
        
        List<MessageHandler> matchingHandlers = getHandlersForType(messageType);
        if (matchingHandlers.isEmpty()) {
            LOGGER.warn("No handler found for message type: {}", messageType);
            return createNoHandlerResponse(message);
        }
        
        for (MessageHandler handler : matchingHandlers) {
            try {
                WebSocketMessage response = handler.handleTextMessage(sessionId, message);
                if (response != null) {
                    LOGGER.debug("Handler {} processed {} message for session {}", 
                            handler.getName(), messageType, sessionId);
                    return response;
                }
            } catch (Exception e) {
                LOGGER.error("Error in handler {} processing {} message for session {}: {}", 
                        handler.getName(), messageType, sessionId, e.getMessage(), e);
                throw e;
            }
        }
        
        LOGGER.debug("No handler returned a response for {} message for session {}", messageType, sessionId);
        return null;
    }
    
    /**
     * Route a binary message to the appropriate handler based on message type.
     * 
     * @param sessionId ID of the WebSocket session
     * @param message Deserialized WebSocket message
     * @param rawData Raw binary data
     * @return Response message from the handler, or null if no response is needed
     * @throws Exception if routing fails
     */
    @Override
    public WebSocketMessage routeBinaryMessage(String sessionId, WebSocketMessage message, ByteBuffer rawData) throws Exception {
        if (message == null || message.getType() == null) {
            LOGGER.warn("Cannot route null message or message with null type for session {}", sessionId);
            return null;
        }
        
        MessageType messageType = message.getType();
        
        LOGGER.debug("Routing binary {} message for session {}, size: {} bytes", 
                messageType, sessionId, rawData.remaining());
        
        List<MessageHandler> matchingHandlers = getHandlersForType(messageType);
        if (matchingHandlers.isEmpty()) {
            LOGGER.warn("No handler found for binary message type: {}", messageType);
            return createNoHandlerResponse(message);
        }
        
        for (MessageHandler handler : matchingHandlers) {
            try {
                WebSocketMessage response = handler.handleBinaryMessage(sessionId, message, rawData);
                if (response != null) {
                    LOGGER.debug("Handler {} processed binary {} message for session {}", 
                            handler.getName(), messageType, sessionId);
                    return response;
                }
            } catch (Exception e) {
                LOGGER.error("Error in handler {} processing binary {} message for session {}: {}", 
                        handler.getName(), messageType, sessionId, e.getMessage(), e);
                throw e;
            }
        }
        
        LOGGER.debug("No handler returned a response for binary {} message for session {}", messageType, sessionId);
        return null;
    }
    
    /**
     * Register a message handler for a specific message type.
     * 
     * @param messageType Type of messages to handle
     * @param handler Handler to register
     */
    @Override
    public void registerHandler(String messageType, MessageHandler handler) {
        if (messageType == null || handler == null) {
            return;
        }
        
        try {
            MessageType type = MessageType.valueOf(messageType);
            registerHandlerForType(type, handler);
        } catch (IllegalArgumentException e) {
            LOGGER.warn("Invalid message type: {}", messageType);
        }
    }
    
    /**
     * Unregister a message handler for a specific message type.
     * 
     * @param messageType Type of messages to unhandle
     * @return True if a handler was unregistered, false otherwise
     */
    @Override
    public boolean unregisterHandler(String messageType) {
        if (messageType == null) {
            return false;
        }
        
        try {
            MessageType type = MessageType.valueOf(messageType);
            List<MessageHandler> typeHandlers = handlersByType.get(type);
            if (typeHandlers != null) {
                handlersByType.remove(type);
                return true;
            }
            return false;
        } catch (IllegalArgumentException e) {
            LOGGER.warn("Invalid message type: {}", messageType);
            return false;
        }
    }
    
    /**
     * Check if a handler is registered for a specific message type.
     * 
     * @param messageType Type of messages to check
     * @return True if a handler is registered, false otherwise
     */
    @Override
    public boolean hasHandlerForType(String messageType) {
        if (messageType == null) {
            return false;
        }
        
        try {
            MessageType type = MessageType.valueOf(messageType);
            List<MessageHandler> typeHandlers = handlersByType.get(type);
            return typeHandlers != null && !typeHandlers.isEmpty();
        } catch (IllegalArgumentException e) {
            LOGGER.warn("Invalid message type: {}", messageType);
            return false;
        }
    }
    
    /**
     * Get all registered message handlers.
     * 
     * @return List of registered message handlers
     */
    @Override
    public List<MessageHandler> getRegisteredHandlers() {
        return Collections.unmodifiableList(handlers);
    }
    
    /**
     * Register a message handler.
     * 
     * @param handler Handler to register
     */
    private void registerHandler(MessageHandler handler) {
        if (handler == null) {
            return;
        }
        
        handlers.add(handler);
        
        // Sort handlers by priority (highest first)
        Collections.sort(handlers, Comparator.comparingInt(MessageHandler::getPriority).reversed());
        
        // Register handler for each supported message type
        for (MessageType type : handler.getSupportedMessageTypes()) {
            registerHandlerForType(type, handler);
        }
        
        LOGGER.info("Registered message handler: {}, supported types: {}", 
                handler.getName(), handler.getSupportedMessageTypes());
    }
    
    /**
     * Register a handler for a specific message type.
     * 
     * @param type Message type
     * @param handler Handler to register
     */
    private void registerHandlerForType(MessageType type, MessageHandler handler) {
        List<MessageHandler> typeHandlers = handlersByType.computeIfAbsent(type, k -> new ArrayList<>());
        typeHandlers.add(handler);
        
        // Sort handlers by priority (highest first)
        typeHandlers.sort(Comparator.comparingInt(MessageHandler::getPriority).reversed());
    }
    
    /**
     * Get handlers for a specific message type.
     * 
     * @param type Message type
     * @return List of handlers for the message type
     */
    private List<MessageHandler> getHandlersForType(MessageType type) {
        List<MessageHandler> typeHandlers = handlersByType.get(type);
        if (typeHandlers != null) {
            return new ArrayList<>(typeHandlers);
        }
        return Collections.emptyList();
    }
    
    /**
     * Create a response for messages that have no handler.
     * 
     * @param message Original message
     * @return Response message
     */
    private WebSocketMessage createNoHandlerResponse(WebSocketMessage message) {
        WebSocketMessage response = new WebSocketMessage();
        response.setType(MessageType.ERROR);
        response.addPayload("error", "No handler found for message type: " + message.getType());
        response.addPayload("requestId", message.getId());
        return response;
    }
}


LiveExecutionService.java
--------------------------------------------

  package com.cstestforge.service.realtime;

import com.cstestforge.model.execution.TestExecutionResult;
import com.cstestforge.model.execution.TestStatus;
import com.cstestforge.model.execution.TestLog;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.List;
import java.util.Set;
import java.util.Map;

/**
 * Service for providing real-time execution updates.
 * This interface defines methods for broadcasting execution updates
 * and managing WebSocket and SSE clients.
 */
public interface LiveExecutionService {
    
    /**
     * Register an SSE client for receiving execution updates.
     * 
     * @param executionId ID of the test execution
     * @param emitter SSE emitter for sending events to the client
     */
    void registerClient(String executionId, SseEmitter emitter);
    
    /**
     * Unregister an SSE client.
     * 
     * @param executionId ID of the test execution
     * @param emitter SSE emitter to unregister
     */
    void unregisterClient(String executionId, SseEmitter emitter);
    
    /**
     * Get all registered SSE clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @return Set of registered SSE emitters
     */
    Set<SseEmitter> getClientsForExecution(String executionId);
    
    /**
     * Get the number of registered SSE clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @return Number of registered SSE emitters
     */
    int getClientCount(String executionId);
    
    /**
     * Send a status update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param status Execution status
     */
    void sendStatusUpdate(SseEmitter emitter, String executionId, TestStatus status);
    
    /**
     * Send a progress update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param progress Execution progress (0.0 to 1.0)
     */
    void sendProgressUpdate(SseEmitter emitter, String executionId, double progress);
    
    /**
     * Send a results update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param results Test execution results
     */
    void sendResultsUpdate(SseEmitter emitter, String executionId, List<TestExecutionResult> results);
    
    /**
     * Send a log update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param log Test log entry
     */
    void sendLogUpdate(SseEmitter emitter, String executionId, String testId, TestLog log);
    
    /**
     * Send an error update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param error Error message
     */
    void sendErrorUpdate(SseEmitter emitter, String executionId, String error);
    
    /**
     * Broadcast a status update to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param status Execution status
     * @return Number of clients the update was sent to
     */
    int broadcastExecutionStatus(String executionId, TestStatus status);
    
    /**
     * Broadcast a progress update to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param progress Execution progress (0.0 to 1.0)
     * @return Number of clients the update was sent to
     */
    int broadcastExecutionProgress(String executionId, double progress);
    
    /**
     * Broadcast a results update to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param results Test execution results
     * @return Number of clients the update was sent to
     */
    int broadcastExecutionResults(String executionId, List<TestExecutionResult> results);
    
    /**
     * Broadcast a complete notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param results Final test execution results
     * @return Number of clients the notification was sent to
     */
    int broadcastExecutionComplete(String executionId, List<TestExecutionResult> results);
    
    /**
     * Broadcast an error notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param error Error message
     * @return Number of clients the notification was sent to
     */
    int broadcastExecutionError(String executionId, String error);
    
    /**
     * Broadcast a log update to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param log Test log entry
     * @return Number of clients the update was sent to
     */
    int broadcastTestLog(String executionId, String testId, TestLog log);
    
    /**
     * Broadcast a test start notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param testName Name of the test
     * @return Number of clients the notification was sent to
     */
    int broadcastTestStart(String executionId, String testId, String testName);
    
    /**
     * Broadcast a test complete notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param result Test execution result
     * @return Number of clients the notification was sent to
     */
    int broadcastTestComplete(String executionId, TestExecutionResult result);
    
    /**
     * Broadcast a screenshot capture notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param screenshotId ID of the screenshot
     * @param timestamp Timestamp of the screenshot
     * @return Number of clients the notification was sent to
     */
    int broadcastScreenshotCaptured(String executionId, String testId, String screenshotId, long timestamp);
    
    /**
     * Broadcast custom data to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param eventType Type of the event
     * @param data Event data
     * @return Number of clients the data was sent to
     */
    int broadcastCustomData(String executionId, String eventType, Map<String, Object> data);
    
    /**
     * Start the service.
     */
    void start();
    
    /**
     * Stop the service.
     */
    void stop();
    
    /**
     * Check if the service is running.
     * 
     * @return True if the service is running, false otherwise
     */
    boolean isRunning();
}


LiveExecutionServiceImpl.java
-------------------------------------------------

  package com.cstestforge.service.realtime;

import com.cstestforge.model.execution.TestExecutionResult;
import com.cstestforge.model.execution.TestStatus;
import com.cstestforge.model.execution.TestLog;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.model.websocket.MessageType;
import com.cstestforge.service.websocket.MessagePublisher;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter.SseEventBuilder;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Collections;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Implementation of the LiveExecutionService interface.
 * This class provides real-time execution updates to clients via SSE and WebSockets.
 */
@Service
public class LiveExecutionServiceImpl implements LiveExecutionService {

    private static final CSLogger LOGGER = new CSLogger(LiveExecutionServiceImpl.class);
    
    private final Map<String, Set<SseEmitter>> executionClients = new ConcurrentHashMap<>();
    private final AtomicBoolean running = new AtomicBoolean(false);
    
    private final MessagePublisher messagePublisher;
    
    private static final String SSE_EVENT_STATUS = "status";
    private static final String SSE_EVENT_PROGRESS = "progress";
    private static final String SSE_EVENT_RESULT = "result";
    private static final String SSE_EVENT_COMPLETE = "complete";
    private static final String SSE_EVENT_ERROR = "error";
    private static final String SSE_EVENT_LOG = "log";
    private static final String SSE_EVENT_TEST_START = "test_start";
    private static final String SSE_EVENT_TEST_COMPLETE = "test_complete";
    private static final String SSE_EVENT_SCREENSHOT = "screenshot";
    private static final String SSE_EVENT_CUSTOM = "custom";
    
    /**
     * Constructor with autowired dependencies.
     * 
     * @param messagePublisher Publisher for WebSocket messages
     */
    @Autowired
    public LiveExecutionServiceImpl(MessagePublisher messagePublisher) {
        this.messagePublisher = messagePublisher;
    }
    
    /**
     * Initialize the service.
     */
    @PostConstruct
    public void init() {
        start();
    }
    
    /**
     * Clean up resources when the service is shutting down.
     */
    @PreDestroy
    public void cleanup() {
        stop();
    }
    
    /**
     * Start the service.
     */
    @Override
    public void start() {
        if (running.compareAndSet(false, true)) {
            LOGGER.info("Starting live execution service");
        }
    }
    
    /**
     * Stop the service.
     */
    @Override
    public void stop() {
        if (running.compareAndSet(true, false)) {
            LOGGER.info("Stopping live execution service");
            
            // Complete all SSE emitters
            for (Set<SseEmitter> emitters : executionClients.values()) {
                for (SseEmitter emitter : emitters) {
                    try {
                        emitter.complete();
                    } catch (Exception e) {
                        LOGGER.error("Error completing SSE emitter: {}", e.getMessage(), e);
                    }
                }
            }
            
            // Clear all collections
            executionClients.clear();
        }
    }
    
    /**
     * Check if the service is running.
     * 
     * @return True if the service is running, false otherwise
     */
    @Override
    public boolean isRunning() {
        return running.get();
    }
    
    /**
     * Register an SSE client for receiving execution updates.
     * 
     * @param executionId ID of the test execution
     * @param emitter SSE emitter for sending events to the client
     */
    @Override
    public void registerClient(String executionId, SseEmitter emitter) {
        if (!running.get()) {
            LOGGER.warn("Cannot register client: Service is not running");
            emitter.completeWithError(new IllegalStateException("Service is not running"));
            return;
        }
        
        LOGGER.info("Registering client for execution: {}", executionId);
        
        Set<SseEmitter> clients = executionClients.computeIfAbsent(
                executionId, k -> new CopyOnWriteArraySet<>());
        
        clients.add(emitter);
        
        // Set completion callback to remove the emitter
        emitter.onCompletion(() -> {
            LOGGER.debug("SSE emitter completed for execution: {}", executionId);
            unregisterClient(executionId, emitter);
        });
        
        // Set timeout callback to remove the emitter
        emitter.onTimeout(() -> {
            LOGGER.debug("SSE emitter timed out for execution: {}", executionId);
            unregisterClient(executionId, emitter);
        });
        
        // Set error callback to remove the emitter
        emitter.onError(e -> {
            LOGGER.error("SSE emitter error for execution: {}: {}", executionId, e.getMessage(), e);
            unregisterClient(executionId, emitter);
        });
        
        LOGGER.debug("Client registered for execution: {}, total clients: {}", 
                executionId, clients.size());
    }
    
    /**
     * Unregister an SSE client.
     * 
     * @param executionId ID of the test execution
     * @param emitter SSE emitter to unregister
     */
    @Override
    public void unregisterClient(String executionId, SseEmitter emitter) {
        LOGGER.debug("Unregistering client for execution: {}", executionId);
        
        Set<SseEmitter> clients = executionClients.get(executionId);
        if (clients != null) {
            clients.remove(emitter);
            
            // Remove execution ID if no clients remain
            if (clients.isEmpty()) {
                executionClients.remove(executionId);
            }
            
            LOGGER.debug("Client unregistered for execution: {}, remaining clients: {}", 
                    executionId, clients.size());
        }
    }
    
    /**
     * Get all registered SSE clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @return Set of registered SSE emitters
     */
    @Override
    public Set<SseEmitter> getClientsForExecution(String executionId) {
        Set<SseEmitter> clients = executionClients.get(executionId);
        return clients != null ? Collections.unmodifiableSet(clients) : Collections.emptySet();
    }
    
    /**
     * Get the number of registered SSE clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @return Number of registered SSE emitters
     */
    @Override
    public int getClientCount(String executionId) {
        Set<SseEmitter> clients = executionClients.get(executionId);
        return clients != null ? clients.size() : 0;
    }
    
    /**
     * Send a status update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param status Execution status
     */
    @Override
    public void sendStatusUpdate(SseEmitter emitter, String executionId, TestStatus status) {
        if (emitter == null) {
            return;
        }
        
        try {
            Map<String, Object> data = new HashMap<>();
            data.put("executionId", executionId);
            data.put("status", status.name());
            data.put("timestamp", System.currentTimeMillis());
            
            SseEventBuilder event = SseEmitter.event()
                    .name(SSE_EVENT_STATUS)
                    .data(data);
            
            emitter.send(event);
            
            LOGGER.debug("Status update sent to client for execution: {}, status: {}", 
                    executionId, status);
        } catch (IOException e) {
            LOGGER.error("Failed to send status update to client for execution: {}: {}", 
                    executionId, e.getMessage(), e);
            emitter.completeWithError(e);
        }
    }
    
    /**
     * Send a progress update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param progress Execution progress (0.0 to 1.0)
     */
    @Override
    public void sendProgressUpdate(SseEmitter emitter, String executionId, double progress) {
        if (emitter == null) {
            return;
        }
        
        try {
            Map<String, Object> data = new HashMap<>();
            data.put("executionId", executionId);
            data.put("progress", progress);
            data.put("timestamp", System.currentTimeMillis());
            
            SseEventBuilder event = SseEmitter.event()
                    .name(SSE_EVENT_PROGRESS)
                    .data(data);
            
            emitter.send(event);
            
            LOGGER.debug("Progress update sent to client for execution: {}, progress: {}", 
                    executionId, progress);
        } catch (IOException e) {
            LOGGER.error("Failed to send progress update to client for execution: {}: {}", 
                    executionId, e.getMessage(), e);
            emitter.completeWithError(e);
        }
    }
    
    /**
     * Send a results update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param results Test execution results
     */
    @Override
    public void sendResultsUpdate(SseEmitter emitter, String executionId, List<TestExecutionResult> results) {
        if (emitter == null || results == null) {
            return;
        }
        
        try {
            Map<String, Object> data = new HashMap<>();
            data.put("executionId", executionId);
            data.put("results", results);
            data.put("timestamp", System.currentTimeMillis());
            
            SseEventBuilder event = SseEmitter.event()
                    .name(SSE_EVENT_RESULT)
                    .data(data);
            
            emitter.send(event);
            
            LOGGER.debug("Results update sent to client for execution: {}, results count: {}", 
                    executionId, results.size());
        } catch (IOException e) {
            LOGGER.error("Failed to send results update to client for execution: {}: {}", 
                    executionId, e.getMessage(), e);
            emitter.completeWithError(e);
        }
    }
    
    /**
     * Send a log update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param log Test log entry
     */
    @Override
    public void sendLogUpdate(SseEmitter emitter, String executionId, String testId, TestLog log) {
        if (emitter == null || log == null) {
            return;
        }
        
        try {
            Map<String, Object> data = new HashMap<>();
            data.put("executionId", executionId);
            data.put("testId", testId);
            data.put("log", log);
            data.put("timestamp", System.currentTimeMillis());
            
            SseEventBuilder event = SseEmitter.event()
                    .name(SSE_EVENT_LOG)
                    .data(data);
            
            emitter.send(event);
            
            LOGGER.debug("Log update sent to client for execution: {}, test: {}, level: {}", 
                    executionId, testId, log.getLevel());
        } catch (IOException e) {
            LOGGER.error("Failed to send log update to client for execution: {}, test: {}: {}", 
                    executionId, testId, e.getMessage(), e);
            emitter.completeWithError(e);
        }
    }
    
    /**
     * Send an error update to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param executionId ID of the test execution
     * @param error Error message
     */
    @Override
    public void sendErrorUpdate(SseEmitter emitter, String executionId, String error) {
        if (emitter == null) {
            return;
        }
        
        try {
            Map<String, Object> data = new HashMap<>();
            data.put("executionId", executionId);
            data.put("error", error);
            data.put("timestamp", System.currentTimeMillis());
            
            SseEventBuilder event = SseEmitter.event()
                    .name(SSE_EVENT_ERROR)
                    .data(data);
            
            emitter.send(event);
            
            LOGGER.debug("Error update sent to client for execution: {}, error: {}", 
                    executionId, error);
        } catch (IOException e) {
            LOGGER.error("Failed to send error update to client for execution: {}: {}", 
                    executionId, e.getMessage(), e);
            emitter.completeWithError(e);
        }
    }
    
    /**
     * Broadcast a status update to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param status Execution status
     * @return Number of clients the update was sent to
     */
    @Override
    public int broadcastExecutionStatus(String executionId, TestStatus status) {
        LOGGER.info("Broadcasting execution status: {}, status: {}", executionId, status);
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_STATUS, buildStatusData(executionId, status));
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.EXECUTION_STATUS_UPDATE);
        message.setPayload(buildStatusData(executionId, status));
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Status update broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast a progress update to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param progress Execution progress (0.0 to 1.0)
     * @return Number of clients the update was sent to
     */
    @Override
    public int broadcastExecutionProgress(String executionId, double progress) {
        LOGGER.debug("Broadcasting execution progress: {}, progress: {}", executionId, progress);
        
        // Prepare data
        Map<String, Object> data = new HashMap<>();
        data.put("executionId", executionId);
        data.put("progress", progress);
        data.put("timestamp", System.currentTimeMillis());
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_PROGRESS, data);
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.EXECUTION_STATUS_UPDATE);
        message.setPayload(data);
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Progress update broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast a results update to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param results Test execution results
     * @return Number of clients the update was sent to
     */
    @Override
    public int broadcastExecutionResults(String executionId, List<TestExecutionResult> results) {
        if (results == null) {
            return 0;
        }
        
        LOGGER.debug("Broadcasting execution results: {}, results count: {}", 
                executionId, results.size());
        
        // Prepare data
        Map<String, Object> data = new HashMap<>();
        data.put("executionId", executionId);
        data.put("results", results);
        data.put("timestamp", System.currentTimeMillis());
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_RESULT, data);
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.TEST_RESULT);
        message.setPayload(data);
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Results update broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast a complete notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param results Final test execution results
     * @return Number of clients the notification was sent to
     */
    @Override
    public int broadcastExecutionComplete(String executionId, List<TestExecutionResult> results) {
        LOGGER.info("Broadcasting execution complete: {}", executionId);
        
        // Prepare data
        Map<String, Object> data = new HashMap<>();
        data.put("executionId", executionId);
        data.put("status", TestStatus.COMPLETED.name());
        data.put("results", results);
        data.put("timestamp", System.currentTimeMillis());
        
        // Calculate summary statistics
        if (results != null) {
            int total = results.size();
            int passed = 0;
            int failed = 0;
            int skipped = 0;
            
            for (TestExecutionResult result : results) {
                switch (result.getStatus()) {
                    case PASSED:
                        passed++;
                        break;
                    case FAILED:
                        failed++;
                        break;
                    case SKIPPED:
                        skipped++;
                        break;
                }
            }
            
            data.put("total", total);
            data.put("passed", passed);
            data.put("failed", failed);
            data.put("skipped", skipped);
        }
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_COMPLETE, data);
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.EXECUTION_COMPLETED);
        message.setPayload(data);
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Complete notification broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast an error notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param error Error message
     * @return Number of clients the notification was sent to
     */
    @Override
    public int broadcastExecutionError(String executionId, String error) {
        LOGGER.info("Broadcasting execution error: {}, error: {}", executionId, error);
        
        // Prepare data
        Map<String, Object> data = new HashMap<>();
        data.put("executionId", executionId);
        data.put("error", error);
        data.put("status", TestStatus.ERROR.name());
        data.put("timestamp", System.currentTimeMillis());
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_ERROR, data);
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.EXECUTION_ERROR);
        message.setPayload(data);
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Error notification broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast a log update to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param log Test log entry
     * @return Number of clients the update was sent to
     */
    @Override
    public int broadcastTestLog(String executionId, String testId, TestLog log) {
        if (log == null) {
            return 0;
        }
        
        LOGGER.debug("Broadcasting test log: {}, test: {}, level: {}", 
                executionId, testId, log.getLevel());
        
        // Prepare data
        Map<String, Object> data = new HashMap<>();
        data.put("executionId", executionId);
        data.put("testId", testId);
        data.put("log", log);
        data.put("timestamp", System.currentTimeMillis());
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_LOG, data);
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.TEST_LOG);
        message.setPayload(data);
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Log update broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast a test start notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param testName Name of the test
     * @return Number of clients the notification was sent to
     */
    @Override
    public int broadcastTestStart(String executionId, String testId, String testName) {
        LOGGER.debug("Broadcasting test start: {}, test: {}, name: {}", 
                executionId, testId, testName);
        
        // Prepare data
        Map<String, Object> data = new HashMap<>();
        data.put("executionId", executionId);
        data.put("testId", testId);
        data.put("testName", testName);
        data.put("timestamp", System.currentTimeMillis());
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_TEST_START, data);
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.EXECUTION_STATUS_UPDATE);
        message.setPayload(data);
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Test start notification broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast a test complete notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param result Test execution result
     * @return Number of clients the notification was sent to
     */
    @Override
    public int broadcastTestComplete(String executionId, TestExecutionResult result) {
        if (result == null) {
            return 0;
        }
        
        LOGGER.debug("Broadcasting test complete: {}, test: {}, status: {}", 
                executionId, result.getTestId(), result.getStatus());
        
        // Prepare data
        Map<String, Object> data = new HashMap<>();
        data.put("executionId", executionId);
        data.put("result", result);
        data.put("timestamp", System.currentTimeMillis());
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_TEST_COMPLETE, data);
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.TEST_RESULT);
        message.setPayload(data);
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Test complete notification broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast a screenshot capture notification to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param testId ID of the test
     * @param screenshotId ID of the screenshot
     * @param timestamp Timestamp of the screenshot
     * @return Number of clients the notification was sent to
     */
    @Override
    public int broadcastScreenshotCaptured(String executionId, String testId, String screenshotId, long timestamp) {
        LOGGER.debug("Broadcasting screenshot captured: {}, test: {}, screenshot: {}", 
                executionId, testId, screenshotId);
        
        // Prepare data
        Map<String, Object> data = new HashMap<>();
        data.put("executionId", executionId);
        data.put("testId", testId);
        data.put("screenshotId", screenshotId);
        data.put("timestamp", timestamp);
        data.put("captureTime", System.currentTimeMillis());
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_SCREENSHOT, data);
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.SCREENSHOT);
        message.setPayload(data);
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Screenshot notification broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast custom data to all clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param eventType Type of the event
     * @param data Event data
     * @return Number of clients the data was sent to
     */
    @Override
    public int broadcastCustomData(String executionId, String eventType, Map<String, Object> data) {
        if (data == null) {
            data = new HashMap<>();
        }
        
        LOGGER.debug("Broadcasting custom data: {}, event type: {}", executionId, eventType);
        
        // Add execution ID and timestamp if not present
        if (!data.containsKey("executionId")) {
            data.put("executionId", executionId);
        }
        
        if (!data.containsKey("timestamp")) {
            data.put("timestamp", System.currentTimeMillis());
        }
        
        // Send via SSE
        int sseClients = broadcastToSseClients(executionId, SSE_EVENT_CUSTOM + "_" + eventType, data);
        
        // Send via WebSocket
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.CUSTOM);
        message.addPayload("eventType", eventType);
        message.setPayload(data);
        
        int wsClients = messagePublisher.sendMessageToExecution(executionId, message);
        
        LOGGER.debug("Custom data broadcast to {} SSE clients and {} WebSocket clients for execution: {}", 
                sseClients, wsClients, executionId);
        
        return sseClients + wsClients;
    }
    
    /**
     * Broadcast data to all SSE clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @param eventName Name of the event
     * @param data Event data
     * @return Number of clients the data was sent to
     */
    private int broadcastToSseClients(String executionId, String eventName, Map<String, Object> data) {
        Set<SseEmitter> clients = executionClients.get(executionId);
        if (clients == null || clients.isEmpty()) {
            return 0;
        }
        
        int successCount = 0;
        Set<SseEmitter> failedEmitters = new HashSet<>();
        
        for (SseEmitter emitter : clients) {
            try {
                SseEventBuilder event = SseEmitter.event()
                        .name(eventName)
                        .data(data);
                
                emitter.send(event);
                successCount++;
            } catch (IOException e) {
                LOGGER.error("Failed to send SSE event to client for execution: {}: {}", 
                        executionId, e.getMessage(), e);
                failedEmitters.add(emitter);
            }
        }
        
        // Remove failed emitters
        for (SseEmitter emitter : failedEmitters) {
            clients.remove(emitter);
            try {
                emitter.completeWithError(new IOException("Failed to send event"));
            } catch (Exception e) {
                LOGGER.error("Error completing failed SSE emitter: {}", e.getMessage(), e);
            }
        }
        
        return successCount;
    }
    
    /**
     * Build status data for an execution.
     * 
     * @param executionId ID of the test execution
     * @param status Execution status
     * @return Status data
     */
    private Map<String, Object> buildStatusData(String executionId, TestStatus status) {
        Map<String, Object> data = new HashMap<>();
        data.put("executionId", executionId);
        data.put("status", status.name());
        data.put("timestamp", System.currentTimeMillis());
        return data;
    }
}

ResourceMonitorService.java
------------------------------------------------

  package com.cstestforge.service.realtime;

import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.Map;
import java.util.Set;

/**
 * Service for monitoring system resources during test execution.
 * This interface defines methods for tracking CPU, memory, and other resource usage.
 */
public interface ResourceMonitorService {
    
    /**
     * Start monitoring resources for a test execution.
     * 
     * @param executionId ID of the test execution
     */
    void startMonitoring(String executionId);
    
    /**
     * Stop monitoring resources for a test execution.
     * 
     * @param executionId ID of the test execution
     */
    void stopMonitoring(String executionId);
    
    /**
     * Check if a test execution is being monitored.
     * 
     * @param executionId ID of the test execution
     * @return True if the execution is being monitored, false otherwise
     */
    boolean isMonitoring(String executionId);
    
    /**
     * Get the current resource metrics for a test execution.
     * 
     * @param executionId ID of the test execution
     * @return Map of metric names to values
     */
    Map<String, Double> getCurrentMetrics(String executionId);
    
    /**
     * Get the resource metrics history for a test execution.
     * 
     * @param executionId ID of the test execution
     * @return List of metric snapshots, each a map of metric names to values
     */
    java.util.List<Map<String, Object>> getMetricsHistory(String executionId);
    
    /**
     * Set the monitoring interval for a test execution.
     * 
     * @param executionId ID of the test execution
     * @param intervalMs Monitoring interval in milliseconds
     */
    void setMonitoringInterval(String executionId, long intervalMs);
    
    /**
     * Set resource threshold alerts for a test execution.
     * 
     * @param executionId ID of the test execution
     * @param thresholds Map of metric names to threshold values
     */
    void setAlertThresholds(String executionId, Map<String, Double> thresholds);
    
    /**
     * Register an SSE client for receiving resource updates.
     * 
     * @param executionId ID of the test execution
     * @param emitter SSE emitter for sending events to the client
     */
    void registerClient(String executionId, SseEmitter emitter);
    
    /**
     * Unregister an SSE client.
     * 
     * @param executionId ID of the test execution
     * @param emitter SSE emitter to unregister
     */
    void unregisterClient(String executionId, SseEmitter emitter);
    
    /**
     * Get all registered SSE clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @return Set of registered SSE emitters
     */
    Set<SseEmitter> getClientsForExecution(String executionId);
    
    /**
     * Get the number of registered SSE clients for an execution.
     * 
     * @param executionId ID of the test execution
     * @return Number of registered SSE emitters
     */
    int getClientCount(String executionId);
    
    /**
     * Send current metrics to an SSE client.
     * 
     * @param executionId ID of the test execution
     * @param emitter SSE emitter
     */
    void sendCurrentMetrics(String executionId, SseEmitter emitter);
    
    /**
     * Send a notification to an SSE client.
     * 
     * @param emitter SSE emitter
     * @param message Notification message
     */
    void sendNotification(SseEmitter emitter, String message);
    
    /**
     * Start the service.
     */
    void start();
    
    /**
     * Stop the service.
     */
    void stop();
    
    /**
     * Check if the service is running.
     * 
     * @return True if the service is running, false otherwise
     */
    boolean isRunning();
}

