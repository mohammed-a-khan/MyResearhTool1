recorder/common/polyfills.js
------------------------------------------

/**
 * CSTestForge Browser Compatibility Polyfills
 * 
 * This module provides comprehensive polyfills to ensure consistent behavior
 * across all supported browsers (Chrome, Firefox, Safari, Edge, and IE 11).
 * It is designed to be injected into the target application during recording
 * and playback to provide consistent behavior regardless of browser.
 * 
 * @module polyfills
 * @copyright CSTestForge 2025
 */

(function() {
    'use strict';

    // Current browser information (populated by version-detector.js)
    const browserInfo = window.CSTestForge?.browserInfo || {
        name: null,
        version: null,
        isIE: false,
        isEdgeLegacy: false,
        isEdgeChromium: false,
        isChrome: false,
        isFirefox: false,
        isSafari: false
    };

    /**
     * Returns whether the current browser needs this polyfill
     * 
     * @param {string} feature - Feature to check
     * @param {number} minVersion - Minimum version required for each browser
     * @returns {boolean} True if polyfill is needed
     */
    function needsPolyfill(feature, minVersions) {
        if (!browserInfo.name || !browserInfo.version) {
            // If we can't detect the browser, assume we need the polyfill
            return true;
        }
        
        if (!minVersions[browserInfo.name]) {
            // If we don't have data for this browser, assume we need the polyfill
            return true;
        }
        
        return parseFloat(browserInfo.version) < minVersions[browserInfo.name];
    }

    /**
     * Safely add a polyfill without overriding existing implementations
     * 
     * @param {object} target - Target object (e.g. window, Element.prototype)
     * @param {string} property - Property name to polyfill
     * @param {Function} implementation - Polyfill implementation
     * @param {boolean} force - Whether to force the polyfill even if property exists
     */
    function polyfill(target, property, implementation, force = false) {
        if (force || typeof target[property] === 'undefined') {
            Object.defineProperty(target, property, {
                configurable: true,
                writable: true,
                value: implementation
            });
        }
    }

    /**
     * Element.matches polyfill
     * Required for: IE (all versions), Edge < 15
     */
    if (needsPolyfill('Element.matches', {
        ie: Infinity,
        edge: 15,
        chrome: 34,
        firefox: 34,
        safari: 7.1
    })) {
        polyfill(Element.prototype, 'matches', function(selector) {
            const element = this;
            const matches = (element.document || element.ownerDocument).querySelectorAll(selector);
            let i = matches.length;
            while (--i >= 0 && matches.item(i) !== element) {}
            return i > -1;
        });
    }

    /**
     * Element.closest polyfill
     * Required for: IE (all versions), Edge < 15
     */
    if (needsPolyfill('Element.closest', {
        ie: Infinity,
        edge: 15,
        chrome: 41,
        firefox: 35,
        safari: 9
    })) {
        polyfill(Element.prototype, 'closest', function(selector) {
            let element = this;
            if (!document.documentElement.contains(element)) {
                return null;
            }
            
            do {
                if (element.matches(selector)) {
                    return element;
                }
                element = element.parentElement || element.parentNode;
            } while (element !== null && element.nodeType === 1);
            
            return null;
        });
    }

    /**
     * CustomEvent polyfill
     * Required for: IE (all versions)
     */
    if (needsPolyfill('CustomEvent', {
        ie: Infinity,
        edge: 14,
        chrome: 15,
        firefox: 11,
        safari: 7
    })) {
        polyfill(window, 'CustomEvent', function(event, params) {
            params = params || { bubbles: false, cancelable: false, detail: null };
            const evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            return evt;
        });
        
        polyfill(window.CustomEvent, 'prototype', Object.create(window.Event.prototype));
    }

    /**
     * requestAnimationFrame polyfill
     * Required for: IE < 10, older browsers
     */
    if (needsPolyfill('requestAnimationFrame', {
        ie: 10,
        edge: 12,
        chrome: 24,
        firefox: 23,
        safari: 7
    })) {
        let lastTime = 0;
        
        polyfill(window, 'requestAnimationFrame', function(callback) {
            const currTime = new Date().getTime();
            const timeToCall = Math.max(0, 16 - (currTime - lastTime));
            const id = window.setTimeout(function() {
                callback(currTime + timeToCall);
            }, timeToCall);
            
            lastTime = currTime + timeToCall;
            return id;
        });
        
        polyfill(window, 'cancelAnimationFrame', function(id) {
            clearTimeout(id);
        });
    }
    
    /**
     * Element.remove polyfill
     * Required for: IE < 11
     */
    if (needsPolyfill('Element.remove', {
        ie: 11,
        edge: 12,
        chrome: 24,
        firefox: 23,
        safari: 7
    })) {
        polyfill(Element.prototype, 'remove', function() {
            if (this.parentNode) {
                this.parentNode.removeChild(this);
            }
        });
    }

    /**
     * Array.from polyfill
     * Required for: IE (all versions), Edge < 12
     */
    if (needsPolyfill('Array.from', {
        ie: Infinity,
        edge: 12,
        chrome: 45,
        firefox: 32,
        safari: 9
    })) {
        polyfill(Array, 'from', function(arrayLike) {
            const arr = [];
            const len = arrayLike.length;
            
            for (let i = 0; i < len; i++) {
                arr.push(arrayLike[i]);
            }
            
            return arr;
        });
    }

    /**
     * Array.prototype.includes polyfill
     * Required for: IE (all versions), Edge < 14
     */
    if (needsPolyfill('Array.prototype.includes', {
        ie: Infinity,
        edge: 14,
        chrome: 47,
        firefox: 43,
        safari: 9
    })) {
        polyfill(Array.prototype, 'includes', function(searchElement, fromIndex) {
            if (this === null || this === undefined) {
                throw new TypeError('Array.prototype.includes called on null or undefined');
            }
            
            const O = Object(this);
            const len = parseInt(O.length, 10) || 0;
            
            if (len === 0) {
                return false;
            }
            
            const n = parseInt(fromIndex, 10) || 0;
            let k;
            
            if (n >= 0) {
                k = n;
            } else {
                k = len + n;
                if (k < 0) {
                    k = 0;
                }
            }
            
            while (k < len) {
                const currentElement = O[k];
                if (searchElement === currentElement || 
                    (searchElement !== searchElement && currentElement !== currentElement)) {
                    return true;
                }
                k++;
            }
            
            return false;
        });
    }

    /**
     * String.prototype.includes polyfill
     * Required for: IE (all versions), Edge < 12
     */
    if (needsPolyfill('String.prototype.includes', {
        ie: Infinity,
        edge: 12,
        chrome: 41,
        firefox: 40,
        safari: 9
    })) {
        polyfill(String.prototype, 'includes', function(search, start) {
            if (typeof start !== 'number') {
                start = 0;
            }
            
            if (start + search.length > this.length) {
                return false;
            } else {
                return this.indexOf(search, start) !== -1;
            }
        });
    }

    /**
     * String.prototype.startsWith polyfill
     * Required for: IE (all versions)
     */
    if (needsPolyfill('String.prototype.startsWith', {
        ie: Infinity,
        edge: 12,
        chrome: 41,
        firefox: 17,
        safari: 9
    })) {
        polyfill(String.prototype, 'startsWith', function(searchString, position) {
            position = position || 0;
            return this.substring(position, position + searchString.length) === searchString;
        });
    }

    /**
     * String.prototype.endsWith polyfill
     * Required for: IE (all versions)
     */
    if (needsPolyfill('String.prototype.endsWith', {
        ie: Infinity,
        edge: 12,
        chrome: 41,
        firefox: 17,
        safari: 9
    })) {
        polyfill(String.prototype, 'endsWith', function(searchString, position) {
            const subjectString = this.toString();
            if (typeof position !== 'number' || !isFinite(position) || 
                Math.floor(position) !== position || position > subjectString.length) {
                position = subjectString.length;
            }
            position -= searchString.length;
            const lastIndex = subjectString.indexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
        });
    }

    /**
     * Object.assign polyfill
     * Required for: IE (all versions), Edge < 12
     */
    if (needsPolyfill('Object.assign', {
        ie: Infinity,
        edge: 12,
        chrome: 45,
        firefox: 34,
        safari: 9
    })) {
        polyfill(Object, 'assign', function(target) {
            if (target === null || target === undefined) {
                throw new TypeError('Cannot convert undefined or null to object');
            }
            
            const to = Object(target);
            
            for (let index = 1; index < arguments.length; index++) {
                const nextSource = arguments[index];
                
                if (nextSource !== null && nextSource !== undefined) {
                    for (const nextKey in nextSource) {
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            
            return to;
        });
    }

    /**
     * Promise polyfill
     * Required for: IE (all versions), Edge < 12, Safari < 10
     */
    if (needsPolyfill('Promise', {
        ie: Infinity,
        edge: 12,
        chrome: 32,
        firefox: 29,
        safari: 10
    })) {
        // Full Promise implementation
        (function() {
            function CSPromise(executor) {
                if (typeof this !== 'object') {
                    throw new TypeError('Promises must be constructed via new');
                }
                if (typeof executor !== 'function') {
                    throw new TypeError('Promise constructor\'s argument is not a function');
                }
                
                this._state = 0; // 0: pending, 1: fulfilled, 2: rejected
                this._handled = false;
                this._value = undefined;
                this._deferreds = [];
                
                doResolve(executor, this);
            }
            
            function handle(self, deferred) {
                if (self._state === 0) {
                    self._deferreds.push(deferred);
                    return;
                }
                
                self._handled = true;
                setTimeout(function() {
                    const cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                    
                    if (cb === null) {
                        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
                        return;
                    }
                    
                    let x;
                    try {
                        x = cb(self._value);
                    } catch (e) {
                        reject(deferred.promise, e);
                        return;
                    }
                    
                    resolve(deferred.promise, x);
                }, 0);
            }
            
            function resolve(self, newValue) {
                try {
                    if (newValue === self) {
                        throw new TypeError('A promise cannot be resolved with itself.');
                    }
                    
                    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
                        const then = newValue.then;
                        
                        if (typeof then === 'function') {
                            doResolve(function(resolve, reject) {
                                try {
                                    then.call(newValue, resolve, reject);
                                } catch (e) {
                                    reject(e);
                                }
                            }, self);
                            return;
                        }
                    }
                    
                    self._state = 1;
                    self._value = newValue;
                    finale(self);
                } catch (e) {
                    reject(self, e);
                }
            }
            
            function reject(self, newValue) {
                self._state = 2;
                self._value = newValue;
                finale(self);
            }
            
            function finale(self) {
                if (self._state === 2 && self._deferreds.length === 0) {
                    setTimeout(function() {
                        if (!self._handled) {
                            // Unhandled rejection warning
                            console.warn('Unhandled promise rejection', self._value);
                        }
                    }, 0);
                }
                
                for (let i = 0, len = self._deferreds.length; i < len; i++) {
                    handle(self, self._deferreds[i]);
                }
                
                self._deferreds = null;
            }
            
            function doResolve(fn, self) {
                let done = false;
                
                try {
                    fn(function(value) {
                        if (done) return;
                        done = true;
                        resolve(self, value);
                    }, function(reason) {
                        if (done) return;
                        done = true;
                        reject(self, reason);
                    });
                } catch (e) {
                    if (done) return;
                    done = true;
                    reject(self, e);
                }
            }
            
            CSPromise.prototype.then = function(onFulfilled, onRejected) {
                const prom = new this.constructor(function() {});
                
                handle(this, {
                    onFulfilled: typeof onFulfilled === 'function' ? onFulfilled : null,
                    onRejected: typeof onRejected === 'function' ? onRejected : null,
                    promise: prom
                });
                
                return prom;
            };
            
            CSPromise.prototype.catch = function(onRejected) {
                return this.then(null, onRejected);
            };
            
            CSPromise.prototype.finally = function(callback) {
                return this.then(
                    function(value) {
                        return CSPromise.resolve(callback()).then(function() {
                            return value;
                        });
                    },
                    function(reason) {
                        return CSPromise.resolve(callback()).then(function() {
                            throw reason;
                        });
                    }
                );
            };
            
            CSPromise.resolve = function(value) {
                if (value && typeof value === 'object' && value.constructor === CSPromise) {
                    return value;
                }
                
                return new CSPromise(function(resolve) {
                    resolve(value);
                });
            };
            
            CSPromise.reject = function(value) {
                return new CSPromise(function(resolve, reject) {
                    reject(value);
                });
            };
            
            CSPromise.all = function(arr) {
                return new CSPromise(function(resolve, reject) {
                    if (!Array.isArray(arr)) {
                        return reject(new TypeError('Promise.all accepts an array'));
                    }
                    
                    const args = Array.prototype.slice.call(arr);
                    if (args.length === 0) return resolve([]);
                    
                    let remaining = args.length;
                    
                    function res(i, val) {
                        try {
                            if (val && (typeof val === 'object' || typeof val === 'function')) {
                                const then = val.then;
                                if (typeof then === 'function') {
                                    then.call(val, function(val) {
                                        res(i, val);
                                    }, reject);
                                    return;
                                }
                            }
                            
                            args[i] = val;
                            if (--remaining === 0) {
                                resolve(args);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    }
                    
                    for (let i = 0; i < args.length; i++) {
                        res(i, args[i]);
                    }
                });
            };
            
            CSPromise.race = function(arr) {
                return new CSPromise(function(resolve, reject) {
                    if (!Array.isArray(arr)) {
                        return reject(new TypeError('Promise.race accepts an array'));
                    }
                    
                    for (let i = 0; i < arr.length; i++) {
                        CSPromise.resolve(arr[i]).then(resolve, reject);
                    }
                });
            };
            
            polyfill(window, 'Promise', CSPromise, true);
        })();
    }

    /**
     * Fetch API polyfill
     * Required for: IE (all versions), Edge < 14
     */
    if (needsPolyfill('fetch', {
        ie: Infinity,
        edge: 14,
        chrome: 42,
        firefox: 39,
        safari: 10.1
    })) {
        // Simple fetch polyfill based on XMLHttpRequest
        polyfill(window, 'fetch', function(url, options) {
            return new Promise(function(resolve, reject) {
                options = options || {};
                
                const request = new XMLHttpRequest();
                request.open(options.method || 'GET', url, true);
                
                if (options.headers) {
                    Object.keys(options.headers).forEach(function(key) {
                        request.setRequestHeader(key, options.headers[key]);
                    });
                }
                
                request.onload = function() {
                    const response = {
                        status: request.status,
                        statusText: request.statusText,
                        headers: parseHeaders(request.getAllResponseHeaders())
                    };
                    
                    response.url = 'responseURL' in request ? 
                        request.responseURL : 
                        response.headers.get('X-Request-URL');
                    
                    const body = 'response' in request ? 
                        request.response : 
                        request.responseText;
                    
                    response.text = function() {
                        return Promise.resolve(body);
                    };
                    
                    response.json = function() {
                        return Promise.resolve(JSON.parse(body));
                    };
                    
                    response.blob = function() {
                        return Promise.resolve(new Blob([body]));
                    };
                    
                    resolve(response);
                };
                
                request.onerror = function() {
                    reject(new TypeError('Network request failed'));
                };
                
                request.ontimeout = function() {
                    reject(new TypeError('Network request failed'));
                };
                
                request.send(options.body || null);
            });
            
            function parseHeaders(headers) {
                const headerMap = {};
                const headersArray = headers.trim().split('\n');
                
                headersArray.forEach(function(line) {
                    const parts = line.trim().split(':');
                    const key = parts.shift().trim();
                    const value = parts.join(':').trim();
                    headerMap[key.toLowerCase()] = value;
                });
                
                return {
                    get: function(name) {
                        return headerMap[name.toLowerCase()];
                    }
                };
            }
        });
    }

    /**
     * URL polyfill
     * Required for: IE < 11
     */
    if (needsPolyfill('URL', {
        ie: 11,
        edge: 12,
        chrome: 32,
        firefox: 26,
        safari: 7.1
    })) {
        (function(global) {
            // Shim for the URL constructor
            function CSURL(url, base) {
                if (typeof url !== 'string') {
                    throw new TypeError('URL must be a string');
                }
                
                let baseElement;
                if (base !== undefined) {
                    baseElement = document.createElement('a');
                    baseElement.href = base;
                }
                
                const element = document.createElement('a');
                if (baseElement) {
                    // Resolve the URL against the base
                    const basePath = baseElement.pathname.split('/');
                    basePath.pop(); // Remove file part
                    
                    if (url[0] === '/') {
                        element.href = baseElement.protocol + '//' + baseElement.host + url;
                    } else if (url.indexOf('://') > -1) {
                        element.href = url;
                    } else {
                        element.href = baseElement.protocol + '//' + baseElement.host + 
                            basePath.join('/') + '/' + url;
                    }
                } else {
                    element.href = url;
                }
                
                this.protocol = element.protocol;
                this.hostname = element.hostname;
                this.port = element.port;
                this.host = element.host;
                this.pathname = element.pathname;
                this.search = element.search;
                this.hash = element.hash;
                this.href = element.href;
                this.origin = this.protocol + '//' + this.host;
                
                // Parse query parameters
                this.searchParams = new URLSearchParams(this.search);
                
                Object.defineProperty(this, 'toString', {
                    value: function() {
                        return this.href;
                    },
                    enumerable: false
                });
            }
            
            // Polyfill for URLSearchParams
            function URLSearchParams(init) {
                this._entries = {};
                
                if (typeof init === 'string') {
                    if (init.indexOf('?') === 0) {
                        init = init.substring(1);
                    }
                    
                    const pairs = init.split('&');
                    for (let i = 0; i < pairs.length; i++) {
                        const pair = pairs[i].split('=');
                        const key = decodeURIComponent(pair[0].replace(/\+/g, ' '));
                        const value = pair.length > 1 ? 
                            decodeURIComponent(pair[1].replace(/\+/g, ' ')) : '';
                        
                        if (!this._entries[key]) {
                            this._entries[key] = [];
                        }
                        
                        this._entries[key].push(value);
                    }
                }
            }
            
            URLSearchParams.prototype.append = function(name, value) {
                if (!this._entries[name]) {
                    this._entries[name] = [];
                }
                
                this._entries[name].push(String(value));
            };
            
            URLSearchParams.prototype.delete = function(name) {
                delete this._entries[name];
            };
            
            URLSearchParams.prototype.get = function(name) {
                return this.has(name) ? this._entries[name][0] : null;
            };
            
            URLSearchParams.prototype.getAll = function(name) {
                return this.has(name) ? this._entries[name].slice(0) : [];
            };
            
            URLSearchParams.prototype.has = function(name) {
                return Object.prototype.hasOwnProperty.call(this._entries, name);
            };
            
            URLSearchParams.prototype.set = function(name, value) {
                this._entries[name] = [String(value)];
            };
            
            URLSearchParams.prototype.toString = function() {
                const parts = [];
                for (const key in this._entries) {
                    if (Object.prototype.hasOwnProperty.call(this._entries, key)) {
                        const values = this._entries[key];
                        for (let i = 0; i < values.length; i++) {
                            parts.push(
                                encodeURIComponent(key) + '=' + 
                                encodeURIComponent(values[i])
                            );
                        }
                    }
                }
                
                return parts.join('&');
            };
            
            polyfill(global, 'URL', CSURL, true);
            polyfill(global, 'URLSearchParams', URLSearchParams, true);
        })(typeof window !== 'undefined' ? window : global);
    }

    /**
     * MutationObserver polyfill
     * Required for: IE < 11
     */
    if (needsPolyfill('MutationObserver', {
        ie: 11,
        edge: 12,
        chrome: 26,
        firefox: 14,
        safari: 7
    })) {
        (function(global) {
            // Use MutationEvents as a fallback
            function CSMutationObserver(callback) {
                this._callback = callback;
                this._records = [];
                this._element = null;
                this._registerTimeout = null;
                this._elementObservers = [];
            }
            
            CSMutationObserver.prototype.observe = function(element, options) {
                // Default options
                options = options || {
                    childList: false,
                    attributes: false,
                    characterData: false,
                    subtree: false,
                    attributeOldValue: false,
                    characterDataOldValue: false,
                    attributeFilter: null
                };
                
                const observer = {
                    element: element,
                    options: options,
                    records: []
                };
                
                this._elementObservers.push(observer);
                
                // Setup mutation events
                if (options.attributes || options.attributeFilter) {
                    element.addEventListener('DOMAttrModified', this._handleAttrModified.bind(this, observer), true);
                }
                
                if (options.characterData) {
                    element.addEventListener('DOMCharacterDataModified', 
                        this._handleCharacterDataModified.bind(this, observer), true);
                }
                
                if (options.childList || options.subtree) {
                    element.addEventListener('DOMNodeInserted', 
                        this._handleNodeInserted.bind(this, observer), true);
                    element.addEventListener('DOMNodeRemoved', 
                        this._handleNodeRemoved.bind(this, observer), true);
                }
            };
            
            CSMutationObserver.prototype.disconnect = function() {
                // Remove all observers
                this._elementObservers = [];
                this._callback = null;
                this._records = [];
                
                if (this._registerTimeout) {
                    clearTimeout(this._registerTimeout);
                    this._registerTimeout = null;
                }
            };
            
            CSMutationObserver.prototype.takeRecords = function() {
                const records = this._records.slice();
                this._records = [];
                return records;
            };
            
            CSMutationObserver.prototype._handleAttrModified = function(observer, event) {
                if (observer.options.attributeFilter && 
                    observer.options.attributeFilter.indexOf(event.attrName) === -1) {
                    return;
                }
                
                const record = {
                    type: 'attributes',
                    target: event.target,
                    attributeName: event.attrName,
                    oldValue: event.prevValue,
                    addedNodes: [],
                    removedNodes: []
                };
                
                this._records.push(record);
                this._scheduleCallback();
            };
            
            CSMutationObserver.prototype._handleCharacterDataModified = function(observer, event) {
                const record = {
                    type: 'characterData',
                    target: event.target,
                    oldValue: event.prevValue,
                    addedNodes: [],
                    removedNodes: []
                };
                
                this._records.push(record);
                this._scheduleCallback();
            };
            
            CSMutationObserver.prototype._handleNodeInserted = function(observer, event) {
                const record = {
                    type: 'childList',
                    target: event.relatedNode,
                    addedNodes: [event.target],
                    removedNodes: [],
                    previousSibling: event.target.previousSibling,
                    nextSibling: event.target.nextSibling
                };
                
                this._records.push(record);
                this._scheduleCallback();
            };
            
            CSMutationObserver.prototype._handleNodeRemoved = function(observer, event) {
                const record = {
                    type: 'childList',
                    target: event.relatedNode,
                    addedNodes: [],
                    removedNodes: [event.target],
                    previousSibling: event.target.previousSibling,
                    nextSibling: event.target.nextSibling
                };
                
                this._records.push(record);
                this._scheduleCallback();
            };
            
            CSMutationObserver.prototype._scheduleCallback = function() {
                if (this._registerTimeout) {
                    return;
                }
                
                this._registerTimeout = setTimeout(function() {
                    const records = this.takeRecords();
                    if (records.length) {
                        this._callback(records, this);
                    }
                    this._registerTimeout = null;
                }.bind(this), 10);
            };
            
            polyfill(global, 'MutationObserver', CSMutationObserver, true);
        })(typeof window !== 'undefined' ? window : global);
    }

    /**
     * Symbol polyfill (simple implementation for internal use)
     * Required for: IE (all versions), Edge < 12
     */
    if (needsPolyfill('Symbol', {
        ie: Infinity,
        edge: 12,
        chrome: 38,
        firefox: 36,
        safari: 9
    })) {
        (function(global) {
            const id = 0;
            
            function CSSymbol(description) {
                this.id = '@@CSTESTFORGE_SYMBOL_' + (id++) + '_' + (description || '');
                return this;
            }
            
            CSSymbol.for = function(key) {
                return CSSymbol[key] || (CSSymbol[key] = new CSSymbol(key));
            };
            
            polyfill(global, 'Symbol', CSSymbol, true);
            
            // Define common symbols
            if (!Symbol.iterator) Symbol.iterator = Symbol('iterator');
            if (!Symbol.toStringTag) Symbol.toStringTag = Symbol('toStringTag');
        })(typeof window !== 'undefined' ? window : global);
    }

    /**
     * Iterator and Iteration Protocol Polyfills
     * Required for: IE (all versions), Edge < 12
     */
    if (needsPolyfill('Iterators', {
        ie: Infinity,
        edge: 12,
        chrome: 38,
        firefox: 36,
        safari: 9
    })) {
        // Add iterator capabilities to common objects
        if (!Array.prototype[Symbol.iterator]) {
            Object.defineProperty(Array.prototype, Symbol.iterator, {
                value: function() {
                    let index = 0;
                    const array = this;
                    
                    return {
                        next: function() {
                            return index < array.length ? 
                                { value: array[index++], done: false } : 
                                { done: true };
                        }
                    };
                },
                configurable: true,
                writable: true
            });
        }
        
        if (!String.prototype[Symbol.iterator]) {
            Object.defineProperty(String.prototype, Symbol.iterator, {
                value: function() {
                    let index = 0;
                    const string = this;
                    
                    return {
                        next: function() {
                            return index < string.length ? 
                                { value: string.charAt(index++), done: false } : 
                                { done: true };
                        }
                    };
                },
                configurable: true,
                writable: true
            });
        }
    }

    /**
     * FormData polyfill (simplified)
     * Required for: IE < 10
     */
    if (needsPolyfill('FormData', {
        ie: 10,
        edge: 12,
        chrome: 7,
        firefox: 4,
        safari: 5
    })) {
        (function(global) {
            function CSFormData() {
                this._data = [];
            }
            
            CSFormData.prototype.append = function(name, value, filename) {
                this._data.push({
                    name: name,
                    value: value,
                    filename: filename
                });
            };
            
            CSFormData.prototype.delete = function(name) {
                for (let i = this._data.length - 1; i >= 0; i--) {
                    if (this._data[i].name === name) {
                        this._data.splice(i, 1);
                    }
                }
            };
            
            CSFormData.prototype.get = function(name) {
                for (let i = 0; i < this._data.length; i++) {
                    if (this._data[i].name === name) {
                        return this._data[i].value;
                    }
                }
                
                return null;
            };
            
            CSFormData.prototype.getAll = function(name) {
                const values = [];
                
                for (let i = 0; i < this._data.length; i++) {
                    if (this._data[i].name === name) {
                        values.push(this._data[i].value);
                    }
                }
                
                return values;
            };
            
            CSFormData.prototype.has = function(name) {
                for (let i = 0; i < this._data.length; i++) {
                    if (this._data[i].name === name) {
                        return true;
                    }
                }
                
                return false;
            };
            
            CSFormData.prototype.set = function(name, value, filename) {
                let found = false;
                
                for (let i = 0; i < this._data.length; i++) {
                    if (this._data[i].name === name) {
                        if (!found) {
                            this._data[i] = {
                                name: name,
                                value: value,
                                filename: filename
                            };
                            found = true;
                        } else {
                            this._data.splice(i, 1);
                            i--;
                        }
                    }
                }
                
                if (!found) {
                    this.append(name, value, filename);
                }
            };
            
            CSFormData.prototype.forEach = function(callback, thisArg) {
                for (let i = 0; i < this._data.length; i++) {
                    callback.call(
                        thisArg || null,
                        this._data[i].value,
                        this._data[i].name,
                        this
                    );
                }
            };
            
            polyfill(global, 'FormData', CSFormData, true);
        })(typeof window !== 'undefined' ? window : global);
    }

    /**
     * IntersectionObserver polyfill (simplified)
     * Required for: IE (all versions), Edge < 15, Safari < 12.1
     */
    if (needsPolyfill('IntersectionObserver', {
        ie: Infinity,
        edge: 15,
        chrome: 51,
        firefox: 55,
        safari: 12.1
    })) {
        (function(global) {
            function CSIntersectionObserver(callback, options) {
                this._callback = callback;
                this._observationTargets = [];
                this._checkVisibilityTimeout = null;
                
                this._options = {
                    root: options && options.root || null,
                    rootMargin: options && options.rootMargin || '0px',
                    threshold: options && options.threshold || 0
                };
                
                // Parse rootMargin
                this._parseRootMargin();
                
                // Ensure threshold is an array
                if (!Array.isArray(this._options.threshold)) {
                    this._options.threshold = [this._options.threshold];
                }
            }
            
            CSIntersectionObserver.prototype._parseRootMargin = function() {
                const margins = this._options.rootMargin.split(/\s+/).map(function(margin) {
                    return parseInt(margin, 10) || 0;
                });
                
                this._rootMargin = {
                    top: margins[0],
                    right: margins.length > 1 ? margins[1] : margins[0],
                    bottom: margins.length > 2 ? margins[2] : margins[0],
                    left: margins.length > 3 ? margins[3] : (margins.length > 1 ? margins[1] : margins[0])
                };
            };
            
            CSIntersectionObserver.prototype.observe = function(target) {
                // Ensure target is an Element
                if (!(target instanceof Element)) {
                    throw new TypeError('target must be an Element');
                }
                
                // Check if already observing this target
                for (let i = 0; i < this._observationTargets.length; i++) {
                    if (this._observationTargets[i].element === target) {
                        return;
                    }
                }
                
                const newObservation = {
                    element: target,
                    isVisible: false,
                    wasVisible: false,
                    lastRatio: 0
                };
                
                this._observationTargets.push(newObservation);
                
                // Start checking visibility
                this._startCheckingVisibility();
            };
            
            CSIntersectionObserver.prototype.unobserve = function(target) {
                for (let i = 0; i < this._observationTargets.length; i++) {
                    if (this._observationTargets[i].element === target) {
                        this._observationTargets.splice(i, 1);
                        break;
                    }
                }
                
                if (this._observationTargets.length === 0) {
                    this._stopCheckingVisibility();
                }
            };
            
            CSIntersectionObserver.prototype.disconnect = function() {
                this._observationTargets = [];
                this._stopCheckingVisibility();
            };
            
            CSIntersectionObserver.prototype.takeRecords = function() {
                const records = [];
                
                this._observationTargets.forEach(function(observation) {
                    const ratio = this._getIntersectionRatio(observation.element);
                    const isVisible = this._isVisible(ratio);
                    
                    if (isVisible !== observation.isVisible) {
                        records.push({
                            time: Date.now(),
                            target: observation.element,
                            isIntersecting: isVisible,
                            intersectionRatio: ratio,
                            boundingClientRect: this._getBoundingClientRect(observation.element),
                            rootBounds: this._getRootBounds()
                        });
                        
                        observation.isVisible = isVisible;
                    }
                    
                    observation.lastRatio = ratio;
                }, this);
                
                return records;
            };
            
            CSIntersectionObserver.prototype._startCheckingVisibility = function() {
                if (this._checkVisibilityTimeout) {
                    return;
                }
                
                const check = function() {
                    this._checkVisibility();
                    this._checkVisibilityTimeout = setTimeout(check, 100);
                }.bind(this);
                
                check();
                
                // Also check on common events that might change visibility
                window.addEventListener('scroll', this._checkVisibility.bind(this), false);
                window.addEventListener('resize', this._checkVisibility.bind(this), false);
                
                if (this._options.root) {
                    this._options.root.addEventListener('scroll', this._checkVisibility.bind(this), false);
                    this._options.root.addEventListener('resize', this._checkVisibility.bind(this), false);
                }
            };
            
            CSIntersectionObserver.prototype._stopCheckingVisibility = function() {
                if (this._checkVisibilityTimeout) {
                    clearTimeout(this._checkVisibilityTimeout);
                    this._checkVisibilityTimeout = null;
                }
                
                window.removeEventListener('scroll', this._checkVisibility, false);
                window.removeEventListener('resize', this._checkVisibility, false);
                
                if (this._options.root) {
                    this._options.root.removeEventListener('scroll', this._checkVisibility, false);
                    this._options.root.removeEventListener('resize', this._checkVisibility, false);
                }
            };
            
            CSIntersectionObserver.prototype._checkVisibility = function() {
                const records = this.takeRecords();
                
                if (records.length > 0) {
                    this._callback(records, this);
                }
            };
            
            CSIntersectionObserver.prototype._isVisible = function(ratio) {
                for (let i = 0; i < this._options.threshold.length; i++) {
                    if (ratio >= this._options.threshold[i]) {
                        return true;
                    }
                }
                
                return false;
            };
            
            CSIntersectionObserver.prototype._getIntersectionRatio = function(element) {
                const elementRect = this._getBoundingClientRect(element);
                const rootRect = this._getRootBounds();
                
                // If element or root is not visible, return 0
                if (!elementRect.width || !elementRect.height || 
                    !rootRect.width || !rootRect.height) {
                    return 0;
                }
                
                // Calculate intersection
                const intersectionRect = {
                    top: Math.max(elementRect.top, rootRect.top),
                    right: Math.min(elementRect.right, rootRect.right),
                    bottom: Math.min(elementRect.bottom, rootRect.bottom),
                    left: Math.max(elementRect.left, rootRect.left)
                };
                
                // If there's no intersection, return 0
                if (intersectionRect.top >= intersectionRect.bottom || 
                    intersectionRect.left >= intersectionRect.right) {
                    return 0;
                }
                
                const intersectionArea = 
                    (intersectionRect.right - intersectionRect.left) * 
                    (intersectionRect.bottom - intersectionRect.top);
                
                const elementArea = 
                    (elementRect.right - elementRect.left) * 
                    (elementRect.bottom - elementRect.top);
                
                return intersectionArea / elementArea;
            };
            
            CSIntersectionObserver.prototype._getBoundingClientRect = function(element) {
                const rect = element.getBoundingClientRect();
                
                return {
                    top: rect.top,
                    right: rect.right,
                    bottom: rect.bottom,
                    left: rect.left,
                    width: rect.width || rect.right - rect.left,
                    height: rect.height || rect.bottom - rect.top
                };
            };
            
            CSIntersectionObserver.prototype._getRootBounds = function() {
                if (this._options.root) {
                    return this._getBoundingClientRect(this._options.root);
                }
                
                // If no root, use viewport
                return {
                    top: 0,
                    right: window.innerWidth || document.documentElement.clientWidth,
                    bottom: window.innerHeight || document.documentElement.clientHeight,
                    left: 0,
                    width: window.innerWidth || document.documentElement.clientWidth,
                    height: window.innerHeight || document.documentElement.clientHeight
                };
            };
            
            polyfill(global, 'IntersectionObserver', CSIntersectionObserver, true);
        })(typeof window !== 'undefined' ? window : global);
    }

    /**
     * ResizeObserver polyfill (simplified)
     * Required for: IE (all versions), Edge < 18, Safari < 13.1
     */
    if (needsPolyfill('ResizeObserver', {
        ie: Infinity,
        edge: 18,
        chrome: 64,
        firefox: 69,
        safari: 13.1
    })) {
        (function(global) {
            function CSResizeObserver(callback) {
                this._callback = callback;
                this._observationTargets = [];
                this._activeObservations = [];
                this._checkSizesTimeout = null;
            }
            
            CSResizeObserver.prototype.observe = function(target) {
                // Ensure target is an Element
                if (!(target instanceof Element)) {
                    throw new TypeError('target must be an Element');
                }
                
                // Check if already observing this target
                for (let i = 0; i < this._observationTargets.length; i++) {
                    if (this._observationTargets[i].element === target) {
                        return;
                    }
                }
                
                const newObservation = {
                    element: target,
                    contentRect: this._getContentRect(target)
                };
                
                this._observationTargets.push(newObservation);
                
                // Start checking sizes
                this._startCheckingSizes();
            };
            
            CSResizeObserver.prototype.unobserve = function(target) {
                for (let i = 0; i < this._observationTargets.length; i++) {
                    if (this._observationTargets[i].element === target) {
                        this._observationTargets.splice(i, 1);
                        break;
                    }
                }
                
                if (this._observationTargets.length === 0) {
                    this._stopCheckingSizes();
                }
            };
            
            CSResizeObserver.prototype.disconnect = function() {
                this._observationTargets = [];
                this._activeObservations = [];
                this._stopCheckingSizes();
            };
            
            CSResizeObserver.prototype._startCheckingSizes = function() {
                if (this._checkSizesTimeout) {
                    return;
                }
                
                const check = function() {
                    this._checkSizes();
                    this._checkSizesTimeout = setTimeout(check, 100);
                }.bind(this);
                
                check();
                
                // Also check on common events that might change sizes
                window.addEventListener('resize', this._checkSizes.bind(this), false);
            };
            
            CSResizeObserver.prototype._stopCheckingSizes = function() {
                if (this._checkSizesTimeout) {
                    clearTimeout(this._checkSizesTimeout);
                    this._checkSizesTimeout = null;
                }
                
                window.removeEventListener('resize', this._checkSizes, false);
            };
            
            CSResizeObserver.prototype._checkSizes = function() {
                this._activeObservations = [];
                
                this._observationTargets.forEach(function(observation) {
                    const contentRect = this._getContentRect(observation.element);
                    
                    if (this._contentRectChanged(contentRect, observation.contentRect)) {
                        this._activeObservations.push({
                            target: observation.element,
                            contentRect: contentRect
                        });
                        
                        observation.contentRect = contentRect;
                    }
                }, this);
                
                if (this._activeObservations.length > 0) {
                    this._callback(this._activeObservations, this);
                }
            };
            
            CSResizeObserver.prototype._getContentRect = function(target) {
                const style = window.getComputedStyle(target);
                const paddingLeft = parseFloat(style.paddingLeft) || 0;
                const paddingTop = parseFloat(style.paddingTop) || 0;
                const paddingRight = parseFloat(style.paddingRight) || 0;
                const paddingBottom = parseFloat(style.paddingBottom) || 0;
                
                return {
                    top: paddingTop,
                    right: target.clientWidth - paddingRight,
                    bottom: target.clientHeight - paddingBottom,
                    left: paddingLeft,
                    width: target.clientWidth - paddingLeft - paddingRight,
                    height: target.clientHeight - paddingTop - paddingBottom
                };
            };
            
            CSResizeObserver.prototype._contentRectChanged = function(rect1, rect2) {
                return rect1.width !== rect2.width || rect1.height !== rect2.height;
            };
            
            polyfill(global, 'ResizeObserver', CSResizeObserver, true);
        })(typeof window !== 'undefined' ? window : global);
    }

    // Initialize polyfills
    console.log('CSTestForge: Polyfills loaded');
})();


recorder/chrome/chrome-injector.js
-----------------------------------------------------

/**
 * CSTestForge Chrome Injector
 * 
 * This module provides Chrome-specific injection capabilities for the CSTestForge recorder.
 * It handles browser detection, feature compatibility, DOM manipulation, and event capturing
 * tailored specifically for Chrome and Chrome-based browsers.
 * 
 * @module chrome-injector
 * @requires base-injector
 * @requires event-capture
 * @requires dom-observer
 * @requires element-identifier
 * @copyright CSTestForge 2025
 */

(function() {
    'use strict';

    /**
     * Chrome-specific implementation of the CSTestForge injector
     */
    class ChromeInjector {
        /**
         * Creates a new ChromeInjector instance
         * @param {Object} config - Configuration options
         */
        constructor(config = {}) {
            // Default configuration settings
            this.config = Object.assign({
                captureClicks: true,
                captureKeyboard: true,
                captureSelects: true,
                captureNavigation: true,
                captureHover: true,
                captureScreenshots: true,
                captureConsoleOutput: true,
                captureNetwork: true,
                polyfillFeatures: true,
                useShadowDOM: false,
                isolateStyles: true,
                extensionMode: false, // Whether running as a Chrome extension
                debugMode: false,
                injectionPoint: 'body', // Where to inject the recorder UI if needed
                eventThrottleMs: 50
            }, config);

            // Communication channel for sending events
            this.port = null;
            
            // Chrome-specific feature detection results
            this.features = {
                supportsExtensionAPI: this._checkExtensionSupport(),
                supportsShadowDOM: !!HTMLElement.prototype.attachShadow,
                supportsPromises: typeof Promise !== 'undefined',
                supportsModules: this._checkModuleSupport(),
                supportsContentScripts: this._checkContentScriptSupport(),
                supportsMutationObserver: typeof MutationObserver !== 'undefined',
                supportsIntersectionObserver: typeof IntersectionObserver !== 'undefined',
                supportsPerformanceAPI: this._checkPerformanceAPISupport(),
                supportsWebSockets: typeof WebSocket !== 'undefined',
                supportsServiceWorkers: 'serviceWorker' in navigator,
                supportsSessionStorage: this._checkSessionStorageSupport(),
                supportsChromeStorage: this._checkChromeStorageSupport(),
                isHeadless: this._checkIfHeadless(),
                isIncognito: this._checkIfIncognito(),
                hasDevToolsOpen: this._checkDevToolsOpen()
            };
            
            // Store for mutation observer and event listeners
            this.observers = {};
            this.listeners = {};
            
            // Namespace to prevent collision with application code
            this.namespace = '__CSTestForge_' + Math.random().toString(36).substring(2, 15);
            
            // Initialization state
            this.isInitialized = false;
        }
        
        /**
         * Initialize the Chrome injection system
         * @returns {Promise<boolean>} Success indicator
         */
        async initialize() {
            if (this.isInitialized) {
                return true;
            }
            
            try {
                this._log('Initializing Chrome injector...');
                
                // 1. Set up browser detection
                await this._detectBrowserDetails();
                
                // 2. Inject necessary polyfills for Chrome if needed
                if (this.config.polyfillFeatures) {
                    await this._injectPolyfills();
                }
                
                // 3. Set up communication channel
                await this._setupCommunication();
                
                // 4. Inject CSS and UI elements if needed
                await this._injectStyles();
                
                // 5. Setup event listeners and DOM observers
                await this._setupEventCapture();
                
                // 6. Initialize network and console monitoring
                if (this.config.captureConsoleOutput) {
                    this._setupConsoleCapture();
                }
                
                if (this.config.captureNetwork) {
                    this._setupNetworkCapture();
                }
                
                // 7. Register commands
                this._registerCommands();
                
                this.isInitialized = true;
                this._log('Chrome injector initialized successfully');
                
                return true;
            } catch (error) {
                this._error('Failed to initialize Chrome injector', error);
                return false;
            }
        }
        
        /**
         * Clean up resources and remove injected elements
         */
        destroy() {
            if (!this.isInitialized) {
                return;
            }
            
            try {
                this._log('Destroying Chrome injector...');
                
                // 1. Clean up event listeners
                this._removeAllEventListeners();
                
                // 2. Disconnect all observers
                this._disconnectAllObservers();
                
                // 3. Remove injected elements
                this._removeInjectedElements();
                
                // 4. Restore console functionality
                this._restoreConsole();
                
                // 5. Close communication channel
                this._closeCommunication();
                
                this.isInitialized = false;
                this._log('Chrome injector destroyed successfully');
            } catch (error) {
                this._error('Error destroying Chrome injector', error);
            }
        }
        
        /**
         * Inject a script into the page context
         * @param {string} scriptContent - JavaScript to inject
         * @param {boolean} asModule - Whether to inject as a module
         * @returns {Promise<any>} Result of script execution
         */
        injectScript(scriptContent, asModule = false) {
            return new Promise((resolve, reject) => {
                try {
                    const script = document.createElement('script');
                    script.dataset.csTestForge = 'injected-script';
                    
                    if (asModule && this.features.supportsModules) {
                        script.type = 'module';
                    }
                    
                    // Create a unique ID for this script execution
                    const executionId = 'csExec_' + Math.random().toString(36).substring(2, 15);
                    
                    // Set up listener for the result
                    const listener = (event) => {
                        if (event.data && 
                            event.data.type === 'CS_SCRIPT_RESULT' && 
                            event.data.executionId === executionId) {
                            
                            window.removeEventListener('message', listener);
                            
                            if (event.data.error) {
                                reject(new Error(event.data.error));
                            } else {
                                resolve(event.data.result);
                            }
                        }
                    };
                    
                    window.addEventListener('message', listener);
                    
                    // Wrap the script content to capture its result
                    script.textContent = `
                        (function() {
                            try {
                                const result = (function() {
                                    ${scriptContent}
                                })();
                                
                                window.postMessage({
                                    type: 'CS_SCRIPT_RESULT',
                                    executionId: '${executionId}',
                                    result: result
                                }, '*');
                            } catch (err) {
                                window.postMessage({
                                    type: 'CS_SCRIPT_RESULT',
                                    executionId: '${executionId}',
                                    error: err.message
                                }, '*');
                            }
                        })();
                    `;
                    
                    document.head.appendChild(script);
                    
                    // Cleanup
                    setTimeout(() => {
                        if (script.parentNode) {
                            script.parentNode.removeChild(script);
                        }
                    }, 100);
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        /**
         * Creates a shadow root for isolating injected elements
         * @param {Element} element - Element to attach shadow root to
         * @returns {ShadowRoot} The shadow root
         */
        createShadowRoot(element) {
            if (!this.features.supportsShadowDOM) {
                this._warn('ShadowDOM not supported in this browser');
                return element;
            }
            
            // Using open mode to allow accessibility of shadow DOM content
            const shadowRoot = element.attachShadow({ mode: 'open' });
            return shadowRoot;
        }
        
        /**
         * Sends an event to the recorder application
         * @param {string} eventType - Type of event
         * @param {Object} data - Event data
         */
        sendEvent(eventType, data = {}) {
            if (!this.port) {
                this._warn('Communication channel not established');
                return;
            }
            
            try {
                const event = {
                    type: eventType,
                    timestamp: Date.now(),
                    url: window.location.href,
                    data: data,
                    source: 'chrome-injector'
                };
                
                if (this.config.extensionMode && this.features.supportsExtensionAPI) {
                    // Use Chrome extension messaging
                    this.port.postMessage(event);
                } else {
                    // Use window messaging
                    window.postMessage({
                        namespace: this.namespace,
                        event: event
                    }, '*');
                }
            } catch (error) {
                this._error('Error sending event', error);
            }
        }
        
        /**
         * Execute a command from the recorder application
         * @param {string} command - Command name
         * @param {Object} params - Command parameters
         * @returns {Promise<any>} Command result
         */
        async executeCommand(command, params = {}) {
            this._log(`Executing command: ${command}`);
            
            if (!this.commandHandlers || !this.commandHandlers[command]) {
                throw new Error(`Unknown command: ${command}`);
            }
            
            try {
                return await this.commandHandlers[command](params);
            } catch (error) {
                this._error(`Error executing command ${command}`, error);
                throw error;
            }
        }
        
        /**
         * Highlight an element on the page
         * @param {Element|string} element - Element or CSS selector
         * @param {Object} options - Highlight options
         */
        highlightElement(element, options = {}) {
            const defaultOptions = {
                color: '#C54B8C', // Primary brand color
                duration: 2000,
                outlineWidth: '2px',
                outlineStyle: 'solid',
                borderRadius: '2px',
                pulseEffect: true,
                zIndex: 2147483647 // Maximum z-index
            };
            
            const highlightOptions = Object.assign(defaultOptions, options);
            
            try {
                // Find the element if selector provided
                if (typeof element === 'string') {
                    element = document.querySelector(element);
                }
                
                if (!element) {
                    this._warn('Element not found for highlighting');
                    return;
                }
                
                // Get element position
                const rect = element.getBoundingClientRect();
                
                // Create highlight overlay
                const overlay = document.createElement('div');
                overlay.dataset.csTestForge = 'highlight-overlay';
                
                Object.assign(overlay.style, {
                    position: 'fixed',
                    boxSizing: 'border-box',
                    top: rect.top + 'px',
                    left: rect.left + 'px',
                    width: rect.width + 'px',
                    height: rect.height + 'px',
                    outline: `${highlightOptions.outlineWidth} ${highlightOptions.outlineStyle} ${highlightOptions.color}`,
                    borderRadius: highlightOptions.borderRadius,
                    pointerEvents: 'none',
                    zIndex: highlightOptions.zIndex
                });
                
                // Add pulse animation if enabled
                if (highlightOptions.pulseEffect) {
                    overlay.style.animation = `cstf-pulse ${highlightOptions.duration / 1000}s ease-in-out`;
                    
                    // Add the keyframes for the animation if not already present
                    if (!document.querySelector('#cstf-highlight-keyframes')) {
                        const keyframes = document.createElement('style');
                        keyframes.id = 'cstf-highlight-keyframes';
                        keyframes.textContent = `
                            @keyframes cstf-pulse {
                                0% { opacity: 0; }
                                25% { opacity: 0.7; }
                                50% { opacity: 0.5; }
                                75% { opacity: 0.7; }
                                100% { opacity: 0; }
                            }
                        `;
                        document.head.appendChild(keyframes);
                    }
                }
                
                // Add to DOM
                document.body.appendChild(overlay);
                
                // Remove after duration
                setTimeout(() => {
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                }, highlightOptions.duration);
                
                // Handle element scrolling into view if necessary
                if (options.scrollIntoView) {
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center',
                        inline: 'center'
                    });
                }
            } catch (error) {
                this._error('Error highlighting element', error);
            }
        }
        
        /*********************
         * Private Methods
         ********************/
        
        /**
         * Check if Chrome extension API is supported
         * @private
         * @returns {boolean} Whether extension API is supported
         */
        _checkExtensionSupport() {
            return typeof chrome !== 'undefined' && 
                   typeof chrome.runtime !== 'undefined' &&
                   typeof chrome.runtime.sendMessage !== 'undefined';
        }
        
        /**
         * Check if ES6 modules are supported
         * @private
         * @returns {boolean} Whether modules are supported
         */
        _checkModuleSupport() {
            try {
                new Function('return import("")');
                return true;
            } catch (err) {
                return false;
            }
        }
        
        /**
         * Check if content scripts are supported
         * @private
         * @returns {boolean} Whether content scripts are supported
         */
        _checkContentScriptSupport() {
            return typeof chrome !== 'undefined' && 
                   typeof chrome.tabs !== 'undefined' && 
                   typeof chrome.tabs.executeScript !== 'undefined';
        }
        
        /**
         * Check if Performance API is supported
         * @private
         * @returns {boolean} Whether Performance API is supported
         */
        _checkPerformanceAPISupport() {
            return typeof performance !== 'undefined' && 
                   typeof performance.now === 'function' &&
                   typeof performance.mark === 'function';
        }
        
        /**
         * Check if SessionStorage is supported
         * @private
         * @returns {boolean} Whether SessionStorage is supported
         */
        _checkSessionStorageSupport() {
            try {
                const testKey = '__csTestForge_test__';
                sessionStorage.setItem(testKey, 'test');
                sessionStorage.removeItem(testKey);
                return true;
            } catch (e) {
                return false;
            }
        }
        
        /**
         * Check if Chrome Storage API is supported
         * @private
         * @returns {boolean} Whether Chrome Storage API is supported
         */
        _checkChromeStorageSupport() {
            return typeof chrome !== 'undefined' && 
                   typeof chrome.storage !== 'undefined' &&
                   typeof chrome.storage.local !== 'undefined';
        }
        
        /**
         * Check if browser is running in headless mode
         * @private
         * @returns {boolean} Whether browser is headless
         */
        _checkIfHeadless() {
            // Multiple techniques to detect headless mode
            const checks = [
                // Check for Plugins (Headless has none)
                navigator.plugins.length === 0,
                
                // Check for WebDriver
                navigator.webdriver === true,
                
                // Check for unusual navigator properties
                navigator.languages === undefined,
                
                // Check for hardware concurrency (sometimes limited in headless)
                navigator.hardwareConcurrency <= 2,
                
                // Check for unusual touch points behavior
                'ontouchstart' in window && navigator.maxTouchPoints === 0
            ];
            
            // Consider headless if majority of checks pass
            return checks.filter(Boolean).length > checks.length / 2;
        }
        
        /**
         * Check if browser is in incognito mode
         * @private
         * @returns {boolean} Whether browser is in incognito mode
         */
        _checkIfIncognito() {
            if (!this.features.supportsSessionStorage) {
                // If sessionStorage is disabled, likely incognito
                return true;
            }
            
            // Try to use filesystem API which is disabled in incognito
            try {
                window.webkitRequestFileSystem(
                    window.TEMPORARY, 1,
                    () => { 
                        this._incognitoResult = false; 
                    },
                    () => { 
                        this._incognitoResult = true; 
                    }
                );
                
                return this._incognitoResult;
            } catch (e) {
                // If filesystem API not available, use fallback detection
                return !window.indexedDB;
            }
        }
        
        /**
         * Check if DevTools is open
         * @private
         * @returns {boolean} Whether DevTools is open
         */
        _checkDevToolsOpen() {
            // Method 1: Check for Firebug
            if (window.Firebug && window.Firebug.chrome && window.Firebug.chrome.isInitialized) {
                return true;
            }
            
            // Method 2: Check if debugger statement takes unusually long time
            const startTime = Date.now();
            debugger; // This statement is ignored when DevTools is closed
            const endTime = Date.now();
            
            // If more than 50ms passed, DevTools was likely open
            return endTime - startTime > 50;
        }
        
        /**
         * Detect detailed browser information
         * @private
         */
        async _detectBrowserDetails() {
            try {
                // Extract detailed Chrome version
                const userAgent = navigator.userAgent;
                const chromeRegex = /(Chrome)\\/(([0-9]+)\\.([0-9]+)\\.([0-9]+)\\.([0-9]+)).*/;
                const match = userAgent.match(chromeRegex);
                
                let version = null;
                if (match) {
                    version = {
                        full: match[2],
                        major: parseInt(match[3], 10),
                        minor: parseInt(match[4], 10),
                        build: parseInt(match[5], 10),
                        patch: parseInt(match[6], 10)
                    };
                }
                
                // Determine Chrome variant
                let variant = 'Chrome';
                if (userAgent.includes('Edg/')) {
                    variant = 'EdgeChromium';
                } else if (userAgent.includes('OPR/')) {
                    variant = 'Opera';
                } else if (userAgent.includes('Brave')) {
                    variant = 'Brave';
                } else if (userAgent.includes('Vivaldi')) {
                    variant = 'Vivaldi';
                } else if (userAgent.includes('YaBrowser')) {
                    variant = 'Yandex';
                }
                
                // Detect OS
                let os = 'Unknown';
                let osVersion = null;
                
                if (userAgent.includes('Windows')) {
                    os = 'Windows';
                    const windowsMatch = userAgent.match(/Windows NT ([0-9.]+)/);
                    if (windowsMatch) {
                        const ntVersion = windowsMatch[1];
                        const windowsVersions = {
                            '10.0': '10',
                            '6.3': '8.1',
                            '6.2': '8',
                            '6.1': '7',
                            '6.0': 'Vista',
                            '5.2': 'XP',
                            '5.1': 'XP'
                        };
                        osVersion = windowsVersions[ntVersion] || ntVersion;
                    }
                } else if (userAgent.includes('Mac OS X')) {
                    os = 'macOS';
                    const macMatch = userAgent.match(/Mac OS X ([0-9_.]+)/);
                    if (macMatch) {
                        osVersion = macMatch[1].replace(/_/g, '.');
                    }
                } else if (userAgent.includes('Linux')) {
                    os = 'Linux';
                } else if (userAgent.includes('Android')) {
                    os = 'Android';
                    const androidMatch = userAgent.match(/Android ([0-9.]+)/);
                    if (androidMatch) {
                        osVersion = androidMatch[1];
                    }
                } else if (userAgent.includes('iOS')) {
                    os = 'iOS';
                    const iosMatch = userAgent.match(/OS ([0-9_]+)/);
                    if (iosMatch) {
                        osVersion = iosMatch[1].replace(/_/g, '.');
                    }
                }
                
                // Store browser details
                this.browserDetails = {
                    name: 'Chrome',
                    variant: variant,
                    version: version,
                    userAgent: userAgent,
                    os: os,
                    osVersion: osVersion,
                    language: navigator.language,
                    platform: navigator.platform,
                    isIncognito: this._checkIfIncognito(),
                    isHeadless: this._checkIfHeadless(),
                    hasDevToolsOpen: this._checkDevToolsOpen()
                };
                
                // Make available globally for other CSTestForge components
                window.CSTestForge = window.CSTestForge || {};
                window.CSTestForge.browserInfo = {
                    name: 'Chrome',
                    version: version ? version.full : null,
                    isChrome: true,
                    isFirefox: false,
                    isSafari: false,
                    isEdge: variant === 'EdgeChromium',
                    isEdgeChromium: variant === 'EdgeChromium',
                    isEdgeLegacy: false,
                    isIE: false,
                    isOpera: variant === 'Opera',
                    isBrave: variant === 'Brave'
                };
                
                this._log('Detected browser details', this.browserDetails);
            } catch (error) {
                this._error('Error detecting browser details', error);
                
                // Fallback to basic info
                this.browserDetails = {
                    name: 'Chrome',
                    userAgent: navigator.userAgent
                };
            }
        }
        
        /**
         * Inject required polyfills for Chrome/Chromium
         * @private
         */
        async _injectPolyfills() {
            try {
                // Chrome generally has good feature support, but there are edge cases
                const polyfillsNeeded = [];
                
                // For older Chrome versions
                if (this.browserDetails.version && this.browserDetails.version.major < 50) {
                    polyfillsNeeded.push('fetch');
                }
                
                if (this.browserDetails.version && this.browserDetails.version.major < 55) {
                    polyfillsNeeded.push('IntersectionObserver');
                }
                
                if (this.browserDetails.version && this.browserDetails.version.major < 64) {
                    polyfillsNeeded.push('ResizeObserver');
                }
                
                if (polyfillsNeeded.length > 0) {
                    this._log(`Injecting polyfills for Chrome: ${polyfillsNeeded.join(', ')}`);
                    
                    // Using CSTestForge's polyfills module
                    const script = document.createElement('script');
                    script.dataset.csTestForge = 'polyfills';
                    script.src = this._getResourceUrl('polyfills.js');
                    
                    // Wait for script to load
                    await new Promise((resolve, reject) => {
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                } else {
                    this._log('No polyfills needed for this Chrome version');
                }
            } catch (error) {
                this._error('Error injecting polyfills', error);
            }
        }
        
        /**
         * Set up communication channel with the recorder application
         * @private
         */
        async _setupCommunication() {
            try {
                if (this.config.extensionMode && this.features.supportsExtensionAPI) {
                    // Chrome extension mode - use runtime port
                    this.port = chrome.runtime.connect({ name: 'cstestforge-recorder' });
                    
                    this.port.onMessage.addListener((message) => {
                        this._handleMessage(message);
                    });
                    
                    this.port.onDisconnect.addListener(() => {
                        this._log('Port disconnected');
                        this.port = null;
                    });
                } else {
                    // Standalone mode - use window messaging
                    this._addEventListenerWithCleanup(window, 'message', (event) => {
                        if (event.data && 
                            event.data.namespace === this.namespace &&
                            event.data.command) {
                            
                            this._handleCommand(event.data.command, event.data.params);
                        }
                    });
                }
                
                // Send ready event
                this.sendEvent('INJECTOR_READY', {
                    features: this.features,
                    browserDetails: this.browserDetails
                });
            } catch (error) {
                this._error('Error setting up communication', error);
            }
        }
        
        /**
         * Handle incoming messages from the recorder
         * @private
         * @param {Object} message - The message object
         */
        _handleMessage(message) {
            if (!message || !message.command) {
                return;
            }
            
            this._handleCommand(message.command, message.params);
        }
        
        /**
         * Handle commands from the recorder
         * @private
         * @param {string} command - Command name
         * @param {Object} params - Command parameters
         */
        async _handleCommand(command, params) {
            try {
                await this.executeCommand(command, params);
            } catch (error) {
                this._error(`Error handling command: ${command}`, error);
                
                this.sendEvent('COMMAND_ERROR', {
                    command: command,
                    error: error.message,
                    stack: error.stack
                });
            }
        }
        
        /**
         * Inject necessary CSS styles
         * @private
         */
        async _injectStyles() {
            try {
                const styleContent = `
                    /* CSTestForge Chrome Injector Styles */
                    [data-cs-test-forge="highlight-overlay"] {
                        pointer-events: none !important;
                        box-sizing: border-box !important;
                        position: fixed !important;
                        z-index: 2147483647 !important;
                    }
                    
                    [data-cs-test-forge="recorder-ui"] {
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
                        font-size: 14px !important;
                        color: #333 !important;
                    }
                    
                    [data-cs-test-forge="tooltip"] {
                        position: absolute !important;
                        background: rgba(0, 0, 0, 0.8) !important;
                        color: white !important;
                        padding: 5px 10px !important;
                        border-radius: 4px !important;
                        font-size: 12px !important;
                        z-index: 2147483647 !important;
                        pointer-events: none !important;
                        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2) !important;
                    }
                    
                    /* Animation for element highlighting */
                    @keyframes cstf-pulse {
                        0% { opacity: 0; }
                        25% { opacity: 0.7; }
                        50% { opacity: 0.5; }
                        75% { opacity: 0.7; }
                        100% { opacity: 0; }
                    }
                `;
                
                const style = document.createElement('style');
                style.dataset.csTestForge = 'injected-styles';
                style.textContent = styleContent;
                
                document.head.appendChild(style);
            } catch (error) {
                this._error('Error injecting styles', error);
            }
        }
        
        /**
         * Set up event capture for the page
         * @private
         */
        async _setupEventCapture() {
            try {
                // Create and configure event capture module instance
                // This code assumes event-capture.js is already loaded
                if (window.CSTestForge && window.CSTestForge.EventCapture) {
                    const eventCapture = new window.CSTestForge.EventCapture({
                        captureClicks: this.config.captureClicks,
                        captureKeyboard: this.config.captureKeyboard,
                        captureSelects: this.config.captureSelects,
                        captureNavigation: this.config.captureNavigation,
                        captureHover: this.config.captureHover,
                        throttleMs: this.config.eventThrottleMs,
                        onEvent: (eventType, eventData) => {
                            this.sendEvent(eventType, eventData);
                        }
                    });
                    
                    await eventCapture.initialize();
                    this.eventCapture = eventCapture;
                    
                    // Save for cleanup
                    this.modules = this.modules || {};
                    this.modules.eventCapture = eventCapture;
                } else {
                    this._warn('EventCapture module not found');
                    
                    // Fallback to basic click capturing
                    this._setupBasicEventCapture();
                }
                
                // Set up DOM observer
                this._setupDOMObserver();
            } catch (error) {
                this._error('Error setting up event capture', error);
                
                // Fallback to basic capture
                this._setupBasicEventCapture();
            }
        }
        
        /**
         * Fallback to basic event capturing when full module unavailable
         * @private
         */
        _setupBasicEventCapture() {
            this._log('Using basic event capture as fallback');
            
            // Capture clicks
            if (this.config.captureClicks) {
                this._addEventListenerWithCleanup(document, 'click', (event) => {
                    // Skip events from our own UI
                    if (this._isFromCsTestForge(event.target)) {
                        return;
                    }
                    
                    const elementInfo = this._getElementInfo(event.target);
                    
                    this.sendEvent('CLICK', {
                        elementInfo: elementInfo,
                        clientX: event.clientX,
                        clientY: event.clientY,
                        ctrlKey: event.ctrlKey,
                        altKey: event.altKey,
                        shiftKey: event.shiftKey,
                        metaKey: event.metaKey,
                        button: event.button
                    });
                }, true);
            }
            
            // Capture form interactions
            if (this.config.captureClicks) {
                // Input changes
                this._addEventListenerWithCleanup(document, 'change', (event) => {
                    if (this._isFromCsTestForge(event.target)) {
                        return;
                    }
                    
                    const elementInfo = this._getElementInfo(event.target);
                    
                    // Handle different input types
                    let value = event.target.value;
                    if (event.target.type === 'checkbox' || event.target.type === 'radio') {
                        value = event.target.checked;
                    }
                    
                    this.sendEvent('INPUT_CHANGE', {
                        elementInfo: elementInfo,
                        value: value,
                        inputType: event.target.type || 'text'
                    });
                }, true);
            }
            
            // Capture navigation
            if (this.config.captureNavigation) {
                // Use both popstate and hashchange
                this._addEventListenerWithCleanup(window, 'popstate', () => {
                    this.sendEvent('NAVIGATION', {
                        url: window.location.href,
                        title: document.title,
                        type: 'popstate'
                    });
                });
                
                this._addEventListenerWithCleanup(window, 'hashchange', () => {
                    this.sendEvent('NAVIGATION', {
                        url: window.location.href,
                        title: document.title,
                        type: 'hashchange'
                    });
                });
                
                // Capture form submissions
                this._addEventListenerWithCleanup(document, 'submit', (event) => {
                    if (this._isFromCsTestForge(event.target)) {
                        return;
                    }
                    
                    const elementInfo = this._getElementInfo(event.target);
                    
                    this.sendEvent('FORM_SUBMIT', {
                        elementInfo: elementInfo,
                        action: event.target.action,
                        method: event.target.method
                    });
                }, true);
                
                // Monkey patch history API
                const originalPushState = history.pushState;
                const originalReplaceState = history.replaceState;
                
                history.pushState = function() {
                    const result = originalPushState.apply(this, arguments);
                    
                    window.dispatchEvent(new Event('pushstate'));
                    window.dispatchEvent(new Event('locationchange'));
                    
                    return result;
                };
                
                history.replaceState = function() {
                    const result = originalReplaceState.apply(this, arguments);
                    
                    window.dispatchEvent(new Event('replacestate'));
                    window.dispatchEvent(new Event('locationchange'));
                    
                    return result;
                };
                
                this._addEventListenerWithCleanup(window, 'locationchange', () => {
                    this.sendEvent('NAVIGATION', {
                        url: window.location.href,
                        title: document.title,
                        type: 'historyapi'
                    });
                });
            }
        }
        
        /**
         * Set up DOM observer to detect changes
         * @private
         */
        _setupDOMObserver() {
            try {
                // Create and configure DOM observer module instance
                if (window.CSTestForge && window.CSTestForge.DOMObserver) {
                    const domObserver = new window.CSTestForge.DOMObserver({
                        subtree: true,
                        childList: true,
                        attributes: true,
                        characterData: true,
                        onMutation: (mutationRecords) => {
                            // Throttle DOM mutations to reduce overhead
                            if (this._domMutationTimeout) {
                                clearTimeout(this._domMutationTimeout);
                            }
                            
                            this._domMutationTimeout = setTimeout(() => {
                                const processedMutations = this._processMutations(mutationRecords);
                                
                                if (processedMutations.changes.length > 0) {
                                    this.sendEvent('DOM_MUTATION', processedMutations);
                                }
                            }, 200); // Throttle to 200ms
                        }
                    });
                    
                    domObserver.initialize();
                    
                    // Save for cleanup
                    this.modules = this.modules || {};
                    this.modules.domObserver = domObserver;
                } else {
                    this._warn('DOMObserver module not found');
                    
                    // Fallback to basic MutationObserver
                    this._setupBasicDOMObserver();
                }
            } catch (error) {
                this._error('Error setting up DOM observer', error);
                
                // Fallback to basic observer
                this._setupBasicDOMObserver();
            }
        }
        
        /**
         * Fallback to basic DOM observation
         * @private
         */
        _setupBasicDOMObserver() {
            this._log('Using basic DOM observer as fallback');
            
            if (!this.features.supportsMutationObserver) {
                this._warn('MutationObserver not supported');
                return;
            }
            
            const observer = new MutationObserver((mutations) => {
                // Throttle DOM mutations to reduce overhead
                if (this._domMutationTimeout) {
                    clearTimeout(this._domMutationTimeout);
                }
                
                this._domMutationTimeout = setTimeout(() => {
                    const processedMutations = this._processMutations(mutations);
                    
                    if (processedMutations.changes.length > 0) {
                        this.sendEvent('DOM_MUTATION', processedMutations);
                    }
                }, 200); // Throttle to 200ms
            });
            
            // Start observing
            observer.observe(document.documentElement, {
                subtree: true,
                childList: true,
                attributes: true,
                characterData: true,
                attributeOldValue: true,
                characterDataOldValue: true
            });
            
            // Save for cleanup
            this.observers.domMutation = observer;
        }
        
        /**
         * Process DOM mutations to extract relevant changes
         * @private
         * @param {MutationRecord[]} mutations - Mutation records
         * @returns {Object} Processed mutations
         */
        _processMutations(mutations) {
            const changes = [];
            const stats = {
                addedNodes: 0,
                removedNodes: 0,
                attributeChanges: 0,
                textChanges: 0
            };
            
            for (const mutation of mutations) {
                // Skip mutations in our own elements
                if (this._isFromCsTestForge(mutation.target)) {
                    continue;
                }
                
                if (mutation.type === 'childList') {
                    if (mutation.addedNodes.length > 0) {
                        stats.addedNodes += mutation.addedNodes.length;
                        
                        // Only add significant added nodes
                        for (const node of mutation.addedNodes) {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                const elementInfo = this._getElementInfo(node);
                                
                                changes.push({
                                    type: 'nodeAdded',
                                    elementInfo: elementInfo,
                                    parentPath: this._getElementXPath(mutation.target)
                                });
                            }
                        }
                    }
                    
                    if (mutation.removedNodes.length > 0) {
                        stats.removedNodes += mutation.removedNodes.length;
                        
                        // Only add significant removed nodes (elements)
                        for (const node of mutation.removedNodes) {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                // For removed nodes, we can't get much info
                                changes.push({
                                    type: 'nodeRemoved',
                                    tagName: node.tagName,
                                    parentPath: this._getElementXPath(mutation.target)
                                });
                            }
                        }
                    }
                } else if (mutation.type === 'attributes') {
                    stats.attributeChanges++;
                    
                    changes.push({
                        type: 'attributeChanged',
                        elementInfo: this._getElementInfo(mutation.target),
                        attributeName: mutation.attributeName,
                        oldValue: mutation.oldValue,
                        newValue: mutation.target.getAttribute(mutation.attributeName)
                    });
                } else if (mutation.type === 'characterData') {
                    stats.textChanges++;
                    
                    changes.push({
                        type: 'textChanged',
                        elementInfo: this._getElementInfo(mutation.target.parentElement),
                        oldValue: mutation.oldValue,
                        newValue: mutation.target.nodeValue
                    });
                }
            }
            
            return {
                changes: changes,
                stats: stats,
                timestamp: Date.now(),
                url: window.location.href
            };
        }
        
        /**
         * Set up console output capturing
         * @private
         */
        _setupConsoleCapture() {
            try {
                // Save original console methods
                this._originalConsole = {
                    log: console.log,
                    warn: console.warn,
                    error: console.error,
                    info: console.info,
                    debug: console.debug
                };
                
                // Override console.log
                console.log = (...args) => {
                    this._originalConsole.log.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'log',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Override console.warn
                console.warn = (...args) => {
                    this._originalConsole.warn.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'warn',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Override console.error
                console.error = (...args) => {
                    this._originalConsole.error.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'error',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Override console.info
                console.info = (...args) => {
                    this._originalConsole.info.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'info',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Override console.debug
                console.debug = (...args) => {
                    this._originalConsole.debug.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'debug',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Also capture JavaScript errors
                this._addEventListenerWithCleanup(window, 'error', (event) => {
                    this.sendEvent('JS_ERROR', {
                        message: event.message,
                        source: event.filename,
                        lineno: event.lineno,
                        colno: event.colno,
                        error: event.error ? {
                            name: event.error.name,
                            message: event.error.message,
                            stack: event.error.stack
                        } : null
                    });
                });
                
                // Capture unhandled promise rejections
                this._addEventListenerWithCleanup(window, 'unhandledrejection', (event) => {
                    const error = event.reason;
                    
                    this.sendEvent('UNHANDLED_REJECTION', {
                        message: error ? error.message : 'Unknown promise rejection',
                        stack: error && error.stack ? error.stack : null
                    });
                });
            } catch (error) {
                this._error('Error setting up console capture', error);
            }
        }
        
        /**
         * Safely stringify console arguments
         * @private
         * @param {Array} args - Console arguments
         * @returns {Array<string>} Stringified arguments
         */
        _stringifyConsoleArgs(args) {
            try {
                return args.map(arg => {
                    if (arg === null) return 'null';
                    if (arg === undefined) return 'undefined';
                    
                    // For errors, extract useful information
                    if (arg instanceof Error) {
                        return {
                            type: 'Error',
                            name: arg.name,
                            message: arg.message,
                            stack: arg.stack
                        };
                    }
                    
                    // For DOM nodes, get a useful representation
                    if (arg instanceof Node) {
                        if (arg.nodeType === Node.ELEMENT_NODE) {
                            return {
                                type: 'DOMElement',
                                tagName: arg.tagName,
                                id: arg.id,
                                className: arg.className,
                                attributes: this._getElementAttributes(arg),
                                xpath: this._getElementXPath(arg)
                            };
                        } else if (arg.nodeType === Node.TEXT_NODE) {
                            return {
                                type: 'DOMText',
                                textContent: arg.textContent.substring(0, 100)
                            };
                        }
                        
                        return {
                            type: 'DOMNode',
                            nodeType: arg.nodeType,
                            nodeName: arg.nodeName
                        };
                    }
                    
                    // Try regular JSON stringify for other types
                    try {
                        return JSON.stringify(arg);
                    } catch (e) {
                        return String(arg);
                    }
                });
            } catch (error) {
                this._error('Error stringifying console args', error);
                return args.map(arg => String(arg));
            }
        }
        
        /**
         * Set up network request capturing using Performance API
         * @private
         */
        _setupNetworkCapture() {
            try {
                if (!this.features.supportsPerformanceAPI) {
                    this._warn('Performance API not supported, network capture disabled');
                    return;
                }
                
                // Use PerformanceObserver if available (Chrome 52+)
                if ('PerformanceObserver' in window) {
                    const observer = new PerformanceObserver((list) => {
                        const entries = list.getEntries();
                        for (const entry of entries) {
                            // Only process resource entries (not navigation, paint, etc.)
                            if (entry.entryType === 'resource') {
                                this._processResourceTiming(entry);
                            }
                        }
                    });
                    
                    observer.observe({ entryTypes: ['resource'] });
                    
                    // Save for cleanup
                    this.observers.performance = observer;
                } else {
                    // Fallback to polling for older browsers
                    const checkResources = () => {
                        const entries = performance.getEntriesByType('resource');
                        
                        // Process only new entries (not seen before)
                        for (const entry of entries) {
                            const id = entry.name + '-' + entry.startTime;
                            
                            if (!this._processedResources || !this._processedResources.has(id)) {
                                this._processResourceTiming(entry);
                                
                                // Mark as processed
                                if (!this._processedResources) {
                                    this._processedResources = new Set();
                                }
                                this._processedResources.add(id);
                            }
                        }
                    };
                    
                    // Check periodically
                    this._networkCaptureInterval = setInterval(checkResources, 1000);
                    
                    // Initial check
                    checkResources();
                }
                
                // Also patch XMLHttpRequest for more detailed XHR tracking
                this._patchXMLHttpRequest();
                
                // And patch fetch if available
                if (typeof fetch === 'function') {
                    this._patchFetch();
                }
            } catch (error) {
                this._error('Error setting up network capture', error);
            }
        }
        
        /**
         * Process a resource timing entry
         * @private
         * @param {PerformanceResourceTiming} entry - Performance entry
         */
        _processResourceTiming(entry) {
            try {
                // Skip tracking our own resources
                if (entry.name.includes('cstestforge') || 
                    entry.name.includes('csTestForge')) {
                    return;
                }
                
                // Extract useful information
                const timing = {
                    name: entry.name,
                    entryType: entry.entryType,
                    startTime: entry.startTime,
                    duration: entry.duration,
                    initiatorType: entry.initiatorType,
                    redirectStart: entry.redirectStart,
                    redirectEnd: entry.redirectEnd,
                    fetchStart: entry.fetchStart,
                    domainLookupStart: entry.domainLookupStart,
                    domainLookupEnd: entry.domainLookupEnd,
                    connectStart: entry.connectStart,
                    connectEnd: entry.connectEnd,
                    secureConnectionStart: entry.secureConnectionStart,
                    requestStart: entry.requestStart,
                    responseStart: entry.responseStart,
                    responseEnd: entry.responseEnd,
                    transferSize: entry.transferSize,
                    encodedBodySize: entry.encodedBodySize,
                    decodedBodySize: entry.decodedBodySize
                };
                
                // Calculate valuable metrics
                const metrics = {
                    dnsTime: entry.domainLookupEnd - entry.domainLookupStart,
                    tcpTime: entry.connectEnd - entry.connectStart,
                    sslTime: entry.secureConnectionStart ? 
                        entry.connectEnd - entry.secureConnectionStart : 0,
                    requestTime: entry.responseStart - entry.requestStart,
                    responseTime: entry.responseEnd - entry.responseStart,
                    totalTime: entry.duration,
                    url: entry.name
                };
                
                this.sendEvent('NETWORK_RESOURCE', {
                    timing: timing,
                    metrics: metrics,
                    timestamp: Date.now()
                });
            } catch (error) {
                this._error('Error processing resource timing', error);
            }
        }
        
        /**
         * Patch XMLHttpRequest to capture detailed request/response data
         * @private
         */
        _patchXMLHttpRequest() {
            const originalOpen = XMLHttpRequest.prototype.open;
            const originalSend = XMLHttpRequest.prototype.send;
            const self = this;
            
            XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
                // Save request information
                this._csRequestInfo = {
                    method: method,
                    url: url,
                    async: async !== false,
                    user: user,
                    timestamp: Date.now(),
                    requestHeaders: {}
                };
                
                return originalOpen.apply(this, arguments);
            };
            
            // Track request headers
            const originalSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
            XMLHttpRequest.prototype.setRequestHeader = function(header, value) {
                if (this._csRequestInfo) {
                    this._csRequestInfo.requestHeaders[header] = value;
                }
                return originalSetRequestHeader.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function(body) {
                if (this._csRequestInfo) {
                    // Save request body if possible
                    this._csRequestInfo.requestBody = body;
                    
                    // Track request start time
                    this._csRequestInfo.startTime = performance.now();
                    
                    // Send request start event
                    self.sendEvent('XHR_START', {
                        method: this._csRequestInfo.method,
                        url: this._csRequestInfo.url,
                        async: this._csRequestInfo.async,
                        headers: this._csRequestInfo.requestHeaders,
                        timestamp: Date.now()
                    });
                    
                    // Track response
                    this.addEventListener('load', function() {
                        if (!this._csRequestInfo) {
                            return;
                        }
                        
                        // Calculate timing
                        const endTime = performance.now();
                        const duration = endTime - this._csRequestInfo.startTime;
                        
                        // Extract response headers
                        const responseHeaders = {};
                        const allHeaders = this.getAllResponseHeaders();
                        const headerLines = allHeaders.split(/\r?\n/);
                        
                        for (const line of headerLines) {
                            if (line.trim() === '') continue;
                            
                            const parts = line.split(': ');
                            const header = parts.shift();
                            const value = parts.join(': ');
                            
                            responseHeaders[header] = value;
                        }
                        
                        // Extract and limit response body if possible
                        let responseBody = null;
                        try {
                            // Only include response body for certain content types
                            const contentType = responseHeaders['content-type'] || '';
                            
                            if (contentType.includes('application/json') ||
                                contentType.includes('text/html') ||
                                contentType.includes('text/plain') ||
                                contentType.includes('text/xml') ||
                                contentType.includes('application/xml')) {
                                
                                responseBody = this.responseText.substring(0, 5000);
                                
                                // Add ellipsis if truncated
                                if (this.responseText.length > 5000) {
                                    responseBody += '...';
                                }
                            }
                        } catch (e) {
                            // Don't crash if we can't access response text
                        }
                        
                        // Send completion event
                        self.sendEvent('XHR_COMPLETE', {
                            method: this._csRequestInfo.method,
                            url: this._csRequestInfo.url,
                            status: this.status,
                            statusText: this.statusText,
                            duration: duration,
                            responseHeaders: responseHeaders,
                            responseBody: responseBody,
                            timestamp: Date.now()
                        });
                    });
                    
                    // Track errors
                    this.addEventListener('error', function() {
                        if (!this._csRequestInfo) {
                            return;
                        }
                        
                        self.sendEvent('XHR_ERROR', {
                            method: this._csRequestInfo.method,
                            url: this._csRequestInfo.url,
                            timestamp: Date.now()
                        });
                    });
                    
                    // Track aborts
                    this.addEventListener('abort', function() {
                        if (!this._csRequestInfo) {
                            return;
                        }
                        
                        self.sendEvent('XHR_ABORT', {
                            method: this._csRequestInfo.method,
                            url: this._csRequestInfo.url,
                            timestamp: Date.now()
                        });
                    });
                    
                    // Track timeouts
                    this.addEventListener('timeout', function() {
                        if (!this._csRequestInfo) {
                            return;
                        }
                        
                        self.sendEvent('XHR_TIMEOUT', {
                            method: this._csRequestInfo.method,
                            url: this._csRequestInfo.url,
                            timestamp: Date.now()
                        });
                    });
                }
                
                return originalSend.apply(this, arguments);
            };
            
            // Save original for cleanup
            this._originalXHR = {
                open: originalOpen,
                send: originalSend,
                setRequestHeader: originalSetRequestHeader
            };
        }
        
        /**
         * Patch fetch API to capture request/response data
         * @private
         */
        _patchFetch() {
            const originalFetch = window.fetch;
            const self = this;
            
            window.fetch = function(input, init) {
                const url = (typeof input === 'string') ? input : input.url;
                const method = (init && init.method) ? init.method : 
                               (input.method ? input.method : 'GET');
                
                // Gather request information
                const requestInfo = {
                    url: url,
                    method: method,
                    headers: (init && init.headers) ? init.headers : 
                             (input.headers ? input.headers : {}),
                    timestamp: Date.now(),
                    startTime: performance.now()
                };
                
                // Send request start event
                self.sendEvent('FETCH_START', {
                    method: requestInfo.method,
                    url: requestInfo.url,
                    headers: requestInfo.headers,
                    timestamp: Date.now()
                });
                
                // Start the fetch and track response
                return originalFetch.apply(this, arguments).then(response => {
                    // Calculate timing
                    const endTime = performance.now();
                    const duration = endTime - requestInfo.startTime;
                    
                    // Clone the response so we can process it without consuming it
                    const responseClone = response.clone();
                    
                    // Process response headers
                    const responseHeaders = {};
                    responseClone.headers.forEach((value, name) => {
                        responseHeaders[name] = value;
                    });
                    
                    // Extract content type
                    const contentType = responseClone.headers.get('content-type') || '';
                    
                    // Only process text-based responses
                    if (contentType.includes('application/json') ||
                        contentType.includes('text/html') ||
                        contentType.includes('text/plain') ||
                        contentType.includes('text/xml') ||
                        contentType.includes('application/xml')) {
                        
                        responseClone.text().then(text => {
                            // Limit response size
                            const responseBody = text.substring(0, 5000);
                            
                            // Send completion event with response body
                            self.sendEvent('FETCH_COMPLETE', {
                                method: requestInfo.method,
                                url: requestInfo.url,
                                status: responseClone.status,
                                statusText: responseClone.statusText,
                                duration: duration,
                                responseHeaders: responseHeaders,
                                responseBody: responseBody,
                                timestamp: Date.now()
                            });
                        }).catch(error => {
                            // Send completion event without response body
                            self.sendEvent('FETCH_COMPLETE', {
                                method: requestInfo.method,
                                url: requestInfo.url,
                                status: responseClone.status,
                                statusText: responseClone.statusText,
                                duration: duration,
                                responseHeaders: responseHeaders,
                                error: error.message,
                                timestamp: Date.now()
                            });
                        });
                    } else {
                        // Binary or non-text response, don't include body
                        self.sendEvent('FETCH_COMPLETE', {
                            method: requestInfo.method,
                            url: requestInfo.url,
                            status: responseClone.status,
                            statusText: responseClone.statusText,
                            duration: duration,
                            responseHeaders: responseHeaders,
                            contentType: contentType,
                            timestamp: Date.now()
                        });
                    }
                    
                    // Return the original response
                    return response;
                }).catch(error => {
                    // Calculate timing
                    const endTime = performance.now();
                    const duration = endTime - requestInfo.startTime;
                    
                    // Send error event
                    self.sendEvent('FETCH_ERROR', {
                        method: requestInfo.method,
                        url: requestInfo.url,
                        duration: duration,
                        error: error.message,
                        timestamp: Date.now()
                    });
                    
                    // Re-throw the error to let the original caller handle it
                    throw error;
                });
            };
            
            // Save original for cleanup
            this._originalFetch = originalFetch;
        }
        
        /**
         * Register command handlers for the recorder
         * @private
         */
        _registerCommands() {
            this.commandHandlers = {
                // Element interaction commands
                'highlightElement': (params) => this._commandHighlightElement(params),
                'getElementInfo': (params) => this._commandGetElementInfo(params),
                'findElements': (params) => this._commandFindElements(params),
                'scrollToElement': (params) => this._commandScrollToElement(params),
                'clickElement': (params) => this._commandClickElement(params),
                'setValue': (params) => this._commandSetValue(params),
                'getTextContent': (params) => this._commandGetTextContent(params),
                'getAttributes': (params) => this._commandGetAttributes(params),
                'hover': (params) => this._commandHover(params),
                
                // Document commands
                'getTitle': () => this._commandGetTitle(),
                'getUrl': () => this._commandGetUrl(),
                'takeScreenshot': (params) => this._commandTakeScreenshot(params),
                'executeScript': (params) => this._commandExecuteScript(params),
                
                // Navigation commands
                'navigate': (params) => this._commandNavigate(params),
                'refresh': () => this._commandRefresh(),
                'back': () => this._commandBack(),
                'forward': () => this._commandForward(),
                
                // Cookie and storage commands
                'getCookies': () => this._commandGetCookies(),
                'setCookie': (params) => this._commandSetCookie(params),
                'deleteCookie': (params) => this._commandDeleteCookie(params),
                'localStorage': (params) => this._commandLocalStorage(params),
                'sessionStorage': (params) => this._commandSessionStorage(params),
                
                // Recorder control
                'startRecording': () => this._commandStartRecording(),
                'stopRecording': () => this._commandStopRecording(),
                'pauseRecording': () => this._commandPauseRecording(),
                'resumeRecording': () => this._commandResumeRecording(),
                
                // System commands
                'getSystemInfo': () => this._commandGetSystemInfo(),
                'ping': () => this._commandPing()
            };
        }
        
        /**
         * Command handler for highlighting elements
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandHighlightElement(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                this.highlightElement(element, params.options);
                return true;
            } catch (error) {
                throw new Error(`Failed to highlight element: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting element info
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandGetElementInfo(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                return this._getElementInfo(element);
            } catch (error) {
                throw new Error(`Failed to get element info: ${error.message}`);
            }
        }
        
        /**
         * Command handler for finding elements
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandFindElements(params) {
            try {
                const elements = await this._findElements(params.locator);
                return elements.map(element => this._getElementInfo(element));
            } catch (error) {
                throw new Error(`Failed to find elements: ${error.message}`);
            }
        }
        
        /**
         * Command handler for scrolling to element
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandScrollToElement(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                const options = params.options || { behavior: 'smooth', block: 'center', inline: 'center' };
                element.scrollIntoView(options);
                
                return true;
            } catch (error) {
                throw new Error(`Failed to scroll to element: ${error.message}`);
            }
        }
        
        /**
         * Command handler for clicking element
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandClickElement(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                // Optional highlighting before click
                if (params.highlight) {
                    this.highlightElement(element, {
                        color: '#C54B8C',
                        duration: 500,
                        outlineWidth: '2px'
                    });
                    
                    // Wait a bit for highlighting to be visible
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Optional scrolling before click
                if (params.scroll) {
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                    
                    // Wait for scrolling to complete
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Simulate exact click coordinates if provided
                if (params.clientX !== undefined && params.clientY !== undefined) {
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window,
                        detail: 1,
                        screenX: params.screenX || 0,
                        screenY: params.screenY || 0,
                        clientX: params.clientX,
                        clientY: params.clientY,
                        ctrlKey: params.ctrlKey || false,
                        altKey: params.altKey || false,
                        shiftKey: params.shiftKey || false,
                        metaKey: params.metaKey || false,
                        button: params.button || 0,
                        relatedTarget: null
                    });
                    
                    element.dispatchEvent(clickEvent);
                } else {
                    // Simple click in center of element
                    if (params.useNativeEvents) {
                        // Calculate center of element
                        const rect = element.getBoundingClientRect();
                        const centerX = Math.floor(rect.left + rect.width / 2);
                        const centerY = Math.floor(rect.top + rect.height / 2);
                        
                        const clickEvent = new MouseEvent('click', {
                            bubbles: true,
                            cancelable: true,
                            view: window,
                            detail: 1,
                            screenX: centerX,
                            screenY: centerY,
                            clientX: centerX,
                            clientY: centerY,
                            ctrlKey: params.ctrlKey || false,
                            altKey: params.altKey || false,
                            shiftKey: params.shiftKey || false,
                            metaKey: params.metaKey || false,
                            button: params.button || 0,
                            relatedTarget: null
                        });
                        
                        element.dispatchEvent(clickEvent);
                    } else {
                        // Use the simple .click() method
                        element.click();
                    }
                }
                
                return true;
            } catch (error) {
                throw new Error(`Failed to click element: ${error.message}`);
            }
        }
        
        /**
         * Command handler for setting element value
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandSetValue(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                // Handle different input types
                if (element.tagName.toLowerCase() === 'input') {
                    const inputType = element.type.toLowerCase();
                    
                    if (inputType === 'checkbox' || inputType === 'radio') {
                        // For checkbox/radio, set the checked property
                        if (typeof params.value === 'boolean') {
                            element.checked = params.value;
                            
                            // Dispatch change event
                            const event = new Event('change', { bubbles: true });
                            element.dispatchEvent(event);
                            
                            return true;
                        } else {
                            throw new Error(`Invalid value for ${inputType}: ${params.value}`);
                        }
                    }
                }
                
                // For selects, handle differently
                if (element.tagName.toLowerCase() === 'select') {
                    // Set by index, value, or text
                    if (params.selectByIndex !== undefined) {
                        element.selectedIndex = params.selectByIndex;
                    } else if (params.selectByValue !== undefined) {
                        element.value = params.selectByValue;
                    } else if (params.selectByText !== undefined) {
                        const options = element.options;
                        for (let i = 0; i < options.length; i++) {
                            if (options[i].text === params.selectByText) {
                                element.selectedIndex = i;
                                break;
                            }
                        }
                    } else {
                        element.value = params.value;
                    }
                    
                    // Dispatch change event
                    const event = new Event('change', { bubbles: true });
                    element.dispatchEvent(event);
                    
                    return true;
                }
                
                // Clear the field first if requested
                if (params.clearFirst) {
                    element.value = '';
                    
                    // Fire input event to trigger any listeners
                    const inputEvent = new Event('input', { bubbles: true });
                    element.dispatchEvent(inputEvent);
                }
                
                // Type the value character by character
                if (params.typeCharByChar && typeof params.value === 'string') {
                    const delay = params.typeDelay || 50;
                    const value = params.value;
                    
                    // Focus the element
                    element.focus();
                    
                    // Type each character with a delay
                    for (let i = 0; i < value.length; i++) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        
                        // Append the character
                        const currentValue = element.value;
                        element.value = currentValue + value[i];
                        
                        // Fire input event for each character
                        const inputEvent = new Event('input', { bubbles: true });
                        element.dispatchEvent(inputEvent);
                    }
                } else {
                    // Set the value directly
                    element.value = params.value;
                }
                
                // Fire input event
                const inputEvent = new Event('input', { bubbles: true });
                element.dispatchEvent(inputEvent);
                
                // Fire change event
                const changeEvent = new Event('change', { bubbles: true });
                element.dispatchEvent(changeEvent);
                
                return true;
            } catch (error) {
                throw new Error(`Failed to set value: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting text content
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandGetTextContent(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                return {
                    textContent: element.textContent,
                    innerText: element.innerText,
                    value: element.value
                };
            } catch (error) {
                throw new Error(`Failed to get text content: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting element attributes
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandGetAttributes(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                return this._getElementAttributes(element);
            } catch (error) {
                throw new Error(`Failed to get attributes: ${error.message}`);
            }
        }
        
        /**
         * Command handler for hovering over element
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandHover(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                // Optional scrolling before hover
                if (params.scroll) {
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                    
                    // Wait for scrolling to complete
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Simulate hover
                const rect = element.getBoundingClientRect();
                const centerX = Math.floor(rect.left + rect.width / 2);
                const centerY = Math.floor(rect.top + rect.height / 2);
                
                // Create mouseenter and mouseover events
                const mouseEnterEvent = new MouseEvent('mouseenter', {
                    bubbles: false,
                    cancelable: true,
                    view: window,
                    detail: 0,
                    screenX: centerX,
                    screenY: centerY,
                    clientX: centerX,
                    clientY: centerY,
                    ctrlKey: params.ctrlKey || false,
                    altKey: params.altKey || false,
                    shiftKey: params.shiftKey || false,
                    metaKey: params.metaKey || false,
                    relatedTarget: null
                });
                
                const mouseOverEvent = new MouseEvent('mouseover', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    detail: 0,
                    screenX: centerX,
                    screenY: centerY,
                    clientX: centerX,
                    clientY: centerY,
                    ctrlKey: params.ctrlKey || false,
                    altKey: params.altKey || false,
                    shiftKey: params.shiftKey || false,
                    metaKey: params.metaKey || false,
                    relatedTarget: null
                });
                
                const mouseMoveEvent = new MouseEvent('mousemove', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    detail: 0,
                    screenX: centerX,
                    screenY: centerY,
                    clientX: centerX,
                    clientY: centerY,
                    ctrlKey: params.ctrlKey || false,
                    altKey: params.altKey || false,
                    shiftKey: params.shiftKey || false,
                    metaKey: params.metaKey || false,
                    relatedTarget: null
                });
                
                // Dispatch the events
                element.dispatchEvent(mouseEnterEvent);
                element.dispatchEvent(mouseOverEvent);
                element.dispatchEvent(mouseMoveEvent);
                
                // Optional highlight during hover
                if (params.highlight) {
                    this.highlightElement(element, {
                        color: '#C54B8C',
                        duration: params.highlightDuration || 2000,
                        outlineWidth: '2px'
                    });
                }
                
                return true;
            } catch (error) {
                throw new Error(`Failed to hover: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting document title
         * @private
         */
        _commandGetTitle() {
            return {
                title: document.title
            };
        }
        
        /**
         * Command handler for getting current URL
         * @private
         */
        _commandGetUrl() {
            return {
                url: window.location.href,
                origin: window.location.origin,
                pathname: window.location.pathname,
                search: window.location.search,
                hash: window.location.hash
            };
        }
        
        /**
         * Command handler for taking screenshot
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandTakeScreenshot(params) {
            try {
                // Validate if we're in extension mode or have a screenshot service
                if (!this.config.extensionMode || !chrome.tabs) {
                    throw new Error('Screenshot functionality requires extension mode');
                }
                
                // Extension mode - use chrome.tabs.captureVisibleTab
                return new Promise((resolve, reject) => {
                    chrome.tabs.captureVisibleTab(null, { format: 'png' }, (dataUrl) => {
                        if (chrome.runtime.lastError) {
                            reject(new Error(chrome.runtime.lastError.message));
                            return;
                        }
                        
                        // Optional element-only screenshot
                        if (params.element) {
                            this._cropScreenshotToElement(dataUrl, params.element)
                                .then(resolve)
                                .catch(reject);
                        } else {
                            resolve({ dataUrl: dataUrl });
                        }
                    });
                });
            } catch (error) {
                throw new Error(`Failed to take screenshot: ${error.message}`);
            }
        }
        
        /**
         * Crop screenshot to element
         * @private
         * @param {string} dataUrl - Base64 data URL of full screenshot
         * @param {Object} elementLocator - Locator for element to crop to
         * @returns {Promise<Object>} Cropped screenshot data
         */
        async _cropScreenshotToElement(dataUrl, elementLocator) {
            try {
                const element = await this._findElement(elementLocator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(elementLocator)}`);
                }
                
                // Get element position and size
                const rect = element.getBoundingClientRect();
                
                // Create an image element to draw on canvas
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = function() {
                        // Create canvas
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        
                        // Set canvas size to element size
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                        
                        // Draw the cropped region
                        context.drawImage(
                            img,
                            rect.left, rect.top, rect.width, rect.height, // Source rectangle
                            0, 0, rect.width, rect.height // Destination rectangle
                        );
                        
                        // Convert canvas to data URL
                        const croppedDataUrl = canvas.toDataURL('image/png');
                        
                        resolve({ 
                            dataUrl: croppedDataUrl,
                            elementInfo: {
                                x: rect.left,
                                y: rect.top,
                                width: rect.width,
                                height: rect.height
                            }
                        });
                    };
                    
                    img.onerror = function() {
                        reject(new Error('Failed to load screenshot image'));
                    };
                    
                    img.src = dataUrl;
                });
            } catch (error) {
                throw new Error(`Failed to crop screenshot: ${error.message}`);
            }
        }
        
        /**
         * Command handler for executing script
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandExecuteScript(params) {
            try {
                const script = params.script;
                const args = params.args || [];
                
                // Execute the script in the page context
                const result = await this.injectScript(`
                    (function() {
                        try {
                            const args = ${JSON.stringify(args)};
                            return (${script}).apply(null, args);
                        } catch (e) {
                            throw new Error('Script execution error: ' + e.message);
                        }
                    })();
                `);
                
                return { result };
            } catch (error) {
                throw new Error(`Failed to execute script: ${error.message}`);
            }
        }
        
        /**
         * Command handler for navigating to URL
         * @private
         * @param {Object} params - Command parameters
         */
        _commandNavigate(params) {
            try {
                // Validate URL
                if (!params.url) {
                    throw new Error('URL is required');
                }
                
                // Navigate to URL
                window.location.href = params.url;
                
                return true;
            } catch (error) {
                throw new Error(`Failed to navigate: ${error.message}`);
            }
        }
        
        /**
         * Command handler for refreshing page
         * @private
         */
        _commandRefresh() {
            try {
                window.location.reload();
                return true;
            } catch (error) {
                throw new Error(`Failed to refresh: ${error.message}`);
            }
        }
        
        /**
         * Command handler for navigating back
         * @private
         */
        _commandBack() {
            try {
                window.history.back();
                return true;
            } catch (error) {
                throw new Error(`Failed to navigate back: ${error.message}`);
            }
        }
        
        /**
         * Command handler for navigating forward
         * @private
         */
        _commandForward() {
            try {
                window.history.forward();
                return true;
            } catch (error) {
                throw new Error(`Failed to navigate forward: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting cookies
         * @private
         */
        _commandGetCookies() {
            try {
                const cookies = document.cookie.split(';')
                    .map(cookie => cookie.trim())
                    .filter(cookie => cookie.length > 0)
                    .map(cookie => {
                        const [name, ...valueParts] = cookie.split('=');
                        const value = valueParts.join('=');
                        
                        return {
                            name: name.trim(),
                            value: value
                        };
                    });
                
                return { cookies };
            } catch (error) {
                throw new Error(`Failed to get cookies: ${error.message}`);
            }
        }
        
        /**
         * Command handler for setting cookie
         * @private
         * @param {Object} params - Command parameters
         */
        _commandSetCookie(params) {
            try {
                if (!params.name || !params.value) {
                    throw new Error('Cookie name and value are required');
                }
                
                let cookieString = `${params.name}=${params.value}`;
                
                if (params.domain) {
                    cookieString += `; domain=${params.domain}`;
                }
                
                if (params.path) {
                    cookieString += `; path=${params.path}`;
                }
                
                if (params.expires) {
                    if (params.expires instanceof Date) {
                        cookieString += `; expires=${params.expires.toUTCString()}`;
                    } else if (typeof params.expires === 'number') {
                        const date = new Date();
                        date.setTime(date.getTime() + params.expires * 1000);
                        cookieString += `; expires=${date.toUTCString()}`;
                    } else {
                        cookieString += `; expires=${params.expires}`;
                    }
                }
                
                if (params.maxAge) {
                    cookieString += `; max-age=${params.maxAge}`;
                }
                
                if (params.secure) {
                    cookieString += '; secure';
                }
                
                if (params.httpOnly) {
                    cookieString += '; httpOnly';
                }
                
                if (params.sameSite) {
                    cookieString += `; samesite=${params.sameSite}`;
                }
                
                document.cookie = cookieString;
                
                return true;
            } catch (error) {
                throw new Error(`Failed to set cookie: ${error.message}`);
            }
        }
        
        /**
         * Command handler for deleting cookie
         * @private
         * @param {Object} params - Command parameters
         */
        _commandDeleteCookie(params) {
            try {
                if (!params.name) {
                    throw new Error('Cookie name is required');
                }
                
                // Set expiration to past date to delete
                let cookieString = `${params.name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC`;
                
                if (params.path) {
                    cookieString += `; path=${params.path}`;
                } else {
                    cookieString += '; path=/';
                }
                
                if (params.domain) {
                    cookieString += `; domain=${params.domain}`;
                }
                
                document.cookie = cookieString;
                
                return true;
            } catch (error) {
                throw new Error(`Failed to delete cookie: ${error.message}`);
            }
        }
        
        /**
         * Command handler for localStorage operations
         * @private
         * @param {Object} params - Command parameters
         */
        _commandLocalStorage(params) {
            try {
                const action = params.action || 'getAll';
                
                switch (action) {
                    case 'get':
                        if (!params.key) {
                            throw new Error('Key is required for get action');
                        }
                        return { value: localStorage.getItem(params.key) };
                        
                    case 'set':
                        if (!params.key || params.value === undefined) {
                            throw new Error('Key and value are required for set action');
                        }
                        localStorage.setItem(params.key, params.value);
                        return true;
                        
                    case 'remove':
                        if (!params.key) {
                            throw new Error('Key is required for remove action');
                        }
                        localStorage.removeItem(params.key);
                        return true;
                        
                    case 'clear':
                        localStorage.clear();
                        return true;
                        
                    case 'getAll':
                        const items = {};
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            items[key] = localStorage.getItem(key);
                        }
                        return { items };
                        
                    default:
                        throw new Error(`Unknown localStorage action: ${action}`);
                }
            } catch (error) {
                throw new Error(`Failed to perform localStorage action: ${error.message}`);
            }
        }
        
        /**
         * Command handler for sessionStorage operations
         * @private
         * @param {Object} params - Command parameters
         */
        _commandSessionStorage(params) {
            try {
                const action = params.action || 'getAll';
                
                switch (action) {
                    case 'get':
                        if (!params.key) {
                            throw new Error('Key is required for get action');
                        }
                        return { value: sessionStorage.getItem(params.key) };
                        
                    case 'set':
                        if (!params.key || params.value === undefined) {
                            throw new Error('Key and value are required for set action');
                        }
                        sessionStorage.setItem(params.key, params.value);
                        return true;
                        
                    case 'remove':
                        if (!params.key) {
                            throw new Error('Key is required for remove action');
                        }
                        sessionStorage.removeItem(params.key);
                        return true;
                        
                    case 'clear':
                        sessionStorage.clear();
                        return true;
                        
                    case 'getAll':
                        const items = {};
                        for (let i = 0; i < sessionStorage.length; i++) {
                            const key = sessionStorage.key(i);
                            items[key] = sessionStorage.getItem(key);
                        }
                        return { items };
                        
                    default:
                        throw new Error(`Unknown sessionStorage action: ${action}`);
                }
            } catch (error) {
                throw new Error(`Failed to perform sessionStorage action: ${error.message}`);
            }
        }
        
        /**
         * Command handler for starting recording
         * @private
         */
        _commandStartRecording() {
            try {
                if (this.eventCapture) {
                    this.eventCapture.start();
                }
                
                return { status: 'recording' };
            } catch (error) {
                throw new Error(`Failed to start recording: ${error.message}`);
            }
        }
        
        /**
         * Command handler for stopping recording
         * @private
         */
        _commandStopRecording() {
            try {
                if (this.eventCapture) {
                    this.eventCapture.stop();
                }
                
                return { status: 'stopped' };
            } catch (error) {
                throw new Error(`Failed to stop recording: ${error.message}`);
            }
        }
        
        /**
         * Command handler for pausing recording
         * @private
         */
        _commandPauseRecording() {
            try {
                if (this.eventCapture) {
                    this.eventCapture.pause();
                }
                
                return { status: 'paused' };
            } catch (error) {
                throw new Error(`Failed to pause recording: ${error.message}`);
            }
        }
        
        /**
         * Command handler for resuming recording
         * @private
         */
        _commandResumeRecording() {
            try {
                if (this.eventCapture) {
                    this.eventCapture.resume();
                }
                
                return { status: 'recording' };
            } catch (error) {
                throw new Error(`Failed to resume recording: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting system info
         * @private
         */
        _commandGetSystemInfo() {
            return {
                browserDetails: this.browserDetails,
                features: this.features,
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                languages: navigator.languages,
                userAgent: navigator.userAgent,
                vendor: navigator.vendor,
                platform: navigator.platform,
                memory: performance.memory ? {
                    totalJSHeapSize: performance.memory.totalJSHeapSize,
                    usedJSHeapSize: performance.memory.usedJSHeapSize,
                    jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
                } : null,
                screenSize: {
                    width: window.screen.width,
                    height: window.screen.height,
                    availWidth: window.screen.availWidth,
                    availHeight: window.screen.availHeight,
                    colorDepth: window.screen.colorDepth,
                    pixelDepth: window.screen.pixelDepth
                },
                windowSize: {
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight,
                    outerWidth: window.outerWidth,
                    outerHeight: window.outerHeight
                },
                devicePixelRatio: window.devicePixelRatio,
                timestamp: Date.now()
            };
        }
        
        /**
         * Command handler for ping
         * @private
         */
        _commandPing() {
            return {
                timestamp: Date.now(),
                status: 'ok'
            };
        }
        
        /**
         * Get element info from an element
         * @private
         * @param {Element} element - DOM element
         * @returns {Object} Element information
         */
        _getElementInfo(element) {
            if (!element) {
                return null;
            }
            
            try {
                // Get element rectangle
                const rect = element.getBoundingClientRect();
                
                // Get text content (limited to 1000 chars)
                const textContent = element.textContent ? 
                    element.textContent.substring(0, 1000) : '';
                
                // Get value for form elements
                let value = null;
                if (element.tagName.toLowerCase() === 'input' || 
                    element.tagName.toLowerCase() === 'textarea' || 
                    element.tagName.toLowerCase() === 'select') {
                    
                    if (element.type === 'password') {
                        // Mask password values
                        value = '********';
                    } else if (element.type === 'checkbox' || element.type === 'radio') {
                        value = element.checked;
                    } else {
                        value = element.value;
                    }
                }
                
                // Get XPath
                const xpath = this._getElementXPath(element);
                
                // Get CSS selector
                const cssSelector = this._getElementCssSelector(element);
                
                // Get element attributes
                const attributes = this._getElementAttributes(element);
                
                // Get computed style properties
                const computedStyle = window.getComputedStyle(element);
                const styles = {
                    color: computedStyle.color,
                    backgroundColor: computedStyle.backgroundColor,
                    fontSize: computedStyle.fontSize,
                    fontWeight: computedStyle.fontWeight,
                    display: computedStyle.display,
                    visibility: computedStyle.visibility,
                    position: computedStyle.position,
                    zIndex: computedStyle.zIndex,
                    opacity: computedStyle.opacity
                };
                
                // Element state
                const state = {
                    isVisible: this._isElementVisible(element),
                    isEnabled: !element.disabled,
                    isChecked: element.checked || false
                };
                
                return {
                    tagName: element.tagName,
                    id: element.id,
                    name: element.getAttribute('name'),
                    className: element.className,
                    type: element.getAttribute('type'),
                    value: value,
                    textContent: textContent,
                    attributes: attributes,
                    styles: styles,
                    state: state,
                    rect: {
                        left: rect.left,
                        top: rect.top,
                        right: rect.right,
                        bottom: rect.bottom,
                        width: rect.width,
                        height: rect.height,
                        x: rect.x,
                        y: rect.y
                    },
                    xpath: xpath,
                    cssSelector: cssSelector
                };
            } catch (error) {
                this._error('Error getting element info', error);
                
                // Return basic info on error
                return {
                    tagName: element.tagName,
                    id: element.id,
                    className: element.className,
                    error: error.message
                };
            }
        }
        
        /**
         * Get element attributes
         * @private
         * @param {Element} element - DOM element
         * @returns {Object} Element attributes
         */
        _getElementAttributes(element) {
            const attributes = {};
            
            if (!element || !element.attributes) {
                return attributes;
            }
            
            for (let i = 0; i < element.attributes.length; i++) {
                const attr = element.attributes[i];
                attributes[attr.name] = attr.value;
            }
            
            return attributes;
        }
        
        /**
         * Get XPath for element
         * @private
         * @param {Element} element - DOM element
         * @returns {string} XPath
         */
        _getElementXPath(element) {
            if (!element) {
                return '';
            }
            
            if (element === document.body) {
                return '/html/body';
            }
            
            // Check if element has an ID
            if (element.id) {
                // Use ID-based XPath for elements with unique IDs
                return `//*[@id="${element.id}"]`;
            }
            
            // For other elements, generate full path
            const paths = [];
            
            // Use helper function to generate paths
            while (element && element.nodeType === Node.ELEMENT_NODE) {
                let index = 0;
                let hasFollowingSiblingsWithSameTag = false;
                
                // Count previous siblings with same tag name
                let sibling = element.previousSibling;
                while (sibling) {
                    if (sibling.nodeType === Node.ELEMENT_NODE && 
                        sibling.tagName === element.tagName) {
                        index++;
                    }
                    sibling = sibling.previousSibling;
                }
                
                // Check if there are any following siblings with same tag
                sibling = element.nextSibling;
                while (sibling && !hasFollowingSiblingsWithSameTag) {
                    if (sibling.nodeType === Node.ELEMENT_NODE && 
                        sibling.tagName === element.tagName) {
                        hasFollowingSiblingsWithSameTag = true;
                    }
                    sibling = sibling.nextSibling;
                }
                
                // Generate path for current element
                const tagName = element.tagName.toLowerCase();
                const pathIndex = (index || hasFollowingSiblingsWithSameTag) ? 
                    `[${index + 1}]` : '';
                    
                paths.unshift(tagName + pathIndex);
                
                // Move up to parent
                element = element.parentNode;
            }
            
            return '/' + paths.join('/');
        }
        
        /**
         * Get CSS selector for element
         * @private
         * @param {Element} element - DOM element
         * @returns {string} CSS selector
         */
        _getElementCssSelector(element) {
            if (!element) {
                return '';
            }
            
            if (element === document.body) {
                return 'body';
            }
            
            // Try to create a unique selector with ID
            if (element.id) {
                return `#${CSS.escape(element.id)}`;
            }
            
            // Try with classes
            if (element.className) {
                const classSelector = '.' + Array.from(element.classList)
                    .map(c => CSS.escape(c))
                    .join('.');
                
                // Check if this uniquely identifies the element
                if (document.querySelectorAll(classSelector).length === 1) {
                    return classSelector;
                }
            }
            
            // Generate more complex selector
            let selector = element.tagName.toLowerCase();
            
            // Add useful attributes
            if (element.getAttribute('name')) {
                selector += `[name="${CSS.escape(element.getAttribute('name'))}"]`;
            }
            
            if (element.getAttribute('type')) {
                selector += `[type="${CSS.escape(element.getAttribute('type'))}"]`;
            }
            
            if (element.getAttribute('role')) {
                selector += `[role="${CSS.escape(element.getAttribute('role'))}"]`;
            }
            
            // If more specificity needed, add nth-child
            const parent = element.parentNode;
            if (parent && parent.children.length > 1) {
                let nthChild = 1;
                for (let i = 0; i < parent.children.length; i++) {
                    if (parent.children[i] === element) {
                        break;
                    }
                    if (parent.children[i].tagName === element.tagName) {
                        nthChild++;
                    }
                }
                
                if (nthChild > 1 || parent.querySelectorAll(selector).length > 1) {
                    selector += `:nth-of-type(${nthChild})`;
                }
            }
            
            // If element still not uniquely identified, add parent context
            if (document.querySelectorAll(selector).length > 1 && element.parentElement) {
                const parentSelector = this._getElementCssSelector(element.parentElement);
                if (parentSelector) {
                    selector = `${parentSelector} > ${selector}`;
                }
            }
            
            return selector;
        }
        
        /**
         * Check if element is visible
         * @private
         * @param {Element} element - DOM element
         * @returns {boolean} True if element is visible
         */
        _isElementVisible(element) {
            if (!element) {
                return false;
            }
            
            // Check if element is in DOM
            if (!document.body.contains(element)) {
                return false;
            }
            
            const style = window.getComputedStyle(element);
            
            // Check basic display/visibility properties
            if (style.display === 'none' || 
                style.visibility === 'hidden' || 
                style.opacity === '0') {
                return false;
            }
            
            // Check element dimensions
            const rect = element.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                return false;
            }
            
            // Check if element is in viewport
            if (rect.right < 0 || 
                rect.bottom < 0 || 
                rect.left > window.innerWidth || 
                rect.top > window.innerHeight) {
                return false;
            }
            
            // Check if covered by another element
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Get element at point, considering potential shadow DOM
            let elementAtPoint = document.elementFromPoint(centerX, centerY);
            while (elementAtPoint && elementAtPoint.shadowRoot) {
                const pointInShadow = elementAtPoint.shadowRoot.elementFromPoint(centerX, centerY);
                if (!pointInShadow || pointInShadow === elementAtPoint) {
                    break;
                }
                elementAtPoint = pointInShadow;
            }
            
            // Check if element or any of its descendants is at the center point
            if (elementAtPoint) {
                return element === elementAtPoint || element.contains(elementAtPoint) || 
                       elementAtPoint.contains(element);
            }
            
            return false;
        }
        
        /**
         * Find an element by various locator types
         * @private
         * @param {Object} locator - Element locator
         * @returns {Promise<Element>} Found element or null
         */
        async _findElement(locator) {
            if (!locator) {
                throw new Error('Locator is required');
            }
            
            // Support different locator types
            if (locator.id) {
                return document.getElementById(locator.id);
            }
            
            if (locator.css) {
                return document.querySelector(locator.css);
            }
            
            if (locator.xpath) {
                return this._findElementByXPath(locator.xpath);
            }
            
            if (locator.name) {
                return document.querySelector(`[name="${CSS.escape(locator.name)}"]`);
            }
            
            if (locator.linkText) {
                const links = Array.from(document.querySelectorAll('a'));
                return links.find(link => link.textContent.trim() === locator.linkText);
            }
            
            if (locator.partialLinkText) {
                const links = Array.from(document.querySelectorAll('a'));
                return links.find(link => link.textContent.includes(locator.partialLinkText));
            }
            
            if (locator.tagName) {
                return document.querySelector(locator.tagName);
            }
            
            if (locator.className) {
                return document.querySelector(`.${CSS.escape(locator.className)}`);
            }
            
            if (locator.text) {
                return this._findElementByText(locator.text, locator.exact !== false);
            }
            
            if (locator.attributes) {
                let selector = '*';
                for (const [attr, value] of Object.entries(locator.attributes)) {
                    selector += `[${attr}="${CSS.escape(value)}"]`;
                }
                return document.querySelector(selector);
            }
            
            if (locator.js) {
                // Execute JavaScript to find element
                return await this.injectScript(`
                    (function() {
                        return ${locator.js};
                    })();
                `);
            }
            
            throw new Error(`Unsupported locator: ${JSON.stringify(locator)}`);
        }
        
        /**
         * Find elements by various locator types
         * @private
         * @param {Object} locator - Element locator
         * @returns {Promise<Element[]>} Found elements
         */
        async _findElements(locator) {
            if (!locator) {
                throw new Error('Locator is required');
            }
            
            // Support different locator types
            if (locator.id) {
                const element = document.getElementById(locator.id);
                return element ? [element] : [];
            }
            
            if (locator.css) {
                return Array.from(document.querySelectorAll(locator.css));
            }
            
            if (locator.xpath) {
                return this._findElementsByXPath(locator.xpath);
            }
            
            if (locator.name) {
                return Array.from(document.querySelectorAll(`[name="${CSS.escape(locator.name)}"]`));
            }
            
            if (locator.linkText) {
                const links = Array.from(document.querySelectorAll('a'));
                return links.filter(link => link.textContent.trim() === locator.linkText);
            }
            
            if (locator.partialLinkText) {
                const links = Array.from(document.querySelectorAll('a'));
                return links.filter(link => link.textContent.includes(locator.partialLinkText));
            }
            
            if (locator.tagName) {
                return Array.from(document.querySelectorAll(locator.tagName));
            }
            
            if (locator.className) {
                return Array.from(document.querySelectorAll(`.${CSS.escape(locator.className)}`));
            }
            
            if (locator.text) {
                return this._findElementsByText(locator.text, locator.exact !== false);
            }
            
            if (locator.attributes) {
                let selector = '*';
                for (const [attr, value] of Object.entries(locator.attributes)) {
                    selector += `[${attr}="${CSS.escape(value)}"]`;
                }
                return Array.from(document.querySelectorAll(selector));
            }
            
            if (locator.js) {
                // Execute JavaScript to find elements
                const result = await this.injectScript(`
                    (function() {
                        const result = ${locator.js};
                        if (result instanceof Element) {
                            return [result];
                        } else if (Array.isArray(result)) {
                            return result.filter(item => item instanceof Element);
                        } else if (result instanceof NodeList || result instanceof HTMLCollection) {
                            return Array.from(result);
                        }
                        return [];
                    })();
                `);
                
                return result || [];
            }
            
            throw new Error(`Unsupported locator: ${JSON.stringify(locator)}`);
        }
        
        /**
         * Find element by XPath
         * @private
         * @param {string} xpath - XPath expression
         * @returns {Element} Found element or null
         */
        _findElementByXPath(xpath) {
            try {
                const result = document.evaluate(
                    xpath,
                    document,
                    null,
                    XPathResult.FIRST_ORDERED_NODE_TYPE,
                    null
                );
                
                return result.singleNodeValue;
            } catch (error) {
                this._error(`Invalid XPath: ${xpath}`, error);
                return null;
            }
        }
        
        /**
         * Find elements by XPath
         * @private
         * @param {string} xpath - XPath expression
         * @returns {Element[]} Found elements
         */
        _findElementsByXPath(xpath) {
            try {
                const result = document.evaluate(
                    xpath,
                    document,
                    null,
                    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
                    null
                );
                
                const elements = [];
                for (let i = 0; i < result.snapshotLength; i++) {
                    elements.push(result.snapshotItem(i));
                }
                
                return elements;
            } catch (error) {
                this._error(`Invalid XPath: ${xpath}`, error);
                return [];
            }
        }
        
        /**
         * Find element by text content
         * @private
         * @param {string} text - Text to search for
         * @param {boolean} exact - Whether to match exact text
         * @returns {Element} Found element or null
         */
        _findElementByText(text, exact = true) {
            // Create a text filter function
            const matchesText = exact ?
                (element) => element.textContent.trim() === text :
                (element) => element.textContent.includes(text);
            
            // Get all text nodes
            const walker = document.createTreeWalker(
                document.body,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        return matchesText({ textContent: node.nodeValue }) ?
                            NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                    }
                }
            );
            
            // Find first matching text node
            const textNode = walker.nextNode();
            if (textNode) {
                // Return the element containing this text
                return textNode.parentElement;
            }
            
            // Alternative approach - check elements directly
            const elements = document.querySelectorAll('*');
            for (const element of elements) {
                if (matchesText(element)) {
                    return element;
                }
            }
            
            return null;
        }
        
        /**
         * Find elements by text content
         * @private
         * @param {string} text - Text to search for
         * @param {boolean} exact - Whether to match exact text
         * @returns {Element[]} Found elements
         */
        _findElementsByText(text, exact = true) {
            const results = [];
            
            // Create a text filter function
            const matchesText = exact ?
                (element) => element.textContent.trim() === text :
                (element) => element.textContent.includes(text);
            
            // Check all elements
            const elements = document.querySelectorAll('*');
            for (const element of elements) {
                if (matchesText(element)) {
                    results.push(element);
                }
            }
            
            return results;
        }
        
        /**
         * Add event listener with cleanup registration
         * @private
         * @param {EventTarget} target - Event target
         * @param {string} type - Event type
         * @param {Function} listener - Event listener
         * @param {boolean|Object} options - Event listener options
         */
        _addEventListenerWithCleanup(target, type, listener, options) {
            target.addEventListener(type, listener, options);
            
            // Register for cleanup
            this.listeners = this.listeners || {};
            this.listeners[type] = this.listeners[type] || [];
            this.listeners[type].push({ target, listener });
        }
        
        /**
         * Remove all registered event listeners
         * @private
         */
        _removeAllEventListeners() {
            if (!this.listeners) return;
            
            for (const type in this.listeners) {
                for (const { target, listener } of this.listeners[type]) {
                    target.removeEventListener(type, listener);
                }
            }
            
            this.listeners = {};
        }
        
        /**
         * Disconnect all observers
         * @private
         */
        _disconnectAllObservers() {
            if (!this.observers) return;
            
            for (const key in this.observers) {
                if (this.observers[key] && typeof this.observers[key].disconnect === 'function') {
                    this.observers[key].disconnect();
                }
            }
            
            this.observers = {};
        }
        
        /**
         * Remove injected elements
         * @private
         */
        _removeInjectedElements() {
            // Remove all elements with data-cs-test-forge attribute
            const elements = document.querySelectorAll('[data-cs-test-forge]');
            for (const element of elements) {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            }
        }
        
        /**
         * Restore original console functions
         * @private
         */
        _restoreConsole() {
            if (this._originalConsole) {
                for (const method in this._originalConsole) {
                    console[method] = this._originalConsole[method];
                }
                this._originalConsole = null;
            }
            
            // Restore XHR and fetch if patched
            if (this._originalXHR) {
                XMLHttpRequest.prototype.open = this._originalXHR.open;
                XMLHttpRequest.prototype.send = this._originalXHR.send;
                XMLHttpRequest.prototype.setRequestHeader = this._originalXHR.setRequestHeader;
                this._originalXHR = null;
            }
            
            if (this._originalFetch) {
                window.fetch = this._originalFetch;
                this._originalFetch = null;
            }
        }
        
        /**
         * Close communication channel
         * @private
         */
        _closeCommunication() {
            if (this.port) {
                try {
                    this.port.disconnect();
                } catch (e) {
                    // Ignore errors during disconnect
                }
                this.port = null;
            }
            
            // Clear any pending timeouts
            if (this._networkCaptureInterval) {
                clearInterval(this._networkCaptureInterval);
                this._networkCaptureInterval = null;
            }
            
            if (this._domMutationTimeout) {
                clearTimeout(this._domMutationTimeout);
                this._domMutationTimeout = null;
            }
        }
        
        /**
         * Check if element is from CSTestForge
         * @private
         * @param {Element} element - Element to check
         * @returns {boolean} Whether element is from CSTestForge
         */
        _isFromCsTestForge(element) {
            if (!element || element.nodeType !== Node.ELEMENT_NODE) {
                return false;
            }
            
            // Check for our data attribute
            if (element.hasAttribute('data-cs-test-forge')) {
                return true;
            }
            
            // Check for our namespace
            if (element.id && element.id.startsWith('cs-test-forge-')) {
                return true;
            }
            
            // Check for our class
            if (element.className && typeof element.className === 'string' && 
                element.className.includes('cs-test-forge-')) {
                return true;
            }
            
            return false;
        }
        
        /**
         * Get resource URL for injector resources
         * @private
         * @param {string} resource - Resource name
         * @returns {string} Resource URL
         */
        _getResourceUrl(resource) {
            if (this.config.extensionMode && this.features.supportsExtensionAPI) {
                // Chrome extension mode
                return chrome.runtime.getURL(resource);
            } else {
                // Standalone mode
                const baseUrl = this.config.resourceBaseUrl || '';
                return `${baseUrl}/${resource}`;
            }
        }
        
        /**
         * Log message (only in debug mode)
         * @private
         * @param {string} message - Message to log
         * @param {*} data - Optional data to log
         */
        _log(message, data) {
            if (!this.config.debugMode) return;
            
            if (data !== undefined) {
                console.log(`[CSTestForge:Chrome] ${message}`, data);
            } else {
                console.log(`[CSTestForge:Chrome] ${message}`);
            }
        }
        
        /**
         * Log warning
         * @private
         * @param {string} message - Warning message
         * @param {*} data - Optional data
         */
        _warn(message, data) {
            if (data !== undefined) {
                console.warn(`[CSTestForge:Chrome] ${message}`, data);
            } else {
                console.warn(`[CSTestForge:Chrome] ${message}`);
            }
        }
        
        /**
         * Log error
         * @private
         * @param {string} message - Error message
         * @param {Error} error - Error object
         */
        _error(message, error) {
            console.error(`[CSTestForge:Chrome] ${message}`, error);
        }
    }
    
    // Make available globally
    window.CSTestForge = window.CSTestForge || {};
    window.CSTestForge.ChromeInjector = ChromeInjector;
    
    // Auto-initialize if configured
    if (window.CSTestForge.autoInitialize) {
        const injector = new ChromeInjector(window.CSTestForge.config);
        injector.initialize().then(() => {
            window.CSTestForge.injector = injector;
        });
    }
})();


recorder/chrome/manifest.json
---------------------------------------------

{
  "manifest_version": 3,
  "name": "CSTestForge Recorder",
  "description": "Advanced test automation recorder for Selenium and Playwright",
  "version": "1.0.0",
  "action": {
    "default_title": "CSTestForge Recorder",
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "32": "icons/icon32.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "icons": {
    "16": "icons/icon16.png",
    "32": "icons/icon32.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "permissions": [
    "activeTab",
    "tabs",
    "scripting",
    "storage",
    "downloads",
    "cookies",
    "webNavigation",
    "webRequest"
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "background": {
    "service_worker": "background.js",
    "type": "module"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content-script.js"],
      "run_at": "document_start"
    }
  ],
  "devtools_page": "devtools.html",
  "web_accessible_resources": [
    {
      "resources": [
        "injected/*",
        "polyfills.js",
        "event-capture.js",
        "dom-observer.js",
        "element-identifier.js",
        "network-monitor.js",
        "timing-collector.js",
        "feature-detector.js",
        "version-detector.js",
        "base-injector.js",
        "chrome-injector.js"
      ],
      "matches": ["<all_urls>"]
    }
  ],
  "commands": {
    "toggle-recording": {
      "suggested_key": {
        "default": "Ctrl+Shift+R",
        "mac": "Command+Shift+R"
      },
      "description": "Toggle recording"
    },
    "take-screenshot": {
      "suggested_key": {
        "default": "Ctrl+Shift+S",
        "mac": "Command+Shift+S"
      },
      "description": "Take screenshot"
    }
  },
  "options_page": "options.html",
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'"
  }
}


recorder/chrome/background.js
---------------------------------------------------

/**
 * CSTestForge Chrome Extension Background Script
 * 
 * This background script manages the state of the recorder and coordinates
 * communication between the UI, content scripts, and injected recorder scripts.
 * It handles browser events, manages sessions, and processes recording data.
 * 
 * @module background
 * @copyright CSTestForge 2025
 */

// Global state for the recorder
const state = {
    recording: false,
    paused: false,
    recordingTabId: null,
    recordingWindowId: null,
    recordingFrameId: 0,
    recordingSessionId: null,
    recordingStartTime: null,
    recordingEvents: [],
    recordingSettings: {
        framework: 'selenium', // selenium, playwright
        language: 'java',      // java, typescript
        testType: 'testng',    // testng, bdd
        captureScreenshots: true,
        captureConsoleOutput: true,
        captureNetwork: true,
        elementsThreshold: 5,  // Max elements to suggest for each action
        smartLocators: true,   // Use AI for locator generation
        selfHealing: true,     // Use self-healing locators
        useJSAttributes: true, // Use JS for fetching attributes
        debuggingEnabled: false
    },
    connectedPorts: new Map(),
    browserInfo: null,
    elementRegistry: new Map()
};

// Extension constants
const EXTENSION_PREFIX = 'cstestforge';
const RECORDER_SCRIPTS = [
    'polyfills.js',
    'event-capture.js',
    'dom-observer.js',
    'element-identifier.js',
    'network-monitor.js',
    'timing-collector.js',
    'feature-detector.js',
    'version-detector.js',
    'base-injector.js',
    'chrome-injector.js'
];

// Message handler for extension messaging
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    // Process messages from popup, content scripts, or devtools
    try {
        if (!message || !message.action) {
            console.error('Invalid message received:', message);
            return false;
        }
        
        console.debug(`[Background] Received message: ${message.action}`, message);
        
        switch (message.action) {
            case 'GET_STATE':
                handleGetState(sendResponse);
                return true; // Keep the messaging channel open
                
            case 'START_RECORDING':
                handleStartRecording(message.options, sendResponse);
                return true;
                
            case 'STOP_RECORDING':
                handleStopRecording(sendResponse);
                return true;
                
            case 'PAUSE_RECORDING':
                handlePauseRecording(sendResponse);
                return true;
                
            case 'RESUME_RECORDING':
                handleResumeRecording(sendResponse);
                return true;
                
            case 'CLEAR_RECORDING':
                handleClearRecording(sendResponse);
                return true;
                
            case 'GET_RECORDING_DATA':
                handleGetRecordingData(sendResponse);
                return true;
                
            case 'GENERATE_CODE':
                handleGenerateCode(message.options, sendResponse);
                return true;
                
            case 'EXPORT_RECORDING':
                handleExportRecording(message.options, sendResponse);
                return true;
                
            case 'UPDATE_SETTINGS':
                handleUpdateSettings(message.settings, sendResponse);
                return true;
                
            case 'GET_SETTINGS':
                handleGetSettings(sendResponse);
                return true;
                
            case 'INJECT_SCRIPTS':
                handleInjectScripts(message.tabId, sendResponse);
                return true;
                
            case 'RUN_COMMAND':
                handleRunCommand(message.command, message.params, sender.tab?.id, sendResponse);
                return true;
                
            case 'RECORD_EVENT':
                handleRecordEvent(message.event, sender.tab?.id, sendResponse);
                return true;
                
            case 'TAKE_SCREENSHOT':
                handleTakeScreenshot(message.options, sender.tab?.id, sendResponse);
                return true;
                
            case 'HIGHLIGHT_ELEMENT':
                handleHighlightElement(message.locator, sender.tab?.id, sendResponse);
                return true;
                
            case 'GET_ELEMENT_INFO':
                handleGetElementInfo(message.locator, sender.tab?.id, sendResponse);
                return true;
                
            case 'FIND_ELEMENTS':
                handleFindElements(message.locator, sender.tab?.id, sendResponse);
                return true;
                
            case 'SET_VALUE':
                handleSetValue(message.locator, message.value, message.options, sender.tab?.id, sendResponse);
                return true;
                
            case 'CLICK_ELEMENT':
                handleClickElement(message.locator, message.options, sender.tab?.id, sendResponse);
                return true;
                
            case 'GET_TEXT_CONTENT':
                handleGetTextContent(message.locator, sender.tab?.id, sendResponse);
                return true;
                
            case 'GET_PAGE_SOURCE':
                handleGetPageSource(sender.tab?.id, sendResponse);
                return true;
                
            case 'EXECUTE_SCRIPT':
                handleExecuteScript(message.script, message.args, sender.tab?.id, sendResponse);
                return true;
                
            case 'GET_LOCATORS':
                handleGetLocators(message.element, sender.tab?.id, sendResponse);
                return true;
                
            case 'TEST_LOCATOR':
                handleTestLocator(message.locator, sender.tab?.id, sendResponse);
                return true;
                
            case 'GET_BROWSER_INFO':
                handleGetBrowserInfo(sendResponse);
                return true;
                
            default:
                console.warn(`[Background] Unknown action: ${message.action}`);
                sendResponse({ success: false, error: `Unknown action: ${message.action}` });
                return false;
        }
    } catch (error) {
        console.error(`[Background] Error processing message: ${error.message}`, error);
        sendResponse({ success: false, error: error.message });
        return false;
    }
});

// Connection handler for long-lived connections
chrome.runtime.onConnect.addListener((port) => {
    if (!port.name.startsWith(`${EXTENSION_PREFIX}-`)) {
        return; // Not our port
    }
    
    console.debug(`[Background] Port connected: ${port.name}`);
    
    // Register port
    const portInfo = {
        port: port,
        name: port.name,
        type: port.name.split('-')[1], // popup, devtools, content, etc.
        tabId: null,
        windowId: null,
        connected: true,
        lastMessage: Date.now()
    };
    
    // Extract tab and window IDs from the port name
    const tabIdMatch = port.name.match(/tab-(\d+)/);
    if (tabIdMatch) {
        portInfo.tabId = parseInt(tabIdMatch[1], 10);
    }
    
    const windowIdMatch = port.name.match(/window-(\d+)/);
    if (windowIdMatch) {
        portInfo.windowId = parseInt(windowIdMatch[1], 10);
    }
    
    // Store port
    state.connectedPorts.set(port.name, portInfo);
    
    // Listen for messages
    port.onMessage.addListener((message) => {
        handlePortMessage(port, message);
    });
    
    // Listen for disconnect
    port.onDisconnect.addListener(() => {
        console.debug(`[Background] Port disconnected: ${port.name}`);
        
        // Mark as disconnected
        const portInfo = state.connectedPorts.get(port.name);
        if (portInfo) {
            portInfo.connected = false;
            portInfo.disconnectedAt = Date.now();
        }
        
        // Clean up after a delay to allow for reconnects
        setTimeout(() => {
            if (state.connectedPorts.has(port.name)) {
                const portInfo = state.connectedPorts.get(port.name);
                if (!portInfo.connected) {
                    state.connectedPorts.delete(port.name);
                }
            }
        }, 30000); // 30 second delay
    });
    
    // Send initial state
    port.postMessage({
        action: 'INITIAL_STATE',
        state: getPublicState()
    });
});

// Browser action click handler
chrome.action.onClicked.addListener((tab) => {
    // Only inject if not already active
    checkRecorderState(tab.id).then(isActive => {
        if (!isActive) {
            injectRecorderScripts(tab.id)
                .then(() => {
                    console.debug(`[Background] Recorder injected into tab ${tab.id}`);
                    // Update badge
                    chrome.action.setBadgeText({ text: 'ON', tabId: tab.id });
                    chrome.action.setBadgeBackgroundColor({ color: '#4CAF50', tabId: tab.id });
                })
                .catch(error => {
                    console.error(`[Background] Failed to inject recorder: ${error.message}`, error);
                    // Update badge
                    chrome.action.setBadgeText({ text: 'ERR', tabId: tab.id });
                    chrome.action.setBadgeBackgroundColor({ color: '#F44336', tabId: tab.id });
                });
        } else if (state.recording && state.recordingTabId === tab.id) {
            // Toggle pause/resume if already recording
            if (state.paused) {
                handleResumeRecording();
            } else {
                handlePauseRecording();
            }
        } else {
            // Show popup
            chrome.action.setPopup({ popup: 'popup.html', tabId: tab.id });
            
            // Programmatically click the action to show popup
            chrome.tabs.sendMessage(tab.id, { action: 'TOGGLE_RECORDER_UI' });
        }
    });
});

// Command listener for keyboard shortcuts
chrome.commands.onCommand.addListener((command) => {
    if (command === 'toggle-recording') {
        // Get active tab
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            if (tabs.length === 0) return;
            
            const tab = tabs[0];
            
            if (state.recording) {
                if (state.recordingTabId === tab.id) {
                    // Toggle pause/resume
                    if (state.paused) {
                        handleResumeRecording();
                    } else {
                        handlePauseRecording();
                    }
                } else {
                    // Don't allow recording multiple tabs
                    showNotification('Recording in progress', 
                        'Stop recording in the other tab before starting a new recording.');
                }
            } else {
                // Start recording
                handleStartRecording({
                    tabId: tab.id,
                    windowId: tab.windowId
                });
            }
        });
    } else if (command === 'take-screenshot') {
        // Get active tab
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            if (tabs.length === 0) return;
            
            const tab = tabs[0];
            
            // Take screenshot
            handleTakeScreenshot({
                fullPage: false,
                showInGallery: true
            }, tab.id);
        });
    }
});

// Tab events to handle recording session cleanup
chrome.tabs.onRemoved.addListener((tabId, removeInfo) => {
    if (state.recordingTabId === tabId) {
        console.debug(`[Background] Recording tab closed: ${tabId}`);
        
        // Ask if user wants to save recording
        if (state.recording && state.recordingEvents.length > 0) {
            // Auto-stop recording
            handleStopRecording();
            
            showNotification('Recording stopped', 
                'The tab being recorded was closed. Your recording has been saved.',
                { requireInteraction: true });
        } else {
            // Just clear recording state
            handleClearRecording();
        }
    }
    
    // Clean up ports for this tab
    for (const [portName, portInfo] of state.connectedPorts.entries()) {
        if (portInfo.tabId === tabId) {
            console.debug(`[Background] Cleaning up port for closed tab: ${portName}`);
            state.connectedPorts.delete(portName);
        }
    }
});

// Storage change listener
chrome.storage.onChanged.addListener((changes, areaName) => {
    if (areaName === 'local') {
        if (changes.recordingSettings) {
            state.recordingSettings = changes.recordingSettings.newValue;
            broadcastToAllPorts({
                action: 'SETTINGS_UPDATED',
                settings: state.recordingSettings
            });
        }
    }
});

// On extension install
chrome.runtime.onInstalled.addListener((details) => {
    if (details.reason === 'install') {
        // First install
        console.debug('[Background] Extension installed');
        initializeExtension();
    } else if (details.reason === 'update') {
        // Update
        console.debug(`[Background] Extension updated from ${details.previousVersion}`);
        handleExtensionUpdate(details.previousVersion);
    }
});

// Initialize on startup
initializeExtension();

/**
 * Initialize the extension state
 */
async function initializeExtension() {
    // Load settings from storage
    try {
        const data = await chrome.storage.local.get('recordingSettings');
        if (data.recordingSettings) {
            state.recordingSettings = data.recordingSettings;
        } else {
            // First run, save default settings
            await chrome.storage.local.set({ recordingSettings: state.recordingSettings });
        }
        
        console.debug('[Background] Settings loaded', state.recordingSettings);
    } catch (error) {
        console.error(`[Background] Error loading settings: ${error.message}`, error);
    }
    
    // Load any saved recording session
    try {
        const data = await chrome.storage.local.get('recordingSession');
        if (data.recordingSession) {
            if (data.recordingSession.events && 
                data.recordingSession.events.length > 0 &&
                Date.now() - data.recordingSession.endTime < 24 * 60 * 60 * 1000) {
                // Only restore if less than 24 hours old
                state.recordingEvents = data.recordingSession.events;
                state.recordingSessionId = data.recordingSession.id;
                state.recordingStartTime = data.recordingSession.startTime;
                
                console.debug('[Background] Restored recording session', {
                    id: state.recordingSessionId,
                    events: state.recordingEvents.length
                });
            } else {
                // Too old, clear it
                await chrome.storage.local.remove('recordingSession');
            }
        }
    } catch (error) {
        console.error(`[Background] Error loading recording session: ${error.message}`, error);
    }
}

/**
 * Handle extension update
 * @param {string} previousVersion - Previous version
 */
async function handleExtensionUpdate(previousVersion) {
    // Check if any migration is needed
    const currentVersion = chrome.runtime.getManifest().version;
    
    // Example version-specific migrations
    if (compareVersions(previousVersion, '1.0.0') < 0) {
        // Migration from pre-1.0.0 to 1.0.0
        console.debug('[Background] Migrating from pre-1.0.0');
        
        // Just re-initialize with defaults
        await chrome.storage.local.remove('recordingSettings');
        await initializeExtension();
    }
    
    // Show update notification
    showNotification(
        'CSTestForge Recorder Updated',
        `Updated to version ${currentVersion}. Click for release notes.`,
        {
            requireInteraction: true,
            onClick: () => {
                chrome.tabs.create({
                    url: `https://cstestforge.example.com/releases/v${currentVersion}`
                });
            }
        }
    );
}

/**
 * Compare version strings
 * @param {string} v1 - Version 1
 * @param {string} v2 - Version 2
 * @returns {number} -1 if v1 < v2, 0 if v1 = v2, 1 if v1 > v2
 */
function compareVersions(v1, v2) {
    const v1Parts = v1.split('.').map(Number);
    const v2Parts = v2.split('.').map(Number);
    
    for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
        const v1Part = i < v1Parts.length ? v1Parts[i] : 0;
        const v2Part = i < v2Parts.length ? v2Parts[i] : 0;
        
        if (v1Part < v2Part) return -1;
        if (v1Part > v2Part) return 1;
    }
    
    return 0;
}

/**
 * Get a clean version of the state for broadcasting
 * @returns {Object} Public state object
 */
function getPublicState() {
    return {
        recording: state.recording,
        paused: state.paused,
        recordingTabId: state.recordingTabId,
        recordingWindowId: state.recordingWindowId,
        recordingSessionId: state.recordingSessionId,
        recordingStartTime: state.recordingStartTime,
        recordingEventsCount: state.recordingEvents.length,
        recordingSettings: state.recordingSettings,
        browserInfo: state.browserInfo
    };
}

/**
 * Handle GET_STATE message
 * @param {Function} sendResponse - Response callback
 */
function handleGetState(sendResponse) {
    sendResponse({
        success: true,
        state: getPublicState()
    });
}

/**
 * Handle START_RECORDING message
 * @param {Object} options - Recording options
 * @param {Function} sendResponse - Response callback
 */
async function handleStartRecording(options, sendResponse) {
    try {
        // Validate tab
        const tabId = options?.tabId;
        if (!tabId) {
            throw new Error('Tab ID is required');
        }
        
        // Check if already recording
        if (state.recording) {
            throw new Error('Already recording');
        }
        
        // Get tab info
        const tab = await chrome.tabs.get(tabId);
        
        // Start new recording session
        state.recording = true;
        state.paused = false;
        state.recordingTabId = tabId;
        state.recordingWindowId = tab.windowId;
        state.recordingSessionId = generateSessionId();
        state.recordingStartTime = Date.now();
        state.recordingEvents = [];
        
        // Apply options if provided
        if (options?.settings) {
            state.recordingSettings = {
                ...state.recordingSettings,
                ...options.settings
            };
            
            // Save settings
            await chrome.storage.local.set({ 
                recordingSettings: state.recordingSettings 
            });
        }
        
        // Ensure the recorder is injected
        await injectRecorderScripts(tabId);
        
        // Start recording in the tab
        await executeInTab(tabId, {
            action: 'RUN_COMMAND',
            command: 'startRecording'
        });
        
        // Update badge
        chrome.action.setBadgeText({ 
            text: '⚫', 
            tabId 
        });
        
        chrome.action.setBadgeBackgroundColor({ 
            color: '#F44336', 
            tabId 
        });
        
        // Record page metadata as first event
        const pageInfo = await getPageInfo(tabId);
        recordEvent({
            type: 'NAVIGATION',
            url: pageInfo.url,
            title: pageInfo.title,
            timestamp: Date.now(),
            metadata: {
                pageInfo
            }
        });
        
        // Broadcast state change
        broadcastStateChange();
        
        console.debug(`[Background] Recording started in tab ${tabId}`, {
            sessionId: state.recordingSessionId,
            settings: state.recordingSettings
        });
        
        if (sendResponse) {
            sendResponse({
                success: true,
                state: getPublicState()
            });
        }
    } catch (error) {
        console.error(`[Background] Error starting recording: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle STOP_RECORDING message
 * @param {Function} sendResponse - Response callback
 */
async function handleStopRecording(sendResponse) {
    try {
        if (!state.recording) {
            throw new Error('Not recording');
        }
        
        const tabId = state.recordingTabId;
        
        // Stop recording in the tab if available
        if (tabId) {
            try {
                await executeInTab(tabId, {
                    action: 'RUN_COMMAND',
                    command: 'stopRecording'
                });
            } catch (error) {
                // Tab might be closed, ignore
                console.warn(`[Background] Error stopping recording in tab: ${error.message}`);
            }
            
            // Update badge
            chrome.action.setBadgeText({ 
                text: '', 
                tabId 
            });
        }
        
        // Record session end time
        const endTime = Date.now();
        
        // Create session data
        const recordingSession = {
            id: state.recordingSessionId,
            startTime: state.recordingStartTime,
            endTime: endTime,
            tabId: state.recordingTabId,
            windowId: state.recordingWindowId,
            settings: state.recordingSettings,
            events: state.recordingEvents
        };
        
        // Save recording session
        await chrome.storage.local.set({ recordingSession });
        
        // Update state
        state.recording = false;
        state.paused = false;
        state.recordingTabId = null;
        state.recordingWindowId = null;
        
        // Broadcast state change
        broadcastStateChange();
        
        console.debug('[Background] Recording stopped', {
            sessionId: state.recordingSessionId,
            events: state.recordingEvents.length
        });
        
        if (sendResponse) {
            sendResponse({
                success: true,
                state: getPublicState(),
                recordingSession
            });
        }
    } catch (error) {
        console.error(`[Background] Error stopping recording: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle PAUSE_RECORDING message
 * @param {Function} sendResponse - Response callback
 */
async function handlePauseRecording(sendResponse) {
    try {
        if (!state.recording) {
            throw new Error('Not recording');
        }
        
        if (state.paused) {
            throw new Error('Already paused');
        }
        
        const tabId = state.recordingTabId;
        
        // Pause recording in the tab
        if (tabId) {
            try {
                await executeInTab(tabId, {
                    action: 'RUN_COMMAND',
                    command: 'pauseRecording'
                });
            } catch (error) {
                console.warn(`[Background] Error pausing recording in tab: ${error.message}`);
            }
            
            // Update badge
            chrome.action.setBadgeText({ 
                text: '❚❚', 
                tabId 
            });
            
            chrome.action.setBadgeBackgroundColor({ 
                color: '#FF9800', 
                tabId 
            });
        }
        
        // Update state
        state.paused = true;
        
        // Record pause event
        recordEvent({
            type: 'RECORDER',
            action: 'pause',
            timestamp: Date.now()
        });
        
        // Broadcast state change
        broadcastStateChange();
        
        console.debug('[Background] Recording paused');
        
        if (sendResponse) {
            sendResponse({
                success: true,
                state: getPublicState()
            });
        }
    } catch (error) {
        console.error(`[Background] Error pausing recording: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle RESUME_RECORDING message
 * @param {Function} sendResponse - Response callback
 */
async function handleResumeRecording(sendResponse) {
    try {
        if (!state.recording) {
            throw new Error('Not recording');
        }
        
        if (!state.paused) {
            throw new Error('Not paused');
        }
        
        const tabId = state.recordingTabId;
        
        // Resume recording in the tab
        if (tabId) {
            try {
                await executeInTab(tabId, {
                    action: 'RUN_COMMAND',
                    command: 'resumeRecording'
                });
            } catch (error) {
                console.warn(`[Background] Error resuming recording in tab: ${error.message}`);
            }
            
            // Update badge
            chrome.action.setBadgeText({ 
                text: '⚫', 
                tabId 
            });
            
            chrome.action.setBadgeBackgroundColor({ 
                color: '#F44336', 
                tabId 
            });
        }
        
        // Update state
        state.paused = false;
        
        // Record resume event
        recordEvent({
            type: 'RECORDER',
            action: 'resume',
            timestamp: Date.now()
        });
        
        // Broadcast state change
        broadcastStateChange();
        
        console.debug('[Background] Recording resumed');
        
        if (sendResponse) {
            sendResponse({
                success: true,
                state: getPublicState()
            });
        }
    } catch (error) {
        console.error(`[Background] Error resuming recording: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle CLEAR_RECORDING message
 * @param {Function} sendResponse - Response callback
 */
async function handleClearRecording(sendResponse) {
    try {
        // Clear recording data
        state.recordingEvents = [];
        
        // Clear saved session
        await chrome.storage.local.remove('recordingSession');
        
        console.debug('[Background] Recording cleared');
        
        if (sendResponse) {
            sendResponse({
                success: true
            });
        }
        
        // Broadcast state change
        broadcastStateChange();
    } catch (error) {
        console.error(`[Background] Error clearing recording: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle GET_RECORDING_DATA message
 * @param {Function} sendResponse - Response callback
 */
function handleGetRecordingData(sendResponse) {
    try {
        // Create session data
        const recordingData = {
            id: state.recordingSessionId,
            startTime: state.recordingStartTime,
            endTime: state.recording ? null : Date.now(),
            tabId: state.recordingTabId,
            windowId: state.recordingWindowId,
            settings: state.recordingSettings,
            events: state.recordingEvents,
            recording: state.recording,
            paused: state.paused
        };
        
        if (sendResponse) {
            sendResponse({
                success: true,
                data: recordingData
            });
        }
    } catch (error) {
        console.error(`[Background] Error getting recording data: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle GENERATE_CODE message
 * @param {Object} options - Code generation options
 * @param {Function} sendResponse - Response callback
 */
async function handleGenerateCode(options, sendResponse) {
    try {
        // Validate
        if (state.recordingEvents.length === 0) {
            throw new Error('No recording data available');
        }
        
        // Get settings from options or current settings
        const settings = {
            ...state.recordingSettings,
            ...options
        };
        
        // Generate code based on framework/language/test type
        const framework = settings.framework;
        const language = settings.language;
        const testType = settings.testType;
        
        console.debug(`[Background] Generating code for ${framework}/${language}/${testType}`);
        
        // Create code generator configuration
        const config = {
            events: state.recordingEvents,
            sessionId: state.recordingSessionId,
            startTime: state.recordingStartTime,
            endTime: Date.now(),
            settings
        };
        
        // Call code generator
        const codeGenerator = new CodeGenerator(config);
        const code = await codeGenerator.generate();
        
        if (sendResponse) {
            sendResponse({
                success: true,
                code
            });
        }
    } catch (error) {
        console.error(`[Background] Error generating code: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle EXPORT_RECORDING message
 * @param {Object} options - Export options
 * @param {Function} sendResponse - Response callback
 */
async function handleExportRecording(options, sendResponse) {
    try {
        // Validate
        if (state.recordingEvents.length === 0) {
            throw new Error('No recording data available');
        }
        
        // Get export format
        const format = options?.format || 'json';
        
        // Create export data
        const exportData = {
            id: state.recordingSessionId,
            startTime: state.recordingStartTime,
            endTime: Date.now(),
            settings: state.recordingSettings,
            events: state.recordingEvents,
            metadata: {
                exportTime: Date.now(),
                exportFormat: format,
                exportOptions: options,
                version: chrome.runtime.getManifest().version
            }
        };
        
        let blob;
        let filename;
        
        // Format data based on export format
        switch (format) {
            case 'json':
                blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                    type: 'application/json' 
                });
                filename = `cstestforge_recording_${formatDate(state.recordingStartTime)}.json`;
                break;
                
            case 'html':
                // Generate HTML report
                const html = generateHtmlReport(exportData);
                blob = new Blob([html], { 
                    type: 'text/html' 
                });
                filename = `cstestforge_report_${formatDate(state.recordingStartTime)}.html`;
                break;
                
            case 'csv':
                // Generate CSV
                const csv = generateCsv(exportData);
                blob = new Blob([csv], { 
                    type: 'text/csv' 
                });
                filename = `cstestforge_events_${formatDate(state.recordingStartTime)}.csv`;
                break;
                
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
        
        // Create download URL
        const url = URL.createObjectURL(blob);
        
        // Download the file
        const downloadId = await chrome.downloads.download({
            url: url,
            filename: filename,
            saveAs: options?.saveAs !== false
        });
        
        // Clean up URL after download
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        
        if (sendResponse) {
            sendResponse({
                success: true,
                downloadId,
                filename
            });
        }
    } catch (error) {
        console.error(`[Background] Error exporting recording: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle UPDATE_SETTINGS message
 * @param {Object} settings - New settings
 * @param {Function} sendResponse - Response callback
 */
async function handleUpdateSettings(settings, sendResponse) {
    try {
        if (!settings) {
            throw new Error('Settings are required');
        }
        
        // Update settings
        state.recordingSettings = {
            ...state.recordingSettings,
            ...settings
        };
        
        // Save settings
        await chrome.storage.local.set({ 
            recordingSettings: state.recordingSettings 
        });
        
        console.debug('[Background] Settings updated', state.recordingSettings);
        
        if (sendResponse) {
            sendResponse({
                success: true,
                settings: state.recordingSettings
            });
        }
        
        // Broadcast settings change
        broadcastToAllPorts({
            action: 'SETTINGS_UPDATED',
            settings: state.recordingSettings
        });
    } catch (error) {
        console.error(`[Background] Error updating settings: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle GET_SETTINGS message
 * @param {Function} sendResponse - Response callback
 */
function handleGetSettings(sendResponse) {
    if (sendResponse) {
        sendResponse({
            success: true,
            settings: state.recordingSettings
        });
    }
}

/**
 * Handle INJECT_SCRIPTS message
 * @param {number} tabId - Tab ID to inject into
 * @param {Function} sendResponse - Response callback
 */
async function handleInjectScripts(tabId, sendResponse) {
    try {
        if (!tabId) {
            throw new Error('Tab ID is required');
        }
        
        await injectRecorderScripts(tabId);
        
        if (sendResponse) {
            sendResponse({
                success: true
            });
        }
    } catch (error) {
        console.error(`[Background] Error injecting scripts: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle RUN_COMMAND message
 * @param {string} command - Command to run
 * @param {Object} params - Command parameters
 * @param {number} tabId - Tab ID to run in
 * @param {Function} sendResponse - Response callback
 */
async function handleRunCommand(command, params, tabId, sendResponse) {
    try {
        if (!command) {
            throw new Error('Command is required');
        }
        
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Execute command in the tab
        const result = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command,
            params
        });
        
        if (sendResponse) {
            sendResponse({
                success: true,
                result
            });
        }
    } catch (error) {
        console.error(`[Background] Error running command: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle RECORD_EVENT message
 * @param {Object} event - Event to record
 * @param {number} tabId - Source tab ID
 * @param {Function} sendResponse - Response callback
 */
function handleRecordEvent(event, tabId, sendResponse) {
    try {
        if (!event) {
            throw new Error('Event is required');
        }
        
        // Only record if recording is active and not paused
        if (state.recording && !state.paused && 
            state.recordingTabId === tabId) {
            
            recordEvent(event);
            
            if (sendResponse) {
                sendResponse({
                    success: true
                });
            }
        } else {
            // Silently ignore events when not recording
            if (sendResponse) {
                sendResponse({
                    success: false,
                    error: 'Not recording or recorder paused'
                });
            }
        }
    } catch (error) {
        console.error(`[Background] Error recording event: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle TAKE_SCREENSHOT message
 * @param {Object} options - Screenshot options
 * @param {number} tabId - Tab ID to screenshot
 * @param {Function} sendResponse - Response callback
 */
async function handleTakeScreenshot(options, tabId, sendResponse) {
    try {
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Take screenshot
        const dataUrl = await chrome.tabs.captureVisibleTab(
            null, 
            { format: 'png' }
        );
        
        // Process options
        const screenshotOptions = {
            fullPage: options?.fullPage || false,
            element: options?.element || null,
            showInGallery: options?.showInGallery || false
        };
        
        // If full page screenshot is requested, use content script
        let fullScreenshot = dataUrl;
        
        if (screenshotOptions.fullPage) {
            try {
                const result = await executeInTab(targetTabId, {
                    action: 'CAPTURE_FULL_PAGE'
                });
                
                if (result && result.dataUrl) {
                    fullScreenshot = result.dataUrl;
                }
            } catch (error) {
                console.warn('[Background] Error capturing full page screenshot, falling back to visible area', error);
            }
        }
        
        // If element screenshot is requested, crop the screenshot
        let finalScreenshot = fullScreenshot;
        let elementInfo = null;
        
        if (screenshotOptions.element) {
            try {
                const element = screenshotOptions.element;
                
                // Get element info
                const info = await executeInTab(targetTabId, {
                    action: 'GET_ELEMENT_INFO',
                    locator: element
                });
                
                if (info && info.rect) {
                    elementInfo = info;
                    
                    // Crop screenshot to element
                    finalScreenshot = await cropScreenshot(
                        fullScreenshot, 
                        info.rect
                    );
                }
            } catch (error) {
                console.warn('[Background] Error capturing element screenshot, falling back to full screenshot', error);
            }
        }
        
        // Record the screenshot as event if recording
        if (state.recording && !state.paused && 
            state.recordingTabId === targetTabId) {
            
            // Record screenshot event
            recordEvent({
                type: 'SCREENSHOT',
                timestamp: Date.now(),
                dataUrl: finalScreenshot,
                fullPage: screenshotOptions.fullPage,
                element: elementInfo
            });
        }
        
        // Show in gallery if requested
        if (screenshotOptions.showInGallery) {
            // Create temporary screenshot file for viewing
            const blob = await dataURLToBlob(finalScreenshot);
            const url = URL.createObjectURL(blob);
            
            // Open in a new tab
            chrome.tabs.create({
                url: chrome.runtime.getURL('screenshot.html') + 
                     '?src=' + encodeURIComponent(url)
            });
            
            // Clean up URL after a delay
            setTimeout(() => URL.revokeObjectURL(url), 60000);
        }
        
        if (sendResponse) {
            sendResponse({
                success: true,
                dataUrl: finalScreenshot,
                fullPage: screenshotOptions.fullPage,
                element: elementInfo
            });
        }
    } catch (error) {
        console.error(`[Background] Error taking screenshot: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle HIGHLIGHT_ELEMENT message
 * @param {Object} locator - Element locator
 * @param {number} tabId - Tab ID to highlight in
 * @param {Function} sendResponse - Response callback
 */
async function handleHighlightElement(locator, tabId, sendResponse) {
    try {
        if (!locator) {
            throw new Error('Locator is required');
        }
        
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Highlight the element
        const result = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command: 'highlightElement',
            params: {
                locator,
                options: {
                    color: '#C54B8C', // Primary brand color
                    duration: 2000,
                    outlineWidth: '2px',
                    pulseEffect: true
                }
            }
        });
        
        if (sendResponse) {
            sendResponse({
                success: true,
                result
            });
        }
    } catch (error) {
        console.error(`[Background] Error highlighting element: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle GET_ELEMENT_INFO message
 * @param {Object} locator - Element locator
 * @param {number} tabId - Tab ID to get info from
 * @param {Function} sendResponse - Response callback
 */
async function handleGetElementInfo(locator, tabId, sendResponse) {
    try {
        if (!locator) {
            throw new Error('Locator is required');
        }
        
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Get element info
        const result = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command: 'getElementInfo',
            params: {
                locator
            }
        });
        
        if (sendResponse) {
            sendResponse({
                success: true,
                elementInfo: result
            });
        }
    } catch (error) {
        console.error(`[Background] Error getting element info: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle FIND_ELEMENTS message
 * @param {Object} locator - Element locator
 * @param {number} tabId - Tab ID to find elements in
 * @param {Function} sendResponse - Response callback
 */
async function handleFindElements(locator, tabId, sendResponse) {
    try {
        if (!locator) {
            throw new Error('Locator is required');
        }
        
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Find elements
        const result = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command: 'findElements',
            params: {
                locator
            }
        });
        
        if (sendResponse) {
            sendResponse({
                success: true,
                elements: result
            });
        }
    } catch (error) {
        console.error(`[Background] Error finding elements: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle SET_VALUE message
 * @param {Object} locator - Element locator
 * @param {*} value - Value to set
 * @param {Object} options - Options for setting value
 * @param {number} tabId - Tab ID to set value in
 * @param {Function} sendResponse - Response callback
 */
async function handleSetValue(locator, value, options, tabId, sendResponse) {
    try {
        if (!locator) {
            throw new Error('Locator is required');
        }
        
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Set value
        const result = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command: 'setValue',
            params: {
                locator,
                value,
                ...options
            }
        });
        
        // Record the action if recording
        if (state.recording && !state.paused && 
            state.recordingTabId === targetTabId) {
            
            // Get element info for better recording
            let elementInfo;
            try {
                elementInfo = await executeInTab(targetTabId, {
                    action: 'RUN_COMMAND',
                    command: 'getElementInfo',
                    params: { locator }
                });
            } catch (e) {
                // Ignore errors
            }
            
            // Record set value event
            recordEvent({
                type: 'SET_VALUE',
                timestamp: Date.now(),
                locator,
                value,
                options,
                elementInfo
            });
        }
        
        if (sendResponse) {
            sendResponse({
                success: true,
                result
            });
        }
    } catch (error) {
        console.error(`[Background] Error setting value: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle CLICK_ELEMENT message
 * @param {Object} locator - Element locator
 * @param {Object} options - Click options
 * @param {number} tabId - Tab ID to click in
 * @param {Function} sendResponse - Response callback
 */
async function handleClickElement(locator, options, tabId, sendResponse) {
    try {
        if (!locator) {
            throw new Error('Locator is required');
        }
        
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Get element info before click for better recording
        let elementInfo;
        try {
            elementInfo = await executeInTab(targetTabId, {
                action: 'RUN_COMMAND',
                command: 'getElementInfo',
                params: { locator }
            });
        } catch (e) {
            // Ignore errors
        }
        
        // Click element
        const result = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command: 'clickElement',
            params: {
                locator,
                ...options
            }
        });
        
        // Record the action if recording
        if (state.recording && !state.paused && 
            state.recordingTabId === targetTabId) {
            
            // Record click event
            recordEvent({
                type: 'CLICK',
                timestamp: Date.now(),
                locator,
                options,
                elementInfo
            });
        }
        
        if (sendResponse) {
            sendResponse({
                success: true,
                result
            });
        }
    } catch (error) {
        console.error(`[Background] Error clicking element: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle GET_TEXT_CONTENT message
 * @param {Object} locator - Element locator
 * @param {number} tabId - Tab ID to get text from
 * @param {Function} sendResponse - Response callback
 */
async function handleGetTextContent(locator, tabId, sendResponse) {
    try {
        if (!locator) {
            throw new Error('Locator is required');
        }
        
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Get text content
        const result = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command: 'getTextContent',
            params: {
                locator
            }
        });
        
        if (sendResponse) {
            sendResponse({
                success: true,
                textContent: result
            });
        }
    } catch (error) {
        console.error(`[Background] Error getting text content: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle GET_PAGE_SOURCE message
 * @param {number} tabId - Tab ID to get source from
 * @param {Function} sendResponse - Response callback
 */
async function handleGetPageSource(tabId, sendResponse) {
    try {
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Get page source
        const source = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command: 'executeScript',
            params: {
                script: 'return document.documentElement.outerHTML;'
            }
        });
        
        if (sendResponse) {
            sendResponse({
                success: true,
                source
            });
        }
    } catch (error) {
        console.error(`[Background] Error getting page source: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle EXECUTE_SCRIPT message
 * @param {string} script - Script to execute
 * @param {Array} args - Arguments for the script
 * @param {number} tabId - Tab ID to execute in
 * @param {Function} sendResponse - Response callback
 */
async function handleExecuteScript(script, args, tabId, sendResponse) {
    try {
        if (!script) {
            throw new Error('Script is required');
        }
        
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Execute script
        const result = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command: 'executeScript',
            params: {
                script,
                args: args || []
            }
        });
        
        // Record the action if recording
        if (state.recording && !state.paused && 
            state.recordingTabId === targetTabId) {
            
            // Record execute script event
            recordEvent({
                type: 'EXECUTE_SCRIPT',
                timestamp: Date.now(),
                script,
                args: args || []
            });
        }
        
        if (sendResponse) {
            sendResponse({
                success: true,
                result
            });
        }
    } catch (error) {
        console.error(`[Background] Error executing script: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle GET_LOCATORS message
 * @param {Object} element - Element info to generate locators for
 * @param {number} tabId - Tab ID context
 * @param {Function} sendResponse - Response callback
 */
async function handleGetLocators(element, tabId, sendResponse) {
    try {
        if (!element) {
            throw new Error('Element is required');
        }
        
        // Generate locators for the element
        const locators = [];
        
        // ID locator
        if (element.id) {
            locators.push({
                type: 'id',
                value: element.id,
                strategy: 'id',
                code: {
                    java: {
                        selenium: `driver.findElement(By.id("${element.id}"))`,
                        playwright: `page.locator("#${element.id}")`
                    },
                    typescript: {
                        selenium: `driver.findElement(By.id("${element.id}"))`,
                        playwright: `page.locator("#${element.id}")`
                    }
                }
            });
        }
        
        // CSS selector
        if (element.cssSelector) {
            locators.push({
                type: 'css',
                value: element.cssSelector,
                strategy: 'css',
                code: {
                    java: {
                        selenium: `driver.findElement(By.cssSelector("${element.cssSelector.replace(/"/g, '\\"')}"))`,
                        playwright: `page.locator("${element.cssSelector.replace(/"/g, '\\"')}")`
                    },
                    typescript: {
                        selenium: `driver.findElement(By.css("${element.cssSelector.replace(/"/g, '\\"')}"))`,
                        playwright: `page.locator("${element.cssSelector.replace(/"/g, '\\"')}")`
                    }
                }
            });
        }
        
        // XPath
        if (element.xpath) {
            locators.push({
                type: 'xpath',
                value: element.xpath,
                strategy: 'xpath',
                code: {
                    java: {
                        selenium: `driver.findElement(By.xpath("${element.xpath.replace(/"/g, '\\"')}"))`,
                        playwright: `page.locator("xpath=${element.xpath.replace(/"/g, '\\"')}")`
                    },
                    typescript: {
                        selenium: `driver.findElement(By.xpath("${element.xpath.replace(/"/g, '\\"')}"))`,
                        playwright: `page.locator("xpath=${element.xpath.replace(/"/g, '\\"')}")`
                    }
                }
            });
        }
        
        // Name
        if (element.attributes && element.attributes.name) {
            const name = element.attributes.name;
            locators.push({
                type: 'name',
                value: name,
                strategy: 'name',
                code: {
                    java: {
                        selenium: `driver.findElement(By.name("${name.replace(/"/g, '\\"')}"))`,
                        playwright: `page.locator("[name='${name.replace(/'/g, "\\'")}']")`
                    },
                    typescript: {
                        selenium: `driver.findElement(By.name("${name.replace(/"/g, '\\"')}"))`,
                        playwright: `page.locator("[name='${name.replace(/'/g, "\\'")}']")`
                    }
                }
            });
        }
        
        // Link text
        if (element.tagName === 'A' && element.textContent) {
            const text = element.textContent.trim();
            locators.push({
                type: 'linkText',
                value: text,
                strategy: 'linkText',
                code: {
                    java: {
                        selenium: `driver.findElement(By.linkText("${text.replace(/"/g, '\\"')}"))`,
                        playwright: `page.getByRole('link', { name: "${text.replace(/"/g, '\\"')}" })`
                    },
                    typescript: {
                        selenium: `driver.findElement(By.linkText("${text.replace(/"/g, '\\"')}"))`,
                        playwright: `page.getByRole('link', { name: "${text.replace(/"/g, '\\"')}" })`
                    }
                }
            });
        }
        
        // Test locators if requested
        if (tabId) {
            for (const locator of locators) {
                try {
                    const testResult = await handleTestLocator(
                        { [locator.type]: locator.value }, 
                        tabId
                    );
                    
                    locator.testResult = testResult;
                } catch (error) {
                    locator.testResult = {
                        success: false,
                        error: error.message
                    };
                }
            }
            
            // Sort by test result
            locators.sort((a, b) => {
                // Put successful tests first
                if (a.testResult?.success && !b.testResult?.success) {
                    return -1;
                }
                if (!a.testResult?.success && b.testResult?.success) {
                    return 1;
                }
                
                // Sort by locator type preference
                const typeOrder = ['id', 'css', 'name', 'linkText', 'xpath'];
                return typeOrder.indexOf(a.type) - typeOrder.indexOf(b.type);
            });
        }
        
        if (sendResponse) {
            sendResponse({
                success: true,
                locators
            });
        }
    } catch (error) {
        console.error(`[Background] Error getting locators: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle TEST_LOCATOR message
 * @param {Object} locator - Locator to test
 * @param {number} tabId - Tab ID to test in
 * @param {Function} sendResponse - Response callback
 */
async function handleTestLocator(locator, tabId, sendResponse) {
    try {
        if (!locator) {
            throw new Error('Locator is required');
        }
        
        // Run in specified tab or recording tab if available
        const targetTabId = tabId || state.recordingTabId;
        
        if (!targetTabId) {
            throw new Error('No tab specified and no recording in progress');
        }
        
        // Find elements with the locator
        const elements = await executeInTab(targetTabId, {
            action: 'RUN_COMMAND',
            command: 'findElements',
            params: {
                locator
            }
        });
        
        // Test result
        const result = {
            success: elements && elements.length > 0,
            count: elements ? elements.length : 0,
            elements: elements || []
        };
        
        if (sendResponse) {
            sendResponse(result);
        }
        
        return result;
    } catch (error) {
        console.error(`[Background] Error testing locator: ${error.message}`, error);
        
        const result = {
            success: false,
            error: error.message
        };
        
        if (sendResponse) {
            sendResponse(result);
        }
        
        return result;
    }
}

/**
 * Handle GET_BROWSER_INFO message
 * @param {Function} sendResponse - Response callback
 */
async function handleGetBrowserInfo(sendResponse) {
    try {
        // Get browser info if not already cached
        if (!state.browserInfo) {
            // Get browser info from the current tab
            const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
            
            if (tab) {
                try {
                    const result = await executeInTab(tab.id, {
                        action: 'GET_BROWSER_INFO'
                    });
                    
                    if (result) {
                        state.browserInfo = result;
                    }
                } catch (error) {
                    console.warn('[Background] Error getting browser info from tab', error);
                }
            }
            
            // Fallback to basic info if not available
            if (!state.browserInfo) {
                const browserInfo = {
                    name: 'Chrome',
                    version: navigator.userAgent.match(/Chrome\/([0-9.]+)/)?.[1] || 'unknown',
                    userAgent: navigator.userAgent
                };
                
                state.browserInfo = browserInfo;
            }
        }
        
        if (sendResponse) {
            sendResponse({
                success: true,
                browserInfo: state.browserInfo
            });
        }
    } catch (error) {
        console.error(`[Background] Error getting browser info: ${error.message}`, error);
        
        if (sendResponse) {
            sendResponse({
                success: false,
                error: error.message
            });
        }
    }
}

/**
 * Handle port message
 * @param {chrome.runtime.Port} port - Port that received the message
 * @param {Object} message - Message received
 */
function handlePortMessage(port, message) {
    try {
        // Update port last message time
        const portInfo = state.connectedPorts.get(port.name);
        if (portInfo) {
            portInfo.lastMessage = Date.now();
        }
        
        // Process message
        if (!message || !message.action) {
            console.warn('[Background] Invalid port message', message);
            return;
        }
        
        console.debug(`[Background] Port message: ${message.action}`, message);
        
        // Process specific port message types
        switch (message.action) {
            case 'PING':
                port.postMessage({
                    action: 'PONG',
                    timestamp: Date.now()
                });
                break;
                
            case 'GET_STATE':
                port.postMessage({
                    action: 'STATE_UPDATE',
                    state: getPublicState()
                });
                break;
                
            default:
                // Forward to regular message handler
                const sender = {
                    tab: { id: portInfo?.tabId }
                };
                
                chrome.runtime.onMessage.addListener((message, sender) => {});
                
                // Create synthetic sendResponse function
                const sendResponse = (response) => {
                    port.postMessage({
                        action: `${message.action}_RESPONSE`,
                        requestId: message.requestId,
                        ...response
                    });
                };
                
                // Process message
                chrome.runtime.onMessage._emit(message, sender, sendResponse);
        }
    } catch (error) {
        console.error(`[Background] Error handling port message: ${error.message}`, error);
        
        // Send error response
        try {
            port.postMessage({
                action: `${message.action}_ERROR`,
                requestId: message.requestId,
                error: error.message
            });
        } catch (e) {
            // Ignore errors in error handling
        }
    }
}

/**
 * Add event to recording
 * @param {Object} event - Event to record
 */
function recordEvent(event) {
    if (!event) return;
    
    // Ensure required properties
    event.timestamp = event.timestamp || Date.now();
    event.id = event.id || generateEventId();
    
    // Add to events array
    state.recordingEvents.push(event);
    
    // Broadcast event to all connections
    broadcastToAllPorts({
        action: 'EVENT_RECORDED',
        event
    });
    
    console.debug(`[Background] Event recorded: ${event.type}`, event);
}

/**
 * Broadcast state change to all connections
 */
function broadcastStateChange() {
    broadcastToAllPorts({
        action: 'STATE_CHANGED',
        state: getPublicState()
    });
}

/**
 * Broadcast message to all connected ports
 * @param {Object} message - Message to broadcast
 */
function broadcastToAllPorts(message) {
    for (const [portName, portInfo] of state.connectedPorts.entries()) {
        if (portInfo.connected) {
            try {
                portInfo.port.postMessage(message);
            } catch (error) {
                console.warn(`[Background] Error broadcasting to port ${portName}`, error);
                portInfo.connected = false;
            }
        }
    }
}

/**
 * Check if recorder is active in a tab
 * @param {number} tabId - Tab ID to check
 * @returns {Promise<boolean>} Whether recorder is active
 */
async function checkRecorderState(tabId) {
    try {
        const result = await executeInTab(tabId, {
            action: 'CHECK_RECORDER_STATE'
        });
        
        return result && result.active;
    } catch (error) {
        return false;
    }
}

/**
 * Get page information
 * @param {number} tabId - Tab ID to get info from
 * @returns {Promise<Object>} Page information
 */
async function getPageInfo(tabId) {
    try {
        const tab = await chrome.tabs.get(tabId);
        
        // Get additional info from page
        let pageInfo = {
            url: tab.url,
            title: tab.title
        };
        
        try {
            const result = await executeInTab(tabId, {
                action: 'GET_PAGE_INFO'
            });
            
            if (result) {
                pageInfo = { ...pageInfo, ...result };
            }
        } catch (error) {
            // Ignore errors
        }
        
        return pageInfo;
    } catch (error) {
        console.error(`[Background] Error getting page info: ${error.message}`, error);
        return {
            url: tab?.url || '',
            title: tab?.title || ''
        };
    }
}

/**
 * Execute a message in a tab
 * @param {number} tabId - Tab ID to execute in
 * @param {Object} message - Message to send
 * @returns {Promise<any>} Response from the tab
 */
function executeInTab(tabId, message) {
    return new Promise((resolve, reject) => {
        try {
            chrome.tabs.sendMessage(tabId, message, (response) => {
                if (chrome.runtime.lastError) {
                    // Check if we need to inject scripts
                    if (chrome.runtime.lastError.message.includes('not established')) {
                        // Try injecting recorder and then retry once
                        injectRecorderScripts(tabId)
                            .then(() => {
                                // Retry after injection
                                chrome.tabs.sendMessage(tabId, message, (retryResponse) => {
                                    if (chrome.runtime.lastError) {
                                        reject(new Error(chrome.runtime.lastError.message));
                                    } else {
                                        resolve(retryResponse);
                                    }
                                });
                            })
                            .catch(reject);
                    } else {
                        reject(new Error(chrome.runtime.lastError.message));
                    }
                } else {
                    resolve(response);
                }
            });
        } catch (error) {
            reject(error);
        }
    });
}

/**
 * Inject recorder scripts into a tab
 * @param {number} tabId - Tab ID to inject into
 * @returns {Promise<void>} Completion promise
 */
async function injectRecorderScripts(tabId) {
    try {
        console.debug(`[Background] Injecting recorder scripts into tab ${tabId}`);
        
        // Inject content script first
        await chrome.scripting.executeScript({
            target: { tabId },
            files: ['content-script.js']
        });
        
        // Inject recorder scripts in order
        for (const script of RECORDER_SCRIPTS) {
            console.debug(`[Background] Injecting ${script}`);
            
            await chrome.scripting.executeScript({
                target: { tabId },
                files: [script]
            });
        }
        
        // Initialize recorder
        await executeInTab(tabId, {
            action: 'INITIALIZE_RECORDER',
            settings: state.recordingSettings
        });
        
        console.debug(`[Background] Recorder scripts injected into tab ${tabId}`);
    } catch (error) {
        console.error(`[Background] Error injecting recorder scripts: ${error.message}`, error);
        throw error;
    }
}

/**
 * Crop a screenshot to a specific region
 * @param {string} dataUrl - Screenshot data URL
 * @param {Object} rect - Rectangle to crop to
 * @returns {Promise<string>} Cropped screenshot data URL
 */
function cropScreenshot(dataUrl, rect) {
    return new Promise((resolve, reject) => {
        try {
            const image = new Image();
            
            image.onload = () => {
                try {
                    // Create canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    
                    // Draw cropped image
                    const context = canvas.getContext('2d');
                    context.drawImage(
                        image,
                        rect.left, rect.top, rect.width, rect.height,
                        0, 0, rect.width, rect.height
                    );
                    
                    // Convert to data URL
                    const croppedDataUrl = canvas.toDataURL('image/png');
                    resolve(croppedDataUrl);
                } catch (error) {
                    reject(error);
                }
            };
            
            image.onerror = () => {
                reject(new Error('Failed to load image for cropping'));
            };
            
            image.src = dataUrl;
        } catch (error) {
            reject(error);
        }
    });
}

/**
 * Convert a data URL to a Blob
 * @param {string} dataUrl - Data URL to convert
 * @returns {Promise<Blob>} Converted blob
 */
function dataURLToBlob(dataUrl) {
    return new Promise((resolve, reject) => {
        try {
            const parts = dataUrl.split(';base64,');
            const contentType = parts[0].split(':')[1];
            const byteString = atob(parts[1]);
            const arrayBuffer = new ArrayBuffer(byteString.length);
            const uint8Array = new Uint8Array(arrayBuffer);
            
            for (let i = 0; i < byteString.length; i++) {
                uint8Array[i] = byteString.charCodeAt(i);
            }
            
            resolve(new Blob([arrayBuffer], { type: contentType }));
        } catch (error) {
            reject(error);
        }
    });
}

/**
 * Generate a session ID
 * @returns {string} Generated session ID
 */
function generateSessionId() {
    const timestamp = Date.now().toString(36);
    const randomPart = Math.random().toString(36).substring(2, 10);
    return `${timestamp}-${randomPart}`;
}

/**
 * Generate an event ID
 * @returns {string} Generated event ID
 */
function generateEventId() {
    return Math.random().toString(36).substring(2, 15);
}

/**
 * Format a date for filenames
 * @param {number} timestamp - Timestamp to format
 * @returns {string} Formatted date string
 */
function formatDate(timestamp) {
    const date = new Date(timestamp);
    return date.toISOString()
        .replace(/[:.]/g, '-')
        .replace('T', '_')
        .replace('Z', '');
}

/**
 * Show a notification
 * @param {string} title - Notification title
 * @param {string} message - Notification message
 * @param {Object} options - Notification options
 */
function showNotification(title, message, options = {}) {
    chrome.notifications.create({
        type: 'basic',
        iconUrl: 'icons/icon128.png',
        title,
        message,
        requireInteraction: options.requireInteraction || false
    }, (notificationId) => {
        // Handle click if needed
        if (options.onClick) {
            chrome.notifications.onClicked.addListener(function clickListener(clickedId) {
                if (clickedId === notificationId) {
                    options.onClick();
                    chrome.notifications.onClicked.removeListener(clickListener);
                }
            });
        }
    });
}

/**
 * Generate CSV from recording data
 * @param {Object} data - Recording data
 * @returns {string} Generated CSV
 */
function generateCsv(data) {
    if (!data || !data.events || !data.events.length) {
        return 'No events recorded';
    }
    
    // CSV header
    let csv = 'Index,Timestamp,DateTime,Type,Action,URL,Element,Value\n';
    
    // Add events
    data.events.forEach((event, index) => {
        const timestamp = event.timestamp || '';
        const datetime = timestamp ? new Date(timestamp).toISOString() : '';
        const type = event.type || '';
        const action = event.action || '';
        const url = event.url || '';
        
        // Determine element info
        let element = '';
        if (event.locator) {
            if (event.locator.id) {
                element = `id="${event.locator.id}"`;
            } else if (event.locator.css) {
                element = `css="${event.locator.css}"`;
            } else if (event.locator.xpath) {
                element = `xpath="${event.locator.xpath}"`;
            } else if (event.locator.name) {
                element = `name="${event.locator.name}"`;
            } else if (event.locator.linkText) {
                element = `linkText="${event.locator.linkText}"`;
            }
        } else if (event.elementInfo) {
            const info = event.elementInfo;
            if (info.id) {
                element = `id="${info.id}"`;
            } else if (info.name) {
                element = `name="${info.name}"`;
            } else if (info.tagName) {
                element = `${info.tagName.toLowerCase()}`;
                if (info.className) {
                    element += `.${info.className.replace(/\s+/g, '.')}`;
                }
            }
        }
        
        // Determine value
        let value = '';
        if (event.value !== undefined) {
            value = String(event.value).replace(/"/g, '""');
        }
        
        // Escape CSV special characters
        element = element.replace(/"/g, '""');
        
        // Add row
        csv += `${index + 1},"${timestamp}","${datetime}","${type}","${action}","${url}","${element}","${value}"\n`;
    });
    
    return csv;
}

/**
 * Generate HTML report from recording data
 * @param {Object} data - Recording data
 * @returns {string} Generated HTML report
 */
function generateHtmlReport(data) {
    if (!data || !data.events || !data.events.length) {
        return '<html><body><h1>No events recorded</h1></body></html>';
    }
    
    // Format date
    const formatDateTime = (timestamp) => {
        return new Date(timestamp).toLocaleString();
    };
    
    // Get session info
    const sessionStartTime = formatDateTime(data.startTime);
    const sessionEndTime = formatDateTime(data.endTime);
    const sessionDuration = Math.round((data.endTime - data.startTime) / 1000);
    
    // HTML template
    const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSTestForge Recording Report</title>
    <style>
        :root {
            --primary-color: #C54B8C;
            --primary-light: #e185b3;
            --primary-dark: #9c3a6e;
            --secondary-color: #4B8CC5;
            --text-color: #333;
            --bg-color: #f8f9fa;
            --card-bg: #fff;
            --border-color: #ddd;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1, h2, h3 {
            color: var(--primary-color);
        }
        
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .summary-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .summary-card h3 {
            margin-top: 0;
            font-size: 16px;
            color: var(--secondary-color);
        }
        
        .summary-card p {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0 0 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        th {
            background-color: var(--primary-light);
            color: white;
            font-weight: 600;
        }
        
        tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        tr:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .badge-click {
            background-color: #4caf50;
            color: white;
        }
        
        .badge-navigation {
            background-color: #2196f3;
            color: white;
        }
        
        .badge-input {
            background-color: #ff9800;
            color: white;
        }
        
        .badge-screenshot {
            background-color: #9c27b0;
            color: white;
        }
        
        .badge-assert {
            background-color: #f44336;
            color: white;
        }
        
        .badge-wait {
            background-color: #607d8b;
            color: white;
        }
        
        .badge-other {
            background-color: #9e9e9e;
            color: white;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            font-size: 0.9em;
            color: #666;
        }
        
        .timestamp {
            font-size: 0.8em;
            color: #666;
        }
        
        .element-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .screenshot {
            max-width: 100%;
            height: auto;
            margin: 10px 0;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            th, td {
                padding: 8px 10px;
            }
            
            .summary {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>CSTestForge Recording Report</h1>
            <p>Generated on ${formatDateTime(data.metadata.exportTime)}</p>
        </header>
        
        <section class="summary">
            <div class="summary-card">
                <h3>Session ID</h3>
                <p>${data.id}</p>
            </div>
            <div class="summary-card">
                <h3>Start Time</h3>
                <p>${sessionStartTime}</p>
            </div>
            <div class="summary-card">
                <h3>End Time</h3>
                <p>${sessionEndTime}</p>
            </div>
            <div class="summary-card">
                <h3>Duration</h3>
                <p>${sessionDuration} seconds</p>
            </div>
            <div class="summary-card">
                <h3>Total Events</h3>
                <p>${data.events.length}</p>
            </div>
            <div class="summary-card">
                <h3>Framework</h3>
                <p>${data.settings.framework.toUpperCase()}</p>
            </div>
            <div class="summary-card">
                <h3>Language</h3>
                <p>${data.settings.language}</p>
            </div>
            <div class="summary-card">
                <h3>Test Type</h3>
                <p>${data.settings.testType.toUpperCase()}</p>
            </div>
        </section>
        
        <h2>Events Timeline</h2>
        <table>
            <thead>
                <tr>
                    <th>#</th>
                    <th>Time</th>
                    <th>Type</th>
                    <th>Details</th>
                </tr>
            </thead>
            <tbody>
                ${data.events.map((event, index) => {
                    // Get event type
                    const type = event.type || 'OTHER';
                    
                    // Determine badge class
                    let badgeClass = 'badge-other';
                    if (type === 'CLICK') {
                        badgeClass = 'badge-click';
                    } else if (type === 'NAVIGATION') {
                        badgeClass = 'badge-navigation';
                    } else if (type === 'SET_VALUE' || type === 'INPUT_CHANGE') {
                        badgeClass = 'badge-input';
                    } else if (type === 'SCREENSHOT') {
                        badgeClass = 'badge-screenshot';
                    } else if (type === 'ASSERT') {
                        badgeClass = 'badge-assert';
                    } else if (type === 'WAIT') {
                        badgeClass = 'badge-wait';
                    }
                    
                    // Format event time
                    const eventTime = formatDateTime(event.timestamp);
                    
                    // Get element info
                    let elementDetails = '';
                    if (event.locator) {
                        if (event.locator.id) {
                            elementDetails += `<div class="element-info">ID: <span class="code">${event.locator.id}</span></div>`;
                        } else if (event.locator.css) {
                            elementDetails += `<div class="element-info">CSS: <span class="code">${event.locator.css}</span></div>`;
                        } else if (event.locator.xpath) {
                            elementDetails += `<div class="element-info">XPath: <span class="code">${event.locator.xpath}</span></div>`;
                        }
                    } else if (event.elementInfo) {
                        const info = event.elementInfo;
                        elementDetails += '<div class="element-info">';
                        if (info.tagName) {
                            elementDetails += `Tag: <span class="code">${info.tagName.toLowerCase()}</span><br>`;
                        }
                        if (info.id) {
                            elementDetails += `ID: <span class="code">${info.id}</span><br>`;
                        }
                        if (info.className) {
                            elementDetails += `Class: <span class="code">${info.className}</span><br>`;
                        }
                        elementDetails += '</div>';
                    }
                    
                    // Get action details
                    let details = '';
                    
                    if (type === 'NAVIGATION') {
                        details = `Navigated to: <span class="code">${event.url || ''}</span>`;
                        if (event.title) {
                            details += `<br>Page title: ${event.title}`;
                        }
                    } else if (type === 'CLICK') {
                        details = 'Clicked element:';
                        details += elementDetails;
                    } else if (type === 'SET_VALUE') {
                        details = `Set value: <span class="code">${event.value !== undefined ? event.value : ''}</span>`;
                        details += elementDetails;
                    } else if (type === 'SCREENSHOT') {
                        details = 'Screenshot captured';
                        if (event.dataUrl) {
                            details += `<br><img class="screenshot" src="${event.dataUrl}" alt="Screenshot">`;
                        }
                    } else if (type === 'EXECUTE_SCRIPT') {
                        details = `Executed script: <span class="code">${event.script.substring(0, 100)}${event.script.length > 100 ? '...' : ''}</span>`;
                    } else if (type === 'WAIT') {
                        details = `Waited for: ${event.condition || 'timeout'} - ${event.duration || 0}ms`;
                    } else if (type === 'ASSERT') {
                        details = `Assertion: ${event.assertion || ''} - ${event.result ? 'PASSED' : 'FAILED'}`;
                    } else {
                        details = JSON.stringify(event).substring(0, 200);
                        if (JSON.stringify(event).length > 200) {
                            details += '...';
                        }
                    }
                    
                    return `
                    <tr>
                        <td>${index + 1}</td>
                        <td>
                            ${eventTime}
                            <div class="timestamp">${event.timestamp}</div>
                        </td>
                        <td><span class="badge ${badgeClass}">${type}</span></td>
                        <td>${details}</td>
                    </tr>`;
                }).join('')}
            </tbody>
        </table>
        
        <footer>
            <p>Generated by CSTestForge Recorder ${data.metadata.version}</p>
        </footer>
    </div>
</body>
</html>`;

    return html;
}

/**
 * Code generator class
 */
class CodeGenerator {
    /**
     * Create a code generator
     * @param {Object} config - Generator configuration
     */
    constructor(config) {
        this.config = config;
        this.events = config.events || [];
        this.settings = config.settings || {};
        this.framework = config.settings.framework || 'selenium';
        this.language = config.settings.language || 'java';
        this.testType = config.settings.testType || 'testng';
    }
    
    /**
     * Generate code
     * @returns {Promise<Object>} Generated code
     */
    async generate() {
        console.debug('[CodeGenerator] Generating code', this.settings);
        
        // Select generator based on framework/language/testType
        const generatorKey = `${this.framework}_${this.language}_${this.testType}`;
        
        switch (generatorKey) {
            case 'selenium_java_testng':
                return this.generateSeleniumJavaTestNG();
                
            case 'selenium_java_bdd':
                return this.generateSeleniumJavaBDD();
                
            case 'selenium_typescript_testng':
                return this.generateSeleniumTypescriptTestNG();
                
            case 'selenium_typescript_bdd':
                return this.generateSeleniumTypescriptBDD();
                
            case 'playwright_java_testng':
                return this.generatePlaywrightJavaTestNG();
                
            case 'playwright_java_bdd':
                return this.generatePlaywrightJavaBDD();
                
            case 'playwright_typescript_testng':
                return this.generatePlaywrightTypescriptTestNG();
                
            case 'playwright_typescript_bdd':
                return this.generatePlaywrightTypescriptBDD();
                
            default:
                // Default to Selenium Java TestNG
                return this.generateSeleniumJavaTestNG();
        }
    }
    
    /**
     * Generate Selenium Java TestNG code
     * @returns {Promise<Object>} Generated code
     */
    async generateSeleniumJavaTestNG() {
        // Get test name from first navigation
        const firstNavigation = this.events.find(e => e.type === 'NAVIGATION');
        let testName = 'TestRecording';
        
        if (firstNavigation && firstNavigation.url) {
            try {
                const url = new URL(firstNavigation.url);
                testName = `Test${this.camelCase(url.hostname.replace(/\./g, '_'))}`;
            } catch (e) {
                // Ignore URL parsing errors
            }
        }
        
        // Generate page class
        const pageClass = this.generateSeleniumJavaPageClass(testName, firstNavigation);
        
        // Generate test class
        const testClass = this.generateSeleniumJavaTestClass(testName, pageClass.className);
        
        return {
            files: [
                {
                    name: `${testName}.java`,
                    content: testClass.content,
                    type: 'test',
                    language: 'java'
                },
                {
                    name: `${pageClass.className}.java`,
                    content: pageClass.content,
                    type: 'page',
                    language: 'java'
                }
            ],
            mainFile: `${testName}.java`,
            framework: this.framework,
            language: this.language,
            testType: this.testType
        };
    }
    
    /**
     * Generate Selenium Java page class
     * @param {string} testName - Test name
     * @param {Object} navigation - Navigation event
     * @returns {Object} Generated page class
     */
    generateSeleniumJavaPageClass(testName, navigation) {
        // Get base URL and title
        let baseUrl = '';
        let pageTitle = 'Page';
        
        if (navigation && navigation.url) {
            baseUrl = navigation.url;
            if (navigation.title) {
                pageTitle = navigation.title;
            } else {
                try {
                    const url = new URL(navigation.url);
                    pageTitle = url.hostname.split('.')[0];
                    pageTitle = this.capitalizeFirstLetter(pageTitle);
                } catch (e) {
                    // Ignore URL parsing errors
                }
            }
        }
        
        // Page class name
        const className = `${pageTitle.replace(/[^a-zA-Z0-9]/g, '')}Page`;
        
        // Collect elements from events
        const elements = new Map();
        
        for (const event of this.events) {
            if ((event.type === 'CLICK' || event.type === 'SET_VALUE' || event.type === 'ASSERT') &&
                 (event.locator || event.elementInfo)) {
                
                let elementInfo = event.elementInfo || {};
                let locator = event.locator || {};
                
                // Skip if no usable locator
                if (!locator.id && !locator.css && !locator.xpath && !locator.name && 
                    !elementInfo.id && !elementInfo.name && !elementInfo.xpath && !elementInfo.cssSelector) {
                    continue;
                }
                
                // Determine element name
                let elementName = '';
                
                if (event.type === 'CLICK') {
                    elementName = 'btn';
                } else if (event.type === 'SET_VALUE') {
                    elementName = 'input';
                } else {
                    elementName = 'element';
                }
                
                // Add identifier if available
                if (locator.id || elementInfo.id) {
                    elementName += this.camelCase(locator.id || elementInfo.id);
                } else if (locator.name || elementInfo.name) {
                    elementName += this.camelCase(locator.name || elementInfo.name);
                } else if (elementInfo.tagName) {
                    elementName += this.capitalizeFirstLetter(elementInfo.tagName.toLowerCase());
                    
                    if (elementInfo.textContent) {
                        // Add first few words of text
                        const text = elementInfo.textContent.trim().split(/\s+/).slice(0, 2).join('');
                        if (text) {
                            elementName += this.camelCase(text);
                        }
                    }
                } else {
                    // Generate a unique name
                    elementName += `Element${elements.size + 1}`;
                }
                
                // Create locator string
                let locatorString = '';
                
                if (locator.id || elementInfo.id) {
                    locatorString = `By.id("${locator.id || elementInfo.id}")`;
                } else if (locator.name || elementInfo.name) {
                    locatorString = `By.name("${locator.name || elementInfo.name}")`;
                } else if (locator.css || elementInfo.cssSelector) {
                    locatorString = `By.cssSelector("${(locator.css || elementInfo.cssSelector).replace(/"/g, '\\"')}")`;
                } else if (locator.xpath || elementInfo.xpath) {
                    locatorString = `By.xpath("${(locator.xpath || elementInfo.xpath).replace(/"/g, '\\"')}")`;
                }
                
                // Add element if not already added
                if (locatorString && !elements.has(elementName)) {
                    elements.set(elementName, {
                        name: elementName,
                        locator: locatorString,
                        type: event.type
                    });
                }
            }
        }
        
        // Generate page class content
        let content = `package com.cstestforge.tests;\n\n`;
        content += `import org.openqa.selenium.By;\n`;
        content += `import org.openqa.selenium.WebDriver;\n`;
        content += `import org.openqa.selenium.WebElement;\n`;
        content += `import org.openqa.selenium.support.ui.ExpectedConditions;\n`;
        content += `import org.openqa.selenium.support.ui.WebDriverWait;\n\n`;
        
        content += `/**\n`;
        content += ` * Page Object for ${pageTitle}\n`;
        content += ` * Generated by CSTestForge Recorder\n`;
        content += ` */\n`;
        content += `public class ${className} {\n\n`;
        
        // Fields
        content += `    private final WebDriver driver;\n`;
        content += `    private final WebDriverWait wait;\n\n`;
        
        if (baseUrl) {
            content += `    private static final String PAGE_URL = "${baseUrl}";\n\n`;
        }
        
        // Element locators
        for (const [name, element] of elements.entries()) {
            content += `    private static final By ${element.name.toUpperCase()} = ${element.locator};\n`;
        }
        
        content += `\n`;
        
        // Constructor
        content += `    /**\n`;
        content += `     * Constructor\n`;
        content += `     * @param driver WebDriver instance\n`;
        content += `     */\n`;
        content += `    public ${className}(WebDriver driver) {\n`;
        content += `        this.driver = driver;\n`;
        content += `        this.wait = new WebDriverWait(driver, 10);\n`;
        content += `    }\n\n`;
        
        // Navigation method
        if (baseUrl) {
            content += `    /**\n`;
            content += `     * Navigate to page\n`;
            content += `     * @return this page object\n`;
            content += `     */\n`;
            content += `    public ${className} navigateTo() {\n`;
            content += `        driver.get(PAGE_URL);\n`;
            content += `        return this;\n`;
            content += `    }\n\n`;
        }
        
        // Element methods
        for (const [name, element] of elements.entries()) {
            const methodName = element.name;
            
            // Getter method
            content += `    /**\n`;
            content += `     * Get ${methodName} element\n`;
            content += `     * @return WebElement\n`;
            content += `     */\n`;
            content += `    public WebElement get${this.capitalizeFirstLetter(methodName)}() {\n`;
            content += `        return wait.until(ExpectedConditions.presenceOfElementLocated(${methodName.toUpperCase()}));\n`;
            content += `    }\n\n`;
            
            // Action methods
            if (element.type === 'CLICK') {
                content += `    /**\n`;
                content += `     * Click ${methodName}\n`;
                content += `     * @return this page object\n`;
                content += `     */\n`;
                content += `    public ${className} click${this.capitalizeFirstLetter(methodName)}() {\n`;
                content += `        wait.until(ExpectedConditions.elementToBeClickable(${methodName.toUpperCase()})).click();\n`;
                content += `        return this;\n`;
                content += `    }\n\n`;
            } else if (element.type === 'SET_VALUE') {
                content += `    /**\n`;
                content += `     * Set value in ${methodName}\n`;
                content += `     * @param value value to set\n`;
                content += `     * @return this page object\n`;
                content += `     */\n`;
                content += `    public ${className} set${this.capitalizeFirstLetter(methodName)}(String value) {\n`;
                content += `        WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(${methodName.toUpperCase()}));\n`;
                content += `        element.clear();\n`;
                content += `        element.sendKeys(value);\n`;
                content += `        return this;\n`;
                content += `    }\n\n`;
            }
        }
        
        // Close class
        content += `}\n`;
        
        return {
            className,
            content
        };
    }
    
    /**
     * Generate Selenium Java TestNG test class
     * @param {string} testName - Test name
     * @param {string} pageClassName - Page class name
     * @returns {Object} Generated test class
     */
    generateSeleniumJavaTestClass(testName, pageClassName) {
        // Generate test content
        let content = `package com.cstestforge.tests;\n\n`;
        content += `import org.openqa.selenium.WebDriver;\n`;
        content += `import org.openqa.selenium.chrome.ChromeDriver;\n`;
        content += `import org.testng.annotations.AfterClass;\n`;
        content += `import org.testng.annotations.BeforeClass;\n`;
        content += `import org.testng.annotations.Test;\n\n`;
        
        content += `/**\n`;
        content += ` * Selenium WebDriver test generated by CSTestForge Recorder\n`;
        content += ` */\n`;
        content += `public class ${testName} {\n\n`;
        
        // Fields
        content += `    private WebDriver driver;\n`;
        content += `    private ${pageClassName} page;\n\n`;
        
        // Setup
        content += `    @BeforeClass\n`;
        content += `    public void setUp() {\n`;
        content += `        // Set up WebDriver\n`;
        content += `        driver = new ChromeDriver();\n`;
        content += `        driver.manage().window().maximize();\n`;
        content += `        \n`;
        content += `        // Initialize page object\n`;
        content += `        page = new ${pageClassName}(driver);\n`;
        content += `    }\n\n`;
        
        // Test method
        content += `    @Test\n`;
        content += `    public void testRecordedActions() {\n`;
        content += `        // Navigate to page\n`;
        content += `        page.navigateTo();\n`;
        
        // Process events
        for (const event of this.events) {
            if (event.type === 'CLICK' && (event.locator || event.elementInfo)) {
                const element = this.getElementName(event);
                if (element) {
                    content += `        \n        // Click element\n`;
                    content += `        page.click${this.capitalizeFirstLetter(element)}();\n`;
                }
            } else if (event.type === 'SET_VALUE' && (event.locator || event.elementInfo)) {
                const element = this.getElementName(event);
                if (element && event.value !== undefined) {
                    content += `        \n        // Set value\n`;
                    content += `        page.set${this.capitalizeFirstLetter(element)}("${event.value.toString().replace(/"/g, '\\"')}");\n`;
                }
            } else if (event.type === 'WAIT') {
                content += `        \n        // Wait\n`;
                content += `        try { Thread.sleep(${event.duration || 1000}); } catch (Exception e) {}\n`;
            } else if (event.type === 'EXECUTE_SCRIPT' && event.script) {
                content += `        \n        // Execute JavaScript\n`;
                content += `        ((org.openqa.selenium.JavascriptExecutor) driver).executeScript("${event.script.replace(/"/g, '\\"')}");\n`;
            }
        }
        
        content += `    }\n\n`;
        
        // Teardown
        content += `    @AfterClass\n`;
        content += `    public void tearDown() {\n`;
        content += `        if (driver != null) {\n`;
        content += `            driver.quit();\n`;
        content += `        }\n`;
        content += `    }\n`;
        
        // Close class
        content += `}\n`;
        
        return {
            content
        };
    }
    
    /**
     * Generate Selenium Java BDD code
     * @returns {Promise<Object>} Generated code
     */
    async generateSeleniumJavaBDD() {
        // Get test name from first navigation
        const firstNavigation = this.events.find(e => e.type === 'NAVIGATION');
        let testName = 'TestRecording';
        let featureName = 'Recording';
        
        if (firstNavigation && firstNavigation.url) {
            try {
                const url = new URL(firstNavigation.url);
                testName = `Test${this.camelCase(url.hostname.replace(/\./g, '_'))}`;
                featureName = url.hostname.split('.')[0];
                featureName = this.capitalizeFirstLetter(featureName);
            } catch (e) {
                // Ignore URL parsing errors
            }
        }
        
        // Generate page class
        const pageClass = this.generateSeleniumJavaPageClass(testName, firstNavigation);
        
        // Generate step definitions class
        const stepDefsClass = this.generateSeleniumJavaStepDefs(testName, pageClass.className);
        
        // Generate feature file
        const featureFile = this.generateFeatureFile(featureName);
        
        return {
            files: [
                {
                    name: `${testName}Steps.java`,
                    content: stepDefsClass.content,
                    type: 'steps',
                    language: 'java'
                },
                {
                    name: `${pageClass.className}.java`,
                    content: pageClass.content,
                    type: 'page',
                    language: 'java'
                },
                {
                    name: `${featureName.toLowerCase()}.feature`,
                    content: featureFile.content,
                    type: 'feature',
                    language: 'gherkin'
                }
            ],
            mainFile: `${featureName.toLowerCase()}.feature`,
            framework: this.framework,
            language: this.language,
            testType: this.testType
        };
    }
    
    /**
     * Generate Selenium Java step definitions
     * @param {string} testName - Test name
     * @param {string} pageClassName - Page class name
     * @returns {Object} Generated step definitions
     */
    generateSeleniumJavaStepDefs(testName, pageClassName) {
        // Generate content
        let content = `package com.cstestforge.tests.steps;\n\n`;
        content += `import io.cucumber.java.After;\n`;
        content += `import io.cucumber.java.Before;\n`;
        content += `import io.cucumber.java.en.Given;\n`;
        content += `import io.cucumber.java.en.When;\n`;
        content += `import io.cucumber.java.en.Then;\n`;
        content += `import org.openqa.selenium.WebDriver;\n`;
        content += `import org.openqa.selenium.chrome.ChromeDriver;\n\n`;
        content += `import com.cstestforge.tests.${pageClassName};\n\n`;
        
        content += `/**\n`;
        content += ` * Step definitions for ${testName}\n`;
        content += ` * Generated by CSTestForge Recorder\n`;
        content += ` */\n`;
        content += `public class ${testName}Steps {\n\n`;
        
        // Fields
        content += `    private WebDriver driver;\n`;
        content += `    private ${pageClassName} page;\n\n`;
        
        // Setup
        content += `    @Before\n`;
        content += `    public void setUp() {\n`;
        content += `        // Set up WebDriver\n`;
        content += `        driver = new ChromeDriver();\n`;
        content += `        driver.manage().window().maximize();\n`;
        content += `        \n`;
        content += `        // Initialize page object\n`;
        content += `        page = new ${pageClassName}(driver);\n`;
        content += `    }\n\n`;
        
        // Navigation step
        content += `    @Given("I navigate to the website")\n`;
        content += `    public void i_navigate_to_the_website() {\n`;
        content += `        page.navigateTo();\n`;
        content += `    }\n\n`;
        
        // Click steps
        const clickElements = new Set();
        for (const event of this.events) {
            if (event.type === 'CLICK' && (event.locator || event.elementInfo)) {
                const element = this.getElementName(event);
                if (element && !clickElements.has(element)) {
                    clickElements.add(element);
                    
                    const elementDisplay = this.formatElementNameForDisplay(element);
                    content += `    @When("I click the ${elementDisplay}")\n`;
                    content += `    public void i_click_the_${element.toLowerCase()}() {\n`;
                    content += `        page.click${this.capitalizeFirstLetter(element)}();\n`;
                    content += `    }\n\n`;
                }
            }
        }
        
        // Input steps
        const inputElements = new Set();
        for (const event of this.events) {
            if (event.type === 'SET_VALUE' && (event.locator || event.elementInfo)) {
                const element = this.getElementName(event);
                if (element && !inputElements.has(element)) {
                    inputElements.add(element);
                    
                    const elementDisplay = this.formatElementNameForDisplay(element);
                    content += `    @When("I enter {string} in the ${elementDisplay}")\n`;
                    content += `    public void i_enter_text_in_the_${element.toLowerCase()}(String text) {\n`;
                    content += `        page.set${this.capitalizeFirstLetter(element)}(text);\n`;
                    content += `    }\n\n`;
                }
            }
        }
        
        // Wait step
        content += `    @When("I wait for {int} milliseconds")\n`;
        content += `    public void i_wait_for_milliseconds(Integer ms) {\n`;
        content += `        try { Thread.sleep(ms); } catch (Exception e) {}\n`;
        content += `    }\n\n`;
        
        // JavaScript step
        content += `    @When("I execute JavaScript {string}")\n`;
        content += `    public void i_execute_javascript(String script) {\n`;
        content += `        ((org.openqa.selenium.JavascriptExecutor) driver).executeScript(script);\n`;
        content += `    }\n\n`;
        
        // Teardown
        content += `    @After\n`;
        content += `    public void tearDown() {\n`;
        content += `        if (driver != null) {\n`;
        content += `            driver.quit();\n`;
        content += `        }\n`;
        content += `    }\n`;
        
        // Close class
        content += `}\n`;
        
        return {
            content
        };
    }
    
    /**
     * Generate feature file
     * @param {string} featureName - Feature name
     * @returns {Object} Generated feature file
     */
    generateFeatureFile(featureName) {
        // Generate content
        let content = `Feature: ${featureName} Website\n`;
        content += `  As a user\n`;
        content += `  I want to interact with the ${featureName} website\n`;
        content += `  So that I can use its functionality\n\n`;
        
        content += `Scenario: Recorded test scenario\n`;
        content += `  Given I navigate to the website\n`;
        
        // Process events
        for (const event of this.events) {
            if (event.type === 'CLICK' && (event.locator || event.elementInfo)) {
                const element = this.getElementName(event);
                if (element) {
                    const elementDisplay = this.formatElementNameForDisplay(element);
                    content += `  When I click the ${elementDisplay}\n`;
                }
            } else if (event.type === 'SET_VALUE' && (event.locator || event.elementInfo)) {
                const element = this.getElementName(event);
                if (element && event.value !== undefined) {
                    const elementDisplay = this.formatElementNameForDisplay(element);
                    content += `  When I enter "${event.value.toString().replace(/"/g, '\\"')}" in the ${elementDisplay}\n`;
                }
            } else if (event.type === 'WAIT') {
                content += `  When I wait for ${event.duration || 1000} milliseconds\n`;
            } else if (event.type === 'EXECUTE_SCRIPT' && event.script) {
                content += `  When I execute JavaScript "${event.script.replace(/"/g, '\\"')}"\n`;
            }
        }
        
        return {
            content
        };
    }
    
    /**
     * Generate Selenium TypeScript TestNG code
     * @returns {Promise<Object>} Generated code
     */
    async generateSeleniumTypescriptTestNG() {
        // Get test name from first navigation
        const firstNavigation = this.events.find(e => e.type === 'NAVIGATION');
        let testName = 'TestRecording';
        
        if (firstNavigation && firstNavigation.url) {
            try {
                const url = new URL(firstNavigation.url);
                testName = `Test${this.camelCase(url.hostname.replace(/\./g, '_'))}`;
            } catch (e) {
                // Ignore URL parsing errors
            }
        }
        
        // Generate page class
        const pageClass = this.generateSeleniumTsPageClass(testName, firstNavigation);
        
        // Generate test class
        const testClass = this.generateSeleniumTsTestClass(testName, pageClass.className);
        
        return {
            files: [
                {
                    name: `${testName}.ts`,
                    content: testClass.content,
                    type: 'test',
                    language: 'typescript'
                },
                {
                    name: `${pageClass.className}.ts`,
                    content: pageClass.content,
                    type: 'page',
                    language: 'typescript'
                }
            ],
            mainFile: `${testName}.ts`,
            framework: this.framework,
            language: this.language,
            testType: this.testType
        };
    }
    
    /**
     * Generate Selenium TypeScript page class
     * @param {string} testName - Test name
     * @param {Object} navigation - Navigation event
     * @returns {Object} Generated page class
     */
    generateSeleniumTsPageClass(testName, navigation) {
        // Get base URL and title
        let baseUrl = '';
        let pageTitle = 'Page';
        
        if (navigation && navigation.url) {
            baseUrl = navigation.url;
            if (navigation.title) {
                pageTitle = navigation.title;
            } else {
                try {
                    const url = new URL(navigation.url);
                    pageTitle = url.hostname.split('.')[0];
                    pageTitle = this.capitalizeFirstLetter(pageTitle);
                } catch (e) {
                    // Ignore URL parsing errors
                }
            }
        }
        
        // Page class name
        const className = `${pageTitle.replace(/[^a-zA-Z0-9]/g, '')}Page`;
        
        // Collect elements from events
        const elements = new Map();
        
        for (const event of this.events) {
            if ((event.type === 'CLICK' || event.type === 'SET_VALUE' || event.type === 'ASSERT') &&
                 (event.locator || event.elementInfo)) {
                
                let elementInfo = event.elementInfo || {};
                let locator = event.locator || {};
                
                // Skip if no usable locator
                if (!locator.id && !locator.css && !locator.xpath && !locator.name && 
                    !elementInfo.id && !elementInfo.name && !elementInfo.xpath && !elementInfo.cssSelector) {
                    continue;
                }
                
                // Determine element name
                let elementName = '';
                
                if (event.type === 'CLICK') {
                    elementName = 'btn';
                } else if (event.type === 'SET_VALUE') {
                    elementName = 'input';
                } else {
                    elementName = 'element';
                }
                
                // Add identifier if available
                if (locator.id || elementInfo.id) {
                    elementName += this.camelCase(locator.id || elementInfo.id);
                } else if (locator.name || elementInfo.name) {
                    elementName += this.camelCase(locator.name || elementInfo.name);
                } else if (elementInfo.tagName) {
                    elementName += this.capitalizeFirstLetter(elementInfo.tagName.toLowerCase());
                    
                    if (elementInfo.textContent) {
                        // Add first few words of text
                        const text = elementInfo.textContent.trim().split(/\s+/).slice(0, 2).join('');
                        if (text) {
                            elementName += this.camelCase(text);
                        }
                    }
                } else {
                    // Generate a unique name
                    elementName += `Element${elements.size + 1}`;
                }
                
                // Create locator string
                let locatorString = '';
                
                if (locator.id || elementInfo.id) {
                    locatorString = `By.id("${locator.id || elementInfo.id}")`;
                } else if (locator.name || elementInfo.name) {
                    locatorString = `By.name("${locator.name || elementInfo.name}")`;
                } else if (locator.css || elementInfo.cssSelector) {
                    locatorString = `By.css("${(locator.css || elementInfo.cssSelector).replace(/"/g, '\\"')}")`;
                } else if (locator.xpath || elementInfo.xpath) {
                    locatorString = `By.xpath("${(locator.xpath || elementInfo.xpath).replace(/"/g, '\\"')}")`;
                }
                
                // Add element if not already added
                if (locatorString && !elements.has(elementName)) {
                    elements.set(elementName, {
                        name: elementName,
                        locator: locatorString,
                        type: event.type
                    });
                }
            }
        }
        
        // Generate page class content
        let content = `import { WebDriver, WebElement, By, until } from 'selenium-webdriver';\n\n`;
        
        content += `/**\n`;
        content += ` * Page Object for ${pageTitle}\n`;
        content += ` * Generated by CSTestForge Recorder\n`;
        content += ` */\n`;
        content += `export class ${className} {\n`;
        
        // Fields
        if (baseUrl) {
            content += `    private static readonly PAGE_URL: string = "${baseUrl}";\n`;
        }
        
        // Element locators
        for (const [name, element] of elements.entries()) {
            content += `    private static readonly ${element.name.toUpperCase()}: By = ${element.locator};\n`;
        }
        
        content += `\n`;
        
        // Constructor
        content += `    /**\n`;
        content += `     * Constructor\n`;
        content += `     * @param driver WebDriver instance\n`;
        content += `     */\n`;
        content += `    constructor(private driver: WebDriver) {}\n\n`;
        
        // Navigation method
        if (baseUrl) {
            content += `    /**\n`;
            content += `     * Navigate to page\n`;
            content += `     * @returns Promise resolving to this page object\n`;
            content += `     */\n`;
            content += `    public async navigateTo(): Promise<${className}> {\n`;
            content += `        await this.driver.get(${className}.PAGE_URL);\n`;
            content += `        return this;\n`;
            content += `    }\n\n`;
        }
        
        // Element methods
        for (const [name, element] of elements.entries()) {
            const methodName = element.name;
            
            // Getter method
            content += `    /**\n`;
            content += `     * Get ${methodName} element\n`;
            content += `     * @returns Promise resolving to WebElement\n`;
            content += `     */\n`;
            content += `    public async get${this.capitalizeFirstLetter(methodName)}(): Promise<WebElement> {\n`;
            content += `        return this.driver.wait(until.elementLocated(${className}.${methodName.toUpperCase()}), 10000);\n`;
            content += `    }\n\n`;
            
            // Action methods
            if (element.type === 'CLICK') {
                content += `    /**\n`;
                content += `     * Click ${methodName}\n`;
                content += `     * @returns Promise resolving to this page object\n`;
                content += `     */\n`;
                content += `    public async click${this.capitalizeFirstLetter(methodName)}(): Promise<${className}> {\n`;
                content += `        const element = await this.driver.wait(until.elementLocated(${className}.${methodName.toUpperCase()}), 10000);\n`;
                content += `        await this.driver.wait(until.elementIsVisible(element), 10000);\n`;
                content += `        await element.click();\n`;
                content += `        return this;\n`;
                content += `    }\n\n`;
            } else if (element.type === 'SET_VALUE') {
                content += `    /**\n`;
                content += `     * Set value in ${methodName}\n`;
                content += `     * @param value value to set\n`;
                content += `     * @returns Promise resolving to this page object\n`;
                content += `     */\n`;
                content += `    public async set${this.capitalizeFirstLetter(methodName)}(value: string): Promise<${className}> {\n`;
                content += `        const element = await this.driver.wait(until.elementLocated(${className}.${methodName.toUpperCase()}), 10000);\n`;
                content += `        await element.clear();\n`;
                content += `        await element.sendKeys(value);\n`;
                content += `        return this;\n`;
                content += `    }\n\n`;
            }
        }
        
        // Close class
        content += `}\n`;
        
        return {
            className,
            content
        };
    }
    
    /**
     * Generate Selenium TypeScript test class
     * @param {string} testName - Test name
     * @param {string} pageClassName - Page class name
     * @returns {Object} Generated test class
     */
    generateSeleniumTsTestClass(testName, pageClassName) {
        // Generate test content
        let content = `import { WebDriver, Builder } from 'selenium-webdriver';\n`;
        content += `import { ${pageClassName} } from './${pageClassName}';\n\n`;
        
        content += `/**\n`;
        content += ` * Selenium WebDriver test generated by CSTestForge Recorder\n`;
        content += ` */\n`;
        content += `describe('${testName}', () => {\n`;
        content += `    let driver: WebDriver;\n`;
        content += `    let page: ${pageClassName};\n\n`;
        
        // Setup
        content += `    beforeAll(async () => {\n`;
        content += `        // Set up WebDriver\n`;
        content += `        driver = await new Builder().forBrowser('chrome').build();\n`;
        content += `        \n`;
        content += `        // Initialize page object\n`;
        content += `        page = new ${pageClassName}(driver);\n`;
        content += `    });\n\n`;
        
        // Test method
        content += `    test('Recorded actions', async () => {\n`;
        content += `        // Navigate to page\n`;
        content += `        await page.navigateTo();\n`;
        
        // Process events
        for (const event of this.events) {
            if (event.type === 'CLICK' && (event.locator || event.elementInfo)) {
                const element = this.getElementName(event);
                if (element) {
                    content += `        \n        // Click element\n`;
                    content += `        await page.click${this.capitalizeFirstLetter(element)}();\n`;
                }
            } else if (event.type === 'SET_VALUE' && (event.locator || event.elementInfo)) {
                const element = this.getElementName(event);
                if (element && event.value !== undefined) {
                    content += `        \n        // Set value\n`;
                    content += `        await page.set${this.capitalizeFirstLetter(element)}("${event.value.toString().replace(/"/g, '\\"')}");\n`;
                }
            } else if (event.type === 'WAIT') {
                content += `        \n        // Wait\n`;
                content += `        await new Promise(r => setTimeout(r, ${event.duration || 1000}));\n`;
            } else if (event.type === 'EXECUTE_SCRIPT' && event.script) {
                content += `        \n        // Execute JavaScript\n`;
                content += `        await driver.executeScript("${event.script.replace(/"/g, '\\"')}");\n`;
            }
        }
        
        content += `    });\n\n`;
        
        // Teardown
        content += `    afterAll(async () => {\n`;
        content += `        // Close browser\n`;
        content += `        if (driver) {\n`;
        content += `            await driver.quit();\n`;
        content += `        }\n`;
        content += `    });\n`;
        
        // Close describe
        content += `});\n`;
        
        return {
            content
        };
    }
    
    /**
     * Generate Selenium TypeScript BDD code
     * @returns {Promise<Object>} Generated code
     */
    async generateSeleniumTypescriptBDD() {
        // Get test name from first navigation
        const firstNavigation = this.events.find(e => e.type === 'NAVIGATION');
        let testName = 'TestRecording';
        let featureName = 'Recording';
        
        if (firstNavigation && firstNavigation.url) {
            try {
                const url = new URL(firstNavigation.url);
                testName = `Test${this.camelCase(url.hostname.replace(/\./g, '_'))}`;
                featureName = url.hostname.split('.')[0];
                featureName = this.capitalizeFirstLetter(featureName);
            } catch (e) {
                // Ignore URL parsing errors
            }
        }
        
        // Generate page class
        const pageClass = this.generateSeleniumTsPageClass(testName, firstNavigation);
        
        // Generate step definitions class
        const stepDefsClass = this.generateSeleniumTsStepDefs(testName, pageClass.className);
        
        // Generate feature file
        const featureFile = this.generateFeatureFile(featureName);
        
        return {
            files: [
                {
                    name: `${testName}Steps.ts`,
                    content: stepDefsClass.content,
                    type: 'steps',
                    language: 'typescript'
                },
                {
                    name: `${pageClass.className}.ts`,
                    content: pageClass.content,
                    type: 'page',
                    language: 'typescript'
                },
                {
                    name: `${featureName.toLowerCase()}.feature`,
                    content: featureFile.content,
                    type: 'feature',
                    language: 'gherkin'
                }
            ],
            mainFile: `${featureName.toLowerCase()}.feature`,
            framework: this.framework,
            language: this.language,
            testType: this.testType
        };
    }
    
    /**
 * Generate Selenium TypeScript step definitions
 * @param {string} testName - Test name
 * @param {string} pageClassName - Page class name
 * @returns {Object} Generated step definitions
 */
generateSeleniumTsStepDefs(testName, pageClassName) {
    // Generate content
    let content = `import { Given, When, Then, Before, After } from '@cucumber/cucumber';
import { WebDriver, Builder } from 'selenium-webdriver';
import { ${pageClassName} } from './${pageClassName}';

/**
 * Step definitions for ${testName}
 * Generated by CSTestForge Recorder
 */

let driver: WebDriver;
let page: ${pageClassName};

Before(async function() {
    // Set up WebDriver
    driver = await new Builder().forBrowser('chrome').build();
    
    // Initialize page object
    page = new ${pageClassName}(driver);
});

Given('I navigate to the website', async function() {
    await page.navigateTo();
});

// Click steps
${this.getClickElements().map(element => {
    const elementDisplay = this.formatElementNameForDisplay(element);
    return `When('I click the ${elementDisplay}', async function() {
    await page.click${this.capitalizeFirstLetter(element)}();
});`
}).join('\n\n')}

// Input steps
${this.getInputElements().map(element => {
    const elementDisplay = this.formatElementNameForDisplay(element);
    return `When('I enter {string} in the ${elementDisplay}', async function(text: string) {
    await page.set${this.capitalizeFirstLetter(element)}(text);
});`
}).join('\n\n')}

When('I wait for {int} milliseconds', async function(ms: number) {
    await new Promise(resolve => setTimeout(resolve, ms));
});

When('I execute JavaScript {string}', async function(script: string) {
    await driver.executeScript(script);
});

After(async function() {
    // Close browser
    if (driver) {
        await driver.quit();
    }
});`;

    return {
        content
    };
}

/**
 * Get click elements from recorded events
 * @returns {string[]} Array of element names
 */
getClickElements() {
    const clickElements = new Set();
    
    for (const event of this.events) {
        if (event.type === 'CLICK' && (event.locator || event.elementInfo)) {
            const element = this.getElementName(event);
            if (element) {
                clickElements.add(element);
            }
        }
    }
    
    return Array.from(clickElements);
}

/**
 * Get input elements from recorded events
 * @returns {string[]} Array of element names
 */
getInputElements() {
    const inputElements = new Set();
    
    for (const event of this.events) {
        if (event.type === 'SET_VALUE' && (event.locator || event.elementInfo)) {
            const element = this.getElementName(event);
            if (element) {
                inputElements.add(element);
            }
        }
    }
    
    return Array.from(inputElements);
}


recorder/firefox/firefox-injector.js
---------------------------------------------

/**
 * CSTestForge Firefox Injector
 * 
 * This module provides Firefox-specific injection capabilities for the CSTestForge recorder.
 * It handles browser detection, feature compatibility, DOM manipulation, and event capturing
 * tailored specifically for Firefox browsers.
 * 
 * @module firefox-injector
 * @requires base-injector
 * @requires event-capture
 * @requires dom-observer
 * @requires element-identifier
 * @copyright CSTestForge 2025
 */

(function() {
    'use strict';

    /**
     * Firefox-specific implementation of the CSTestForge injector
     */
    class FirefoxInjector {
        /**
         * Creates a new FirefoxInjector instance
         * @param {Object} config - Configuration options
         */
        constructor(config = {}) {
            // Default configuration settings
            this.config = Object.assign({
                captureClicks: true,
                captureKeyboard: true,
                captureSelects: true,
                captureNavigation: true,
                captureHover: true,
                captureScreenshots: true,
                captureConsoleOutput: true,
                captureNetwork: true,
                polyfillFeatures: true,
                useShadowDOM: false,
                isolateStyles: true,
                extensionMode: false,
                debugMode: false,
                injectionPoint: 'body',
                eventThrottleMs: 50
            }, config);

            // Communication channel for sending events
            this.port = null;
            
            // Firefox-specific feature detection results
            this.features = {
                supportsExtensionAPI: this._checkExtensionSupport(),
                supportsShadowDOM: !!HTMLElement.prototype.attachShadow,
                supportsPromises: typeof Promise !== 'undefined',
                supportsModules: this._checkModuleSupport(),
                supportsContentScripts: this._checkContentScriptSupport(),
                supportsMutationObserver: typeof MutationObserver !== 'undefined',
                supportsIntersectionObserver: typeof IntersectionObserver !== 'undefined',
                supportsPerformanceAPI: this._checkPerformanceAPISupport(),
                supportsWebSockets: typeof WebSocket !== 'undefined',
                supportsServiceWorkers: 'serviceWorker' in navigator,
                supportsSessionStorage: this._checkSessionStorageSupport(),
                supportsBrowserStorage: this._checkBrowserStorageSupport(),
                isHeadless: this._checkIfHeadless(),
                isPrivateBrowsing: this._checkIfPrivateBrowsing(),
                hasDevToolsOpen: this._checkDevToolsOpen()
            };
            
            // Store for mutation observer and event listeners
            this.observers = {};
            this.listeners = {};
            
            // Namespace to prevent collision with application code
            this.namespace = '__CSTestForge_' + Math.random().toString(36).substring(2, 15);
            
            // Initialization state
            this.isInitialized = false;
        }
        
        /**
         * Initialize the Firefox injection system
         * @returns {Promise<boolean>} Success indicator
         */
        async initialize() {
            if (this.isInitialized) {
                return true;
            }
            
            try {
                this._log('Initializing Firefox injector...');
                
                // 1. Set up browser detection
                await this._detectBrowserDetails();
                
                // 2. Inject necessary polyfills for Firefox if needed
                if (this.config.polyfillFeatures) {
                    await this._injectPolyfills();
                }
                
                // 3. Set up communication channel
                await this._setupCommunication();
                
                // 4. Inject CSS and UI elements if needed
                await this._injectStyles();
                
                // 5. Setup event listeners and DOM observers
                await this._setupEventCapture();
                
                // 6. Initialize network and console monitoring
                if (this.config.captureConsoleOutput) {
                    this._setupConsoleCapture();
                }
                
                if (this.config.captureNetwork) {
                    this._setupNetworkCapture();
                }
                
                // 7. Register commands
                this._registerCommands();
                
                this.isInitialized = true;
                this._log('Firefox injector initialized successfully');
                
                return true;
            } catch (error) {
                this._error('Failed to initialize Firefox injector', error);
                return false;
            }
        }
        
        /**
         * Clean up resources and remove injected elements
         */
        destroy() {
            if (!this.isInitialized) {
                return;
            }
            
            try {
                this._log('Destroying Firefox injector...');
                
                // 1. Clean up event listeners
                this._removeAllEventListeners();
                
                // 2. Disconnect all observers
                this._disconnectAllObservers();
                
                // 3. Remove injected elements
                this._removeInjectedElements();
                
                // 4. Restore console functionality
                this._restoreConsole();
                
                // 5. Close communication channel
                this._closeCommunication();
                
                this.isInitialized = false;
                this._log('Firefox injector destroyed successfully');
            } catch (error) {
                this._error('Error destroying Firefox injector', error);
            }
        }
        
        /**
         * Inject a script into the page context
         * @param {string} scriptContent - JavaScript to inject
         * @param {boolean} asModule - Whether to inject as a module
         * @returns {Promise<any>} Result of script execution
         */
        injectScript(scriptContent, asModule = false) {
            return new Promise((resolve, reject) => {
                try {
                    const script = document.createElement('script');
                    script.dataset.csTestForge = 'injected-script';
                    
                    if (asModule && this.features.supportsModules) {
                        script.type = 'module';
                    }
                    
                    // Create a unique ID for this script execution
                    const executionId = 'csExec_' + Math.random().toString(36).substring(2, 15);
                    
                    // Set up listener for the result
                    const listener = (event) => {
                        if (event.data && 
                            event.data.type === 'CS_SCRIPT_RESULT' && 
                            event.data.executionId === executionId) {
                            
                            window.removeEventListener('message', listener);
                            
                            if (event.data.error) {
                                reject(new Error(event.data.error));
                            } else {
                                resolve(event.data.result);
                            }
                        }
                    };
                    
                    window.addEventListener('message', listener);
                    
                    // Wrap the script content to capture its result
                    script.textContent = `
                        (function() {
                            try {
                                const result = (function() {
                                    ${scriptContent}
                                })();
                                
                                window.postMessage({
                                    type: 'CS_SCRIPT_RESULT',
                                    executionId: '${executionId}',
                                    result: result
                                }, '*');
                            } catch (err) {
                                window.postMessage({
                                    type: 'CS_SCRIPT_RESULT',
                                    executionId: '${executionId}',
                                    error: err.message
                                }, '*');
                            }
                        })();
                    `;
                    
                    document.head.appendChild(script);
                    
                    // Cleanup
                    setTimeout(() => {
                        if (script.parentNode) {
                            script.parentNode.removeChild(script);
                        }
                    }, 100);
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        /**
         * Creates a shadow root for isolating injected elements
         * @param {Element} element - Element to attach shadow root to
         * @returns {ShadowRoot} The shadow root
         */
        createShadowRoot(element) {
            if (!this.features.supportsShadowDOM) {
                this._warn('ShadowDOM not supported in this browser');
                return element;
            }
            
            // Using open mode to allow accessibility of shadow DOM content
            const shadowRoot = element.attachShadow({ mode: 'open' });
            return shadowRoot;
        }
        
        /**
         * Sends an event to the recorder application
         * @param {string} eventType - Type of event
         * @param {Object} data - Event data
         */
        sendEvent(eventType, data = {}) {
            if (!this.port) {
                this._warn('Communication channel not established');
                return;
            }
            
            try {
                const event = {
                    type: eventType,
                    timestamp: Date.now(),
                    url: window.location.href,
                    data: data,
                    source: 'firefox-injector'
                };
                
                if (this.config.extensionMode && this.features.supportsExtensionAPI) {
                    // Use Firefox extension messaging
                    this.port.postMessage(event);
                } else {
                    // Use window messaging
                    window.postMessage({
                        namespace: this.namespace,
                        event: event
                    }, '*');
                }
            } catch (error) {
                this._error('Error sending event', error);
            }
        }
        
        /**
         * Execute a command from the recorder application
         * @param {string} command - Command name
         * @param {Object} params - Command parameters
         * @returns {Promise<any>} Command result
         */
        async executeCommand(command, params = {}) {
            this._log(`Executing command: ${command}`);
            
            if (!this.commandHandlers || !this.commandHandlers[command]) {
                throw new Error(`Unknown command: ${command}`);
            }
            
            try {
                return await this.commandHandlers[command](params);
            } catch (error) {
                this._error(`Error executing command ${command}`, error);
                throw error;
            }
        }
        
        /**
         * Highlight an element on the page
         * @param {Element|string} element - Element or CSS selector
         * @param {Object} options - Highlight options
         */
        highlightElement(element, options = {}) {
            const defaultOptions = {
                color: '#C54B8C', // Primary brand color
                duration: 2000,
                outlineWidth: '2px',
                outlineStyle: 'solid',
                borderRadius: '2px',
                pulseEffect: true,
                zIndex: 2147483647 // Maximum z-index
            };
            
            const highlightOptions = Object.assign(defaultOptions, options);
            
            try {
                // Find the element if selector provided
                if (typeof element === 'string') {
                    element = document.querySelector(element);
                }
                
                if (!element) {
                    this._warn('Element not found for highlighting');
                    return;
                }
                
                // Get element position
                const rect = element.getBoundingClientRect();
                
                // Create highlight overlay
                const overlay = document.createElement('div');
                overlay.dataset.csTestForge = 'highlight-overlay';
                
                Object.assign(overlay.style, {
                    position: 'fixed',
                    boxSizing: 'border-box',
                    top: rect.top + 'px',
                    left: rect.left + 'px',
                    width: rect.width + 'px',
                    height: rect.height + 'px',
                    outline: `${highlightOptions.outlineWidth} ${highlightOptions.outlineStyle} ${highlightOptions.color}`,
                    borderRadius: highlightOptions.borderRadius,
                    pointerEvents: 'none',
                    zIndex: highlightOptions.zIndex
                });
                
                // Add pulse animation if enabled
                if (highlightOptions.pulseEffect) {
                    overlay.style.animation = `cstf-pulse ${highlightOptions.duration / 1000}s ease-in-out`;
                    
                    // Add the keyframes for the animation if not already present
                    if (!document.querySelector('#cstf-highlight-keyframes')) {
                        const keyframes = document.createElement('style');
                        keyframes.id = 'cstf-highlight-keyframes';
                        keyframes.textContent = `
                            @keyframes cstf-pulse {
                                0% { opacity: 0; }
                                25% { opacity: 0.7; }
                                50% { opacity: 0.5; }
                                75% { opacity: 0.7; }
                                100% { opacity: 0; }
                            }
                        `;
                        document.head.appendChild(keyframes);
                    }
                }
                
                // Add to DOM
                document.body.appendChild(overlay);
                
                // Remove after duration
                setTimeout(() => {
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                }, highlightOptions.duration);
                
                // Handle element scrolling into view if necessary
                if (options.scrollIntoView) {
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center',
                        inline: 'center'
                    });
                }
            } catch (error) {
                this._error('Error highlighting element', error);
            }
        }
        
        /*********************
         * Private Methods
         ********************/
        
        /**
         * Check if Firefox extension API is supported
         * @private
         * @returns {boolean} Whether extension API is supported
         */
        _checkExtensionSupport() {
            return typeof browser !== 'undefined' && 
                   typeof browser.runtime !== 'undefined' &&
                   typeof browser.runtime.sendMessage !== 'undefined';
        }
        
        /**
         * Check if ES6 modules are supported
         * @private
         * @returns {boolean} Whether modules are supported
         */
        _checkModuleSupport() {
            try {
                new Function('return import("")');
                return true;
            } catch (err) {
                return false;
            }
        }
        
        /**
         * Check if content scripts are supported
         * @private
         * @returns {boolean} Whether content scripts are supported
         */
        _checkContentScriptSupport() {
            return typeof browser !== 'undefined' && 
                   typeof browser.tabs !== 'undefined' && 
                   typeof browser.tabs.executeScript !== 'undefined';
        }
        
        /**
         * Check if Performance API is supported
         * @private
         * @returns {boolean} Whether Performance API is supported
         */
        _checkPerformanceAPISupport() {
            return typeof performance !== 'undefined' && 
                   typeof performance.now === 'function' &&
                   typeof performance.mark === 'function';
        }
        
        /**
         * Check if SessionStorage is supported
         * @private
         * @returns {boolean} Whether SessionStorage is supported
         */
        _checkSessionStorageSupport() {
            try {
                const testKey = '__csTestForge_test__';
                sessionStorage.setItem(testKey, 'test');
                sessionStorage.removeItem(testKey);
                return true;
            } catch (e) {
                return false;
            }
        }
        
        /**
         * Check if Firefox Storage API is supported
         * @private
         * @returns {boolean} Whether Firefox Storage API is supported
         */
        _checkBrowserStorageSupport() {
            return typeof browser !== 'undefined' && 
                   typeof browser.storage !== 'undefined' &&
                   typeof browser.storage.local !== 'undefined';
        }
        
        /**
         * Check if browser is running in headless mode
         * @private
         * @returns {boolean} Whether browser is headless
         */
        _checkIfHeadless() {
            // Multiple techniques to detect headless mode
            const checks = [
                // Check for Plugins (Headless has none)
                navigator.plugins.length === 0,
                
                // Check for WebDriver
                navigator.webdriver === true,
                
                // Check for unusual navigator properties
                navigator.languages === undefined,
                
                // Check for hardware concurrency (sometimes limited in headless)
                navigator.hardwareConcurrency <= 2,
                
                // Check for unusual touch points behavior
                'ontouchstart' in window && navigator.maxTouchPoints === 0
            ];
            
            // Consider headless if majority of checks pass
            return checks.filter(Boolean).length > checks.length / 2;
        }
        
        /**
         * Check if browser is in private browsing mode
         * Firefox has specific behavior for detecting private browsing
         * @private
         * @returns {boolean} Whether browser is in private browsing mode
         */
        _checkIfPrivateBrowsing() {
            // For Firefox, we can check IndexedDB functionality
            try {
                // In Firefox private browsing, IndexedDB is disabled by default
                const db = indexedDB.open('test');
                return false;
            } catch(e) {
                return true;
            }
        }
        
        /**
         * Check if DevTools is open
         * @private
         * @returns {boolean} Whether DevTools is open
         */
        _checkDevToolsOpen() {
            // Firefox-specific detection technique
            let devtoolsOpen = false;
            
            // Method 1: Check for Firebug
            if (window.Firebug && window.Firebug.chrome && window.Firebug.chrome.isInitialized) {
                return true;
            }
            
            // Method 2: Check debugger statement timing
            const startTime = Date.now();
            debugger; // This statement is ignored when DevTools is closed
            const endTime = Date.now();
            
            // If more than 50ms passed, DevTools was likely open
            return endTime - startTime > 50;
        }
        
        /**
         * Detect detailed browser information
         * @private
         */
        async _detectBrowserDetails() {
            try {
                // Extract detailed Firefox version
                const userAgent = navigator.userAgent;
                const firefoxRegex = /(Firefox|FxiOS)\\/(([0-9]+)\\.([0-9]+)(?:\\.([0-9]+))?).*?/;
                const match = userAgent.match(firefoxRegex);
                
                let version = null;
                if (match) {
                    version = {
                        full: match[2],
                        major: parseInt(match[3], 10),
                        minor: parseInt(match[4], 10),
                        patch: match[5] ? parseInt(match[5], 10) : 0
                    };
                }
                
                // Determine Firefox variant
                let variant = 'Firefox';
                if (userAgent.includes('Fennec')) {
                    variant = 'Firefox Mobile';
                } else if (userAgent.includes('FxiOS')) {
                    variant = 'Firefox iOS';
                } else if (userAgent.includes('Focus')) {
                    variant = 'Firefox Focus';
                } else if (userAgent.includes('Aurora')) {
                    variant = 'Firefox Aurora';
                } else if (userAgent.includes('SeaMonkey')) {
                    variant = 'SeaMonkey';
                }
                
                // Detect OS
                let os = 'Unknown';
                let osVersion = null;
                
                if (userAgent.includes('Windows')) {
                    os = 'Windows';
                    const windowsMatch = userAgent.match(/Windows NT ([0-9.]+)/);
                    if (windowsMatch) {
                        const ntVersion = windowsMatch[1];
                        const windowsVersions = {
                            '10.0': '10',
                            '6.3': '8.1',
                            '6.2': '8',
                            '6.1': '7',
                            '6.0': 'Vista',
                            '5.2': 'XP',
                            '5.1': 'XP'
                        };
                        osVersion = windowsVersions[ntVersion] || ntVersion;
                    }
                } else if (userAgent.includes('Mac OS X')) {
                    os = 'macOS';
                    const macMatch = userAgent.match(/Mac OS X ([0-9_.]+)/);
                    if (macMatch) {
                        osVersion = macMatch[1].replace(/_/g, '.');
                    }
                } else if (userAgent.includes('Linux')) {
                    os = 'Linux';
                } else if (userAgent.includes('Android')) {
                    os = 'Android';
                    const androidMatch = userAgent.match(/Android ([0-9.]+)/);
                    if (androidMatch) {
                        osVersion = androidMatch[1];
                    }
                } else if (userAgent.includes('iOS')) {
                    os = 'iOS';
                    const iosMatch = userAgent.match(/OS ([0-9_]+)/);
                    if (iosMatch) {
                        osVersion = iosMatch[1].replace(/_/g, '.');
                    }
                }
                
                // Store browser details
                this.browserDetails = {
                    name: 'Firefox',
                    variant: variant,
                    version: version,
                    userAgent: userAgent,
                    os: os,
                    osVersion: osVersion,
                    language: navigator.language,
                    platform: navigator.platform,
                    isPrivateBrowsing: this._checkIfPrivateBrowsing(),
                    isHeadless: this._checkIfHeadless(),
                    hasDevToolsOpen: this._checkDevToolsOpen()
                };
                
                // Make available globally for other CSTestForge components
                window.CSTestForge = window.CSTestForge || {};
                window.CSTestForge.browserInfo = {
                    name: 'Firefox',
                    version: version ? version.full : null,
                    isChrome: false,
                    isFirefox: true,
                    isSafari: false,
                    isEdge: false,
                    isEdgeChromium: false,
                    isEdgeLegacy: false,
                    isIE: false,
                    isOpera: false,
                    isBrave: false
                };
                
                this._log('Detected browser details', this.browserDetails);
            } catch (error) {
                this._error('Error detecting browser details', error);
                
                // Fallback to basic info
                this.browserDetails = {
                    name: 'Firefox',
                    userAgent: navigator.userAgent
                };
            }
        }
        
        /**
         * Inject required polyfills for Firefox
         * @private
         */
        async _injectPolyfills() {
            try {
                // Firefox generally has good feature support, but there are edge cases
                const polyfillsNeeded = [];
                
                // For older Firefox versions
                if (this.browserDetails.version && this.browserDetails.version.major < 55) {
                    polyfillsNeeded.push('IntersectionObserver');
                }
                
                if (this.browserDetails.version && this.browserDetails.version.major < 63) {
                    polyfillsNeeded.push('ResizeObserver');
                }
                
                if (polyfillsNeeded.length > 0) {
                    this._log(`Injecting polyfills for Firefox: ${polyfillsNeeded.join(', ')}`);
                    
                    // Using CSTestForge's polyfills module
                    const script = document.createElement('script');
                    script.dataset.csTestForge = 'polyfills';
                    script.src = this._getResourceUrl('polyfills.js');
                    
                    // Wait for script to load
                    await new Promise((resolve, reject) => {
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                } else {
                    this._log('No polyfills needed for this Firefox version');
                }
            } catch (error) {
                this._error('Error injecting polyfills', error);
            }
        }
        
        /**
         * Set up communication channel with the recorder application
         * @private
         */
        async _setupCommunication() {
            try {
                if (this.config.extensionMode && this.features.supportsExtensionAPI) {
                    // Firefox extension mode - use runtime port
                    this.port = browser.runtime.connect({ name: 'cstestforge-recorder' });
                    
                    // Set up message listener
                    this.port.onMessage.addListener((message) => {
                        this._handleMessage(message);
                    });
                    
                    // Set up disconnect listener
                    this.port.onDisconnect.addListener(() => {
                        this._log('Port disconnected');
                        this.port = null;
                    });
                } else {
                    // Standalone mode - use window messaging
                    this._addEventListenerWithCleanup(window, 'message', (event) => {
                        if (event.data && 
                            event.data.namespace === this.namespace &&
                            event.data.command) {
                            
                            this._handleCommand(event.data.command, event.data.params);
                        }
                    });
                }
                
                // Send ready event
                this.sendEvent('INJECTOR_READY', {
                    features: this.features,
                    browserDetails: this.browserDetails
                });
            } catch (error) {
                this._error('Error setting up communication', error);
            }
        }
        
        /**
         * Handle incoming messages from the recorder
         * @private
         * @param {Object} message - The message object
         */
        _handleMessage(message) {
            if (!message || !message.command) {
                return;
            }
            
            this._handleCommand(message.command, message.params);
        }
        
        /**
         * Handle commands from the recorder
         * @private
         * @param {string} command - Command name
         * @param {Object} params - Command parameters
         */
        async _handleCommand(command, params) {
            try {
                await this.executeCommand(command, params);
            } catch (error) {
                this._error(`Error handling command: ${command}`, error);
                
                this.sendEvent('COMMAND_ERROR', {
                    command: command,
                    error: error.message,
                    stack: error.stack
                });
            }
        }
        
        /**
         * Inject necessary CSS styles
         * @private
         */
        async _injectStyles() {
            try {
                const styleContent = `
                    /* CSTestForge Firefox Injector Styles */
                    [data-cs-test-forge="highlight-overlay"] {
                        pointer-events: none !important;
                        box-sizing: border-box !important;
                        position: fixed !important;
                        z-index: 2147483647 !important;
                    }
                    
                    [data-cs-test-forge="recorder-ui"] {
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
                        font-size: 14px !important;
                        color: #333 !important;
                    }
                    
                    [data-cs-test-forge="tooltip"] {
                        position: absolute !important;
                        background: rgba(0, 0, 0, 0.8) !important;
                        color: white !important;
                        padding: 5px 10px !important;
                        border-radius: 4px !important;
                        font-size: 12px !important;
                        z-index: 2147483647 !important;
                        pointer-events: none !important;
                        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2) !important;
                    }
                    
                    /* Animation for element highlighting */
                    @keyframes cstf-pulse {
                        0% { opacity: 0; }
                        25% { opacity: 0.7; }
                        50% { opacity: 0.5; }
                        75% { opacity: 0.7; }
                        100% { opacity: 0; }
                    }
                `;
                
                const style = document.createElement('style');
                style.dataset.csTestForge = 'injected-styles';
                style.textContent = styleContent;
                
                document.head.appendChild(style);
            } catch (error) {
                this._error('Error injecting styles', error);
            }
        }
        
        /**
         * Set up event capture for the page
         * @private
         */
        async _setupEventCapture() {
            try {
                // Create and configure event capture module instance
                // This code assumes event-capture.js is already loaded
                if (window.CSTestForge && window.CSTestForge.EventCapture) {
                    const eventCapture = new window.CSTestForge.EventCapture({
                        captureClicks: this.config.captureClicks,
                        captureKeyboard: this.config.captureKeyboard,
                        captureSelects: this.config.captureSelects,
                        captureNavigation: this.config.captureNavigation,
                        captureHover: this.config.captureHover,
                        throttleMs: this.config.eventThrottleMs,
                        onEvent: (eventType, eventData) => {
                            this.sendEvent(eventType, eventData);
                        }
                    });
                    
                    await eventCapture.initialize();
                    this.eventCapture = eventCapture;
                    
                    // Save for cleanup
                    this.modules = this.modules || {};
                    this.modules.eventCapture = eventCapture;
                } else {
                    this._warn('EventCapture module not found');
                    
                    // Fallback to basic click capturing
                    this._setupBasicEventCapture();
                }
                
                // Set up DOM observer
                this._setupDOMObserver();
            } catch (error) {
                this._error('Error setting up event capture', error);
                
                // Fallback to basic capture
                this._setupBasicEventCapture();
            }
        }
        
        /**
         * Fallback to basic event capturing when full module unavailable
         * @private
         */
        _setupBasicEventCapture() {
            this._log('Using basic event capture as fallback');
            
            // Capture clicks
            if (this.config.captureClicks) {
                this._addEventListenerWithCleanup(document, 'click', (event) => {
                    // Skip events from our own UI
                    if (this._isFromCsTestForge(event.target)) {
                        return;
                    }
                    
                    const elementInfo = this._getElementInfo(event.target);
                    
                    this.sendEvent('CLICK', {
                        elementInfo: elementInfo,
                        clientX: event.clientX,
                        clientY: event.clientY,
                        ctrlKey: event.ctrlKey,
                        altKey: event.altKey,
                        shiftKey: event.shiftKey,
                        metaKey: event.metaKey,
                        button: event.button
                    });
                }, true);
            }
            
            // Capture form interactions
            if (this.config.captureClicks) {
                // Input changes
                this._addEventListenerWithCleanup(document, 'change', (event) => {
                    if (this._isFromCsTestForge(event.target)) {
                        return;
                    }
                    
                    const elementInfo = this._getElementInfo(event.target);
                    
                    // Handle different input types
                    let value = event.target.value;
                    if (event.target.type === 'checkbox' || event.target.type === 'radio') {
                        value = event.target.checked;
                    }
                    
                    this.sendEvent('INPUT_CHANGE', {
                        elementInfo: elementInfo,
                        value: value,
                        inputType: event.target.type || 'text'
                    });
                }, true);
            }
            
            // Capture navigation
            if (this.config.captureNavigation) {
                // Use both popstate and hashchange
                this._addEventListenerWithCleanup(window, 'popstate', () => {
                    this.sendEvent('NAVIGATION', {
                        url: window.location.href,
                        title: document.title,
                        type: 'popstate'
                    });
                });
                
                this._addEventListenerWithCleanup(window, 'hashchange', () => {
                    this.sendEvent('NAVIGATION', {
                        url: window.location.href,
                        title: document.title,
                        type: 'hashchange'
                    });
                });
                
                // Capture form submissions
                this._addEventListenerWithCleanup(document, 'submit', (event) => {
                    if (this._isFromCsTestForge(event.target)) {
                        return;
                    }
                    
                    const elementInfo = this._getElementInfo(event.target);
                    
                    this.sendEvent('FORM_SUBMIT', {
                        elementInfo: elementInfo,
                        action: event.target.action,
                        method: event.target.method
                    });
                }, true);
                
                // Monkey patch history API
                const originalPushState = history.pushState;
                const originalReplaceState = history.replaceState;
                
                history.pushState = function() {
                    const result = originalPushState.apply(this, arguments);
                    
                    window.dispatchEvent(new Event('pushstate'));
                    window.dispatchEvent(new Event('locationchange'));
                    
                    return result;
                };
                
                history.replaceState = function() {
                    const result = originalReplaceState.apply(this, arguments);
                    
                    window.dispatchEvent(new Event('replacestate'));
                    window.dispatchEvent(new Event('locationchange'));
                    
                    return result;
                };
                
                this._addEventListenerWithCleanup(window, 'locationchange', () => {
                    this.sendEvent('NAVIGATION', {
                        url: window.location.href,
                        title: document.title,
                        type: 'historyapi'
                    });
                });
            }
        }
        
        /**
         * Set up DOM observer to detect changes
         * @private
         */
        _setupDOMObserver() {
            try {
                // Create and configure DOM observer module instance
                if (window.CSTestForge && window.CSTestForge.DOMObserver) {
                    const domObserver = new window.CSTestForge.DOMObserver({
                        subtree: true,
                        childList: true,
                        attributes: true,
                        characterData: true,
                        onMutation: (mutationRecords) => {
                            // Throttle DOM mutations to reduce overhead
                            if (this._domMutationTimeout) {
                                clearTimeout(this._domMutationTimeout);
                            }
                            
                            this._domMutationTimeout = setTimeout(() => {
                                const processedMutations = this._processMutations(mutationRecords);
                                
                                if (processedMutations.changes.length > 0) {
                                    this.sendEvent('DOM_MUTATION', processedMutations);
                                }
                            }, 200); // Throttle to 200ms
                        }
                    });
                    
                    domObserver.initialize();
                    
                    // Save for cleanup
                    this.modules = this.modules || {};
                    this.modules.domObserver = domObserver;
                } else {
                    this._warn('DOMObserver module not found');
                    
                    // Fallback to basic MutationObserver
                    this._setupBasicDOMObserver();
                }
            } catch (error) {
                this._error('Error setting up DOM observer', error);
                
                // Fallback to basic observer
                this._setupBasicDOMObserver();
            }
        }
        
        /**
         * Fallback to basic DOM observation
         * @private
         */
        _setupBasicDOMObserver() {
            this._log('Using basic DOM observer as fallback');
            
            if (!this.features.supportsMutationObserver) {
                this._warn('MutationObserver not supported');
                return;
            }
            
            const observer = new MutationObserver((mutations) => {
                // Throttle DOM mutations to reduce overhead
                if (this._domMutationTimeout) {
                    clearTimeout(this._domMutationTimeout);
                }
                
                this._domMutationTimeout = setTimeout(() => {
                    const processedMutations = this._processMutations(mutations);
                    
                    if (processedMutations.changes.length > 0) {
                        this.sendEvent('DOM_MUTATION', processedMutations);
                    }
                }, 200); // Throttle to 200ms
            });
            
            // Start observing
            observer.observe(document.documentElement, {
                subtree: true,
                childList: true,
                attributes: true,
                characterData: true,
                attributeOldValue: true,
                characterDataOldValue: true
            });
            
            // Save for cleanup
            this.observers.domMutation = observer;
        }
        
        /**
         * Process DOM mutations to extract relevant changes
         * @private
         * @param {MutationRecord[]} mutations - Mutation records
         * @returns {Object} Processed mutations
         */
        _processMutations(mutations) {
            const changes = [];
            const stats = {
                addedNodes: 0,
                removedNodes: 0,
                attributeChanges: 0,
                textChanges: 0
            };
            
            for (const mutation of mutations) {
                // Skip mutations in our own elements
                if (this._isFromCsTestForge(mutation.target)) {
                    continue;
                }
                
                if (mutation.type === 'childList') {
                    if (mutation.addedNodes.length > 0) {
                        stats.addedNodes += mutation.addedNodes.length;
                        
                        // Only add significant added nodes
                        for (const node of mutation.addedNodes) {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                const elementInfo = this._getElementInfo(node);
                                
                                changes.push({
                                    type: 'nodeAdded',
                                    elementInfo: elementInfo,
                                    parentPath: this._getElementXPath(mutation.target)
                                });
                            }
                        }
                    }
                    
                    if (mutation.removedNodes.length > 0) {
                        stats.removedNodes += mutation.removedNodes.length;
                        
                        // Only add significant removed nodes (elements)
                        for (const node of mutation.removedNodes) {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                // For removed nodes, we can't get much info
                                changes.push({
                                    type: 'nodeRemoved',
                                    tagName: node.tagName,
                                    parentPath: this._getElementXPath(mutation.target)
                                });
                            }
                        }
                    }
                } else if (mutation.type === 'attributes') {
                    stats.attributeChanges++;
                    
                    changes.push({
                        type: 'attributeChanged',
                        elementInfo: this._getElementInfo(mutation.target),
                        attributeName: mutation.attributeName,
                        oldValue: mutation.oldValue,
                        newValue: mutation.target.getAttribute(mutation.attributeName)
                    });
                } else if (mutation.type === 'characterData') {
                    stats.textChanges++;
                    
                    changes.push({
                        type: 'textChanged',
                        elementInfo: this._getElementInfo(mutation.target.parentElement),
                        oldValue: mutation.oldValue,
                        newValue: mutation.target.nodeValue
                    });
                }
            }
            
            return {
                changes: changes,
                stats: stats,
                timestamp: Date.now(),
                url: window.location.href
            };
        }
        
        /**
         * Set up console output capturing
         * @private
         */
        _setupConsoleCapture() {
            try {
                // Save original console methods
                this._originalConsole = {
                    log: console.log,
                    warn: console.warn,
                    error: console.error,
                    info: console.info,
                    debug: console.debug
                };
                
                // Override console.log
                console.log = (...args) => {
                    this._originalConsole.log.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'log',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Override console.warn
                console.warn = (...args) => {
                    this._originalConsole.warn.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'warn',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Override console.error
                console.error = (...args) => {
                    this._originalConsole.error.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'error',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Override console.info
                console.info = (...args) => {
                    this._originalConsole.info.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'info',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Override console.debug
                console.debug = (...args) => {
                    this._originalConsole.debug.apply(console, args);
                    
                    this.sendEvent('CONSOLE', {
                        type: 'debug',
                        args: this._stringifyConsoleArgs(args)
                    });
                };
                
                // Also capture JavaScript errors
                this._addEventListenerWithCleanup(window, 'error', (event) => {
                    this.sendEvent('JS_ERROR', {
                        message: event.message,
                        source: event.filename,
                        lineno: event.lineno,
                        colno: event.colno,
                        error: event.error ? {
                            name: event.error.name,
                            message: event.error.message,
                            stack: event.error.stack
                        } : null
                    });
                });
                
                // Capture unhandled promise rejections
                this._addEventListenerWithCleanup(window, 'unhandledrejection', (event) => {
                    const error = event.reason;
                    
                    this.sendEvent('UNHANDLED_REJECTION', {
                        message: error ? error.message : 'Unknown promise rejection',
                        stack: error && error.stack ? error.stack : null
                    });
                });
            } catch (error) {
                this._error('Error setting up console capture', error);
            }
        }
        
        /**
         * Safely stringify console arguments
         * @private
         * @param {Array} args - Console arguments
         * @returns {Array<string>} Stringified arguments
         */
        _stringifyConsoleArgs(args) {
            try {
                return args.map(arg => {
                    if (arg === null) return 'null';
                    if (arg === undefined) return 'undefined';
                    
                    // For errors, extract useful information
                    if (arg instanceof Error) {
                        return {
                            type: 'Error',
                            name: arg.name,
                            message: arg.message,
                            stack: arg.stack
                        };
                    }
                    
                    // For DOM nodes, get a useful representation
                    if (arg instanceof Node) {
                        if (arg.nodeType === Node.ELEMENT_NODE) {
                            return {
                                type: 'DOMElement',
                                tagName: arg.tagName,
                                id: arg.id,
                                className: arg.className,
                                attributes: this._getElementAttributes(arg),
                                xpath: this._getElementXPath(arg)
                            };
                        } else if (arg.nodeType === Node.TEXT_NODE) {
                            return {
                                type: 'DOMText',
                                textContent: arg.textContent.substring(0, 100)
                            };
                        }
                        
                        return {
                            type: 'DOMNode',
                            nodeType: arg.nodeType,
                            nodeName: arg.nodeName
                        };
                    }
                    
                    // Try regular JSON stringify for other types
                    try {
                        return JSON.stringify(arg);
                    } catch (e) {
                        return String(arg);
                    }
                });
            } catch (error) {
                this._error('Error stringifying console args', error);
                return args.map(arg => String(arg));
            }
        }
        
        /**
         * Set up network request capturing
         * @private
         */
        _setupNetworkCapture() {
            try {
                if (!this.features.supportsPerformanceAPI) {
                    this._warn('Performance API not supported, network capture disabled');
                    return;
                }
                
                // Use PerformanceObserver if available
                if ('PerformanceObserver' in window) {
                    const observer = new PerformanceObserver((list) => {
                        const entries = list.getEntries();
                        for (const entry of entries) {
                            // Only process resource entries (not navigation, paint, etc.)
                            if (entry.entryType === 'resource') {
                                this._processResourceTiming(entry);
                            }
                        }
                    });
                    
                    observer.observe({ entryTypes: ['resource'] });
                    
                    // Save for cleanup
                    this.observers.performance = observer;
                } else {
                    // Fallback to polling for older browsers
                    const checkResources = () => {
                        const entries = performance.getEntriesByType('resource');
                        
                        // Process only new entries (not seen before)
                        for (const entry of entries) {
                            const id = entry.name + '-' + entry.startTime;
                            
                            if (!this._processedResources || !this._processedResources.has(id)) {
                                this._processResourceTiming(entry);
                                
                                // Mark as processed
                                if (!this._processedResources) {
                                    this._processedResources = new Set();
                                }
                                this._processedResources.add(id);
                            }
                        }
                    };
                    
                    // Check periodically
                    this._networkCaptureInterval = setInterval(checkResources, 1000);
                    
                    // Initial check
                    checkResources();
                }
                
                // Patch XMLHttpRequest for more detailed XHR tracking
                this._patchXMLHttpRequest();
                
                // And patch fetch if available
                if (typeof fetch === 'function') {
                    this._patchFetch();
                }
            } catch (error) {
                this._error('Error setting up network capture', error);
            }
        }
        
        /**
         * Process a resource timing entry
         * @private
         * @param {PerformanceResourceTiming} entry - Performance entry
         */
        _processResourceTiming(entry) {
            try {
                // Skip tracking our own resources
                if (entry.name.includes('cstestforge') || 
                    entry.name.includes('csTestForge')) {
                    return;
                }
                
                // Extract useful information
                const timing = {
                    name: entry.name,
                    entryType: entry.entryType,
                    startTime: entry.startTime,
                    duration: entry.duration,
                    initiatorType: entry.initiatorType,
                    redirectStart: entry.redirectStart,
                    redirectEnd: entry.redirectEnd,
                    fetchStart: entry.fetchStart,
                    domainLookupStart: entry.domainLookupStart,
                    domainLookupEnd: entry.domainLookupEnd,
                    connectStart: entry.connectStart,
                    connectEnd: entry.connectEnd,
                    secureConnectionStart: entry.secureConnectionStart,
                    requestStart: entry.requestStart,
                    responseStart: entry.responseStart,
                    responseEnd: entry.responseEnd,
                    transferSize: entry.transferSize,
                    encodedBodySize: entry.encodedBodySize,
                    decodedBodySize: entry.decodedBodySize
                };
                
                // Calculate valuable metrics
                const metrics = {
                    dnsTime: entry.domainLookupEnd - entry.domainLookupStart,
                    tcpTime: entry.connectEnd - entry.connectStart,
                    sslTime: entry.secureConnectionStart ? 
                        entry.connectEnd - entry.secureConnectionStart : 0,
                    requestTime: entry.responseStart - entry.requestStart,
                    responseTime: entry.responseEnd - entry.responseStart,
                    totalTime: entry.duration,
                    url: entry.name
                };
                
                this.sendEvent('NETWORK_RESOURCE', {
                    timing: timing,
                    metrics: metrics,
                    timestamp: Date.now()
                });
            } catch (error) {
                this._error('Error processing resource timing', error);
            }
        }
        
        /**
         * Patch XMLHttpRequest to capture detailed request/response data
         * @private
         */
        _patchXMLHttpRequest() {
            const originalOpen = XMLHttpRequest.prototype.open;
            const originalSend = XMLHttpRequest.prototype.send;
            const self = this;
            
            XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
                // Save request information
                this._csRequestInfo = {
                    method: method,
                    url: url,
                    async: async !== false,
                    user: user,
                    timestamp: Date.now(),
                    requestHeaders: {}
                };
                
                return originalOpen.apply(this, arguments);
            };
            
            // Track request headers
            const originalSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
            XMLHttpRequest.prototype.setRequestHeader = function(header, value) {
                if (this._csRequestInfo) {
                    this._csRequestInfo.requestHeaders[header] = value;
                }
                return originalSetRequestHeader.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function(body) {
                if (this._csRequestInfo) {
                    // Save request body if possible
                    this._csRequestInfo.requestBody = body;
                    
                    // Track request start time
                    this._csRequestInfo.startTime = performance.now();
                    
                    // Send request start event
                    self.sendEvent('XHR_START', {
                        method: this._csRequestInfo.method,
                        url: this._csRequestInfo.url,
                        async: this._csRequestInfo.async,
                        headers: this._csRequestInfo.requestHeaders,
                        timestamp: Date.now()
                    });
                    
                    // Track response
                    this.addEventListener('load', function() {
                        if (!this._csRequestInfo) {
                            return;
                        }
                        
                        // Calculate timing
                        const endTime = performance.now();
                        const duration = endTime - this._csRequestInfo.startTime;
                        
                        // Extract response headers
                        const responseHeaders = {};
                        const allHeaders = this.getAllResponseHeaders();
                        const headerLines = allHeaders.split(/\r?\n/);
                        
                        for (const line of headerLines) {
                            if (line.trim() === '') continue;
                            
                            const parts = line.split(': ');
                            const header = parts.shift();
                            const value = parts.join(': ');
                            
                            responseHeaders[header] = value;
                        }
                        
                        // Extract and limit response body if possible
                        let responseBody = null;
                        try {
                            // Only include response body for certain content types
                            const contentType = responseHeaders['content-type'] || '';
                            
                            if (contentType.includes('application/json') ||
                                contentType.includes('text/html') ||
                                contentType.includes('text/plain') ||
                                contentType.includes('text/xml') ||
                                contentType.includes('application/xml')) {
                                
                                responseBody = this.responseText.substring(0, 5000);
                                
                                // Add ellipsis if truncated
                                if (this.responseText.length > 5000) {
                                    responseBody += '...';
                                }
                            }
                        } catch (e) {
                            // Don't crash if we can't access response text
                        }
                        
                        // Send completion event
                        self.sendEvent('XHR_COMPLETE', {
                            method: this._csRequestInfo.method,
                            url: this._csRequestInfo.url,
                            status: this.status,
                            statusText: this.statusText,
                            duration: duration,
                            responseHeaders: responseHeaders,
                            responseBody: responseBody,
                            timestamp: Date.now()
                        });
                    });
                    
                    // Track errors
                    this.addEventListener('error', function() {
                        if (!this._csRequestInfo) {
                            return;
                        }
                        
                        self.sendEvent('XHR_ERROR', {
                            method: this._csRequestInfo.method,
                            url: this._csRequestInfo.url,
                            timestamp: Date.now()
                        });
                    });
                    
                    // Track aborts
                    this.addEventListener('abort', function() {
                        if (!this._csRequestInfo) {
                            return;
                        }
                        
                        self.sendEvent('XHR_ABORT', {
                            method: this._csRequestInfo.method,
                            url: this._csRequestInfo.url,
                            timestamp: Date.now()
                        });
                    });
                    
                    // Track timeouts
                    this.addEventListener('timeout', function() {
                        if (!this._csRequestInfo) {
                            return;
                        }
                        
                        self.sendEvent('XHR_TIMEOUT', {
                            method: this._csRequestInfo.method,
                            url: this._csRequestInfo.url,
                            timestamp: Date.now()
                        });
                    });
                }
                
                return originalSend.apply(this, arguments);
            };
            
            // Save original for cleanup
            this._originalXHR = {
                open: originalOpen,
                send: originalSend,
                setRequestHeader: originalSetRequestHeader
            };
        }
        
        /**
         * Patch fetch API to capture request/response data
         * @private
         */
        _patchFetch() {
            const originalFetch = window.fetch;
            const self = this;
            
            window.fetch = function(input, init) {
                const url = (typeof input === 'string') ? input : input.url;
                const method = (init && init.method) ? init.method : 
                               (input.method ? input.method : 'GET');
                
                // Gather request information
                const requestInfo = {
                    url: url,
                    method: method,
                    headers: (init && init.headers) ? init.headers : 
                             (input.headers ? input.headers : {}),
                    timestamp: Date.now(),
                    startTime: performance.now()
                };
                
                // Send request start event
                self.sendEvent('FETCH_START', {
                    method: requestInfo.method,
                    url: requestInfo.url,
                    headers: requestInfo.headers,
                    timestamp: Date.now()
                });
                
                // Start the fetch and track response
                return originalFetch.apply(this, arguments).then(response => {
                    // Calculate timing
                    const endTime = performance.now();
                    const duration = endTime - requestInfo.startTime;
                    
                    // Clone the response so we can process it without consuming it
                    const responseClone = response.clone();
                    
                    // Process response headers
                    const responseHeaders = {};
                    responseClone.headers.forEach((value, name) => {
                        responseHeaders[name] = value;
                    });
                    
                    // Extract content type
                    const contentType = responseClone.headers.get('content-type') || '';
                    
                    // Only process text-based responses
                    if (contentType.includes('application/json') ||
                        contentType.includes('text/html') ||
                        contentType.includes('text/plain') ||
                        contentType.includes('text/xml') ||
                        contentType.includes('application/xml')) {
                        
                        responseClone.text().then(text => {
                            // Limit response size
                            const responseBody = text.substring(0, 5000);
                            
                            // Send completion event with response body
                            self.sendEvent('FETCH_COMPLETE', {
                                method: requestInfo.method,
                                url: requestInfo.url,
                                status: responseClone.status,
                                statusText: responseClone.statusText,
                                duration: duration,
                                responseHeaders: responseHeaders,
                                responseBody: responseBody,
                                timestamp: Date.now()
                            });
                        }).catch(error => {
                            // Send completion event without response body
                            self.sendEvent('FETCH_COMPLETE', {
                                method: requestInfo.method,
                                url: requestInfo.url,
                                status: responseClone.status,
                                statusText: responseClone.statusText,
                                duration: duration,
                                responseHeaders: responseHeaders,
                                error: error.message,
                                timestamp: Date.now()
                            });
                        });
                    } else {
                        // Binary or non-text response, don't include body
                        self.sendEvent('FETCH_COMPLETE', {
                            method: requestInfo.method,
                            url: requestInfo.url,
                            status: responseClone.status,
                            statusText: responseClone.statusText,
                            duration: duration,
                            responseHeaders: responseHeaders,
                            contentType: contentType,
                            timestamp: Date.now()
                        });
                    }
                    
                    // Return the original response
                    return response;
                }).catch(error => {
                    // Calculate timing
                    const endTime = performance.now();
                    const duration = endTime - requestInfo.startTime;
                    
                    // Send error event
                    self.sendEvent('FETCH_ERROR', {
                        method: requestInfo.method,
                        url: requestInfo.url,
                        duration: duration,
                        error: error.message,
                        timestamp: Date.now()
                    });
                    
                    // Re-throw the error to let the original caller handle it
                    throw error;
                });
            };
            
            // Save original for cleanup
            this._originalFetch = originalFetch;
        }
        
        /**
         * Register command handlers for the recorder
         * @private
         */
        _registerCommands() {
            this.commandHandlers = {
                // Element interaction commands
                'highlightElement': (params) => this._commandHighlightElement(params),
                'getElementInfo': (params) => this._commandGetElementInfo(params),
                'findElements': (params) => this._commandFindElements(params),
                'scrollToElement': (params) => this._commandScrollToElement(params),
                'clickElement': (params) => this._commandClickElement(params),
                'setValue': (params) => this._commandSetValue(params),
                'getTextContent': (params) => this._commandGetTextContent(params),
                'getAttributes': (params) => this._commandGetAttributes(params),
                'hover': (params) => this._commandHover(params),
                
                // Document commands
                'getTitle': () => this._commandGetTitle(),
                'getUrl': () => this._commandGetUrl(),
                'takeScreenshot': (params) => this._commandTakeScreenshot(params),
                'executeScript': (params) => this._commandExecuteScript(params),
                
                // Navigation commands
                'navigate': (params) => this._commandNavigate(params),
                'refresh': () => this._commandRefresh(),
                'back': () => this._commandBack(),
                'forward': () => this._commandForward(),
                
                // Cookie and storage commands
                'getCookies': () => this._commandGetCookies(),
                'setCookie': (params) => this._commandSetCookie(params),
                'deleteCookie': (params) => this._commandDeleteCookie(params),
                'localStorage': (params) => this._commandLocalStorage(params),
                'sessionStorage': (params) => this._commandSessionStorage(params),
                
                // Recorder control
                'startRecording': () => this._commandStartRecording(),
                'stopRecording': () => this._commandStopRecording(),
                'pauseRecording': () => this._commandPauseRecording(),
                'resumeRecording': () => this._commandResumeRecording(),
                
                // System commands
                'getSystemInfo': () => this._commandGetSystemInfo(),
                'ping': () => this._commandPing()
            };
        }
        
        /**
         * Command handler for highlighting elements
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandHighlightElement(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                this.highlightElement(element, params.options);
                return true;
            } catch (error) {
                throw new Error(`Failed to highlight element: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting element info
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandGetElementInfo(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                return this._getElementInfo(element);
            } catch (error) {
                throw new Error(`Failed to get element info: ${error.message}`);
            }
        }
        
        /**
         * Command handler for finding elements
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandFindElements(params) {
            try {
                const elements = await this._findElements(params.locator);
                return elements.map(element => this._getElementInfo(element));
            } catch (error) {
                throw new Error(`Failed to find elements: ${error.message}`);
            }
        }
        
        /**
         * Command handler for scrolling to element
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandScrollToElement(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                const options = params.options || { behavior: 'smooth', block: 'center', inline: 'center' };
                element.scrollIntoView(options);
                
                return true;
            } catch (error) {
                throw new Error(`Failed to scroll to element: ${error.message}`);
            }
        }
        
        /**
         * Command handler for clicking element
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandClickElement(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                // Optional highlighting before click
                if (params.highlight) {
                    this.highlightElement(element, {
                        color: '#C54B8C',
                        duration: 500,
                        outlineWidth: '2px'
                    });
                    
                    // Wait a bit for highlighting to be visible
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Optional scrolling before click
                if (params.scroll) {
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                    
                    // Wait for scrolling to complete
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Simulate exact click coordinates if provided
                if (params.clientX !== undefined && params.clientY !== undefined) {
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window,
                        detail: 1,
                        screenX: params.screenX || 0,
                        screenY: params.screenY || 0,
                        clientX: params.clientX,
                        clientY: params.clientY,
                        ctrlKey: params.ctrlKey || false,
                        altKey: params.altKey || false,
                        shiftKey: params.shiftKey || false,
                        metaKey: params.metaKey || false,
                        button: params.button || 0,
                        relatedTarget: null
                    });
                    
                    element.dispatchEvent(clickEvent);
                } else {
                    // Simple click in center of element
                    if (params.useNativeEvents) {
                        // Calculate center of element
                        const rect = element.getBoundingClientRect();
                        const centerX = Math.floor(rect.left + rect.width / 2);
                        const centerY = Math.floor(rect.top + rect.height / 2);
                        
                        const clickEvent = new MouseEvent('click', {
                            bubbles: true,
                            cancelable: true,
                            view: window,
                            detail: 1,
                            screenX: centerX,
                            screenY: centerY,
                            clientX: centerX,
                            clientY: centerY,
                            ctrlKey: params.ctrlKey || false,
                            altKey: params.altKey || false,
                            shiftKey: params.shiftKey || false,
                            metaKey: params.metaKey || false,
                            button: params.button || 0,
                            relatedTarget: null
                        });
                        
                        element.dispatchEvent(clickEvent);
                    } else {
                        // Use the simple .click() method
                        element.click();
                    }
                }
                
                return true;
            } catch (error) {
                throw new Error(`Failed to click element: ${error.message}`);
            }
        }
        
        /**
         * Command handler for setting element value
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandSetValue(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                // Handle different input types
                if (element.tagName.toLowerCase() === 'input') {
                    const inputType = element.type.toLowerCase();
                    
                    if (inputType === 'checkbox' || inputType === 'radio') {
                        // For checkbox/radio, set the checked property
                        if (typeof params.value === 'boolean') {
                            element.checked = params.value;
                            
                            // Dispatch change event
                            const event = new Event('change', { bubbles: true });
                            element.dispatchEvent(event);
                            
                            return true;
                        } else {
                            throw new Error(`Invalid value for ${inputType}: ${params.value}`);
                        }
                    }
                }
                
                // For selects, handle differently
                if (element.tagName.toLowerCase() === 'select') {
                    // Set by index, value, or text
                    if (params.selectByIndex !== undefined) {
                        element.selectedIndex = params.selectByIndex;
                    } else if (params.selectByValue !== undefined) {
                        element.value = params.selectByValue;
                    } else if (params.selectByText !== undefined) {
                        const options = element.options;
                        for (let i = 0; i < options.length; i++) {
                            if (options[i].text === params.selectByText) {
                                element.selectedIndex = i;
                                break;
                            }
                        }
                    } else {
                        element.value = params.value;
                    }
                    
                    // Dispatch change event
                    const event = new Event('change', { bubbles: true });
                    element.dispatchEvent(event);
                    
                    return true;
                }
                
                // Clear the field first if requested
                if (params.clearFirst) {
                    element.value = '';
                    
                    // Fire input event to trigger any listeners
                    const inputEvent = new Event('input', { bubbles: true });
                    element.dispatchEvent(inputEvent);
                }
                
                // Type the value character by character
                if (params.typeCharByChar && typeof params.value === 'string') {
                    const delay = params.typeDelay || 50;
                    const value = params.value;
                    
                    // Focus the element
                    element.focus();
                    
                    // Type each character with a delay
                    for (let i = 0; i < value.length; i++) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        
                        // Append the character
                        const currentValue = element.value;
                        element.value = currentValue + value[i];
                        
                        // Fire input event for each character
                        const inputEvent = new Event('input', { bubbles: true });
                        element.dispatchEvent(inputEvent);
                    }
                } else {
                    // Set the value directly
                    element.value = params.value;
                }
                
                // Fire input event
                const inputEvent = new Event('input', { bubbles: true });
                element.dispatchEvent(inputEvent);
                
                // Fire change event
                const changeEvent = new Event('change', { bubbles: true });
                element.dispatchEvent(changeEvent);
                
                return true;
            } catch (error) {
                throw new Error(`Failed to set value: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting text content
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandGetTextContent(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                return {
                    textContent: element.textContent,
                    innerText: element.innerText,
                    value: element.value
                };
            } catch (error) {
                throw new Error(`Failed to get text content: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting element attributes
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandGetAttributes(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                return this._getElementAttributes(element);
            } catch (error) {
                throw new Error(`Failed to get attributes: ${error.message}`);
            }
        }
        
        /**
         * Command handler for hovering over element
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandHover(params) {
            try {
                const element = await this._findElement(params.locator);
                if (!element) {
                    throw new Error(`Element not found: ${JSON.stringify(params.locator)}`);
                }
                
                // Optional scrolling before hover
                if (params.scroll) {
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                    
                    // Wait for scrolling to complete
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Simulate hover
                const rect = element.getBoundingClientRect();
                const centerX = Math.floor(rect.left + rect.width / 2);
                const centerY = Math.floor(rect.top + rect.height / 2);
                
                // Create mouseenter and mouseover events
                const mouseEnterEvent = new MouseEvent('mouseenter', {
                    bubbles: false,
                    cancelable: true,
                    view: window,
                    detail: 0,
                    screenX: centerX,
                    screenY: centerY,
                    clientX: centerX,
                    clientY: centerY,
                    ctrlKey: params.ctrlKey || false,
                    altKey: params.altKey || false,
                    shiftKey: params.shiftKey || false,
                    metaKey: params.metaKey || false,
                    relatedTarget: null
                });
                
                const mouseOverEvent = new MouseEvent('mouseover', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    detail: 0,
                    screenX: centerX,
                    screenY: centerY,
                    clientX: centerX,
                    clientY: centerY,
                    ctrlKey: params.ctrlKey || false,
                    altKey: params.altKey || false,
                    shiftKey: params.shiftKey || false,
                    metaKey: params.metaKey || false,
                    relatedTarget: null
                });
                
                const mouseMoveEvent = new MouseEvent('mousemove', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    detail: 0,
                    screenX: centerX,
                    screenY: centerY,
                    clientX: centerX,
                    clientY: centerY,
                    ctrlKey: params.ctrlKey || false,
                    altKey: params.altKey || false,
                    shiftKey: params.shiftKey || false,
                    metaKey: params.metaKey || false,
                    relatedTarget: null
                });
                
                // Dispatch the events
                element.dispatchEvent(mouseEnterEvent);
                element.dispatchEvent(mouseOverEvent);
                element.dispatchEvent(mouseMoveEvent);
                
                // Optional highlight during hover
                if (params.highlight) {
                    this.highlightElement(element, {
                        color: '#C54B8C',
                        duration: params.highlightDuration || 2000,
                        outlineWidth: '2px'
                    });
                }
                
                return true;
            } catch (error) {
                throw new Error(`Failed to hover: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting document title
         * @private
         */
        _commandGetTitle() {
            return {
                title: document.title
            };
        }
        
        /**
         * Command handler for getting current URL
         * @private
         */
        _commandGetUrl() {
            return {
                url: window.location.href,
                origin: window.location.origin,
                pathname: window.location.pathname,
                search: window.location.search,
                hash: window.location.hash
            };
        }
        
        /**
         * Command handler for taking screenshot
         * For Firefox, we need to request the screenshot from the extension
         * since content scripts cannot directly take screenshots
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandTakeScreenshot(params) {
            try {
                // Validate if we're in extension mode
                if (!this.config.extensionMode) {
                    throw new Error('Screenshot functionality requires extension mode');
                }
                
                if (!browser || !browser.runtime) {
                    throw new Error('Browser extension API not available');
                }
                
                // Request screenshot from the background script
                return new Promise((resolve, reject) => {
                    browser.runtime.sendMessage({
                        action: 'TAKE_SCREENSHOT',
                        options: params
                    }).then(response => {
                        if (response.error) {
                            reject(new Error(response.error));
                        } else {
                            resolve(response);
                        }
                    }).catch(error => {
                        reject(error);
                    });
                });
            } catch (error) {
                throw new Error(`Failed to take screenshot: ${error.message}`);
            }
        }
        
        /**
         * Command handler for executing script
         * @private
         * @param {Object} params - Command parameters
         */
        async _commandExecuteScript(params) {
            try {
                const script = params.script;
                const args = params.args || [];
                
                // Execute the script in the page context
                const result = await this.injectScript(`
                    (function() {
                        try {
                            const args = ${JSON.stringify(args)};
                            return (${script}).apply(null, args);
                        } catch (e) {
                            throw new Error('Script execution error: ' + e.message);
                        }
                    })();
                `);
                
                return { result };
            } catch (error) {
                throw new Error(`Failed to execute script: ${error.message}`);
            }
        }
        
        /**
         * Command handler for navigating to URL
         * @private
         * @param {Object} params - Command parameters
         */
        _commandNavigate(params) {
            try {
                // Validate URL
                if (!params.url) {
                    throw new Error('URL is required');
                }
                
                // Navigate to URL
                window.location.href = params.url;
                
                return true;
            } catch (error) {
                throw new Error(`Failed to navigate: ${error.message}`);
            }
        }
        
        /**
         * Command handler for refreshing page
         * @private
         */
        _commandRefresh() {
            try {
                window.location.reload();
                return true;
            } catch (error) {
                throw new Error(`Failed to refresh: ${error.message}`);
            }
        }
        
        /**
         * Command handler for navigating back
         * @private
         */
        _commandBack() {
            try {
                window.history.back();
                return true;
            } catch (error) {
                throw new Error(`Failed to navigate back: ${error.message}`);
            }
        }
        
        /**
         * Command handler for navigating forward
         * @private
         */
        _commandForward() {
            try {
                window.history.forward();
                return true;
            } catch (error) {
                throw new Error(`Failed to navigate forward: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting cookies
         * @private
         */
        _commandGetCookies() {
            try {
                const cookies = document.cookie.split(';')
                    .map(cookie => cookie.trim())
                    .filter(cookie => cookie.length > 0)
                    .map(cookie => {
                        const [name, ...valueParts] = cookie.split('=');
                        const value = valueParts.join('=');
                        
                        return {
                            name: name.trim(),
                            value: value
                        };
                    });
                
                return { cookies };
            } catch (error) {
                throw new Error(`Failed to get cookies: ${error.message}`);
            }
        }
        
        /**
         * Command handler for setting cookie
         * @private
         * @param {Object} params - Command parameters
         */
        _commandSetCookie(params) {
            try {
                if (!params.name || !params.value) {
                    throw new Error('Cookie name and value are required');
                }
                
                let cookieString = `${params.name}=${params.value}`;
                
                if (params.domain) {
                    cookieString += `; domain=${params.domain}`;
                }
                
                if (params.path) {
                    cookieString += `; path=${params.path}`;
                }
                
                if (params.expires) {
                    if (params.expires instanceof Date) {
                        cookieString += `; expires=${params.expires.toUTCString()}`;
                    } else if (typeof params.expires === 'number') {
                        const date = new Date();
                        date.setTime(date.getTime() + params.expires * 1000);
                        cookieString += `; expires=${date.toUTCString()}`;
                    } else {
                        cookieString += `; expires=${params.expires}`;
                    }
                }
                
                if (params.maxAge) {
                    cookieString += `; max-age=${params.maxAge}`;
                }
                
                if (params.secure) {
                    cookieString += '; secure';
                }
                
                if (params.httpOnly) {
                    cookieString += '; httpOnly';
                }
                
                if (params.sameSite) {
                    cookieString += `; samesite=${params.sameSite}`;
                }
                
                document.cookie = cookieString;
                
                return true;
            } catch (error) {
                throw new Error(`Failed to set cookie: ${error.message}`);
            }
        }
        
        /**
         * Command handler for deleting cookie
         * @private
         * @param {Object} params - Command parameters
         */
        _commandDeleteCookie(params) {
            try {
                if (!params.name) {
                    throw new Error('Cookie name is required');
                }
                
                // Set expiration to past date to delete
                let cookieString = `${params.name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC`;
                
                if (params.path) {
                    cookieString += `; path=${params.path}`;
                } else {
                    cookieString += '; path=/';
                }
                
                if (params.domain) {
                    cookieString += `; domain=${params.domain}`;
                }
                
                document.cookie = cookieString;
                
                return true;
            } catch (error) {
                throw new Error(`Failed to delete cookie: ${error.message}`);
            }
        }
        
        /**
         * Command handler for localStorage operations
         * @private
         * @param {Object} params - Command parameters
         */
        _commandLocalStorage(params) {
            try {
                const action = params.action || 'getAll';
                
                switch (action) {
                    case 'get':
                        if (!params.key) {
                            throw new Error('Key is required for get action');
                        }
                        return { value: localStorage.getItem(params.key) };
                        
                    case 'set':
                        if (!params.key || params.value === undefined) {
                            throw new Error('Key and value are required for set action');
                        }
                        localStorage.setItem(params.key, params.value);
                        return true;
                        
                    case 'remove':
                        if (!params.key) {
                            throw new Error('Key is required for remove action');
                        }
                        localStorage.removeItem(params.key);
                        return true;
                        
                    case 'clear':
                        localStorage.clear();
                        return true;
                        
                    case 'getAll':
                        const items = {};
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            items[key] = localStorage.getItem(key);
                        }
                        return { items };
                        
                    default:
                        throw new Error(`Unknown localStorage action: ${action}`);
                }
            } catch (error) {
                throw new Error(`Failed to perform localStorage action: ${error.message}`);
            }
        }
        
        /**
         * Command handler for sessionStorage operations
         * @private
         * @param {Object} params - Command parameters
         */
        _commandSessionStorage(params) {
            try {
                const action = params.action || 'getAll';
                
                switch (action) {
                    case 'get':
                        if (!params.key) {
                            throw new Error('Key is required for get action');
                        }
                        return { value: sessionStorage.getItem(params.key) };
                        
                    case 'set':
                        if (!params.key || params.value === undefined) {
                            throw new Error('Key and value are required for set action');
                        }
                        sessionStorage.setItem(params.key, params.value);
                        return true;
                        
                    case 'remove':
                        if (!params.key) {
                            throw new Error('Key is required for remove action');
                        }
                        sessionStorage.removeItem(params.key);
                        return true;
                        
                    case 'clear':
                        sessionStorage.clear();
                        return true;
                        
                    case 'getAll':
                        const items = {};
                        for (let i = 0; i < sessionStorage.length; i++) {
                            const key = sessionStorage.key(i);
                            items[key] = sessionStorage.getItem(key);
                        }
                        return { items };
                        
                    default:
                        throw new Error(`Unknown sessionStorage action: ${action}`);
                }
            } catch (error) {
                throw new Error(`Failed to perform sessionStorage action: ${error.message}`);
            }
        }
        
        /**
         * Command handler for starting recording
         * @private
         */
        _commandStartRecording() {
            try {
                if (this.eventCapture) {
                    this.eventCapture.start();
                }
                
                return { status: 'recording' };
            } catch (error) {
                throw new Error(`Failed to start recording: ${error.message}`);
            }
        }
        
        /**
         * Command handler for stopping recording
         * @private
         */
        _commandStopRecording() {
            try {
                if (this.eventCapture) {
                    this.eventCapture.stop();
                }
                
                return { status: 'stopped' };
            } catch (error) {
                throw new Error(`Failed to stop recording: ${error.message}`);
            }
        }
        
        /**
         * Command handler for pausing recording
         * @private
         */
        _commandPauseRecording() {
            try {
                if (this.eventCapture) {
                    this.eventCapture.pause();
                }
                
                return { status: 'paused' };
            } catch (error) {
                throw new Error(`Failed to pause recording: ${error.message}`);
            }
        }
        
        /**
         * Command handler for resuming recording
         * @private
         */
        _commandResumeRecording() {
            try {
                if (this.eventCapture) {
                    this.eventCapture.resume();
                }
                
                return { status: 'recording' };
            } catch (error) {
                throw new Error(`Failed to resume recording: ${error.message}`);
            }
        }
        
        /**
         * Command handler for getting system info
         * @private
         */
        _commandGetSystemInfo() {
            return {
                browserDetails: this.browserDetails,
                features: this.features,
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                languages: navigator.languages,
                userAgent: navigator.userAgent,
                vendor: navigator.vendor,
                platform: navigator.platform,
                memory: performance.memory ? {
                    totalJSHeapSize: performance.memory.totalJSHeapSize,
                    usedJSHeapSize: performance.memory.usedJSHeapSize,
                    jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
                } : null,
                screenSize: {
                    width: window.screen.width,
                    height: window.screen.height,
                    availWidth: window.screen.availWidth,
                    availHeight: window.screen.availHeight,
                    colorDepth: window.screen.colorDepth,
                    pixelDepth: window.screen.pixelDepth
                },
                windowSize: {
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight,
                    outerWidth: window.outerWidth,
                    outerHeight: window.outerHeight
                },
                devicePixelRatio: window.devicePixelRatio,
                timestamp: Date.now()
            };
        }
        
        /**
         * Command handler for ping
         * @private
         */
        _commandPing() {
            return {
                timestamp: Date.now(),
                status: 'ok'
            };
        }
        
        /**
         * Get element info from an element
         * @private
         * @param {Element} element - DOM element
         * @returns {Object} Element information
         */
        _getElementInfo(element) {
            if (!element) {
                return null;
            }
            
            try {
                // Get element rectangle
                const rect = element.getBoundingClientRect();
                
                // Get text content (limited to 1000 chars)
                const textContent = element.textContent ? 
                    element.textContent.substring(0, 1000) : '';
                
                // Get value for form elements
                let value = null;
                if (element.tagName.toLowerCase() === 'input' || 
                    element.tagName.toLowerCase() === 'textarea' || 
                    element.tagName.toLowerCase() === 'select') {
                    
                    if (element.type === 'password') {
                        // Mask password values
                        value = '********';
                    } else if (element.type === 'checkbox' || element.type === 'radio') {
                        value = element.checked;
                    } else {
                        value = element.value;
                    }
                }
                
                // Get XPath
                const xpath = this._getElementXPath(element);
                
                // Get CSS selector
                const cssSelector = this._getElementCssSelector(element);
                
                // Get element attributes
                const attributes = this._getElementAttributes(element);
                
                // Get computed style properties
                const computedStyle = window.getComputedStyle(element);
                const styles = {
                    color: computedStyle.color,
                    backgroundColor: computedStyle.backgroundColor,
                    fontSize: computedStyle.fontSize,
                    fontWeight: computedStyle.fontWeight,
                    display: computedStyle.display,
                    visibility: computedStyle.visibility,
                    position: computedStyle.position,
                    zIndex: computedStyle.zIndex,
                    opacity: computedStyle.opacity
                };
                
                // Element state
                const state = {
                    isVisible: this._isElementVisible(element),
                    isEnabled: !element.disabled,
                    isChecked: element.checked || false
                };
                
                return {
                    tagName: element.tagName,
                    id: element.id,
                    name: element.getAttribute('name'),
                    className: element.className,
                    type: element.getAttribute('type'),
                    value: value,
                    textContent: textContent,
                    attributes: attributes,
                    styles: styles,
                    state: state,
                    rect: {
                        left: rect.left,
                        top: rect.top,
                        right: rect.right,
                        bottom: rect.bottom,
                        width: rect.width,
                        height: rect.height,
                        x: rect.x,
                        y: rect.y
                    },
                    xpath: xpath,
                    cssSelector: cssSelector
                };
            } catch (error) {
                this._error('Error getting element info', error);
                
                // Return basic info on error
                return {
                    tagName: element.tagName,
                    id: element.id,
                    className: element.className,
                    error: error.message
                };
            }
        }
        
        /**
         * Get element attributes
         * @private
         * @param {Element} element - DOM element
         * @returns {Object} Element attributes
         */
        _getElementAttributes(element) {
            const attributes = {};
            
            if (!element || !element.attributes) {
                return attributes;
            }
            
            for (let i = 0; i < element.attributes.length; i++) {
                const attr = element.attributes[i];
                attributes[attr.name] = attr.value;
            }
            
            return attributes;
        }
        
        /**
         * Get XPath for element
         * @private
         * @param {Element} element - DOM element
         * @returns {string} XPath
         */
        _getElementXPath(element) {
            if (!element) {
                return '';
            }
            
            if (element === document.body) {
                return '/html/body';
            }
            
            // Check if element has an ID
            if (element.id) {
                // Use ID-based XPath for elements with unique IDs
                return `//*[@id="${element.id}"]`;
            }
            
            // For other elements, generate full path
            const paths = [];
            
            // Use helper function to generate paths
            while (element && element.nodeType === Node.ELEMENT_NODE) {
                let index = 0;
                let hasFollowingSiblingsWithSameTag = false;
                
                // Count previous siblings with same tag name
                let sibling = element.previousSibling;
                while (sibling) {
                    if (sibling.nodeType === Node.ELEMENT_NODE && 
                        sibling.tagName === element.tagName) {
                        index++;
                    }
                    sibling = sibling.previousSibling;
                }
                
                // Check if there are any following siblings with same tag
                sibling = element.nextSibling;
                while (sibling && !hasFollowingSiblingsWithSameTag) {
                    if (sibling.nodeType === Node.ELEMENT_NODE && 
                        sibling.tagName === element.tagName) {
                        hasFollowingSiblingsWithSameTag = true;
                    }
                    sibling = sibling.nextSibling;
                }
                
                // Generate path for current element
                const tagName = element.tagName.toLowerCase();
                const pathIndex = (index || hasFollowingSiblingsWithSameTag) ? 
                    `[${index + 1}]` : '';
                    
                paths.unshift(tagName + pathIndex);
                
                // Move up to parent
                element = element.parentNode;
            }
            
            return '/' + paths.join('/');
        }
        
        /**
         * Get CSS selector for element
         * @private
         * @param {Element} element - DOM element
         * @returns {string} CSS selector
         */
        _getElementCssSelector(element) {
            if (!element) {
                return '';
            }
            
            if (element === document.body) {
                return 'body';
            }
            
            // Try to create a unique selector with ID
            if (element.id) {
                return `#${CSS.escape(element.id)}`;
            }
            
            // Try with classes
            if (element.className) {
                const classSelector = '.' + Array.from(element.classList)
                    .map(c => CSS.escape(c))
                    .join('.');
                
                // Check if this uniquely identifies the element
                if (document.querySelectorAll(classSelector).length === 1) {
                    return classSelector;
                }
            }
            
            // Generate more complex selector
            let selector = element.tagName.toLowerCase();
            
            // Add useful attributes
            if (element.getAttribute('name')) {
                selector += `[name="${CSS.escape(element.getAttribute('name'))}"]`;
            }
            
            if (element.getAttribute('type')) {
                selector += `[type="${CSS.escape(element.getAttribute('type'))}"]`;
            }
            
            if (element.getAttribute('role')) {
                selector += `[role="${CSS.escape(element.getAttribute('role'))}"]`;
            }
            
            // If more specificity needed, add nth-child
            const parent = element.parentNode;
            if (parent && parent.children.length > 1) {
                let nthChild = 1;
                for (let i = 0; i < parent.children.length; i++) {
                    if (parent.children[i] === element) {
                        break;
                    }
                    if (parent.children[i].tagName === element.tagName) {
                        nthChild++;
                    }
                }
                
                if (nthChild > 1 || parent.querySelectorAll(selector).length > 1) {
                    selector += `:nth-of-type(${nthChild})`;
                }
            }
            
            // If element still not uniquely identified, add parent context
            if (document.querySelectorAll(selector).length > 1 && element.parentElement) {
                const parentSelector = this._getElementCssSelector(element.parentElement);
                if (parentSelector) {
                    selector = `${parentSelector} > ${selector}`;
                }
            }
            
            return selector;
        }
        
        /**
         * Check if element is visible
         * @private
         * @param {Element} element - DOM element
         * @returns {boolean} True if element is visible
         */
        _isElementVisible(element) {
            if (!element) {
                return false;
            }
            
            // Check if element is in DOM
            if (!document.body.contains(element)) {
                return false;
            }
            
            const style = window.getComputedStyle(element);
            
            // Check basic display/visibility properties
            if (style.display === 'none' || 
                style.visibility === 'hidden' || 
                style.opacity === '0') {
                return false;
            }
            
            // Check element dimensions
            const rect = element.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                return false;
            }
            
            // Check if element is in viewport
            if (rect.right < 0 || 
                rect.bottom < 0 || 
                rect.left > window.innerWidth || 
                rect.top > window.innerHeight) {
                return false;
            }
            
            // Check if covered by another element
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Get element at point, considering potential shadow DOM
            let elementAtPoint = document.elementFromPoint(centerX, centerY);
            while (elementAtPoint && elementAtPoint.shadowRoot) {
                const pointInShadow = elementAtPoint.shadowRoot.elementFromPoint(centerX, centerY);
                if (!pointInShadow || pointInShadow === elementAtPoint) {
                    break;
                }
                elementAtPoint = pointInShadow;
            }
            
            // Check if element or any of its descendants is at the center point
            if (elementAtPoint) {
                return element === elementAtPoint || element.contains(elementAtPoint) || 
                       elementAtPoint.contains(element);
            }
            
            return false;
        }
        
        /**
         * Find an element by various locator types
         * @private
         * @param {Object} locator - Element locator
         * @returns {Promise<Element>} Found element or null
         */
        async _findElement(locator) {
            if (!locator) {
                throw new Error('Locator is required');
            }
            
            // Support different locator types
            if (locator.id) {
                return document.getElementById(locator.id);
            }
            
            if (locator.css) {
                return document.querySelector(locator.css);
            }
            
            if (locator.xpath) {
                return this._findElementByXPath(locator.xpath);
            }
            
            if (locator.name) {
                return document.querySelector(`[name="${CSS.escape(locator.name)}"]`);
            }
            
            if (locator.linkText) {
                const links = Array.from(document.querySelectorAll('a'));
                return links.find(link => link.textContent.trim() === locator.linkText);
            }
            
            if (locator.partialLinkText) {
                const links = Array.from(document.querySelectorAll('a'));
                return links.find(link => link.textContent.includes(locator.partialLinkText));
            }
            
            if (locator.tagName) {
                return document.querySelector(locator.tagName);
            }
            
            if (locator.className) {
                return document.querySelector(`.${CSS.escape(locator.className)}`);
            }
            
            if (locator.text) {
                return this._findElementByText(locator.text, locator.exact !== false);
            }
            
            if (locator.attributes) {
                let selector = '*';
                for (const [attr, value] of Object.entries(locator.attributes)) {
                    selector += `[${attr}="${CSS.escape(value)}"]`;
                }
                return document.querySelector(selector);
            }
            
            if (locator.js) {
                // Execute JavaScript to find element
                return await this.injectScript(`
                    (function() {
                        return ${locator.js};
                    })();
                `);
            }
            
            throw new Error(`Unsupported locator: ${JSON.stringify(locator)}`);
        }
        
        /**
         * Find elements by various locator types
         * @private
         * @param {Object} locator - Element locator
         * @returns {Promise<Element[]>} Found elements
         */
        async _findElements(locator) {
            if (!locator) {
                throw new Error('Locator is required');
            }
            
            // Support different locator types
            if (locator.id) {
                const element = document.getElementById(locator.id);
                return element ? [element] : [];
            }
            
            if (locator.css) {
                return Array.from(document.querySelectorAll(locator.css));
            }
            
            if (locator.xpath) {
                return this._findElementsByXPath(locator.xpath);
            }
            
            if (locator.name) {
                return Array.from(document.querySelectorAll(`[name="${CSS.escape(locator.name)}"]`));
            }
            
            if (locator.linkText) {
                const links = Array.from(document.querySelectorAll('a'));
                return links.filter(link => link.textContent.trim() === locator.linkText);
            }
            
            if (locator.partialLinkText) {
                const links = Array.from(document.querySelectorAll('a'));
                return links.filter(link => link.textContent.includes(locator.partialLinkText));
            }
            
            if (locator.tagName) {
                return Array.from(document.querySelectorAll(locator.tagName));
            }
            
            if (locator.className) {
                return Array.from(document.querySelectorAll(`.${CSS.escape(locator.className)}`));
            }
            
            if (locator.text) {
                return this._findElementsByText(locator.text, locator.exact !== false);
            }
            
            if (locator.attributes) {
                let selector = '*';
                for (const [attr, value] of Object.entries(locator.attributes)) {
                    selector += `[${attr}="${CSS.escape(value)}"]`;
                }
                return Array.from(document.querySelectorAll(selector));
            }
            
            if (locator.js) {
                // Execute JavaScript to find elements
                const result = await this.injectScript(`
                    (function() {
                        const result = ${locator.js};
                        if (result instanceof Element) {
                            return [result];
                        } else if (Array.isArray(result)) {
                            return result.filter(item => item instanceof Element);
                        } else if (result instanceof NodeList || result instanceof HTMLCollection) {
                            return Array.from(result);
                        }
                        return [];
                    })();
                `);
                
                return result || [];
            }
            
            throw new Error(`Unsupported locator: ${JSON.stringify(locator)}`);
        }
        
        /**
         * Find element by XPath
         * @private
         * @param {string} xpath - XPath expression
         * @returns {Element} Found element or null
         */
        _findElementByXPath(xpath) {
            try {
                const result = document.evaluate(
                    xpath,
                    document,
                    null,
                    XPathResult.FIRST_ORDERED_NODE_TYPE,
                    null
                );
                
                return result.singleNodeValue;
            } catch (error) {
                this._error(`Invalid XPath: ${xpath}`, error);
                return null;
            }
        }
        
        /**
         * Find elements by XPath
         * @private
         * @param {string} xpath - XPath expression
         * @returns {Element[]} Found elements
         */
        _findElementsByXPath(xpath) {
            try {
                const result = document.evaluate(
                    xpath,
                    document,
                    null,
                    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
                    null
                );
                
                const elements = [];
                for (let i = 0; i < result.snapshotLength; i++) {
                    elements.push(result.snapshotItem(i));
                }
                
                return elements;
            } catch (error) {
                this._error(`Invalid XPath: ${xpath}`, error);
                return [];
            }
        }
        
        /**
         * Find element by text content
         * @private
         * @param {string} text - Text to search for
         * @param {boolean} exact - Whether to match exact text
         * @returns {Element} Found element or null
         */
        _findElementByText(text, exact = true) {
            // Firefox-optimized text search
            // Create a text filter function
            const matchesText = exact ?
                (element) => element.textContent.trim() === text :
                (element) => element.textContent.includes(text);
            
            // Use TreeWalker API which is very efficient in Firefox
            const walker = document.createTreeWalker(
                document.body,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        const parent = node.parentElement;
                        if (!parent) return NodeFilter.FILTER_REJECT;
                        
                        return matchesText({ textContent: node.nodeValue }) ?
                            NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                    }
                }
            );
            
            // Find first matching text node
            const textNode = walker.nextNode();
            if (textNode) {
                // Return the element containing this text
                return textNode.parentElement;
            }
            
            // Alternative approach - check elements directly
            const elements = document.querySelectorAll('*');
            for (const element of elements) {
                if (matchesText(element)) {
                    return element;
                }
            }
            
            return null;
        }
        
        /**
         * Find elements by text content
         * @private
         * @param {string} text - Text to search for
         * @param {boolean} exact - Whether to match exact text
         * @returns {Element[]} Found elements
         */
        _findElementsByText(text, exact = true) {
            const results = [];
            
            // Create a text filter function
            const matchesText = exact ?
                (element) => element.textContent.trim() === text :
                (element) => element.textContent.includes(text);
            
            // Use TreeWalker for efficiency in Firefox
            const walker = document.createTreeWalker(
                document.body,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        const parent = node.parentElement;
                        if (!parent) return NodeFilter.FILTER_REJECT;
                        
                        return matchesText({ textContent: node.nodeValue }) ?
                            NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                    }
                }
            );
            
            // Collect all matching text nodes
            let textNode;
            while (textNode = walker.nextNode()) {
                const parent = textNode.parentElement;
                if (parent && !results.includes(parent)) {
                    results.push(parent);
                }
            }
            
            // Alternative approach for elements with child nodes
            const elements = document.querySelectorAll('*');
            for (const element of elements) {
                if (matchesText(element) && !results.includes(element)) {
                    results.push(element);
                }
            }
            
            return results;
        }
        
        /**
         * Add event listener with cleanup registration
         * @private
         * @param {EventTarget} target - Event target
         * @param {string} type - Event type
         * @param {Function} listener - Event listener
         * @param {boolean|Object} options - Event listener options
         */
        _addEventListenerWithCleanup(target, type, listener, options) {
            target.addEventListener(type, listener, options);
            
            // Register for cleanup
            this.listeners = this.listeners || {};
            this.listeners[type] = this.listeners[type] || [];
            this.listeners[type].push({ target, listener });
        }
        
        /**
         * Remove all registered event listeners
         * @private
         */
        _removeAllEventListeners() {
            if (!this.listeners) return;
            
            for (const type in this.listeners) {
                for (const { target, listener } of this.listeners[type]) {
                    target.removeEventListener(type, listener);
                }
            }
            
            this.listeners = {};
        }
        
        /**
         * Disconnect all observers
         * @private
         */
        _disconnectAllObservers() {
            if (!this.observers) return;
            
            for (const key in this.observers) {
                if (this.observers[key] && typeof this.observers[key].disconnect === 'function') {
                    this.observers[key].disconnect();
                }
            }
            
            this.observers = {};
        }
        
        /**
         * Remove injected elements
         * @private
         */
        _removeInjectedElements() {
            // Remove all elements with data-cs-test-forge attribute
            const elements = document.querySelectorAll('[data-cs-test-forge]');
            for (const element of elements) {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            }
        }
        
        /**
         * Restore original console functions
         * @private
         */
        _restoreConsole() {
            if (this._originalConsole) {
                for (const method in this._originalConsole) {
                    console[method] = this._originalConsole[method];
                }
                this._originalConsole = null;
            }
            
            // Restore XHR and fetch if patched
            if (this._originalXHR) {
                XMLHttpRequest.prototype.open = this._originalXHR.open;
                XMLHttpRequest.prototype.send = this._originalXHR.send;
                XMLHttpRequest.prototype.setRequestHeader = this._originalXHR.setRequestHeader;
                this._originalXHR = null;
            }
            
            if (this._originalFetch) {
                window.fetch = this._originalFetch;
                this._originalFetch = null;
            }
        }
        
        /**
         * Close communication channel
         * @private
         */
        _closeCommunication() {
            if (this.port) {
                try {
                    this.port.disconnect();
                } catch (e) {
                    // Ignore errors during disconnect
                }
                this.port = null;
            }
            
            // Clear any pending timeouts
            if (this._networkCaptureInterval) {
                clearInterval(this._networkCaptureInterval);
                this._networkCaptureInterval = null;
            }
            
            if (this._domMutationTimeout) {
                clearTimeout(this._domMutationTimeout);
                this._domMutationTimeout = null;
            }
        }
        
        /**
         * Check if element is from CSTestForge
         * @private
         * @param {Element} element - Element to check
         * @returns {boolean} Whether element is from CSTestForge
         */
        _isFromCsTestForge(element) {
            if (!element || element.nodeType !== Node.ELEMENT_NODE) {
                return false;
            }
            
            // Check for our data attribute
            if (element.hasAttribute('data-cs-test-forge')) {
                return true;
            }
            
            // Check for our namespace
            if (element.id && element.id.startsWith('cs-test-forge-')) {
                return true;
            }
            
            // Check for our class
            if (element.className && typeof element.className === 'string' && 
                element.className.includes('cs-test-forge-')) {
                return true;
            }
            
            return false;
        }
        
        /**
         * Get resource URL for injector resources
         * @private
         * @param {string} resource - Resource name
         * @returns {string} Resource URL
         */
        _getResourceUrl(resource) {
            if (this.config.extensionMode && this.features.supportsExtensionAPI) {
                // Firefox extension mode
                return browser.runtime.getURL(resource);
            } else {
                // Standalone mode
                const baseUrl = this.config.resourceBaseUrl || '';
                return `${baseUrl}/${resource}`;
            }
        }
        
        /**
         * Log message (only in debug mode)
         * @private
         * @param {string} message - Message to log
         * @param {*} data - Optional data to log
         */
        _log(message, data) {
            if (!this.config.debugMode) return;
            
            if (data !== undefined) {
                console.log(`[CSTestForge:Firefox] ${message}`, data);
            } else {
                console.log(`[CSTestForge:Firefox] ${message}`);
            }
        }
        
        /**
         * Log warning
         * @private
         * @param {string} message - Warning message
         * @param {*} data - Optional data
         */
        _warn(message, data) {
            if (data !== undefined) {
                console.warn(`[CSTestForge:Firefox] ${message}`, data);
            } else {
                console.warn(`[CSTestForge:Firefox] ${message}`);
            }
        }
        
        /**
         * Log error
         * @private
         * @param {string} message - Error message
         * @param {Error} error - Error object
         */
        _error(message, error) {
            console.error(`[CSTestForge:Firefox] ${message}`, error);
        }
    }
    
    // Make available globally
    window.CSTestForge = window.CSTestForge || {};
    window.CSTestForge.FirefoxInjector = FirefoxInjector;
    
    // Auto-initialize if configured
    if (window.CSTestForge.autoInitialize) {
        const injector = new FirefoxInjector(window.CSTestForge.config);
        injector.initialize().then(() => {
            window.CSTestForge.injector = injector;
        });
    }
})();


recorder/firefox/manifest.json
--------------------------------------------

{
  "manifest_version": 2,
  "name": "CSTestForge Recorder",
  "description": "Advanced test automation recorder for Selenium and Playwright",
  "version": "1.0.0",
  "browser_action": {
    "default_title": "CSTestForge Recorder",
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "32": "icons/icon32.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "icons": {
    "16": "icons/icon16.png",
    "32": "icons/icon32.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "permissions": [
    "activeTab",
    "tabs",
    "<all_urls>",
    "storage",
    "downloads",
    "cookies",
    "webNavigation",
    "webRequest",
    "clipboardWrite"
  ],
  "background": {
    "scripts": ["background.js"]
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content-script.js"],
      "run_at": "document_start"
    }
  ],
  "web_accessible_resources": [
    "injected/*",
    "polyfills.js",
    "event-capture.js",
    "dom-observer.js",
    "element-identifier.js",
    "network-monitor.js",
    "timing-collector.js",
    "feature-detector.js",
    "version-detector.js",
    "base-injector.js",
    "firefox-injector.js"
  ],
  "commands": {
    "toggle-recording": {
      "suggested_key": {
        "default": "Ctrl+Shift+R",
        "mac": "Command+Shift+R"
      },
      "description": "Toggle recording"
    },
    "take-screenshot": {
      "suggested_key": {
        "default": "Ctrl+Shift+S",
        "mac": "Command+Shift+S"
      },
      "description": "Take screenshot"
    }
  },
  "options_ui": {
    "page": "options.html",
    "open_in_tab": true
  },
  "applications": {
    "gecko": {
      "id": "cstestforge-recorder@example.com",
      "strict_min_version": "60.0"
    }
  }
}


recorder/firefox/background.js
------------------------------------------

// Firefox Extension Background Script for CSTestForge
// Handles communication between recorder application and browser content scripts

// State management for active recording sessions
let recordingActive = false;
let recordingTabId = null;
let recordingFrameId = 0;
let recordingSessionId = null;
let portConnection = null;
let pendingEvents = [];
let recordingConfig = {
  captureNetwork: true,
  captureDOMChanges: true,
  captureConsole: true,
  recordFrames: true,
  elementDetectionLevel: 'advanced'
};

// Connection to the main application
browser.runtime.onConnect.addListener(port => {
  if (port.name === "cs-testforge-recorder") {
    portConnection = port;
    console.log("Connected to CSTestForge recorder application");
    
    // Handle messages from the recorder application
    port.onMessage.addListener(handleRecorderMessage);
    
    // Handle disconnection
    port.onDisconnect.addListener(() => {
      console.log("Disconnected from CSTestForge recorder application");
      portConnection = null;
      if (recordingActive) {
        stopRecording();
      }
    });
    
    // Send any pending events that occurred before connection was established
    if (pendingEvents.length > 0) {
      pendingEvents.forEach(event => port.postMessage(event));
      pendingEvents = [];
    }
  }
});

// Handle messages from content scripts
browser.runtime.onMessage.addListener((message, sender) => {
  if (!message.type || !message.type.startsWith('cstestforge_')) {
    return;
  }
  
  // Add sender information to the message
  message.sender = {
    tabId: sender.tab.id,
    frameId: sender.frameId || 0,
    url: sender.url || sender.tab.url
  };
  
  // Add timestamp if not present
  if (!message.timestamp) {
    message.timestamp = Date.now();
  }
  
  // Add session ID if recording is active
  if (recordingActive && recordingSessionId) {
    message.sessionId = recordingSessionId;
  }
  
  // Handle specific message types
  switch (message.type) {
    case 'cstestforge_dom_event':
      handleDomEvent(message);
      break;
    case 'cstestforge_network_event':
      handleNetworkEvent(message);
      break;
    case 'cstestforge_console_event':
      handleConsoleEvent(message);
      break;
    case 'cstestforge_element_info':
      handleElementInfo(message);
      break;
    case 'cstestforge_error':
      handleErrorEvent(message);
      break;
    case 'cstestforge_ready':
      handleContentScriptReady(message, sender);
      break;
    default:
      // Forward unknown message types to the recorder app
      forwardToRecorder(message);
      break;
  }
  
  // Return true to indicate async response
  return true;
});

// Handle recorder application messages
function handleRecorderMessage(message) {
  switch (message.command) {
    case 'start_recording':
      startRecording(message.tabId, message.config, message.sessionId);
      break;
    case 'stop_recording':
      stopRecording();
      break;
    case 'pause_recording':
      pauseRecording();
      break;
    case 'resume_recording':
      resumeRecording();
      break;
    case 'update_config':
      updateConfig(message.config);
      break;
    case 'inject_script':
      injectScript(message.tabId, message.frameId, message.script);
      break;
    case 'highlight_element':
      highlightElement(message.tabId, message.frameId, message.selector, message.duration);
      break;
    case 'get_element_info':
      getElementInfo(message.tabId, message.frameId, message.selector);
      break;
    case 'execute_action':
      executeAction(message.tabId, message.frameId, message.action);
      break;
    case 'ping':
      respondToPing(message.id);
      break;
    case 'screenshot':
      captureScreenshot(message.tabId, message.area);
      break;
    default:
      console.warn('Unknown command received:', message.command);
      break;
  }
}

// Start recording
function startRecording(tabId, config, sessionId) {
  if (recordingActive) {
    stopRecording();
  }
  
  recordingActive = true;
  recordingTabId = tabId;
  recordingSessionId = sessionId || generateSessionId();
  
  if (config) {
    recordingConfig = {...recordingConfig, ...config};
  }
  
  // Inject content scripts to the target tab and all frames
  injectContentScripts(tabId);
  
  // Update badge
  browser.browserAction.setBadgeText({text: "REC"});
  browser.browserAction.setBadgeBackgroundColor({color: "#C54B8C"});
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_recording_started',
    sessionId: recordingSessionId,
    tabId: tabId,
    timestamp: Date.now(),
    config: recordingConfig
  });
  
  // Add tab event listeners
  setupTabListeners();
}

// Stop recording
function stopRecording() {
  if (!recordingActive) {
    return;
  }
  
  recordingActive = false;
  
  // Reset badge
  browser.browserAction.setBadgeText({text: ""});
  
  // Uninject content scripts
  uninjectContentScripts(recordingTabId);
  
  // Remove tab event listeners
  removeTabListeners();
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_recording_stopped',
    sessionId: recordingSessionId,
    timestamp: Date.now()
  });
  
  recordingTabId = null;
}

// Pause recording
function pauseRecording() {
  if (!recordingActive) {
    return;
  }
  
  // Update content scripts to pause event capture
  sendToContentScripts(recordingTabId, {
    command: 'pause_recording'
  });
  
  // Update badge
  browser.browserAction.setBadgeText({text: "||"});
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_recording_paused',
    sessionId: recordingSessionId,
    timestamp: Date.now()
  });
}

// Resume recording
function resumeRecording() {
  if (!recordingActive) {
    return;
  }
  
  // Update content scripts to resume event capture
  sendToContentScripts(recordingTabId, {
    command: 'resume_recording'
  });
  
  // Update badge
  browser.browserAction.setBadgeText({text: "REC"});
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_recording_resumed',
    sessionId: recordingSessionId,
    timestamp: Date.now()
  });
}

// Update recording configuration
function updateConfig(config) {
  recordingConfig = {...recordingConfig, ...config};
  
  // Update content scripts with new configuration
  if (recordingActive) {
    sendToContentScripts(recordingTabId, {
      command: 'update_config',
      config: recordingConfig
    });
  }
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_config_updated',
    config: recordingConfig,
    timestamp: Date.now()
  });
}

// Inject custom script to page
function injectScript(tabId, frameId, script) {
  browser.tabs.executeScript(tabId, {
    frameId: frameId || 0,
    code: script
  }).then(results => {
    sendToRecorder({
      type: 'cstestforge_script_injected',
      tabId: tabId,
      frameId: frameId || 0,
      result: results && results[0],
      timestamp: Date.now()
    });
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'script_injection',
      tabId: tabId,
      frameId: frameId || 0,
      timestamp: Date.now()
    });
  });
}

// Highlight an element
function highlightElement(tabId, frameId, selector, duration) {
  const highlightScript = `
    (function() {
      try {
        const element = document.querySelector('${selector.replace(/'/g, "\\'")}');
        if (!element) return false;
        
        const originalOutline = element.style.outline;
        const originalOutlineOffset = element.style.outlineOffset;
        const originalTransition = element.style.transition;
        const originalPosition = element.style.position;
        const originalZIndex = element.style.zIndex;
        
        element.style.outline = '2px solid #C54B8C';
        element.style.outlineOffset = '2px';
        element.style.transition = 'outline 0.2s ease-in-out';
        element.style.position = originalPosition === 'static' ? 'relative' : originalPosition;
        element.style.zIndex = '99999';
        
        setTimeout(() => {
          element.style.outline = originalOutline;
          element.style.outlineOffset = originalOutlineOffset;
          element.style.transition = originalTransition;
          element.style.position = originalPosition;
          element.style.zIndex = originalZIndex;
        }, ${duration || 1000});
        
        return true;
      } catch (e) {
        console.error('CSTestForge highlight error:', e);
        return false;
      }
    })();
  `;
  
  browser.tabs.executeScript(tabId, {
    frameId: frameId || 0,
    code: highlightScript
  }).then(results => {
    sendToRecorder({
      type: 'cstestforge_element_highlighted',
      tabId: tabId,
      frameId: frameId || 0,
      selector: selector,
      success: results && results[0],
      timestamp: Date.now()
    });
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'highlight_element',
      selector: selector,
      tabId: tabId,
      frameId: frameId || 0,
      timestamp: Date.now()
    });
  });
}

// Get detailed element information
function getElementInfo(tabId, frameId, selector) {
  const script = `
    (function() {
      try {
        const element = document.querySelector('${selector.replace(/'/g, "\\'")}');
        if (!element) return null;
        
        // Calculate element visibility
        const rect = element.getBoundingClientRect();
        const isInViewport = rect.top < window.innerHeight && rect.left < window.innerWidth && rect.bottom > 0 && rect.right > 0;
        
        // Compute computed styles
        const computedStyle = window.getComputedStyle(element);
        const isVisible = !(computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0');
        
        // Get element attributes
        const attributes = {};
        for (let i = 0; i < element.attributes.length; i++) {
          const attr = element.attributes[i];
          attributes[attr.name] = attr.value;
        }
        
        // Generate XPath
        function getXPath(element) {
          if (!element) return '';
          
          if (element.id) {
            return `//*[@id="${element.id}"]`;
          }
          
          if (element === document.body) {
            return '/html/body';
          }
          
          let ix = 0;
          const siblings = element.parentNode.childNodes;
          
          for (let i = 0; i < siblings.length; i++) {
            const sibling = siblings[i];
            
            if (sibling === element) {
              const tagName = element.tagName.toLowerCase();
              const pathIndex = ix + 1;
              const parentPath = getXPath(element.parentNode);
              
              return `${parentPath}/${tagName}[${pathIndex}]`;
            }
            
            if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
              ix++;
            }
          }
        }
        
        // Generate CSS Selector
        function generateCssSelector(element) {
          if (!element) return '';
          if (element.id) return `#${element.id}`;
          
          let selector = element.tagName.toLowerCase();
          
          if (element.className) {
            const classes = element.className.split(' ').filter(c => c && !c.startsWith('ng-') && !c.includes(':'));
            if (classes.length > 0) {
              selector += '.' + classes.join('.');
            }
          }
          
          // Add attribute selectors for specific attributes
          const relevantAttrs = ['name', 'type', 'role', 'data-test', 'data-testid', 'data-test-id', 'data-cy'];
          for (const attr of relevantAttrs) {
            if (element.hasAttribute(attr)) {
              selector += `[${attr}="${element.getAttribute(attr)}"]`;
              break; // Just use one unique attribute
            }
          }
          
          return selector;
        }
        
        // Smart CSS Selector
        function generateSmartSelector(element) {
          if (!element) return '';
          
          // Start with the element's tag
          let selector = element.tagName.toLowerCase();
          
          // Add ID if it exists and isn't auto-generated
          if (element.id && !/^[0-9]/.test(element.id) && !element.id.includes(':')) {
            return `#${element.id}`;
          }
          
          // Add specific attribute selectors
          const preferredAttrs = [
            'data-testid', 'data-test', 'data-test-id', 'data-cy', 'data-automation',
            'name', 'aria-label', 'title', 'for', 'alt'
          ];
          
          for (const attr of preferredAttrs) {
            if (element.hasAttribute(attr)) {
              selector += `[${attr}="${element.getAttribute(attr)}"]`;
              return selector; // These are usually unique enough
            }
          }
          
          // Add classes that don't look auto-generated
          if (element.className) {
            const classes = element.className.split(' ')
              .filter(c => c && !c.includes(':') && !c.startsWith('ng-') && !/^[a-z][0-9]$/.test(c) && c.length > 2);
            
            if (classes.length === 1) {
              selector += `.${classes[0]}`;
            } else if (classes.length > 1) {
              // Just use the first 2 classes to avoid over-specificity
              selector += `.${classes[0]}.${classes[1]}`;
            }
          }
          
          // Make selector more specific by adding parent context
          if (element.parentElement && element.parentElement !== document.body) {
            const parentTag = element.parentElement.tagName.toLowerCase();
            
            // If parent has ID, use that
            if (element.parentElement.id && !/^[0-9]/.test(element.parentElement.id) && !element.parentElement.id.includes(':')) {
              return `#${element.parentElement.id} > ${selector}`;
            }
            
            // Otherwise just use parent tag
            return `${parentTag} > ${selector}`;
          }
          
          return selector;
        }
        
        return {
          tagName: element.tagName,
          id: element.id,
          className: element.className,
          attributes: attributes,
          text: element.textContent.trim().substring(0, 100),
          value: element.value,
          type: element.type,
          checked: element.checked,
          dimensions: {
            width: rect.width,
            height: rect.height,
            top: rect.top,
            left: rect.left,
            bottom: rect.bottom,
            right: rect.right
          },
          isInViewport: isInViewport,
          isVisible: isVisible,
          xpath: getXPath(element),
          cssSelector: generateCssSelector(element),
          smartSelector: generateSmartSelector(element)
        };
      } catch (e) {
        console.error('CSTestForge element info error:', e);
        return null;
      }
    })();
  `;
  
  browser.tabs.executeScript(tabId, {
    frameId: frameId || 0,
    code: script
  }).then(results => {
    sendToRecorder({
      type: 'cstestforge_element_info',
      tabId: tabId,
      frameId: frameId || 0,
      selector: selector,
      elementInfo: results && results[0],
      timestamp: Date.now()
    });
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'get_element_info',
      selector: selector,
      tabId: tabId,
      frameId: frameId || 0,
      timestamp: Date.now()
    });
  });
}

// Execute an action on an element
function executeAction(tabId, frameId, action) {
  const script = `
    (function() {
      try {
        const element = document.querySelector('${action.selector.replace(/'/g, "\\'")}');
        if (!element) return { success: false, error: 'Element not found' };
        
        switch ('${action.type}') {
          case 'click':
            element.click();
            break;
          case 'rightClick':
            const rightClickEvent = new MouseEvent('contextmenu', {
              bubbles: true,
              cancelable: true,
              view: window,
              button: 2,
              buttons: 2
            });
            element.dispatchEvent(rightClickEvent);
            break;
          case 'doubleClick':
            const dblClickEvent = new MouseEvent('dblclick', {
              bubbles: true,
              cancelable: true,
              view: window
            });
            element.dispatchEvent(dblClickEvent);
            break;
          case 'type':
            element.value = '${(action.text || '').replace(/'/g, "\\'")}';
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            break;
          case 'clear':
            element.value = '';
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            break;
          case 'select':
            const options = element.querySelectorAll('option');
            for (let i = 0; i < options.length; i++) {
              const option = options[i];
              if (option.value === '${(action.value || '').replace(/'/g, "\\'")}' || option.text === '${(action.text || '').replace(/'/g, "\\'")}') {
                option.selected = true;
                element.dispatchEvent(new Event('change', { bubbles: true }));
                break;
              }
            }
            break;
          case 'check':
            if (!element.checked) {
              element.click();
            }
            break;
          case 'uncheck':
            if (element.checked) {
              element.click();
            }
            break;
          case 'focus':
            element.focus();
            break;
          case 'blur':
            element.blur();
            break;
          case 'hover':
            const hoverEvent = new MouseEvent('mouseover', {
              bubbles: true,
              cancelable: true,
              view: window
            });
            element.dispatchEvent(hoverEvent);
            break;
          default:
            return { success: false, error: 'Unsupported action type' };
        }
        
        return { success: true };
      } catch (e) {
        console.error('CSTestForge action error:', e);
        return { success: false, error: e.message };
      }
    })();
  `;
  
  browser.tabs.executeScript(tabId, {
    frameId: frameId || 0,
    code: script
  }).then(results => {
    const result = results && results[0];
    sendToRecorder({
      type: 'cstestforge_action_executed',
      tabId: tabId,
      frameId: frameId || 0,
      action: action,
      success: result && result.success,
      error: result && result.error,
      timestamp: Date.now()
    });
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'execute_action',
      action: action,
      tabId: tabId,
      frameId: frameId || 0,
      timestamp: Date.now()
    });
  });
}

// Respond to ping from recorder
function respondToPing(id) {
  sendToRecorder({
    type: 'cstestforge_pong',
    id: id,
    timestamp: Date.now()
  });
}

// Capture screenshot
function captureScreenshot(tabId, area) {
  browser.tabs.captureVisibleTab(null, { format: 'png' }).then(dataUrl => {
    // If area is specified, crop the image
    if (area) {
      cropImage(dataUrl, area).then(croppedDataUrl => {
        sendToRecorder({
          type: 'cstestforge_screenshot',
          tabId: tabId,
          dataUrl: croppedDataUrl,
          timestamp: Date.now()
        });
      }).catch(error => {
        sendToRecorder({
          type: 'cstestforge_error',
          error: error.message,
          context: 'screenshot_crop',
          tabId: tabId,
          timestamp: Date.now()
        });
      });
    } else {
      sendToRecorder({
        type: 'cstestforge_screenshot',
        tabId: tabId,
        dataUrl: dataUrl,
        timestamp: Date.now()
      });
    }
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'screenshot',
      tabId: tabId,
      timestamp: Date.now()
    });
  });
}

// Crop image utility function
function cropImage(dataUrl, area) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = function() {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Ensure crop area doesn't exceed image dimensions
        const cropArea = {
          x: Math.min(area.x, img.width),
          y: Math.min(area.y, img.height),
          width: Math.min(area.width, img.width - area.x),
          height: Math.min(area.height, img.height - area.y)
        };
        
        canvas.width = cropArea.width;
        canvas.height = cropArea.height;
        
        ctx.drawImage(
          img,
          cropArea.x, cropArea.y, cropArea.width, cropArea.height,
          0, 0, cropArea.width, cropArea.height
        );
        
        resolve(canvas.toDataURL('image/png'));
      } catch (e) {
        reject(e);
      }
    };
    img.onerror = function() {
      reject(new Error('Failed to load image for cropping'));
    };
    img.src = dataUrl;
  });
}

// Handle DOM events
function handleDomEvent(message) {
  if (!recordingActive) {
    return;
  }
  
  // Filter events based on configuration
  if (!recordingConfig.captureDOMChanges) {
    return;
  }
  
  // Forward to recorder
  forwardToRecorder(message);
}

// Handle network events
function handleNetworkEvent(message) {
  if (!recordingActive) {
    return;
  }
  
  // Filter events based on configuration
  if (!recordingConfig.captureNetwork) {
    return;
  }
  
  // Forward to recorder
  forwardToRecorder(message);
}

// Handle console events
function handleConsoleEvent(message) {
  if (!recordingActive) {
    return;
  }
  
  // Filter events based on configuration
  if (!recordingConfig.captureConsole) {
    return;
  }
  
  // Forward to recorder
  forwardToRecorder(message);
}

// Handle element info events
function handleElementInfo(message) {
  // Always forward element info events
  forwardToRecorder(message);
}

// Handle error events
function handleErrorEvent(message) {
  // Always forward error events
  forwardToRecorder(message);
}

// Handle content script ready events
function handleContentScriptReady(message, sender) {
  if (recordingActive && recordingTabId === sender.tab.id) {
    // Send recording configuration to the content script
    browser.tabs.sendMessage(sender.tab.id, {
      command: 'start_recording',
      config: recordingConfig,
      sessionId: recordingSessionId
    }, { frameId: sender.frameId || 0 }).catch(error => {
      console.error('Failed to send recording config to content script:', error);
    });
  }
}

// Forward message to recorder application
function forwardToRecorder(message) {
  if (portConnection) {
    portConnection.postMessage(message);
  } else {
    // Store event for sending when connection is established
    pendingEvents.push(message);
    
    // Limit stored events to prevent memory issues
    if (pendingEvents.length > 1000) {
      pendingEvents.shift();
    }
  }
}

// Send message to content scripts
function sendToContentScripts(tabId, message) {
  if (!tabId) {
    return;
  }
  
  browser.tabs.sendMessage(tabId, message).catch(error => {
    console.error('Failed to send message to content scripts:', error);
  });
}

// Inject content scripts to the target tab and all frames
function injectContentScripts(tabId) {
  // Inject event capture script to main frame and all iframes
  const codeToInject = `
    if (!window._csTestForgeInjected) {
      window._csTestForgeInjected = true;
      
      // Notify background script that content script is ready
      browser.runtime.sendMessage({
        type: 'cstestforge_ready',
        timestamp: Date.now(),
        url: window.location.href,
        title: document.title
      });
    }
  `;
  
  // Execute in the main frame
  browser.tabs.executeScript(tabId, {
    file: '/content-script.js',
    runAt: 'document_start'
  }).then(() => {
    browser.tabs.executeScript(tabId, {
      code: codeToInject
    });
  }).catch(error => {
    console.error('Failed to inject content script to main frame:', error);
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'inject_content_script',
      tabId: tabId,
      timestamp: Date.now()
    });
  });
  
  // Find and inject into all iframes if needed
  if (recordingConfig.recordFrames) {
    browser.webNavigation.getAllFrames({ tabId }).then(frames => {
      frames.forEach(frame => {
        if (frame.frameId !== 0) { // Skip main frame (already handled)
          browser.tabs.executeScript(tabId, {
            file: '/content-script.js',
            frameId: frame.frameId,
            runAt: 'document_start'
          }).then(() => {
            browser.tabs.executeScript(tabId, {
              code: codeToInject,
              frameId: frame.frameId
            });
          }).catch(error => {
            console.error(`Failed to inject content script to frame ${frame.frameId}:`, error);
            // Some frames may not be accessible due to same-origin policy, which is expected
          });
        }
      });
    }).catch(error => {
      console.error('Failed to get frames:', error);
    });
  }
}

// Uninject content scripts from the target tab
function uninjectContentScripts(tabId) {
  if (!tabId) {
    return;
  }
  
  const cleanupCode = `
    if (window._csTestForgeInjected) {
      // Clean up event listeners
      window._csTestForgeCleanup && window._csTestForgeCleanup();
      delete window._csTestForgeInjected;
      delete window._csTestForgeCleanup;
    }
  `;
  
  // Execute in the main frame
  browser.tabs.executeScript(tabId, {
    code: cleanupCode
  }).catch(error => {
    console.error('Failed to uninject content script from main frame:', error);
  });
  
  // Find and uninject from all iframes if needed
  if (recordingConfig.recordFrames) {
    browser.webNavigation.getAllFrames({ tabId }).then(frames => {
      frames.forEach(frame => {
        if (frame.frameId !== 0) { // Skip main frame (already handled)
          browser.tabs.executeScript(tabId, {
            code: cleanupCode,
            frameId: frame.frameId
          }).catch(error => {
            // Some frames may not be accessible due to same-origin policy, which is expected
          });
        }
      });
    }).catch(error => {
      console.error('Failed to get frames:', error);
    });
  }
}

// Set up tab event listeners
function setupTabListeners() {
  // Listen for tab navigation events
  browser.webNavigation.onCommitted.addListener(onNavigationCommitted);
  browser.webNavigation.onCompleted.addListener(onNavigationCompleted);
  browser.webNavigation.onDOMContentLoaded.addListener(onDOMContentLoaded);
  browser.webNavigation.onErrorOccurred.addListener(onNavigationError);
  
  // Listen for tab updates
  browser.tabs.onUpdated.addListener(onTabUpdated);
  
  // Listen for tab removal
  browser.tabs.onRemoved.addListener(onTabRemoved);
}

// Remove tab event listeners
function removeTabListeners() {
  browser.webNavigation.onCommitted.removeListener(onNavigationCommitted);
  browser.webNavigation.onCompleted.removeListener(onNavigationCompleted);
  browser.webNavigation.onDOMContentLoaded.removeListener(onDOMContentLoaded);
  browser.webNavigation.onErrorOccurred.removeListener(onNavigationError);
  browser.tabs.onUpdated.removeListener(onTabUpdated);
  browser.tabs.onRemoved.removeListener(onTabRemoved);
}

// Handle navigation committed event
function onNavigationCommitted(details) {
  if (!recordingActive || details.tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_navigation_committed',
    tabId: details.tabId,
    frameId: details.frameId,
    url: details.url,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
  
  // Re-inject content scripts after navigation
  if (details.frameId === 0) {
    setTimeout(() => {
      injectContentScripts(details.tabId);
    }, 100);
  }
}

// Handle navigation completed event
function onNavigationCompleted(details) {
  if (!recordingActive || details.tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_navigation_completed',
    tabId: details.tabId,
    frameId: details.frameId,
    url: details.url,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
}

// Handle DOM content loaded event
function onDOMContentLoaded(details) {
  if (!recordingActive || details.tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_dom_content_loaded',
    tabId: details.tabId,
    frameId: details.frameId,
    url: details.url,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
}

// Handle navigation error event
function onNavigationError(details) {
  if (!recordingActive || details.tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_navigation_error',
    tabId: details.tabId,
    frameId: details.frameId,
    url: details.url,
    error: details.error,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
}

// Handle tab update event
function onTabUpdated(tabId, changeInfo, tab) {
  if (!recordingActive || tabId !== recordingTabId) {
    return;
  }
  
  if (changeInfo.status === 'loading') {
    sendToRecorder({
      type: 'cstestforge_tab_loading',
      tabId: tabId,
      url: tab.url,
      timestamp: Date.now(),
      sessionId: recordingSessionId
    });
  } else if (changeInfo.status === 'complete') {
    sendToRecorder({
      type: 'cstestforge_tab_complete',
      tabId: tabId,
      url: tab.url,
      title: tab.title,
      timestamp: Date.now(),
      sessionId: recordingSessionId
    });
  }
}

// Handle tab removed event
function onTabRemoved(tabId) {
  if (!recordingActive || tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_tab_closed',
    tabId: tabId,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
  
  // Stop recording if the recording tab is closed
  stopRecording();
}

// Generate a unique session ID
function generateSessionId() {
  return 'cs_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
}

// Send message to recorder
function sendToRecorder(message) {
  if (portConnection) {
    portConnection.postMessage(message);
  } else {
    // Store event for sending when connection is established
    pendingEvents.push(message);
    
    // Limit stored events to prevent memory issues
    if (pendingEvents.length > 1000) {
      pendingEvents.shift();
    }
  }
}

// Initialize extension
function initialize() {
  // Set browser action badge initially to empty
  browser.browserAction.setBadgeText({text: ""});
  
  // Register browser action click handler
  browser.browserAction.onClicked.addListener(tab => {
    if (recordingActive && recordingTabId === tab.id) {
      // Stop recording if already recording on this tab
      stopRecording();
    } else {
      // Start recording on this tab
      startRecording(tab.id);
    }
  });
  
  console.log("CSTestForge Firefox extension initialized");
}

// Call initialize function
initialize();



firefox/content-script.js
-----------------------------------------------

// Firefox Extension Content Script for CSTestForge
// Responsible for capturing user events, DOM changes, and network activity during test recording

(function() {
  // State management
  let recording = false;
  let sessionId = null;
  let config = {
    captureNetwork: true,
    captureDOMChanges: true,
    captureConsole: true,
    recordFrames: true,
    elementDetectionLevel: 'advanced'
  };
  let eventListeners = [];
  let ignoredElements = new WeakSet();
  let lastEvent = null;
  let lastMouseMoveTime = 0;
  let mouseMoveDebouncePeriod = 100; // ms
  let mouseMoveTimeout = null;
  
  // Cache for element descriptions (to avoid recalculations)
  const elementCache = new WeakMap();
  
  // Collection of cleanup functions
  const cleanupFunctions = [];
  
  // Initialize when the content script is loaded
  initialize();
  
  // Handle messages from background script
  browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (!message.command) {
      return;
    }
    
    switch (message.command) {
      case 'start_recording':
        startRecording(message.sessionId, message.config);
        break;
      case 'stop_recording':
        stopRecording();
        break;
      case 'pause_recording':
        pauseRecording();
        break;
      case 'resume_recording':
        resumeRecording();
        break;
      case 'update_config':
        updateConfig(message.config);
        break;
      case 'get_element_info':
        const elementInfo = getElementInfo(message.selector);
        sendResponse(elementInfo);
        return true; // Keep the message channel open for async response
      case 'execute_action':
        const result = executeAction(message.action);
        sendResponse(result);
        return true; // Keep the message channel open for async response
      case 'highlight_element':
        const highlighted = highlightElement(message.selector, message.duration);
        sendResponse({ success: highlighted });
        return true; // Keep the message channel open for async response
    }
  });
  
  // Initialize content script
  function initialize() {
    // Expose cleanup function to window object for background script to call
    window._csTestForgeCleanup = cleanup;
    
    // Send ready message to background script
    browser.runtime.sendMessage({
      type: 'cstestforge_ready',
      timestamp: Date.now(),
      url: window.location.href,
      title: document.title
    }).catch(error => {
      console.error('Failed to send ready message:', error);
    });
    
    // Add method to ignore elements from recording
    window.csTestForgeIgnoreElement = (element) => {
      if (element) {
        ignoredElements.add(element);
      }
    };
  }
  
  // Start recording events
  function startRecording(newSessionId, newConfig) {
    // Reset state first in case we're restarting
    stopRecording();
    
    recording = true;
    sessionId = newSessionId || ('cs_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15));
    
    if (newConfig) {
      config = { ...config, ...newConfig };
    }
    
    // Record page navigation
    recordNavigation();
    
    // Set up event listeners
    setupEventListeners();
    
    // Set up mutation observer for DOM changes
    setupMutationObserver();
    
    // Set up console listener
    setupConsoleListener();
    
    // Set up network listener
    setupNetworkListener();
  }
  
  // Stop recording events
  function stopRecording() {
    recording = false;
    
    // Clean up all event listeners and observers
    cleanup();
  }
  
  // Pause recording events
  function pauseRecording() {
    recording = false;
  }
  
  // Resume recording events
  function resumeRecording() {
    recording = true;
  }
  
  // Update recording configuration
  function updateConfig(newConfig) {
    const oldConfig = { ...config };
    config = { ...config, ...newConfig };
    
    // Handle configuration changes that require reinitializing listeners
    if (recording) {
      if (oldConfig.captureNetwork !== config.captureNetwork ||
          oldConfig.captureDOMChanges !== config.captureDOMChanges ||
          oldConfig.captureConsole !== config.captureConsole) {
        
        // Reinitialize event listeners based on new configuration
        cleanup();
        setupEventListeners();
        
        if (config.captureDOMChanges) {
          setupMutationObserver();
        }
        
        if (config.captureConsole) {
          setupConsoleListener();
        }
        
        if (config.captureNetwork) {
          setupNetworkListener();
        }
      }
    }
  }
  
  // Clean up all event listeners and observers
  function cleanup() {
    // Remove all registered event listeners
    for (const { element, type, listener, options } of eventListeners) {
      element.removeEventListener(type, listener, options);
    }
    eventListeners = [];
    
    // Run all cleanup functions
    for (const cleanup of cleanupFunctions) {
      try {
        cleanup();
      } catch (e) {
        console.error('Error in cleanup function:', e);
      }
    }
    
    // Clear the cleanup functions array
    cleanupFunctions.length = 0;
    
    // Clear any pending timeouts
    if (mouseMoveTimeout) {
      clearTimeout(mouseMoveTimeout);
      mouseMoveTimeout = null;
    }
  }
  
  // Setup all event listeners
  function setupEventListeners() {
    // Mouse events
    addEventListenerWithCleanup(document, 'click', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'contextmenu', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'dblclick', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'mousedown', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'mouseup', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'mousemove', recordMouseMove, { capture: true, passive: true });
    
    // Keyboard events
    addEventListenerWithCleanup(document, 'keydown', recordKeyboardEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'keyup', recordKeyboardEvent, { capture: true, passive: true });
    
    // Form events
    addEventListenerWithCleanup(document, 'change', recordFormEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'input', recordFormEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'submit', recordFormEvent, { capture: true, passive: true });
    
    // Focus events
    addEventListenerWithCleanup(document, 'focus', recordFocusEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'blur', recordFocusEvent, { capture: true, passive: true });
    
    // Drag events
    addEventListenerWithCleanup(document, 'dragstart', recordDragEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'dragend', recordDragEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'drop', recordDragEvent, { capture: true, passive: true });
    
    // Scroll events (debounced)
    let scrollTimeout = null;
    addEventListenerWithCleanup(document, 'scroll', (event) => {
      if (!recording || !event.target) return;
      
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      
      scrollTimeout = setTimeout(() => {
        recordScrollEvent(event);
        scrollTimeout = null;
      }, 200);
    }, { capture: true, passive: true });
    
    // Window events
    addEventListenerWithCleanup(window, 'resize', (event) => {
      if (!recording) return;
      
      recordEvent('window_resize', {
        width: window.innerWidth,
        height: window.innerHeight
      });
    }, { passive: true });
    
    // Page lifecycle events
    addEventListenerWithCleanup(window, 'beforeunload', (event) => {
      if (!recording) return;
      
      recordEvent('page_beforeunload', {
        url: window.location.href
      });
    }, { passive: true });
    
    addEventListenerWithCleanup(window, 'unload', (event) => {
      if (!recording) return;
      
      recordEvent('page_unload', {
        url: window.location.href
      });
    }, { passive: true });
    
    addEventListenerWithCleanup(window, 'pagehide', (event) => {
      if (!recording) return;
      
      recordEvent('page_hide', {
        url: window.location.href,
        persisted: event.persisted
      });
    }, { passive: true });
    
    addEventListenerWithCleanup(window, 'pageshow', (event) => {
      if (!recording) return;
      
      recordEvent('page_show', {
        url: window.location.href,
        persisted: event.persisted
      });
    }, { passive: true });
    
    // History events
    const originalPushState = window.history.pushState;
    window.history.pushState = function() {
      const result = originalPushState.apply(this, arguments);
      
      if (recording) {
        recordEvent('history_push_state', {
          url: window.location.href,
          state: arguments[0] ? JSON.stringify(arguments[0]) : null,
          title: arguments[1],
          path: arguments[2]
        });
      }
      
      return result;
    };
    cleanupFunctions.push(() => {
      window.history.pushState = originalPushState;
    });
    
    const originalReplaceState = window.history.replaceState;
    window.history.replaceState = function() {
      const result = originalReplaceState.apply(this, arguments);
      
      if (recording) {
        recordEvent('history_replace_state', {
          url: window.location.href,
          state: arguments[0] ? JSON.stringify(arguments[0]) : null,
          title: arguments[1],
          path: arguments[2]
        });
      }
      
      return result;
    };
    cleanupFunctions.push(() => {
      window.history.replaceState = originalReplaceState;
    });
    
    addEventListenerWithCleanup(window, 'popstate', (event) => {
      if (!recording) return;
      
      recordEvent('history_pop_state', {
        url: window.location.href,
        state: event.state ? JSON.stringify(event.state) : null
      });
    }, { passive: true });
  }
  
  // Helper to add event listener and track for cleanup
  function addEventListenerWithCleanup(element, type, listener, options) {
    const wrappedListener = function(event) {
      if (recording) {
        listener(event);
      }
    };
    
    element.addEventListener(type, wrappedListener, options);
    
    eventListeners.push({
      element,
      type,
      listener: wrappedListener,
      options
    });
  }
  
  // Set up mutation observer for DOM changes
  function setupMutationObserver() {
    if (!config.captureDOMChanges) {
      return;
    }
    
    const observer = new MutationObserver((mutations) => {
      if (!recording) return;
      
      // Group mutations by type to reduce the number of events
      const addedNodes = new Set();
      const removedNodes = new Set();
      const attributeChanges = new Map(); // Map<Element, Set<attributeName>>
      const textChanges = new Set();
      
      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE && !ignoredElements.has(node)) {
              addedNodes.add(node);
            }
          });
          
          mutation.removedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE && !ignoredElements.has(node)) {
              removedNodes.add(node);
            }
          });
        } else if (mutation.type === 'attributes') {
          if (!ignoredElements.has(mutation.target) && mutation.target.nodeType === Node.ELEMENT_NODE) {
            if (!attributeChanges.has(mutation.target)) {
              attributeChanges.set(mutation.target, new Set());
            }
            attributeChanges.get(mutation.target).add(mutation.attributeName);
          }
        } else if (mutation.type === 'characterData') {
          if (!ignoredElements.has(mutation.target) && 
              mutation.target.nodeType === Node.TEXT_NODE && 
              mutation.target.parentElement && 
              !ignoredElements.has(mutation.target.parentElement)) {
            textChanges.add(mutation.target.parentElement);
          }
        }
      }
      
      // Record node additions
      if (addedNodes.size > 0) {
        const elementsData = Array.from(addedNodes).map(element => {
          return getElementShortDescription(element);
        });
        
        if (elementsData.length > 0) {
          recordEvent('dom_elements_added', {
            elements: elementsData
          });
        }
      }
      
      // Record node removals
      if (removedNodes.size > 0) {
        const elementsData = Array.from(removedNodes).map(element => {
          return getElementShortDescription(element);
        });
        
        if (elementsData.length > 0) {
          recordEvent('dom_elements_removed', {
            elements: elementsData
          });
        }
      }
      
      // Record attribute changes
      if (attributeChanges.size > 0) {
        const changes = [];
        
        attributeChanges.forEach((attributes, element) => {
          const elementDesc = getElementShortDescription(element);
          
          attributes.forEach(attrName => {
            changes.push({
              element: elementDesc,
              attribute: attrName,
              value: element.getAttribute(attrName)
            });
          });
        });
        
        if (changes.length > 0) {
          recordEvent('dom_attributes_changed', {
            changes: changes
          });
        }
      }
      
      // Record text changes
      if (textChanges.size > 0) {
        const changes = [];
        
        textChanges.forEach(element => {
          const elementDesc = getElementShortDescription(element);
          
          changes.push({
            element: elementDesc,
            text: element.textContent.substring(0, 100) + (element.textContent.length > 100 ? '...' : '')
          });
        });
        
        if (changes.length > 0) {
          recordEvent('dom_text_changed', {
            changes: changes
          });
        }
      }
    });
    
    observer.observe(document, {
      childList: true,
      attributes: true,
      characterData: true,
      subtree: true,
      attributeOldValue: true,
      characterDataOldValue: true
    });
    
    cleanupFunctions.push(() => {
      observer.disconnect();
    });
  }
  
  // Set up console listener
  function setupConsoleListener() {
    if (!config.captureConsole) {
      return;
    }
    
    const originals = {
      log: console.log,
      info: console.info,
      warn: console.warn,
      error: console.error,
      debug: console.debug
    };
    
    function wrap(method, level) {
      return function() {
        // Call original method
        const result = originals[method].apply(this, arguments);
        
        // Record the console event
        if (recording) {
          const args = Array.from(arguments).map(arg => {
            if (typeof arg === 'string') {
              return arg;
            } else {
              try {
                return JSON.stringify(arg);
              } catch (e) {
                return String(arg);
              }
            }
          });
          
          recordEvent('console', {
            level,
            args
          });
        }
        
        return result;
      };
    }
    
    console.log = wrap('log', 'log');
    console.info = wrap('info', 'info');
    console.warn = wrap('warn', 'warn');
    console.error = wrap('error', 'error');
    console.debug = wrap('debug', 'debug');
    
    cleanupFunctions.push(() => {
      console.log = originals.log;
      console.info = originals.info;
      console.warn = originals.warn;
      console.error = originals.error;
      console.debug = originals.debug;
    });
  }
  
  // Set up network listener
  function setupNetworkListener() {
    if (!config.captureNetwork) {
      return;
    }
    
    // Intercept fetch requests
    const originalFetch = window.fetch;
    window.fetch = async function() {
      const url = arguments[0] instanceof Request ? arguments[0].url : String(arguments[0]);
      const method = arguments[0] instanceof Request ? arguments[0].method : (arguments[1]?.method || 'GET');
      const startTime = Date.now();
      
      if (recording) {
        recordEvent('network_request_started', {
          url,
          method,
          type: 'fetch'
        });
      }
      
      try {
        const response = await originalFetch.apply(this, arguments);
        
        if (recording) {
          recordEvent('network_request_completed', {
            url,
            method,
            type: 'fetch',
            status: response.status,
            statusText: response.statusText,
            duration: Date.now() - startTime
          });
        }
        
        return response;
      } catch (error) {
        if (recording) {
          recordEvent('network_request_failed', {
            url,
            method,
            type: 'fetch',
            error: error.message,
            duration: Date.now() - startTime
          });
        }
        
        throw error;
      }
    };
    
    cleanupFunctions.push(() => {
      window.fetch = originalFetch;
    });
    
    // Intercept XMLHttpRequest
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    XMLHttpRequest.prototype.open = function() {
      this._csTestForgeURL = arguments[1];
      this._csTestForgeMethod = arguments[0];
      return originalXHROpen.apply(this, arguments);
    };
    
    XMLHttpRequest.prototype.send = function() {
      if (recording) {
        const startTime = Date.now();
        const url = this._csTestForgeURL;
        const method = this._csTestForgeMethod;
        
        recordEvent('network_request_started', {
          url,
          method,
          type: 'xhr'
        });
        
        const onLoadEnd = () => {
          if (recording) {
            if (this.readyState === 4) {
              if (this.status >= 200 && this.status < 400) {
                recordEvent('network_request_completed', {
                  url,
                  method,
                  type: 'xhr',
                  status: this.status,
                  statusText: this.statusText,
                  duration: Date.now() - startTime
                });
              } else {
                recordEvent('network_request_failed', {
                  url,
                  method,
                  type: 'xhr',
                  status: this.status,
                  statusText: this.statusText,
                  error: `HTTP Error ${this.status}`,
                  duration: Date.now() - startTime
                });
              }
            }
          }
          
          this.removeEventListener('loadend', onLoadEnd);
        };
        
        this.addEventListener('loadend', onLoadEnd);
      }
      
      return originalXHRSend.apply(this, arguments);
    };
    
    cleanupFunctions.push(() => {
      XMLHttpRequest.prototype.open = originalXHROpen;
      XMLHttpRequest.prototype.send = originalXHRSend;
    });
    
    // Listen for resource timing entries
    if (window.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes('resource')) {
      const observer = new PerformanceObserver((list) => {
        if (!recording) return;
        
        const entries = list.getEntries();
        
        for (const entry of entries) {
          // Skip CSTestForge's own requests
          if (entry.name.includes('cs-testforge')) {
            continue;
          }
          
          recordEvent('network_resource', {
            url: entry.name,
            initiatorType: entry.initiatorType,
            duration: entry.duration,
            transferSize: entry.transferSize,
            encodedBodySize: entry.encodedBodySize,
            decodedBodySize: entry.decodedBodySize
          });
        }
      });
      
      observer.observe({ entryTypes: ['resource'] });
      
      cleanupFunctions.push(() => {
        observer.disconnect();
      });
    }
  }
  
  // Record mouse events
  function recordMouseEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementInfo(target);
    
    recordEvent('mouse', {
      type: event.type,
      button: event.button,
      buttons: event.buttons,
      clientX: event.clientX,
      clientY: event.clientY,
      screenX: event.screenX,
      screenY: event.screenY,
      altKey: event.altKey,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      target: elementInfo
    });
    
    // For click events, check if we need to record special interactions
    if (event.type === 'click') {
      recordSpecialInteractions(event);
    }
  }
  
  // Record mouse move events (debounced)
  function recordMouseMove(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const now = Date.now();
    
    // Debounce mouse move events
    if (now - lastMouseMoveTime < mouseMoveDebouncePeriod) {
      if (mouseMoveTimeout) {
        clearTimeout(mouseMoveTimeout);
      }
      
      mouseMoveTimeout = setTimeout(() => {
        lastMouseMoveTime = Date.now();
        recordMouseMoveEvent(event);
        mouseMoveTimeout = null;
      }, mouseMoveDebouncePeriod);
      
      return;
    }
    
    lastMouseMoveTime = now;
    recordMouseMoveEvent(event);
  }
  
  // Handle mouse move event recording
  function recordMouseMoveEvent(event) {
    const target = event.target;
    const elementInfo = getElementShortDescription(target);
    
    recordEvent('mouse_move', {
      clientX: event.clientX,
      clientY: event.clientY,
      screenX: event.screenX,
      screenY: event.screenY,
      target: elementInfo
    });
  }
  
  // Record keyboard events
  function recordKeyboardEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    // Don't record keyboard events for password fields
    if (event.target.type === 'password') {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementShortDescription(target);
    
    // Determine if we should record the key value
    let key = event.key;
    let recordValue = true;
    
    // Check if we're in a sensitive field
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
      const type = target.type && target.type.toLowerCase();
      
      if (type === 'password' || 
          type === 'email' || 
          type === 'tel' || 
          target.name?.toLowerCase().includes('card') ||
          target.name?.toLowerCase().includes('credit') ||
          target.name?.toLowerCase().includes('payment') ||
          target.name?.toLowerCase().includes('phone') ||
          target.name?.toLowerCase().includes('address') ||
          target.name?.toLowerCase().includes('ssn') ||
          target.name?.toLowerCase().includes('social') ||
          target.name?.toLowerCase().includes('security') ||
          target.id?.toLowerCase().includes('card') ||
          target.id?.toLowerCase().includes('credit') ||
          target.id?.toLowerCase().includes('payment') ||
          target.id?.toLowerCase().includes('phone') ||
          target.id?.toLowerCase().includes('address') ||
          target.id?.toLowerCase().includes('ssn') ||
          target.id?.toLowerCase().includes('social') ||
          target.id?.toLowerCase().includes('security')) {
        recordValue = false;
        key = '*';
      }
    }
    
    recordEvent('keyboard', {
      type: event.type,
      key: recordValue ? key : '*',
      code: event.code,
      location: event.location,
      repeat: event.repeat,
      altKey: event.altKey,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      target: elementInfo
    });
  }
  
  // Record form events
  function recordFormEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementInfo(target);
    
    // Determine if we should record the value
    let value = target.value;
    let recordValue = true;
    
    // Check if we're in a sensitive field
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
      const type = target.type && target.type.toLowerCase();
      
      if (type === 'password' || 
          type === 'email' || 
          type === 'tel' || 
          target.name?.toLowerCase().includes('card') ||
          target.name?.toLowerCase().includes('credit') ||
          target.name?.toLowerCase().includes('payment') ||
          target.name?.toLowerCase().includes('phone') ||
          target.name?.toLowerCase().includes('address') ||
          target.name?.toLowerCase().includes('ssn') ||
          target.name?.toLowerCase().includes('social') ||
          target.name?.toLowerCase().includes('security') ||
          target.id?.toLowerCase().includes('card') ||
          target.id?.toLowerCase().includes('credit') ||
          target.id?.toLowerCase().includes('payment') ||
          target.id?.toLowerCase().includes('phone') ||
          target.id?.toLowerCase().includes('address') ||
          target.id?.toLowerCase().includes('ssn') ||
          target.id?.toLowerCase().includes('social') ||
          target.id?.toLowerCase().includes('security')) {
        recordValue = false;
        value = '************';
      }
    }
    
    let eventData = {
      type: event.type,
      target: elementInfo
    };
    
    // Add type-specific data
    if (event.type === 'change' || event.type === 'input') {
      if (target.type === 'checkbox' || target.type === 'radio') {
        eventData.checked = target.checked;
      } else if (target.tagName === 'SELECT') {
        const selectedOptions = [];
        for (let i = 0; i < target.options.length; i++) {
          if (target.options[i].selected) {
            selectedOptions.push({
              index: i,
              value: target.options[i].value,
              text: target.options[i].text
            });
          }
        }
        eventData.selectedOptions = selectedOptions;
      } else {
        eventData.value = recordValue ? value : '************';
      }
    } else if (event.type === 'submit') {
      if (target.tagName === 'FORM') {
        const formData = {};
        const elements = target.elements;
        
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          
          if (element.name) {
            if (element.type === 'checkbox' || element.type === 'radio') {
              if (element.checked) {
                formData[element.name] = element.value;
              }
            } else if (element.tagName === 'SELECT') {
              if (element.multiple) {
                formData[element.name] = [];
                for (let j = 0; j < element.options.length; j++) {
                  if (element.options[j].selected) {
                    formData[element.name].push(element.options[j].value);
                  }
                }
              } else {
                formData[element.name] = element.value;
              }
            } else {
              const shouldMaskValue = element.type === 'password' || 
                element.type === 'email' || 
                element.type === 'tel' || 
                element.name?.toLowerCase().includes('card') ||
                element.name?.toLowerCase().includes('credit') ||
                element.name?.toLowerCase().includes('payment') ||
                element.name?.toLowerCase().includes('phone') ||
                element.name?.toLowerCase().includes('address') ||
                element.name?.toLowerCase().includes('ssn') ||
                element.name?.toLowerCase().includes('social') ||
                element.name?.toLowerCase().includes('security') ||
                element.id?.toLowerCase().includes('card') ||
                element.id?.toLowerCase().includes('credit') ||
                element.id?.toLowerCase().includes('payment') ||
                element.id?.toLowerCase().includes('phone') ||
                element.id?.toLowerCase().includes('address') ||
                element.id?.toLowerCase().includes('ssn') ||
                element.id?.toLowerCase().includes('social') ||
                element.id?.toLowerCase().includes('security');
              
              formData[element.name] = shouldMaskValue ? '************' : element.value;
            }
          }
        }
        
        eventData.formData = formData;
      }
    }
    
    recordEvent('form', eventData);
  }
  
  // Record focus events
  function recordFocusEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementShortDescription(target);
    
    recordEvent('focus', {
      type: event.type,
      target: elementInfo
    });
  }
  
  // Record drag events
  function recordDragEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementShortDescription(target);
    
    recordEvent('drag', {
      type: event.type,
      clientX: event.clientX,
      clientY: event.clientY,
      screenX: event.screenX,
      screenY: event.screenY,
      target: elementInfo
    });
  }
  
  // Record scroll events
  function recordScrollEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target === document ? document.documentElement : event.target;
    const elementInfo = getElementShortDescription(target);
    
    // Get scroll position
    const scrollTop = target === document.documentElement ? window.scrollY : target.scrollTop;
    const scrollLeft = target === document.documentElement ? window.scrollX : target.scrollLeft;
    
    recordEvent('scroll', {
      scrollTop,
      scrollLeft,
      target: elementInfo
    });
  }
  
  // Record page navigation
  function recordNavigation() {
    recordEvent('navigation', {
      url: window.location.href,
      title: document.title,
      referrer: document.referrer,
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      screenWidth: window.screen.width,
      screenHeight: window.screen.height,
      windowWidth: window.innerWidth,
      windowHeight: window.innerHeight
    });
  }
  
  // Special interactions recording (e.g., clicks on specific types of elements)
  function recordSpecialInteractions(event) {
    const target = event.target;
    
    // Handle links
    if (target.tagName === 'A' || target.closest('a')) {
      const link = target.tagName === 'A' ? target : target.closest('a');
      const href = link.href || '';
      
      recordEvent('link_click', {
        href,
        text: link.textContent.trim().substring(0, 100) + (link.textContent.length > 100 ? '...' : ''),
        target: link.target,
        download: link.download
      });
    }
    
    // Handle buttons
    if (target.tagName === 'BUTTON' || 
        target.type === 'button' || 
        target.type === 'submit' || 
        target.type === 'reset' ||
        target.role === 'button' ||
        target.closest('button')) {
      
      const button = target.tagName === 'BUTTON' || target.type === 'button' || target.type === 'submit' || target.type === 'reset' ? 
                    target : 
                    (target.role === 'button' ? target : target.closest('button'));
      
      recordEvent('button_click', {
        text: button.textContent.trim().substring(0, 100) + (button.textContent.length > 100 ? '...' : ''),
        type: button.type || 'button',
        name: button.name,
        value: button.value
      });
    }
    
    // Handle form controls
    if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA') {
      const isCheckbox = target.type === 'checkbox';
      const isRadio = target.type === 'radio';
      
      if (isCheckbox) {
        recordEvent('checkbox_click', {
          checked: target.checked,
          name: target.name,
          value: target.value
        });
      } else if (isRadio) {
        recordEvent('radio_click', {
          checked: target.checked,
          name: target.name,
          value: target.value
        });
      }
    }
  }
  
  // Record a generic event
  function recordEvent(category, data) {
    const event = {
      type: 'cstestforge_dom_event',
      category,
      data,
      timestamp: Date.now(),
      url: window.location.href,
      sessionId: sessionId
    };
    
    // Send event to background script
    browser.runtime.sendMessage(event).catch(error => {
      console.error('Failed to send event to background script:', error);
    });
  }
  
  // Get information about an element
  function getElementInfo(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return null;
    }
    
    // Check if we already have cached info for this element
    if (elementCache.has(element)) {
      return elementCache.get(element);
    }
    
    // Generate XPath
    function getXPath(element) {
      if (!element) return '';
      
      if (element.id) {
        return `//*[@id="${element.id}"]`;
      }
      
      if (element === document.body) {
        return '/html/body';
      }
      
      let ix = 0;
      const siblings = element.parentNode.childNodes;
      
      for (let i = 0; i < siblings.length; i++) {
        const sibling = siblings[i];
        
        if (sibling === element) {
          const tagName = element.tagName.toLowerCase();
          const pathIndex = ix + 1;
          const parentPath = getXPath(element.parentNode);
          
          return `${parentPath}/${tagName}[${pathIndex}]`;
        }
        
        if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
          ix++;
        }
      }
    }
    
    // Generate CSS Selector
    function generateCssSelector(element) {
      if (!element) return '';
      if (element.id) return `#${element.id}`;
      
      let selector = element.tagName.toLowerCase();
      
      if (element.className) {
        const classes = element.className.split(' ').filter(c => c && !c.startsWith('ng-') && !c.includes(':'));
        if (classes.length > 0) {
          selector += '.' + classes.join('.');
        }
      }
      
      // Add attribute selectors for specific attributes
      const relevantAttrs = ['name', 'type', 'role', 'data-test', 'data-testid', 'data-test-id', 'data-cy'];
      for (const attr of relevantAttrs) {
        if (element.hasAttribute(attr)) {
          selector += `[${attr}="${element.getAttribute(attr)}"]`;
          break; // Just use one unique attribute
        }
      }
      
      return selector;
    }
    
    // Smart CSS Selector
    function generateSmartSelector(element) {
      if (!element) return '';
      
      // Start with the element's tag
      let selector = element.tagName.toLowerCase();
      
      // Add ID if it exists and isn't auto-generated
      if (element.id && !/^[0-9]/.test(element.id) && !element.id.includes(':')) {
        return `#${element.id}`;
      }
      
      // Add specific attribute selectors
      const preferredAttrs = [
        'data-testid', 'data-test', 'data-test-id', 'data-cy', 'data-automation',
        'name', 'aria-label', 'title', 'for', 'alt'
      ];
      
      for (const attr of preferredAttrs) {
        if (element.hasAttribute(attr)) {
          selector += `[${attr}="${element.getAttribute(attr)}"]`;
          return selector; // These are usually unique enough
        }
      }
      
      // Add classes that don't look auto-generated
      if (element.className) {
        const classes = element.className.split(' ')
          .filter(c => c && !c.includes(':') && !c.startsWith('ng-') && !/^[a-z][0-9]$/.test(c) && c.length > 2);
        
        if (classes.length === 1) {
          selector += `.${classes[0]}`;
        } else if (classes.length > 1) {
          // Just use the first 2 classes to avoid over-specificity
          selector += `.${classes[0]}.${classes[1]}`;
        }
      }
      
      // Make selector more specific by adding parent context
      if (element.parentElement && element.parentElement !== document.body) {
        const parentTag = element.parentElement.tagName.toLowerCase();
        
        // If parent has ID, use that
        if (element.parentElement.id && !/^[0-9]/.test(element.parentElement.id) && !element.parentElement.id.includes(':')) {
          return `#${element.parentElement.id} > ${selector}`;
        }
        
        // Otherwise just use parent tag
        return `${parentTag} > ${selector}`;
      }
      
      return selector;
    }
    
    // Calculate element visibility
    const rect = element.getBoundingClientRect();
    const isInViewport = rect.top < window.innerHeight && rect.left < window.innerWidth && rect.bottom > 0 && rect.right > 0;
    
    // Compute computed styles
    const computedStyle = window.getComputedStyle(element);
    const isVisible = !(computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0');
    
    // Get element attributes
    const attributes = {};
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      attributes[attr.name] = attr.value;
    }
    
    const elementInfo = {
      tagName: element.tagName,
      id: element.id,
      className: element.className,
      attributes: attributes,
      text: element.textContent.trim().substring(0, 100) + (element.textContent.length > 100 ? '...' : ''),
      value: element.value,
      type: element.type,
      checked: element.checked,
      dimensions: {
        width: rect.width,
        height: rect.height,
        top: rect.top,
        left: rect.left,
        bottom: rect.bottom,
        right: rect.right
      },
      isInViewport: isInViewport,
      isVisible: isVisible,
      xpath: getXPath(element),
      cssSelector: generateCssSelector(element),
      smartSelector: generateSmartSelector(element)
    };
    
    // Cache the element info for future use
    elementCache.set(element, elementInfo);
    
    return elementInfo;
  }
  
  // Get a short description of an element (for events where full info isn't needed)
  function getElementShortDescription(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return null;
    }
    
    return {
      tagName: element.tagName,
      id: element.id,
      className: element.className,
      xpath: `${element.tagName.toLowerCase()}${element.id ? `#${element.id}` : ''}`
    };
  }
  
  // Execute an action on an element
  function executeAction(action) {
    try {
      const element = document.querySelector(action.selector);
      if (!element) return { success: false, error: 'Element not found' };
      
      switch (action.type) {
        case 'click':
          element.click();
          break;
        case 'rightClick':
          const rightClickEvent = new MouseEvent('contextmenu', {
            bubbles: true,
            cancelable: true,
            view: window,
            button: 2,
            buttons: 2
          });
          element.dispatchEvent(rightClickEvent);
          break;
        case 'doubleClick':
          const dblClickEvent = new MouseEvent('dblclick', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          element.dispatchEvent(dblClickEvent);
          break;
        case 'type':
          element.value = action.text || '';
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
          break;
        case 'clear':
          element.value = '';
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
          break;
        case 'select':
          const options = element.querySelectorAll('option');
          for (let i = 0; i < options.length; i++) {
            const option = options[i];
            if (option.value === action.value || option.text === action.text) {
              option.selected = true;
              element.dispatchEvent(new Event('change', { bubbles: true }));
              break;
            }
          }
          break;
        case 'check':
          if (!element.checked) {
            element.click();
          }
          break;
        case 'uncheck':
          if (element.checked) {
            element.click();
          }
          break;
        case 'focus':
          element.focus();
          break;
        case 'blur':
          element.blur();
          break;
        case 'hover':
          const hoverEvent = new MouseEvent('mouseover', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          element.dispatchEvent(hoverEvent);
          break;
        default:
          return { success: false, error: 'Unsupported action type' };
      }
      
      return { success: true };
    } catch (e) {
      console.error('CSTestForge action error:', e);
      return { success: false, error: e.message };
    }
  }
  
  // Highlight an element
  function highlightElement(selector, duration) {
    try {
      const element = document.querySelector(selector);
      if (!element) return false;
      
      const originalOutline = element.style.outline;
      const originalOutlineOffset = element.style.outlineOffset;
      const originalTransition = element.style.transition;
      const originalPosition = element.style.position;
      const originalZIndex = element.style.zIndex;
      
      element.style.outline = '2px solid #C54B8C';
      element.style.outlineOffset = '2px';
      element.style.transition = 'outline 0.2s ease-in-out';
      element.style.position = originalPosition === 'static' ? 'relative' : originalPosition;
      element.style.zIndex = '99999';
      
      setTimeout(() => {
        element.style.outline = originalOutline;
        element.style.outlineOffset = originalOutlineOffset;
        element.style.transition = originalTransition;
        element.style.position = originalPosition;
        element.style.zIndex = originalZIndex;
      }, duration || 1000);
      
      return true;
    } catch (e) {
      console.error('CSTestForge highlight error:', e);
      return false;
    }
  }
  
  // Check if an event should be ignored
  function shouldIgnoreEvent(event) {
    // Skip if target is an ignored element
    if (event.target && ignoredElements.has(event.target)) {
      return true;
    }
    
    // Skip events from CSTestForge itself
    if (event.target && (
      event.target.id?.includes('cstestforge') || 
      event.target.className?.includes('cstestforge') ||
      event.target.tagName === 'CS-TESTFORGE-HIGHLIGHT')) {
      return true;
    }
    
    // Check for parent elements that should be ignored
    let parent = event.target?.parentElement;
    while (parent) {
      if (ignoredElements.has(parent) || 
          parent.id?.includes('cstestforge') || 
          parent.className?.includes('cstestforge') ||
          parent.tagName === 'CS-TESTFORGE-HIGHLIGHT') {
        return true;
      }
      parent = parent.parentElement;
    }
    
    return false;
  }
})();


recorder/edge/edge-injector.js
---------------------------------------

/**
 * CSTestForge Edge Browser Injection Script
 * 
 * This script is responsible for injecting recording capabilities into Microsoft Edge.
 * It provides adaptations specific to Edge's implementation of the WebExtension API.
 */

(function() {
  // Edge version detection for compatibility
  const userAgent = navigator.userAgent;
  const edgeRegex = /Edg\/([0-9]+)/;
  const match = userAgent.match(edgeRegex);
  const edgeVersion = match ? parseInt(match[1], 10) : 0;
  
  // Configuration for browser-specific quirks
  const config = {
    // Edge-specific feature detection
    features: {
      supportsPromiseAPIs: edgeVersion >= 79, // Chromium-based Edge
      supportsShadowDOM: edgeVersion >= 79,
      requiresCustomScrollHandling: edgeVersion < 79, // Legacy EdgeHTML
      requiresCustomEventPatching: edgeVersion < 79
    },
    
    // Extension support
    extension: {
      isInstalled: typeof browser !== 'undefined' || typeof chrome !== 'undefined',
      api: typeof browser !== 'undefined' ? browser : chrome
    }
  };
  
  /**
   * Injects a script into the page to capture events
   * @param {Object} options - Injection options
   * @param {Function} callback - Called when injection is complete
   */
  function injectScript(options, callback) {
    const scriptElement = document.createElement('script');
    
    if (options.url) {
      scriptElement.src = options.url;
      
      if (callback) {
        scriptElement.onload = () => callback(null, true);
        scriptElement.onerror = (error) => callback(error, false);
      }
    } else if (options.code) {
      scriptElement.textContent = options.code;
      
      // For direct code injection, we can assume it executes synchronously
      if (callback) {
        setTimeout(() => callback(null, true), 0);
      }
    }
    
    // Make sure script is removed after execution
    scriptElement.setAttribute('data-cstestforge', 'true');
    
    // Append to document
    (document.head || document.documentElement).appendChild(scriptElement);
    
    // Clean up if needed
    if (options.removeAfterExecution && !options.url) {
      scriptElement.parentNode.removeChild(scriptElement);
    }
  }
  
  /**
   * Creates a unique container ID for injected elements
   * @returns {string} Unique ID
   */
  function createContainerId() {
    return 'cs-testforge-container-' + Math.random().toString(36).substring(2, 15);
  }
  
  /**
   * Creates and injects an isolated container for UI elements
   * @param {Function} callback - Called with the container ID
   */
  function createIsolatedContainer(callback) {
    const containerId = createContainerId();
    
    // Create a detached div
    const container = document.createElement('div');
    container.id = containerId;
    container.style.position = 'fixed';
    container.style.top = '0';
    container.style.left = '0';
    container.style.width = '0';
    container.style.height = '0';
    container.style.overflow = 'hidden';
    container.style.zIndex = '2147483647'; // Max zIndex
    container.setAttribute('data-cstestforge', 'true');
    
    // If Shadow DOM is supported, use it for better isolation
    if (config.features.supportsShadowDOM) {
      const shadowRoot = container.attachShadow({ mode: 'closed' });
      
      // Create a style element for shadow DOM
      const style = document.createElement('style');
      style.textContent = `
        :host {
          all: initial;
          contain: content;
        }
        * {
          font-family: sans-serif;
          box-sizing: border-box;
        }
      `;
      
      shadowRoot.appendChild(style);
      
      // Create inner container that will hold the actual content
      const innerContainer = document.createElement('div');
      innerContainer.id = containerId + '-inner';
      shadowRoot.appendChild(innerContainer);
      
      document.body.appendChild(container);
      callback(containerId, innerContainer, shadowRoot);
    } else {
      // Fallback if Shadow DOM not supported
      const iframe = document.createElement('iframe');
      iframe.style.border = 'none';
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.background = 'transparent';
      
      container.appendChild(iframe);
      document.body.appendChild(container);
      
      // Wait for iframe to load
      iframe.onload = () => {
        const innerDoc = iframe.contentDocument || iframe.contentWindow.document;
        
        // Create styles in iframe
        const style = innerDoc.createElement('style');
        style.textContent = `
          body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            overflow: hidden;
          }
          * {
            box-sizing: border-box;
          }
        `;
        
        innerDoc.head.appendChild(style);
        
        // Create inner container
        const innerContainer = innerDoc.createElement('div');
        innerContainer.id = containerId + '-inner';
        innerDoc.body.appendChild(innerContainer);
        
        callback(containerId, innerContainer, null);
      };
      
      // Fallback in case iframe doesn't trigger onload
      setTimeout(() => {
        if (!iframe.contentDocument && !iframe.contentWindow) {
          callback(containerId, container, null);
        }
      }, 1000);
    }
  }
  
  /**
   * Sets up a communication channel between the injected script and the extension
   * @param {Object} options - Options for the channel
   * @returns {Object} Communication methods
   */
  function setupCommunication(options) {
    const channelId = options.channelId || 'cs-testforge-channel-' + Math.random().toString(36).substring(2, 15);
    
    const communicationMethods = {
      // Send message to extension
      sendToExtension: function(message) {
        // Check if extension is installed
        if (!config.extension.isInstalled) {
          return false;
        }
        
        message.channelId = channelId;
        
        try {
          if (config.features.supportsPromiseAPIs) {
            config.extension.api.runtime.sendMessage(message).catch(() => {
              // Extension might not be receiving messages, fallback to window events
              window.postMessage({
                type: 'cs-testforge-to-extension',
                channelId: channelId,
                message: message
              }, '*');
            });
          } else {
            config.extension.api.runtime.sendMessage(message, (response) => {
              if (config.extension.api.runtime.lastError) {
                // Extension might not be receiving messages, fallback to window events
                window.postMessage({
                  type: 'cs-testforge-to-extension',
                  channelId: channelId,
                  message: message
                }, '*');
              }
            });
          }
          return true;
        } catch (e) {
          // If direct extension communication fails, fallback to window events
          window.postMessage({
            type: 'cs-testforge-to-extension',
            channelId: channelId,
            message: message
          }, '*');
          return false;
        }
      },
      
      // Send message to page script
      sendToPage: function(message) {
        window.postMessage({
          type: 'cs-testforge-to-page',
          channelId: channelId,
          message: message
        }, '*');
      },
      
      // Listen for messages from extension
      listenForExtension: function(callback) {
        const listener = (event) => {
          if (event.data && 
              event.data.type === 'cs-testforge-to-content' && 
              event.data.channelId === channelId) {
            callback(event.data.message);
          }
        };
        
        window.addEventListener('message', listener);
        
        return {
          remove: () => window.removeEventListener('message', listener)
        };
      },
      
      // Listen for messages from page script
      listenForPage: function(callback) {
        const listener = (event) => {
          if (event.data && 
              event.data.type === 'cs-testforge-to-content' && 
              event.data.channelId === channelId) {
            callback(event.data.message);
          }
        };
        
        window.addEventListener('message', listener);
        
        return {
          remove: () => window.removeEventListener('message', listener)
        };
      }
    };
    
    return communicationMethods;
  }
  
  /**
   * Applies Edge-specific patches to event handling
   */
  function applyEdgeSpecificPatches() {
    if (config.features.requiresCustomEventPatching) {
      // Patch MouseEvent for legacy EdgeHTML
      const originalMouseEvent = window.MouseEvent;
      
      try {
        window.MouseEvent = function(type, init) {
          init = init || {};
          const event = document.createEvent('MouseEvent');
          
          event.initMouseEvent(
            type,
            init.bubbles !== undefined ? init.bubbles : true,
            init.cancelable !== undefined ? init.cancelable : true,
            init.view || window,
            init.detail || 0,
            init.screenX || 0,
            init.screenY || 0,
            init.clientX || 0,
            init.clientY || 0,
            init.ctrlKey || false,
            init.altKey || false,
            init.shiftKey || false,
            init.metaKey || false,
            init.button || 0,
            init.relatedTarget || null
          );
          
          return event;
        };
      } catch (e) {
        console.error('Failed to patch MouseEvent', e);
      }
      
      // Patch CustomEvent for legacy EdgeHTML
      const originalCustomEvent = window.CustomEvent;
      
      try {
        window.CustomEvent = function(type, init) {
          init = init || { bubbles: false, cancelable: false, detail: null };
          const event = document.createEvent('CustomEvent');
          event.initCustomEvent(
            type,
            init.bubbles !== undefined ? init.bubbles : false,
            init.cancelable !== undefined ? init.cancelable : false,
            init.detail || null
          );
          return event;
        };
      } catch (e) {
        console.error('Failed to patch CustomEvent', e);
      }
    }
    
    // Add scroll event handling patches if needed
    if (config.features.requiresCustomScrollHandling) {
      // For legacy Edge, we need a more reliable way to track scrolling
      const originalAddEventListener = EventTarget.prototype.addEventListener;
      
      EventTarget.prototype.addEventListener = function(type, listener, options) {
        if (type === 'scroll') {
          // Use a more reliable approach for scroll events in legacy Edge
          const element = this;
          let lastScrollTop = element.scrollTop;
          let lastScrollLeft = element.scrollLeft;
          
          const scrollDetectionInterval = setInterval(() => {
            const currentScrollTop = element.scrollTop;
            const currentScrollLeft = element.scrollLeft;
            
            if (currentScrollTop !== lastScrollTop || currentScrollLeft !== lastScrollLeft) {
              const event = new CustomEvent('scroll', {
                bubbles: true,
                cancelable: false,
                detail: {
                  scrollTop: currentScrollTop,
                  scrollLeft: currentScrollLeft,
                  deltaY: currentScrollTop - lastScrollTop,
                  deltaX: currentScrollLeft - lastScrollLeft
                }
              });
              
              lastScrollTop = currentScrollTop;
              lastScrollLeft = currentScrollLeft;
              
              listener.call(element, event);
            }
          }, 100); // 10 times per second should be sufficient
          
          // Store the interval ID for cleanup
          if (!element._csTestForgeScrollIntervals) {
            element._csTestForgeScrollIntervals = [];
          }
          
          element._csTestForgeScrollIntervals.push({
            listener,
            interval: scrollDetectionInterval
          });
          
          // We still call the original to maintain compatibility
          return originalAddEventListener.call(this, type, listener, options);
        }
        
        return originalAddEventListener.call(this, type, listener, options);
      };
      
      const originalRemoveEventListener = EventTarget.prototype.removeEventListener;
      
      EventTarget.prototype.removeEventListener = function(type, listener, options) {
        if (type === 'scroll' && this._csTestForgeScrollIntervals) {
          // Find and clear any intervals for this listener
          const intervalIndex = this._csTestForgeScrollIntervals.findIndex(item => item.listener === listener);
          
          if (intervalIndex !== -1) {
            clearInterval(this._csTestForgeScrollIntervals[intervalIndex].interval);
            this._csTestForgeScrollIntervals.splice(intervalIndex, 1);
          }
        }
        
        return originalRemoveEventListener.call(this, type, listener, options);
      };
    }
  }
  
  /**
   * Main entry point - injects the CSTestForge recorder into the page
   * @param {Object} options - Injection options
   * @param {Function} callback - Called when injection is complete
   */
  function inject(options, callback) {
    // Apply Edge-specific patches
    if (config.features.requiresCustomEventPatching || config.features.requiresCustomScrollHandling) {
      applyEdgeSpecificPatches();
    }
    
    // Create event capture code
    const captureCode = `
      (function() {
        // Initialize CSTestForge capture
        if (window._csTestForgeInitialized) {
          return;
        }
        
        window._csTestForgeInitialized = true;
        
        // Setup messaging
        const channelId = '${options.channelId || 'cs-testforge-channel-' + Math.random().toString(36).substring(2, 15)}';
        
        // Send message to content script
        function sendToContentScript(message) {
          window.postMessage({
            type: 'cs-testforge-to-content',
            channelId: channelId,
            message: message
          }, '*');
        }
        
        // Listen for messages from content script
        window.addEventListener('message', function(event) {
          if (event.data && 
              event.data.type === 'cs-testforge-to-page' && 
              event.data.channelId === channelId) {
            
            // Handle incoming commands
            const message = event.data.message;
            
            if (message.command === 'start_recording') {
              startRecording(message.config);
            } else if (message.command === 'stop_recording') {
              stopRecording();
            } else if (message.command === 'get_element_info') {
              getElementInfo(message.selector, message.requestId);
            }
          }
        });
        
        // Capture DOM events
        let recording = false;
        let eventListeners = [];
        let config = {
          captureClicks: true,
          captureInputs: true,
          captureKeyboard: true
        };
        
        function startRecording(newConfig) {
          if (recording) {
            stopRecording();
          }
          
          recording = true;
          
          if (newConfig) {
            config = Object.assign(config, newConfig);
          }
          
          setupEventCapture();
          
          sendToContentScript({
            type: 'recording_started',
            timestamp: Date.now()
          });
        }
        
        function stopRecording() {
          if (!recording) {
            return;
          }
          
          recording = false;
          
          // Remove all event listeners
          for (let i = 0; i < eventListeners.length; i++) {
            const listener = eventListeners[i];
            listener.element.removeEventListener(listener.type, listener.handler, listener.options);
          }
          
          eventListeners = [];
          
          sendToContentScript({
            type: 'recording_stopped',
            timestamp: Date.now()
          });
        }
        
        function setupEventCapture() {
          // Capture clicks
          if (config.captureClicks) {
            addGlobalEventListener(document, 'click', handleClick);
            addGlobalEventListener(document, 'contextmenu', handleContextMenu);
            addGlobalEventListener(document, 'dblclick', handleDblClick);
          }
          
          // Capture form interactions
          if (config.captureInputs) {
            addGlobalEventListener(document, 'change', handleChange);
            addGlobalEventListener(document, 'input', handleInput);
            addGlobalEventListener(document, 'focus', handleFocus);
            addGlobalEventListener(document, 'blur', handleBlur);
            addGlobalEventListener(document, 'submit', handleSubmit);
          }
          
          // Capture keyboard
          if (config.captureKeyboard) {
            addGlobalEventListener(document, 'keydown', handleKeyDown);
            addGlobalEventListener(document, 'keyup', handleKeyUp);
          }
        }
        
        function addGlobalEventListener(element, type, handler, options) {
          const wrappedHandler = function(event) {
            if (recording) {
              handler(event);
            }
          };
          
          element.addEventListener(type, wrappedHandler, options);
          
          eventListeners.push({
            element: element,
            type: type,
            handler: wrappedHandler,
            options: options
          });
        }
        
        // Element path generation
        function getElementInfo(selector, requestId) {
          try {
            const element = document.querySelector(selector);
            
            if (!element) {
              sendToContentScript({
                type: 'element_info_response',
                requestId: requestId,
                success: false,
                error: 'Element not found'
              });
              return;
            }
            
            const rect = element.getBoundingClientRect();
            
            // Get all attributes
            const attributes = {};
            for (let i = 0; i < element.attributes.length; i++) {
              attributes[element.attributes[i].name] = element.attributes[i].value;
            }
            
            // Generate xpath
            function getXPath(element) {
              if (element.id) {
                return '//*[@id="' + element.id + '"]';
              }
              
              if (element === document.body) {
                return '/html/body';
              }
              
              if (!element.parentNode) {
                return '';
              }
              
              let ix = 0;
              const siblings = element.parentNode.childNodes;
              
              for (let i = 0; i < siblings.length; i++) {
                const sibling = siblings[i];
                
                if (sibling === element) {
                  return getXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (ix + 1) + ']';
                }
                
                if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                  ix++;
                }
              }
            }
            
            // Generate CSS selector
            function getCssSelector(element) {
              if (element.id) {
                return '#' + element.id;
              }
              
              if (element === document.body) {
                return 'body';
              }
              
              if (element === document.documentElement) {
                return 'html';
              }
              
              let selector = element.tagName.toLowerCase();
              
              if (element.className) {
                const classes = element.className.split(/\\s+/);
                
                for (let i = 0; i < classes.length; i++) {
                  if (classes[i]) {
                    selector += '.' + classes[i];
                  }
                }
              }
              
              // If parent has ID, use that for more specific selector
              if (element.parentNode && element.parentNode.id) {
                return '#' + element.parentNode.id + ' > ' + selector;
              }
              
              return selector;
            }
            
            const info = {
              tagName: element.tagName,
              id: element.id,
              className: element.className,
              attributes: attributes,
              text: element.textContent.trim().substring(0, 100),
              xpath: getXPath(element),
              cssSelector: getCssSelector(element),
              rect: {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height
              }
            };
            
            sendToContentScript({
              type: 'element_info_response',
              requestId: requestId,
              success: true,
              info: info
            });
          } catch (error) {
            sendToContentScript({
              type: 'element_info_response',
              requestId: requestId,
              success: false,
              error: error.message
            });
          }
        }
        
        // Event handlers
        function handleClick(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'click',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: event.clientX,
              clientY: event.clientY
            }
          });
        }
        
        function handleContextMenu(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'contextmenu',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: event.clientX,
              clientY: event.clientY
            }
          });
        }
        
        function handleDblClick(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'dblclick',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: event.clientX,
              clientY: event.clientY
            }
          });
        }
        
        function handleChange(event) {
          const target = event.target;
          
          // Special handling for different input types
          let value = target.value;
          
          if (target.type === 'checkbox' || target.type === 'radio') {
            value = target.checked;
          } else if (target.type === 'password') {
            // Mask password value
            value = '********';
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'change',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            value: value
          });
        }
        
        function handleInput(event) {
          const target = event.target;
          
          // Skip for password fields
          if (target.type === 'password') {
            return;
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'input',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            value: target.value
          });
        }
        
        function handleFocus(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'focus',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            }
          });
        }
        
        function handleBlur(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'blur',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            }
          });
        }
        
        function handleSubmit(event) {
          const target = event.target;
          
          // Collect form data
          const formData = {};
          
          if (target.tagName === 'FORM') {
            const elements = target.elements;
            
            for (let i = 0; i < elements.length; i++) {
              const element = elements[i];
              
              if (element.name) {
                if (element.type === 'checkbox' || element.type === 'radio') {
                  if (element.checked) {
                    formData[element.name] = element.value;
                  }
                } else if (element.type === 'password') {
                  // Mask password
                  formData[element.name] = '********';
                } else {
                  formData[element.name] = element.value;
                }
              }
            }
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'submit',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              action: target.action,
              method: target.method
            },
            formData: formData
          });
        }
        
        function handleKeyDown(event) {
          const target = event.target;
          
          // Skip if target is a password field
          if (target.type === 'password') {
            return;
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'keydown',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            key: event.key,
            code: event.code,
            keyCode: event.keyCode,
            altKey: event.altKey,
            ctrlKey: event.ctrlKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey
          });
        }
        
        function handleKeyUp(event) {
          const target = event.target;
          
          // Skip if target is a password field
          if (target.type === 'password') {
            return;
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'keyup',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            key: event.key,
            code: event.code,
            keyCode: event.keyCode,
            altKey: event.altKey,
            ctrlKey: event.ctrlKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey
          });
        }
        
        // Notify ready
        sendToContentScript({
          type: 'page_ready',
          url: window.location.href,
          title: document.title,
          timestamp: Date.now()
        });
      })();
    `;
    
    // Inject the capture code
    injectScript({ code: captureCode, removeAfterExecution: true }, (error, success) => {
      if (error) {
        if (callback) {
          callback(error, null);
        }
        return;
      }
      
      // Create communication channel
      const communication = setupCommunication({ channelId: options.channelId });
      
      // Create UI container if needed
      if (options.createUI) {
        createIsolatedContainer((containerId, container, shadowRoot) => {
          const result = {
            communication: communication,
            container: {
              id: containerId,
              element: container,
              shadowRoot: shadowRoot
            }
          };
          
          if (callback) {
            callback(null, result);
          }
        });
      } else {
        const result = {
          communication: communication
        };
        
        if (callback) {
          callback(null, result);
        }
      }
    });
  }
  
  // Export the API
  window.CSTestForgeEdgeInjector = {
    inject: inject,
    injectScript: injectScript,
    createIsolatedContainer: createIsolatedContainer,
    setupCommunication: setupCommunication,
    getBrowserInfo: function() {
      return {
        version: edgeVersion,
        features: config.features
      };
    }
  };
})();


recorder/edge/manifest.json
----------------------------------


{
  "manifest_version": 2,
  "name": "CSTestForge Recorder",
  "version": "1.0.0",
  "description": "Test recording and playback extension for CSTestForge framework",
  "author": "CSTestForge",
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "browser_action": {
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    },
    "default_title": "CSTestForge Recorder",
    "default_popup": "popup.html"
  },
  "background": {
    "scripts": ["background.js"],
    "persistent": true
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content-script.js"],
      "run_at": "document_start",
      "all_frames": true
    }
  ],
  "permissions": [
    "<all_urls>",
    "tabs",
    "activeTab",
    "webNavigation",
    "webRequest",
    "webRequestBlocking",
    "storage",
    "clipboardWrite",
    "contextMenus"
  ],
  "web_accessible_resources": [
    "injected-scripts/*",
    "icons/*",
    "styles/*"
  ],
  "content_security_policy": "script-src 'self' 'unsafe-eval'; object-src 'self'",
  "minimum_edge_version": "79.0"
}


recorder/edge/background.js
-------------------------------------------------------

/**
 * CSTestForge Edge Extension Background Script
 * 
 * Manages recording sessions, communication with the CSTestForge app, and coordinates
 * with content scripts across tabs and frames.
 */

// State management
let recordingActive = false;
let recordingTabId = null;
let recordingFrameId = 0;
let recordingSessionId = null;
let portConnection = null;
let pendingEvents = [];
let networkRequests = new Map(); // For tracking network requests
let recordingConfig = {
  captureNetwork: true,
  captureDOMChanges: true,
  captureConsole: true,
  recordFrames: true,
  elementDetectionLevel: 'advanced'
};

// Browser API compatibility layer - standard for Chrome/Edge
const browserAPI = chrome;

// Initialize extension
initializeExtension();

/**
 * Initialize the extension
 */
function initializeExtension() {
  setupContextMenu();
  setupBrowserAction();
  setupNetworkListeners();
  setupConnectionListener();
  setupMessageListeners();
  setupNavigationListeners();
  
  console.log('CSTestForge Edge extension initialized');
}

/**
 * Set up the context menu
 */
function setupContextMenu() {
  browserAPI.contextMenus.create({
    id: 'cstestforge-start-recording',
    title: 'Start Recording',
    contexts: ['browser_action']
  });
  
  browserAPI.contextMenus.create({
    id: 'cstestforge-stop-recording',
    title: 'Stop Recording',
    contexts: ['browser_action'],
    enabled: false
  });
  
  browserAPI.contextMenus.create({
    id: 'cstestforge-take-screenshot',
    title: 'Take Screenshot',
    contexts: ['browser_action']
  });
  
  browserAPI.contextMenus.create({
    id: 'cstestforge-separator',
    type: 'separator',
    contexts: ['browser_action']
  });
  
  browserAPI.contextMenus.create({
    id: 'cstestforge-options',
    title: 'Options',
    contexts: ['browser_action']
  });
  
  browserAPI.contextMenus.onClicked.addListener((info, tab) => {
    switch (info.menuItemId) {
      case 'cstestforge-start-recording':
        startRecording(tab.id);
        break;
      case 'cstestforge-stop-recording':
        stopRecording();
        break;
      case 'cstestforge-take-screenshot':
        captureScreenshot(tab.id);
        break;
      case 'cstestforge-options':
        browserAPI.runtime.openOptionsPage();
        break;
    }
  });
}

/**
 * Set up the browser action button
 */
function setupBrowserAction() {
  browserAPI.browserAction.onClicked.addListener((tab) => {
    if (recordingActive && recordingTabId === tab.id) {
      // Stop recording if already recording on this tab
      stopRecording();
    } else {
      // Start recording on this tab
      startRecording(tab.id);
    }
  });
}

/**
 * Set up network request listeners
 */
function setupNetworkListeners() {
  // Before request listener
  browserAPI.webRequest.onBeforeRequest.addListener(
    (details) => {
      if (!recordingActive || details.tabId !== recordingTabId || !recordingConfig.captureNetwork) {
        return;
      }
      
      // Store request start time
      networkRequests.set(details.requestId, {
        startTime: Date.now(),
        method: details.method,
        url: details.url,
        type: details.type,
        frameId: details.frameId
      });
      
      // Send event
      sendToRecorder({
        type: 'cstestforge_network_request_started',
        requestId: details.requestId,
        url: details.url,
        method: details.method,
        type: details.type,
        timestamp: Date.now(),
        sessionId: recordingSessionId,
        tabId: details.tabId,
        frameId: details.frameId
      });
    },
    { urls: ['<all_urls>'] }
  );
  
  // Completed listener
  browserAPI.webRequest.onCompleted.addListener(
    (details) => {
      if (!recordingActive || details.tabId !== recordingTabId || !recordingConfig.captureNetwork) {
        return;
      }
      
      const request = networkRequests.get(details.requestId);
      if (request) {
        // Calculate duration
        const duration = Date.now() - request.startTime;
        
        // Send event
        sendToRecorder({
          type: 'cstestforge_network_request_completed',
          requestId: details.requestId,
          url: details.url,
          method: request.method,
          type: request.type,
          status: details.statusCode,
          statusText: details.statusLine,
          duration: duration,
          timestamp: Date.now(),
          sessionId: recordingSessionId,
          tabId: details.tabId,
          frameId: details.frameId
        });
        
        // Clean up
        networkRequests.delete(details.requestId);
      }
    },
    { urls: ['<all_urls>'] }
  );
  
  // Error listener
  browserAPI.webRequest.onErrorOccurred.addListener(
    (details) => {
      if (!recordingActive || details.tabId !== recordingTabId || !recordingConfig.captureNetwork) {
        return;
      }
      
      const request = networkRequests.get(details.requestId);
      if (request) {
        // Calculate duration
        const duration = Date.now() - request.startTime;
        
        // Send event
        sendToRecorder({
          type: 'cstestforge_network_request_failed',
          requestId: details.requestId,
          url: details.url,
          method: request.method,
          type: request.type,
          error: details.error,
          duration: duration,
          timestamp: Date.now(),
          sessionId: recordingSessionId,
          tabId: details.tabId,
          frameId: details.frameId
        });
        
        // Clean up
        networkRequests.delete(details.requestId);
      }
    },
    { urls: ['<all_urls>'] }
  );
  
  // Headers received listener
  browserAPI.webRequest.onHeadersReceived.addListener(
    (details) => {
      if (!recordingActive || details.tabId !== recordingTabId || !recordingConfig.captureNetwork) {
        return;
      }
      
      const request = networkRequests.get(details.requestId);
      if (request) {
        // Extract headers
        const headers = {};
        if (details.responseHeaders) {
          for (const header of details.responseHeaders) {
            headers[header.name.toLowerCase()] = header.value;
          }
        }
        
        // Send event
        sendToRecorder({
          type: 'cstestforge_network_response_headers',
          requestId: details.requestId,
          url: details.url,
          status: details.statusCode,
          statusText: details.statusLine,
          headers: headers,
          contentType: headers['content-type'] || '',
          contentLength: headers['content-length'] || 0,
          timestamp: Date.now(),
          sessionId: recordingSessionId,
          tabId: details.tabId,
          frameId: details.frameId
        });
      }
    },
    { urls: ['<all_urls>'] },
    ['responseHeaders']
  );
}

/**
 * Set up connection listener for native app communication
 */
function setupConnectionListener() {
  browserAPI.runtime.onConnect.addListener((port) => {
    if (port.name === 'cs-testforge-recorder') {
      portConnection = port;
      console.log('Connected to CSTestForge recorder application');
      
      // Handle messages from the recorder application
      port.onMessage.addListener(handleRecorderMessage);
      // Handle disconnect
      port.onDisconnect.addListener(() => {
        console.log('Disconnected from CSTestForge recorder application');
        portConnection = null;
        
        // Stop recording if active
        if (recordingActive) {
          stopRecording();
        }
      });
      
      // Send any pending events
      if (pendingEvents.length > 0) {
        pendingEvents.forEach(event => port.postMessage(event));
        pendingEvents = [];
      }
    }
  });
}

/**
 * Set up message listeners for content script communication
 */
function setupMessageListeners() {
  browserAPI.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (!message.type || !message.type.startsWith('cstestforge_')) {
      return;
    }
    
    // Add sender information to the message
    message.sender = {
      tabId: sender.tab.id,
      frameId: sender.frameId || 0,
      url: sender.url || sender.tab.url
    };
    
    // Add timestamp if not present
    if (!message.timestamp) {
      message.timestamp = Date.now();
    }
    
    // Add session ID if recording is active
    if (recordingActive && recordingSessionId) {
      message.sessionId = recordingSessionId;
    }
    
    // Handle specific message types
    switch (message.type) {
      case 'cstestforge_dom_event':
        handleDomEvent(message);
        break;
      case 'cstestforge_network_event':
        handleNetworkEvent(message);
        break;
      case 'cstestforge_console_event':
        handleConsoleEvent(message);
        break;
      case 'cstestforge_element_info':
        handleElementInfo(message);
        break;
      case 'cstestforge_error':
        handleErrorEvent(message);
        break;
      case 'cstestforge_ready':
        handleContentScriptReady(message, sender);
        break;
      default:
        // Forward unknown message types to the recorder app
        forwardToRecorder(message);
        break;
    }
    
    // Return true to indicate async response
    return true;
  });
}

/**
 * Set up navigation event listeners
 */
function setupNavigationListeners() {
  // Listen for tab navigation events
  browserAPI.webNavigation.onCommitted.addListener(onNavigationCommitted);
  browserAPI.webNavigation.onCompleted.addListener(onNavigationCompleted);
  browserAPI.webNavigation.onDOMContentLoaded.addListener(onDOMContentLoaded);
  browserAPI.webNavigation.onErrorOccurred.addListener(onNavigationError);
  
  // Listen for tab updates
  browserAPI.tabs.onUpdated.addListener(onTabUpdated);
  
  // Listen for tab removal
  browserAPI.tabs.onRemoved.addListener(onTabRemoved);
}

/**
 * Handle messages from the recorder application
 * @param {Object} message - Message from recorder
 */
function handleRecorderMessage(message) {
  switch (message.command) {
    case 'start_recording':
      startRecording(message.tabId, message.config, message.sessionId);
      break;
    case 'stop_recording':
      stopRecording();
      break;
    case 'pause_recording':
      pauseRecording();
      break;
    case 'resume_recording':
      resumeRecording();
      break;
    case 'update_config':
      updateConfig(message.config);
      break;
    case 'inject_script':
      injectScript(message.tabId, message.frameId, message.script);
      break;
    case 'highlight_element':
      highlightElement(message.tabId, message.frameId, message.selector, message.duration);
      break;
    case 'get_element_info':
      getElementInfo(message.tabId, message.frameId, message.selector);
      break;
    case 'execute_action':
      executeAction(message.tabId, message.frameId, message.action);
      break;
    case 'ping':
      respondToPing(message.id);
      break;
    case 'screenshot':
      captureScreenshot(message.tabId, message.area);
      break;
    default:
      console.warn('Unknown command received:', message.command);
      break;
  }
}

/**
 * Start recording
 * @param {number} tabId - ID of the tab to record
 * @param {Object} config - Configuration for recording
 * @param {string} sessionId - Session ID to use
 */
function startRecording(tabId, config, sessionId) {
  if (recordingActive) {
    stopRecording();
  }
  
  recordingActive = true;
  recordingTabId = tabId;
  recordingSessionId = sessionId || generateSessionId();
  
  if (config) {
    recordingConfig = {...recordingConfig, ...config};
  }
  
  // Inject content scripts to the target tab and all frames
  injectContentScripts(tabId);
  
  // Update badge
  browserAPI.browserAction.setBadgeText({text: "REC"});
  browserAPI.browserAction.setBadgeBackgroundColor({color: "#C54B8C"});
  
  // Update context menu
  browserAPI.contextMenus.update('cstestforge-start-recording', { enabled: false });
  browserAPI.contextMenus.update('cstestforge-stop-recording', { enabled: true });
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_recording_started',
    sessionId: recordingSessionId,
    tabId: tabId,
    timestamp: Date.now(),
    config: recordingConfig
  });
  
  // Get tab info
  browserAPI.tabs.get(tabId, (tab) => {
    sendToRecorder({
      type: 'cstestforge_tab_info',
      sessionId: recordingSessionId,
      tabId: tabId,
      url: tab.url,
      title: tab.title,
      timestamp: Date.now()
    });
  });
}

/**
 * Stop recording
 */
function stopRecording() {
  if (!recordingActive) {
    return;
  }
  
  recordingActive = false;
  
  // Reset badge
  browserAPI.browserAction.setBadgeText({text: ""});
  
  // Update context menu
  browserAPI.contextMenus.update('cstestforge-start-recording', { enabled: true });
  browserAPI.contextMenus.update('cstestforge-stop-recording', { enabled: false });
  
  // Uninject content scripts
  uninjectContentScripts(recordingTabId);
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_recording_stopped',
    sessionId: recordingSessionId,
    timestamp: Date.now()
  });
  
  // Clear network request tracking
  networkRequests.clear();
  
  recordingTabId = null;
}

/**
 * Pause recording
 */
function pauseRecording() {
  if (!recordingActive) {
    return;
  }
  
  // Update content scripts to pause event capture
  sendToContentScripts(recordingTabId, {
    command: 'pause_recording'
  });
  
  // Update badge
  browserAPI.browserAction.setBadgeText({text: "||"});
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_recording_paused',
    sessionId: recordingSessionId,
    timestamp: Date.now()
  });
}

/**
 * Resume recording
 */
function resumeRecording() {
  if (!recordingActive) {
    return;
  }
  
  // Update content scripts to resume event capture
  sendToContentScripts(recordingTabId, {
    command: 'resume_recording'
  });
  
  // Update badge
  browserAPI.browserAction.setBadgeText({text: "REC"});
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_recording_resumed',
    sessionId: recordingSessionId,
    timestamp: Date.now()
  });
}

/**
 * Update recording configuration
 * @param {Object} config - New configuration
 */
function updateConfig(config) {
  recordingConfig = {...recordingConfig, ...config};
  
  // Update content scripts with new configuration
  if (recordingActive) {
    sendToContentScripts(recordingTabId, {
      command: 'update_config',
      config: recordingConfig
    });
  }
  
  // Notify recorder application
  sendToRecorder({
    type: 'cstestforge_config_updated',
    config: recordingConfig,
    timestamp: Date.now()
  });
}

/**
 * Inject custom script to page
 * @param {number} tabId - ID of the tab to inject into
 * @param {number} frameId - ID of the frame to inject into
 * @param {string} script - Script to inject
 */
function injectScript(tabId, frameId, script) {
  browserAPI.tabs.executeScript(tabId, {
    frameId: frameId || 0,
    code: script
  }).then(results => {
    sendToRecorder({
      type: 'cstestforge_script_injected',
      tabId: tabId,
      frameId: frameId || 0,
      result: results && results[0],
      timestamp: Date.now()
    });
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'script_injection',
      tabId: tabId,
      frameId: frameId || 0,
      timestamp: Date.now()
    });
  });
}

/**
 * Highlight an element
 * @param {number} tabId - ID of the tab
 * @param {number} frameId - ID of the frame
 * @param {string} selector - CSS selector for the element
 * @param {number} duration - Duration of highlight in ms
 */
function highlightElement(tabId, frameId, selector, duration) {
  const highlightScript = `
    (function() {
      try {
        const element = document.querySelector('${selector.replace(/'/g, "\\'")}');
        if (!element) return false;
        
        const originalOutline = element.style.outline;
        const originalOutlineOffset = element.style.outlineOffset;
        const originalTransition = element.style.transition;
        const originalPosition = element.style.position;
        const originalZIndex = element.style.zIndex;
        
        element.style.outline = '2px solid #C54B8C';
        element.style.outlineOffset = '2px';
        element.style.transition = 'outline 0.2s ease-in-out';
        element.style.position = originalPosition === 'static' ? 'relative' : originalPosition;
        element.style.zIndex = '99999';
        
        setTimeout(() => {
          element.style.outline = originalOutline;
          element.style.outlineOffset = originalOutlineOffset;
          element.style.transition = originalTransition;
          element.style.position = originalPosition;
          element.style.zIndex = originalZIndex;
        }, ${duration || 1000});
        
        return true;
      } catch (e) {
        console.error('CSTestForge highlight error:', e);
        return false;
      }
    })();
  `;
  
  browserAPI.tabs.executeScript(tabId, {
    frameId: frameId || 0,
    code: highlightScript
  }).then(results => {
    sendToRecorder({
      type: 'cstestforge_element_highlighted',
      tabId: tabId,
      frameId: frameId || 0,
      selector: selector,
      success: results && results[0],
      timestamp: Date.now()
    });
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'highlight_element',
      selector: selector,
      tabId: tabId,
      frameId: frameId || 0,
      timestamp: Date.now()
    });
  });
}

/**
 * Get detailed element information
 * @param {number} tabId - ID of the tab
 * @param {number} frameId - ID of the frame
 * @param {string} selector - CSS selector for the element
 */
function getElementInfo(tabId, frameId, selector) {
  const script = `
    (function() {
      try {
        const element = document.querySelector('${selector.replace(/'/g, "\\'")}');
        if (!element) return null;
        
        // Calculate element visibility
        const rect = element.getBoundingClientRect();
        const isInViewport = rect.top < window.innerHeight && rect.left < window.innerWidth && rect.bottom > 0 && rect.right > 0;
        
        // Compute computed styles
        const computedStyle = window.getComputedStyle(element);
        const isVisible = !(computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0');
        
        // Get element attributes
        const attributes = {};
        for (let i = 0; i < element.attributes.length; i++) {
          const attr = element.attributes[i];
          attributes[attr.name] = attr.value;
        }
        
        // Generate XPath
        function getXPath(element) {
          if (!element) return '';
          
          if (element.id) {
            return `//*[@id="${element.id}"]`;
          }
          
          if (element === document.body) {
            return '/html/body';
          }
          
          let ix = 0;
          const siblings = element.parentNode.childNodes;
          
          for (let i = 0; i < siblings.length; i++) {
            const sibling = siblings[i];
            
            if (sibling === element) {
              const tagName = element.tagName.toLowerCase();
              const pathIndex = ix + 1;
              const parentPath = getXPath(element.parentNode);
              
              return `${parentPath}/${tagName}[${pathIndex}]`;
            }
            
            if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
              ix++;
            }
          }
        }
        
        // Generate CSS Selector
        function generateCssSelector(element) {
          if (!element) return '';
          if (element.id) return `#${element.id}`;
          
          let selector = element.tagName.toLowerCase();
          
          if (element.className) {
            const classes = element.className.split(' ').filter(c => c && !c.startsWith('ng-') && !c.includes(':'));
            if (classes.length > 0) {
              selector += '.' + classes.join('.');
            }
          }
          
          // Add attribute selectors for specific attributes
          const relevantAttrs = ['name', 'type', 'role', 'data-test', 'data-testid', 'data-test-id', 'data-cy'];
          for (const attr of relevantAttrs) {
            if (element.hasAttribute(attr)) {
              selector += `[${attr}="${element.getAttribute(attr)}"]`;
              break; // Just use one unique attribute
            }
          }
          
          return selector;
        }
        
        // Smart CSS Selector
        function generateSmartSelector(element) {
          if (!element) return '';
          
          // Start with the element's tag
          let selector = element.tagName.toLowerCase();
          
          // Add ID if it exists and isn't auto-generated
          if (element.id && !/^[0-9]/.test(element.id) && !element.id.includes(':')) {
            return `#${element.id}`;
          }
          
          // Add specific attribute selectors
          const preferredAttrs = [
            'data-testid', 'data-test', 'data-test-id', 'data-cy', 'data-automation',
            'name', 'aria-label', 'title', 'for', 'alt'
          ];
          
          for (const attr of preferredAttrs) {
            if (element.hasAttribute(attr)) {
              selector += `[${attr}="${element.getAttribute(attr)}"]`;
              return selector; // These are usually unique enough
            }
          }
          
          // Add classes that don't look auto-generated
          if (element.className) {
            const classes = element.className.split(' ')
              .filter(c => c && !c.includes(':') && !c.startsWith('ng-') && !/^[a-z][0-9]$/.test(c) && c.length > 2);
            
            if (classes.length === 1) {
              selector += `.${classes[0]}`;
            } else if (classes.length > 1) {
              // Just use the first 2 classes to avoid over-specificity
              selector += `.${classes[0]}.${classes[1]}`;
            }
          }
          
          // Make selector more specific by adding parent context
          if (element.parentElement && element.parentElement !== document.body) {
            const parentTag = element.parentElement.tagName.toLowerCase();
            
            // If parent has ID, use that
            if (element.parentElement.id && !/^[0-9]/.test(element.parentElement.id) && !element.parentElement.id.includes(':')) {
              return `#${element.parentElement.id} > ${selector}`;
            }
            
            // Otherwise just use parent tag
            return `${parentTag} > ${selector}`;
          }
          
          return selector;
        }
        
        return {
          tagName: element.tagName,
          id: element.id,
          className: element.className,
          attributes: attributes,
          text: element.textContent.trim().substring(0, 100),
          value: element.value,
          type: element.type,
          checked: element.checked,
          dimensions: {
            width: rect.width,
            height: rect.height,
            top: rect.top,
            left: rect.left,
            bottom: rect.bottom,
            right: rect.right
          },
          isInViewport: isInViewport,
          isVisible: isVisible,
          xpath: getXPath(element),
          cssSelector: generateCssSelector(element),
          smartSelector: generateSmartSelector(element)
        };
      } catch (e) {
        console.error('CSTestForge element info error:', e);
        return null;
      }
    })();
  `;
  
  browserAPI.tabs.executeScript(tabId, {
    frameId: frameId || 0,
    code: script
  }).then(results => {
    sendToRecorder({
      type: 'cstestforge_element_info',
      tabId: tabId,
      frameId: frameId || 0,
      selector: selector,
      elementInfo: results && results[0],
      timestamp: Date.now()
    });
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'get_element_info',
      selector: selector,
      tabId: tabId,
      frameId: frameId || 0,
      timestamp: Date.now()
    });
  });
}

/**
 * Execute an action on an element
 * @param {number} tabId - ID of the tab
 * @param {number} frameId - ID of the frame
 * @param {Object} action - Action to execute
 */
function executeAction(tabId, frameId, action) {
  const script = `
    (function() {
      try {
        const element = document.querySelector('${action.selector.replace(/'/g, "\\'")}');
        if (!element) return { success: false, error: 'Element not found' };
        
        switch ('${action.type}') {
          case 'click':
            element.click();
            break;
          case 'rightClick':
            const rightClickEvent = new MouseEvent('contextmenu', {
              bubbles: true,
              cancelable: true,
              view: window,
              button: 2,
              buttons: 2
            });
            element.dispatchEvent(rightClickEvent);
            break;
          case 'doubleClick':
            const dblClickEvent = new MouseEvent('dblclick', {
              bubbles: true,
              cancelable: true,
              view: window
            });
            element.dispatchEvent(dblClickEvent);
            break;
          case 'type':
            element.value = '${(action.text || '').replace(/'/g, "\\'")}';
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            break;
          case 'clear':
            element.value = '';
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            break;
          case 'select':
            const options = element.querySelectorAll('option');
            for (let i = 0; i < options.length; i++) {
              const option = options[i];
              if (option.value === '${(action.value || '').replace(/'/g, "\\'")}' || option.text === '${(action.text || '').replace(/'/g, "\\'")}') {
                option.selected = true;
                element.dispatchEvent(new Event('change', { bubbles: true }));
                break;
              }
            }
            break;
          case 'check':
            if (!element.checked) {
              element.click();
            }
            break;
          case 'uncheck':
            if (element.checked) {
              element.click();
            }
            break;
          case 'focus':
            element.focus();
            break;
          case 'blur':
            element.blur();
            break;
          case 'hover':
            const hoverEvent = new MouseEvent('mouseover', {
              bubbles: true,
              cancelable: true,
              view: window
            });
            element.dispatchEvent(hoverEvent);
            break;
          default:
            return { success: false, error: 'Unsupported action type' };
        }
        
        return { success: true };
      } catch (e) {
        console.error('CSTestForge action error:', e);
        return { success: false, error: e.message };
      }
    })();
  `;
  
  browserAPI.tabs.executeScript(tabId, {
    frameId: frameId || 0,
    code: script
  }).then(results => {
    const result = results && results[0];
    sendToRecorder({
      type: 'cstestforge_action_executed',
      tabId: tabId,
      frameId: frameId || 0,
      action: action,
      success: result && result.success,
      error: result && result.error,
      timestamp: Date.now()
    });
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'execute_action',
      action: action,
      tabId: tabId,
      frameId: frameId || 0,
      timestamp: Date.now()
    });
  });
}

/**
 * Respond to ping from recorder
 * @param {string} id - Ping ID
 */
function respondToPing(id) {
  sendToRecorder({
    type: 'cstestforge_pong',
    id: id,
    timestamp: Date.now()
  });
}

/**
 * Capture screenshot
 * @param {number} tabId - ID of the tab
 * @param {Object} area - Area to capture
 */
function captureScreenshot(tabId, area) {
  browserAPI.tabs.captureVisibleTab(null, { format: 'png' }).then(dataUrl => {
    // If area is specified, crop the image
    if (area) {
      cropImage(dataUrl, area).then(croppedDataUrl => {
        sendToRecorder({
          type: 'cstestforge_screenshot',
          tabId: tabId,
          dataUrl: croppedDataUrl,
          timestamp: Date.now()
        });
      }).catch(error => {
        sendToRecorder({
          type: 'cstestforge_error',
          error: error.message,
          context: 'screenshot_crop',
          tabId: tabId,
          timestamp: Date.now()
        });
      });
    } else {
      sendToRecorder({
        type: 'cstestforge_screenshot',
        tabId: tabId,
        dataUrl: dataUrl,
        timestamp: Date.now()
      });
    }
  }).catch(error => {
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'screenshot',
      tabId: tabId,
      timestamp: Date.now()
    });
  });
}

/**
 * Crop image utility function
 * @param {string} dataUrl - Data URL of the image
 * @param {Object} area - Area to crop
 * @returns {Promise<string>} Cropped image data URL
 */
function cropImage(dataUrl, area) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = function() {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Ensure crop area doesn't exceed image dimensions
        const cropArea = {
          x: Math.min(area.x, img.width),
          y: Math.min(area.y, img.height),
          width: Math.min(area.width, img.width - area.x),
          height: Math.min(area.height, img.height - area.y)
        };
        
        canvas.width = cropArea.width;
        canvas.height = cropArea.height;
        
        ctx.drawImage(
          img,
          cropArea.x, cropArea.y, cropArea.width, cropArea.height,
          0, 0, cropArea.width, cropArea.height
        );
        
        resolve(canvas.toDataURL('image/png'));
      } catch (e) {
        reject(e);
      }
    };
    img.onerror = function() {
      reject(new Error('Failed to load image for cropping'));
    };
    img.src = dataUrl;
  });
}

/**
 * Handle DOM events
 * @param {Object} message - Event message
 */
function handleDomEvent(message) {
  if (!recordingActive) {
    return;
  }
  
  // Filter events based on configuration
  if (!recordingConfig.captureDOMChanges) {
    return;
  }
  
  // Forward to recorder
  forwardToRecorder(message);
}

/**
 * Handle network events
 * @param {Object} message - Event message
 */
function handleNetworkEvent(message) {
  if (!recordingActive) {
    return;
  }
  
  // Filter events based on configuration
  if (!recordingConfig.captureNetwork) {
    return;
  }
  
  // Forward to recorder
  forwardToRecorder(message);
}

/**
 * Handle console events
 * @param {Object} message - Event message
 */
function handleConsoleEvent(message) {
  if (!recordingActive) {
    return;
  }
  
  // Filter events based on configuration
  if (!recordingConfig.captureConsole) {
    return;
  }
  
  // Forward to recorder
  forwardToRecorder(message);
}

/**
 * Handle element info events
 * @param {Object} message - Event message
 */
function handleElementInfo(message) {
  // Always forward element info events
  forwardToRecorder(message);
}

/**
 * Handle error events
 * @param {Object} message - Event message
 */
function handleErrorEvent(message) {
  // Always forward error events
  forwardToRecorder(message);
}

/**
 * Handle content script ready events
 * @param {Object} message - Ready message
 * @param {Object} sender - Message sender
 */
function handleContentScriptReady(message, sender) {
  if (recordingActive && recordingTabId === sender.tab.id) {
    // Send recording configuration to the content script
    browserAPI.tabs.sendMessage(sender.tab.id, {
      command: 'start_recording',
      config: recordingConfig,
      sessionId: recordingSessionId
    }, { frameId: sender.frameId || 0 }).catch(error => {
      console.error('Failed to send recording config to content script:', error);
    });
  }
}

/**
 * Forward message to recorder application
 * @param {Object} message - Message to forward
 */
function forwardToRecorder(message) {
  if (portConnection) {
    portConnection.postMessage(message);
  } else {
    // Store event for sending when connection is established
    pendingEvents.push(message);
    
    // Limit stored events to prevent memory issues
    if (pendingEvents.length > 1000) {
      pendingEvents.shift();
    }
  }
}

/**
 * Send message to content scripts
 * @param {number} tabId - ID of the tab
 * @param {Object} message - Message to send
 */
function sendToContentScripts(tabId, message) {
  if (!tabId) {
    return;
  }
  
  browserAPI.tabs.sendMessage(tabId, message).catch(error => {
    console.error('Failed to send message to content scripts:', error);
  });
}

/**
 * Inject content scripts to the target tab and all frames
 * @param {number} tabId - ID of the tab
 */
function injectContentScripts(tabId) {
  // Inject event capture script to main frame and all iframes
  const codeToInject = `
    if (!window._csTestForgeInjected) {
      window._csTestForgeInjected = true;
      
      // Notify background script that content script is ready
      chrome.runtime.sendMessage({
        type: 'cstestforge_ready',
        timestamp: Date.now(),
        url: window.location.href,
        title: document.title
      });
    }
  `;
  
  // Execute in the main frame
  browserAPI.tabs.executeScript(tabId, {
    file: '/content-script.js',
    runAt: 'document_start'
  }).then(() => {
    browserAPI.tabs.executeScript(tabId, {
      code: codeToInject
    });
  }).catch(error => {
    console.error('Failed to inject content script to main frame:', error);
    sendToRecorder({
      type: 'cstestforge_error',
      error: error.message,
      context: 'inject_content_script',
      tabId: tabId,
      timestamp: Date.now()
    });
  });
  
  // Find and inject into all iframes if needed
  if (recordingConfig.recordFrames) {
    browserAPI.webNavigation.getAllFrames({ tabId }).then(frames => {
      frames.forEach(frame => {
        if (frame.frameId !== 0) { // Skip main frame (already handled)
          browserAPI.tabs.executeScript(tabId, {
            file: '/content-script.js',
            frameId: frame.frameId,
            runAt: 'document_start'
          }).then(() => {
            browserAPI.tabs.executeScript(tabId, {
              code: codeToInject,
              frameId: frame.frameId
            });
          }).catch(error => {
            console.error(`Failed to inject content script to frame ${frame.frameId}:`, error);
            // Some frames may not be accessible due to same-origin policy, which is expected
          });
        }
      });
    }).catch(error => {
      console.error('Failed to get frames:', error);
    });
  }
}

/**
 * Uninject content scripts from the target tab
 * @param {number} tabId - ID of the tab
 */
function uninjectContentScripts(tabId) {
  if (!tabId) {
    return;
  }
  
  const cleanupCode = `
    if (window._csTestForgeInjected) {
      // Clean up event listeners
      window._csTestForgeCleanup && window._csTestForgeCleanup();
      delete window._csTestForgeInjected;
      delete window._csTestForgeCleanup;
    }
  `;
  
  // Execute in the main frame
  browserAPI.tabs.executeScript(tabId, {
    code: cleanupCode
  }).catch(error => {
    console.error('Failed to uninject content script from main frame:', error);
  });
  
  // Find and uninject from all iframes if needed
  if (recordingConfig.recordFrames) {
    browserAPI.webNavigation.getAllFrames({ tabId }).then(frames => {
      frames.forEach(frame => {
        if (frame.frameId !== 0) { // Skip main frame (already handled)
          browserAPI.tabs.executeScript(tabId, {
            code: cleanupCode,
            frameId: frame.frameId
          }).catch(error => {
            // Some frames may not be accessible due to same-origin policy, which is expected
          });
        }
      });
    }).catch(error => {
      console.error('Failed to get frames:', error);
    });
  }
}

/**
 * Handle navigation committed event
 * @param {Object} details - Navigation details
 */
function onNavigationCommitted(details) {
  if (!recordingActive || details.tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_navigation_committed',
    tabId: details.tabId,
    frameId: details.frameId,
    url: details.url,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
  
  // Re-inject content scripts after navigation
  if (details.frameId === 0) {
    setTimeout(() => {
      injectContentScripts(details.tabId);
    }, 100);
  }
}

/**
 * Handle navigation completed event
 * @param {Object} details - Navigation details
 */
function onNavigationCompleted(details) {
  if (!recordingActive || details.tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_navigation_completed',
    tabId: details.tabId,
    frameId: details.frameId,
    url: details.url,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
}

/**
 * Handle DOM content loaded event
 * @param {Object} details - Navigation details
 */
function onDOMContentLoaded(details) {
  if (!recordingActive || details.tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_dom_content_loaded',
    tabId: details.tabId,
    frameId: details.frameId,
    url: details.url,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
}

/**
 * Handle navigation error event
 * @param {Object} details - Navigation details
 */
function onNavigationError(details) {
  if (!recordingActive || details.tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_navigation_error',
    tabId: details.tabId,
    frameId: details.frameId,
    url: details.url,
    error: details.error,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
}

/**
 * Handle tab update event
 * @param {number} tabId - ID of the tab
 * @param {Object} changeInfo - Change information
 * @param {Object} tab - Tab details
 */
function onTabUpdated(tabId, changeInfo, tab) {
  if (!recordingActive || tabId !== recordingTabId) {
    return;
  }
  
  if (changeInfo.status === 'loading') {
    sendToRecorder({
      type: 'cstestforge_tab_loading',
      tabId: tabId,
      url: tab.url,
      timestamp: Date.now(),
      sessionId: recordingSessionId
    });
  } else if (changeInfo.status === 'complete') {
    sendToRecorder({
      type: 'cstestforge_tab_complete',
      tabId: tabId,
      url: tab.url,
      title: tab.title,
      timestamp: Date.now(),
      sessionId: recordingSessionId
    });
  }
}

/**
 * Handle tab removed event
 * @param {number} tabId - ID of the tab
 */
function onTabRemoved(tabId) {
  if (!recordingActive || tabId !== recordingTabId) {
    return;
  }
  
  sendToRecorder({
    type: 'cstestforge_tab_closed',
    tabId: tabId,
    timestamp: Date.now(),
    sessionId: recordingSessionId
  });
  
  // Stop recording if the recording tab is closed
  stopRecording();
}

/**
 * Generate a unique session ID
 * @returns {string} Session ID
 */
function generateSessionId() {
  return 'cs_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
}

/**
 * Send message to recorder
 * @param {Object} message - Message to send
 */
function sendToRecorder(message) {
  if (portConnection) {
    portConnection.postMessage(message);
  } else {
    // Store event for sending when connection is established
    pendingEvents.push(message);
    
    // Limit stored events to prevent memory issues
    if (pendingEvents.length > 1000) {
      pendingEvents.shift();
    }
  }
}


recorder/edge/content-script.js
----------------------------------------------------

/**
 * CSTestForge Edge Extension Content Script
 * 
 * This script is injected into web pages to capture user events, DOM changes,
 * and network activity during test recording.
 */

(function() {
  // State management
  let recording = false;
  let sessionId = null;
  let config = {
    captureNetwork: true,
    captureDOMChanges: true,
    captureConsole: true,
    recordFrames: true,
    elementDetectionLevel: 'advanced'
  };
  let eventListeners = [];
  let ignoredElements = new WeakSet();
  let lastEvent = null;
  let lastMouseMoveTime = 0;
  let mouseMoveDebouncePeriod = 100; // ms
  let mouseMoveTimeout = null;
  
  // Element cache for storing element descriptions
  const elementCache = new WeakMap();
  
  // Collection of cleanup functions
  const cleanupFunctions = [];
  
  // Initialize when the content script is loaded
  initialize();
  
  /**
   * Initialize the content script
   */
  function initialize() {
    // Browser API compatibility layer - standard for Chrome/Edge
    window.browserAPI = chrome;
    
    // Expose cleanup function to window object for background script to call
    window._csTestForgeCleanup = cleanup;
    
    // Send ready message to background script
    browserAPI.runtime.sendMessage({
      type: 'cstestforge_ready',
      timestamp: Date.now(),
      url: window.location.href,
      title: document.title
    }).catch(error => {
      console.error('Failed to send ready message:', error);
    });
    
    // Set up message listener
    browserAPI.runtime.onMessage.addListener(handleMessage);
    
    // Add method to ignore elements from recording
    window.csTestForgeIgnoreElement = (element) => {
      if (element) {
        ignoredElements.add(element);
      }
    };
    
    // Handle Edge-specific quirks
    if (navigator.userAgent.includes('Edg/')) {
      handleEdgeQuirks();
    }
  }
  
  /**
   * Handle messages from background script
   * @param {Object} message - Message received
   * @param {Object} sender - Message sender details
   * @param {Function} sendResponse - Response function
   * @returns {boolean} Whether to keep the message channel open
   */
  function handleMessage(message, sender, sendResponse) {
    if (!message.command) {
      return false;
    }
    
    switch (message.command) {
      case 'start_recording':
        startRecording(message.sessionId, message.config);
        break;
      case 'stop_recording':
        stopRecording();
        break;
      case 'pause_recording':
        pauseRecording();
        break;
      case 'resume_recording':
        resumeRecording();
        break;
      case 'update_config':
        updateConfig(message.config);
        break;
      case 'get_element_info':
        const elementInfo = getElementInfo(message.selector);
        sendResponse(elementInfo);
        return true; // Keep the message channel open for async response
      case 'execute_action':
        const result = executeAction(message.action);
        sendResponse(result);
        return true; // Keep the message channel open for async response
      case 'highlight_element':
        const highlighted = highlightElement(message.selector, message.duration);
        sendResponse({ success: highlighted });
        return true; // Keep the message channel open for async response
    }
    
    return false;
  }
  
  /**
   * Apply Edge-specific quirks handling
   */
  function handleEdgeQuirks() {
    // Check Edge version
    const edgeRegex = /Edg\/([0-9]+)/;
    const match = navigator.userAgent.match(edgeRegex);
    const edgeVersion = match ? parseInt(match[1], 10) : 0;
    
    // Legacy Edge (EdgeHTML, pre-Chromium) needs special handling
    if (edgeVersion < 79) {
      // Custom event polyfill for older Edge
      if (typeof CustomEvent !== 'function') {
        window.CustomEvent = function(event, params) {
          params = params || { bubbles: false, cancelable: false, detail: undefined };
          const evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
          return evt;
        };
        CustomEvent.prototype = window.Event.prototype;
      }
      
      // Fix for MouseEvent constructor in legacy Edge
      const originalMouseEvent = window.MouseEvent;
      try {
        new MouseEvent('test');
      } catch (e) {
        window.MouseEvent = function(type, init) {
          init = init || {};
          const event = document.createEvent('MouseEvent');
          event.initMouseEvent(
            type,
            init.bubbles !== undefined ? init.bubbles : true,
            init.cancelable !== undefined ? init.cancelable : true,
            init.view || window,
            init.detail || 0,
            init.screenX || 0,
            init.screenY || 0,
            init.clientX || 0,
            init.clientY || 0,
            init.ctrlKey || false,
            init.altKey || false,
            init.shiftKey || false,
            init.metaKey || false,
            init.button || 0,
            init.relatedTarget || null
          );
          return event;
        };
        
        cleanupFunctions.push(() => {
          window.MouseEvent = originalMouseEvent;
        });
      }
    }
  }
  
  /**
   * Start recording events
   * @param {string} newSessionId - Session ID for recording
   * @param {Object} newConfig - Configuration for recording
   */
  function startRecording(newSessionId, newConfig) {
    // Reset state first in case we're restarting
    stopRecording();
    
    recording = true;
    sessionId = newSessionId || ('cs_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15));
    
    if (newConfig) {
      config = { ...config, ...newConfig };
    }
    
    // Record page navigation
    recordNavigation();
    
    // Set up event listeners
    setupEventListeners();
    
    // Set up mutation observer for DOM changes
    setupMutationObserver();
    
    // Set up console listener
    setupConsoleListener();
    
    // Set up network listener
    setupNetworkListener();
    
    // Record page readiness
    browserAPI.runtime.sendMessage({
      type: 'cstestforge_recording_started',
      sessionId: sessionId,
      url: window.location.href,
      title: document.title,
      timestamp: Date.now()
    }).catch(error => {
      console.error('Failed to send recording started message:', error);
    });
  }
  
  /**
   * Stop recording events
   */
  function stopRecording() {
    if (!recording) {
      return;
    }
    
    recording = false;
    
    // Clean up all event listeners and observers
    cleanup();
    
    // Notify background script
    browserAPI.runtime.sendMessage({
      type: 'cstestforge_recording_stopped',
      sessionId: sessionId,
      timestamp: Date.now()
    }).catch(error => {
      console.error('Failed to send recording stopped message:', error);
    });
  }
  
  /**
   * Pause recording events
   */
  function pauseRecording() {
    recording = false;
    
    // Notify background script
    browserAPI.runtime.sendMessage({
      type: 'cstestforge_recording_paused',
      sessionId: sessionId,
      timestamp: Date.now()
    }).catch(error => {
      console.error('Failed to send recording paused message:', error);
    });
  }
  
  /**
   * Resume recording events
   */
  function resumeRecording() {
    recording = true;
    
    // Notify background script
    browserAPI.runtime.sendMessage({
      type: 'cstestforge_recording_resumed',
      sessionId: sessionId,
      timestamp: Date.now()
    }).catch(error => {
      console.error('Failed to send recording resumed message:', error);
    });
  }
  
  /**
   * Update recording configuration
   * @param {Object} newConfig - New configuration
   */
  function updateConfig(newConfig) {
    const oldConfig = { ...config };
    config = { ...config, ...newConfig };
    
    // Handle configuration changes that require reinitializing listeners
    if (recording) {
      if (oldConfig.captureNetwork !== config.captureNetwork || 
          oldConfig.captureDOMChanges !== config.captureDOMChanges || 
          oldConfig.captureConsole !== config.captureConsole) {
        
        // Reinitialize event listeners based on new configuration
        cleanup();
        setupEventListeners();
        
        if (config.captureDOMChanges) {
          setupMutationObserver();
        }
        
        if (config.captureConsole) {
          setupConsoleListener();
        }
        
        if (config.captureNetwork) {
          setupNetworkListener();
        }
      }
    }
    
    // Notify background script
    browserAPI.runtime.sendMessage({
      type: 'cstestforge_config_updated',
      config: config,
      sessionId: sessionId,
      timestamp: Date.now()
    }).catch(error => {
      console.error('Failed to send config updated message:', error);
    });
  }
  
  /**
   * Clean up all event listeners and observers
   */
  function cleanup() {
    // Remove all registered event listeners
    for (const { element, type, listener, options } of eventListeners) {
      element.removeEventListener(type, listener, options);
    }
    eventListeners = [];
    
    // Run all cleanup functions
    for (const cleanup of cleanupFunctions) {
      try {
        cleanup();
      } catch (e) {
        console.error('Error in cleanup function:', e);
      }
    }
    
    // Clear the cleanup functions array
    cleanupFunctions.length = 0;
    
    // Clear any pending timeouts
    if (mouseMoveTimeout) {
      clearTimeout(mouseMoveTimeout);
      mouseMoveTimeout = null;
    }
  }
  
  /**
   * Set up all event listeners
   */
  function setupEventListeners() {
    // Mouse events
    addEventListenerWithCleanup(document, 'click', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'contextmenu', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'dblclick', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'mousedown', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'mouseup', recordMouseEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'mousemove', recordMouseMove, { capture: true, passive: true });
    
    // Keyboard events
    addEventListenerWithCleanup(document, 'keydown', recordKeyboardEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'keyup', recordKeyboardEvent, { capture: true, passive: true });
    
    // Form events
    addEventListenerWithCleanup(document, 'change', recordFormEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'input', recordFormEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'submit', recordFormEvent, { capture: true, passive: true });
    
    // Focus events
    addEventListenerWithCleanup(document, 'focus', recordFocusEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'blur', recordFocusEvent, { capture: true, passive: true });
    
    // Drag events
    addEventListenerWithCleanup(document, 'dragstart', recordDragEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'dragend', recordDragEvent, { capture: true, passive: true });
    addEventListenerWithCleanup(document, 'drop', recordDragEvent, { capture: true, passive: true });
    
    // Scroll events (debounced)
    let scrollTimeout = null;
    addEventListenerWithCleanup(document, 'scroll', (event) => {
      if (!recording || !event.target) return;
      
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      
      scrollTimeout = setTimeout(() => {
        recordScrollEvent(event);
        scrollTimeout = null;
      }, 200);
    }, { capture: true, passive: true });
    
    // Window events
    addEventListenerWithCleanup(window, 'resize', (event) => {
      if (!recording) return;
      
      recordEvent('window_resize', {
        width: window.innerWidth,
        height: window.innerHeight
      });
    }, { passive: true });
    
    // Page lifecycle events
    addEventListenerWithCleanup(window, 'beforeunload', (event) => {
      if (!recording) return;
      
      recordEvent('page_beforeunload', {
        url: window.location.href
      });
    }, { passive: true });
    
    addEventListenerWithCleanup(window, 'unload', (event) => {
      if (!recording) return;
      
      recordEvent('page_unload', {
        url: window.location.href
      });
    }, { passive: true });
    
    addEventListenerWithCleanup(window, 'pagehide', (event) => {
      if (!recording) return;
      
      recordEvent('page_hide', {
        url: window.location.href,
        persisted: event.persisted
      });
    }, { passive: true });
    
    addEventListenerWithCleanup(window, 'pageshow', (event) => {
      if (!recording) return;
      
      recordEvent('page_show', {
        url: window.location.href,
        persisted: event.persisted
      });
    }, { passive: true });
    
    // History events
    const originalPushState = window.history.pushState;
    window.history.pushState = function() {
      const result = originalPushState.apply(this, arguments);
      
      if (recording) {
        recordEvent('history_push_state', {
          url: window.location.href,
          state: arguments[0] ? JSON.stringify(arguments[0]) : null,
          title: arguments[1],
          path: arguments[2]
        });
      }
      
      return result;
    };
    cleanupFunctions.push(() => {
      window.history.pushState = originalPushState;
    });
    
    const originalReplaceState = window.history.replaceState;
    window.history.replaceState = function() {
      const result = originalReplaceState.apply(this, arguments);
      
      if (recording) {
        recordEvent('history_replace_state', {
          url: window.location.href,
          state: arguments[0] ? JSON.stringify(arguments[0]) : null,
          title: arguments[1],
          path: arguments[2]
        });
      }
      
      return result;
    };
    cleanupFunctions.push(() => {
      window.history.replaceState = originalReplaceState;
    });
    
    addEventListenerWithCleanup(window, 'popstate', (event) => {
      if (!recording) return;
      
      recordEvent('history_pop_state', {
        url: window.location.href,
        state: event.state ? JSON.stringify(event.state) : null
      });
    }, { passive: true });
  }
  
  /**
   * Helper to add event listener and track for cleanup
   * @param {Element} element - Element to attach listener to
   * @param {string} type - Event type
   * @param {Function} listener - Event listener
   * @param {Object} options - Event listener options
   */
  function addEventListenerWithCleanup(element, type, listener, options) {
    const wrappedListener = function(event) {
      if (recording) {
        listener(event);
      }
    };
    
    element.addEventListener(type, wrappedListener, options);
    
    eventListeners.push({
      element,
      type,
      listener: wrappedListener,
      options
    });
  }
  
  /**
   * Set up mutation observer for DOM changes
   */
  function setupMutationObserver() {
    if (!config.captureDOMChanges) {
      return;
    }
    
    const observer = new MutationObserver((mutations) => {
      if (!recording) return;
      
      // Group mutations by type to reduce the number of events
      const addedNodes = new Set();
      const removedNodes = new Set();
      const attributeChanges = new Map(); // Map<Element, Set<attributeName>>
      const textChanges = new Set();
      
      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE && !ignoredElements.has(node)) {
              addedNodes.add(node);
            }
          });
          
          mutation.removedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE && !ignoredElements.has(node)) {
              removedNodes.add(node);
            }
          });
        } else if (mutation.type === 'attributes') {
          if (!ignoredElements.has(mutation.target) && mutation.target.nodeType === Node.ELEMENT_NODE) {
            if (!attributeChanges.has(mutation.target)) {
              attributeChanges.set(mutation.target, new Set());
            }
            attributeChanges.get(mutation.target).add(mutation.attributeName);
          }
        } else if (mutation.type === 'characterData') {
          if (!ignoredElements.has(mutation.target) && 
              mutation.target.nodeType === Node.TEXT_NODE && 
              mutation.target.parentElement && 
              !ignoredElements.has(mutation.target.parentElement)) {
            textChanges.add(mutation.target.parentElement);
          }
        }
      }
      
      // Record node additions
      if (addedNodes.size > 0) {
        const elementsData = Array.from(addedNodes).map(element => {
          return getElementShortDescription(element);
        });
        
        if (elementsData.length > 0) {
          recordEvent('dom_elements_added', {
            elements: elementsData
          });
        }
      }
      
      // Record node removals
      if (removedNodes.size > 0) {
        const elementsData = Array.from(removedNodes).map(element => {
          return getElementShortDescription(element);
        });
        
        if (elementsData.length > 0) {
          recordEvent('dom_elements_removed', {
            elements: elementsData
          });
        }
      }
      
      // Record attribute changes
      if (attributeChanges.size > 0) {
        const changes = [];
        
        attributeChanges.forEach((attributes, element) => {
          const elementDesc = getElementShortDescription(element);
          
          attributes.forEach(attrName => {
            changes.push({
              element: elementDesc,
              attribute: attrName,
              value: element.getAttribute(attrName)
            });
          });
        });
        
        if (changes.length > 0) {
          recordEvent('dom_attributes_changed', {
            changes: changes
          });
        }
      }
      
      // Record text changes
      if (textChanges.size > 0) {
        const changes = [];
        
        textChanges.forEach(element => {
          const elementDesc = getElementShortDescription(element);
          
          changes.push({
            element: elementDesc,
            text: element.textContent.substring(0, 100) + (element.textContent.length > 100 ? '...' : '')
          });
        });
        
        if (changes.length > 0) {
          recordEvent('dom_text_changed', {
            changes: changes
          });
        }
      }
    });
    
    observer.observe(document, {
      childList: true,
      attributes: true,
      characterData: true,
      subtree: true,
      attributeOldValue: true,
      characterDataOldValue: true
    });
    
    cleanupFunctions.push(() => {
      observer.disconnect();
    });
  }
  
  /**
   * Set up console listener
   */
  function setupConsoleListener() {
    if (!config.captureConsole) {
      return;
    }
    
    const originals = {
      log: console.log,
      info: console.info,
      warn: console.warn,
      error: console.error,
      debug: console.debug
    };
    
    function wrap(method, level) {
      return function() {
        // Call original method
        const result = originals[method].apply(this, arguments);
        
        // Record the console event
        if (recording) {
          const args = Array.from(arguments).map(arg => {
            if (typeof arg === 'string') {
              return arg;
            } else {
              try {
                return JSON.stringify(arg);
              } catch (e) {
                return String(arg);
              }
            }
          });
          
          recordEvent('console', {
            level,
            args
          });
        }
        
        return result;
      };
    }
    
    console.log = wrap('log', 'log');
    console.info = wrap('info', 'info');
    console.warn = wrap('warn', 'warn');
    console.error = wrap('error', 'error');
    console.debug = wrap('debug', 'debug');
    
    cleanupFunctions.push(() => {
      console.log = originals.log;
      console.info = originals.info;
      console.warn = originals.warn;
      console.error = originals.error;
      console.debug = originals.debug;
    });
  }
  
  /**
   * Set up network listener
   */
  function setupNetworkListener() {
    if (!config.captureNetwork) {
      return;
    }
    
    // Intercept fetch requests
    const originalFetch = window.fetch;
    window.fetch = async function() {
      const url = arguments[0] instanceof Request ? arguments[0].url : String(arguments[0]);
      const method = arguments[0] instanceof Request ? arguments[0].method : (arguments[1]?.method || 'GET');
      const startTime = Date.now();
      
      if (recording) {
        recordEvent('network_request_started', {
          url,
          method,
          type: 'fetch'
        });
      }
      
      try {
        const response = await originalFetch.apply(this, arguments);
        
        if (recording) {
          recordEvent('network_request_completed', {
            url,
            method,
            type: 'fetch',
            status: response.status,
            statusText: response.statusText,
            duration: Date.now() - startTime
          });
        }
        
        return response;
      } catch (error) {
        if (recording) {
          recordEvent('network_request_failed', {
            url,
            method,
            type: 'fetch',
            error: error.message,
            duration: Date.now() - startTime
          });
        }
        
        throw error;
      }
    };
    
    cleanupFunctions.push(() => {
      window.fetch = originalFetch;
    });
    
    // Intercept XMLHttpRequest
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;
    
    XMLHttpRequest.prototype.open = function() {
      this._csTestForgeURL = arguments[1];
      this._csTestForgeMethod = arguments[0];
      return originalXHROpen.apply(this, arguments);
    };

    XMLHttpRequest.prototype.send = function() {
      if (recording) {
        const startTime = Date.now();
        const url = this._csTestForgeURL;
        const method = this._csTestForgeMethod;
        
        recordEvent('network_request_started', {
          url,
          method,
          type: 'xhr'
        });
        
        const onLoadEnd = () => {
          if (recording) {
            if (this.readyState === 4) {
              if (this.status >= 200 && this.status < 400) {
                recordEvent('network_request_completed', {
                  url,
                  method,
                  type: 'xhr',
                  status: this.status,
                  statusText: this.statusText,
                  duration: Date.now() - startTime
                });
              } else {
                recordEvent('network_request_failed', {
                  url,
                  method,
                  type: 'xhr',
                  status: this.status,
                  statusText: this.statusText,
                  error: `HTTP Error ${this.status}`,
                  duration: Date.now() - startTime
                });
              }
            }
          }
          
          this.removeEventListener('loadend', onLoadEnd);
        };
        
        this.addEventListener('loadend', onLoadEnd);
      }
      
      return originalXHRSend.apply(this, arguments);
    };
    
    cleanupFunctions.push(() => {
      XMLHttpRequest.prototype.open = originalXHROpen;
      XMLHttpRequest.prototype.send = originalXHRSend;
    });
    
    // Monitor navigation timing for performance
    if (window.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes('navigation')) {
      const navigationObserver = new PerformanceObserver((list) => {
        if (!recording) return;
        
        const entries = list.getEntries();
        for (const entry of entries) {
          recordEvent('navigation_timing', {
            type: entry.type,
            redirectCount: entry.redirectCount,
            redirectTime: entry.redirectEnd - entry.redirectStart,
            domainLookupTime: entry.domainLookupEnd - entry.domainLookupStart,
            connectTime: entry.connectEnd - entry.connectStart,
            requestTime: entry.responseEnd - entry.requestStart,
            responseTime: entry.responseEnd - entry.responseStart,
            domContentLoadedTime: entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart,
            loadTime: entry.loadEventEnd - entry.loadEventStart,
            duration: entry.duration
          });
        }
      });
      
      try {
        navigationObserver.observe({ type: 'navigation', buffered: true });
        
        cleanupFunctions.push(() => {
          navigationObserver.disconnect();
        });
      } catch (e) {
        console.error('Failed to observe navigation timing:', e);
      }
    }
    
    // Listen for resource timing entries
    if (window.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes('resource')) {
      const resourceObserver = new PerformanceObserver((list) => {
        if (!recording) return;
        
        const entries = list.getEntries();
        
        for (const entry of entries) {
          // Skip CSTestForge's own requests
          if (entry.name.includes('cs-testforge')) {
            continue;
          }
          
          recordEvent('network_resource', {
            url: entry.name,
            initiatorType: entry.initiatorType,
            duration: entry.duration,
            transferSize: entry.transferSize,
            encodedBodySize: entry.encodedBodySize,
            decodedBodySize: entry.decodedBodySize
          });
        }
      });
      
      try {
        resourceObserver.observe({ entryTypes: ['resource'] });
        
        cleanupFunctions.push(() => {
          resourceObserver.disconnect();
        });
      } catch (e) {
        console.error('Failed to observe resource timing:', e);
      }
    }
  }
  
  /**
   * Record mouse events
   * @param {MouseEvent} event - Mouse event
   */
  function recordMouseEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementInfo(target);
    
    recordEvent('mouse', {
      type: event.type,
      button: event.button,
      buttons: event.buttons,
      clientX: event.clientX,
      clientY: event.clientY,
      screenX: event.screenX,
      screenY: event.screenY,
      altKey: event.altKey,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      target: elementInfo
    });
    
    // For click events, check if we need to record special interactions
    if (event.type === 'click') {
      recordSpecialInteractions(event);
    }
  }
  
  /**
   * Record mouse move events (debounced)
   * @param {MouseEvent} event - Mouse event
   */
  function recordMouseMove(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const now = Date.now();
    
    // Debounce mouse move events
    if (now - lastMouseMoveTime < mouseMoveDebouncePeriod) {
      if (mouseMoveTimeout) {
        clearTimeout(mouseMoveTimeout);
      }
      
      mouseMoveTimeout = setTimeout(() => {
        lastMouseMoveTime = Date.now();
        recordMouseMoveEvent(event);
        mouseMoveTimeout = null;
      }, mouseMoveDebouncePeriod);
      
      return;
    }
    
    lastMouseMoveTime = now;
    recordMouseMoveEvent(event);
  }
  
  /**
   * Handle mouse move event recording
   * @param {MouseEvent} event - Mouse event
   */
  function recordMouseMoveEvent(event) {
    const target = event.target;
    const elementInfo = getElementShortDescription(target);
    
    recordEvent('mouse_move', {
      clientX: event.clientX,
      clientY: event.clientY,
      screenX: event.screenX,
      screenY: event.screenY,
      target: elementInfo
    });
  }
  
  /**
   * Record keyboard events
   * @param {KeyboardEvent} event - Keyboard event
   */
  function recordKeyboardEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    // Don't record keyboard events for password fields
    if (event.target.type === 'password') {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementShortDescription(target);
    
    // Determine if we should record the key value
    let key = event.key;
    let recordValue = true;
    
    // Check if we're in a sensitive field
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
      const type = target.type && target.type.toLowerCase();
      
      if (type === 'password' || 
          type === 'email' || 
          type === 'tel' || 
          target.name?.toLowerCase().includes('card') ||
          target.name?.toLowerCase().includes('credit') ||
          target.name?.toLowerCase().includes('payment') ||
          target.name?.toLowerCase().includes('phone') ||
          target.name?.toLowerCase().includes('address') ||
          target.name?.toLowerCase().includes('ssn') ||
          target.name?.toLowerCase().includes('social') ||
          target.name?.toLowerCase().includes('security') ||
          target.id?.toLowerCase().includes('card') ||
          target.id?.toLowerCase().includes('credit') ||
          target.id?.toLowerCase().includes('payment') ||
          target.id?.toLowerCase().includes('phone') ||
          target.id?.toLowerCase().includes('address') ||
          target.id?.toLowerCase().includes('ssn') ||
          target.id?.toLowerCase().includes('social') ||
          target.id?.toLowerCase().includes('security')) {
        recordValue = false;
        key = '*';
      }
    }
    
    recordEvent('keyboard', {
      type: event.type,
      key: recordValue ? key : '*',
      code: event.code,
      location: event.location,
      repeat: event.repeat,
      altKey: event.altKey,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      target: elementInfo
    });
  }
  
  /**
   * Record form events
   * @param {Event} event - Form event
   */
  function recordFormEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementInfo(target);
    
    // Determine if we should record the value
    let value = target.value;
    let recordValue = true;
    
    // Check if we're in a sensitive field
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
      const type = target.type && target.type.toLowerCase();
      
      if (type === 'password' || 
          type === 'email' || 
          type === 'tel' || 
          target.name?.toLowerCase().includes('card') ||
          target.name?.toLowerCase().includes('credit') ||
          target.name?.toLowerCase().includes('payment') ||
          target.name?.toLowerCase().includes('phone') ||
          target.name?.toLowerCase().includes('address') ||
          target.name?.toLowerCase().includes('ssn') ||
          target.name?.toLowerCase().includes('social') ||
          target.name?.toLowerCase().includes('security') ||
          target.id?.toLowerCase().includes('card') ||
          target.id?.toLowerCase().includes('credit') ||
          target.id?.toLowerCase().includes('payment') ||
          target.id?.toLowerCase().includes('phone') ||
          target.id?.toLowerCase().includes('address') ||
          target.id?.toLowerCase().includes('ssn') ||
          target.id?.toLowerCase().includes('social') ||
          target.id?.toLowerCase().includes('security')) {
        recordValue = false;
        value = '************';
      }
    }
    
    let eventData = {
      type: event.type,
      target: elementInfo
    };
    
    // Add type-specific data
    if (event.type === 'change' || event.type === 'input') {
      if (target.type === 'checkbox' || target.type === 'radio') {
        eventData.checked = target.checked;
      } else if (target.tagName === 'SELECT') {
        const selectedOptions = [];
        for (let i = 0; i < target.options.length; i++) {
          if (target.options[i].selected) {
            selectedOptions.push({
              index: i,
              value: target.options[i].value,
              text: target.options[i].text
            });
          }
        }
        eventData.selectedOptions = selectedOptions;
      } else {
        eventData.value = recordValue ? value : '************';
      }
    } else if (event.type === 'submit') {
      if (target.tagName === 'FORM') {
        const formData = {};
        const elements = target.elements;
        
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          
          if (element.name) {
            if (element.type === 'checkbox' || element.type === 'radio') {
              if (element.checked) {
                formData[element.name] = element.value;
              }
            } else if (element.tagName === 'SELECT') {
              if (element.multiple) {
                formData[element.name] = [];
                for (let j = 0; j < element.options.length; j++) {
                  if (element.options[j].selected) {
                    formData[element.name].push(element.options[j].value);
                  }
                }
              } else {
                formData[element.name] = element.value;
              }
            } else {
              const shouldMaskValue = element.type === 'password' || 
                element.type === 'email' || 
                element.type === 'tel' || 
                element.name?.toLowerCase().includes('card') ||
                element.name?.toLowerCase().includes('credit') ||
                element.name?.toLowerCase().includes('payment') ||
                element.name?.toLowerCase().includes('phone') ||
                element.name?.toLowerCase().includes('address') ||
                element.name?.toLowerCase().includes('ssn') ||
                element.name?.toLowerCase().includes('social') ||
                element.name?.toLowerCase().includes('security') ||
                element.id?.toLowerCase().includes('card') ||
                element.id?.toLowerCase().includes('credit') ||
                element.id?.toLowerCase().includes('payment') ||
                element.id?.toLowerCase().includes('phone') ||
                element.id?.toLowerCase().includes('address') ||
                element.id?.toLowerCase().includes('ssn') ||
                element.id?.toLowerCase().includes('social') ||
                element.id?.toLowerCase().includes('security');
              
              formData[element.name] = shouldMaskValue ? '************' : element.value;
            }
          }
        }
        
        eventData.formData = formData;
      }
    }
    
    recordEvent('form', eventData);
  }
  
  /**
   * Record focus events
   * @param {FocusEvent} event - Focus event
   */
  function recordFocusEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementShortDescription(target);
    
    recordEvent('focus', {
      type: event.type,
      target: elementInfo
    });
  }
  
  /**
   * Record drag events
   * @param {DragEvent} event - Drag event
   */
  function recordDragEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target;
    const elementInfo = getElementShortDescription(target);
    
    recordEvent('drag', {
      type: event.type,
      clientX: event.clientX,
      clientY: event.clientY,
      screenX: event.screenX,
      screenY: event.screenY,
      target: elementInfo
    });
  }
  
  /**
   * Record scroll events
   * @param {Event} event - Scroll event
   */
  function recordScrollEvent(event) {
    if (!recording || !event.target) return;
    
    // Skip if target is an ignored element
    if (shouldIgnoreEvent(event)) {
      return;
    }
    
    const target = event.target === document ? document.documentElement : event.target;
    const elementInfo = getElementShortDescription(target);
    
    // Get scroll position
    const scrollTop = target === document.documentElement ? window.scrollY : target.scrollTop;
    const scrollLeft = target === document.documentElement ? window.scrollX : target.scrollLeft;
    
    recordEvent('scroll', {
      scrollTop,
      scrollLeft,
      target: elementInfo
    });
  }
  
  /**
   * Record page navigation
   */
  function recordNavigation() {
    recordEvent('navigation', {
      url: window.location.href,
      title: document.title,
      referrer: document.referrer,
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      screenWidth: window.screen.width,
      screenHeight: window.screen.height,
      windowWidth: window.innerWidth,
      windowHeight: window.innerHeight
    });
  }
  
  /**
   * Special interactions recording (e.g., clicks on specific types of elements)
   * @param {MouseEvent} event - Click event
   */
  function recordSpecialInteractions(event) {
    const target = event.target;
    
    // Handle links
    if (target.tagName === 'A' || target.closest('a')) {
      const link = target.tagName === 'A' ? target : target.closest('a');
      const href = link.href || '';
      
      recordEvent('link_click', {
        href,
        text: link.textContent.trim().substring(0, 100) + (link.textContent.length > 100 ? '...' : ''),
        target: link.target,
        download: link.download
      });
    }
    
    // Handle buttons
    if (target.tagName === 'BUTTON' || 
        target.type === 'button' || 
        target.type === 'submit' || 
        target.type === 'reset' ||
        target.role === 'button' ||
        target.closest('button')) {
      
      const button = target.tagName === 'BUTTON' || target.type === 'button' || target.type === 'submit' || target.type === 'reset' ? 
                    target : 
                    (target.role === 'button' ? target : target.closest('button'));
      
      recordEvent('button_click', {
        text: button.textContent.trim().substring(0, 100) + (button.textContent.length > 100 ? '...' : ''),
        type: button.type || 'button',
        name: button.name,
        value: button.value
      });
    }
    
    // Handle form controls
    if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA') {
      const isCheckbox = target.type === 'checkbox';
      const isRadio = target.type === 'radio';
      
      if (isCheckbox) {
        recordEvent('checkbox_click', {
          checked: target.checked,
          name: target.name,
          value: target.value
        });
      } else if (isRadio) {
        recordEvent('radio_click', {
          checked: target.checked,
          name: target.name,
          value: target.value
        });
      }
    }
  }
  
  /**
   * Record a generic event
   * @param {string} category - Event category
   * @param {Object} data - Event data
   */
  function recordEvent(category, data) {
    const event = {
      type: 'cstestforge_dom_event',
      category,
      data,
      timestamp: Date.now(),
      url: window.location.href,
      sessionId: sessionId
    };
    
    // Send event to background script
    browserAPI.runtime.sendMessage(event).catch(error => {
      console.error('Failed to send event to background script:', error);
    });
  }
  
  /**
   * Get information about an element
   * @param {Element} element - DOM element
   * @returns {Object} Element information
   */
  function getElementInfo(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return null;
    }
    
    // Check if we already have cached info for this element
    if (elementCache.has(element)) {
      return elementCache.get(element);
    }
    
    try {
      // Calculate element visibility
      const rect = element.getBoundingClientRect();
      const isInViewport = rect.top < window.innerHeight && rect.left < window.innerWidth && rect.bottom > 0 && rect.right > 0;
      
      // Compute computed styles
      const computedStyle = window.getComputedStyle(element);
      const isVisible = !(computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0');
      
      // Get element attributes
      const attributes = {};
      for (let i = 0; i < element.attributes.length; i++) {
        const attr = element.attributes[i];
        attributes[attr.name] = attr.value;
      }
      
      // Generate XPath
      function getXPath(element) {
        if (!element) return '';
        
        if (element.id) {
          return `//*[@id="${element.id}"]`;
        }
        
        if (element === document.body) {
          return '/html/body';
        }
        
        let ix = 0;
        const siblings = element.parentNode.childNodes;
        
        for (let i = 0; i < siblings.length; i++) {
          const sibling = siblings[i];
          
          if (sibling === element) {
            const tagName = element.tagName.toLowerCase();
            const pathIndex = ix + 1;
            const parentPath = getXPath(element.parentNode);
            
            return `${parentPath}/${tagName}[${pathIndex}]`;
          }
          
          if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
            ix++;
          }
        }
      }
      
      // Generate CSS Selector
      function generateCssSelector(element) {
        if (!element) return '';
        if (element.id) return `#${element.id}`;
        
        let selector = element.tagName.toLowerCase();
        
        if (element.className) {
          const classes = element.className.split(' ').filter(c => c && !c.startsWith('ng-') && !c.includes(':'));
          if (classes.length > 0) {
            selector += '.' + classes.join('.');
          }
        }
        
        // Add attribute selectors for specific attributes
        const relevantAttrs = ['name', 'type', 'role', 'data-test', 'data-testid', 'data-test-id', 'data-cy'];
        for (const attr of relevantAttrs) {
          if (element.hasAttribute(attr)) {
            selector += `[${attr}="${element.getAttribute(attr)}"]`;
            break; // Just use one unique attribute
          }
        }
        
        return selector;
      }
      
      // Smart CSS Selector
      function generateSmartSelector(element) {
        if (!element) return '';
        
        // Start with the element's tag
        let selector = element.tagName.toLowerCase();
        
        // Add ID if it exists and isn't auto-generated
        if (element.id && !/^[0-9]/.test(element.id) && !element.id.includes(':')) {
          return `#${element.id}`;
        }
        
        // Add specific attribute selectors
        const preferredAttrs = [
          'data-testid', 'data-test', 'data-test-id', 'data-cy', 'data-automation',
          'name', 'aria-label', 'title', 'for', 'alt'
        ];
        
        for (const attr of preferredAttrs) {
          if (element.hasAttribute(attr)) {
            selector += `[${attr}="${element.getAttribute(attr)}"]`;
            return selector; // These are usually unique enough
          }
        }
        
        // Add classes that don't look auto-generated
        if (element.className) {
          const classes = element.className.split(' ')
            .filter(c => c && !c.includes(':') && !c.startsWith('ng-') && !/^[a-z][0-9]$/.test(c) && c.length > 2);
          
          if (classes.length === 1) {
            selector += `.${classes[0]}`;
          } else if (classes.length > 1) {
            // Just use the first 2 classes to avoid over-specificity
            selector += `.${classes[0]}.${classes[1]}`;
          }
        }
        
        // Make selector more specific by adding parent context
        if (element.parentElement && element.parentElement !== document.body) {
          const parentTag = element.parentElement.tagName.toLowerCase();
          
          // If parent has ID, use that
          if (element.parentElement.id && !/^[0-9]/.test(element.parentElement.id) && !element.parentElement.id.includes(':')) {
            return `#${element.parentElement.id} > ${selector}`;
          }
          
          // Otherwise just use parent tag
          return `${parentTag} > ${selector}`;
        }
        
        return selector;
      }
      
      const elementInfo = {
        tagName: element.tagName,
        id: element.id,
        className: element.className,
        attributes: attributes,
        text: element.textContent.trim().substring(0, 100) + (element.textContent.length > 100 ? '...' : ''),
        value: element.value,
        type: element.type,
        checked: element.checked,
        dimensions: {
          width: rect.width,
          height: rect.height,
          top: rect.top,
          left: rect.left,
          bottom: rect.bottom,
          right: rect.right
        },
        isInViewport: isInViewport,
        isVisible: isVisible,
        xpath: getXPath(element),
        cssSelector: generateCssSelector(element),
        smartSelector: generateSmartSelector(element)
      };
      
      // Cache the element info for future use
      elementCache.set(element, elementInfo);
      
      return elementInfo;
    } catch (e) {
      console.error('Error generating element info:', e);
      
      // Return a minimal element description if there's an error
      return {
        tagName: element.tagName,
        id: element.id,
        className: element.className
      };
    }
  }
  
  /**
   * Get a short description of an element (for events where full info isn't needed)
   * @param {Element} element - DOM element
   * @returns {Object} Short element description
   */
  function getElementShortDescription(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return null;
    }
    
    return {
      tagName: element.tagName,
      id: element.id,
      className: element.className,
      xpath: `${element.tagName.toLowerCase()}${element.id ? `#${element.id}` : ''}`
    };
  }
  
  /**
   * Execute an action on an element
   * @param {Object} action - Action to execute
   * @returns {Object} Action result
   */
  function executeAction(action) {
    try {
      const element = document.querySelector(action.selector);
      if (!element) return { success: false, error: 'Element not found' };
      
      switch (action.type) {
        case 'click':
          element.click();
          break;
        case 'rightClick':
          const rightClickEvent = new MouseEvent('contextmenu', {
            bubbles: true,
            cancelable: true,
            view: window,
            button: 2,
            buttons: 2
          });
          element.dispatchEvent(rightClickEvent);
          break;
        case 'doubleClick':
          const dblClickEvent = new MouseEvent('dblclick', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          element.dispatchEvent(dblClickEvent);
          break;
        case 'type':
          element.value = action.text || '';
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
          break;
        case 'clear':
          element.value = '';
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));
          break;
        case 'select':
          const options = element.querySelectorAll('option');
          for (let i = 0; i < options.length; i++) {
            const option = options[i];
            if (option.value === action.value || option.text === action.text) {
              option.selected = true;
              element.dispatchEvent(new Event('change', { bubbles: true }));
              break;
            }
          }
          break;
        case 'check':
          if (!element.checked) {
            element.click();
          }
          break;
        case 'uncheck':
          if (element.checked) {
            element.click();
          }
          break;
        case 'focus':
          element.focus();
          break;
        case 'blur':
          element.blur();
          break;
        case 'hover':
          const hoverEvent = new MouseEvent('mouseover', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          element.dispatchEvent(hoverEvent);
          break;
        default:
          return { success: false, error: 'Unsupported action type' };
      }
      
      return { success: true };
    } catch (e) {
      console.error('CSTestForge action error:', e);
      return { success: false, error: e.message };
    }
  }
  
  /**
   * Highlight an element
   * @param {string} selector - CSS selector for the element
   * @param {number} duration - Duration of highlight in ms
   * @returns {boolean} Success status
   */
  function highlightElement(selector, duration) {
    try {
      const element = document.querySelector(selector);
      if (!element) return false;
      
      const originalOutline = element.style.outline;
      const originalOutlineOffset = element.style.outlineOffset;
      const originalTransition = element.style.transition;
      const originalPosition = element.style.position;
      const originalZIndex = element.style.zIndex;
      
      element.style.outline = '2px solid #C54B8C';
      element.style.outlineOffset = '2px';
      element.style.transition = 'outline 0.2s ease-in-out';
      element.style.position = originalPosition === 'static' ? 'relative' : originalPosition;
      element.style.zIndex = '99999';
      
      setTimeout(() => {
        element.style.outline = originalOutline;
        element.style.outlineOffset = originalOutlineOffset;
        element.style.transition = originalTransition;
        element.style.position = originalPosition;
        element.style.zIndex = originalZIndex;
      }, duration || 1000);
      
      return true;
    } catch (e) {
      console.error('CSTestForge highlight error:', e);
      return false;
    }
  }
  
  /**
   * Check if an event should be ignored
   * @param {Event} event - DOM event
   * @returns {boolean} Whether to ignore the event
   */
  function shouldIgnoreEvent(event) {
    // Skip if target is an ignored element
    if (event.target && ignoredElements.has(event.target)) {
      return true;
    }
    
    // Skip events from CSTestForge itself
    if (event.target && (
      event.target.id?.includes('cstestforge') || 
      event.target.className?.includes('cstestforge') ||
      event.target.tagName === 'CS-TESTFORGE-HIGHLIGHT')) {
      return true;
    }
    
    // Check for parent elements that should be ignored
    let parent = event.target?.parentElement;
    while (parent) {
      if (ignoredElements.has(parent) || 
          parent.id?.includes('cstestforge') || 
          parent.className?.includes('cstestforge') ||
          parent.tagName === 'CS-TESTFORGE-HIGHLIGHT') {
        return true;
      }
      parent = parent.parentElement;
    }
    
    return false;
  }
})();


recorder/safari/safari-injector.js
-------------------------------------------

/**
 * CSTestForge Safari Browser Injection Script
 * 
 * This script is responsible for injecting recording capabilities into Safari browsers.
 * It handles Safari-specific implementation details and quirks.
 */

(function() {
  // Safari version detection
  const userAgent = navigator.userAgent;
  const safariRegex = /Version\/([0-9]+)\.([0-9]+)(?:\.([0-9]+))?.*Safari/;
  const match = userAgent.match(safariRegex);
  const safariVersion = match ? {
    major: parseInt(match[1], 10),
    minor: parseInt(match[2], 10),
    patch: match[3] ? parseInt(match[3], 10) : 0
  } : { major: 0, minor: 0, patch: 0 };
  
  // iOS Safari detection
  const isIOS = /iPhone|iPad|iPod/.test(userAgent);
  
  // Configuration for browser-specific quirks
  const config = {
    // Safari-specific feature detection
    features: {
      supportsShadowDOM: safariVersion.major >= 10,
      supportsCustomElements: safariVersion.major >= 10 && safariVersion.minor >= 1,
      supportsClassList: true, // Supported in all modern Safari versions
      supportsPassiveListeners: safariVersion.major >= 10,
      supportsPromises: safariVersion.major >= 10,
      supportsIntersectionObserver: safariVersion.major >= 12 && safariVersion.minor >= 1,
      supportsMutationObserver: safariVersion.major >= 7,
      supportsPerformanceAPI: safariVersion.major >= 11,
      supportsAsyncAwait: safariVersion.major >= 11,
      requiresWebkitPrefixes: safariVersion.major < 14,
      isIOS: isIOS,
      hasBrokenEventHandling: isIOS && safariVersion.major < 13,
      hasBrokenPositionFixed: isIOS && safariVersion.major < 12
    },
    
    // Extension support
    extension: {
      isInstalled: typeof safari !== 'undefined' && typeof safari.extension !== 'undefined',
      api: typeof safari !== 'undefined' ? safari.extension : null
    }
  };
  
  /**
   * Injects a script into the page
   * @param {Object} options - Injection options
   * @param {Function} callback - Function to call when complete
   */
  function injectScript(options, callback) {
    const scriptElement = document.createElement('script');
    
    if (options.url) {
      scriptElement.src = options.url;
      
      if (callback) {
        scriptElement.onload = () => callback(null, true);
        scriptElement.onerror = (error) => callback(error, false);
      }
    } else if (options.code) {
      scriptElement.textContent = options.code;
      
      // For direct code injection, we can assume it executes synchronously
      if (callback) {
        setTimeout(() => callback(null, true), 0);
      }
    }
    
    // Make sure script is removed after execution
    scriptElement.setAttribute('data-cstestforge', 'true');
    
    // Append to document
    (document.head || document.documentElement).appendChild(scriptElement);
    
    // Clean up if needed
    if (options.removeAfterExecution && !options.url) {
      scriptElement.parentNode.removeChild(scriptElement);
    }
  }
  
  /**
   * Creates a unique container ID for injected elements
   * @returns {string} Unique ID
   */
  function createContainerId() {
    return 'cs-testforge-container-' + Math.random().toString(36).substring(2, 15);
  }
  
  /**
   * Creates and injects an isolated container for UI elements
   * @param {Function} callback - Called with the container ID
   */
  function createIsolatedContainer(callback) {
    const containerId = createContainerId();
    
    // Create a detached div
    const container = document.createElement('div');
    container.id = containerId;
    container.style.position = config.features.hasBrokenPositionFixed ? 'absolute' : 'fixed';
    container.style.top = '0';
    container.style.left = '0';
    container.style.width = '0';
    container.style.height = '0';
    container.style.overflow = 'hidden';
    container.style.zIndex = '2147483647'; // Max zIndex
    container.setAttribute('data-cstestforge', 'true');
    
    // If Shadow DOM is supported, use it for better isolation
    if (config.features.supportsShadowDOM) {
      try {
        const shadowRoot = container.attachShadow({ mode: 'closed' });
        
        // Create a style element for shadow DOM
        const style = document.createElement('style');
        style.textContent = `
          :host {
            all: initial;
            contain: content;
          }
          * {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            box-sizing: border-box;
          }
        `;
        
        shadowRoot.appendChild(style);
        
        // Create inner container that will hold the actual content
        const innerContainer = document.createElement('div');
        innerContainer.id = containerId + '-inner';
        shadowRoot.appendChild(innerContainer);
        
        document.body.appendChild(container);
        callback(containerId, innerContainer, shadowRoot);
      } catch (e) {
        console.error('Failed to create shadow root, falling back to iframe', e);
        createIsolatedIframeContainer(containerId, container, callback);
      }
    } else {
      // Fallback if Shadow DOM not supported
      createIsolatedIframeContainer(containerId, container, callback);
    }
  }
  
  /**
   * Creates an isolated container using an iframe (fallback)
   * @param {string} containerId - Container ID
   * @param {Element} container - Container element
   * @param {Function} callback - Callback function
   */
  function createIsolatedIframeContainer(containerId, container, callback) {
    const iframe = document.createElement('iframe');
    iframe.style.border = 'none';
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.style.background = 'transparent';
    
    container.appendChild(iframe);
    document.body.appendChild(container);
    
    // Wait for iframe to load
    iframe.onload = () => {
      const innerDoc = iframe.contentDocument || iframe.contentWindow.document;
      
      // Create styles in iframe
      const style = innerDoc.createElement('style');
      style.textContent = `
        body {
          margin: 0;
          padding: 0;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
          overflow: hidden;
        }
        * {
          box-sizing: border-box;
        }
      `;
      
      innerDoc.head.appendChild(style);
      
      // Create inner container
      const innerContainer = innerDoc.createElement('div');
      innerContainer.id = containerId + '-inner';
      innerDoc.body.appendChild(innerContainer);
      
      callback(containerId, innerContainer, null);
    };
    
    // Fallback in case iframe doesn't trigger onload
    setTimeout(() => {
      if (!iframe.contentDocument && !iframe.contentWindow) {
        callback(containerId, container, null);
      }
    }, 1000);
  }
  
  /**
   * Sets up a communication channel between the injected script and the extension
   * @param {Object} options - Options for the channel
   * @returns {Object} Communication methods
   */
  function setupCommunication(options) {
    const channelId = options.channelId || 'cs-testforge-channel-' + Math.random().toString(36).substring(2, 15);
    
    // Function to get the Safari extension API
    function getSafariExtension() {
      if (typeof safari !== 'undefined' && safari.extension) {
        return safari.extension;
      }
      return null;
    }
    
    const communicationMethods = {
      // Send message to extension
      sendToExtension: function(message) {
        // Check if Safari extension is available
        const extension = getSafariExtension();
        if (extension && extension.dispatchMessage) {
          try {
            message.channelId = channelId;
            extension.dispatchMessage('cs-testforge-to-extension', message);
            return true;
          } catch (e) {
            console.error('Failed to send message to extension:', e);
            
            // Fallback to window events
            window.postMessage({
              type: 'cs-testforge-to-extension',
              channelId: channelId,
              message: message
            }, '*');
            return false;
          }
        } else {
          // If direct extension communication is not available, fallback to window events
          window.postMessage({
            type: 'cs-testforge-to-extension',
            channelId: channelId,
            message: message
          }, '*');
          return false;
        }
      },
      
      // Send message to page script
      sendToPage: function(message) {
        window.postMessage({
          type: 'cs-testforge-to-page',
          channelId: channelId,
          message: message
        }, '*');
      },
      
      // Listen for messages from extension
      listenForExtension: function(callback) {
        const extension = getSafariExtension();
        if (extension && extension.addEventListener) {
          const listener = function(event) {
            if (event.name === 'cs-testforge-to-content') {
              const message = event.message;
              if (message && message.channelId === channelId) {
                callback(message);
              }
            }
          };
          
          extension.addEventListener('message', listener, false);
          
          return {
            remove: () => extension.removeEventListener('message', listener, false)
          };
        } else {
          // Fallback to window event listener
          const windowListener = (event) => {
            if (event.data && 
                event.data.type === 'cs-testforge-to-content' && 
                event.data.channelId === channelId) {
              callback(event.data.message);
            }
          };
          
          window.addEventListener('message', windowListener);
          
          return {
            remove: () => window.removeEventListener('message', windowListener)
          };
        }
      },
      
      // Listen for messages from page script
      listenForPage: function(callback) {
        const listener = (event) => {
          if (event.data && 
              event.data.type === 'cs-testforge-to-content' && 
              event.data.channelId === channelId) {
            callback(event.data.message);
          }
        };
        
        window.addEventListener('message', listener);
        
        return {
          remove: () => window.removeEventListener('message', listener)
        };
      }
    };
    
    return communicationMethods;
  }
  
  /**
   * Apply Safari-specific patches for compatibility
   */
  function applySafariPatches() {
    // Add passive event listener support for older Safari
    if (!config.features.supportsPassiveListeners) {
      try {
        const originalAddEventListener = EventTarget.prototype.addEventListener;
        EventTarget.prototype.addEventListener = function(type, listener, options) {
          if (options && typeof options !== 'boolean' && options.passive !== undefined) {
            // Just ignore the passive option for older Safari
            if (typeof options === 'object') {
              const newOptions = {};
              for (const key in options) {
                if (key !== 'passive') {
                  newOptions[key] = options[key];
                }
              }
              return originalAddEventListener.call(this, type, listener, newOptions);
            } else {
              return originalAddEventListener.call(this, type, listener, false);
            }
          } else {
            return originalAddEventListener.call(this, type, listener, options);
          }
        };
      } catch (e) {
        console.error('Failed to patch addEventListener for passive listeners', e);
      }
    }
    
    // Fix for broken touch events on iOS Safari
    if (config.features.hasBrokenEventHandling) {
      try {
        const originalDispatchEvent = EventTarget.prototype.dispatchEvent;
        EventTarget.prototype.dispatchEvent = function(event) {
          if (event.type === 'touchstart' || event.type === 'touchmove' || event.type === 'touchend') {
            // iOS Safari sometimes fails to deliver these events
            // Create a small delay to help ensure delivery
            setTimeout(() => {
              return originalDispatchEvent.call(this, event);
            }, 0);
            return true;
          } else {
            return originalDispatchEvent.call(this, event);
          }
        };
      } catch (e) {
        console.error('Failed to patch dispatchEvent for touch events', e);
      }
    }
    
    // Polyfill for CustomEvent if needed
    if (typeof window.CustomEvent !== 'function') {
      window.CustomEvent = function(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        const evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      };
      CustomEvent.prototype = window.Event.prototype;
    }
    
    // Add webkit prefix for CSS where needed
    if (config.features.requiresWebkitPrefixes) {
      const originalSetProperty = CSSStyleDeclaration.prototype.setProperty;
      const prefixedProperties = [
        'animation', 'animation-delay', 'animation-direction', 'animation-duration',
        'animation-fill-mode', 'animation-iteration-count', 'animation-name',
        'animation-play-state', 'animation-timing-function', 'backdrop-filter',
        'backface-visibility', 'background-clip', 'background-origin',
        'border-radius', 'box-shadow', 'column-count', 'column-gap',
        'column-rule', 'column-width', 'filter', 'flex', 'flex-basis',
        'flex-direction', 'flex-flow', 'flex-grow', 'flex-shrink',
        'flex-wrap', 'justify-content', 'perspective', 'transform',
        'transform-origin', 'transform-style', 'transition',
        'transition-delay', 'transition-duration', 'transition-property',
        'transition-timing-function', 'user-select'
      ];
      
      CSSStyleDeclaration.prototype.setProperty = function(propertyName, value, priority) {
        // Call original method
        originalSetProperty.call(this, propertyName, value, priority);
        
        // Add prefixed version if needed
        if (prefixedProperties.includes(propertyName)) {
          originalSetProperty.call(this, '-webkit-' + propertyName, value, priority);
        }
      };
    }
  }
  
  /**
   * Main entry point - injects the CSTestForge recorder into the page
   * @param {Object} options - Injection options
   * @param {Function} callback - Called when injection is complete
   */
  function inject(options, callback) {
    // Apply Safari-specific patches
    applySafariPatches();
    
    // Create event capture code
    const captureCode = `
      (function() {
        // Initialize CSTestForge capture
        if (window._csTestForgeInitialized) {
          return;
        }
        
        window._csTestForgeInitialized = true;
        
        // Setup messaging
        const channelId = '${options.channelId || 'cs-testforge-channel-' + Math.random().toString(36).substring(2, 15)}';
        
        // Send message to content script
        function sendToContentScript(message) {
          window.postMessage({
            type: 'cs-testforge-to-content',
            channelId: channelId,
            message: message
          }, '*');
        }
        
        // Listen for messages from content script
        window.addEventListener('message', function(event) {
          if (event.data && 
              event.data.type === 'cs-testforge-to-page' && 
              event.data.channelId === channelId) {
            
            // Handle incoming commands
            const message = event.data.message;
            
            if (message.command === 'start_recording') {
              startRecording(message.config);
            } else if (message.command === 'stop_recording') {
              stopRecording();
            } else if (message.command === 'get_element_info') {
              getElementInfo(message.selector, message.requestId);
            }
          }
        });
        
        // Capture DOM events
        let recording = false;
        let eventListeners = [];
        let config = {
          captureClicks: true,
          captureInputs: true,
          captureKeyboard: true
        };
        
        function startRecording(newConfig) {
          if (recording) {
            stopRecording();
          }
          
          recording = true;
          
          if (newConfig) {
            config = Object.assign(config, newConfig);
          }
          
          setupEventCapture();
          
          sendToContentScript({
            type: 'recording_started',
            timestamp: Date.now()
          });
        }
        
        function stopRecording() {
          if (!recording) {
            return;
          }
          
          recording = false;
          
          // Remove all event listeners
          for (let i = 0; i < eventListeners.length; i++) {
            const listener = eventListeners[i];
            listener.element.removeEventListener(listener.type, listener.handler, listener.options);
          }
          
          eventListeners = [];
          
          sendToContentScript({
            type: 'recording_stopped',
            timestamp: Date.now()
          });
        }
        
        function setupEventCapture() {
          // Capture clicks
          if (config.captureClicks) {
            addGlobalEventListener(document, 'click', handleClick, { capture: true });
            addGlobalEventListener(document, 'contextmenu', handleContextMenu, { capture: true });
            addGlobalEventListener(document, 'dblclick', handleDblClick, { capture: true });
          }
          
          // Capture form interactions
          if (config.captureInputs) {
            addGlobalEventListener(document, 'change', handleChange, { capture: true });
            addGlobalEventListener(document, 'input', handleInput, { capture: true });
            addGlobalEventListener(document, 'focus', handleFocus, { capture: true });
            addGlobalEventListener(document, 'blur', handleBlur, { capture: true });
            addGlobalEventListener(document, 'submit', handleSubmit, { capture: true });
          }
          
          // Capture keyboard
          if (config.captureKeyboard) {
            addGlobalEventListener(document, 'keydown', handleKeyDown, { capture: true });
            addGlobalEventListener(document, 'keyup', handleKeyUp, { capture: true });
          }
          
          // Capture touch events for mobile Safari
          if (${config.features.isIOS}) {
            addGlobalEventListener(document, 'touchstart', handleTouch, { capture: true });
            addGlobalEventListener(document, 'touchend', handleTouch, { capture: true });
            addGlobalEventListener(document, 'touchmove', handleTouch, { capture: true });
          }
          
          // Capture scroll events (debounced)
          let scrollTimeout = null;
          addGlobalEventListener(window, 'scroll', function(event) {
            if (scrollTimeout) {
              clearTimeout(scrollTimeout);
            }
            
            scrollTimeout = setTimeout(function() {
              handleScroll(event);
              scrollTimeout = null;
            }, 100);
          }, { capture: true });
        }
        
        function addGlobalEventListener(element, type, handler, options) {
          const wrappedHandler = function(event) {
            if (recording) {
              handler(event);
            }
          };
          
          element.addEventListener(type, wrappedHandler, options);
          
          eventListeners.push({
            element: element,
            type: type,
            handler: wrappedHandler,
            options: options
          });
        }
        
        // Element path generation
        function getElementInfo(selector, requestId) {
          try {
            const element = document.querySelector(selector);
            
            if (!element) {
              sendToContentScript({
                type: 'element_info_response',
                requestId: requestId,
                success: false,
                error: 'Element not found'
              });
              return;
            }
            
            const rect = element.getBoundingClientRect();
            
            // Get all attributes
            const attributes = {};
            for (let i = 0; i < element.attributes.length; i++) {
              attributes[element.attributes[i].name] = element.attributes[i].value;
            }
            
            // Generate xpath
            function getXPath(element) {
              if (element.id) {
                return '//*[@id="' + element.id + '"]';
              }
              
              if (element === document.body) {
                return '/html/body';
              }
              
              if (!element.parentNode) {
                return '';
              }
              
              let ix = 0;
              const siblings = element.parentNode.childNodes;
              
              for (let i = 0; i < siblings.length; i++) {
                const sibling = siblings[i];
                
                if (sibling === element) {
                  return getXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (ix + 1) + ']';
                }
                
                if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                  ix++;
                }
              }
            }
            
            // Generate CSS selector
            function getCssSelector(element) {
              if (element.id) {
                return '#' + element.id;
              }
              
              if (element === document.body) {
                return 'body';
              }
              
              if (element === document.documentElement) {
                return 'html';
              }
              
              let selector = element.tagName.toLowerCase();
              
              if (element.className) {
                const classes = element.className.split(/\\s+/);
                
                for (let i = 0; i < classes.length; i++) {
                  if (classes[i]) {
                    selector += '.' + classes[i];
                  }
                }
              }
              
              // If parent has ID, use that for more specific selector
              if (element.parentNode && element.parentNode.id) {
                return '#' + element.parentNode.id + ' > ' + selector;
              }
              
              return selector;
            }
            
            const info = {
              tagName: element.tagName,
              id: element.id,
              className: element.className,
              attributes: attributes,
              text: element.textContent.trim().substring(0, 100),
              xpath: getXPath(element),
              cssSelector: getCssSelector(element),
              rect: {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height
              }
            };
            
            sendToContentScript({
              type: 'element_info_response',
              requestId: requestId,
              success: true,
              info: info
            });
          } catch (error) {
            sendToContentScript({
              type: 'element_info_response',
              requestId: requestId,
              success: false,
              error: error.message
            });
          }
        }
        
        // Event handlers
        function handleClick(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'click',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: event.clientX,
              clientY: event.clientY
            }
          });
        }
        
        function handleContextMenu(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'contextmenu',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: event.clientX,
              clientY: event.clientY
            }
          });
        }
        
        function handleDblClick(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'dblclick',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: event.clientX,
              clientY: event.clientY
            }
          });
        }
        
        function handleTouch(event) {
          const target = event.target;
          const touch = event.touches && event.touches[0] ? event.touches[0] : 
                       (event.changedTouches && event.changedTouches[0] ? event.changedTouches[0] : null);
          
          if (!touch) return;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: event.type,
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: touch.clientX,
              clientY: touch.clientY,
              identifier: touch.identifier
            }
          });
        }
        
        function handleChange(event) {
          const target = event.target;
          
          // Special handling for different input types
          let value = target.value;
          
          if (target.type === 'checkbox' || target.type === 'radio') {
            value = target.checked;
          } else if (target.type === 'password') {
            // Mask password value
            value = '********';
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'change',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            value: value
          });
        }
        
        function handleInput(event) {
          const target = event.target;
          
          // Skip for password fields
          if (target.type === 'password') {
            return;
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'input',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            value: target.value
          });
        }
        
        function handleFocus(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'focus',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            }
          });
        }
        
        function handleBlur(event) {
          const target = event.target;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'blur',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            }
          });
        }
        
        function handleSubmit(event) {
          const target = event.target;
          
          // Collect form data
          const formData = {};
          
          if (target.tagName === 'FORM') {
            const elements = target.elements;
            
            for (let i = 0; i < elements.length; i++) {
              const element = elements[i];
              
              if (element.name) {
                if (element.type === 'checkbox' || element.type === 'radio') {
                  if (element.checked) {
                    formData[element.name] = element.value;
                  }
                } else if (element.type === 'password') {
                  // Mask password
                  formData[element.name] = '********';
                } else {
                  formData[element.name] = element.value;
                }
              }
            }
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'submit',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              action: target.action,
              method: target.method
            },
            formData: formData
          });
        }
        
        function handleKeyDown(event) {
          const target = event.target;
          
          // Skip if target is a password field
          if (target.type === 'password') {
            return;
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'keydown',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            key: event.key,
            code: event.code,
            keyCode: event.keyCode,
            altKey: event.altKey,
            ctrlKey: event.ctrlKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey
          });
        }
        
        function handleKeyUp(event) {
          const target = event.target;
          
          // Skip if target is a password field
          if (target.type === 'password') {
            return;
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'keyup',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            key: event.key,
            code: event.code,
            keyCode: event.keyCode,
            altKey: event.altKey,
            ctrlKey: event.ctrlKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey
          });
        }
        
        function handleScroll(event) {
          const target = event.target || document.documentElement;
          
          // Get scroll position
          const scrollTop = window.scrollY || document.documentElement.scrollTop;
          const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'scroll',
            timestamp: Date.now(),
            element: {
              tagName: target.tagName || 'window',
              id: target.id,
              className: target.className
            },
            scrollPosition: {
              scrollTop: scrollTop,
              scrollLeft: scrollLeft
            }
          });
        }
        
        // Special Safari-specific handling for viewport changes
        // (Safari handles responsive design differently)
        if (${config.features.isIOS}) {
          // Listen for orientation changes
          window.addEventListener('orientationchange', function() {
            if (!recording) return;
            
            // Small delay to let Safari update dimensions
            setTimeout(function() {
              sendToContentScript({
                type: 'dom_event',
                eventType: 'orientationchange',
                timestamp: Date.now(),
                orientation: window.orientation,
                dimensions: {
                  width: window.innerWidth,
                  height: window.innerHeight,
                  screenWidth: window.screen.width,
                  screenHeight: window.screen.height
                }
              });
            }, 300);
          });
          
          // Listen for viewport resize on iOS Safari (zoom changes)
          let lastWidth = window.innerWidth;
          let lastHeight = window.innerHeight;
          let resizeTimeout;
          
          window.addEventListener('resize', function() {
            if (!recording) return;
            
            clearTimeout(resizeTimeout);
            
            resizeTimeout = setTimeout(function() {
              const newWidth = window.innerWidth;
              const newHeight = window.innerHeight;
              
              // Only report if dimensions actually changed
              if (newWidth !== lastWidth || newHeight !== lastHeight) {
                lastWidth = newWidth;
                lastHeight = newHeight;
                
                sendToContentScript({
                  type: 'dom_event',
                  eventType: 'viewport_change',
                  timestamp: Date.now(),
                  dimensions: {
                    width: newWidth,
                    height: newHeight,
                    screenWidth: window.screen.width,
                    screenHeight: window.screen.height
                  }
                });
              }
            }, 200);
          });
        }
        
        // Notify ready
        sendToContentScript({
          type: 'page_ready',
          url: window.location.href,
          title: document.title,
          timestamp: Date.now()
        });
      })();
    `;
    
    // Inject the capture code
    injectScript({ code: captureCode, removeAfterExecution: true }, (error, success) => {
      if (error) {
        if (callback) {
          callback(error, null);
        }
        return;
      }
      
      // Create communication channel
      const communication = setupCommunication({ channelId: options.channelId });
      
      // Create UI container if needed
      if (options.createUI) {
        createIsolatedContainer((containerId, container, shadowRoot) => {
          const result = {
            communication: communication,
            container: {
              id: containerId,
              element: container,
              shadowRoot: shadowRoot
            }
          };
          
          if (callback) {
            callback(null, result);
          }
        });
      } else {
        const result = {
          communication: communication
        };
        
        if (callback) {
          callback(null, result);
        }
      }
    });
  }
  
  /**
   * Create a properly structured Safari extension Info.plist object
   * @returns {Object} Info.plist structure
   */
  function createInfoPlist() {
    return {
      "CFBundleDisplayName": "CSTestForge Recorder",
      "CFBundleIdentifier": "com.cstestforge.recorder.safari",
      "CFBundleInfoDictionaryVersion": "6.0",
      "CFBundleShortVersionString": "1.0.0",
      "CFBundleVersion": "1",
      "Chrome": {
        "Database Quota": 104857600,
        "Global Page": "background.html",
        "Popovers": [
          {
            "Filename": "popup.html",
            "Height": 500,
            "Identifier": "mainPopover",
            "Width": 350
          }
        ]
      },
      "Content": {
        "Scripts": {
          "Start": ["js/content-script.js"]
        },
        "Stylesheets": ["css/content-style.css"],
        "Whitelist": ["http://*/*", "https://*/*"]
      },
      "Description": "CSTestForge test automation recorder for Safari",
      "DeveloperIdentifier": "CSTestForge",
      "ExtensionInfoDictionaryVersion": "1.0",
      "Permissions": {
        "Website Access": {
          "Include Secure Pages": true,
          "Level": "All"
        }
      },
      "Website": "https://cstestforge.org/"
    };
  }
  
  /**
   * Create Safari extension settings structure
   * @returns {Object} Settings structure
   */
  function createExtensionSettings() {
    return {
      "CSTestForgeSettings": {
        "recordingDefaults": {
          "captureNetwork": true,
          "captureDOMChanges": true,
          "captureConsole": true,
          "recordFrames": true,
          "elementDetectionLevel": "advanced"
        },
        "uiTheme": "system",
        "safariSpecific": {
          "useWebkitPrefixes": safariVersion.major < 14,
          "useCompatibilityMode": isIOS && safariVersion.major < 13,
          "useIframeForContainers": !config.features.supportsShadowDOM
        }
      }
    };
  }
  
  /**
   * Get information about the Safari browser environment
   * @returns {Object} Safari environment information
   */
  function getSafariEnvironmentInfo() {
    return {
      version: safariVersion,
      features: config.features,
      isIOS: config.features.isIOS,
      userAgent: navigator.userAgent,
      hasExtensionAPI: typeof safari !== 'undefined' && !!safari.extension,
      isMobile: /iPhone|iPad|iPod/.test(navigator.userAgent),
      isPrivateMode: isInPrivateMode(),
      // Extensions can't detect private mode reliably in Safari, so we use a heuristic
      canUseLocalStorage: canUseLocalStorage()
    };
  }
  
  /**
   * Check if browser is in private mode (best effort, not reliable in Safari)
   * @returns {boolean} Whether browser appears to be in private mode
   */
  function isInPrivateMode() {
    try {
      localStorage.setItem('cs_testforge_test', '1');
      localStorage.removeItem('cs_testforge_test');
      return false;
    } catch (e) {
      return true;
    }
  }
  
  /**
   * Check if local storage is available
   * @returns {boolean} Whether local storage is available
   */
  function canUseLocalStorage() {
    try {
      localStorage.setItem('cs_testforge_test', '1');
      localStorage.removeItem('cs_testforge_test');
      return true;
    } catch (e) {
      return false;
    }
  }
  
  /**
   * Creates a style element with Safari-specific styles
   * @param {Object} options - Style options
   * @returns {HTMLElement} Style element
   */
  function createSafariStyleElement(options) {
    const styleElement = document.createElement('style');
    
    // Add Safari-specific CSS
    const cssRules = [
      // Fix for position:fixed in iOS Safari
      config.features.hasBrokenPositionFixed ? 
        '.cs-testforge-fixed { position: absolute !important; }' : 
        '.cs-testforge-fixed { position: fixed !important; }',
      
      // Ensure proper z-index on Safari
      '.cs-testforge-overlay { z-index: 2147483647 !important; }',
      
      // Fix for iOS Safari touch handling
      config.features.isIOS ? 
        '.cs-testforge-touchable { -webkit-tap-highlight-color: transparent !important; }' : 
        '',
      
      // Fix for Safari scrolling
      '.cs-testforge-scroll-container { -webkit-overflow-scrolling: touch !important; }'
    ];
    
    styleElement.textContent = cssRules.join('\n');
    return styleElement;
  }
  
  /**
   * Fix for Safari-specific event issues
   * @param {Element} element - Element to fix
   */
  function fixSafariEventIssues(element) {
    if (!config.features.hasBrokenEventHandling) {
      return; // Only needed for older Safari
    }
    
    // Fix click events in iOS Safari
    const fixClick = function(e) {
      e.preventDefault();
      const event = document.createEvent('MouseEvents');
      event.initMouseEvent('click', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
      e.target.dispatchEvent(event);
    };
    
    // Add event handler to all interactive elements
    const interactiveElements = element.querySelectorAll('button, a, input, select, textarea, [role="button"]');
    for (let i = 0; i < interactiveElements.length; i++) {
      const el = interactiveElements[i];
      el.addEventListener('touchend', fixClick, false);
    }
  }
  
  /**
   * Get Safari-specific locator strategies
   * @returns {Object} Locator strategies
   */
  function getSafariLocatorStrategies() {
    return {
      // Safari has issues with certain XPath expressions, so provide alternatives
      xpath: {
        useNamespaceResolver: safariVersion.major < 11,
        useSimplifiedXPathSyntax: config.features.isIOS && safariVersion.major < 13,
        avoidDescendantAxis: safariVersion.major < 10,
        avoidPreciseTextMatching: config.features.isIOS && safariVersion.major < 12
      },
      
      // CSS selector strategies for Safari
      css: {
        avoidComplexSelectors: safariVersion.major < 10,
        useSimpleAttributeSelectors: config.features.isIOS && safariVersion.major < 12,
        useWebkitPseudoElements: safariVersion.major < 14,
        maxSelectorLength: config.features.isIOS ? 1000 : 2000 // Safari has limits on selector length
      }
    };
  }
  
  // Export the API
  window.CSTestForgeSafariInjector = {
    inject: inject,
    injectScript: injectScript,
    createIsolatedContainer: createIsolatedContainer,
    setupCommunication: setupCommunication,
    applySafariPatches: applySafariPatches,
    createInfoPlist: createInfoPlist,
    createExtensionSettings: createExtensionSettings,
    getSafariEnvironmentInfo: getSafariEnvironmentInfo,
    createSafariStyleElement: createSafariStyleElement,
    fixSafariEventIssues: fixSafariEventIssues,
    getSafariLocatorStrategies: getSafariLocatorStrategies,
    getBrowserInfo: function() {
      return {
        version: safariVersion,
        features: config.features,
        isIOS: config.features.isIOS
      };
    }
  };
})();


recorder/safari/Info.plist
--------------------------------------------------

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Author</key>
    <string>CSTestForge</string>
    <key>Builder Version</key>
    <string>17613.2.9.1.8</string>
    <key>CFBundleDisplayName</key>
    <string>CSTestForge Recorder</string>
    <key>CFBundleIdentifier</key>
    <string>com.cstestforge.recorder.safari</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>Chrome</key>
    <dict>
        <key>Database Quota</key>
        <integer>104857600</integer>
        <key>Global Page</key>
        <string>background.html</string>
        <key>Popovers</key>
        <array>
            <dict>
                <key>Filename</key>
                <string>popup.html</string>
                <key>Height</key>
                <integer>500</integer>
                <key>Identifier</key>
                <string>mainPopover</string>
                <key>Width</key>
                <integer>350</integer>
            </dict>
        </array>
    </dict>
    <key>Content</key>
    <dict>
        <key>Scripts</key>
        <dict>
            <key>Start</key>
            <array>
                <string>js/content-script.js</string>
            </array>
        </dict>
        <key>Stylesheets</key>
        <array>
            <string>css/content-style.css</string>
        </array>
        <key>Whitelist</key>
        <array>
            <string>http://*/*</string>
            <string>https://*/*</string>
        </array>
    </dict>
    <key>Description</key>
    <string>CSTestForge test automation recorder for Safari</string>
    <key>DeveloperIdentifier</key>
    <string>CSTestForge</string>
    <key>ExtensionInfoDictionaryVersion</key>
    <string>1.0</string>
    <key>Permissions</key>
    <dict>
        <key>Website Access</key>
        <dict>
            <key>Include Secure Pages</key>
            <true/>
            <key>Level</key>
            <string>All</string>
        </dict>
    </dict>
    <key>Website</key>
    <string>https://cstestforge.org/</string>
</dict>
</plist>


recorder/ie/ie-injector.js
------------------------------------------

/**
 * CSTestForge Internet Explorer Browser Injection Script
 * 
 * This script is responsible for injecting recording capabilities into Internet Explorer.
 * It provides comprehensive compatibility with IE11 and handles all IE-specific quirks.
 */

(function() {
  // IE version detection
  const userAgent = navigator.userAgent;
  const ieRegex = /MSIE\s?(\d+)(?:\.(\d+))?/i;
  const tridentRegex = /Trident\/(\d+)(?:\.(\d+))?/i;
  
  let ieVersion = {
    major: 0,
    minor: 0,
    isIE: false,
    isIE11: false,
    isIEEdge: false
  };
  
  // Check for old IE versions (MSIE token)
  const msieMatch = userAgent.match(ieRegex);
  if (msieMatch) {
    ieVersion.major = parseInt(msieMatch[1], 10);
    ieVersion.minor = msieMatch[2] ? parseInt(msieMatch[2], 10) : 0;
    ieVersion.isIE = true;
  } else {
    // Check for IE11 (Trident token, no MSIE token)
    const tridentMatch = userAgent.match(tridentRegex);
    if (tridentMatch) {
      ieVersion.major = 11; // IE11
      ieVersion.minor = 0;
      ieVersion.isIE = true;
      ieVersion.isIE11 = true;
    } else if (userAgent.indexOf('Edge/') > -1) {
      ieVersion.isIEEdge = true;
    }
  }
  
  // Configuration for browser-specific quirks
  const config = {
    // IE-specific feature detection
    features: {
      supportsPromises: ieVersion.major >= 11,
      supportsCustomElements: false, // Not supported in IE
      supportsClassList: ieVersion.major >= 10,
      supportsShadowDOM: false, // Not supported in IE
      supportsES6: false, // Not supported in IE
      supportsPassiveListeners: false, // Not supported in IE
      supportsHTMLImports: false, // Not supported in IE
      supportsFlexbox: ieVersion.major >= 11,
      supportsQuerySelector: ieVersion.major >= 9,
      supportsLocalStorage: true, // Supported in IE8+
      hasBrokenJSON: ieVersion.major < 9,
      hasBrokenBoxModel: ieVersion.major < 9,
      hasBrokenCache: true, // IE has caching issues
      hasEventListenerIssues: ieVersion.major < 11,
      hasComputedStyleIssues: ieVersion.major < 9,
      hasConsoleLogIssues: ieVersion.major < 10,
      hasBrokenXHR: ieVersion.major < 10
    },
    
    // Extension support
    extension: {
      isInstalled: false, // No extension API in IE
      api: null
    }
  };
  
  /**
   * Adds IE compatibility polyfills
   */
  function addIEPolyfills() {
    // Polyfill for console (IE8 and IE9 in certain modes don't have console)
    if (!window.console) {
      window.console = {};
    }
    
    const consoleMethods = ['log', 'info', 'warn', 'error', 'debug', 'trace', 'dir', 'group',
                            'groupCollapsed', 'groupEnd', 'time', 'timeEnd', 'profile', 'profileEnd',
                            'dirxml', 'assert', 'count', 'markTimeline', 'timeStamp', 'clear'];
    
    for (let i = 0; i < consoleMethods.length; i++) {
      const method = consoleMethods[i];
      if (!window.console[method]) {
        window.console[method] = function() {};
      }
    }
    
    // Polyfill for Array.prototype.forEach
    if (!Array.prototype.forEach) {
      Array.prototype.forEach = function(callback, thisArg) {
        if (typeof callback !== 'function') {
          throw new TypeError(callback + ' is not a function');
        }
        
        var thisValue = thisArg || window;
        for (var i = 0; i < this.length; i++) {
          callback.call(thisValue, this[i], i, this);
        }
      };
    }
    
    // Polyfill for Array.prototype.map
    if (!Array.prototype.map) {
      Array.prototype.map = function(callback, thisArg) {
        if (typeof callback !== 'function') {
          throw new TypeError(callback + ' is not a function');
        }
        
        var thisValue = thisArg || window;
        var result = [];
        for (var i = 0; i < this.length; i++) {
          result.push(callback.call(thisValue, this[i], i, this));
        }
        return result;
      };
    }
    
    // Polyfill for Array.prototype.filter
    if (!Array.prototype.filter) {
      Array.prototype.filter = function(callback, thisArg) {
        if (typeof callback !== 'function') {
          throw new TypeError(callback + ' is not a function');
        }
        
        var thisValue = thisArg || window;
        var result = [];
        for (var i = 0; i < this.length; i++) {
          if (callback.call(thisValue, this[i], i, this)) {
            result.push(this[i]);
          }
        }
        return result;
      };
    }
    
    // Polyfill for Array.isArray
    if (!Array.isArray) {
      Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
      };
    }
    
    // Polyfill for Function.prototype.bind
    if (!Function.prototype.bind) {
      Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
          throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        
        var aArgs = Array.prototype.slice.call(arguments, 1);
        var fToBind = this;
        var FNOP = function() {};
        var fBound = function() {
          return fToBind.apply(this instanceof FNOP ? this : oThis,
                   aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        
        if (this.prototype) {
          FNOP.prototype = this.prototype;
        }
        fBound.prototype = new FNOP();
        
        return fBound;
      };
    }
    
    // Polyfill for String.prototype.trim
    if (!String.prototype.trim) {
      String.prototype.trim = function() {
        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
      };
    }
    
    // Polyfill for Object.keys
    if (!Object.keys) {
      Object.keys = (function() {
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString');
        var dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ];
        var dontEnumsLength = dontEnums.length;
        
        return function(obj) {
          if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
            throw new TypeError('Object.keys called on non-object');
          }
          
          var result = [];
          for (var prop in obj) {
            if (hasOwnProperty.call(obj, prop)) {
              result.push(prop);
            }
          }
          
          if (hasDontEnumBug) {
            for (var i = 0; i < dontEnumsLength; i++) {
              if (hasOwnProperty.call(obj, dontEnums[i])) {
                result.push(dontEnums[i]);
              }
            }
          }
          return result;
        };
      }());
    }
    
    // Polyfill for CustomEvent
    if (typeof window.CustomEvent !== 'function') {
      window.CustomEvent = function(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      };
      window.CustomEvent.prototype = window.Event.prototype;
    }
    
    // Polyfill for Element.classList
    if (!("classList" in document.createElement("_")) && ieVersion.major < 10) {
      (function() {
        var prototype = Array.prototype,
            indexOf = prototype.indexOf,
            slice = prototype.slice,
            push = prototype.push,
            splice = prototype.splice,
            join = prototype.join;
        
        function DOMTokenList(el) {
          this._element = el;
          var classes = el.className.trim().split(/\s+/);
          for (var i = 0; i < classes.length; i++) {
            push.call(this, classes[i]);
          }
        }
        
        DOMTokenList.prototype = {
          add: function(token) {
            if (this.contains(token)) return;
            push.call(this, token);
            this._element.className = slice.call(this, 0).join(" ");
          },
          
          contains: function(token) {
            return indexOf.call(this, token) !== -1;
          },
          
          item: function(index) {
            return this[index] || null;
          },
          
          remove: function(token) {
            var i = indexOf.call(this, token);
            if (i === -1) return;
            splice.call(this, i, 1);
            this._element.className = slice.call(this, 0).join(" ");
          },
          
          toString: function() {
            return slice.call(this, 0).join(" ");
          },
          
          toggle: function(token) {
            if (this.contains(token)) {
              this.remove(token);
              return false;
            } else {
              this.add(token);
              return true;
            }
          }
        };
        
        Object.defineProperty(Element.prototype, "classList", {
          get: function() {
            return new DOMTokenList(this);
          },
          enumerable: true
        });
      })();
    }
    
    // Polyfill for Element.matches
    if (!Element.prototype.matches) {
      Element.prototype.matches =
          Element.prototype.matchesSelector ||
          Element.prototype.mozMatchesSelector ||
          Element.prototype.msMatchesSelector ||
          Element.prototype.oMatchesSelector ||
          Element.prototype.webkitMatchesSelector ||
          function(s) {
            var matches = (document || this.ownerDocument).querySelectorAll(s),
                i = matches.length;
            while (--i >= 0 && matches.item(i) !== this) {}
            return i > -1;
          };
    }
    
    // Polyfill for Element.closest
    if (!Element.prototype.closest) {
      Element.prototype.closest = function(s) {
        var el = this;
        do {
          if (el.matches(s)) return el;
          el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
      };
    }
    
    // Polyfill for JSON
    if (config.features.hasBrokenJSON && !window.JSON) {
      window.JSON = {
        parse: function(sJSON) {
          return eval('(' + sJSON + ')');
        },
        stringify: function(obj) {
          var t = typeof obj;
          if (t !== "object" || obj === null) {
            if (t === "string") obj = '"' + obj + '"';
            return String(obj);
          } else {
            var n, v, json = [], arr = (obj && obj.constructor === Array);
            for (n in obj) {
              v = obj[n];
              t = typeof v;
              if (t === "string") v = '"' + v + '"';
              else if (t === "object" && v !== null) v = JSON.stringify(v);
              json.push((arr ? "" : '"' + n + '":') + String(v));
            }
            return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}");
          }
        }
      };
    }
    
    // Polyfill for Date.now
    if (!Date.now) {
      Date.now = function() {
        return new Date().getTime();
      };
    }
  }
  
  /**
   * Fixes IE-specific event handling issues
   */
  function fixIEEventIssues() {
    if (config.features.hasEventListenerIssues) {
      // Fix for IE's event capturing/bubbling
      const originalAddEventListener = Element.prototype.addEventListener;
      const originalRemoveEventListener = Element.prototype.removeEventListener;
      
      // Map to track event handlers for cleanup
      const eventHandlers = new Map();
      
      Element.prototype.addEventListener = function(type, listener, useCapture) {
        // Handle deprecated useCapture parameter (boolean vs options object)
        const options = typeof useCapture === 'object' ? useCapture : { capture: !!useCapture };
        
        // Create wrapper function to handle event properly
        const wrappedListener = function(event) {
          // Ensure event has proper target (IE uses srcElement)
          if (!event.target && event.srcElement) {
            event.target = event.srcElement;
          }
          
          // Add stopPropagation method if missing
          if (!event.stopPropagation) {
            event.stopPropagation = function() {
              this.cancelBubble = true;
            };
          }
          
          // Add preventDefault method if missing
          if (!event.preventDefault) {
            event.preventDefault = function() {
              this.returnValue = false;
            };
          }
          
          // Call original listener
          listener.call(this, event);
        };
        
        // Store original and wrapped listeners for cleanup
        if (!eventHandlers.has(this)) {
          eventHandlers.set(this, new Map());
        }
        
        if (!eventHandlers.get(this).has(listener)) {
          eventHandlers.get(this).set(listener, { wrappedListener, type, options });
        }
        
        // Call original with wrapped listener
        return originalAddEventListener.call(this, type, wrappedListener, options.capture);
      };
      
      Element.prototype.removeEventListener = function(type, listener, useCapture) {
        // Handle deprecated useCapture parameter (boolean vs options object)
        const options = typeof useCapture === 'object' ? useCapture : { capture: !!useCapture };
        
        // Find wrappedListener
        if (eventHandlers.has(this) && eventHandlers.get(this).has(listener)) {
          const handlerInfo = eventHandlers.get(this).get(listener);
          
          // Only remove if type and capture match
          if (handlerInfo.type === type && handlerInfo.options.capture === options.capture) {
            originalRemoveEventListener.call(this, type, handlerInfo.wrappedListener, options.capture);
            eventHandlers.get(this).delete(listener);
            
            // Clean up Maps to prevent memory leaks
            if (eventHandlers.get(this).size === 0) {
              eventHandlers.delete(this);
            }
          }
        }
        
        // Always try to remove the original listener as fallback
        return originalRemoveEventListener.call(this, type, listener, options.capture);
      };
    }
  }
  
  /**
   * Fixes IE-specific DOM issues
   */
  function fixIEDOMIssues() {
    // Fix for IE's broken computed style
    if (config.features.hasComputedStyleIssues) {
      const originalGetComputedStyle = window.getComputedStyle;
      
      window.getComputedStyle = function(el, pseudoElt) {
        try {
          return originalGetComputedStyle(el, pseudoElt);
        } catch (e) {
          // Fallback for IE8 and below
          if (el.currentStyle) {
            return el.currentStyle;
          }
          return {};
        }
      };
    }
    
    // Fix for broken XMLHttpRequest in IE9 and below
    if (config.features.hasBrokenXHR && window.XDomainRequest) {
      // Store original XMLHttpRequest constructor
      const NativeXMLHttpRequest = window.XMLHttpRequest;
      
      // Define new XMLHttpRequest constructor
      window.XMLHttpRequest = function() {
        const xhr = new NativeXMLHttpRequest();
        
        // Patch CORS for IE9 and below
        if (xhr.withCredentials === undefined && window.XDomainRequest) {
          const xdr = new window.XDomainRequest();
          
          // Copy properties and methods
          for (let prop in xhr) {
            if (xhr.hasOwnProperty(prop) && typeof xhr[prop] !== 'function') {
              try {
                xdr[prop] = xhr[prop];
              } catch (e) {
                // Some properties can't be copied
              }
            }
          }
          
          // Override methods
          xdr.open = function(method, url) {
            if (/^https?:\/\//i.test(url)) {
              xdr.open(method, url);
            } else {
              throw new Error('XDomainRequest only works with HTTP and HTTPS URLs');
            }
          };
          
          return xdr;
        }
        
        return xhr;
      };
    }
  }
  
  /**
   * Injects a script into the page
   * @param {Object} options - Injection options
   * @param {Function} callback - Called when injection is complete
   */
  function injectScript(options, callback) {
    const scriptElement = document.createElement('script');
    
    if (options.url) {
      scriptElement.src = options.url;
      
      if (callback) {
        scriptElement.onreadystatechange = function() {
          if (this.readyState === 'loaded' || this.readyState === 'complete') {
            callback(null, true);
          }
        };
        
        scriptElement.onload = function() {
          callback(null, true);
        };
        
        scriptElement.onerror = function(error) {
          callback(error || new Error('Failed to load script'), false);
        };
      }
    } else if (options.code) {
      try {
        // For IE, it's safer to use script.text rather than textContent
        scriptElement.text = options.code;
        
        // For direct code injection, we can assume it executes synchronously
        if (callback) {
          setTimeout(function() {
            callback(null, true);
          }, 0);
        }
      } catch (error) {
        if (callback) {
          callback(error, false);
        }
        return;
      }
    }
    
    // Make sure script is removed after execution if needed
    scriptElement.setAttribute('data-cstestforge', 'true');
    
    // Append to document
    (document.head || document.documentElement).appendChild(scriptElement);
    
    // Clean up if needed
    if (options.removeAfterExecution && !options.url) {
      try {
        scriptElement.parentNode.removeChild(scriptElement);
      } catch (e) {
        // Ignore errors in cleanup
      }
    }
  }
  
  /**
   * Creates a unique container ID for injected elements
   * @returns {string} Unique container ID
   */
  function createContainerId() {
    // Use a timestamp-based ID for IE compatibility
    return 'cs-testforge-container-' + new Date().getTime() + '-' + Math.floor(Math.random() * 10000);
  }
  
  /**
   * Creates and injects an isolated container for UI elements
   * @param {Function} callback - Called with the container ID
   */
  function createIsolatedContainer(callback) {
    const containerId = createContainerId();
    
    // Create a detached div
    const container = document.createElement('div');
    container.id = containerId;
    container.style.position = 'absolute';
    container.style.top = '0';
    container.style.left = '0';
    container.style.width = '0';
    container.style.height = '0';
    container.style.overflow = 'hidden';
    container.style.zIndex = '2147483647'; // Max zIndex
    container.setAttribute('data-cstestforge', 'true');
    
    // In IE, we need to use IFRAMEs for isolation since Shadow DOM isn't supported
    const iframe = document.createElement('iframe');
    iframe.style.border = 'none';
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.style.background = 'transparent';
    
    container.appendChild(iframe);
    document.body.appendChild(container);
    
    // In IE, we need to handle onload slightly differently
    if (iframe.attachEvent) {
      iframe.attachEvent('onload', function() {
        handleIframeLoad();
      });
    } else {
      iframe.onload = function() {
        handleIframeLoad();
      };
    }
    
    // Handle iframe load event
    function handleIframeLoad() {
      try {
        // IE needs special handling for accessing iframe content
        const innerDoc = iframe.contentWindow.document || iframe.contentDocument;
        
        // Add styles to iframe to ensure consistent rendering
        let head = innerDoc.getElementsByTagName('head')[0];
        if (!head) {
          head = innerDoc.createElement('head');
          innerDoc.documentElement.appendChild(head);
        }
        
        // Add body if it doesn't exist
        let body = innerDoc.getElementsByTagName('body')[0];
        if (!body) {
          body = innerDoc.createElement('body');
          innerDoc.documentElement.appendChild(body);
        }
        
        // Create styles in iframe
        const style = innerDoc.createElement('style');
        style.type = 'text/css';
        
        // IE-specific CSS resets
        const cssText = `
          body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background-color: transparent;
          }
          * {
            box-sizing: border-box;
          }
        `;
        
        // Add CSS to the style element (IE-compatible method)
        if (style.styleSheet) {
          style.styleSheet.cssText = cssText;
        } else {
          style.appendChild(innerDoc.createTextNode(cssText));
        }
        
        head.appendChild(style);
        
        // Create inner container
        const innerContainer = innerDoc.createElement('div');
        innerContainer.id = containerId + '-inner';
        body.appendChild(innerContainer);
        
        callback(containerId, innerContainer, null);
      } catch (e) {
        // If there's an error creating the isolated container, use the fallback
        console.error('Failed to create isolated container in iframe:', e);
        container.innerHTML = ''; // Clear the iframe
        
        // Create a simple div as fallback
        const fallbackContainer = document.createElement('div');
        fallbackContainer.id = containerId + '-inner';
        container.appendChild(fallbackContainer);
        
        callback(containerId, fallbackContainer, null);
      }
    }
    
    // Fallback in case iframe doesn't trigger onload
    setTimeout(function() {
      try {
        if (iframe.contentWindow && iframe.contentWindow.document.readyState === 'complete') {
          // Already loaded but event not triggered - call handler manually
          handleIframeLoad();
        } else {
          throw new Error('Iframe not loaded');
        }
      } catch (e) {
        // If there's an error or timeout, fall back to a direct div
        console.error('Iframe load timeout - using fallback:', e);
        container.innerHTML = ''; // Clear the iframe
        
        // Create a simple div as fallback
        const fallbackContainer = document.createElement('div');
        fallbackContainer.id = containerId + '-inner';
        container.appendChild(fallbackContainer);
        
        callback(containerId, fallbackContainer, null);
      }
    }, 2000); // 2 second timeout
  }
  
  /**
   * Sets up a communication channel between the injected script and the parent document
   * @param {Object} options - Options for the channel
   * @returns {Object} Communication methods
   */
  function setupCommunication(options) {
    const channelId = options.channelId || 'cs-testforge-channel-' + new Date().getTime() + '-' + Math.floor(Math.random() * 10000);
    
    // In IE, communication has to use window.postMessage or other mechanisms
    const communicationMethods = {
      // Send message to parent
      sendToParent: function(message) {
        // Use postMessage for communication
        try {
          window.parent.postMessage({
            type: 'cs-testforge-to-parent',
            channelId: channelId,
            message: message
          }, '*');
          return true;
        } catch (e) {
          console.error('Failed to send message to parent:', e);
          return false;
        }
      },
      
      // Send message to page script
      sendToPage: function(message) {
        try {
          window.postMessage({
            type: 'cs-testforge-to-page',
            channelId: channelId,
            message: message
          }, '*');
          return true;
        } catch (e) {
          console.error('Failed to send message to page:', e);
          return false;
        }
      },
      
      // Listen for messages from parent
      listenForParent: function(callback) {
        const listener = function(event) {
          try {
            if (event.data && 
                event.data.type === 'cs-testforge-to-child' && 
                event.data.channelId === channelId) {
              callback(event.data.message);
            }
          } catch (e) {
            console.error('Error in parent message listener:', e);
          }
        };
        
        // Use attachEvent for older IE versions
        if (window.attachEvent) {
          window.attachEvent('onmessage', listener);
          
          return {
            remove: function() {
              window.detachEvent('onmessage', listener);
            }
          };
        } else {
          window.addEventListener('message', listener, false);
          
          return {
            remove: function() {
              window.removeEventListener('message', listener, false);
            }
          };
        }
      },
      
      // Listen for messages from page script
      listenForPage: function(callback) {
        const listener = function(event) {
          try {
            if (event.data && 
                event.data.type === 'cs-testforge-to-child' && 
                event.data.channelId === channelId) {
              callback(event.data.message);
            }
          } catch (e) {
            console.error('Error in page message listener:', e);
          }
        };
        
        // Use attachEvent for older IE versions
        if (window.attachEvent) {
          window.attachEvent('onmessage', listener);
          
          return {
            remove: function() {
              window.detachEvent('onmessage', listener);
            }
          };
        } else {
          window.addEventListener('message', listener, false);
          
          return {
            remove: function() {
              window.removeEventListener('message', listener, false);
            }
          };
        }
      }
    };
    
    return communicationMethods;
  }
  
  /**
   * Main entry point - injects the CSTestForge recorder into the page
   * @param {Object} options - Injection options
   * @param {Function} callback - Called when injection is complete
   */
  function inject(options, callback) {
    // Add IE polyfills
    addIEPolyfills();
    
    // Fix IE-specific issues
    fixIEEventIssues();
    fixIEDOMIssues();
    
    // Create event capture code that's compatible with IE
    const captureCode = `
      (function() {
        // Initialize CSTestForge capture
        if (window._csTestForgeInitialized) {
          return;
        }
        
        window._csTestForgeInitialized = true;
        
        // Setup messaging - IE-compatible approach
        var channelId = '${options.channelId || 'cs-testforge-channel-' + new Date().getTime() + '-' + Math.floor(Math.random() * 10000)}';
        
        // Send message to content script - use postMessage for IE compatibility
        function sendToContentScript(message) {
          try {
            window.postMessage({
              type: 'cs-testforge-to-content',
              channelId: channelId,
              message: message
            }, '*');
          } catch (e) {
            // In case of error, try alternative approach
            if (window.parent && window.parent !== window) {
              try {
                window.parent.postMessage({
                  type: 'cs-testforge-to-content',
                  channelId: channelId,
                  message: message
                }, '*');
              } catch (e2) {
                console.error('Failed to send message to content script:', e2);
              }
            }
          }
        }
        
        // Listen for messages from content script
        function setupMessageListener() {
          function messageHandler(event) {
            try {
              if (event.data && 
                  event.data.type === 'cs-testforge-to-page' && 
                  event.data.channelId === channelId) {
                
                // Handle incoming commands
                var message = event.data.message;
                
                if (message.command === 'start_recording') {
                  startRecording(message.config);
                } else if (message.command === 'stop_recording') {
                  stopRecording();
                } else if (message.command === 'get_element_info') {
                  getElementInfo(message.selector, message.requestId);
                }
              }
            } catch (e) {
              console.error('Error in message handler:', e);
            }
          }
          
          // Use attachEvent for older IE versions
          if (window.attachEvent) {
            window.attachEvent('onmessage', messageHandler);
          } else {
            window.addEventListener('message', messageHandler, false);
          }
        }
        
        setupMessageListener();
        
        // Capture DOM events
        var recording = false;
        var eventListeners = [];
        var config = {
          captureClicks: true,
          captureInputs: true,
          captureKeyboard: true
        };
        
        function startRecording(newConfig) {
          if (recording) {
            stopRecording();
          }
          
          recording = true;
          
          if (newConfig) {
            // Merge configs in an IE-compatible way
            for (var key in newConfig) {
              if (newConfig.hasOwnProperty(key)) {
                config[key] = newConfig[key];
              }
            }
          }
          
          setupEventCapture();
          
          sendToContentScript({
            type: 'recording_started',
            timestamp: new Date().getTime()
          });
        }
        
        function stopRecording() {
          if (!recording) {
            return;
          }
          
          recording = false;
          
          // Remove all event listeners
          for (var i = 0; i < eventListeners.length; i++) {
            var listener = eventListeners[i];
            
            // Use IE-compatible event removal
            if (listener.element.detachEvent) {
              listener.element.detachEvent('on' + listener.type, listener.handler);
            } else {
              listener.element.removeEventListener(listener.type, listener.handler, listener.options);
            }
          }
          
          eventListeners = [];
          
          sendToContentScript({
            type: 'recording_stopped',
            timestamp: new Date().getTime()
          });
        }
        
        function setupEventCapture() {
          // Capture clicks
          if (config.captureClicks) {
            addGlobalEventListener(document, 'click', handleClick);
            addGlobalEventListener(document, 'contextmenu', handleContextMenu);
            addGlobalEventListener(document, 'dblclick', handleDblClick);
          }
          
          // Capture form interactions
          if (config.captureInputs) {
            addGlobalEventListener(document, 'change', handleChange);
            addGlobalEventListener(document, 'input', handleInput);
            addGlobalEventListener(document, 'focus', handleFocus);
            addGlobalEventListener(document, 'blur', handleBlur);
            addGlobalEventListener(document, 'submit', handleSubmit);
          }
          
          // Capture keyboard
          if (config.captureKeyboard) {
            addGlobalEventListener(document, 'keydown', handleKeyDown);
            addGlobalEventListener(document, 'keyup', handleKeyUp);
          }
          
          // Capture scroll events (debounced)
          var scrollTimeout = null;
          addGlobalEventListener(window, 'scroll', function(event) {
            if (scrollTimeout) {
              clearTimeout(scrollTimeout);
            }
            
            scrollTimeout = setTimeout(function() {
              handleScroll(event);
              scrollTimeout = null;
            }, 100);
          });
        }
        
        function addGlobalEventListener(element, type, handler, options) {
          function wrappedHandler(event) {
            // Normalize event for IE
            event = event || window.event;
            
            // Add standard properties if missing (for IE)
            if (!event.target && event.srcElement) {
              event.target = event.srcElement;
            }
            
            if (!event.preventDefault) {
              event.preventDefault = function() {
                this.returnValue = false;
              };
            }
            
            if (!event.stopPropagation) {
              event.stopPropagation = function() {
                this.cancelBubble = true;
              };
            }
            
            if (recording) {
              handler(event);
            }
          }
          
          // Use IE-compatible event attachment
          if (element.attachEvent) {
            element.attachEvent('on' + type, wrappedHandler);
          } else {
            element.addEventListener(type, wrappedHandler, options);
          }
          
          eventListeners.push({
            element: element,
            type: type,
            handler: wrappedHandler,
            options: options
          });
        }
        
        // Element information - IE compatible version
        function getElementInfo(selector, requestId) {
          try {
            // Use querySelector if available (IE8+)
            var element = document.querySelector(selector);
            
            if (!element) {
              // Fallback for older IE - try getElementById if selector looks like an ID
              if (selector.charAt(0) === '#') {
                element = document.getElementById(selector.substring(1));
              }
              
              if (!element) {
                sendToContentScript({
                  type: 'element_info_response',
                  requestId: requestId,
                  success: false,
                  error: 'Element not found'
                });
                return;
              }
            }
            
            // Get element position (IE-compatible method)
            var rect = element.getBoundingClientRect();
            
            // Get all attributes
            var attributes = {};
            if (element.attributes) {
              for (var i = 0; i < element.attributes.length; i++) {
                attributes[element.attributes[i].name] = element.attributes[i].value;
              }
            }
            
            // Generate xpath - simplified for IE compatibility
            function getSimpleXPath(element) {
              if (element.id) {
                return '//*[@id="' + element.id + '"]';
              }
              
              if (element === document.body) {
                return '/html/body';
              }
              
              try {
                var path = '';
                while (element && element.nodeType === 1) {
                  var index = 0;
                  var sibling = element;
                  while (sibling) {
                    if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                      index++;
                    }
                    sibling = sibling.previousSibling;
                  }
                  var tagName = element.tagName.toLowerCase();
                  var pathIndex = index > 0 ? '[' + index + ']' : '';
                  path = '/' + tagName + pathIndex + path;
                  element = element.parentNode;
                }
                return path;
              } catch (e) {
                // If xpath generation fails, return a simple identifier
                return element.tagName.toLowerCase() + (element.id ? '#' + element.id : '');
              }
            }
            
            // Generate CSS selector - simplified for IE compatibility
            function getSimpleCssSelector(element) {
              if (element.id) {
                return '#' + element.id;
              }
              
              if (element === document.body) {
                return 'body';
              }
              
              var selector = element.tagName.toLowerCase();
              
              if (element.className) {
                var classes = element.className.split(/\\s+/);
                for (var i = 0; i < classes.length; i++) {
                  if (classes[i]) {
                    selector += '.' + classes[i];
                    break; // Just use first class for simplicity in IE
                  }
                }
              }
              
              // Use parent ID for better specificity if available
              if (element.parentNode && element.parentNode.id) {
                return '#' + element.parentNode.id + ' > ' + selector;
              }
              
              return selector;
            }
            
            var info = {
              tagName: element.tagName,
              id: element.id,
              className: element.className,
              attributes: attributes,
              text: element.innerText ? element.innerText.substring(0, 100) : '',
              xpath: getSimpleXPath(element),
              cssSelector: getSimpleCssSelector(element),
              rect: {
                top: rect.top,
                left: rect.left,
                width: rect.right - rect.left,
                height: rect.bottom - rect.top
              }
            };
            
            sendToContentScript({
              type: 'element_info_response',
              requestId: requestId,
              success: true,
              info: info
            });
          } catch (error) {
            sendToContentScript({
              type: 'element_info_response',
              requestId: requestId,
              success: false,
              error: error.message || 'Unknown error'
            });
          }
        }
        
        // Event handlers - IE compatible versions
        function handleClick(event) {
          var target = event.target || event.srcElement;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'click',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: event.clientX,
              clientY: event.clientY
            }
          });
        }
        
        function handleContextMenu(event) {
          var target = event.target || event.srcElement;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'contextmenu',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: event.clientX,
              clientY: event.clientY
            }
          });
        }
        
        function handleDblClick(event) {
          var target = event.target || event.srcElement;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'dblclick',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              innerText: target.innerText ? target.innerText.substring(0, 50) : '',
              value: target.value
            },
            position: {
              clientX: event.clientX,
              clientY: event.clientY
            }
          });
        }
        
        function handleChange(event) {
          var target = event.target || event.srcElement;
          
          // Special handling for different input types
          var value = target.value;
          
          if (target.type === 'checkbox' || target.type === 'radio') {
            value = target.checked;
          } else if (target.type === 'password') {
            // Mask password value
            value = '********';
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'change',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            value: value
          });
        }
        
        function handleInput(event) {
          var target = event.target || event.srcElement;
          
          // Skip for password fields
          if (target.type === 'password') {
            return;
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'input',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            value: target.value
          });
        }
        
        function handleFocus(event) {
          var target = event.target || event.srcElement;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'focus',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            }
          });
        }
        
        function handleBlur(event) {
          var target = event.target || event.srcElement;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'blur',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            }
          });
        }
        
        function handleSubmit(event) {
          var target = event.target || event.srcElement;
          
          // Collect form data
          var formData = {};
          
          if (target.tagName === 'FORM') {
            var elements = target.elements;
            
            for (var i = 0; i < elements.length; i++) {
              var element = elements[i];
              
              if (element.name) {
                if (element.type === 'checkbox' || element.type === 'radio') {
                  if (element.checked) {
                    formData[element.name] = element.value;
                  }
                } else if (element.type === 'password') {
                  // Mask password
                  formData[element.name] = '********';
                } else {
                  formData[element.name] = element.value;
                }
              }
            }
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'submit',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              action: target.action,
              method: target.method
            },
            formData: formData
          });
        }
        
        function handleKeyDown(event) {
          var target = event.target || event.srcElement;
          
          // Skip if target is a password field
          if (target.type === 'password') {
            return;
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'keydown',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            key: event.keyCode,
            code: event.code || String.fromCharCode(event.keyCode),
            keyCode: event.keyCode,
            altKey: event.altKey,
            ctrlKey: event.ctrlKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey
          });
        }
        
        function handleKeyUp(event) {
          var target = event.target || event.srcElement;
          
          // Skip if target is a password field
          if (target.type === 'password') {
            return;
          }
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'keyup',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName,
              id: target.id,
              className: target.className,
              type: target.type,
              name: target.name
            },
            key: event.keyCode,
            code: event.code || String.fromCharCode(event.keyCode),
            keyCode: event.keyCode,
            altKey: event.altKey,
            ctrlKey: event.ctrlKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey
          });
        }
        
        function handleScroll(event) {
          var target = document.documentElement;
          
          // Get scroll position (IE compatible)
          var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
          var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
          
          sendToContentScript({
            type: 'dom_event',
            eventType: 'scroll',
            timestamp: new Date().getTime(),
            element: {
              tagName: target.tagName || 'window',
              id: target.id,
              className: target.className
            },
            scrollPosition: {
              scrollTop: scrollTop,
              scrollLeft: scrollLeft
            }
          });
        }
        
        // Handle IE-specific navigation tracking
        if (window.history && window.history.pushState) {
          // Modern browsers with pushState
          var originalPushState = window.history.pushState;
          window.history.pushState = function() {
            var result = originalPushState.apply(this, arguments);
            
            if (recording) {
              sendToContentScript({
                type: 'dom_event',
                eventType: 'navigation',
                timestamp: new Date().getTime(),
                url: window.location.href,
                title: document.title,
                navigation_type: 'pushState'
              });
            }
            
            return result;
          };
          
          var originalReplaceState = window.history.replaceState;
          window.history.replaceState = function() {
            var result = originalReplaceState.apply(this, arguments);
            
            if (recording) {
              sendToContentScript({
                type: 'dom_event',
                eventType: 'navigation',
                timestamp: new Date().getTime(),
                url: window.location.href,
                title: document.title,
                navigation_type: 'replaceState'
              });
            }
            
            return result;
          };
        }
        
        // Track hash changes
        function handleHashChange() {
          if (recording) {
            sendToContentScript({
              type: 'dom_event',
              eventType: 'navigation',
              timestamp: new Date().getTime(),
              url: window.location.href,
              title: document.title,
              navigation_type: 'hashChange'
            });
          }
        }
        
        // Use attachEvent for older IE versions
        if (window.attachEvent) {
          window.attachEvent('onhashchange', handleHashChange);
        } else {
          window.addEventListener('hashchange', handleHashChange, false);
        }
        
        // Track page unload
        function handleBeforeUnload() {
          if (recording) {
            sendToContentScript({
              type: 'dom_event',
              eventType: 'beforeunload',
              timestamp: new Date().getTime(),
              url: window.location.href,
              title: document.title
            });
          }
        }
        
        // Use attachEvent for older IE versions
        if (window.attachEvent) {
          window.attachEvent('onbeforeunload', handleBeforeUnload);
        } else {
          window.addEventListener('beforeunload', handleBeforeUnload, false);
        }
        
        // IE-specific mutation observation (for IE 11)
        function setupMutationObservation() {
          if (window.MutationObserver) {
            var observer = new MutationObserver(function(mutations) {
              if (!recording) return;
              
              var changes = {
                addedElements: [],
                removedElements: [],
                attributeChanges: [],
                textChanges: []
              };
              
              for (var i = 0; i < mutations.length; i++) {
                var mutation = mutations[i];
                
                if (mutation.type === 'childList') {
                  // Track added nodes
                  for (var j = 0; j < mutation.addedNodes.length; j++) {
                    var node = mutation.addedNodes[j];
                    if (node.nodeType === 1) { // Element node
                      changes.addedElements.push({
                        tagName: node.tagName,
                        id: node.id,
                        className: node.className
                      });
                    }
                  }
                  
                  // Track removed nodes
                  for (var j = 0; j < mutation.removedNodes.length; j++) {
                    var node = mutation.removedNodes[j];
                    if (node.nodeType === 1) { // Element node
                      changes.removedElements.push({
                        tagName: node.tagName,
                        id: node.id,
                        className: node.className
                      });
                    }
                  }
                } else if (mutation.type === 'attributes') {
                  changes.attributeChanges.push({
                    element: {
                      tagName: mutation.target.tagName,
                      id: mutation.target.id,
                      className: mutation.target.className
                    },
                    attribute: mutation.attributeName,
                    value: mutation.target.getAttribute(mutation.attributeName)
                  });
                } else if (mutation.type === 'characterData' && mutation.target.parentNode) {
                  changes.textChanges.push({
                    element: {
                      tagName: mutation.target.parentNode.tagName,
                      id: mutation.target.parentNode.id,
                      className: mutation.target.parentNode.className
                    },
                    text: mutation.target.data.substring(0, 100)
                  });
                }
              }
              
              // Only send message if there were actual changes
              if (changes.addedElements.length > 0 || 
                  changes.removedElements.length > 0 || 
                  changes.attributeChanges.length > 0 || 
                  changes.textChanges.length > 0) {
                sendToContentScript({
                  type: 'dom_event',
                  eventType: 'mutation',
                  timestamp: new Date().getTime(),
                  changes: changes
                });
              }
            });
            
            observer.observe(document, {
              childList: true,
              attributes: true,
              characterData: true,
              subtree: true
            });
            
            // Store observer for cleanup
            window._csTestForgeMutationObserver = observer;
          } else if (document.documentElement.attachEvent) {
            // For IE versions that don't support MutationObserver, use DOMNodeInserted/DOMNodeRemoved/DOMAttrModified
            // These events aren't ideal but provide some mutation tracking
            document.documentElement.attachEvent('DOMNodeInserted', function(event) {
              if (!recording) return;
              
              var node = event.target || event.srcElement;
              if (node && node.nodeType === 1) {
                sendToContentScript({
                  type: 'dom_event',
                  eventType: 'mutation',
                  timestamp: new Date().getTime(),
                  changes: {
                    addedElements: [{
                      tagName: node.tagName,
                      id: node.id,
                      className: node.className
                    }],
                    removedElements: [],
                    attributeChanges: [],
                    textChanges: []
                  }
                });
              }
            });
            
            document.documentElement.attachEvent('DOMNodeRemoved', function(event) {
              if (!recording) return;
              
              var node = event.target || event.srcElement;
              if (node && node.nodeType === 1) {
                sendToContentScript({
                  type: 'dom_event',
                  eventType: 'mutation',
                  timestamp: new Date().getTime(),
                  changes: {
                    addedElements: [],
                    removedElements: [{
                      tagName: node.tagName,
                      id: node.id,
                      className: node.className
                    }],
                    attributeChanges: [],
                    textChanges: []
                  }
                });
              }
            });
            
            // Unfortunately, DOMAttrModified isn't well supported in IE, so we can't easily track attribute changes
          }
        }
        
        // Only setup mutation observation if specified in config
        if (config.captureDOMChanges) {
          setupMutationObservation();
        }
        
        // Track XHR for network requests in IE
        function setupXHRTracking() {
          if (!config.captureNetwork) {
            return;
          }
          
          var originalXHROpen = XMLHttpRequest.prototype.open;
          var originalXHRSend = XMLHttpRequest.prototype.send;
          
          XMLHttpRequest.prototype.open = function() {
            this._csTestForgeURL = arguments[1];
            this._csTestForgeMethod = arguments[0];
            return originalXHROpen.apply(this, arguments);
          };
          
          XMLHttpRequest.prototype.send = function() {
            if (recording) {
              var startTime = new Date().getTime();
              var url = this._csTestForgeURL;
              var method = this._csTestForgeMethod;
              var xhr = this;
              
              sendToContentScript({
                type: 'dom_event',
                eventType: 'network_request_started',
                timestamp: startTime,
                url: url,
                method: method,
                type: 'xhr'
              });
              
              // Track request completion
              var originalOnReadyStateChange = this.onreadystatechange;
              this.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  if (recording) {
                    if (xhr.status >= 200 && xhr.status < 400) {
                      sendToContentScript({
                        type: 'dom_event',
                        eventType: 'network_request_completed',
                        timestamp: new Date().getTime(),
                        url: url,
                        method: method,
                        type: 'xhr',
                        status: xhr.status,
                        statusText: xhr.statusText,
                        duration: new Date().getTime() - startTime
                      });
                    } else {
                      sendToContentScript({
                        type: 'dom_event',
                        eventType: 'network_request_failed',
                        timestamp: new Date().getTime(),
                        url: url,
                        method: method,
                        type: 'xhr',
                        status: xhr.status,
                        statusText: xhr.statusText,
                        error: 'HTTP Error ' + xhr.status,
                        duration: new Date().getTime() - startTime
                      });
                    }
                  }
                }
                
                if (originalOnReadyStateChange) {
                  originalOnReadyStateChange.apply(this, arguments);
                }
              };
            }
            
            return originalXHRSend.apply(this, arguments);
          };
        }
        
        // Setup XHR tracking
        setupXHRTracking();
        
        // Notify ready
        sendToContentScript({
          type: 'page_ready',
          url: window.location.href,
          title: document.title,
          timestamp: new Date().getTime()
        });
      })();
    `;
    
    // Inject the capture code
    injectScript({ code: captureCode, removeAfterExecution: true }, (error, success) => {
      if (error) {
        if (callback) {
          callback(error, null);
        }
        return;
      }
      
      // Create communication channel
      const communication = setupCommunication({ channelId: options.channelId });
      
      // Create UI container if needed
      if (options.createUI) {
        createIsolatedContainer((containerId, container, shadowRoot) => {
          const result = {
            communication: communication,
            container: {
              id: containerId,
              element: container,
              shadowRoot: shadowRoot
            }
          };
          
          if (callback) {
            callback(null, result);
          }
        });
      } else {
        const result = {
          communication: communication
        };
        
        if (callback) {
          callback(null, result);
        }
      }
    });
  }
  
  /**
   * Get detailed information about the IE environment
   * @returns {Object} IE environment details
   */
  function getIEEnvironmentInfo() {
    // For IE-specific compatibility issues
    const documentMode = document.documentMode;
    
    // Detect compatibility view
    const isInCompatibilityView = ieVersion.major !== documentMode;
    
    // Return comprehensive environment info
    return {
      version: ieVersion.major,
      minor: ieVersion.minor,
      isIE: ieVersion.isIE,
      isIE11: ieVersion.isIE11,
      isIEEdge: ieVersion.isIEEdge,
      documentMode: documentMode,
      isInCompatibilityView: isInCompatibilityView,
      features: config.features,
      userAgent: navigator.userAgent,
      browserLanguage: navigator.browserLanguage || navigator.language,
      systemLanguage: navigator.systemLanguage,
      cpuClass: navigator.cpuClass,
      platform: navigator.platform,
      isWindowsPhone: /Windows Phone/i.test(navigator.userAgent),
      cookieEnabled: navigator.cookieEnabled,
      screenColorDepth: screen.colorDepth,
      screenPixelDepth: screen.pixelDepth,
      docTypeEnabled: document.doctype !== null,
      isActiveXEnabled: typeof ActiveXObject !== 'undefined',
      isVMLSupported: document.namespaces && document.namespaces.length > 0
    };
  }
  
  /**
   * Creates IE-specific style element
   * @param {Object} options - Style options
   * @returns {HTMLElement} Style element
   */
  function createIEStyleElement(options) {
    const styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    
    // IE-specific CSS resets
    const cssRules = [
      // Fix for CSS inconsistencies in IE
      '* { box-sizing: border-box; }',
      // Fix for IE box model issues
      '.cs-testforge-boxfix { width: auto !important; }',
      // Ensure proper z-index on IE
      '.cs-testforge-overlay { z-index: 2147483647 !important; }',
      // Fix for IE hasLayout issues
      '.cs-testforge-haslayout { zoom: 1; }',
      // Fix for IE image scaling
      '.cs-testforge-img { -ms-interpolation-mode: bicubic; }'
    ];
    
    // IE uses styleSheet.cssText instead of textContent
    if (styleElement.styleSheet) {
      styleElement.styleSheet.cssText = cssRules.join('\n');
    } else {
      styleElement.textContent = cssRules.join('\n');
    }
    
    return styleElement;
  }
  
  /**
   * Create IE-specific locator strategies
   * @returns {Object} IE locator strategies
   */
  function getIELocatorStrategies() {
    return {
      // IE-specific strategies for finding elements
      xpath: {
        useIECompatibleXPath: true,
        avoidComplexXPath: ieVersion.major < 9,
        useSimplePredicates: ieVersion.major < 10,
        avoidTextFilters: ieVersion.major < 9
      },
      
      css: {
        // CSS selector limitations in IE
        maxLength: 4095, // IE has a limit of 4095 characters for CSS selectors
        useSimpleSelectors: ieVersion.major < 9,
        avoidAttributeSelectors: ieVersion.major < 8,
        preferIdsOverCompoundSelectors: true
      },
      
      // Alternative strategies for IE
      alternatives: {
        useJavaScriptLocators: ieVersion.major < 8,
        useGetElementBy: ieVersion.major < 9,
        useTableCoordinates: ieVersion.major < 8
      }
    };
  }
  
  /**
   * Get IE-specific recording capabilities
   * @returns {Object} IE recording capabilities
   */
  function getIERecordingCapabilities() {
    return {
      canCaptureScreenshots: ieVersion.major >= 9,
      canRecordVideo: false, // Not supported in IE
      canUseWebSockets: ieVersion.major >= 10,
      canUsePushState: ieVersion.major >= 10,
      canUseMutationObserver: ieVersion.major >= 11,
      canUseAdvancedXHR: ieVersion.major >= 10,
      canUseCustomEvents: ieVersion.major >= 9,
      canUseAdvancedCSS: ieVersion.major >= 9,
      multipleEventListeners: ieVersion.major >= 9,
      dataUriSupport: ieVersion.major >= 8
    };
  }
  
  /**
   * Create a special VBScript helper for IE-specific operations that JavaScript can't do
   * This is needed for certain IE-specific features not available via JavaScript
   * @returns {boolean} Whether VBScript helper was successfully created
   */
  function createVBScriptHelper() {
    if (!ieVersion.isIE || ieVersion.isIE11) {
      return false; // Only needed for older IE versions, not IE11
    }
    
    try {
      // Define VBScript functions for operations not available in JScript
      const vbScript = `
        <!-- VBScript helpers for CSTestForge IE Recorder -->
        <script type="text/vbscript">
        Function CSGetIEVersion()
            CSGetIEVersion = ScriptEngineMajorVersion() & "." & ScriptEngineMinorVersion()
        End Function
        
        Function CSGetActiveXEnabled()
            On Error Resume Next
            Dim test
            Set test = CreateObject("Scripting.Dictionary")
            If Err.Number = 0 Then
                CSGetActiveXEnabled = True
            Else
                CSGetActiveXEnabled = False
            End If
            Set test = Nothing
        End Function
        
        ' Get computed style for elements in older IEs
        Function CSGetComputedStyle(element, styleProp)
            On Error Resume Next
            Dim style
            style = element.currentStyle(styleProp)
            If Err.Number <> 0 Then
                style = ""
            End If
            CSGetComputedStyle = style
        End Function
        
        ' Convert DOM element to XML string
        Function CSElementToXML(element)
            On Error Resume Next
            If TypeName(element) <> "HTMLObjectElement" Then
                CSElementToXML = element.outerHTML
            Else
                CSElementToXML = "<object id=""" & element.id & """ />"
            End If
        End Function
        </script>
      `;
      
      // Create a container for the VBScript
      const container = document.createElement('div');
      container.style.display = 'none';
      container.innerHTML = vbScript;
      document.body.appendChild(container);
      
      // Test if it worked
      try {
        const testVer = window.CSGetIEVersion();
        return true;
      } catch (e) {
        console.error('VBScript helper creation failed:', e);
        return false;
      }
    } catch (e) {
      console.error('VBScript helper creation error:', e);
      return false;
    }
  }
  
  // Export the API
  window.CSTestForgeIEInjector = {
    inject: inject,
    injectScript: injectScript,
    createIsolatedContainer: createIsolatedContainer,
    setupCommunication: setupCommunication,
    addIEPolyfills: addIEPolyfills,
    fixIEEventIssues: fixIEEventIssues,
    fixIEDOMIssues: fixIEDOMIssues,
    getIEEnvironmentInfo: getIEEnvironmentInfo,
    createIEStyleElement: createIEStyleElement,
    getIELocatorStrategies: getIELocatorStrategies,
    getIERecordingCapabilities: getIERecordingCapabilities,
    createVBScriptHelper: createVBScriptHelper,
    getBrowserInfo: function() {
      return {
        version: ieVersion,
        features: config.features,
        isIE: ieVersion.isIE,
        isIE11: ieVersion.isIE11,
        isIEEdge: ieVersion.isIEEdge
      };
    }
  };
})();


recorder/selenium/action-converter.js
--------------------------------------------------

/**
 * CSTestForge Selenium Action Converter
 * 
 * Converts recorded browser actions into Selenium code for Java and TypeScript.
 * Handles both TestNG and BDD (Cucumber) test patterns.
 */

(function() {
  // Language and framework-specific formatters
  const formatters = {
    java: {
      testng: {
        fileExtension: '.java',
        
        generateImports: function(actions, options) {
          return [
            'import org.testng.annotations.Test;',
            'import org.testng.annotations.BeforeMethod;',
            'import org.testng.annotations.AfterMethod;',
            'import org.testng.Assert;',
            'import org.openqa.selenium.WebDriver;',
            'import org.openqa.selenium.WebElement;',
            'import org.openqa.selenium.By;',
            'import org.openqa.selenium.JavascriptExecutor;',
            'import org.openqa.selenium.support.ui.ExpectedConditions;',
            'import org.openqa.selenium.support.ui.WebDriverWait;',
            'import org.openqa.selenium.support.ui.Select;',
            'import org.openqa.selenium.interactions.Actions;',
            'import org.openqa.selenium.Keys;',
            'import java.time.Duration;',
            '',
            'import com.cstestforge.framework.core.utils.CSScreenshotManager;',
            'import com.cstestforge.framework.selenium.CSBaseTest;',
            'import com.cstestforge.framework.selenium.CSElement;',
            'import com.cstestforge.framework.selenium.CSWaitStrategy;',
            'import com.cstestforge.framework.selenium.CSVisibilityWait;',
            'import com.cstestforge.framework.selenium.CSClickableWait;'
          ].join('\n');
        },
        
        generateClassStart: function(className, options) {
          return [
            '/**',
            ' * Generated test class for ' + className,
            ' * Generated by CSTestForge Recorder',
            ' */',
            'public class ' + className + ' extends CSBaseTest {',
            '',
            '    private WebDriver driver;',
            '    private WebDriverWait wait;',
            '    private JavascriptExecutor js;',
            '    private Actions actions;',
            '',
            '    @BeforeMethod',
            '    public void setUp() {',
            '        driver = getDriver();',
            '        wait = new WebDriverWait(driver, Duration.ofSeconds(30));',
            '        js = (JavascriptExecutor) driver;',
            '        actions = new Actions(driver);',
            '    }',
            '',
            '    @AfterMethod',
            '    public void tearDown() {',
            '        if (driver != null) {',
            '            driver.quit();',
            '        }',
            '    }',
            ''
          ].join('\n');
        },
        
        generateMethodStart: function(methodName, options) {
          return [
            '    @Test',
            '    public void ' + methodName + '() {',
            ''
          ].join('\n');
        },
        
        generateMethodEnd: function(options) {
          return '    }\n';
        },
        
        generateClassEnd: function(options) {
          return '}\n';
        },
        
        formatAction: function(action, index, options) {
          const indent = '        ';
          let code = '';
          
          switch (action.type) {
            case 'navigate':
              code = `driver.get("${action.url}");`;
              break;
            
            case 'click':
              if (action.useJS) {
                code = `js.executeScript("arguments[0].click();", driver.findElement(${this.formatLocator(action.locator)}));`;
              } else {
                code = `driver.findElement(${this.formatLocator(action.locator)}).click();`;
              }
              break;
            
            case 'doubleClick':
              code = `actions.doubleClick(driver.findElement(${this.formatLocator(action.locator)})).perform();`;
              break;
            
            case 'rightClick':
              code = `actions.contextClick(driver.findElement(${this.formatLocator(action.locator)})).perform();`;
              break;
            
            case 'type':
              if (action.clearFirst) {
                code = [
                  `WebElement element = driver.findElement(${this.formatLocator(action.locator)});`,
                  `element.clear();`,
                  `element.sendKeys("${this.escapeString(action.text)}");`
                ].join('\n' + indent);
              } else {
                code = `driver.findElement(${this.formatLocator(action.locator)}).sendKeys("${this.escapeString(action.text)}");`;
              }
              break;
            
            case 'clear':
              code = `driver.findElement(${this.formatLocator(action.locator)}).clear();`;
              break;
            
            case 'select':
              if (action.byIndex !== undefined) {
                code = `new Select(driver.findElement(${this.formatLocator(action.locator)})).selectByIndex(${action.byIndex});`;
              } else if (action.byValue !== undefined) {
                code = `new Select(driver.findElement(${this.formatLocator(action.locator)})).selectByValue("${this.escapeString(action.byValue)}");`;
              } else if (action.byText !== undefined) {
                code = `new Select(driver.findElement(${this.formatLocator(action.locator)})).selectByVisibleText("${this.escapeString(action.byText)}");`;
              }
              break;
            
            case 'check':
              code = [
                `WebElement element = driver.findElement(${this.formatLocator(action.locator)});`,
                `if (!element.isSelected()) {`,
                `    element.click();`,
                `}`
              ].join('\n' + indent);
              break;
            
            case 'uncheck':
              code = [
                `WebElement element = driver.findElement(${this.formatLocator(action.locator)});`,
                `if (element.isSelected()) {`,
                `    element.click();`,
                `}`
              ].join('\n' + indent);
              break;
            
            case 'hover':
              code = `actions.moveToElement(driver.findElement(${this.formatLocator(action.locator)})).perform();`;
              break;
            
            case 'dragAndDrop':
              code = `actions.dragAndDrop(driver.findElement(${this.formatLocator(action.sourceLocator)}), driver.findElement(${this.formatLocator(action.targetLocator)})).perform();`;
              break;
            
            case 'wait':
              if (action.waitType === 'visibility') {
                code = `wait.until(ExpectedConditions.visibilityOfElementLocated(${this.formatLocator(action.locator)}));`;
              } else if (action.waitType === 'clickable') {
                code = `wait.until(ExpectedConditions.elementToBeClickable(${this.formatLocator(action.locator)}));`;
              } else if (action.waitType === 'presence') {
                code = `wait.until(ExpectedConditions.presenceOfElementLocated(${this.formatLocator(action.locator)}));`;
              } else if (action.waitType === 'time') {
                code = `Thread.sleep(${action.duration});`;
              }
              break;
            
            case 'executeScript':
              if (action.arguments && action.arguments.length > 0) {
                const args = action.arguments.map(arg => {
                  if (typeof arg === 'string') {
                    return `"${this.escapeString(arg)}"`;
                  } else if (arg === null) {
                    return 'null';
                  } else if (typeof arg === 'object' && arg.type === 'element') {
                    return `driver.findElement(${this.formatLocator(arg.locator)})`;
                  }
                  return String(arg);
                }).join(', ');
                
                code = `js.executeScript("${this.escapeString(action.script)}", ${args});`;
              } else {
                code = `js.executeScript("${this.escapeString(action.script)}");`;
              }
              break;
            
            case 'assertion':
              if (action.assertType === 'equals') {
                code = `Assert.assertEquals(driver.findElement(${this.formatLocator(action.locator)}).${action.property}, "${this.escapeString(action.expectedValue)}");`;
              } else if (action.assertType === 'contains') {
                code = `Assert.assertTrue(driver.findElement(${this.formatLocator(action.locator)}).${action.property}.contains("${this.escapeString(action.expectedValue)}"));`;
              } else if (action.assertType === 'selected') {
                code = `Assert.assertTrue(driver.findElement(${this.formatLocator(action.locator)}).isSelected());`;
              } else if (action.assertType === 'notSelected') {
                code = `Assert.assertFalse(driver.findElement(${this.formatLocator(action.locator)}).isSelected());`;
              } else if (action.assertType === 'exists') {
                code = `Assert.assertNotNull(driver.findElement(${this.formatLocator(action.locator)}));`;
              } else if (action.assertType === 'notExists') {
                code = [
                  `try {`,
                  `    driver.findElement(${this.formatLocator(action.locator)});`,
                  `    Assert.fail("Element should not exist, but was found");`,
                  `} catch (org.openqa.selenium.NoSuchElementException e) {`,
                  `    // Element correctly not found`,
                  `}`
                ].join('\n' + indent);
              }
              break;
            
            case 'screenshot':
              code = `CSScreenshotManager.takeScreenshot(driver, "${action.name || 'screenshot_' + index}");`;
              break;
            
            case 'switchToFrame':
              if (action.nameOrId) {
                code = `driver.switchTo().frame("${this.escapeString(action.nameOrId)}");`;
              } else if (action.index !== undefined) {
                code = `driver.switchTo().frame(${action.index});`;
              } else if (action.locator) {
                code = `driver.switchTo().frame(driver.findElement(${this.formatLocator(action.locator)}));`;
              }
              break;
            
            case 'switchToDefaultContent':
              code = `driver.switchTo().defaultContent();`;
              break;
            
            case 'switchToWindow':
              if (action.nameOrHandle) {
                code = `driver.switchTo().window("${this.escapeString(action.nameOrHandle)}");`;
              } else if (action.index !== undefined) {
                code = [
                  `java.util.Set<String> windowHandles = driver.getWindowHandles();`,
                  `java.util.List<String> windowHandlesList = new java.util.ArrayList<>(windowHandles);`,
                  `driver.switchTo().window(windowHandlesList.get(${action.index}));`
                ].join('\n' + indent);
              }
              break;
            
            case 'keyPress':
              if (action.key === 'Enter') {
                code = `driver.findElement(${this.formatLocator(action.locator)}).sendKeys(Keys.ENTER);`;
              } else if (action.key === 'Tab') {
                code = `driver.findElement(${this.formatLocator(action.locator)}).sendKeys(Keys.TAB);`;
              } else if (action.key === 'Escape') {
                code = `driver.findElement(${this.formatLocator(action.locator)}).sendKeys(Keys.ESCAPE);`;
              } else {
                code = `driver.findElement(${this.formatLocator(action.locator)}).sendKeys(Keys.${action.key.toUpperCase()});`;
              }
              break;
            
            case 'comment':
              code = `// ${action.text}`;
              break;
            
            default:
              code = `// Unsupported action type: ${action.type}`;
          }
          
          return indent + code;
        },
        
        formatLocator: function(locator) {
          switch (locator.type) {
            case 'id':
              return `By.id("${this.escapeString(locator.value)}")`;
            case 'name':
              return `By.name("${this.escapeString(locator.value)}")`;
            case 'className':
              return `By.className("${this.escapeString(locator.value)}")`;
            case 'tagName':
              return `By.tagName("${this.escapeString(locator.value)}")`;
            case 'linkText':
              return `By.linkText("${this.escapeString(locator.value)}")`;
            case 'partialLinkText':
              return `By.partialLinkText("${this.escapeString(locator.value)}")`;
            case 'css':
              return `By.cssSelector("${this.escapeString(locator.value)}")`;
            case 'xpath':
              return `By.xpath("${this.escapeString(locator.value)}")`;
            default:
              return `By.id("unknown-locator-type")`;
          }
        },
        
        escapeString: function(str) {
          if (typeof str !== 'string') {
            return str;
          }
          return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
        }
      },
      
      bdd: {
        fileExtension: '.java',
        
        generateImports: function(actions, options) {
          return [
            'import io.cucumber.java.en.Given;',
            'import io.cucumber.java.en.When;',
            'import io.cucumber.java.en.Then;',
            'import io.cucumber.java.en.And;',
            'import org.testng.Assert;',
            'import org.openqa.selenium.WebDriver;',
            'import org.openqa.selenium.WebElement;',
            'import org.openqa.selenium.By;',
            'import org.openqa.selenium.JavascriptExecutor;',
            'import org.openqa.selenium.support.ui.ExpectedConditions;',
            'import org.openqa.selenium.support.ui.WebDriverWait;',
            'import org.openqa.selenium.support.ui.Select;',
            'import org.openqa.selenium.interactions.Actions;',
            'import org.openqa.selenium.Keys;',
            'import java.time.Duration;',
            '',
            'import com.cstestforge.framework.core.utils.CSScreenshotManager;',
            'import com.cstestforge.framework.selenium.CSBaseStepDef;',
            'import com.cstestforge.framework.selenium.CSElement;',
            'import com.cstestforge.framework.selenium.CSWaitStrategy;',
            'import com.cstestforge.framework.selenium.CSVisibilityWait;',
            'import com.cstestforge.framework.selenium.CSClickableWait;'
          ].join('\n');
        },
        
        generateClassStart: function(className, options) {
          return [
            '/**',
            ' * Generated step definitions for ' + className,
            ' * Generated by CSTestForge Recorder',
            ' */',
            'public class ' + className + 'Steps extends CSBaseStepDef {',
            '',
            '    private WebDriver driver;',
            '    private WebDriverWait wait;',
            '    private JavascriptExecutor js;',
            '    private Actions actions;',
            '',
            '    public ' + className + 'Steps() {',
            '        driver = getDriver();',
            '        wait = new WebDriverWait(driver, Duration.ofSeconds(30));',
            '        js = (JavascriptExecutor) driver;',
            '        actions = new Actions(driver);',
            '    }',
            ''
          ].join('\n');
        },
        
        generateClassEnd: function(options) {
          return '}\n';
        },
        
        formatAction: function(action, index, options) {
          const indent = '    ';
          let annotation = '';
          let methodSignature = '';
          let code = '';
          
          switch (action.type) {
            case 'navigate':
              annotation = '@Given';
              methodSignature = `public void navigateToUrl() {`;
              code = `    driver.get("${action.url}");`;
              break;
            
            case 'click':
              annotation = '@When';
              methodSignature = `public void clickOnElement() {`;
              
              if (action.useJS) {
                code = `    js.executeScript("arguments[0].click();", driver.findElement(${this.formatLocator(action.locator)}));`;
              } else {
                code = `    driver.findElement(${this.formatLocator(action.locator)}).click();`;
              }
              break;
            
            case 'type':
              annotation = '@When';
              methodSignature = `public void enterText() {`;
              
              if (action.clearFirst) {
                code = [
                  `    WebElement element = driver.findElement(${this.formatLocator(action.locator)});`,
                  `    element.clear();`,
                  `    element.sendKeys("${this.escapeString(action.text)}");`
                ].join('\n');
              } else {
                code = `    driver.findElement(${this.formatLocator(action.locator)}).sendKeys("${this.escapeString(action.text)}");`;
              }
              break;
            
            // More action types would be implemented similarly...
            default:
              annotation = '@And';
              methodSignature = `public void performAction${index}() {`;
              code = `    // Implement action: ${action.type}`;
          }
          
          return [
            `${indent}${annotation}(".*")`,
            `${indent}${methodSignature}`,
            `${code}`,
            `${indent}}`
          ].join('\n');
        },
        
        formatLocator: function(locator) {
          // Same as testng formatter
          switch (locator.type) {
            case 'id':
              return `By.id("${this.escapeString(locator.value)}")`;
            case 'name':
              return `By.name("${this.escapeString(locator.value)}")`;
            case 'className':
              return `By.className("${this.escapeString(locator.value)}")`;
            case 'tagName':
              return `By.tagName("${this.escapeString(locator.value)}")`;
            case 'linkText':
              return `By.linkText("${this.escapeString(locator.value)}")`;
            case 'partialLinkText':
              return `By.partialLinkText("${this.escapeString(locator.value)}")`;
            case 'css':
              return `By.cssSelector("${this.escapeString(locator.value)}")`;
            case 'xpath':
              return `By.xpath("${this.escapeString(locator.value)}")`;
            default:
              return `By.id("unknown-locator-type")`;
          }
        },
        
        escapeString: function(str) {
          // Same as testng formatter
          if (typeof str !== 'string') {
            return str;
          }
          return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
        },
        
        generateFeatureFile: function(className, actions, options) {
          // Generate Cucumber feature file content
          const featureName = className.replace(/([A-Z])/g, ' $1').trim();
          
          let feature = [
            `Feature: ${featureName}`,
            `  As a user`,
            `  I want to use the application`,
            `  So that I can complete my tasks`,
            ``
          ];
          
          const scenarioName = options.scenarioName || 'Use the application';
          feature.push(`  Scenario: ${scenarioName}`);
          
          // Group actions into logical steps
          let stepCounter = 0;
          
          for (let i = 0; i < actions.length; i++) {
            const action = actions[i];
            let step = '';
            
            switch (action.type) {
              case 'navigate':
                step = `    Given I navigate to the application`;
                break;
              
              case 'click':
                step = `    When I click on the element`;
                break;
              
              case 'type':
                step = `    When I enter text into the field`;
                break;
              
              case 'select':
                step = `    When I select an option from the dropdown`;
                break;
              
              case 'assertion':
                step = `    Then I should see the expected result`;
                break;
              
              default:
                step = `    And I perform action ${++stepCounter}`;
            }
            
            feature.push(step);
          }
          
          return feature.join('\n') + '\n';
        }
      }
    },
    
    typescript: {
      testng: {
        fileExtension: '.ts',
        
        generateImports: function(actions, options) {
          return [
            'import { Builder, By, Key, until, WebDriver, WebElement, Actions } from "selenium-webdriver";',
            'import { CSTestForgeConfig } from "../config/CSTestForgeConfig";',
            'import { CSScreenshotManager } from "../utils/CSScreenshotManager";',
            'import { CSElement } from "../core/CSElement";',
            'import { CSWaitStrategy } from "../core/CSWaitStrategy";',
            'import { CSVisibilityWait } from "../core/CSVisibilityWait";',
            'import { CSClickableWait } from "../core/CSClickableWait";',
            ''
          ].join('\n');
        },
        
        generateClassStart: function(className, options) {
          return [
            '/**',
            ' * Generated test class for ' + className,
            ' * Generated by CSTestForge Recorder',
            ' */',
            'export class ' + className + ' {',
            '    private driver: WebDriver;',
            '    private actions: Actions;',
            '',
            '    /**',
            '     * Set up test environment before each test',
            '     */',
            '    async before(): Promise<void> {',
            '        this.driver = await new Builder()',
            '            .forBrowser(CSTestForgeConfig.browser)',
            '            .build();',
            '        this.actions = new Actions(this.driver);',
            '    }',
            '',
            '    /**',
            '     * Tear down test environment after each test',
            '     */',
            '    async after(): Promise<void> {',
            '        if (this.driver) {',
            '            await this.driver.quit();',
            '        }',
            '    }',
            ''
          ].join('\n');
        },
        
        generateMethodStart: function(methodName, options) {
          return [
            '    /**',
            '     * ' + methodName,
            '     */',
            '    async ' + methodName + '(): Promise<void> {',
            '        try {',
            '            await this.before();',
            ''
          ].join('\n');
        },
        
        generateMethodEnd: function(options) {
          return [
            '',
            '        } finally {',
            '            await this.after();',
            '        }',
            '    }',
            ''
          ].join('\n');
        },
        
        generateClassEnd: function(options) {
          return '}\n';
        },
        
        formatAction: function(action, index, options) {
          const indent = '            ';
          let code = '';
          
          switch (action.type) {
            case 'navigate':
              code = `await this.driver.get("${action.url}");`;
              break;
            
            case 'click':
              if (action.useJS) {
                code = `await this.driver.executeScript("arguments[0].click();", await this.driver.findElement(${this.formatLocator(action.locator)}));`;
              } else {
                code = `await this.driver.findElement(${this.formatLocator(action.locator)}).click();`;
              }
              break;
            
            case 'doubleClick':
              code = `await this.actions.doubleClick(await this.driver.findElement(${this.formatLocator(action.locator)})).perform();`;
              break;
            
            case 'rightClick':
              code = `await this.actions.contextClick(await this.driver.findElement(${this.formatLocator(action.locator)})).perform();`;
              break;
            
            case 'type':
              if (action.clearFirst) {
                code = [
                  `const element = await this.driver.findElement(${this.formatLocator(action.locator)});`,
                  `await element.clear();`,
                  `await element.sendKeys("${this.escapeString(action.text)}");`
                ].join('\n' + indent);
              } else {
                code = `await this.driver.findElement(${this.formatLocator(action.locator)}).sendKeys("${this.escapeString(action.text)}");`;
              }
              break;
            
            case 'clear':
              code = `await this.driver.findElement(${this.formatLocator(action.locator)}).clear();`;
              break;
            
            case 'select':
              // In TypeScript WebDriver, there's no Select class, so we need to use JavaScript
              if (action.byIndex !== undefined) {
                code = `await this.driver.executeScript("arguments[0].selectedIndex = ${action.byIndex}; arguments[0].dispatchEvent(new Event('change'));", await this.driver.findElement(${this.formatLocator(action.locator)}));`;
              } else if (action.byValue !== undefined) {
                code = `await this.driver.executeScript("Array.from(arguments[0].options).find(o => o.value === '${this.escapeString(action.byValue)}').selected = true; arguments[0].dispatchEvent(new Event('change'));", await this.driver.findElement(${this.formatLocator(action.locator)}));`;
              } else if (action.byText !== undefined) {
                code = `await this.driver.executeScript("Array.from(arguments[0].options).find(o => o.text === '${this.escapeString(action.byText)}').selected = true; arguments[0].dispatchEvent(new Event('change'));", await this.driver.findElement(${this.formatLocator(action.locator)}));`;
              }
              break;
            
            case 'check':
              code = [
                `const element = await this.driver.findElement(${this.formatLocator(action.locator)});`,
                `if (!(await element.isSelected())) {`,
                `    await element.click();`,
                `}`
              ].join('\n' + indent);
              break;
            
            case 'uncheck':
              code = [
                `const element = await this.driver.findElement(${this.formatLocator(action.locator)});`,
                `if (await element.isSelected()) {`,
                `    await element.click();`,
                `}`
              ].join('\n' + indent);
              break;
            
            case 'hover':
              code = `await this.actions.move({ origin: await this.driver.findElement(${this.formatLocator(action.locator)}) }).perform();`;
              break;
            
            case 'dragAndDrop':
              code = `await this.actions.dragAndDrop(await this.driver.findElement(${this.formatLocator(action.sourceLocator)}), await this.driver.findElement(${this.formatLocator(action.targetLocator)})).perform();`;
              break;
            
            case 'wait':
              if (action.waitType === 'visibility') {
                code = `await this.driver.wait(until.elementIsVisible(await this.driver.findElement(${this.formatLocator(action.locator)})), ${action.timeout || 30000});`;
              } else if (action.waitType === 'clickable') {
                code = `await this.driver.wait(until.elementIsEnabled(await this.driver.findElement(${this.formatLocator(action.locator)})), ${action.timeout || 30000});`;
              } else if (action.waitType === 'presence') {
                code = `await this.driver.wait(until.elementLocated(${this.formatLocator(action.locator)}), ${action.timeout || 30000});`;
              } else if (action.waitType === 'time') {
                code = `await new Promise(resolve => setTimeout(resolve, ${action.duration}));`;
              }
              break;
            
            case 'executeScript':
              if (action.arguments && action.arguments.length > 0) {
                const args = action.arguments.map(arg => {
                  if (typeof arg === 'string') {
                    return `"${this.escapeString(arg)}"`;
                  } else if (arg === null) {
                    return 'null';
                  } else if (typeof arg === 'object' && arg.type === 'element') {
                    return `await this.driver.findElement(${this.formatLocator(arg.locator)})`;
                  }
                  return String(arg);
                }).join(', ');
                
                code = `await this.driver.executeScript("${this.escapeString(action.script)}", ${args});`;
              } else {
                code = `await this.driver.executeScript("${this.escapeString(action.script)}");`;
              }
              break;
            
            case 'assertion':
              if (action.assertType === 'equals') {
                code = `expect(await (await this.driver.findElement(${this.formatLocator(action.locator)})).getAttribute("${action.property}")).toBe("${this.escapeString(action.expectedValue)}");`;
              } else if (action.assertType === 'contains') {
                code = `expect(await (await this.driver.findElement(${this.formatLocator(action.locator)})).getAttribute("${action.property}")).toContain("${this.escapeString(action.expectedValue)}");`;
              } else if (action.assertType === 'selected') {
                code = `expect(await (await this.driver.findElement(${this.formatLocator(action.locator)})).isSelected()).toBe(true);`;
              } else if (action.assertType === 'notSelected') {
                code = `expect(await (await this.driver.findElement(${this.formatLocator(action.locator)})).isSelected()).toBe(false);`;
              } else if (action.assertType === 'exists') {
                code = `expect(await this.driver.findElements(${this.formatLocator(action.locator)})).toHaveLength(1);`;
              } else if (action.assertType === 'notExists') {
                code = `expect(await this.driver.findElements(${this.formatLocator(action.locator)})).toHaveLength(0);`;
              }
              break;
            
            case 'screenshot':
              code = `await CSScreenshotManager.takeScreenshot(this.driver, "${action.name || 'screenshot_' + index}");`;
              break;
            
            case 'switchToFrame':
              if (action.nameOrId) {
                code = `await this.driver.switchTo().frame("${this.escapeString(action.nameOrId)}");`;
              } else if (action.index !== undefined) {
                code = `await this.driver.switchTo().frame(${action.index});`;
              } else if (action.locator) {
                code = `await this.driver.switchTo().frame(await this.driver.findElement(${this.formatLocator(action.locator)}));`;
              }
              break;
            
            case 'switchToDefaultContent':
              code = `await this.driver.switchTo().defaultContent();`;
              break;
            
            case 'switchToWindow':
              if (action.nameOrHandle) {
                code = `await this.driver.switchTo().window("${this.escapeString(action.nameOrHandle)}");`;
              } else if (action.index !== undefined) {
                code = [
                  `const handles = await this.driver.getAllWindowHandles();`,
                  `await this.driver.switchTo().window(handles[${action.index}]);`
                ].join('\n' + indent);
              }
              break;
            
            case 'keyPress':
              if (action.key === 'Enter') {
                code = `await this.driver.findElement(${this.formatLocator(action.locator)}).sendKeys(Key.ENTER);`;
              } else if (action.key === 'Tab') {
                code = `await this.driver.findElement(${this.formatLocator(action.locator)}).sendKeys(Key.TAB);`;
              } else if (action.key === 'Escape') {
                code = `await this.driver.findElement(${this.formatLocator(action.locator)}).sendKeys(Key.ESCAPE);`;
              } else {
                code = `await this.driver.findElement(${this.formatLocator(action.locator)}).sendKeys(Key.${action.key.toUpperCase()});`;
              }
              break;
            
            case 'comment':
              code = `// ${action.text}`;
              break;
            
            default:
              code = `// Unsupported action type: ${action.type}`;
          }
          
          return indent + code;
        },
        
        formatLocator: function(locator) {
          switch (locator.type) {
            case 'id':
              return `By.id("${this.escapeString(locator.value)}")`;
            case 'name':
              return `By.name("${this.escapeString(locator.value)}")`;
            case 'className':
              return `By.className("${this.escapeString(locator.value)}")`;
            case 'tagName':
              return `By.tagName("${this.escapeString(locator.value)}")`;
            case 'linkText':
              return `By.linkText("${this.escapeString(locator.value)}")`;
            case 'partialLinkText':
              return `By.partialLinkText("${this.escapeString(locator.value)}")`;
            case 'css':
              return `By.css("${this.escapeString(locator.value)}")`;
            case 'xpath':
              return `By.xpath("${this.escapeString(locator.value)}")`;
            default:
              return `By.id("unknown-locator-type")`;
          }
        },
        
        escapeString: function(str) {
          if (typeof str !== 'string') {
            return str;
          }
          return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
        }
      },
      
      bdd: {
        fileExtension: '.ts',
        
        generateImports: function(actions, options) {
          return [
            'import { Given, When, Then } from "@cucumber/cucumber";',
            'import { Builder, By, Key, until, WebDriver, WebElement, Actions } from "selenium-webdriver";',
            'import { CSTestForgeWorld } from "../support/CSTestForgeWorld";',
            'import { CSScreenshotManager } from "../utils/CSScreenshotManager";',
            'import { CSElement } from "../core/CSElement";',
            'import { CSWaitStrategy } from "../core/CSWaitStrategy";',
            'import { CSVisibilityWait } from "../core/CSVisibilityWait";',
            'import { CSClickableWait } from "../core/CSClickableWait";',
            'import { expect } from "chai";',
            ''
          ].join('\n');
        },
        
        generateStepDefinitions: function(actions, options) {
          let stepDefs = [];
          
          // Generate step definitions based on actions
          for (let i = 0; i < actions.length; i++) {
            const action = actions[i];
            let stepDef = '';
            
            switch (action.type) {
              case 'navigate':
                stepDef = [
                  `Given('I navigate to {string}', async function(this: CSTestForgeWorld, url: string) {`,
                  `    await this.driver.get(url);`,
                  `});`,
                  ``,
                  `Given('I navigate to the application', async function(this: CSTestForgeWorld) {`,
                  `    await this.driver.get("${action.url}");`,
                  `});`,
                  ``
                ].join('\n');
                break;
              
              case 'click':
                stepDef = [
                  `When('I click on element {string}', async function(this: CSTestForgeWorld, locator: string) {`,
                  `    await this.driver.findElement(By.css(locator)).click();`,
                  `});`,
                  ``,
                  `When('I click on the element', async function(this: CSTestForgeWorld) {`,
                  `    await this.driver.findElement(${this.formatLocator(action.locator)}).click();`,
                  `});`,
                  ``
                ].join('\n');
                break;
              
              // More step definitions would be added for other action types...
              
              default:
                // Skip comments and unsupported actions
                if (action.type === 'comment') {
                  continue;
                }
            }
            
            if (stepDef) {
              stepDefs.push(stepDef);
            }
          }
          
          return stepDefs.join('\n');
        },
        
        formatLocator: function(locator) {
          switch (locator.type) {
            case 'id':
              return `By.id("${this.escapeString(locator.value)}")`;
            case 'name':
              return `By.name("${this.escapeString(locator.value)}")`;
            case 'className':
              return `By.className("${this.escapeString(locator.value)}")`;
            case 'tagName':
              return `By.tagName("${this.escapeString(locator.value)}")`;
            case 'linkText':
              return `By.linkText("${this.escapeString(locator.value)}")`;
            case 'partialLinkText':
              return `By.partialLinkText("${this.escapeString(locator.value)}")`;
            case 'css':
              return `By.css("${this.escapeString(locator.value)}")`;
            case 'xpath':
              return `By.xpath("${this.escapeString(locator.value)}")`;
            default:
              return `By.id("unknown-locator-type")`;
          }
        },
        
        escapeString: function(str) {
          if (typeof str !== 'string') {
            return str;
          }
          return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
        },
        
        generateFeatureFile: function(className, actions, options) {
          // Generate Cucumber feature file content
          const featureName = className.replace(/([A-Z])/g, ' $1').trim();
          
          let feature = [
            `Feature: ${featureName}`,
            `  As a user`,
            `  I want to use the application`,
            `  So that I can complete my tasks`,
            ``
          ];
          
          const scenarioName = options.scenarioName || 'Use the application';
          feature.push(`  Scenario: ${scenarioName}`);
          
          // Group actions into logical steps
          let stepCounter = 0;
          
          for (let i = 0; i < actions.length; i++) {
            const action = actions[i];
            let step = '';
            
            switch (action.type) {
              case 'navigate':
                step = `    Given I navigate to the application`;
                break;
              
              case 'click':
                step = `    When I click on the element`;
                break;
              
              case 'type':
                step = `    When I enter text into the field`;
                break;
              
              case 'select':
                step = `    When I select an option from the dropdown`;
                break;
              
              case 'assertion':
                step = `    Then I should see the expected result`;
                break;
              
              default:
                step = `    And I perform action ${++stepCounter}`;
            }
            
            feature.push(step);
          }
          
          return feature.join('\n') + '\n';
        }
      }
    }
  };
  
  /**
   * Converts recorded actions to code in specified language and framework
   * 
   * @param {Object} options Configuration options
   * @param {Array} options.actions Array of recorded actions
   * @param {string} options.language Target language ('java' or 'typescript')
   * @param {string} options.framework Target framework ('testng' or 'bdd')
   * @param {string} options.className Name of the generated class
   * @param {string} options.testMethodName Name of the generated test method
   * @param {Object} options.customOptions Additional options for specific formatters
   * @returns {Object} Generated code files
   */
  function convertActionsToCode(options) {
    const actions = options.actions || [];
    const language = options.language || 'java';
    const framework = options.framework || 'testng';
    const className = options.className || 'GeneratedTest';
    const testMethodName = options.testMethodName || 'generatedTest';
    const customOptions = options.customOptions || {};
    
    // Get the appropriate formatter
    const formatter = formatters[language] && formatters[language][framework];
    
    if (!formatter) {
      throw new Error(`Unsupported language/framework combination: ${language}/${framework}`);
    }
    
    // Generate code
    let mainCode = '';
    let additionalFiles = {};
    
    // Add imports
    mainCode += formatter.generateImports(actions, customOptions) + '\n\n';
    
    // Start class definition
    mainCode += formatter.generateClassStart(className, customOptions) + '\n';
    
    // For TestNG style, generate a test method
    if (framework === 'testng') {
      mainCode += formatter.generateMethodStart(testMethodName, customOptions) + '\n';
      
      // Add actions
      for (let i = 0; i < actions.length; i++) {
        mainCode += formatter.formatAction(actions[i], i, customOptions) + '\n';
      }
      
      // End method definition
      mainCode += formatter.generateMethodEnd(customOptions);
    } else if (framework === 'bdd') {
      // For BDD style, generate step definitions for each action
      for (let i = 0; i < actions.length; i++) {
        mainCode += formatter.formatAction(actions[i], i, customOptions) + '\n\n';
      }
    }
    
    // End class definition
    mainCode += formatter.generateClassEnd(customOptions);
    
    // For BDD, also generate a feature file
    if (framework === 'bdd') {
      const featureFileName = `${className.toLowerCase()}.feature`;
      additionalFiles[featureFileName] = formatter.generateFeatureFile(className, actions, customOptions);
    }
    
    return {
      mainFile: {
        name: `${className}${framework === 'bdd' ? 'Steps' : ''}${formatter.fileExtension}`,
        content: mainCode
      },
      additionalFiles: additionalFiles
    };
  }
  
  /**
   * Enhances recorded actions with smart locator selection
   * 
   * @param {Array} actions Array of recorded actions
   * @param {Object} options Configuration options
   * @returns {Array} Enhanced actions
   */
  function enhanceActionsWithSmartLocators(actions, options) {
    return actions.map(action => {
      // Clone the action to avoid modifying the original
      const enhancedAction = { ...action };
      
      // Enhance locators if present
      if (enhancedAction.locator) {
        enhancedAction.locator = selectBestLocator(enhancedAction.locator, options);
      }
      
      if (enhancedAction.sourceLocator) {
        enhancedAction.sourceLocator = selectBestLocator(enhancedAction.sourceLocator, options);
      }
      
      if (enhancedAction.targetLocator) {
        enhancedAction.targetLocator = selectBestLocator(enhancedAction.targetLocator, options);
      }
      
      return enhancedAction;
    });
  }
  
  /**
   * Selects the best locator strategy from available options
   * 
   * @param {Object} locators Available locators
   * @param {Object} options Configuration options
   * @returns {Object} Best locator
   */
  function selectBestLocator(locators, options) {
    // If locator is already in the desired format, return it
    if (typeof locators === 'object' && locators.type && locators.value) {
      return locators;
    }
    
    // Convert to object if it's an array
    const locatorOptions = Array.isArray(locators) ? 
      locators.reduce((obj, loc) => {
        if (loc.type && loc.value) obj[loc.type] = loc.value;
        return obj;
      }, {}) : 
      (locators || {});
    
    // Priority order for selecting locators
    const priorityOrder = [
      'id',
      'name',
      'css',
      'xpath',
      'linkText',
      'partialLinkText',
      'className',
      'tagName'
    ];
    
    // Additional points for preferred locator types
    const scoreAdjustments = {
      id: 10,         // ID is most stable
      name: 8,        // Name is quite stable
      css: 5,         // CSS is good for shorter selectors
      xpath: 3,       // XPath is powerful but can be fragile
      linkText: 7,    // Link text is good for links
      partialLinkText: 6,
      className: 2,    // Class names can change
      tagName: 0      // Tag names are too generic
    };
    
    // Score each locator type
    const scores = {};
    
    for (const type in locatorOptions) {
      if (locatorOptions.hasOwnProperty(type)) {
        const value = locatorOptions[type];
        
        // Base score from priority
        const priorityIndex = priorityOrder.indexOf(type);
        let score = priorityIndex >= 0 ? (priorityOrder.length - priorityIndex) : 0;
        
        // Add score adjustments
        score += scoreAdjustments[type] || 0;
        
        // Penalize overly complex locators
        if (value && typeof value === 'string') {
          // Penalize very long locators
          if (value.length > 100) {
            score -= 3;
          } else if (value.length > 50) {
            score -= 1;
          }
          
          // Penalize dynamic IDs or overly specific patterns (common in React, Angular)
          if ((type === 'id' || type === 'className') && 
              (value.match(/[0-9]{3,}/) || value.match(/[a-z][0-9]{2,}/i))) {
            score -= 5;
          }
          
          // Penalize complex XPaths with many predicates
          if (type === 'xpath' && (value.match(/\[/g) || []).length > 3) {
            score -= 2;
          }
          
          // Penalize CSS selectors with too many class components
          if (type === 'css' && (value.match(/\./g) || []).length > 3) {
            score -= 2;
          }
        }
        
        scores[type] = score;
      }
    }
    
    // Find the highest-scoring locator type
    let bestType = null;
    let bestScore = -1;
    
    for (const type in scores) {
      if (scores.hasOwnProperty(type) && scores[type] > bestScore) {
        bestScore = scores[type];
        bestType = type;
      }
    }
    
    // Return the best locator, or default to id if none found
    if (bestType && locatorOptions[bestType]) {
      return {
        type: bestType,
        value: locatorOptions[bestType]
      };
    }
    
    // Fallback to first available locator
    for (const type in locatorOptions) {
      if (locatorOptions.hasOwnProperty(type) && locatorOptions[type]) {
        return {
          type: type,
          value: locatorOptions[type]
        };
      }
    }
    
    // Ultimate fallback
    return {
      type: 'id',
      value: 'unknown-element'
    };
  }
  
  /**
   * Optimizes actions by consolidating similar consecutive actions
   * 
   * @param {Array} actions Array of recorded actions
   * @param {Object} options Configuration options
   * @returns {Array} Optimized actions
   */
  function optimizeActions(actions, options) {
    if (!actions || !actions.length) {
      return [];
    }
    
    const optimized = [];
    let skipNext = false;
    
    for (let i = 0; i < actions.length; i++) {
      if (skipNext) {
        skipNext = false;
        continue;
      }
      
      const current = actions[i];
      const next = i < actions.length - 1 ? actions[i + 1] : null;
      
      // Check if current and next actions can be combined
      if (next) {
        // Combine clear + type into a single action
        if (current.type === 'clear' && next.type === 'type' && 
            areLocatorsEqual(current.locator, next.locator)) {
          optimized.push({
            ...next,
            clearFirst: true
          });
          skipNext = true;
          continue;
        }
        
        // Combine consecutive waits into a single longer wait
        if (current.type === 'wait' && next.type === 'wait' && 
            current.waitType === 'time' && next.waitType === 'time') {
          optimized.push({
            type: 'wait',
            waitType: 'time',
            duration: (current.duration || 0) + (next.duration || 0)
          });
          skipNext = true;
          continue;
        }
      }
      
      // If no combination was made, add the current action
      optimized.push(current);
    }
    
    return optimized;
  }
  
  /**
   * Check if two locators are equal
   * 
   * @param {Object} locator1 First locator
   * @param {Object} locator2 Second locator
   * @returns {boolean} Whether the locators are equal
   */
  function areLocatorsEqual(locator1, locator2) {
    if (!locator1 || !locator2) {
      return false;
    }
    
    return locator1.type === locator2.type && locator1.value === locator2.value;
  }
  
  /**
   * Add assertions based on the application state after each action
   * 
   * @param {Array} actions Array of recorded actions
   * @param {Array} states Array of application states after each action
   * @param {Object} options Configuration options
   * @returns {Array} Actions with added assertions
   */
  function addAssertions(actions, states, options) {
    if (!actions || !actions.length || !states || !states.length) {
      return actions;
    }
    
    const result = [];
    
    for (let i = 0; i < actions.length; i++) {
      // Add the original action
      result.push(actions[i]);
      
      // Check if there's a state for this action
      if (states[i]) {
        const state = states[i];
        
        // Add assertions based on the current state
        const possibleAssertions = generateAssertionsFromState(state, actions[i]);
        
        // Add significant assertions
        for (const assertion of possibleAssertions) {
          if (isSignificantAssertion(assertion, actions[i])) {
            result.push(assertion);
          }
        }
      }
    }
    
    return result;
  }
  
  /**
   * Generate possible assertions based on application state
   * 
   * @param {Object} state Application state
   * @param {Object} precedingAction Action that led to this state
   * @returns {Array} Possible assertions
   */
  function generateAssertionsFromState(state, precedingAction) {
    const assertions = [];
    
    // Check for page title or URL changes
    if (state.title) {
      assertions.push({
        type: 'assertion',
        assertType: 'equals',
        locator: {
          type: 'css',
          value: 'title'
        },
        property: 'text',
        expectedValue: state.title
      });
    }
    
    if (state.url && precedingAction.type === 'navigate') {
      assertions.push({
        type: 'assertion',
        assertType: 'equals',
        description: 'Assert navigation to correct URL',
        customCode: {
          java: `Assert.assertEquals(driver.getCurrentUrl(), "${state.url}");`,
          typescript: `expect(await driver.getCurrentUrl()).toBe("${state.url}");`
        }
      });
    }
    
    // Check element visibility or state changes based on the action
    if (precedingAction.type === 'click' && precedingAction.locator) {
      if (state.visibleElements && state.visibleElements.length > 0) {
        const newlyVisibleElement = state.visibleElements[0];
        assertions.push({
          type: 'assertion',
          assertType: 'exists',
          locator: newlyVisibleElement.locator
        });
      }
    }
    
    // Check for form submission results
    if (precedingAction.type === 'submit') {
      if (state.errors && state.errors.length > 0) {
        const error = state.errors[0];
        assertions.push({
          type: 'assertion',
          assertType: 'exists',
          locator: error.locator,
          description: 'Assert error message appears'
        });
      } else if (state.success) {
        assertions.push({
          type: 'assertion',
          assertType: 'exists',
          locator: state.success.locator,
          description: 'Assert success message appears'
        });
      }
    }
    
    return assertions;
  }
  
  /**
   * Determine if an assertion is significant enough to include
   * 
   * @param {Object} assertion Assertion to check
   * @param {Object} precedingAction Action preceding the assertion
   * @returns {boolean} Whether the assertion is significant
   */
  function isSignificantAssertion(assertion, precedingAction) {
    // Always include assertions that have explicit descriptions
    if (assertion.description) {
      return true;
    }
    
    // Title assertions are usually significant
    if (assertion.locator && assertion.locator.type === 'css' && assertion.locator.value === 'title') {
      return true;
    }
    
    // URL assertions after navigation are significant
    if (assertion.customCode && assertion.customCode.java && assertion.customCode.java.includes('getCurrentUrl()')) {
      return true;
    }
    
    // For element state assertions, only include if they provide value
    if (assertion.assertType === 'exists' || assertion.assertType === 'notExists') {
      // Check if this is not just asserting the same element from the action exists
      if (precedingAction.locator && assertion.locator && 
          areLocatorsEqual(precedingAction.locator, assertion.locator)) {
        return false;
      }
      return true;
    }
    
    // By default, include the assertion
    return true;
  }
  
  /**
   * Add setup and teardown code based on the recording environment
   * 
   * @param {Array} actions Array of recorded actions
   * @param {Object} environment Recording environment information
   * @param {Object} options Configuration options
   * @returns {Object} Actions with setup/teardown code
   */
  function addSetupAndTeardown(actions, environment, options) {
    const language = options.language || 'java';
    const framework = options.framework || 'testng';
    
    // Get browser details from the environment
    const browser = environment?.browser?.name?.toLowerCase() || 'chrome';
    const browserVersion = environment?.browser?.version;
    const platform = environment?.platform?.name?.toLowerCase() || 'any';
    
    // Default setup/teardown code
    let setupCode = [];
    let teardownCode = [];
    
    if (language === 'java') {
      setupCode = [
        'driver = getDriver();',
        'wait = new WebDriverWait(driver, Duration.ofSeconds(30));',
        'js = (JavascriptExecutor) driver;',
        'actions = new Actions(driver);'
      ];
      
      teardownCode = [
        'if (driver != null) {',
        '    driver.quit();',
        '}'
      ];
    } else if (language === 'typescript') {
      setupCode = [
        'this.driver = await new Builder()',
        '    .forBrowser(CSTestForgeConfig.browser)',
        '    .build();',
        'this.actions = new Actions(this.driver);'
      ];
      
      teardownCode = [
        'if (this.driver) {',
        '    await this.driver.quit();',
        '}'
      ];
    }
    
    // Add environment-specific customizations
    if (browser === 'chrome') {
      if (language === 'java') {
        setupCode = [
          'ChromeOptions options = new ChromeOptions();',
          '// Add Chrome-specific options',
          'options.addArguments("--no-sandbox");',
          'options.addArguments("--disable-dev-shm-usage");',
          'driver = new ChromeDriver(options);',
          'wait = new WebDriverWait(driver, Duration.ofSeconds(30));',
          'js = (JavascriptExecutor) driver;',
          'actions = new Actions(driver);'
        ];
      } else if (language === 'typescript') {
        setupCode = [
          'const options = new chrome.Options();',
          '// Add Chrome-specific options',
          'options.addArguments("--no-sandbox");',
          'options.addArguments("--disable-dev-shm-usage");',
          'this.driver = await new Builder()',
          '    .forBrowser("chrome")',
          '    .setChromeOptions(options)',
          '    .build();',
          'this.actions = new Actions(this.driver);'
        ];
      }
    } else if (browser === 'firefox') {
      if (language === 'java') {
        setupCode = [
          'FirefoxOptions options = new FirefoxOptions();',
          '// Add Firefox-specific options',
          'driver = new FirefoxDriver(options);',
          'wait = new WebDriverWait(driver, Duration.ofSeconds(30));',
          'js = (JavascriptExecutor) driver;',
          'actions = new Actions(driver);'
        ];
      } else if (language === 'typescript') {
        setupCode = [
          'const options = new firefox.Options();',
          '// Add Firefox-specific options',
          'this.driver = await new Builder()',
          '    .forBrowser("firefox")',
          '    .setFirefoxOptions(options)',
          '    .build();',
          'this.actions = new Actions(this.driver);'
        ];
      }
    }
    
    // Platform-specific adjustments
    if (platform === 'windows') {
      if (browser === 'edge') {
        if (language === 'java') {
          setupCode = [
            'EdgeOptions options = new EdgeOptions();',
            '// Add Edge-specific options',
            'driver = new EdgeDriver(options);',
            'wait = new WebDriverWait(driver, Duration.ofSeconds(30));',
            'js = (JavascriptExecutor) driver;',
            'actions = new Actions(driver);'
          ];
        } else if (language === 'typescript') {
          setupCode = [
            'const options = new edge.Options();',
            '// Add Edge-specific options',
            'this.driver = await new Builder()',
            '    .forBrowser("MicrosoftEdge")',
            '    .setEdgeOptions(options)',
            '    .build();',
            'this.actions = new Actions(this.driver);'
          ];
        }
      }
    } else if (platform === 'mac') {
      if (browser === 'safari') {
        if (language === 'java') {
          setupCode = [
            'SafariOptions options = new SafariOptions();',
            '// Add Safari-specific options',
            'driver = new SafariDriver(options);',
            'wait = new WebDriverWait(driver, Duration.ofSeconds(30));',
            'js = (JavascriptExecutor) driver;',
            'actions = new Actions(driver);'
          ];
        } else if (language === 'typescript') {
          setupCode = [
            'const options = new safari.Options();',
            '// Add Safari-specific options',
            'this.driver = await new Builder()',
            '    .forBrowser("safari")',
            '    .setSafariOptions(options)',
            '    .build();',
            'this.actions = new Actions(this.driver);'
          ];
        }
      }
    }
    
    // Enable specific imports based on browser
    const imports = getImportsForBrowser(browser, language);
    
    return {
      actions,
      setup: setupCode.join('\n'),
      teardown: teardownCode.join('\n'),
      imports
    };
  }
  
  /**
   * Get required imports for specific browser
   * 
   * @param {string} browser Browser name
   * @param {string} language Target language
   * @returns {Array} Required imports
   */
  function getImportsForBrowser(browser, language) {
    const imports = [];
    
    if (language === 'java') {
      if (browser === 'chrome') {
        imports.push('import org.openqa.selenium.chrome.ChromeDriver;');
        imports.push('import org.openqa.selenium.chrome.ChromeOptions;');
      } else if (browser === 'firefox') {
        imports.push('import org.openqa.selenium.firefox.FirefoxDriver;');
        imports.push('import org.openqa.selenium.firefox.FirefoxOptions;');
      } else if (browser === 'edge') {
        imports.push('import org.openqa.selenium.edge.EdgeDriver;');
        imports.push('import org.openqa.selenium.edge.EdgeOptions;');
      } else if (browser === 'safari') {
        imports.push('import org.openqa.selenium.safari.SafariDriver;');
        imports.push('import org.openqa.selenium.safari.SafariOptions;');
      }
    } else if (language === 'typescript') {
      if (browser === 'chrome') {
        imports.push('import { Options as ChromeOptions } from "selenium-webdriver/chrome";');
        imports.push('import chrome from "selenium-webdriver/chrome";');
      } else if (browser === 'firefox') {
        imports.push('import { Options as FirefoxOptions } from "selenium-webdriver/firefox";');
        imports.push('import firefox from "selenium-webdriver/firefox";');
      } else if (browser === 'edge') {
        imports.push('import { Options as EdgeOptions } from "selenium-webdriver/edge";');
        imports.push('import edge from "selenium-webdriver/edge";');
      } else if (browser === 'safari') {
        imports.push('import { Options as SafariOptions } from "selenium-webdriver/safari";');
        imports.push('import safari from "selenium-webdriver/safari";');
      }
    }
    
    return imports;
  }
  
  // Export the public API
  window.CSTestForgeSeleniumActionConverter = {
    convertActionsToCode,
    enhanceActionsWithSmartLocators,
    optimizeActions,
    addAssertions,
    addSetupAndTeardown
  };
})();


recorder/playwright/action-converter.js
-------------------------------------------------

/**
 * CSTestForge Playwright Action Converter
 * 
 * Converts recorded browser actions into Playwright code for Java and TypeScript.
 * Handles both TestNG and BDD (Cucumber) test patterns.
 */

(function() {
  // Language and framework-specific formatters
  const formatters = {
    java: {
      testng: {
        fileExtension: '.java',
        
        generateImports: function(actions, options) {
          return [
            'import org.testng.annotations.Test;',
            'import org.testng.annotations.BeforeMethod;',
            'import org.testng.annotations.AfterMethod;',
            'import org.testng.Assert;',
            'import com.microsoft.playwright.Browser;',
            'import com.microsoft.playwright.BrowserContext;',
            'import com.microsoft.playwright.BrowserType;',
            'import com.microsoft.playwright.Locator;',
            'import com.microsoft.playwright.Page;',
            'import com.microsoft.playwright.Playwright;',
            'import com.microsoft.playwright.options.AriaRole;',
            'import com.microsoft.playwright.options.LoadState;',
            'import java.nio.file.Paths;',
            'import java.util.List;',
            '',
            'import com.cstestforge.framework.core.utils.CSScreenshotManager;',
            'import com.cstestforge.framework.playwright.CSBaseTest;',
            'import com.cstestforge.framework.playwright.CSElement;',
            'import com.cstestforge.framework.playwright.CSWaitStrategy;',
            'import com.cstestforge.framework.playwright.CSVisibilityWait;',
            'import com.cstestforge.framework.playwright.CSClickableWait;'
          ].join('\n');
        },
        
        generateClassStart: function(className, options) {
          return [
            '/**',
            ' * Generated test class for ' + className,
            ' * Generated by CSTestForge Recorder',
            ' */',
            'public class ' + className + ' extends CSBaseTest {',
            '',
            '    private Playwright playwright;',
            '    private Browser browser;',
            '    private BrowserContext context;',
            '    private Page page;',
            '',
            '    @BeforeMethod',
            '    public void setUp() {',
            '        playwright = Playwright.create();',
            '        browser = playwright.chromium().launch();',
            '        context = browser.newContext();',
            '        page = context.newPage();',
            '    }',
            '',
            '    @AfterMethod',
            '    public void tearDown() {',
            '        if (page != null) {',
            '            page.close();',
            '        }',
            '        if (context != null) {',
            '            context.close();',
            '        }',
            '        if (browser != null) {',
            '            browser.close();',
            '        }',
            '        if (playwright != null) {',
            '            playwright.close();',
            '        }',
            '    }',
            ''
          ].join('\n');
        },
        
        generateMethodStart: function(methodName, options) {
          return [
            '    @Test',
            '    public void ' + methodName + '() {',
            ''
          ].join('\n');
        },
        
        generateMethodEnd: function(options) {
          return '    }\n';
        },
        
        generateClassEnd: function(options) {
          return '}\n';
        },
        
        formatAction: function(action, index, options) {
          const indent = '        ';
          let code = '';
          
          switch (action.type) {
            case 'navigate':
              code = `page.navigate("${action.url}");`;
              break;
            
            case 'click':
              if (action.useJS) {
                code = `page.evaluate("document.querySelector('${this.escapeString(this.convertLocatorToCSS(action.locator))}').click()");`;
              } else {
                code = `page.locator(${this.formatLocator(action.locator)}).click();`;
              }
              break;
            
            case 'doubleClick':
              code = `page.locator(${this.formatLocator(action.locator)}).dblclick();`;
              break;
            
            case 'rightClick':
              code = `page.locator(${this.formatLocator(action.locator)}).click(new Locator.ClickOptions().setButton(MouseButton.RIGHT));`;
              break;
            
            case 'type':
              if (action.clearFirst) {
                code = [
                  `page.locator(${this.formatLocator(action.locator)}).clear();`,
                  `page.locator(${this.formatLocator(action.locator)}).fill("${this.escapeString(action.text)}");`
                ].join('\n' + indent);
              } else {
                code = `page.locator(${this.formatLocator(action.locator)}).fill("${this.escapeString(action.text)}");`;
              }
              break;
            
            case 'clear':
              code = `page.locator(${this.formatLocator(action.locator)}).clear();`;
              break;
            
            case 'select':
              if (action.byIndex !== undefined) {
                code = `page.locator(${this.formatLocator(action.locator)}).selectOption(new SelectOption().setIndex(${action.byIndex}));`;
              } else if (action.byValue !== undefined) {
                code = `page.locator(${this.formatLocator(action.locator)}).selectOption("${this.escapeString(action.byValue)}");`;
              } else if (action.byText !== undefined) {
                code = `page.locator(${this.formatLocator(action.locator)}).selectOption(new SelectOption().setLabel("${this.escapeString(action.byText)}"));`;
              }
              break;
            
            case 'check':
              code = `page.locator(${this.formatLocator(action.locator)}).check();`;
              break;
            
            case 'uncheck':
              code = `page.locator(${this.formatLocator(action.locator)}).uncheck();`;
              break;
            
            case 'hover':
              code = `page.locator(${this.formatLocator(action.locator)}).hover();`;
              break;
            
            case 'dragAndDrop':
              code = [
                `page.locator(${this.formatLocator(action.sourceLocator)}).dragTo(`,
                `    page.locator(${this.formatLocator(action.targetLocator)})`,
                `);`
              ].join('\n' + indent);
              break;
            
            case 'wait':
              if (action.waitType === 'visibility') {
                code = `page.locator(${this.formatLocator(action.locator)}).waitFor(new Locator.WaitForOptions().setState(WaitForSelectorState.VISIBLE));`;
              } else if (action.waitType === 'clickable') {
                code = `page.locator(${this.formatLocator(action.locator)}).waitFor(new Locator.WaitForOptions().setState(WaitForSelectorState.VISIBLE));`;
              } else if (action.waitType === 'presence') {
                code = `page.locator(${this.formatLocator(action.locator)}).waitFor();`;
              } else if (action.waitType === 'time') {
                code = `page.waitForTimeout(${action.duration});`;
              } else if (action.waitType === 'load') {
                code = `page.waitForLoadState(LoadState.LOAD);`;
              } else if (action.waitType === 'networkidle') {
                code = `page.waitForLoadState(LoadState.NETWORKIDLE);`;
              } else if (action.waitType === 'domcontentloaded') {
                code = `page.waitForLoadState(LoadState.DOMCONTENTLOADED);`;
              }
              break;
            
            case 'executeScript':
              if (action.arguments && action.arguments.length > 0) {
                const args = action.arguments.map(arg => {
                  if (typeof arg === 'string') {
                    return `"${this.escapeString(arg)}"`;
                  } else if (arg === null) {
                    return 'null';
                  } else if (typeof arg === 'object' && arg.type === 'element') {
                    return `page.locator(${this.formatLocator(arg.locator)})`;
                  }
                  return String(arg);
                }).join(', ');
                
                code = `page.evaluate("${this.escapeString(action.script)}", ${args});`;
              } else {
                code = `page.evaluate("${this.escapeString(action.script)}");`;
              }
              break;
            
            case 'assertion':
              if (action.assertType === 'equals') {
                code = `Assert.assertEquals(page.locator(${this.formatLocator(action.locator)}).textContent(), "${this.escapeString(action.expectedValue)}");`;
              } else if (action.assertType === 'contains') {
                code = `Assert.assertTrue(page.locator(${this.formatLocator(action.locator)}).textContent().contains("${this.escapeString(action.expectedValue)}"));`;
              } else if (action.assertType === 'selected') {
                code = `Assert.assertTrue(page.locator(${this.formatLocator(action.locator)}).isChecked());`;
              } else if (action.assertType === 'notSelected') {
                code = `Assert.assertFalse(page.locator(${this.formatLocator(action.locator)}).isChecked());`;
              } else if (action.assertType === 'exists') {
                code = `Assert.assertTrue(page.locator(${this.formatLocator(action.locator)}).count() > 0);`;
              } else if (action.assertType === 'notExists') {
                code = `Assert.assertEquals(page.locator(${this.formatLocator(action.locator)}).count(), 0);`;
              } else if (action.assertType === 'visible') {
                code = `Assert.assertTrue(page.locator(${this.formatLocator(action.locator)}).isVisible());`;
              } else if (action.assertType === 'notVisible') {
                code = `Assert.assertFalse(page.locator(${this.formatLocator(action.locator)}).isVisible());`;
              }
              break;
            
            case 'screenshot':
              if (action.fullPage) {
                code = `page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("${action.name || 'screenshot_' + index}.png")).setFullPage(true));`;
              } else if (action.locator) {
                code = `page.locator(${this.formatLocator(action.locator)}).screenshot(new Locator.ScreenshotOptions().setPath(Paths.get("${action.name || 'screenshot_' + index}.png")));`;
              } else {
                code = `page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("${action.name || 'screenshot_' + index}.png")));`;
              }
              break;
            
            case 'switchToFrame':
              if (action.locator) {
                code = `page.frameLocator(${this.formatLocator(action.locator)});`;
              } else if (action.nameOrId) {
                code = `page.frame("${this.escapeString(action.nameOrId)}");`;
              }
              break;
            
            case 'keyPress':
              if (action.key === 'Enter') {
                code = `page.locator(${this.formatLocator(action.locator)}).press("Enter");`;
              } else if (action.key === 'Tab') {
                code = `page.locator(${this.formatLocator(action.locator)}).press("Tab");`;
              } else if (action.key === 'Escape') {
                code = `page.locator(${this.formatLocator(action.locator)}).press("Escape");`;
              } else {
                code = `page.locator(${this.formatLocator(action.locator)}).press("${action.key}");`;
              }
              break;
            
            case 'comment':
              code = `// ${action.text}`;
              break;
            
            case 'setViewport':
              code = `page.setViewportSize(${action.width}, ${action.height});`;
              break;
              
            case 'fileUpload':
              code = `page.locator(${this.formatLocator(action.locator)}).setInputFiles(Paths.get("${this.escapeString(action.filePath)}"));`;
              break;
              
            case 'focus':
              code = `page.locator(${this.formatLocator(action.locator)}).focus();`;
              break;
              
            case 'blur':
              code = `page.locator(${this.formatLocator(action.locator)}).blur();`;
              break;
            
            default:
              code = `// Unsupported action type: ${action.type}`;
          }
          
          return indent + code;
        },
        
        formatLocator: function(locator) {
          if (!locator) {
            return `"body"`;
          }
          
          switch (locator.type) {
            case 'id':
              return `"#${this.escapeString(locator.value)}"`;
            case 'name':
              return `"[name='${this.escapeString(locator.value)}']"`;
            case 'className':
              return `".${this.escapeString(locator.value)}"`;
            case 'tagName':
              return `"${this.escapeString(locator.value)}"`;
            case 'linkText':
              return `"a:has-text('${this.escapeString(locator.value)}')"`;
            case 'partialLinkText':
              return `"a:text-matches('${this.escapeString(locator.value)}')"`;
            case 'css':
              return `"${this.escapeString(locator.value)}"`;
            case 'xpath':
              return `xpath=${this.escapeString(locator.value)}`;
            case 'aria':
              return `page.getByRole(AriaRole.${locator.role.toUpperCase()}, new Page.GetByRoleOptions().setName("${this.escapeString(locator.name)}"))`;
            case 'text':
              return `page.getByText("${this.escapeString(locator.value)}")`;
            case 'testId':
              return `page.getByTestId("${this.escapeString(locator.value)}")`;
            case 'label':
              return `page.getByLabel("${this.escapeString(locator.value)}")`;
            case 'placeholder':
              return `page.getByPlaceholder("${this.escapeString(locator.value)}")`;
            case 'altText':
              return `page.getByAltText("${this.escapeString(locator.value)}")`;
            case 'title':
              return `page.getByTitle("${this.escapeString(locator.value)}")`;
            default:
              return `"#unknown-locator-type"`;
          }
        },
        
        convertLocatorToCSS: function(locator) {
          if (!locator) {
            return 'body';
          }
          
          switch (locator.type) {
            case 'id':
              return `#${locator.value}`;
            case 'name':
              return `[name='${locator.value}']`;
            case 'className':
              return `.${locator.value}`;
            case 'tagName':
              return locator.value;
            case 'css':
              return locator.value;
            default:
              return 'body';
          }
        },
        
        escapeString: function(str) {
          if (typeof str !== 'string') {
            return str;
          }
          return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
        }
      },
      
      bdd: {
        fileExtension: '.java',
        
        generateImports: function(actions, options) {
          return [
            'import io.cucumber.java.en.Given;',
            'import io.cucumber.java.en.When;',
            'import io.cucumber.java.en.Then;',
            'import io.cucumber.java.en.And;',
            'import org.testng.Assert;',
            'import com.microsoft.playwright.Browser;',
            'import com.microsoft.playwright.BrowserContext;',
            'import com.microsoft.playwright.BrowserType;',
            'import com.microsoft.playwright.Locator;',
            'import com.microsoft.playwright.Page;',
            'import com.microsoft.playwright.Playwright;',
            'import com.microsoft.playwright.options.AriaRole;',
            'import com.microsoft.playwright.options.LoadState;',
            'import java.nio.file.Paths;',
            'import java.util.List;',
            '',
            'import com.cstestforge.framework.core.utils.CSScreenshotManager;',
            'import com.cstestforge.framework.playwright.CSBaseStepDef;',
            'import com.cstestforge.framework.playwright.CSElement;',
            'import com.cstestforge.framework.playwright.CSWaitStrategy;',
            'import com.cstestforge.framework.playwright.CSVisibilityWait;',
            'import com.cstestforge.framework.playwright.CSClickableWait;'
          ].join('\n');
        },
        
        generateClassStart: function(className, options) {
          return [
            '/**',
            ' * Generated step definitions for ' + className,
            ' * Generated by CSTestForge Recorder',
            ' */',
            'public class ' + className + 'Steps extends CSBaseStepDef {',
            '',
            '    private Playwright playwright;',
            '    private Browser browser;',
            '    private BrowserContext context;',
            '    private Page page;',
            '',
            '    public ' + className + 'Steps() {',
            '        playwright = Playwright.create();',
            '        browser = playwright.chromium().launch();',
            '        context = browser.newContext();',
            '        page = context.newPage();',
            '    }',
            '',
            '    public void closeBrowser() {',
            '        if (page != null) {',
            '            page.close();',
            '        }',
            '        if (context != null) {',
            '            context.close();',
            '        }',
            '        if (browser != null) {',
            '            browser.close();',
            '        }',
            '        if (playwright != null) {',
            '            playwright.close();',
            '        }',
            '    }',
            ''
          ].join('\n');
        },
        
        generateClassEnd: function(options) {
          return '}\n';
        },
        
        formatAction: function(action, index, options) {
          const indent = '    ';
          let annotation = '';
          let methodSignature = '';
          let code = '';
          
          switch (action.type) {
            case 'navigate':
              annotation = '@Given';
              methodSignature = `public void navigateToUrl() {`;
              code = `    page.navigate("${action.url}");`;
              break;
            
            case 'click':
              annotation = '@When';
              methodSignature = `public void clickOnElement() {`;
              
              if (action.useJS) {
                code = `    page.evaluate("document.querySelector('${this.escapeString(this.convertLocatorToCSS(action.locator))}').click()");`;
              } else {
                code = `    page.locator(${this.formatLocator(action.locator)}).click();`;
              }
              break;
            
            case 'type':
              annotation = '@When';
              methodSignature = `public void enterText() {`;
              
              if (action.clearFirst) {
                code = [
                  `    page.locator(${this.formatLocator(action.locator)}).clear();`,
                  `    page.locator(${this.formatLocator(action.locator)}).fill("${this.escapeString(action.text)}");`
                ].join('\n');
              } else {
                code = `    page.locator(${this.formatLocator(action.locator)}).fill("${this.escapeString(action.text)}");`;
              }
              break;
            
            // More action types would be implemented similarly...
            default:
              annotation = '@And';
              methodSignature = `public void performAction${index}() {`;
              code = `    // Implement action: ${action.type}`;
          }
          
          return [
            `${indent}${annotation}(".*")`,
            `${indent}${methodSignature}`,
            `${code}`,
            `${indent}}`
          ].join('\n');
        },
        
        formatLocator: function(locator) {
          // Same as testng formatter
          if (!locator) {
            return `"body"`;
          }
          
          switch (locator.type) {
            case 'id':
              return `"#${this.escapeString(locator.value)}"`;
            case 'name':
              return `"[name='${this.escapeString(locator.value)}']"`;
            case 'className':
              return `".${this.escapeString(locator.value)}"`;
            case 'tagName':
              return `"${this.escapeString(locator.value)}"`;
            case 'linkText':
              return `"a:has-text('${this.escapeString(locator.value)}')"`;
            case 'partialLinkText':
              return `"a:text-matches('${this.escapeString(locator.value)}')"`;
            case 'css':
              return `"${this.escapeString(locator.value)}"`;
            case 'xpath':
              return `xpath=${this.escapeString(locator.value)}`;
            case 'aria':
              return `page.getByRole(AriaRole.${locator.role.toUpperCase()}, new Page.GetByRoleOptions().setName("${this.escapeString(locator.name)}"))`;
            case 'text':
              return `page.getByText("${this.escapeString(locator.value)}")`;
            case 'testId':
              return `page.getByTestId("${this.escapeString(locator.value)}")`;
            case 'label':
              return `page.getByLabel("${this.escapeString(locator.value)}")`;
            case 'placeholder':
              return `page.getByPlaceholder("${this.escapeString(locator.value)}")`;
            case 'altText':
              return `page.getByAltText("${this.escapeString(locator.value)}")`;
            case 'title':
              return `page.getByTitle("${this.escapeString(locator.value)}")`;
            default:
              return `"#unknown-locator-type"`;
          }
        },
        
        convertLocatorToCSS: function(locator) {
          // Same as testng formatter
          if (!locator) {
            return 'body';
          }
          
          switch (locator.type) {
            case 'id':
              return `#${locator.value}`;
            case 'name':
              return `[name='${locator.value}']`;
            case 'className':
              return `.${locator.value}`;
            case 'tagName':
              return locator.value;
            case 'css':
              return locator.value;
            default:
              return 'body';
          }
        },
        
        escapeString: function(str) {
          // Same as testng formatter
          if (typeof str !== 'string') {
            return str;
          }
          return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
        },
        
        generateFeatureFile: function(className, actions, options) {
          // Generate Cucumber feature file content
          const featureName = className.replace(/([A-Z])/g, ' $1').trim();
          
          let feature = [
            `Feature: ${featureName}`,
            `  As a user`,
            `  I want to use the application`,
            `  So that I can complete my tasks`,
            ``
          ];
          
          const scenarioName = options.scenarioName || 'Use the application';
          feature.push(`  Scenario: ${scenarioName}`);
          
          // Group actions into logical steps
          let stepCounter = 0;
          
          for (let i = 0; i < actions.length; i++) {
            const action = actions[i];
            let step = '';
            
            switch (action.type) {
              case 'navigate':
                step = `    Given I navigate to the application`;
                break;
              
              case 'click':
                step = `    When I click on the element`;
                break;
              
              case 'type':
                step = `    When I enter text into the field`;
                break;
              
              case 'select':
                step = `    When I select an option from the dropdown`;
                break;
              
              case 'assertion':
                step = `    Then I should see the expected result`;
                break;
              
              default:
                step = `    And I perform action ${++stepCounter}`;
            }
            
            feature.push(step);
          }
          
          return feature.join('\n') + '\n';
        }
      }
    },
    
    typescript: {
      testng: {
        fileExtension: '.ts',
        
        generateImports: function(actions, options) {
          return [
            'import { test, expect, chromium, Browser, BrowserContext, Page, Locator } from "@playwright/test";',
            'import { CSTestForgeConfig } from "../config/CSTestForgeConfig";',
            'import { CSScreenshotManager } from "../utils/CSScreenshotManager";',
            'import { CSElement } from "../core/CSElement";',
            'import { CSWaitStrategy } from "../core/CSWaitStrategy";',
            'import { CSVisibilityWait } from "../core/CSVisibilityWait";',
            'import { CSClickableWait } from "../core/CSClickableWait";',
            ''
          ].join('\n');
        },
        
        generateClassStart: function(className, options) {
          return [
            '/**',
            ' * Generated test class for ' + className,
            ' * Generated by CSTestForge Recorder',
            ' */',
            `test.describe('${className}', () => {`,
            '    let browser: Browser;',
            '    let context: BrowserContext;',
            '    let page: Page;',
            '',
            '    test.beforeEach(async () => {',
            '        browser = await chromium.launch(CSTestForgeConfig.launchOptions);',
            '        context = await browser.newContext(CSTestForgeConfig.contextOptions);',
            '        page = await context.newPage();',
            '    });',
            '',
            '    test.afterEach(async () => {',
            '        await page.close();',
            '        await context.close();',
            '        await browser.close();',
            '    });',
            ''
          ].join('\n');
        },
        
        generateMethodStart: function(methodName, options) {
          return [
            `    test('${methodName}', async () => {`,
            ''
          ].join('\n');
        },
        
        generateMethodEnd: function(options) {
          return '    });\n';
        },
        
        generateClassEnd: function(options) {
          return '});\n';
        },
        
        formatAction: function(action, index, options) {
          const indent = '        ';
          let code = '';
          
          switch (action.type) {
            case 'navigate':
              code = `await page.goto("${action.url}");`;
              break;
            
            case 'click':
              if (action.useJS) {
                code = `await page.evaluate(() => document.querySelector('${this.escapeString(this.convertLocatorToCSS(action.locator))}').click());`;
              } else {
                code = `await page.locator(${this.formatLocator(action.locator)}).click();`;
              }
              break;
            
            case 'doubleClick':
              code = `await page.locator(${this.formatLocator(action.locator)}).dblclick();`;
              break;
            
            case 'rightClick':
              code = `await page.locator(${this.formatLocator(action.locator)}).click({ button: 'right' });`;
              break;
            
            case 'type':
              if (action.clearFirst) {
                code = [
                  `await page.locator(${this.formatLocator(action.locator)}).clear();`,
                  `await page.locator(${this.formatLocator(action.locator)}).fill("${this.escapeString(action.text)}");`
                ].join('\n' + indent);
              } else {
                code = `await page.locator(${this.formatLocator(action.locator)}).fill("${this.escapeString(action.text)}");`;
              }
              break;
            
            case 'clear':
              code = `await page.locator(${this.formatLocator(action.locator)}).clear();`;
              break;
            
            case 'select':
              if (action.byIndex !== undefined) {
                code = `await page.locator(${this.formatLocator(action.locator)}).selectOption({ index: ${action.byIndex} });`;
              } else if (action.byValue !== undefined) {
                code = `await page.locator(${this.formatLocator(action.locator)}).selectOption("${this.escapeString(action.byValue)}");`;
              } else if (action.byText !== undefined) {
                code = `await page.locator(${this.formatLocator(action.locator)}).selectOption({ label: "${this.escapeString(action.byText)}" });`;
              }
              break;
            
            case 'check':
              code = `await page.locator(${this.formatLocator(action.locator)}).check();`;
              break;
            
            case 'uncheck':
              code = `await page.locator(${this.formatLocator(action.locator)}).uncheck();`;
              break;
            
            case 'hover':
              code = `await page.locator(${this.formatLocator(action.locator)}).hover();`;
              break;
            
            case 'dragAndDrop':
              code = `await page.locator(${this.formatLocator(action.sourceLocator)}).dragTo(page.locator(${this.formatLocator(action.targetLocator)}));`;
              break;
            
            case 'wait':
              if (action.waitType === 'visibility') {
                code = `await page.locator(${this.formatLocator(action.locator)}).waitFor({ state: 'visible' });`;
              } else if (action.waitType === 'clickable') {
                code = `await page.locator(${this.formatLocator(action.locator)}).waitFor({ state: 'visible' });`;
              } else if (action.waitType === 'presence') {
                code = `await page.locator(${this.formatLocator(action.locator)}).waitFor();`;
              } else if (action.waitType === 'time') {
                code = `await page.waitForTimeout(${action.duration});`;
              } else if (action.waitType === 'load') {
                code = `await page.waitForLoadState('load');`;
              } else if (action.waitType === 'networkidle') {
                code = `await page.waitForLoadState('networkidle');`;
              } else if (action.waitType === 'domcontentloaded') {
                code = `await page.waitForLoadState('domcontentloaded');`;
              }
              break;
            
            case 'executeScript':
              if (action.arguments && action.arguments.length > 0) {
                const args = action.arguments.map(arg => {
                  if (typeof arg === 'string') {
                    return `"${this.escapeString(arg)}"`;
                  } else if (arg === null) {
                    return 'null';
                  } else if (typeof arg === 'object' && arg.type === 'element') {
                    return `await page.locator(${this.formatLocator(arg.locator)}).elementHandle()`;
                  }
                  return String(arg);
                }).join(', ');
                
                code = `await page.evaluate((${args}) => { ${action.script} });`;
              } else {
                code = `await page.evaluate(() => { ${action.script} });`;
              }
              break;
            
            case 'assertion':
              if (action.assertType === 'equals') {
                code = `await expect(page.locator(${this.formatLocator(action.locator)})).toHaveText("${this.escapeString(action.expectedValue)}");`;
              } else if (action.assertType === 'contains') {
                code = `await expect(page.locator(${this.formatLocator(action.locator)})).toContainText("${this.escapeString(action.expectedValue)}");`;
              } else if (action.assertType === 'selected') {
                code = `await expect(page.locator(${this.formatLocator(action.locator)})).toBeChecked();`;
              } else if (action.assertType === 'notSelected') {
                code = `await expect(page.locator(${this.formatLocator(action.locator)})).not.toBeChecked();`;
              } else if (action.assertType === 'exists') {
                code = `await expect(page.locator(${this.formatLocator(action.locator)})).toHaveCount(1);`;
              } else if (action.assertType === 'notExists') {
                code = `await expect(page.locator(${this.formatLocator(action.locator)})).toHaveCount(0);`;
              } else if (action.assertType === 'visible') {
                code = `await expect(page.locator(${this.formatLocator(action.locator)})).toBeVisible();`;
              } else if (action.assertType === 'notVisible') {
                code = `await expect(page.locator(${this.formatLocator(action.locator)})).not.toBeVisible();`;
              }
              break;
            
            case 'screenshot':
              if (action.fullPage) {
                code = `await page.screenshot({ path: "${action.name || 'screenshot_' + index}.png", fullPage: true });`;
              } else if (action.locator) {
                code = `await page.locator(${this.formatLocator(action.locator)}).screenshot({ path: "${action.name || 'screenshot_' + index}.png" });`;
              } else {
                code = `await page.screenshot({ path: "${action.name || 'screenshot_' + index}.png" });`;
              }
              break;
            
            case 'switchToFrame':
              if (action.locator) {
                code = `const frameLocator = page.frameLocator(${this.formatLocator(action.locator)});`;
              } else if (action.nameOrId) {
                code = `const frame = page.frame("${this.escapeString(action.nameOrId)}");`;
              }
              break;
            
            case 'keyPress':
              if (action.key === 'Enter') {
                code = `await page.locator(${this.formatLocator(action.locator)}).press("Enter");`;
              } else if (action.key === 'Tab') {
                code = `await page.locator(${this.formatLocator(action.locator)}).press("Tab");`;
              } else if (action.key === 'Escape') {
                code = `await page.locator(${this.formatLocator(action.locator)}).press("Escape");`;
              } else {
                code = `await page.locator(${this.formatLocator(action.locator)}).press("${action.key}");`;
              }
              break;
            
            case 'comment':
              code = `// ${action.text}`;
              break;
            
            case 'setViewport':
              code = `await page.setViewportSize({ width: ${action.width}, height: ${action.height} });`;
              break;
              
            case 'fileUpload':
              code = `await page.locator(${this.formatLocator(action.locator)}).setInputFiles("${this.escapeString(action.filePath)}");`;
              break;
              
            case 'focus':
              code = `await page.locator(${this.formatLocator(action.locator)}).focus();`;
              break;
              
            case 'blur':
              code = `await page.locator(${this.formatLocator(action.locator)}).blur();`;
              break;
            
            default:
              code = `// Unsupported action type: ${action.type}`;
          }
          
          return indent + code;
        },
        
        formatLocator: function(locator) {
          if (!locator) {
            return `'body'`;
          }
          
          switch (locator.type) {
            case 'id':
              return `'#${this.escapeString(locator.value)}'`;
            case 'name':
              return `'[name="${this.escapeString(locator.value)}"]'`;
            case 'className':
              return `'.${this.escapeString(locator.value)}'`;
            case 'tagName':
              return `'${this.escapeString(locator.value)}'`;
            case 'linkText':
              return `'a:has-text("${this.escapeString(locator.value)}")'`;
            case 'partialLinkText':
              return `'a:text-matches("${this.escapeString(locator.value)}")'`;
            case 'css':
              return `'${this.escapeString(locator.value)}'`;
            case 'xpath':
              return `'xpath=${this.escapeString(locator.value)}'`;
            case 'aria':
              return `page.getByRole('${locator.role.toLowerCase()}', { name: '${this.escapeString(locator.name)}' })`;
            case 'text':
              return `page.getByText('${this.escapeString(locator.value)}')`;
            case 'testId':
              return `page.getByTestId('${this.escapeString(locator.value)}')`;
            case 'label':
              return `page.getByLabel('${this.escapeString(locator.value)}')`;
            case 'placeholder':
              return `page.getByPlaceholder('${this.escapeString(locator.value)}')`;
            case 'altText':
              return `page.getByAltText('${this.escapeString(locator.value)}')`;
            case 'title':
              return `page.getByTitle('${this.escapeString(locator.value)}')`;
            default:
              return `'#unknown-locator-type'`;
          }
        },
        
        convertLocatorToCSS: function(locator) {
          if (!locator) {
            return 'body';
          }
          
          switch (locator.type) {
            case 'id':
              return `#${locator.value}`;
            case 'name':
              return `[name="${locator.value}"]`;
            case 'className':
              return `.${locator.value}`;
            case 'tagName':
              return locator.value;
            case 'css':
              return locator.value;
            default:
              return 'body';
          }
        },
        
        escapeString: function(str) {
          if (typeof str !== 'string') {
            return str;
          }
          return str
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
        }
      },
      
      bdd: {
        fileExtension: '.ts',
        
        generateImports: function(actions, options) {
          return [
            'import { Given, When, Then } from "@cucumber/cucumber";',
            'import { Browser, BrowserContext, chromium, Locator, Page } from "@playwright/test";',
            'import { CSTestForgeWorld } from "../support/CSTestForgeWorld";',
            'import { CSScreenshotManager } from "../utils/CSScreenshotManager";',
            'import { CSElement } from "../core/CSElement";',
            'import { CSWaitStrategy } from "../core/CSWaitStrategy";',
            'import { CSVisibilityWait } from "../core/CSVisibilityWait";',
            'import { CSClickableWait } from "../core/CSClickableWait";',
            'import { expect } from "chai";',
            ''
          ].join('\n');
        },
        
        generateStepDefinitions: function(actions, options) {
          let stepDefs = [];
          
          // Generate step definitions based on actions
          for (let i = 0; i < actions.length; i++) {
            const action = actions[i];
            let stepDef = '';
            
            switch (action.type) {
              case 'navigate':
                stepDef = [
                  `Given('I navigate to {string}', async function(this: CSTestForgeWorld, url: string) {`,
                  `    await this.page.goto(url);`,
                  `});`,
                  ``,
                  `Given('I navigate to the application', async function(this: CSTestForgeWorld) {`,
                  `    await this.page.goto("${action.url}");`,
                  `});`,
                  ``
                ].join('\n');
                break;
              
              case 'click':
                stepDef = [
                  `When('I click on element {string}', async function(this: CSTestForgeWorld, locator: string) {`,
                  `    await this.page.locator(locator).click();`,
                  `});`,
                  ``,
                  `When('I click on the element', async function(this: CSTestForgeWorld) {`,
                  `    await this.page.locator(${this.formatLocator(action.locator)}).click();`,
                  `});`,
                  ``
                ].join('\n');
                break;
              
              case 'type':
                stepDef = [
                  `When('I type {string} into element {string}', async function(this: CSTestForgeWorld, text: string, locator: string) {`,
                  `    await this.page.locator(locator).fill(text);`,
                  `});`,
                  ``,
                  `When('I enter text into the field', async function(this: CSTestForgeWorld) {`,
                  `    await this.page.locator(${this.formatLocator(action.locator)}).fill("${this.escapeString(action.text)}");`,
                  `});`,
                  ``
                ].join('\n');
                break;
              
              case 'select':
                stepDef = [
                  `When('I select {string} from the dropdown {string}', async function(this: CSTestForgeWorld, option: string, locator: string) {`,
                  `    await this.page.locator(locator).selectOption(option);`,
                  `});`,
                  ``,
                  `When('I select an option from the dropdown', async function(this: CSTestForgeWorld) {`,
                  action.byIndex !== undefined ? 
                    `    await this.page.locator(${this.formatLocator(action.locator)}).selectOption({ index: ${action.byIndex} });` :
                    action.byValue !== undefined ?
                      `    await this.page.locator(${this.formatLocator(action.locator)}).selectOption("${this.escapeString(action.byValue)}");` :
                      `    await this.page.locator(${this.formatLocator(action.locator)}).selectOption({ label: "${this.escapeString(action.byText)}" });`,
                  `});`,
                  ``
                ].join('\n');
                break;
              
              case 'check':
                stepDef = [
                  `When('I check the checkbox {string}', async function(this: CSTestForgeWorld, locator: string) {`,
                  `    await this.page.locator(locator).check();`,
                  `});`,
                  ``,
                  `When('I check the checkbox', async function(this: CSTestForgeWorld) {`,
                  `    await this.page.locator(${this.formatLocator(action.locator)}).check();`,
                  `});`,
                  ``
                ].join('\n');
                break;
              
              case 'uncheck':
                stepDef = [
                  `When('I uncheck the checkbox {string}', async function(this: CSTestForgeWorld, locator: string) {`,
                  `    await this.page.locator(locator).uncheck();`,
                  `});`,
                  ``,
                  `When('I uncheck the checkbox', async function(this: CSTestForgeWorld) {`,
                  `    await this.page.locator(${this.formatLocator(action.locator)}).uncheck();`,
                  `});`,
                  ``
                ].join('\n');
                break;
              
              case 'assertion':
                switch (action.assertType) {
                  case 'equals':
                    stepDef = [
                      `Then('element {string} should have text {string}', async function(this: CSTestForgeWorld, locator: string, expectedText: string) {`,
                      `    await expect(this.page.locator(locator)).toHaveText(expectedText);`,
                      `});`,
                      ``,
                      `Then('I should see the expected result', async function(this: CSTestForgeWorld) {`,
                      `    await expect(this.page.locator(${this.formatLocator(action.locator)})).toHaveText("${this.escapeString(action.expectedValue)}");`,
                      `});`,
                      ``
                    ].join('\n');
                    break;
                  
                  case 'contains':
                    stepDef = [
                      `Then('element {string} should contain text {string}', async function(this: CSTestForgeWorld, locator: string, expectedText: string) {`,
                      `    await expect(this.page.locator(locator)).toContainText(expectedText);`,
                      `});`,
                      ``,
                      `Then('I should see the expected result', async function(this: CSTestForgeWorld) {`,
                      `    await expect(this.page.locator(${this.formatLocator(action.locator)})).toContainText("${this.escapeString(action.expectedValue)}");`,
                      `});`,
                      ``
                    ].join('\n');
                    break;
                  
                  case 'exists':
                    stepDef = [
                      `Then('element {string} should exist', async function(this: CSTestForgeWorld, locator: string) {`,
                      `    await expect(this.page.locator(locator)).toHaveCount(1);`,
                      `});`,
                      ``,
                      `Then('I should see the expected result', async function(this: CSTestForgeWorld) {`,
                      `    await expect(this.page.locator(${this.formatLocator(action.locator)})).toHaveCount(1);`,
                      `});`,
                      ``
                    ].join('\n');
                    break;
                  
                  // Add more assertion types as needed
                }
                break;
              
              case 'wait':
                if (action.waitType === 'time') {
                  stepDef = [
                    `When('I wait for {int} milliseconds', async function(this: CSTestForgeWorld, duration: number) {`,
                    `    await this.page.waitForTimeout(duration);`,
                    `});`,
                    ``,
                    `When('I wait for some time', async function(this: CSTestForgeWorld) {`,
                    `    await this.page.waitForTimeout(${action.duration});`,
                    `});`,
                    ``
                  ].join('\n');
                } else if (action.waitType === 'visibility') {
                  stepDef = [
                    `When('I wait for element {string} to be visible', async function(this: CSTestForgeWorld, locator: string) {`,
                    `    await this.page.locator(locator).waitFor({ state: 'visible' });`,
                    `});`,
                    ``,
                    `When('I wait for the element to be visible', async function(this: CSTestForgeWorld) {`,
                    `    await this.page.locator(${this.formatLocator(action.locator)}).waitFor({ state: 'visible' });`,
                    `});`,
                    ``
                  ].join('\n');
                }
                // Add more wait types as needed
                break;
              
              default:
                // Skip comments and unsupported actions
                if (action.type === 'comment') {
                  continue;
                }
            }
            
            if (stepDef) {
              stepDefs.push(stepDef);
            }
          }
          
          return stepDefs.join('\n');
        },
        
        formatLocator: function(locator) {
          // Same as testng formatter
          if (!locator) {
            return `'body'`;
          }
          
          switch (locator.type) {
            case 'id':
              return `'#${this.escapeString(locator.value)}'`;
            case 'name':
              return `'[name="${this.escapeString(locator.value)}"]'`;
            case 'className':
              return `'.${this.escapeString(locator.value)}'`;
            case 'tagName':
              return `'${this.escapeString(locator.value)}'`;
            case 'linkText':
              return `'a:has-text("${this.escapeString(locator.value)}")'`;
            case 'partialLinkText':
              return `'a:text-matches("${this.escapeString(locator.value)}")'`;
            case 'css':
              return `'${this.escapeString(locator.value)}'`;
            case 'xpath':
              return `'xpath=${this.escapeString(locator.value)}'`;
            case 'aria':
              return `this.page.getByRole('${locator.role.toLowerCase()}', { name: '${this.escapeString(locator.name)}' })`;
            case 'text':
              return `this.page.getByText('${this.escapeString(locator.value)}')`;
            case 'testId':
              return `this.page.getByTestId('${this.escapeString(locator.value)}')`;
            case 'label':
              return `this.page.getByLabel('${this.escapeString(locator.value)}')`;
            case 'placeholder':
              return `this.page.getByPlaceholder('${this.escapeString(locator.value)}')`;
            case 'altText':
              return `this.page.getByAltText('${this.escapeString(locator.value)}')`;
            case 'title':
              return `this.page.getByTitle('${this.escapeString(locator.value)}')`;
            default:
              return `'#unknown-locator-type'`;
          }
        },
        
        convertLocatorToCSS: function(locator) {
          // Same as testng formatter
          if (!locator) {
            return 'body';
          }
          
          switch (locator.type) {
            case 'id':
              return `#${locator.value}`;
            case 'name':
              return `[name="${locator.value}"]`;
            case 'className':
              return `.${locator.value}`;
            case 'tagName':
              return locator.value;
            case 'css':
              return locator.value;
            default:
              return 'body';
          }
        },
        
        escapeString: function(str) {
          // Same as testng formatter
          if (typeof str !== 'string') {
            return str;
          }
          return str
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
        },
        
        generateFeatureFile: function(className, actions, options) {
          // Generate Cucumber feature file content
          const featureName = className.replace(/([A-Z])/g, ' $1').trim();
          
          let feature = [
            `Feature: ${featureName}`,
            `  As a user`,
            `  I want to use the application`,
            `  So that I can complete my tasks`,
            ``
          ];
          
          const scenarioName = options.scenarioName || 'Use the application';
          feature.push(`  Scenario: ${scenarioName}`);
          
          // Group actions into logical steps
          let stepCounter = 0;
          
          for (let i = 0; i < actions.length; i++) {
            const action = actions[i];
            let step = '';
            
            switch (action.type) {
              case 'navigate':
                step = `    Given I navigate to the application`;
                break;
              
              case 'click':
                step = `    When I click on the element`;
                break;
              
              case 'type':
                step = `    When I enter text into the field`;
                break;
              
              case 'select':
                step = `    When I select an option from the dropdown`;
                break;
              
              case 'check':
                step = `    When I check the checkbox`;
                break;
              
              case 'uncheck':
                step = `    When I uncheck the checkbox`;
                break;
              
              case 'assertion':
                step = `    Then I should see the expected result`;
                break;
              
              case 'wait':
                if (action.waitType === 'time') {
                  step = `    When I wait for some time`;
                } else if (action.waitType === 'visibility') {
                  step = `    When I wait for the element to be visible`;
                } else {
                  step = `    When I wait for the page to load`;
                }
                break;
              
              default:
                if (action.type !== 'comment') {
                  step = `    And I perform action ${++stepCounter}`;
                } else {
                  continue; // Skip comments in feature file
                }
            }
            
            feature.push(step);
          }
          
          return feature.join('\n') + '\n';
        }
      }
    }
  };
  
  /**
   * Converts recorded actions to code in specified language and framework
   * 
   * @param {Object} options Configuration options
   * @param {Array} options.actions Array of recorded actions
   * @param {string} options.language Target language ('java' or 'typescript')
   * @param {string} options.framework Target framework ('testng' or 'bdd')
   * @param {string} options.className Name of the generated class
   * @param {string} options.testMethodName Name of the generated test method
   * @param {Object} options.customOptions Additional options for specific formatters
   * @returns {Object} Generated code files
   */
  function convertActionsToCode(options) {
    const actions = options.actions || [];
    const language = options.language || 'java';
    const framework = options.framework || 'testng';
    const className = options.className || 'GeneratedTest';
    const testMethodName = options.testMethodName || 'generatedTest';
    const customOptions = options.customOptions || {};
    
    // Get the appropriate formatter
    const formatter = formatters[language] && formatters[language][framework];
    
    if (!formatter) {
      throw new Error(`Unsupported language/framework combination: ${language}/${framework}`);
    }
    
    // Generate code
    let mainCode = '';
    let additionalFiles = {};
    
    // Add imports
    mainCode += formatter.generateImports(actions, customOptions) + '\n\n';
    
    // Start class definition
    mainCode += formatter.generateClassStart(className, customOptions) + '\n';
    
    // For TestNG style, generate a test method
    if (framework === 'testng') {
      mainCode += formatter.generateMethodStart(testMethodName, customOptions) + '\n';
      
      // Add actions
      for (let i = 0; i < actions.length; i++) {
        mainCode += formatter.formatAction(actions[i], i, customOptions) + '\n';
      }
      
      // End method definition
      mainCode += formatter.generateMethodEnd(customOptions);
    } else if (framework === 'bdd') {
      // For BDD style, generate step definitions
      mainCode += formatter.generateStepDefinitions(actions, customOptions) + '\n';
    }
    
    // End class definition
    mainCode += formatter.generateClassEnd(customOptions);
    
    // For BDD, also generate a feature file
    if (framework === 'bdd') {
      const featureFileName = `${className.toLowerCase()}.feature`;
      additionalFiles[featureFileName] = formatter.generateFeatureFile(className, actions, customOptions);
    }
    
    return {
      mainFile: {
        name: `${className}${framework === 'bdd' ? 'Steps' : ''}${formatter.fileExtension}`,
        content: mainCode
      },
      additionalFiles: additionalFiles
    };
  }
  
  /**
   * Enhances recorded actions with Playwright-specific features
   * 
   * @param {Array} actions Array of recorded actions
   * @param {Object} options Configuration options
   * @returns {Array} Enhanced actions
   */
  function enhanceActionsWithPlaywrightFeatures(actions, options) {
    return actions.map(action => {
      // Clone the action to avoid modifying the original
      const enhancedAction = { ...action };
      
      // Convert Selenium-style locators to Playwright-style locators
      if (enhancedAction.locator) {
        enhancedAction.locator = convertToPlaywrightLocator(enhancedAction.locator, options);
      }
      
      if (enhancedAction.sourceLocator) {
        enhancedAction.sourceLocator = convertToPlaywrightLocator(enhancedAction.sourceLocator, options);
      }
      
      if (enhancedAction.targetLocator) {
        enhancedAction.targetLocator = convertToPlaywrightLocator(enhancedAction.targetLocator, options);
      }
      
      // Convert Selenium-style actions to Playwright-style actions
      enhancedAction.type = convertActionType(enhancedAction.type);
      
      // Add Playwright-specific parameters to actions
      if (enhancedAction.type === 'type' && !enhancedAction.hasOwnProperty('clearFirst')) {
        // No need for clearFirst in Playwright as fill() replaces content
        delete enhancedAction.clearFirst;
      }
      
      return enhancedAction;
    });
  }
  
  /**
   * Converts Selenium-style locator to Playwright-style locator
   * 
   * @param {Object} locator Selenium-style locator
   * @param {Object} options Configuration options
   * @returns {Object} Playwright-style locator
   */
  function convertToPlaywrightLocator(locator, options) {
    // If locator is already in the desired format, return it
    if (typeof locator === 'object' && locator.type && locator.value) {
      // Convert Selenium-style locator types to Playwright-style
      switch (locator.type) {
        case 'id':
          return {
            type: 'css',
            value: `#${locator.value}`
          };
        
        case 'name':
          return {
            type: 'css',
            value: `[name="${locator.value}"]`
          };
        
        case 'className':
          return {
            type: 'css',
            value: `.${locator.value}`
          };
        
        case 'tagName':
          return {
            type: 'css',
            value: locator.value
          };
        
        case 'linkText':
          return {
            type: 'text',
            value: locator.value
          };
        
        case 'partialLinkText':
          // No direct equivalent, convert to a text locator with :text-matches
          return {
            type: 'css',
            value: `a:text-matches("${locator.value}")`
          };
        
        case 'xpath':
          // Keep xpath as is
          return locator;
        
        case 'css':
          // Keep CSS as is
          return locator;
        
        default:
          return locator;
      }
    }
    
    // Handle more complex locator structures
    if (Array.isArray(locators)) {
      // Find the best locator for Playwright
      const priorityTypes = ['css', 'xpath', 'text', 'aria', 'testId', 'label', 'placeholder'];
      
      for (const type of priorityTypes) {
        const matchingLocator = locators.find(loc => loc.type === type);
        if (matchingLocator) {
          return matchingLocator;
        }
      }
      
      // Fallback to the first available locator
      return locators[0];
    }
    
    // Default case - return the original locator
    return locator;
  }
  
  /**
   * Converts Selenium-style action type to Playwright-style action type
   * 
   * @param {string} actionType Selenium-style action type
   * @returns {string} Playwright-style action type
   */
  function convertActionType(actionType) {
    // Most action types are the same, but some need conversion
    switch (actionType) {
      case 'navigate':
        return 'navigate';
      
      case 'click':
        return 'click';
      
      case 'doubleClick':
        return 'doubleClick';
      
      case 'rightClick':
        return 'rightClick';
      
      case 'type':
        return 'type';
      
      case 'clear':
        return 'clear';
      
      case 'select':
        return 'select';
      
      case 'check':
        return 'check';
      
      case 'uncheck':
        return 'uncheck';
      
      case 'hover':
        return 'hover';
      
      case 'dragAndDrop':
        return 'dragAndDrop';
      
      case 'wait':
        return 'wait';
      
      case 'executeScript':
        return 'executeScript';
      
      case 'assertion':
        return 'assertion';
      
      case 'screenshot':
        return 'screenshot';
      
      case 'switchToFrame':
        return 'switchToFrame';
      
      case 'keyPress':
        return 'keyPress';
      
      case 'comment':
        return 'comment';
      
      default:
        // Return the original type if no conversion is needed
        return actionType;
    }
  }
  
  /**
   * Optimizes actions by consolidating similar consecutive actions
   * 
   * @param {Array} actions Array of recorded actions
   * @param {Object} options Configuration options
   * @returns {Array} Optimized actions
   */
  function optimizeActions(actions, options) {
    if (!actions || !actions.length) {
      return [];
    }
    
    const optimized = [];
    let skipNext = false;
    
    for (let i = 0; i < actions.length; i++) {
      if (skipNext) {
        skipNext = false;
        continue;
      }
      
      const current = actions[i];
      const next = i < actions.length - 1 ? actions[i + 1] : null;
      
      // Check if current and next actions can be combined
      if (next) {
        // In Playwright, type is done with fill() which replaces the content
        // So we don't need to combine clear + type in Playwright
        
        // Combine consecutive waits into a single longer wait
        if (current.type === 'wait' && next.type === 'wait' && 
            current.waitType === 'time' && next.waitType === 'time') {
          optimized.push({
            type: 'wait',
            waitType: 'time',
            duration: (current.duration || 0) + (next.duration || 0)
          });
          skipNext = true;
          continue;
        }
      }
      
      // If no combination was made, add the current action
      optimized.push(current);
    }
    
    return optimized;
  }
  
  /**
   * Add setup and teardown code based on the recording environment
   * 
   * @param {Array} actions Array of recorded actions
   * @param {Object} environment Recording environment information
   * @param {Object} options Configuration options
   * @returns {Object} Actions with setup/teardown code
   */
  function addSetupAndTeardown(actions, environment, options) {
    const language = options.language || 'java';
    const framework = options.framework || 'testng';
    
    // Get browser details from the environment
    const browser = environment?.browser?.name?.toLowerCase() || 'chromium';
    const browserVersion = environment?.browser?.version;
    const headless = environment?.headless !== false;
    const platform = environment?.platform?.name?.toLowerCase() || 'any';
    
    // Default setup/teardown code
    let setupCode = [];
    let teardownCode = [];
    
    if (language === 'java') {
      setupCode = [
        'playwright = Playwright.create();',
        'browser = playwright.chromium().launch();',
        'context = browser.newContext();',
        'page = context.newPage();'
      ];
      
      teardownCode = [
        'if (page != null) {',
        '    page.close();',
        '}',
        'if (context != null) {',
        '    context.close();',
        '}',
        'if (browser != null) {',
        '    browser.close();',
        '}',
        'if (playwright != null) {',
        '    playwright.close();',
        '}'
      ];
    } else if (language === 'typescript') {
      setupCode = [
        'browser = await chromium.launch(CSTestForgeConfig.launchOptions);',
        'context = await browser.newContext(CSTestForgeConfig.contextOptions);',
        'page = await context.newPage();'
      ];
      
      teardownCode = [
        'await page.close();',
        'await context.close();',
        'await browser.close();'
      ];
    }
    
    // Add environment-specific customizations
    if (browser === 'chromium' || browser === 'chrome') {
      if (language === 'java') {
        setupCode = [
          'playwright = Playwright.create();',
          `browser = playwright.chromium().launch(new BrowserType.LaunchOptions().setHeadless(${headless}));`,
          'context = browser.newContext();',
          'page = context.newPage();'
        ];
      } else if (language === 'typescript') {
        setupCode = [
          `browser = await chromium.launch({ headless: ${headless} });`,
          'context = await browser.newContext();',
          'page = await context.newPage();'
        ];
      }
    } else if (browser === 'firefox') {
      if (language === 'java') {
        setupCode = [
          'playwright = Playwright.create();',
          `browser = playwright.firefox().launch(new BrowserType.LaunchOptions().setHeadless(${headless}));`,
          'context = browser.newContext();',
          'page = context.newPage();'
        ];
      } else if (language === 'typescript') {
        setupCode = [
          `browser = await firefox.launch({ headless: ${headless} });`,
          'context = await browser.newContext();',
          'page = await context.newPage();'
        ];
      }
    } else if (browser === 'webkit' || browser === 'safari') {
      if (language === 'java') {
        setupCode = [
          'playwright = Playwright.create();',
          `browser = playwright.webkit().launch(new BrowserType.LaunchOptions().setHeadless(${headless}));`,
          'context = browser.newContext();',
          'page = context.newPage();'
        ];
      } else if (language === 'typescript') {
        setupCode = [
          `browser = await webkit.launch({ headless: ${headless} });`,
          'context = await browser.newContext();',
          'page = await context.newPage();'
        ];
      }
    }
    
    // Add viewport-related code if needed
    if (environment?.viewport?.width && environment?.viewport?.height) {
      const width = environment.viewport.width;
      const height = environment.viewport.height;
      
      if (language === 'java') {
        setupCode.splice(3, 0, `context = browser.newContext(new Browser.NewContextOptions().setViewportSize(${width}, ${height}));`);
        setupCode.splice(3, 1);
      } else if (language === 'typescript') {
        setupCode.splice(1, 0, `context = await browser.newContext({ viewport: { width: ${width}, height: ${height} } });`);
        setupCode.splice(2, 1);
      }
    }
    
    // Add geolocation if needed
    if (environment?.geolocation?.latitude && environment?.geolocation?.longitude) {
      const latitude = environment.geolocation.latitude;
      const longitude = environment.geolocation.longitude;
      
      if (language === 'java') {
        setupCode.splice(3, 0, `context = browser.newContext(new Browser.NewContextOptions().setGeolocation(${latitude}, ${longitude}));`);
        setupCode.splice(3, 1);
      } else if (language === 'typescript') {
        setupCode.splice(1, 0, `context = await browser.newContext({ geolocation: { latitude: ${latitude}, longitude: ${longitude} } });`);
        setupCode.splice(2, 1);
      }
    }
    
    // Add locale if needed
    if (environment?.locale) {
      const locale = environment.locale;
      
      if (language === 'java') {
        setupCode.splice(3, 0, `context = browser.newContext(new Browser.NewContextOptions().setLocale("${locale}"));`);
        setupCode.splice(3, 1);
      } else if (language === 'typescript') {
        setupCode.splice(1, 0, `context = await browser.newContext({ locale: "${locale}" });`);
        setupCode.splice(2, 1);
      }
    }
    
    // Enable specific imports based on browser
    const imports = getImportsForBrowser(browser, language);
    
    return {
      actions,
      setup: setupCode.join('\n'),
      teardown: teardownCode.join('\n'),
      imports
    };
  }
  
  /**
   * Get required imports for specific browser
   * 
   * @param {string} browser Browser name
   * @param {string} language Target language
   * @returns {Array} Required imports
   */
  function getImportsForBrowser(browser, language) {
    const imports = [];
    
    if (language === 'java') {
      if (browser === 'chromium' || browser === 'chrome') {
        imports.push('import com.microsoft.playwright.chromium.ChromiumBrowserType;');
      } else if (browser === 'firefox') {
        imports.push('import com.microsoft.playwright.firefox.FirefoxBrowserType;');
      } else if (browser === 'webkit' || browser === 'safari') {
        imports.push('import com.microsoft.playwright.webkit.WebKitBrowserType;');
      }
    } else if (language === 'typescript') {
      if (browser === 'chromium' || browser === 'chrome') {
        imports.push('import { chromium } from "@playwright/test";');
      } else if (browser === 'firefox') {
        imports.push('import { firefox } from "@playwright/test";');
      } else if (browser === 'webkit' || browser === 'safari') {
        imports.push('import { webkit } from "@playwright/test";');
      }
    }
    
    return imports;
  }
  
  // Export the public API
  window.CSTestForgePlaywrightActionConverter = {
    convertActionsToCode,
    enhanceActionsWithPlaywrightFeatures,
    optimizeActions,
    addSetupAndTeardown
  };
})();


templates/projects/selenium/java/testng/pom.xml
------------------------------------------------------------

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.cstestforge</groupId>
    <artifactId>selenium-java-testng</artifactId>
    <version>1.0.0</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <selenium.version>4.15.0</selenium.version>
        <testng.version>7.8.0</testng.version>
        <slf4j.version>2.0.9</slf4j.version>
        <webdrivermanager.version>5.6.2</webdrivermanager.version>
        <commons-io.version>2.15.0</commons-io.version>
        <commons-lang3.version>3.13.0</commons-lang3.version>
        <jackson.version>2.15.3</jackson.version>
        <assertj.version>3.24.2</assertj.version>
        <awaitility.version>4.2.0</awaitility.version>
        <lombok.version>1.18.30</lombok.version>
        <maven-surefire-plugin.version>3.2.2</maven-surefire-plugin.version>
    </properties>

    <dependencies>
        <!-- Selenium -->
        <dependency>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-java</artifactId>
            <version>${selenium.version}</version>
        </dependency>
        
        <!-- TestNG -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>${testng.version}</version>
        </dependency>
        
        <!-- WebDriverManager -->
        <dependency>
            <groupId>io.github.bonigarcia</groupId>
            <artifactId>webdrivermanager</artifactId>
            <version>${webdrivermanager.version}</version>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        
        <!-- Apache Commons -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>${commons-io.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>${commons-lang3.version}</version>
        </dependency>
        
        <!-- Jackson -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-yaml</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        
        <!-- AssertJ -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>${assertj.version}</version>
        </dependency>
        
        <!-- Awaitility -->
        <dependency>
            <groupId>org.awaitility</groupId>
            <artifactId>awaitility</artifactId>
            <version>${awaitility.version}</version>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope>
        </dependency>
        
        <!-- CSTestForge Framework -->
        <dependency>
            <groupId>com.cstestforge</groupId>
            <artifactId>cstestforge-core</artifactId>
            <version>1.0.0</version>
        </dependency>
        <dependency>
            <groupId>com.cstestforge</groupId>
            <artifactId>cstestforge-selenium</artifactId>
            <version>1.0.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Maven Compiler Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            
            <!-- Maven Surefire Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>${maven-surefire-plugin.version}</version>
                <configuration>
                    <suiteXmlFiles>
                        <suiteXmlFile>src/test/resources/testng.xml</suiteXmlFile>
                    </suiteXmlFiles>
                    <systemPropertyVariables>
                        <browser>${browser}</browser>
                        <environment>${environment}</environment>
                        <headless>${headless}</headless>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
            
            <!-- Maven Failsafe Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>3.2.2</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>integration-test</goal>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

    <profiles>
        <profile>
            <id>chrome</id>
            <properties>
                <browser>chrome</browser>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>firefox</id>
            <properties>
                <browser>firefox</browser>
            </properties>
        </profile>
        <profile>
            <id>edge</id>
            <properties>
                <browser>edge</browser>
            </properties>
        </profile>
        <profile>
            <id>safari</id>
            <properties>
                <browser>safari</browser>
            </properties>
        </profile>
        <profile>
            <id>headless</id>
            <properties>
                <headless>true</headless>
            </properties>
        </profile>
        <profile>
            <id>dev</id>
            <properties>
                <environment>dev</environment>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>qa</id>
            <properties>
                <environment>qa</environment>
            </properties>
        </profile>
        <profile>
            <id>stage</id>
            <properties>
                <environment>stage</environment>
            </properties>
        </profile>
        <profile>
            <id>prod</id>
            <properties>
                <environment>prod</environment>
            </properties>
        </profile>
    </profiles>
</project>



templates/projects/selenium/java/testng/src/test/java/BaseTest.jva.template
-------------------------------------------------------------------------------------

package $PACKAGE_NAME;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSScreenshotManager;
import com.cstestforge.framework.selenium.CSBaseTest;
import io.github.bonigarcia.wdm.WebDriverManager;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.edge.EdgeOptions;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.safari.SafariDriver;
import org.openqa.selenium.safari.SafariOptions;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;
import org.testng.annotations.Parameters;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Objects;

/**
 * Base Test class with common functionality for all test classes.
 * Extends CSBaseTest from CSTestForge framework.
 */
public class BaseTest extends CSBaseTest {
    private static final Logger LOGGER = LoggerFactory.getLogger(BaseTest.class);
    private static final String SCREENSHOT_DIR = "target/screenshots";
    
    protected WebDriver driver;
    protected WebDriverWait wait;
    protected JavascriptExecutor js;
    
    /**
     * Setup method to run before all tests to ensure proper initialization
     */
    @BeforeSuite
    public void setupSuite() {
        // Create screenshots directory
        try {
            Files.createDirectories(Paths.get(SCREENSHOT_DIR));
        } catch (IOException e) {
            LOGGER.error("Failed to create screenshots directory", e);
        }
        
        // Initialize WebDriver binaries
        setupWebDriverBinaries();
    }
    
    /**
     * Setup method to run before each test method
     * 
     * @param browserName Optional browser name to use (can be provided via TestNG XML)
     * @param headless Optional headless mode flag (can be provided via TestNG XML)
     */
    @BeforeMethod
    @Parameters({"browser", "headless"})
    public void setup(String browserName, Boolean headless) {
        // Get browser from parameters or system property or default
        String browser = getBrowserName(browserName);
        boolean isHeadless = isHeadlessMode(headless);
        
        // Initialize WebDriver based on browser
        initializeWebDriver(browser, isHeadless);
        
        // Setup wait and other utilities
        wait = new WebDriverWait(driver, Duration.ofSeconds(30));
        js = (JavascriptExecutor) driver;
        
        // Set base URL from configuration
        String baseUrl = ConfigurationManager.getInstance().getBaseUrl();
        if (baseUrl != null && !baseUrl.isEmpty()) {
            driver.get(baseUrl);
        }
    }
    
    /**
     * Cleanup method to run after each test method
     * 
     * @param result TestNG test result
     */
    @AfterMethod
    public void tearDown(ITestResult result) {
        // Capture screenshot on failure
        if (result.getStatus() == ITestResult.FAILURE) {
            captureScreenshot(result.getName());
        }
        
        // Quit WebDriver
        if (driver != null) {
            driver.quit();
        }
    }
    
    /**
     * Initialize WebDriver based on browser name and headless mode
     * 
     * @param browser Browser name
     * @param headless Headless mode flag
     */
    private void initializeWebDriver(String browser, boolean headless) {
        switch (browser.toLowerCase()) {
            case "chrome":
                ChromeOptions chromeOptions = new ChromeOptions();
                if (headless) {
                    chromeOptions.addArguments("--headless=new");
                }
                chromeOptions.addArguments("--no-sandbox");
                chromeOptions.addArguments("--disable-dev-shm-usage");
                chromeOptions.addArguments("--window-size=1920,1080");
                driver = new ChromeDriver(chromeOptions);
                break;
                
            case "firefox":
                FirefoxOptions firefoxOptions = new FirefoxOptions();
                if (headless) {
                    firefoxOptions.addArguments("-headless");
                }
                driver = new FirefoxDriver(firefoxOptions);
                break;
                
            case "edge":
                EdgeOptions edgeOptions = new EdgeOptions();
                if (headless) {
                    edgeOptions.addArguments("--headless=new");
                }
                driver = new EdgeDriver(edgeOptions);
                break;
                
            case "safari":
                SafariOptions safariOptions = new SafariOptions();
                driver = new SafariDriver(safariOptions);
                break;
                
            default:
                LOGGER.warn("Unsupported browser: {}. Using Chrome as default.", browser);
                ChromeOptions defaultOptions = new ChromeOptions();
                if (headless) {
                    defaultOptions.addArguments("--headless=new");
                }
                defaultOptions.addArguments("--no-sandbox");
                defaultOptions.addArguments("--disable-dev-shm-usage");
                driver = new ChromeDriver(defaultOptions);
                break;
        }
        
        // Maximize window
        driver.manage().window().maximize();
        
        // Set timeouts
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(30));
        driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(30));
    }
    
    /**
     * Setup WebDriver binaries using WebDriverManager
     */
    private void setupWebDriverBinaries() {
        WebDriverManager.chromedriver().setup();
        WebDriverManager.firefoxdriver().setup();
        WebDriverManager.edgedriver().setup();
        // Safari doesn't need WebDriverManager setup
    }
    
    /**
     * Get browser name from parameters, system property, or default to Chrome
     * 
     * @param browserParam Browser parameter from TestNG
     * @return Browser name
     */
    private String getBrowserName(String browserParam) {
        // Priority: 1) TestNG parameter, 2) System property, 3) Default to Chrome
        if (browserParam != null && !browserParam.isEmpty()) {
            return browserParam;
        }
        
        String systemBrowser = System.getProperty("browser");
        if (systemBrowser != null && !systemBrowser.isEmpty()) {
            return systemBrowser;
        }
        
        return "chrome";
    }
    
    /**
     * Determine if headless mode should be used
     * 
     * @param headlessParam Headless parameter from TestNG
     * @return Headless mode flag
     */
    private boolean isHeadlessMode(Boolean headlessParam) {
        // Priority: 1) TestNG parameter, 2) System property, 3) Default to false
        if (headlessParam != null) {
            return headlessParam;
        }
        
        String systemHeadless = System.getProperty("headless");
        if (systemHeadless != null && !systemHeadless.isEmpty()) {
            return Boolean.parseBoolean(systemHeadless);
        }
        
        return false;
    }
    
    /**
     * Capture screenshot and save to file
     * 
     * @param testName Name of the test
     */
    private void captureScreenshot(String testName) {
        if (driver instanceof TakesScreenshot) {
            try {
                File screenshotFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
                String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
                String fileName = String.format("%s/%s_%s.png", SCREENSHOT_DIR, testName, timestamp);
                Files.copy(screenshotFile.toPath(), Path.of(fileName));
                LOGGER.info("Screenshot saved: {}", fileName);
            } catch (IOException e) {
                LOGGER.error("Failed to capture screenshot", e);
            }
        }
    }
    
    /**
     * Get the WebDriver instance
     * 
     * @return WebDriver instance
     */
    @Override
    public WebDriver getDriver() {
        return driver;
    }
}

