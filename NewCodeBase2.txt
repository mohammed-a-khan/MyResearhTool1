package com.cstestforge.framework.selenium.java.wait;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

/**
 * Interface defining the contract for all wait strategies.
 * Provides methods for waiting for conditions with fluent interface.
 */
public interface CSWaitStrategy<T> {
    
    /**
     * Wait until the condition is satisfied using default timeout.
     *
     * @return The result of the wait operation (typically element or boolean)
     * @throws org.openqa.selenium.TimeoutException if the timeout expires
     */
    T until();
    
    /**
     * Wait until the condition is satisfied using specified timeout.
     *
     * @param timeoutInSeconds Timeout in seconds
     * @return The result of the wait operation
     * @throws org.openqa.selenium.TimeoutException if the timeout expires
     */
    T until(long timeoutInSeconds);
    
    /**
     * Set custom polling interval.
     *
     * @param intervalInMillis Polling interval in milliseconds
     * @return This wait strategy instance for method chaining
     */
    CSWaitStrategy<T> pollingEvery(long intervalInMillis);
    
    /**
     * Set custom failure message.
     *
     * @param message Message to include in timeout exception
     * @return This wait strategy instance for method chaining
     */
    CSWaitStrategy<T> withMessage(String message);
    
    /**
     * Set whether to ignore specific exceptions during polling.
     * 
     * @param ignore Whether to ignore specific exceptions
     * @return This wait strategy instance for method chaining
     */
    CSWaitStrategy<T> ignoreExceptions(boolean ignore);
    
    /**
     * Add an exception type to ignore during polling.
     * 
     * @param exceptionType Exception type to ignore
     * @return This wait strategy instance for method chaining
     */
    CSWaitStrategy<T> ignoreException(Class<? extends Throwable> exceptionType);
    
    /**
     * Set a screenshot capture strategy if wait fails.
     * 
     * @param captureScreenshot Whether to capture screenshot on failure
     * @return This wait strategy instance for method chaining
     */
    CSWaitStrategy<T> withScreenshot(boolean captureScreenshot);
    
    /**
     * Register a callback to execute before each poll attempt.
     * 
     * @param callback Callback to execute
     * @return This wait strategy instance for method chaining
     */
    CSWaitStrategy<T> beforePolling(Runnable callback);
    
    /**
     * Register a callback to execute after each poll attempt.
     * 
     * @param callback Callback to execute
     * @return This wait strategy instance for method chaining
     */
    CSWaitStrategy<T> afterPolling(Runnable callback);
}


package com.cstestforge.framework.selenium.java.wait;

import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSScreenshotManager;
import com.cstestforge.framework.selenium.java.browser.CSWebDriverManager;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.FluentWait;
import org.openqa.selenium.support.ui.Wait;

import java.time.Duration;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Function;

/**
 * Abstract base class for all wait strategies.
 * Provides common functionality for wait implementations.
 *
 * @param <T> The type of the wait result
 */
public abstract class CSAbstractWaitStrategy<T> implements CSWaitStrategy<T> {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSAbstractWaitStrategy.class);
    protected static final long DEFAULT_TIMEOUT_SECONDS = 30;
    protected static final long DEFAULT_POLLING_INTERVAL_MILLIS = 500;
    
    protected final WebDriver driver;
    protected final WebElement element;
    protected String customMessage;
    protected long timeoutInSeconds;
    protected long pollingIntervalInMillis;
    protected boolean ignoreAllExceptions;
    protected Set<Class<? extends Throwable>> ignoredExceptions;
    protected boolean captureScreenshot;
    protected Runnable beforePollingCallback;
    protected Runnable afterPollingCallback;
    protected String waitDescription;
    
    /**
     * Constructor for element-based wait strategies.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     */
    protected CSAbstractWaitStrategy(WebDriver driver, WebElement element) {
        this.driver = driver;
        this.element = element;
        this.timeoutInSeconds = DEFAULT_TIMEOUT_SECONDS;
        this.pollingIntervalInMillis = DEFAULT_POLLING_INTERVAL_MILLIS;
        this.ignoredExceptions = new HashSet<>();
        this.ignoredExceptions.add(StaleElementReferenceException.class);
        this.ignoredExceptions.add(NoSuchElementException.class);
        this.ignoreAllExceptions = false;
        this.captureScreenshot = true;
        setWaitDescription();
    }
    
    /**
     * Constructor for driver-based wait strategies.
     *
     * @param driver WebDriver instance
     */
    protected CSAbstractWaitStrategy(WebDriver driver) {
        this(driver, null);
    }
    
    /**
     * Set the description of this wait strategy.
     * Should be overridden by concrete implementations.
     */
    protected abstract void setWaitDescription();
    
    /**
     * Create the expected condition for this wait strategy.
     * Must be implemented by concrete implementations.
     *
     * @return The expected condition function
     */
    protected abstract Function<WebDriver, T> createWaitFunction();
    
    @Override
    public T until() {
        return until(timeoutInSeconds);
    }
    
    @Override
    public T until(long timeoutInSeconds) {
        long startTime = System.currentTimeMillis();
        AtomicLong lastPollTime = new AtomicLong(startTime);
        
        try {
            LOGGER.debug("Starting {} with timeout {} seconds", waitDescription, timeoutInSeconds);
            
            // Create a FluentWait instance
            Wait<WebDriver> wait = new FluentWait<>(driver)
                .withTimeout(Duration.ofSeconds(timeoutInSeconds))
                .pollingEvery(Duration.ofMillis(pollingIntervalInMillis));
            
            // Add ignored exceptions
            if (ignoreAllExceptions) {
                wait = wait.ignoring(Exception.class);
            } else {
                for (Class<? extends Throwable> exceptionClass : ignoredExceptions) {
                    wait = wait.ignoring(exceptionClass);
                }
            }
            
            // Create the wait function with callbacks
            Function<WebDriver, T> waitFunction = createWaitFunction();
            Function<WebDriver, T> wrappedFunction = driver -> {
                if (beforePollingCallback != null) {
                    beforePollingCallback.run();
                }
                
                lastPollTime.set(System.currentTimeMillis());
                T result = waitFunction.apply(driver);
                
                if (afterPollingCallback != null) {
                    afterPollingCallback.run();
                }
                
                return result;
            };
            
            // Execute the wait
            T result = wait.until(wrappedFunction);
            
            long endTime = System.currentTimeMillis();
            LOGGER.debug("{} completed successfully in {} ms", waitDescription, (endTime - startTime));
            
            return result;
        } catch (TimeoutException e) {
            long failTime = System.currentTimeMillis();
            String message = formatTimeoutMessage(failTime - startTime, failTime - lastPollTime.get());
            LOGGER.error(message);
            
            if (captureScreenshot) {
                try {
                    String screenshotPath = CSScreenshotManager.takeScreenshot(driver, "wait_failed_" + System.currentTimeMillis());
                    LOGGER.error("Wait failure screenshot saved to: {}", screenshotPath);
                    CSReporter.getInstance().addScreenshot("Wait Failure", screenshotPath);
                } catch (Exception screenshotException) {
                    LOGGER.error("Failed to capture wait failure screenshot", screenshotException);
                }
            }
            
            throw new TimeoutException(message, e);
        }
    }
    
    @Override
    public CSWaitStrategy<T> pollingEvery(long intervalInMillis) {
        this.pollingIntervalInMillis = intervalInMillis;
        return this;
    }
    
    @Override
    public CSWaitStrategy<T> withMessage(String message) {
        this.customMessage = message;
        return this;
    }
    
    @Override
    public CSWaitStrategy<T> ignoreExceptions(boolean ignore) {
        this.ignoreAllExceptions = ignore;
        return this;
    }
    
    @Override
    public CSWaitStrategy<T> ignoreException(Class<? extends Throwable> exceptionType) {
        this.ignoredExceptions.add(exceptionType);
        return this;
    }
    
    @Override
    public CSWaitStrategy<T> withScreenshot(boolean captureScreenshot) {
        this.captureScreenshot = captureScreenshot;
        return this;
    }
    
    @Override
    public CSWaitStrategy<T> beforePolling(Runnable callback) {
        this.beforePollingCallback = callback;
        return this;
    }
    
    @Override
    public CSWaitStrategy<T> afterPolling(Runnable callback) {
        this.afterPollingCallback = callback;
        return this;
    }
    
    /**
     * Format a timeout exception message with detailed information.
     *
     * @param totalWaitTime Total wait time in milliseconds
     * @param lastPollDuration Duration of the last poll attempt in milliseconds
     * @return Formatted timeout message
     */
    protected String formatTimeoutMessage(long totalWaitTime, long lastPollDuration) {
        StringBuilder message = new StringBuilder();
        
        if (customMessage != null && !customMessage.isEmpty()) {
            message.append(customMessage);
        } else {
            message.append(waitDescription).append(" timed out");
        }
        
        message.append(" after ").append(totalWaitTime).append(" ms");
        message.append(" (last poll: ").append(lastPollDuration).append(" ms)");
        
        if (element != null) {
            try {
                message.append("\nElement: ").append(describeElement(element));
            } catch (Exception e) {
                message.append("\nElement: [Unable to describe element - ").append(e.getMessage()).append("]");
            }
        }
        
        message.append("\nPage URL: ").append(driver.getCurrentUrl());
        message.append("\nPage Title: ").append(driver.getTitle());
        
        return message.toString();
    }
    
    /**
     * Generate a detailed description of a WebElement for debugging.
     *
     * @param element Element to describe
     * @return Element description
     */
    protected String describeElement(WebElement element) {
        try {
            StringBuilder description = new StringBuilder();
            description.append("Tag: ").append(element.getTagName());
            
            String id = element.getAttribute("id");
            if (id != null && !id.isEmpty()) {
                description.append(", ID: ").append(id);
            }
            
            String className = element.getAttribute("class");
            if (className != null && !className.isEmpty()) {
                description.append(", Class: ").append(className);
            }
            
            String name = element.getAttribute("name");
            if (name != null && !name.isEmpty()) {
                description.append(", Name: ").append(name);
            }
            
            String text = element.getText();
            if (text != null && !text.isEmpty() && text.length() <= 50) {
                description.append(", Text: '").append(text).append("'");
            } else if (text != null && !text.isEmpty()) {
                description.append(", Text: '").append(text.substring(0, 47)).append("...'");
            }
            
            try {
                Point location = element.getLocation();
                Dimension size = element.getSize();
                description.append(", Location: (").append(location.getX()).append(",").append(location.getY()).append(")");
                description.append(", Size: ").append(size.getWidth()).append("x").append(size.getHeight());
            } catch (Exception e) {
                // Ignore location/size retrieval errors
            }
            
            return description.toString();
        } catch (StaleElementReferenceException e) {
            return "[Stale Element]";
        } catch (Exception e) {
            return "[Element description failed: " + e.getMessage() + "]";
        }
    }
}


package com.cstestforge.framework.selenium.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;

import java.util.function.Function;

/**
 * Wait strategy for element visibility.
 * Waits until an element is visible in the DOM, meaning it's present, 
 * has height and width greater than 0, and is displayed.
 */
public class CSVisibilityWait extends CSAbstractWaitStrategy<WebElement> {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSVisibilityWait.class);
    
    private boolean checkOpacity;
    private boolean checkOverlays;
    private Double minimumVisiblePercentage;
    private boolean checkCssDisplay;
    private boolean checkCssVisibility;
    
    /**
     * Creates a wait strategy for element visibility.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     */
    public CSVisibilityWait(WebDriver driver, WebElement element) {
        super(driver, element);
        this.checkOpacity = true;
        this.checkOverlays = true;
        this.checkCssDisplay = true;
        this.checkCssVisibility = true;
        this.minimumVisiblePercentage = null; // Default: check any visibility
    }
    
    @Override
    protected void setWaitDescription() {
        this.waitDescription = "Wait for element visibility";
    }
    
    /**
     * Set whether to check element opacity.
     * 
     * @param check Whether to check opacity
     * @return This wait strategy instance for method chaining
     */
    public CSVisibilityWait checkOpacity(boolean check) {
        this.checkOpacity = check;
        return this;
    }
    
    /**
     * Set whether to check if the element is covered by overlays.
     * 
     * @param check Whether to check overlays
     * @return This wait strategy instance for method chaining
     */
    public CSVisibilityWait checkOverlays(boolean check) {
        this.checkOverlays = check;
        return this;
    }
    
    /**
     * Set whether to check CSS display property.
     * 
     * @param check Whether to check CSS display
     * @return This wait strategy instance for method chaining
     */
    public CSVisibilityWait checkCssDisplay(boolean check) {
        this.checkCssDisplay = check;
        return this;
    }
    
    /**
     * Set whether to check CSS visibility property.
     * 
     * @param check Whether to check CSS visibility
     * @return This wait strategy instance for method chaining
     */
    public CSVisibilityWait checkCssVisibility(boolean check) {
        this.checkCssVisibility = check;
        return this;
    }
    
    /**
     * Set minimum percentage of the element that must be visible.
     * 
     * @param percentage Percentage (0.0 to 100.0)
     * @return This wait strategy instance for method chaining
     */
    public CSVisibilityWait minimumVisiblePercentage(double percentage) {
        if (percentage < 0.0 || percentage > 100.0) {
            throw new IllegalArgumentException("Visible percentage must be between 0.0 and 100.0");
        }
        this.minimumVisiblePercentage = percentage;
        return this;
    }
    
    @Override
    protected Function<WebDriver, WebElement> createWaitFunction() {
        return driver -> {
            try {
                // First check basic visibility (present in DOM and displayed)
                if (!isDisplayed(element)) {
                    throw new ElementNotVisibleException("Element is not displayed");
                }
                
                // Check element size
                Dimension size = element.getSize();
                if (size.getHeight() <= 0 || size.getWidth() <= 0) {
                    throw new ElementNotVisibleException(
                            "Element has zero size: " + size.getWidth() + "x" + size.getHeight());
                }
                
                // Check CSS properties if needed
                if (checkCssDisplay && "none".equals(element.getCssValue("display"))) {
                    throw new ElementNotVisibleException("Element has display:none");
                }
                
                if (checkCssVisibility && "hidden".equals(element.getCssValue("visibility"))) {
                    throw new ElementNotVisibleException("Element has visibility:hidden");
                }
                
                // Check opacity if needed
                if (checkOpacity) {
                    String opacityStr = element.getCssValue("opacity");
                    if (opacityStr != null && !opacityStr.isEmpty()) {
                        try {
                            double opacity = Double.parseDouble(opacityStr);
                            if (opacity < 0.1) { // Allow very slight transparency
                                throw new ElementNotVisibleException("Element has opacity: " + opacity);
                            }
                        } catch (NumberFormatException e) {
                            // Ignore opacity parsing errors
                            LOGGER.debug("Could not parse opacity value: {}", opacityStr);
                        }
                    }
                }
                
                // Check if element is covered by overlays
                if (checkOverlays && isElementCovered(element)) {
                    throw new ElementNotVisibleException("Element is covered by overlays");
                }
                
                // Check visible percentage if specified
                if (minimumVisiblePercentage != null && 
                    getVisiblePercentage(element) < minimumVisiblePercentage) {
                    throw new ElementNotVisibleException(
                            "Element visible percentage is below required: " + minimumVisiblePercentage + "%");
                }
                
                return element;
            } catch (StaleElementReferenceException e) {
                throw e;
            } catch (ElementNotVisibleException e) {
                throw e;
            } catch (Exception e) {
                throw new ElementNotVisibleException("Error checking element visibility: " + e.getMessage(), e);
            }
        };
    }
    
    /**
     * Checks if an element is displayed, handling potential exceptions.
     *
     * @param element Element to check
     * @return True if the element is displayed
     */
    private boolean isDisplayed(WebElement element) {
        try {
            return element.isDisplayed();
        } catch (StaleElementReferenceException e) {
            throw e;
        } catch (Exception e) {
            LOGGER.debug("Error checking if element is displayed: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Checks if an element is covered by other elements.
     *
     * @param element Element to check
     * @return True if the element is covered
     */
    private boolean isElementCovered(WebElement element) {
        try {
            // Get element's center point
            Point location = element.getLocation();
            Dimension size = element.getSize();
            int centerX = location.getX() + size.getWidth() / 2;
            int centerY = location.getY() + size.getHeight() / 2;
            
            // Execute JavaScript to check if the element is the topmost at its center point
            String script = 
                "var element = arguments[0];" +
                "var centerX = arguments[1];" +
                "var centerY = arguments[2];" +
                "var elementAtPoint = document.elementFromPoint(centerX, centerY);" +
                "if (!elementAtPoint) return true;" + // Point is outside viewport
                "return !element.contains(elementAtPoint) && !elementAtPoint.contains(element);";
            
            return (Boolean) ((JavascriptExecutor) driver).executeScript(script, element, centerX, centerY);
        } catch (Exception e) {
            LOGGER.debug("Error checking if element is covered: {}", e.getMessage());
            return false; // Assume not covered if check fails
        }
    }
    
    /**
     * Calculates the percentage of an element that's visible in the viewport.
     *
     * @param element Element to check
     * @return Percentage of visibility (0-100)
     */
    private double getVisiblePercentage(WebElement element) {
        try {
            String script = 
                "var element = arguments[0];" +
                "var rect = element.getBoundingClientRect();" +
                "var windowHeight = window.innerHeight || document.documentElement.clientHeight;" +
                "var windowWidth = window.innerWidth || document.documentElement.clientWidth;" +
                
                "var visibleWidth = Math.min(rect.right, windowWidth) - Math.max(rect.left, 0);" +
                "var visibleHeight = Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0);" +
                
                "if (visibleWidth <= 0 || visibleHeight <= 0) return 0;" +
                
                "var elementArea = rect.width * rect.height;" +
                "var visibleArea = visibleWidth * visibleHeight;" +
                
                "return (visibleArea / elementArea) * 100;";
            
            Object result = ((JavascriptExecutor) driver).executeScript(script, element);
            if (result instanceof Number) {
                return ((Number) result).doubleValue();
            }
            return 0.0;
        } catch (Exception e) {
            LOGGER.debug("Error calculating visible percentage: {}", e.getMessage());
            return 0.0; // Assume not visible if check fails
        }
    }
}


package com.cstestforge.framework.selenium.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;

import java.util.function.Function;

/**
 * Wait strategy for element clickability.
 * Waits until an element is clickable, meaning it's visible and enabled.
 * Also provides advanced clickability checks like overlay detection and
 * minimum size verification.
 */
public class CSClickableWait extends CSAbstractWaitStrategy<WebElement> {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSClickableWait.class);
    private static final int DEFAULT_MIN_CLICKABLE_DIMENSION = 5; // pixels
    
    private boolean checkOverlays;
    private boolean checkSize;
    private boolean checkEnabled;
    private boolean checkPointerEvents;
    private int minClickableWidth;
    private int minClickableHeight;
    
    /**
     * Creates a wait strategy for element clickability.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     */
    public CSClickableWait(WebDriver driver, WebElement element) {
        super(driver, element);
        this.checkOverlays = true;
        this.checkSize = true;
        this.checkEnabled = true;
        this.checkPointerEvents = true;
        this.minClickableWidth = DEFAULT_MIN_CLICKABLE_DIMENSION;
        this.minClickableHeight = DEFAULT_MIN_CLICKABLE_DIMENSION;
    }
    
    @Override
    protected void setWaitDescription() {
        this.waitDescription = "Wait for element to be clickable";
    }
    
    /**
     * Set whether to check if the element is covered by overlays.
     * 
     * @param check Whether to check overlays
     * @return This wait strategy instance for method chaining
     */
    public CSClickableWait checkOverlays(boolean check) {
        this.checkOverlays = check;
        return this;
    }
    
    /**
     * Set whether to check if the element is large enough to be clicked.
     * 
     * @param check Whether to check size
     * @return This wait strategy instance for method chaining
     */
    public CSClickableWait checkSize(boolean check) {
        this.checkSize = check;
        return this;
    }
    
    /**
     * Set whether to check if the element is enabled.
     * 
     * @param check Whether to check enabled state
     * @return This wait strategy instance for method chaining
     */
    public CSClickableWait checkEnabled(boolean check) {
        this.checkEnabled = check;
        return this;
    }
    
    /**
     * Set whether to check CSS pointer-events property.
     * 
     * @param check Whether to check pointer-events
     * @return This wait strategy instance for method chaining
     */
    public CSClickableWait checkPointerEvents(boolean check) {
        this.checkPointerEvents = check;
        return this;
    }
    
    /**
     * Set minimum dimensions for an element to be considered clickable.
     * 
     * @param width Minimum width in pixels
     * @param height Minimum height in pixels
     * @return This wait strategy instance for method chaining
     */
    public CSClickableWait minClickableSize(int width, int height) {
        if (width < 0 || height < 0) {
            throw new IllegalArgumentException("Clickable dimensions must be non-negative");
        }
        this.minClickableWidth = width;
        this.minClickableHeight = height;
        return this;
    }
    
    @Override
    protected Function<WebDriver, WebElement> createWaitFunction() {
        return driver -> {
            try {
                // First check basic visibility
                if (!isDisplayed(element)) {
                    throw new ElementNotInteractableException("Element is not displayed");
                }
                
                // Check if element is enabled
                if (checkEnabled && !isEnabled(element)) {
                    throw new ElementNotInteractableException("Element is not enabled");
                }
                
                // Check element size
                if (checkSize) {
                    Dimension size = element.getSize();
                    if (size.getWidth() < minClickableWidth || size.getHeight() < minClickableHeight) {
                        throw new ElementNotInteractableException(
                                "Element size " + size.getWidth() + "x" + size.getHeight() + 
                                " is below minimum clickable size " + minClickableWidth + "x" + minClickableHeight);
                    }
                }
                
                // Check if element is covered by overlays
                if (checkOverlays && isElementCovered(element)) {
                    throw new ElementClickInterceptedException(
                            "Element click would be intercepted by another element");
                }
                
                // Check pointer-events CSS property
                if (checkPointerEvents && "none".equals(element.getCssValue("pointer-events"))) {
                    throw new ElementNotInteractableException("Element has pointer-events: none");
                }
                
                // Additional custom clickability check
                if (!isActuallyClickable(element)) {
                    throw new ElementNotInteractableException("Element is not actually clickable");
                }
                
                return element;
            } catch (StaleElementReferenceException e) {
                throw e;
            } catch (ElementNotInteractableException | ElementClickInterceptedException e) {
                throw e;
            } catch (Exception e) {
                throw new ElementNotInteractableException("Error checking element clickability: " + e.getMessage(), e);
            }
        };
    }
    
    /**
     * Checks if an element is displayed, handling potential exceptions.
     *
     * @param element Element to check
     * @return True if the element is displayed
     */
    private boolean isDisplayed(WebElement element) {
        try {
            return element.isDisplayed();
        } catch (StaleElementReferenceException e) {
            throw e;
        } catch (Exception e) {
            LOGGER.debug("Error checking if element is displayed: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Checks if an element is enabled, handling potential exceptions.
     *
     * @param element Element to check
     * @return True if the element is enabled
     */
    private boolean isEnabled(WebElement element) {
        try {
            return element.isEnabled();
        } catch (StaleElementReferenceException e) {
            throw e;
        } catch (Exception e) {
            LOGGER.debug("Error checking if element is enabled: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Checks if an element is covered by other elements that would intercept clicks.
     *
     * @param element Element to check
     * @return True if the element is covered
     */
    private boolean isElementCovered(WebElement element) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            
            // Get element's center point
            Point location = element.getLocation();
            Dimension size = element.getSize();
            int centerX = location.getX() + size.getWidth() / 2;
            int centerY = location.getY() + size.getHeight() / 2;
            
            // Execute JavaScript to check multiple points on the element
            String checkPointScript = 
                "var element = arguments[0];" +
                "var x = arguments[1];" +
                "var y = arguments[2];" +
                "var elementAtPoint = document.elementFromPoint(x, y);" +
                "if (!elementAtPoint) return true;" + // Point is outside viewport
                "return !element.contains(elementAtPoint) && !elementAtPoint.contains(element);";
            
            // Check center point
            Boolean centerCovered = (Boolean) js.executeScript(checkPointScript, element, centerX, centerY);
            if (centerCovered) {
                return true;
            }
            
            // If element is large enough, also check the four corners (with 5px padding)
            if (size.getWidth() > 20 && size.getHeight() > 20) {
                int padding = 5;
                int left = location.getX() + padding;
                int right = location.getX() + size.getWidth() - padding;
                int top = location.getY() + padding;
                int bottom = location.getY() + size.getHeight() - padding;
                
                Boolean topLeftCovered = (Boolean) js.executeScript(checkPointScript, element, left, top);
                Boolean topRightCovered = (Boolean) js.executeScript(checkPointScript, element, right, top);
                Boolean bottomLeftCovered = (Boolean) js.executeScript(checkPointScript, element, left, bottom);
                Boolean bottomRightCovered = (Boolean) js.executeScript(checkPointScript, element, right, bottom);
                
                // If all corners are covered, consider the element covered
                if (topLeftCovered && topRightCovered && bottomLeftCovered && bottomRightCovered) {
                    return true;
                }
            }
            
            return false;
        } catch (Exception e) {
            LOGGER.debug("Error checking if element is covered: {}", e.getMessage());
            return false; // Assume not covered if check fails
        }
    }
    
    /**
     * Performs a comprehensive check of element clickability using JavaScript.
     *
     * @param element Element to check
     * @return True if the element is actually clickable
     */
    private boolean isActuallyClickable(WebElement element) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            
            String script = 
                "var element = arguments[0];" +
                "var style = window.getComputedStyle(element);" +
                
                // Check basic style properties
                "if (style.display === 'none') return false;" +
                "if (style.visibility === 'hidden') return false;" +
                "if (style.opacity < 0.1) return false;" +
                
                // Check if element or any parent has pointer-events: none
                "var currentElement = element;" +
                "while (currentElement) {" +
                "  if (window.getComputedStyle(currentElement).pointerEvents === 'none') return false;" +
                "  currentElement = currentElement.parentElement;" +
                "}" +
                
                // Check if element is within viewport
                "var rect = element.getBoundingClientRect();" +
                "var windowHeight = window.innerHeight || document.documentElement.clientHeight;" +
                "var windowWidth = window.innerWidth || document.documentElement.clientWidth;" +
                "if (rect.right < 0 || rect.bottom < 0 || " +
                "    rect.left > windowWidth || rect.top > windowHeight) return false;" +
                
                // Check if element has zero size
                "if (rect.width < 1 || rect.height < 1) return false;" +
                
                // For input elements, check if they're readonly or disabled
                "if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || " +
                "    element.tagName === 'SELECT' || element.tagName === 'BUTTON') {" +
                "  if (element.disabled) return false;" +
                "  if (element.readOnly && (element.tagName !== 'SELECT')) return false;" +
                "}" +
                
                // For anchor elements, check if they have href
                "if (element.tagName === 'A' && !element.href) {" +
                "  // Allow anchors without href if they have click handlers or clickable roles" +
                "  var hasClickHandler = element.onclick || element.getAttribute('ng-click') || " +
                "                         element.getAttribute('onClick') || element.getAttribute('onclick');" +
                "  var hasClickableRole = element.getAttribute('role') === 'button' || " +
                "                         element.getAttribute('role') === 'link';" +
                "  if (!hasClickHandler && !hasClickableRole) return false;" +
                "}" +
                
                // Check ARIA attributes
                "if (element.getAttribute('aria-disabled') === 'true') return false;" +
                "if (element.getAttribute('aria-hidden') === 'true') return false;" +
                
                // All checks passed
                "return true;";
            
            return (Boolean) js.executeScript(script, element);
        } catch (Exception e) {
            LOGGER.debug("Error checking if element is actually clickable: {}", e.getMessage());
            return true; // Assume clickable if advanced check fails
        }
    }
}


package com.cstestforge.framework.selenium.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSTextUtils;
import org.openqa.selenium.*;

import java.util.function.Function;
import java.util.regex.Pattern;

/**
 * Wait strategy for text in an element.
 * Waits until an element contains, equals, or matches a specific text.
 * Provides options for case sensitivity, whitespace handling, and regex matching.
 */
public class CSTextWait extends CSAbstractWaitStrategy<WebElement> {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSTextWait.class);
    
    public enum TextMatchType {
        CONTAINS,       // Element text contains the expected text
        EQUALS,         // Element text equals the expected text
        REGEX,          // Element text matches the regular expression
        NOT_CONTAINS,   // Element text does not contain the expected text
        NOT_EQUALS,     // Element text does not equal the expected text
        NOT_REGEX       // Element text does not match the regular expression
    }
    
    private String expectedText;
    private Pattern pattern;
    private TextMatchType matchType;
    private boolean caseSensitive;
    private boolean normalizeWhitespace;
    private boolean trimText;
    private boolean checkPlaceholder;
    private boolean checkValue;
    private boolean checkChildrenText;
    
    /**
     * Creates a wait strategy for element text (contains match).
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     * @param text Expected text
     */
    public CSTextWait(WebDriver driver, WebElement element, String text) {
        this(driver, element, text, TextMatchType.CONTAINS);
    }
    
    /**
     * Creates a wait strategy for element text with specific match type.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     * @param text Expected text
     * @param matchType Type of text matching
     */
    public CSTextWait(WebDriver driver, WebElement element, String text, TextMatchType matchType) {
        super(driver, element);
        this.expectedText = text;
        this.matchType = matchType;
        this.caseSensitive = true;
        this.normalizeWhitespace = true;
        this.trimText = true;
        this.checkPlaceholder = false;
        this.checkValue = false;
        this.checkChildrenText = true;
        
        if (matchType == TextMatchType.REGEX || matchType == TextMatchType.NOT_REGEX) {
            this.pattern = Pattern.compile(text);
        }
    }
    
    /**
     * Creates a wait strategy for element text with regex pattern.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     * @param pattern Regex pattern
     * @param matchType Type of text matching (must be REGEX or NOT_REGEX)
     */
    public CSTextWait(WebDriver driver, WebElement element, Pattern pattern, TextMatchType matchType) {
        super(driver, element);
        if (matchType != TextMatchType.REGEX && matchType != TextMatchType.NOT_REGEX) {
            throw new IllegalArgumentException("Match type must be REGEX or NOT_REGEX when using Pattern");
        }
        this.expectedText = pattern.pattern();
        this.pattern = pattern;
        this.matchType = matchType;
        this.caseSensitive = true; // Pattern handles its own case sensitivity
        this.normalizeWhitespace = true;
        this.trimText = true;
        this.checkPlaceholder = false;
        this.checkValue = false;
        this.checkChildrenText = true;
    }
    
    @Override
    protected void setWaitDescription() {
        String verb = "";
        switch (matchType) {
            case CONTAINS:
                verb = "to contain";
                break;
            case EQUALS:
                verb = "to equal";
                break;
            case REGEX:
                verb = "to match regex";
                break;
            case NOT_CONTAINS:
                verb = "to not contain";
                break;
            case NOT_EQUALS:
                verb = "to not equal";
                break;
            case NOT_REGEX:
                verb = "to not match regex";
                break;
        }
        this.waitDescription = "Wait for element text " + verb + " '" + expectedText + "'";
    }
    
    /**
     * Set case sensitivity for text matching.
     * 
     * @param caseSensitive Whether matching should be case sensitive
     * @return This wait strategy instance for method chaining
     */
    public CSTextWait caseSensitive(boolean caseSensitive) {
        this.caseSensitive = caseSensitive;
        return this;
    }
    
    /**
     * Set whether to normalize whitespace in text.
     * 
     * @param normalize Whether to normalize whitespace
     * @return This wait strategy instance for method chaining
     */
    public CSTextWait normalizeWhitespace(boolean normalize) {
        this.normalizeWhitespace = normalize;
        return this;
    }
    
    /**
     * Set whether to trim leading/trailing whitespace.
     * 
     * @param trim Whether to trim text
     * @return This wait strategy instance for method chaining
     */
    public CSTextWait trimText(boolean trim) {
        this.trimText = trim;
        return this;
    }
    
    /**
     * Set whether to check placeholder attribute.
     * 
     * @param check Whether to check placeholder
     * @return This wait strategy instance for method chaining
     */
    public CSTextWait checkPlaceholder(boolean check) {
        this.checkPlaceholder = check;
        return this;
    }
    
    /**
     * Set whether to check value attribute.
     * 
     * @param check Whether to check value
     * @return This wait strategy instance for method chaining
     */
    public CSTextWait checkValue(boolean check) {
        this.checkValue = check;
        return this;
    }
    
    /**
     * Set whether to check text in child elements.
     * 
     * @param check Whether to check children text
     * @return This wait strategy instance for method chaining
     */
    public CSTextWait checkChildrenText(boolean check) {
        this.checkChildrenText = check;
        return this;
    }
    
    @Override
    protected Function<WebDriver, WebElement> createWaitFunction() {
        return driver -> {
            try {
                if (!isDisplayed(element)) {
                    throw new ElementNotVisibleException("Element is not displayed");
                }
                
                // Get element text, handling all configuration options
                String actualText = getElementText();
                
                // Process text according to options
                if (trimText) {
                    actualText = actualText.trim();
                }
                
                if (normalizeWhitespace) {
                    actualText = CSTextUtils.normalizeWhitespace(actualText);
                }
                
                if (!caseSensitive && matchType != TextMatchType.REGEX && matchType != TextMatchType.NOT_REGEX) {
                    actualText = actualText.toLowerCase();
                    String compareText = expectedText.toLowerCase();
                    
                    // Perform non-regex matching with case insensitivity
                    if (!textMatches(actualText, compareText)) {
                        throw new TextMatchException(matchType, compareText, actualText);
                    }
                } else {
                    // Perform regex or case-sensitive matching
                    if (!textMatches(actualText, expectedText)) {
                        throw new TextMatchException(matchType, expectedText, actualText);
                    }
                }
                
                return element;
            } catch (StaleElementReferenceException e) {
                throw e;
            } catch (TextMatchException e) {
                throw e;
            } catch (Exception e) {
                throw new RuntimeException("Error checking element text: " + e.getMessage(), e);
            }
        };
    }
    
    /**
     * Gets the element's text, considering all options like value and placeholder.
     *
     * @return The element text
     */
    private String getElementText() {
        StringBuilder textBuilder = new StringBuilder();
        
        // Get the direct text
        String directText = element.getText();
        if (directText != null && !directText.isEmpty()) {
            textBuilder.append(directText);
        }
        
        // Check value attribute if configured
        if (checkValue) {
            try {
                String value = element.getAttribute("value");
                if (value != null && !value.isEmpty()) {
                    if (textBuilder.length() > 0) {
                        textBuilder.append(" ");
                    }
                    textBuilder.append(value);
                }
            } catch (Exception e) {
                LOGGER.debug("Error getting value attribute: {}", e.getMessage());
            }
        }
        
        // Check placeholder attribute if configured
        if (checkPlaceholder) {
            try {
                String placeholder = element.getAttribute("placeholder");
                if (placeholder != null && !placeholder.isEmpty()) {
                    if (textBuilder.length() > 0) {
                        textBuilder.append(" ");
                    }
                    textBuilder.append(placeholder);
                }
            } catch (Exception e) {
                LOGGER.debug("Error getting placeholder attribute: {}", e.getMessage());
            }
        }
        
        // If still no text and we should check child elements, get text via JavaScript
        if (textBuilder.length() == 0 && checkChildrenText) {
            try {
                String script = "return arguments[0].textContent || arguments[0].innerText || '';";
                String jsText = (String) ((JavascriptExecutor) driver).executeScript(script, element);
                if (jsText != null && !jsText.isEmpty()) {
                    textBuilder.append(jsText);
                }
            } catch (Exception e) {
                LOGGER.debug("Error getting text with JavaScript: {}", e.getMessage());
            }
        }
        
        return textBuilder.toString();
    }
    
    /**
     * Checks if an element is displayed, handling potential exceptions.
     *
     * @param element Element to check
     * @return True if the element is displayed
     */
    private boolean isDisplayed(WebElement element) {
        try {
            return element.isDisplayed();
        } catch (StaleElementReferenceException e) {
            throw e;
        } catch (Exception e) {
            LOGGER.debug("Error checking if element is displayed: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Checks if the actual text matches the expected text according to match type.
     *
     * @param actualText Actual element text
     * @param expectedText Expected text or pattern
     * @return True if the text matches
     */
    private boolean textMatches(String actualText, String expectedText) {
        switch (matchType) {
            case CONTAINS:
                return actualText.contains(expectedText);
            case EQUALS:
                return actualText.equals(expectedText);
            case REGEX:
                return pattern.matcher(actualText).find();
            case NOT_CONTAINS:
                return !actualText.contains(expectedText);
            case NOT_EQUALS:
                return !actualText.equals(expectedText);
            case NOT_REGEX:
                return !pattern.matcher(actualText).find();
            default:
                throw new IllegalStateException("Unknown match type: " + matchType);
        }
    }
    
    /**
     * Exception thrown when text does not match the expected condition.
     */
    private static class TextMatchException extends RuntimeException {
        private TextMatchException(TextMatchType matchType, String expected, String actual) {
            super(formatMessage(matchType, expected, actual));
        }
        
        private static String formatMessage(TextMatchType matchType, String expected, String actual) {
            switch (matchType) {
                case CONTAINS:
                    return "Expected text to contain '" + expected + "' but got '" + actual + "'";
                case EQUALS:
                    return "Expected text to equal '" + expected + "' but got '" + actual + "'";
                case REGEX:
                    return "Expected text to match regex '" + expected + "' but got '" + actual + "'";
                case NOT_CONTAINS:
                    return "Expected text to not contain '" + expected + "' but got '" + actual + "'";
                case NOT_EQUALS:
                    return "Expected text to not equal '" + expected + "' but got '" + actual + "'";
                case NOT_REGEX:
                    return "Expected text to not match regex '" + expected + "' but got '" + actual + "'";
                default:
                    return "Text match failed. Expected: '" + expected + "', Actual: '" + actual + "'";
            }
        }
    }
}


package com.cstestforge.framework.selenium.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.*;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;
import java.util.regex.Pattern;

/**
 * Wait strategy for element attributes.
 * Waits until an element has an attribute that meets specific criteria.
 * Supports exact match, contains, regex, and presence/absence checks.
 */
public class CSAttributeWait extends CSAbstractWaitStrategy<WebElement> {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSAttributeWait.class);
    
    public enum AttributeMatchType {
        EXISTS,        // Attribute exists (any value)
        NOT_EXISTS,    // Attribute does not exist
        EQUALS,        // Attribute value equals expected value
        NOT_EQUALS,    // Attribute value does not equal expected value
        CONTAINS,      // Attribute value contains expected value
        NOT_CONTAINS,  // Attribute value does not contain expected value
        REGEX,         // Attribute value matches regex pattern
        NOT_REGEX      // Attribute value does not match regex pattern
    }
    
    private String attributeName;
    private String expectedValue;
    private Pattern pattern;
    private AttributeMatchType matchType;
    private boolean caseSensitive;
    private boolean checkCssProperty;
    private boolean checkHtmlAttribute;
    private boolean checkProperty;
    private Map<String, AttributeMatchType> multiAttributes;
    private Map<String, String> multiValues;
    private Map<String, Pattern> multiPatterns;
    
    /**
     * Creates a wait strategy for a single attribute with equals match.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     * @param attributeName Name of the attribute
     * @param expectedValue Expected attribute value
     */
    public CSAttributeWait(WebDriver driver, WebElement element, String attributeName, String expectedValue) {
        this(driver, element, attributeName, expectedValue, AttributeMatchType.EQUALS);
    }
    
    /**
     * Creates a wait strategy for a single attribute with specific match type.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     * @param attributeName Name of the attribute
     * @param expectedValue Expected attribute value
     * @param matchType Type of attribute matching
     */
    public CSAttributeWait(WebDriver driver, WebElement element, String attributeName, String expectedValue,
                           AttributeMatchType matchType) {
        super(driver, element);
        this.attributeName = attributeName;
        this.expectedValue = expectedValue;
        this.matchType = matchType;
        this.caseSensitive = true;
        this.checkCssProperty = false;
        this.checkHtmlAttribute = true;
        this.checkProperty = false;
        this.multiAttributes = new HashMap<>();
        this.multiValues = new HashMap<>();
        this.multiPatterns = new HashMap<>();
        
        if (matchType == AttributeMatchType.REGEX || matchType == AttributeMatchType.NOT_REGEX) {
            this.pattern = Pattern.compile(expectedValue);
        }
    }
    
    /**
     * Creates a wait strategy for a single attribute with regex pattern.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     * @param attributeName Name of the attribute
     * @param pattern Regex pattern
     * @param matchType Type of attribute matching (must be REGEX or NOT_REGEX)
     */
    public CSAttributeWait(WebDriver driver, WebElement element, String attributeName, Pattern pattern,
                           AttributeMatchType matchType) {
        super(driver, element);
        if (matchType != AttributeMatchType.REGEX && matchType != AttributeMatchType.NOT_REGEX) {
            throw new IllegalArgumentException("Match type must be REGEX or NOT_REGEX when using Pattern");
        }
        this.attributeName = attributeName;
        this.expectedValue = pattern.pattern();
        this.pattern = pattern;
        this.matchType = matchType;
        this.caseSensitive = true;
        this.checkCssProperty = false;
        this.checkHtmlAttribute = true;
        this.checkProperty = false;
        this.multiAttributes = new HashMap<>();
        this.multiValues = new HashMap<>();
        this.multiPatterns = new HashMap<>();
    }
    
    /**
     * Creates a wait strategy for multiple attributes.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     */
    public CSAttributeWait(WebDriver driver, WebElement element) {
        super(driver, element);
        this.attributeName = null; // not used in multi-attribute mode
        this.expectedValue = null; // not used in multi-attribute mode
        this.matchType = null; // not used in multi-attribute mode
        this.caseSensitive = true;
        this.checkCssProperty = false;
        this.checkHtmlAttribute = true;
        this.checkProperty = false;
        this.multiAttributes = new HashMap<>();
        this.multiValues = new HashMap<>();
        this.multiPatterns = new HashMap<>();
    }
    
    @Override
    protected void setWaitDescription() {
        if (attributeName != null) {
            String verb = getMatchTypeVerb(matchType);
            this.waitDescription = "Wait for attribute '" + attributeName + "' " + verb + 
                    (expectedValue != null ? " '" + expectedValue + "'" : "");
        } else {
            this.waitDescription = "Wait for multiple attribute conditions";
        }
    }
    
    /**
     * Converts a match type to a verb phrase for descriptions.
     *
     * @param matchType The match type
     * @return A verb phrase
     */
    private String getMatchTypeVerb(AttributeMatchType matchType) {
        if (matchType == null) {
            return "";
        }
        
        switch (matchType) {
            case EXISTS: return "to exist";
            case NOT_EXISTS: return "to not exist";
            case EQUALS: return "to equal";
            case NOT_EQUALS: return "to not equal";
            case CONTAINS: return "to contain";
            case NOT_CONTAINS: return "to not contain";
            case REGEX: return "to match regex";
            case NOT_REGEX: return "to not match regex";
            default: return "to satisfy condition";
        }
    }
    
    /**
     * Set case sensitivity for attribute value matching.
     * 
     * @param caseSensitive Whether matching should be case sensitive
     * @return This wait strategy instance for method chaining
     */
    public CSAttributeWait caseSensitive(boolean caseSensitive) {
        this.caseSensitive = caseSensitive;
        return this;
    }
    
    /**
     * Set whether to check CSS properties.
     * 
     * @param check Whether to check CSS properties
     * @return This wait strategy instance for method chaining
     */
    public CSAttributeWait checkCssProperty(boolean check) {
        this.checkCssProperty = check;
        return this;
    }
    
    /**
     * Set whether to check HTML attributes.
     * 
     * @param check Whether to check HTML attributes
     * @return This wait strategy instance for method chaining
     */
    public CSAttributeWait checkHtmlAttribute(boolean check) {
        this.checkHtmlAttribute = check;
        return this;
    }
    
    /**
     * Set whether to check JavaScript properties.
     * 
     * @param check Whether to check JavaScript properties
     * @return This wait strategy instance for method chaining
     */
    public CSAttributeWait checkProperty(boolean check) {
        this.checkProperty = check;
        return this;
    }
    
    /**
     * Add another attribute condition for multi-attribute mode.
     * 
     * @param attributeName Name of the attribute
     * @param expectedValue Expected attribute value
     * @param matchType Type of attribute matching
     * @return This wait strategy instance for method chaining
     */
    public CSAttributeWait addAttributeCondition(String attributeName, String expectedValue,
                                               AttributeMatchType matchType) {
        multiAttributes.put(attributeName, matchType);
        multiValues.put(attributeName, expectedValue);
        
        if (matchType == AttributeMatchType.REGEX || matchType == AttributeMatchType.NOT_REGEX) {
            multiPatterns.put(attributeName, Pattern.compile(expectedValue));
        }
        
        return this;
    }
    
    /**
     * Add another attribute condition with regex pattern for multi-attribute mode.
     * 
     * @param attributeName Name of the attribute
     * @param pattern Regex pattern
     * @param matchType Type of attribute matching (must be REGEX or NOT_REGEX)
     * @return This wait strategy instance for method chaining
     */
    public CSAttributeWait addAttributeCondition(String attributeName, Pattern pattern,
                                               AttributeMatchType matchType) {
        if (matchType != AttributeMatchType.REGEX && matchType != AttributeMatchType.NOT_REGEX) {
            throw new IllegalArgumentException("Match type must be REGEX or NOT_REGEX when using Pattern");
        }
        
        multiAttributes.put(attributeName, matchType);
        multiValues.put(attributeName, pattern.pattern());
        multiPatterns.put(attributeName, pattern);
        
        return this;
    }
    
    /**
     * Add an existence condition for an attribute.
     * 
     * @param attributeName Name of the attribute
     * @param shouldExist Whether the attribute should exist
     * @return This wait strategy instance for method chaining
     */
    public CSAttributeWait addExistenceCondition(String attributeName, boolean shouldExist) {
        multiAttributes.put(attributeName, shouldExist ? AttributeMatchType.EXISTS : AttributeMatchType.NOT_EXISTS);
        multiValues.put(attributeName, null);
        
        return this;
    }
    
    @Override
    protected Function<WebDriver, WebElement> createWaitFunction() {
        return driver -> {
            try {
                if (attributeName != null) {
                    // Single attribute mode
                    String attributeValue = getAttributeValue(attributeName);
                    
                    if (!attributeMatches(attributeValue, expectedValue, matchType, pattern)) {
                        throw new AttributeMatchException(attributeName, matchType, expectedValue, attributeValue);
                    }
                } else {
                    // Multi-attribute mode
                    for (Map.Entry<String, AttributeMatchType> entry : multiAttributes.entrySet()) {
                        String attrName = entry.getKey();
                        AttributeMatchType attrMatchType = entry.getValue();
                        String attrValue = getAttributeValue(attrName);
                        String expectedAttrValue = multiValues.get(attrName);
                        Pattern attrPattern = multiPatterns.get(attrName);
                        
                        if (!attributeMatches(attrValue, expectedAttrValue, attrMatchType, attrPattern)) {
                            throw new AttributeMatchException(attrName, attrMatchType, expectedAttrValue, attrValue);
                        }
                    }
                }
                
                return element;
            } catch (StaleElementReferenceException e) {
                throw e;
            } catch (AttributeMatchException e) {
                throw e;
            } catch (Exception e) {
                throw new RuntimeException("Error checking element attributes: " + e.getMessage(), e);
            }
        };
    }
    
    /**
     * Gets the value of an attribute, considering all configured sources.
     *
     * @param attrName Name of the attribute
     * @return The attribute value or null if not found
     */
    private String getAttributeValue(String attrName) {
        String value = null;
        
        // Check HTML attribute
        if (checkHtmlAttribute) {
            try {
                value = element.getAttribute(attrName);
                if (value != null) {
                    return value;
                }
            } catch (Exception e) {
                LOGGER.debug("Error getting HTML attribute '{}': {}", attrName, e.getMessage());
            }
        }
        
        // Check CSS property
        if (checkCssProperty && value == null) {
            try {
                value = element.getCssValue(attrName);
                if (value != null && !value.isEmpty()) {
                    return value;
                }
            } catch (Exception e) {
                LOGGER.debug("Error getting CSS property '{}': {}", attrName, e.getMessage());
            }
        }
        
        // Check JavaScript property
        if (checkProperty && value == null) {
            try {
                String script = "return arguments[0][arguments[1]] || null;";
                value = (String) ((JavascriptExecutor) driver).executeScript(script, element, attrName);
                if (value != null) {
                    return value;
                }
            } catch (Exception e) {
                LOGGER.debug("Error getting JavaScript property '{}': {}", attrName, e.getMessage());
            }
        }
        
        return value;
    }
    
    /**
     * Checks if the attribute value matches the expected value according to match type.
     *
     * @param actualValue Actual attribute value
     * @param expectedValue Expected attribute value
     * @param matchType Type of attribute matching
     * @param pattern Regex pattern (if applicable)
     * @return True if the attribute matches
     */
    private boolean attributeMatches(String actualValue, String expectedValue, 
                                     AttributeMatchType matchType, Pattern pattern) {
        // Handle existence checks
        if (matchType == AttributeMatchType.EXISTS) {
            return actualValue != null;
        }
        if (matchType == AttributeMatchType.NOT_EXISTS) {
            return actualValue == null;
        }
        
        // If the actual value is null, it can't match any value-based condition
        if (actualValue == null) {
            return false;
        }
        
        // Handle case insensitivity for non-regex matches
        String actualForComparison = actualValue;
        String expectedForComparison = expectedValue;
        
        if (!caseSensitive && 
            matchType != AttributeMatchType.REGEX && 
            matchType != AttributeMatchType.NOT_REGEX) {
            actualForComparison = actualValue.toLowerCase();
            expectedForComparison = expectedValue != null ? expectedValue.toLowerCase() : null;
        }
        
        // Perform the match
        switch (matchType) {
            case EQUALS:
                return actualForComparison.equals(expectedForComparison);
            case NOT_EQUALS:
                return !actualForComparison.equals(expectedForComparison);
            case CONTAINS:
                return expectedForComparison != null && actualForComparison.contains(expectedForComparison);
            case NOT_CONTAINS:
                return expectedForComparison == null || !actualForComparison.contains(expectedForComparison);
            case REGEX:
                return pattern != null && pattern.matcher(actualValue).find();
            case NOT_REGEX:
                return pattern == null || !pattern.matcher(actualValue).find();
            default:
                throw new IllegalStateException("Unknown match type: " + matchType);
        }
    }
    
    /**
     * Exception thrown when an attribute does not match the expected condition.
     */
    private static class AttributeMatchException extends RuntimeException {
        private AttributeMatchException(String attributeName, AttributeMatchType matchType, 
                                        String expected, String actual) {
            super(formatMessage(attributeName, matchType, expected, actual));
        }
        
        private static String formatMessage(String attributeName, AttributeMatchType matchType, 
                                            String expected, String actual) {
            StringBuilder message = new StringBuilder("Attribute '").append(attributeName).append("' ");
            
            switch (matchType) {
                case EXISTS:
                    return message.append("does not exist").toString();
                case NOT_EXISTS:
                    return message.append("exists but should not").toString();
                case EQUALS:
                    return message.append("value '").append(actual)
                            .append("' does not equal expected '").append(expected).append("'").toString();
                case NOT_EQUALS:
                    return message.append("value '").append(actual)
                            .append("' equals '").append(expected).append("' but should not").toString();
                case CONTAINS:
                    return message.append("value '").append(actual)
                            .append("' does not contain '").append(expected).append("'").toString();
                case NOT_CONTAINS:
                    return message.append("value '").append(actual)
                            .append("' contains '").append(expected).append("' but should not").toString();
                case REGEX:
                    return message.append("value '").append(actual)
                            .append("' does not match regex '").append(expected).append("'").toString();
                case NOT_REGEX:
                    return message.append("value '").append(actual)
                            .append("' matches regex '").append(expected).append("' but should not").toString();
                default:
                    return message.append("match condition failed. Expected: '")
                            .append(expected).append("', Actual: '").append(actual).append("'").toString();
            }
        }
    }
}



package com.cstestforge.framework.selenium.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.*;

import java.util.List;
import java.util.function.Function;

/**
 * Wait strategy for element presence in the DOM.
 * Waits until an element is present in the DOM, meaning it exists regardless of visibility.
 * Also provides advanced presence checks like tag name and attribute verification.
 */
public class CSPresenceWait extends CSAbstractWaitStrategy<WebElement> {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSPresenceWait.class);
    
    private By locator;
    private String expectedTagName;
    private boolean checkChildren;
    private boolean checkAttribute;
    private String attributeName;
    private String attributeValue;
    
    /**
     * Creates a wait strategy for element presence by WebElement.
     * Note: This will only verify that the WebElement reference is still valid.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     */
    public CSPresenceWait(WebDriver driver, WebElement element) {
        super(driver, element);
        this.locator = null;
        this.expectedTagName = null;
        this.checkChildren = false;
        this.checkAttribute = false;
        this.attributeName = null;
        this.attributeValue = null;
    }
    
    /**
     * Creates a wait strategy for element presence by locator.
     * This will verify that an element matching the given locator exists in the DOM.
     *
     * @param driver WebDriver instance
     * @param locator Locator to find the element
     */
    public CSPresenceWait(WebDriver driver, By locator) {
        super(driver);
        this.locator = locator;
        this.expectedTagName = null;
        this.checkChildren = false;
        this.checkAttribute = false;
        this.attributeName = null;
        this.attributeValue = null;
    }
    
    @Override
    protected void setWaitDescription() {
        if (locator != null) {
            this.waitDescription = "Wait for element presence with locator: " + locator;
        } else {
            this.waitDescription = "Wait for element presence";
        }
    }
    
    /**
     * Set the expected tag name of the element.
     * 
     * @param tagName Expected tag name
     * @return This wait strategy instance for method chaining
     */
    public CSPresenceWait withTagName(String tagName) {
        this.expectedTagName = tagName;
        return this;
    }
    
    /**
     * Set whether to check for child elements.
     * 
     * @param check Whether to check for children
     * @return This wait strategy instance for method chaining
     */
    public CSPresenceWait checkChildren(boolean check) {
        this.checkChildren = check;
        return this;
    }
    
    /**
     * Set an attribute that the element should have.
     * 
     * @param name Attribute name
     * @param value Expected attribute value
     * @return This wait strategy instance for method chaining
     */
    public CSPresenceWait withAttribute(String name, String value) {
        this.checkAttribute = true;
        this.attributeName = name;
        this.attributeValue = value;
        return this;
    }
    
    @Override
    protected Function<WebDriver, WebElement> createWaitFunction() {
        return driver -> {
            try {
                WebElement elementToCheck;
                
                // Find the element if using a locator
                if (locator != null) {
                    elementToCheck = driver.findElement(locator);
                } else {
                    elementToCheck = this.element;
                    
                    // For WebElement reference, verify it's still attached to the DOM
                    try {
                        // This will throw if the element is stale
                        elementToCheck.isEnabled();
                    } catch (StaleElementReferenceException e) {
                        throw new NoSuchElementException("Element is no longer attached to the DOM: " + e.getMessage());
                    }
                }
                
                // Check tag name if specified
                if (expectedTagName != null) {
                    String actualTagName = elementToCheck.getTagName();
                    if (!actualTagName.equalsIgnoreCase(expectedTagName)) {
                        throw new NoSuchElementException(
                                "Element has incorrect tag name. Expected: '" + expectedTagName + 
                                "', Actual: '" + actualTagName + "'");
                    }
                }
                
                // Check attribute if specified
                if (checkAttribute && attributeName != null) {
                    String actualValue = elementToCheck.getAttribute(attributeName);
                    
                    // If expecting a specific value
                    if (attributeValue != null) {
                        if (!attributeValue.equals(actualValue)) {
                            throw new NoSuchElementException(
                                    "Element attribute '" + attributeName + "' has incorrect value. " +
                                    "Expected: '" + attributeValue + "', Actual: '" + actualValue + "'");
                        }
                    } 
                    // If just checking attribute existence
                    else if (actualValue == null) {
                        throw new NoSuchElementException(
                                "Element is missing required attribute: '" + attributeName + "'");
                    }
                }
                
                // Check for child elements if required
                if (checkChildren) {
                    List<WebElement> children = elementToCheck.findElements(By.xpath(".//*"));
                    if (children.isEmpty()) {
                        throw new NoSuchElementException("Element has no child elements");
                    }
                }
                
                return elementToCheck;
            } catch (NoSuchElementException e) {
                throw e;
            } catch (StaleElementReferenceException e) {
                throw new NoSuchElementException("Stale element reference: " + e.getMessage());
            } catch (Exception e) {
                throw new NoSuchElementException("Error checking element presence: " + e.getMessage());
            }
        };
    }
    
    /**
     * Find multiple elements based on a locator and check their presence.
     * This is a utility method for checking if at least N elements matching
     * a locator are present.
     *
     * @param driver WebDriver instance
     * @param locator Locator to find elements
     * @param minCount Minimum number of elements that should be present
     * @return The list of found elements
     * @throws TimeoutException if not enough elements are found within the timeout
     */
    public static List<WebElement> waitForElementsPresence(
            WebDriver driver, By locator, int minCount, long timeoutInSeconds) {
        
        CSLogger.getLogger(CSPresenceWait.class).debug(
                "Waiting for at least {} elements with locator: {}", minCount, locator);
        
        // Create a custom wait function for multiple elements
        Function<WebDriver, List<WebElement>> findElementsFunction = d -> {
            List<WebElement> elements = d.findElements(locator);
            if (elements.size() < minCount) {
                throw new NoSuchElementException(
                        "Found only " + elements.size() + " elements, but expected at least " + minCount);
            }
            return elements;
        };
        
        // Use a generic wait implementation without extending CSAbstractWaitStrategy
        try {
            return new CSGenericWait<>(driver, findElementsFunction)
                    .withDescription("Wait for at least " + minCount + " elements with locator: " + locator)
                    .until(timeoutInSeconds);
        } catch (TimeoutException e) {
            // Enhance the exception message
            String message = "Timed out waiting for at least " + minCount + 
                    " elements with locator: " + locator + ". " + e.getMessage();
            throw new TimeoutException(message, e.getCause());
        }
    }
    
    /**
     * Check if an element is present (exists in the DOM) without waiting.
     * This is a utility method for immediate presence checks.
     *
     * @param driver WebDriver instance
     * @param locator Locator to find the element
     * @return True if the element is present, false otherwise
     */
    public static boolean isElementPresent(WebDriver driver, By locator) {
        try {
            driver.findElement(locator);
            return true;
        } catch (NoSuchElementException e) {
            return false;
        } catch (Exception e) {
            CSLogger.getLogger(CSPresenceWait.class).debug(
                    "Error checking element presence: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Check if an element still exists in the DOM without waiting.
     * This is a utility method for immediate checks of WebElement references.
     *
     * @param element WebElement to check
     * @return True if the element still exists, false otherwise
     */
    public static boolean isElementAttached(WebElement element) {
        try {
            // Just access any property to check if the element is still attached
            element.isEnabled();
            return true;
        } catch (StaleElementReferenceException e) {
            return false;
        } catch (Exception e) {
            CSLogger.getLogger(CSPresenceWait.class).debug(
                    "Error checking if element is attached: {}", e.getMessage());
            return false;
        }
    }
}




package com.cstestforge.framework.selenium.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSScreenshotManager;
import com.cstestforge.framework.selenium.java.browser.CSWebDriverManager;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.support.ui.FluentWait;
import org.openqa.selenium.support.ui.Wait;

import java.time.Duration;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Function;

/**
 * Generic wait implementation for custom wait conditions.
 * This class is designed for custom wait conditions that don't fit
 * the standard element-based wait strategies.
 *
 * @param <T> The type of the wait result
 */
public class CSGenericWait<T> {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSGenericWait.class);
    private static final long DEFAULT_TIMEOUT_SECONDS = 30;
    private static final long DEFAULT_POLLING_INTERVAL_MILLIS = 500;
    
    private final WebDriver driver;
    private final Function<WebDriver, T> waitFunction;
    private String description;
    private String customMessage;
    private long timeoutInSeconds;
    private long pollingIntervalInMillis;
    private boolean ignoreAllExceptions;
    private Set<Class<? extends Throwable>> ignoredExceptions;
    private boolean captureScreenshot;
    private Runnable beforePollingCallback;
    private Runnable afterPollingCallback;
    
    /**
     * Creates a generic wait with a custom wait function.
     *
     * @param driver WebDriver instance
     * @param waitFunction Custom wait function that takes a WebDriver and returns a result
     */
    public CSGenericWait(WebDriver driver, Function<WebDriver, T> waitFunction) {
        this.driver = driver;
        this.waitFunction = waitFunction;
        this.description = "Generic wait condition";
        this.timeoutInSeconds = DEFAULT_TIMEOUT_SECONDS;
        this.pollingIntervalInMillis = DEFAULT_POLLING_INTERVAL_MILLIS;
        this.ignoredExceptions = new HashSet<>();
        this.ignoreAllExceptions = false;
        this.captureScreenshot = true;
    }
    
    /**
     * Set a description for this wait condition.
     *
     * @param description Wait condition description
     * @return This wait instance for method chaining
     */
    public CSGenericWait<T> withDescription(String description) {
        this.description = description;
        return this;
    }
    
    /**
     * Set custom polling interval.
     *
     * @param intervalInMillis Polling interval in milliseconds
     * @return This wait instance for method chaining
     */
    public CSGenericWait<T> pollingEvery(long intervalInMillis) {
        this.pollingIntervalInMillis = intervalInMillis;
        return this;
    }
    
    /**
     * Set custom failure message.
     *
     * @param message Message to include in timeout exception
     * @return This wait instance for method chaining
     */
    public CSGenericWait<T> withMessage(String message) {
        this.customMessage = message;
        return this;
    }
    
    /**
     * Set whether to ignore all exceptions during polling.
     *
     * @param ignore Whether to ignore all exceptions
     * @return This wait instance for method chaining
     */
    public CSGenericWait<T> ignoreExceptions(boolean ignore) {
        this.ignoreAllExceptions = ignore;
        return this;
    }
    
    /**
     * Add an exception type to ignore during polling.
     *
     * @param exceptionType Exception type to ignore
     * @return This wait instance for method chaining
     */
    public CSGenericWait<T> ignoreException(Class<? extends Throwable> exceptionType) {
        this.ignoredExceptions.add(exceptionType);
        return this;
    }
    
    /**
     * Set a screenshot capture strategy if wait fails.
     *
     * @param captureScreenshot Whether to capture screenshot on failure
     * @return This wait instance for method chaining
     */
    public CSGenericWait<T> withScreenshot(boolean captureScreenshot) {
        this.captureScreenshot = captureScreenshot;
        return this;
    }
    
    /**
     * Register a callback to execute before each poll attempt.
     *
     * @param callback Callback to execute
     * @return This wait instance for method chaining
     */
    public CSGenericWait<T> beforePolling(Runnable callback) {
        this.beforePollingCallback = callback;
        return this;
    }
    
    /**
     * Register a callback to execute after each poll attempt.
     *
     * @param callback Callback to execute
     * @return This wait instance for method chaining
     */
    public CSGenericWait<T> afterPolling(Runnable callback) {
        this.afterPollingCallback = callback;
        return this;
    }
    
    /**
     * Wait until the condition is satisfied using default timeout.
     *
     * @return The result of the wait operation
     * @throws TimeoutException if the timeout expires
     */
    public T until() {
        return until(timeoutInSeconds);
    }
    
    /**
     * Wait until the condition is satisfied using specified timeout.
     *
     * @param timeoutInSeconds Timeout in seconds
     * @return The result of the wait operation
     * @throws TimeoutException if the timeout expires
     */
    public T until(long timeoutInSeconds) {
        long startTime = System.currentTimeMillis();
        AtomicLong lastPollTime = new AtomicLong(startTime);
        
        try {
            LOGGER.debug("Starting {} with timeout {} seconds", description, timeoutInSeconds);
            
            // Create a FluentWait instance
            Wait<WebDriver> wait = new FluentWait<>(driver)
                .withTimeout(Duration.ofSeconds(timeoutInSeconds))
                .pollingEvery(Duration.ofMillis(pollingIntervalInMillis));
            
            // Add ignored exceptions
            if (ignoreAllExceptions) {
                wait = wait.ignoring(Exception.class);
            } else {
                for (Class<? extends Throwable> exceptionClass : ignoredExceptions) {
                    wait = wait.ignoring(exceptionClass);
                }
            }
            
            // Create the wait function with callbacks
            Function<WebDriver, T> wrappedFunction = driver -> {
                if (beforePollingCallback != null) {
                    beforePollingCallback.run();
                }
                
                lastPollTime.set(System.currentTimeMillis());
                T result = waitFunction.apply(driver);
                
                if (afterPollingCallback != null) {
                    afterPollingCallback.run();
                }
                
                return result;
            };
            
            // Execute the wait
            T result = wait.until(wrappedFunction);
            
            long endTime = System.currentTimeMillis();
            LOGGER.debug("{} completed successfully in {} ms", description, (endTime - startTime));
            
            return result;
        } catch (TimeoutException e) {
            long failTime = System.currentTimeMillis();
            String message = formatTimeoutMessage(failTime - startTime, failTime - lastPollTime.get());
            LOGGER.error(message);
            
            if (captureScreenshot) {
                try {
                    String screenshotPath = CSScreenshotManager.takeScreenshot(driver, "wait_failed_" + System.currentTimeMillis());
                    LOGGER.error("Wait failure screenshot saved to: {}", screenshotPath);
                } catch (Exception screenshotException) {
                    LOGGER.error("Failed to capture wait failure screenshot", screenshotException);
                }
            }
            
            throw new TimeoutException(message, e);
        }
    }
    
    /**
     * Format a timeout exception message with detailed information.
     *
     * @param totalWaitTime Total wait time in milliseconds
     * @param lastPollDuration Duration of the last poll attempt in milliseconds
     * @return Formatted timeout message
     */
    private String formatTimeoutMessage(long totalWaitTime, long lastPollDuration) {
        StringBuilder message = new StringBuilder();
        
        if (customMessage != null && !customMessage.isEmpty()) {
            message.append(customMessage);
        } else {
            message.append(description).append(" timed out");
        }
        
        message.append(" after ").append(totalWaitTime).append(" ms");
        message.append(" (last poll: ").append(lastPollDuration).append(" ms)");
        message.append("\nPage URL: ").append(driver.getCurrentUrl());
        message.append("\nPage Title: ").append(driver.getTitle());
        
        return message.toString();
    }
}



package com.cstestforge.framework.selenium.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;

import java.util.function.Function;

/**
 * Wait strategy for element invisibility.
 * Waits until an element is either not present in the DOM, or present but not visible.
 * Also provides options for checking style properties and advanced invisibility conditions.
 */
public class CSInvisibilityWait extends CSAbstractWaitStrategy<Boolean> {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSInvisibilityWait.class);
    
    private By locator;
    private boolean checkDomRemoval;
    private boolean checkCssVisibility;
    private boolean checkCssDisplay;
    private boolean checkOpacity;
    private Double maxVisiblePercentage;
    
    /**
     * Creates a wait strategy for element invisibility by WebElement.
     *
     * @param driver WebDriver instance
     * @param element Element to wait for
     */
    public CSInvisibilityWait(WebDriver driver, WebElement element) {
        super(driver, element);
        this.locator = null;
        this.checkDomRemoval = true;
        this.checkCssVisibility = true;
        this.checkCssDisplay = true;
        this.checkOpacity = true;
        this.maxVisiblePercentage = null;
    }
    
    /**
     * Creates a wait strategy for element invisibility by locator.
     *
     * @param driver WebDriver instance
     * @param locator Locator to find the element
     */
    public CSInvisibilityWait(WebDriver driver, By locator) {
        super(driver);
        this.locator = locator;
        this.checkDomRemoval = true;
        this.checkCssVisibility = true;
        this.checkCssDisplay = true;
        this.checkOpacity = true;
        this.maxVisiblePercentage = null;
    }
    
    @Override
    protected void setWaitDescription() {
        if (locator != null) {
            this.waitDescription = "Wait for element invisibility with locator: " + locator;
        } else {
            this.waitDescription = "Wait for element invisibility";
        }
    }
    
    /**
     * Set whether to check for element removal from DOM.
     * 
     * @param check Whether to check DOM removal
     * @return This wait strategy instance for method chaining
     */
    public CSInvisibilityWait checkDomRemoval(boolean check) {
        this.checkDomRemoval = check;
        return this;
    }
    
    /**
     * Set whether to check CSS visibility property.
     * 
     * @param check Whether to check CSS visibility
     * @return This wait strategy instance for method chaining
     */
    public CSInvisibilityWait checkCssVisibility(boolean check) {
        this.checkCssVisibility = check;
        return this;
    }
    
    /**
     * Set whether to check CSS display property.
     * 
     * @param check Whether to check CSS display
     * @return This wait strategy instance for method chaining
     */
    public CSInvisibilityWait checkCssDisplay(boolean check) {
        this.checkCssDisplay = check;
        return this;
    }
    
    /**
     * Set whether to check element opacity.
     * 
     * @param check Whether to check opacity
     * @return This wait strategy instance for method chaining
     */
    public CSInvisibilityWait checkOpacity(boolean check) {
        this.checkOpacity = check;
        return this;
    }
    
    /**
     * Set maximum percentage of the element that can be visible.
     * 
     * @param percentage Percentage (0.0 to 100.0)
     * @return This wait strategy instance for method chaining
     */
    public CSInvisibilityWait maxVisiblePercentage(double percentage) {
        if (percentage < 0.0 || percentage > 100.0) {
            throw new IllegalArgumentException("Visible percentage must be between 0.0 and 100.0");
        }
        this.maxVisiblePercentage = percentage;
        return this;
    }
    
    @Override
    protected Function<WebDriver, Boolean> createWaitFunction() {
        return driver -> {
            try {
                WebElement elementToCheck = null;
                
                // Find the element
                if (locator != null) {
                    try {
                        elementToCheck = driver.findElement(locator);
                    } catch (NoSuchElementException e) {
                        // Element not found in DOM, which means it's invisible
                        return true;
                    }
                } else {
                    elementToCheck = this.element;
                    try {
                        // This will throw if the element is stale
                        elementToCheck.getTagName();
                    } catch (StaleElementReferenceException e) {
                        // Element is no longer in DOM, which means it's invisible
                        return true;
                    }
                }
                
                // Check for element visibility
                try {
                    if (!elementToCheck.isDisplayed()) {
                        return true; // Element exists but is not displayed
                    }
                } catch (StaleElementReferenceException e) {
                    // Element is no longer in DOM
                    return true;
                }
                
                // Element is displayed, check additional conditions
                
                // Check element size
                try {
                    Dimension size = elementToCheck.getSize();
                    if (size.getHeight() <= 0 || size.getWidth() <= 0) {
                        return true; // Element has zero size
                    }
                } catch (StaleElementReferenceException e) {
                    return true;
                }
                
                // Check CSS properties if needed
                if (checkCssDisplay) {
                    try {
                        String display = elementToCheck.getCssValue("display");
                        if ("none".equals(display)) {
                            return true; // Element has display:none
                        }
                    } catch (StaleElementReferenceException e) {
                        return true;
                    }
                }
                
                if (checkCssVisibility) {
                    try {
                        String visibility = elementToCheck.getCssValue("visibility");
                        if ("hidden".equals(visibility) || "collapse".equals(visibility)) {
                            return true; // Element has visibility:hidden
                        }
                    } catch (StaleElementReferenceException e) {
                        return true;
                    }
                }
                
                // Check opacity if needed
                if (checkOpacity) {
                    try {
                        String opacityStr = elementToCheck.getCssValue("opacity");
                        if (opacityStr != null && !opacityStr.isEmpty()) {
                            try {
                                double opacity = Double.parseDouble(opacityStr);
                                if (opacity < 0.1) { // Allow very slight transparency
                                    return true; // Element is practically invisible
                                }
                            } catch (NumberFormatException e) {
                                LOGGER.debug("Could not parse opacity value: {}", opacityStr);
                            }
                        }
                    } catch (StaleElementReferenceException e) {
                        return true;
                    }
                }
                
                // Check visible percentage if specified
                if (maxVisiblePercentage != null) {
                    try {
                        double visiblePercentage = getVisiblePercentage(elementToCheck);
                        if (visiblePercentage <= maxVisiblePercentage) {
                            return true; // Element is mostly invisible
                        }
                    } catch (StaleElementReferenceException e) {
                        return true;
                    }
                }
                
                return false; // Element is still visible
            } catch (WebDriverException e) {
                if (checkDomRemoval && (e instanceof StaleElementReferenceException || e instanceof NoSuchElementException)) {
                    return true; // Element is no longer in DOM
                }
                throw e;
            }
        };
    }
    
    /**
     * Calculates the percentage of an element that's visible in the viewport.
     *
     * @param element Element to check
     * @return Percentage of visibility (0-100)
     */
    private double getVisiblePercentage(WebElement element) {
        try {
            String script = 
                "var element = arguments[0];" +
                "var rect = element.getBoundingClientRect();" +
                "var windowHeight = window.innerHeight || document.documentElement.clientHeight;" +
                "var windowWidth = window.innerWidth || document.documentElement.clientWidth;" +
                
                "var visibleWidth = Math.min(rect.right, windowWidth) - Math.max(rect.left, 0);" +
                "var visibleHeight = Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0);" +
                
                "if (visibleWidth <= 0 || visibleHeight <= 0) return 0;" +
                
                "var elementArea = rect.width * rect.height;" +
                "var visibleArea = visibleWidth * visibleHeight;" +
                
                "return (visibleArea / elementArea) * 100;";
            
            Object result = ((JavascriptExecutor) driver).executeScript(script, element);
            if (result instanceof Number) {
                return ((Number) result).doubleValue();
            }
            return 0.0;
        } catch (Exception e) {
            LOGGER.debug("Error calculating visible percentage: {}", e.getMessage());
            return 0.0; // Assume not visible if check fails
        }
    }
    
    /**
     * Wait for multiple elements to be invisible.
     * This is a utility method for waiting until all elements matching a locator
     * are either not present or not visible.
     *
     * @param driver WebDriver instance
     * @param locator Locator to find elements
     * @param timeoutInSeconds Timeout in seconds
     * @return True if all elements are invisible
     * @throws TimeoutException if elements are still visible after timeout
     */
    public static boolean waitForAllInvisible(WebDriver driver, By locator, long timeoutInSeconds) {
        CSLogger.getLogger(CSInvisibilityWait.class).debug(
                "Waiting for all elements to be invisible with locator: {}", locator);
        
        // Create a custom wait function for multiple elements
        Function<WebDriver, Boolean> allInvisibleFunction = d -> {
            try {
                java.util.List<WebElement> elements = d.findElements(locator);
                
                // If no elements found, they're all invisible
                if (elements.isEmpty()) {
                    return true;
                }
                
                // Check if any element is still visible
                for (WebElement element : elements) {
                    try {
                        if (element.isDisplayed()) {
                            return false; // At least one element is still visible
                        }
                    } catch (StaleElementReferenceException e) {
                        // Element is stale, so it's not visible
                        continue;
                    }
                }
                
                // All elements are invisible
                return true;
            } catch (WebDriverException e) {
                if (e instanceof NoSuchElementException) {
                    return true; // No elements found, so they're all invisible
                }
                throw e;
            }
        };
        
        // Use a generic wait implementation
        try {
            return new CSGenericWait<>(driver, allInvisibleFunction)
                    .withDescription("Wait for all elements to be invisible with locator: " + locator)
                    .until(timeoutInSeconds);
        } catch (TimeoutException e) {
            // Enhance the exception message
            String message = "Timed out waiting for all elements to be invisible with locator: " + 
                    locator + ". " + e.getMessage();
            throw new TimeoutException(message, e.getCause());
        }
    }
    
    /**
     * Check if an element is invisible (not displayed or not present) without waiting.
     * This is a utility method for immediate invisibility checks.
     *
     * @param driver WebDriver instance
     * @param locator Locator to find the element
     * @return True if the element is invisible or not present
     */
    public static boolean isElementInvisible(WebDriver driver, By locator) {
        try {
            WebElement element = driver.findElement(locator);
            return !element.isDisplayed();
        } catch (NoSuchElementException | StaleElementReferenceException e) {
            return true; // Element not present or stale, so it's invisible
        } catch (Exception e) {
            CSLogger.getLogger(CSInvisibilityWait.class).debug(
                    "Error checking element invisibility: {}", e.getMessage());
            return false; // Assume visible if check fails (conservative approach)
        }
    }
}



package com.cstestforge.framework.selenium.java.wait;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.util.function.Function;
import java.util.regex.Pattern;

/**
 * Factory for creating wait strategy instances.
 * Provides convenient factory methods for creating various types of wait strategies
 * with common configurations and defaults.
 */
public class CSWaitFactory {
    
    private final WebDriver driver;
    private long defaultTimeoutSeconds = 30;
    private long defaultPollingIntervalMillis = 500;
    private boolean defaultScreenshotOnFailure = true;
    
    /**
     * Creates a wait factory with the specified WebDriver.
     *
     * @param driver WebDriver instance
     */
    public CSWaitFactory(WebDriver driver) {
        this.driver = driver;
    }
    
    /**
     * Set the default timeout for all wait strategies created by this factory.
     *
     * @param timeoutSeconds Default timeout in seconds
     * @return This factory instance for method chaining
     */
    public CSWaitFactory withDefaultTimeout(long timeoutSeconds) {
        this.defaultTimeoutSeconds = timeoutSeconds;
        return this;
    }
    
    /**
     * Set the default polling interval for all wait strategies created by this factory.
     *
     * @param pollingIntervalMillis Default polling interval in milliseconds
     * @return This factory instance for method chaining
     */
    public CSWaitFactory withDefaultPollingInterval(long pollingIntervalMillis) {
        this.defaultPollingIntervalMillis = pollingIntervalMillis;
        return this;
    }
    
    /**
     * Set whether to capture screenshots on failure by default.
     *
     * @param captureScreenshot Whether to capture screenshots on failure
     * @return This factory instance for method chaining
     */
    public CSWaitFactory withDefaultScreenshotOnFailure(boolean captureScreenshot) {
        this.defaultScreenshotOnFailure = captureScreenshot;
        return this;
    }
    
    /**
     * Create a wait strategy for element visibility.
     *
     * @param element Element to wait for
     * @return Configured visibility wait strategy
     */
    public CSVisibilityWait forVisibility(WebElement element) {
        CSVisibilityWait wait = new CSVisibilityWait(driver, element);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element clickability.
     *
     * @param element Element to wait for
     * @return Configured clickability wait strategy
     */
    public CSClickableWait forClickability(WebElement element) {
        CSClickableWait wait = new CSClickableWait(driver, element);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element text.
     *
     * @param element Element to wait for
     * @param text Expected text
     * @return Configured text wait strategy
     */
    public CSTextWait forText(WebElement element, String text) {
        CSTextWait wait = new CSTextWait(driver, element, text);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element text with specific match type.
     *
     * @param element Element to wait for
     * @param text Expected text
     * @param matchType Type of text matching
     * @return Configured text wait strategy
     */
    public CSTextWait forText(WebElement element, String text, CSTextWait.TextMatchType matchType) {
        CSTextWait wait = new CSTextWait(driver, element, text, matchType);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element text with regex pattern.
     *
     * @param element Element to wait for
     * @param pattern Regex pattern
     * @param matchType Type of text matching (must be REGEX or NOT_REGEX)
     * @return Configured text wait strategy
     */
    public CSTextWait forText(WebElement element, Pattern pattern, CSTextWait.TextMatchType matchType) {
        CSTextWait wait = new CSTextWait(driver, element, pattern, matchType);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element attribute.
     *
     * @param element Element to wait for
     * @param attributeName Name of the attribute
     * @param expectedValue Expected attribute value
     * @return Configured attribute wait strategy
     */
    public CSAttributeWait forAttribute(WebElement element, String attributeName, String expectedValue) {
        CSAttributeWait wait = new CSAttributeWait(driver, element, attributeName, expectedValue);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element attribute with specific match type.
     *
     * @param element Element to wait for
     * @param attributeName Name of the attribute
     * @param expectedValue Expected attribute value
     * @param matchType Type of attribute matching
     * @return Configured attribute wait strategy
     */
    public CSAttributeWait forAttribute(WebElement element, String attributeName, String expectedValue,
                                    CSAttributeWait.AttributeMatchType matchType) {
        CSAttributeWait wait = new CSAttributeWait(driver, element, attributeName, expectedValue, matchType);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element attribute with regex pattern.
     *
     * @param element Element to wait for
     * @param attributeName Name of the attribute
     * @param pattern Regex pattern
     * @param matchType Type of attribute matching (must be REGEX or NOT_REGEX)
     * @return Configured attribute wait strategy
     */
    public CSAttributeWait forAttribute(WebElement element, String attributeName, Pattern pattern,
                                    CSAttributeWait.AttributeMatchType matchType) {
        CSAttributeWait wait = new CSAttributeWait(driver, element, attributeName, pattern, matchType);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for multiple element attributes.
     *
     * @param element Element to wait for
     * @return Configured multi-attribute wait strategy
     */
    public CSAttributeWait forAttributes(WebElement element) {
        CSAttributeWait wait = new CSAttributeWait(driver, element);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element presence by WebElement.
     *
     * @param element Element to wait for
     * @return Configured presence wait strategy
     */
    public CSPresenceWait forPresence(WebElement element) {
        CSPresenceWait wait = new CSPresenceWait(driver, element);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element presence by locator.
     *
     * @param locator Locator to find the element
     * @return Configured presence wait strategy
     */
    public CSPresenceWait forPresence(By locator) {
        CSPresenceWait wait = new CSPresenceWait(driver, locator);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element invisibility by WebElement.
     *
     * @param element Element to wait for
     * @return Configured invisibility wait strategy
     */
    public CSInvisibilityWait forInvisibility(WebElement element) {
        CSInvisibilityWait wait = new CSInvisibilityWait(driver, element);
        return applyDefaults(wait);
    }
    
    /**
     * Create a wait strategy for element invisibility by locator.
     *
     * @param locator Locator to find the element
     * @return Configured invisibility wait strategy
     */
    public CSInvisibilityWait forInvisibility(By locator) {
        CSInvisibilityWait wait = new CSInvisibilityWait(driver, locator);
        return applyDefaults(wait);
    }
    
    /**
     * Create a generic wait with a custom wait function.
     *
     * @param <T> Type of the wait result
     * @param waitFunction Custom wait function that takes a WebDriver and returns a result
     * @return Configured generic wait
     */
    public <T> CSGenericWait<T> forCustomCondition(Function<WebDriver, T> waitFunction) {
        CSGenericWait<T> wait = new CSGenericWait<>(driver, waitFunction);
        return applyDefaults(wait);
    }
    
    /**
     * Apply default configurations to a wait strategy.
     *
     * @param <T> Type of the wait result
     * @param <W> Type of the wait strategy
     * @param wait Wait strategy to configure
     * @return Configured wait strategy
     */
    private <T, W extends CSWaitStrategy<T>> W applyDefaults(W wait) {
        wait.pollingEvery(defaultPollingIntervalMillis);
        wait.withScreenshot(defaultScreenshotOnFailure);
        return wait;
    }
    
    /**
     * Apply default configurations to a generic wait.
     *
     * @param <T> Type of the wait result
     * @param wait Generic wait to configure
     * @return Configured generic wait
     */
    private <T> CSGenericWait<T> applyDefaults(CSGenericWait<T> wait) {
        wait.pollingEvery(defaultPollingIntervalMillis);
        wait.withScreenshot(defaultScreenshotOnFailure);
        return wait;
    }
    
    /**
     * Utility method to wait for an element to be visible with default timeout.
     *
     * @param element Element to wait for
     * @return The element after it becomes visible
     */
    public WebElement waitForVisible(WebElement element) {
        return forVisibility(element).until(defaultTimeoutSeconds);
    }
    
    /**
     * Utility method to wait for an element to be clickable with default timeout.
     *
     * @param element Element to wait for
     * @return The element after it becomes clickable
     */
    public WebElement waitForClickable(WebElement element) {
        return forClickability(element).until(defaultTimeoutSeconds);
    }
    
    /**
     * Utility method to wait for an element to be present with default timeout.
     *
     * @param locator Locator to find the element
     * @return The element after it becomes present
     */
    public WebElement waitForPresent(By locator) {
        return forPresence(locator).until(defaultTimeoutSeconds);
    }
    
    /**
     * Utility method to wait for an element to be invisible with default timeout.
     *
     * @param element Element to wait for
     * @return True if the element becomes invisible
     */
    public boolean waitForInvisible(WebElement element) {
        return forInvisibility(element).until(defaultTimeoutSeconds);
    }
    
    /**
     * Utility method to wait for an element to be invisible with default timeout.
     *
     * @param locator Locator to find the element
     * @return True if the element becomes invisible
     */
    public boolean waitForInvisible(By locator) {
        return forInvisibility(locator).until(defaultTimeoutSeconds);
    }
    
    /**
     * Utility method to wait for an element to contain text with default timeout.
     *
     * @param element Element to wait for
     * @param text Expected text
     * @return The element after it contains the expected text
     */
    public WebElement waitForTextContains(WebElement element, String text) {
        return forText(element, text, CSTextWait.TextMatchType.CONTAINS).until(defaultTimeoutSeconds);
    }
    
    /**
     * Utility method to wait for an element to have an attribute with default timeout.
     *
     * @param element Element to wait for
     * @param attributeName Name of the attribute
     * @param expectedValue Expected attribute value
     * @return The element after it has the expected attribute
     */
    public WebElement waitForAttributeEquals(WebElement element, String attributeName, String expectedValue) {
        return forAttribute(element, attributeName, expectedValue, CSAttributeWait.AttributeMatchType.EQUALS)
                .until(defaultTimeoutSeconds);
    }
}



package com.cstestforge.framework.playwright.java.browser;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.config.FrameworkConfig;
import com.cstestforge.framework.core.utils.CSEncryptionUtils;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;
import com.microsoft.playwright.*;
import com.microsoft.playwright.options.Proxy;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;

/**
 * Manages Playwright instances for the CSTestForge framework.
 * This class is responsible for creating, managing, and disposing of Playwright resources.
 * It provides a singleton instance to ensure resource efficiency and thread safety.
 */
public class CSPlaywrightManager {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSPlaywrightManager.class);
    private static final long DEFAULT_TIMEOUT_MS = 30000;
    
    private static CSPlaywrightManager instance;
    private static final ReentrantLock INIT_LOCK = new ReentrantLock();
    
    private final AtomicBoolean initialized = new AtomicBoolean(false);
    private final ConcurrentHashMap<Long, Playwright> playwrightInstances = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<Long, Map<String, Browser>> browserInstances = new ConcurrentHashMap<>();
    private final ThreadLocal<Playwright> threadLocalPlaywright = new ThreadLocal<>();
    
    // Default options for browser creation
    private final ThreadLocal<CSLaunchOptionsManager> launchOptionsManager = ThreadLocal.withInitial(CSLaunchOptionsManager::new);
    
    /**
     * Private constructor for singleton pattern.
     */
    private CSPlaywrightManager() {
        // Private constructor to enforce singleton pattern
    }
    
    /**
     * Gets the singleton instance of the CSPlaywrightManager.
     *
     * @return The singleton instance
     */
    public static CSPlaywrightManager getInstance() {
        if (instance == null) {
            INIT_LOCK.lock();
            try {
                if (instance == null) {
                    instance = new CSPlaywrightManager();
                }
            } finally {
                INIT_LOCK.unlock();
            }
        }
        return instance;
    }
    
    /**
     * Initializes the Playwright manager for the current thread if not already initialized.
     * 
     * @return The current instance for method chaining
     */
    public CSPlaywrightManager initialize() {
        if (threadLocalPlaywright.get() == null) {
            LOGGER.info("Initializing Playwright for thread: {}", Thread.currentThread().getId());
            Playwright playwright = Playwright.create();
            threadLocalPlaywright.set(playwright);
            playwrightInstances.put(Thread.currentThread().getId(), playwright);
            browserInstances.put(Thread.currentThread().getId(), new ConcurrentHashMap<>());
            initialized.set(true);
        }
        return this;
    }
    
    /**
     * Gets the Playwright instance for the current thread.
     * Initializes a new instance if none exists.
     *
     * @return The Playwright instance
     */
    public Playwright getPlaywright() {
        if (threadLocalPlaywright.get() == null) {
            initialize();
        }
        return threadLocalPlaywright.get();
    }
    
    /**
     * Gets the launch options manager for the current thread.
     *
     * @return The launch options manager
     */
    public CSLaunchOptionsManager getLaunchOptionsManager() {
        return launchOptionsManager.get();
    }
    
    /**
     * Creates a Chromium browser instance with default options.
     *
     * @return The created Browser instance
     */
    public Browser createChromiumBrowser() {
        return createChromiumBrowser(launchOptionsManager.get().getChromiumLaunchOptions());
    }
    
    /**
     * Creates a Chromium browser instance with custom options.
     *
     * @param options Browser launch options
     * @return The created Browser instance
     */
    public Browser createChromiumBrowser(BrowserType.LaunchOptions options) {
        return createBrowser("chromium", options);
    }
    
    /**
     * Creates a Firefox browser instance with default options.
     *
     * @return The created Browser instance
     */
    public Browser createFirefoxBrowser() {
        return createFirefoxBrowser(launchOptionsManager.get().getFirefoxLaunchOptions());
    }
    
    /**
     * Creates a Firefox browser instance with custom options.
     *
     * @param options Browser launch options
     * @return The created Browser instance
     */
    public Browser createFirefoxBrowser(BrowserType.LaunchOptions options) {
        return createBrowser("firefox", options);
    }
    
    /**
     * Creates a WebKit browser instance with default options.
     *
     * @return The created Browser instance
     */
    public Browser createWebKitBrowser() {
        return createWebKitBrowser(launchOptionsManager.get().getWebKitLaunchOptions());
    }
    
    /**
     * Creates a WebKit browser instance with custom options.
     *
     * @param options Browser launch options
     * @return The created Browser instance
     */
    public Browser createWebKitBrowser(BrowserType.LaunchOptions options) {
        return createBrowser("webkit", options);
    }
    
    /**
     * Creates a browser instance of the specified type with the given options.
     *
     * @param browserType Type of browser ("chromium", "firefox", or "webkit")
     * @param options Browser launch options
     * @return The created Browser instance
     */
    public Browser createBrowser(String browserType, BrowserType.LaunchOptions options) {
        initialize();
        
        LOGGER.info("Creating {} browser with options: {}", browserType, options);
        Browser browser;
        
        try {
            Playwright playwright = getPlaywright();
            String browserKey = browserType + "_" + System.currentTimeMillis();
            
            switch (browserType.toLowerCase()) {
                case "chromium":
                    browser = playwright.chromium().launch(options);
                    break;
                case "firefox":
                    browser = playwright.firefox().launch(options);
                    break;
                case "webkit":
                    browser = playwright.webkit().launch(options);
                    break;
                default:
                    throw new IllegalArgumentException("Unsupported browser type: " + browserType);
            }
            
            // Store browser instance
            long threadId = Thread.currentThread().getId();
            browserInstances.get(threadId).put(browserKey, browser);
            
            LOGGER.info("Created {} browser successfully", browserType);
            return browser;
        } catch (Exception e) {
            LOGGER.error("Failed to create {} browser: {}", browserType, e.getMessage(), e);
            throw new RuntimeException("Failed to create browser: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a browser context with default options.
     *
     * @param browser Browser instance
     * @return The created BrowserContext
     */
    public BrowserContext createContext(Browser browser) {
        return createContext(browser, new Browser.NewContextOptions());
    }
    
    /**
     * Creates a browser context with custom options.
     *
     * @param browser Browser instance
     * @param options Context options
     * @return The created BrowserContext
     */
    public BrowserContext createContext(Browser browser, Browser.NewContextOptions options) {
        LOGGER.info("Creating browser context with options: {}", options);
        
        try {
            return browser.newContext(options);
        } catch (Exception e) {
            LOGGER.error("Failed to create browser context: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create browser context: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a new page in the given browser context.
     *
     * @param context Browser context
     * @return The created Page
     */
    public Page createPage(BrowserContext context) {
        LOGGER.info("Creating new page in browser context");
        
        try {
            return context.newPage();
        } catch (Exception e) {
            LOGGER.error("Failed to create page: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create page: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a new page in a new context from the given browser.
     *
     * @param browser Browser instance
     * @return The created Page
     */
    public Page createPage(Browser browser) {
        return createPage(createContext(browser));
    }
    
    /**
     * Creates a new page in a new context with the given options from the given browser.
     *
     * @param browser Browser instance
     * @param options Context options
     * @return The created Page
     */
    public Page createPage(Browser browser, Browser.NewContextOptions options) {
        return createPage(createContext(browser, options));
    }
    
    /**
     * Configures proxy settings for browser launch options.
     *
     * @param options Launch options to modify
     * @param proxyServer Proxy server address
     * @param username Optional proxy username
     * @param password Optional proxy password
     * @return The modified launch options
     */
    public BrowserType.LaunchOptions configureProxy(BrowserType.LaunchOptions options, 
                                                   String proxyServer, 
                                                   String username, 
                                                   String password) {
        Proxy proxy = new Proxy(proxyServer);
        
        if (username != null && !username.isEmpty() && password != null) {
            proxy.setUsername(username);
            proxy.setPassword(password);
        }
        
        options.setProxy(proxy);
        return options;
    }
    
    /**
     * Sets up authentication credentials for a BrowserContext.
     *
     * @param context Browser context
     * @param username Username for authentication
     * @param password Password for authentication
     */
    public void setupAuthentication(BrowserContext context, String username, String password) {
        if (username != null && !username.isEmpty() && password != null) {
            context.setHTTPCredentials(username, password);
        }
    }
    
    /**
     * Sets up a tracing session for a BrowserContext for debugging and performance analysis.
     *
     * @param context Browser context
     * @param outputPath Path to save the trace
     * @param captureScreenshots Whether to capture screenshots during tracing
     */
    public void startTracing(BrowserContext context, String outputPath, boolean captureScreenshots) {
        try {
            Path tracePath = Paths.get(outputPath);
            context.tracing().start(new Tracing.StartOptions()
                    .setScreenshots(captureScreenshots)
                    .setSnapshots(true));
            
            LOGGER.info("Started tracing with output path: {}", outputPath);
        } catch (Exception e) {
            LOGGER.error("Failed to start tracing: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to start tracing: " + e.getMessage(), e);
        }
    }
    
    /**
     * Stops the tracing session and saves the trace to the specified path.
     *
     * @param context Browser context
     * @param outputPath Path to save the trace
     */
    public void stopTracing(BrowserContext context, String outputPath) {
        try {
            Path tracePath = Paths.get(outputPath);
            context.tracing().stop(new Tracing.StopOptions()
                    .setPath(tracePath));
            
            LOGGER.info("Stopped tracing and saved to: {}", outputPath);
        } catch (Exception e) {
            LOGGER.error("Failed to stop tracing: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to stop tracing: " + e.getMessage(), e);
        }
    }
    
    /**
     * Closes all browser instances for the current thread.
     */
    public void closeBrowsers() {
        long threadId = Thread.currentThread().getId();
        
        if (browserInstances.containsKey(threadId)) {
            Map<String, Browser> browsers = browserInstances.get(threadId);
            
            browsers.forEach((key, browser) -> {
                try {
                    LOGGER.info("Closing browser instance: {}", key);
                    browser.close();
                } catch (Exception e) {
                    LOGGER.warn("Failed to close browser instance {}: {}", key, e.getMessage());
                }
            });
            
            browsers.clear();
        }
    }
    
    /**
     * Closes the Playwright instance for the current thread and cleans up resources.
     */
    public void close() {
        long threadId = Thread.currentThread().getId();
        
        // Close all browsers first
        closeBrowsers();
        
        // Close Playwright instance
        if (playwrightInstances.containsKey(threadId)) {
            Playwright playwright = playwrightInstances.get(threadId);
            
            try {
                LOGGER.info("Closing Playwright instance for thread: {}", threadId);
                playwright.close();
            } catch (Exception e) {
                LOGGER.warn("Failed to close Playwright instance: {}", e.getMessage());
            } finally {
                playwrightInstances.remove(threadId);
                browserInstances.remove(threadId);
                threadLocalPlaywright.remove();
                initialized.set(false);
            }
        }
    }
    
    /**
     * Closes all Playwright instances across all threads.
     * This should typically be called during JVM shutdown.
     */
    public void closeAll() {
        LOGGER.info("Closing all Playwright instances");
        
        // Close all browsers for all threads
        browserInstances.forEach((threadId, browsers) -> {
            browsers.forEach((key, browser) -> {
                try {
                    LOGGER.info("Closing browser instance {} for thread {}", key, threadId);
                    browser.close();
                } catch (Exception e) {
                    LOGGER.warn("Failed to close browser instance {} for thread {}: {}", 
                            key, threadId, e.getMessage());
                }
            });
            browsers.clear();
        });
        
        // Close all Playwright instances
        playwrightInstances.forEach((threadId, playwright) -> {
            try {
                LOGGER.info("Closing Playwright instance for thread: {}", threadId);
                playwright.close();
            } catch (Exception e) {
                LOGGER.warn("Failed to close Playwright instance for thread {}: {}", 
                        threadId, e.getMessage());
            }
        });
        
        // Clear collections
        playwrightInstances.clear();
        browserInstances.clear();
        threadLocalPlaywright.remove();
        initialized.set(false);
    }
    
    /**
     * Sets up a shutdown hook to clean up resources.
     */
    public void setupShutdownHook() {
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            LOGGER.info("Executing Playwright shutdown hook");
            closeAll();
        }));
        LOGGER.info("Playwright shutdown hook registered");
    }
    
    /**
     * Creates a persistent context that can be used for testing with user data.
     *
     * @param browserType Type of browser ("chromium", "firefox", or "webkit")
     * @param userDataDir Directory for user data
     * @param options Context options
     * @return The created BrowserContext
     */
    public BrowserContext createPersistentContext(String browserType, 
                                                 String userDataDir, 
                                                 BrowserType.LaunchPersistentContextOptions options) {
        initialize();
        
        LOGGER.info("Creating persistent context for {} with user data dir: {}", browserType, userDataDir);
        Path userDataPath = Paths.get(userDataDir);
        
        try {
            Playwright playwright = getPlaywright();
            BrowserContext context;
            
            switch (browserType.toLowerCase()) {
                case "chromium":
                    context = playwright.chromium().launchPersistentContext(userDataPath, options);
                    break;
                case "firefox":
                    context = playwright.firefox().launchPersistentContext(userDataPath, options);
                    break;
                case "webkit":
                    context = playwright.webkit().launchPersistentContext(userDataPath, options);
                    break;
                default:
                    throw new IllegalArgumentException("Unsupported browser type: " + browserType);
            }
            
            LOGGER.info("Created persistent context successfully");
            return context;
        } catch (Exception e) {
            LOGGER.error("Failed to create persistent context: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create persistent context: " + e.getMessage(), e);
        }
    }
    
    /**
     * Installs Playwright browsers or other dependencies.
     * This is useful when running in environments where browsers are not pre-installed.
     */
    public void installPlaywrightDependencies() {
        try {
            LOGGER.info("Installing Playwright dependencies");
            Playwright.create().close();
            LOGGER.info("Playwright dependencies installed successfully");
        } catch (Exception e) {
            LOGGER.error("Failed to install Playwright dependencies: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to install Playwright dependencies: " + e.getMessage(), e);
        }
    }
}



package com.cstestforge.framework.playwright.java.browser;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.config.FrameworkConfig;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.BrowserType;
import com.microsoft.playwright.BrowserType.LaunchOptions;
import com.microsoft.playwright.Browser.NewContextOptions;
import com.microsoft.playwright.Playwright;
import com.microsoft.playwright.options.*;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

/**
 * Manages browser launch options for Playwright browsers.
 * Provides factory methods for creating and configuring browser launch options
 * with sensible defaults and customizations.
 */
public class CSLaunchOptionsManager {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSLaunchOptionsManager.class);
    
    private final Map<String, Object> defaultOptions;
    private Viewport defaultViewport;
    private boolean defaultHeadless;
    private boolean defaultSlowMo;
    private int slowMoValue;
    private boolean defaultIgnoreHTTPSErrors;
    private String defaultDownloadsPath;
    private final Map<String, Map<String, Object>> browserTypeOptions;
    
    /**
     * Creates a new launch options manager with default settings.
     */
    public CSLaunchOptionsManager() {
        this.defaultOptions = new HashMap<>();
        this.browserTypeOptions = new HashMap<>();
        
        // Initialize browser-specific option maps
        browserTypeOptions.put("chromium", new HashMap<>());
        browserTypeOptions.put("firefox", new HashMap<>());
        browserTypeOptions.put("webkit", new HashMap<>());
        
        // Set up default viewport
        this.defaultViewport = new Viewport(1280, 720);
        
        // Load default settings from framework configuration
        loadDefaultSettings();
    }
    
    /**
     * Loads default settings from framework configuration.
     */
    private void loadDefaultSettings() {
        try {
            FrameworkConfig config = ConfigurationManager.getInstance().getFrameworkConfig();
            
            // Load headless mode from config
            this.defaultHeadless = config.getPropertyAsBoolean("playwright.browser.headless", true);
            
            // Load slow motion value from config
            this.defaultSlowMo = config.getPropertyAsBoolean("playwright.browser.slowMo.enabled", false);
            this.slowMoValue = config.getPropertyAsInteger("playwright.browser.slowMo.value", 100);
            
            // Load HTTPS error handling from config
            this.defaultIgnoreHTTPSErrors = config.getPropertyAsBoolean("playwright.browser.ignoreHttpsErrors", true);
            
            // Load downloads path from config
            this.defaultDownloadsPath = config.getProperty(
                    "playwright.browser.downloadsPath", 
                    System.getProperty("java.io.tmpdir") + File.separator + "csplaywright_downloads");
            
            // Load viewport settings from config
            int viewportWidth = config.getPropertyAsInteger("playwright.browser.viewport.width", 1280);
            int viewportHeight = config.getPropertyAsInteger("playwright.browser.viewport.height", 720);
            this.defaultViewport = new Viewport(viewportWidth, viewportHeight);
            
        } catch (Exception e) {
            LOGGER.warn("Failed to load default settings from configuration. Using built-in defaults.", e);
        }
    }
    
    /**
     * Sets the default viewport size for all browser types.
     *
     * @param width Viewport width in pixels
     * @param height Viewport height in pixels
     * @return The current instance for method chaining
     */
    public CSLaunchOptionsManager setDefaultViewport(int width, int height) {
        this.defaultViewport = new Viewport(width, height);
        return this;
    }
    
    /**
     * Sets the default headless mode for all browser types.
     *
     * @param headless Whether to run browsers in headless mode
     * @return The current instance for method chaining
     */
    public CSLaunchOptionsManager setDefaultHeadless(boolean headless) {
        this.defaultHeadless = headless;
        return this;
    }
    
    /**
     * Sets the default slow motion mode for all browser types.
     *
     * @param enabled Whether to enable slow motion mode
     * @param milliseconds Delay in milliseconds between operations
     * @return The current instance for method chaining
     */
    public CSLaunchOptionsManager setDefaultSlowMo(boolean enabled, int milliseconds) {
        this.defaultSlowMo = enabled;
        this.slowMoValue = milliseconds;
        return this;
    }
    
    /**
     * Sets the default HTTPS error handling for all browser types.
     *
     * @param ignore Whether to ignore HTTPS errors
     * @return The current instance for method chaining
     */
    public CSLaunchOptionsManager setDefaultIgnoreHTTPSErrors(boolean ignore) {
        this.defaultIgnoreHTTPSErrors = ignore;
        return this;
    }
    
    /**
     * Sets the default downloads path for all browser types.
     *
     * @param path Path to store downloaded files
     * @return The current instance for method chaining
     */
    public CSLaunchOptionsManager setDefaultDownloadsPath(String path) {
        this.defaultDownloadsPath = path;
        return this;
    }
    
    /**
     * Sets a default option for all browser types.
     *
     * @param key Option key
     * @param value Option value
     * @return The current instance for method chaining
     */
    public CSLaunchOptionsManager setDefaultOption(String key, Object value) {
        defaultOptions.put(key, value);
        return this;
    }
    
    /**
     * Sets a browser-specific option.
     *
     * @param browserType Browser type ("chromium", "firefox", or "webkit")
     * @param key Option key
     * @param value Option value
     * @return The current instance for method chaining
     */
    public CSLaunchOptionsManager setBrowserOption(String browserType, String key, Object value) {
        Map<String, Object> options = browserTypeOptions.get(browserType.toLowerCase());
        if (options == null) {
            throw new IllegalArgumentException("Unsupported browser type: " + browserType);
        }
        
        options.put(key, value);
        return this;
    }
    
    /**
     * Creates Chromium launch options with default settings.
     *
     * @return The created launch options
     */
    public LaunchOptions getChromiumLaunchOptions() {
        return createBaseLaunchOptions()
                .setChannel("chrome")
                .setArgs(getChromiumArgs());
    }
    
    /**
     * Creates Firefox launch options with default settings.
     *
     * @return The created launch options
     */
    public LaunchOptions getFirefoxLaunchOptions() {
        return createBaseLaunchOptions()
                .setFirefoxUserPrefs(getFirefoxPreferences());
    }
    
    /**
     * Creates WebKit launch options with default settings.
     *
     * @return The created launch options
     */
    public LaunchOptions getWebKitLaunchOptions() {
        return createBaseLaunchOptions();
    }
    
    /**
     * Creates base launch options with common settings for all browser types.
     *
     * @return The created launch options
     */
    private LaunchOptions createBaseLaunchOptions() {
        LaunchOptions options = new LaunchOptions();
        
        // Apply common default options
        options.setHeadless(defaultHeadless);
        
        if (defaultSlowMo) {
            options.setSlowMo(slowMoValue);
        }
        
        // Apply any additional default options
        for (Map.Entry<String, Object> entry : defaultOptions.entrySet()) {
            applyOption(options, entry.getKey(), entry.getValue());
        }
        
        return options;
    }
    
    /**
     * Creates default context options with common settings for all browser types.
     *
     * @return The created context options
     */
    public NewContextOptions getDefaultContextOptions() {
        NewContextOptions options = new NewContextOptions();
        
        // Set viewport
        options.setViewportSize(defaultViewport.width, defaultViewport.height);
        
        // Set common options
        options.setIgnoreHTTPSErrors(defaultIgnoreHTTPSErrors);
        
        if (defaultDownloadsPath != null && !defaultDownloadsPath.isEmpty()) {
            options.setAcceptDownloads(true);
            options.setRecordHarPath(Paths.get(defaultDownloadsPath));
        }
        
        return options;
    }
    
    /**
     * Applies a specific option to launch options.
     *
     * @param options Launch options to modify
     * @param key Option key
     * @param value Option value
     */
    private void applyOption(LaunchOptions options, String key, Object value) {
        // Apply option based on key
        switch (key) {
            case "executablePath":
                options.setExecutablePath(Paths.get(value.toString()));
                break;
            case "args":
                if (value instanceof List) {
                    options.setArgs((List<String>) value);
                }
                break;
            case "ignoreDefaultArgs":
                if (value instanceof List) {
                    options.setIgnoreDefaultArgs((List<String>) value);
                } else if (value instanceof Boolean) {
                    options.setIgnoreAllDefaultArgs((Boolean) value);
                }
                break;
            case "proxy":
                if (value instanceof Proxy) {
                    options.setProxy((Proxy) value);
                }
                break;
            case "downloadsPath":
                options.setDownloadsPath(Paths.get(value.toString()));
                break;
            case "tracesDir":
                options.setTracesDir(Paths.get(value.toString()));
                break;
            case "chromiumSandbox":
                options.setChromiumSandbox((Boolean) value);
                break;
            default:
                LOGGER.warn("Unknown option key: {}. Option will be ignored.", key);
                break;
        }
    }
    
    /**
     * Gets default Chromium launch arguments.
     *
     * @return List of Chromium arguments
     */
    private List<String> getChromiumArgs() {
        List<String> args = new ArrayList<>();
        
        // Add common Chromium args
        args.add("--no-sandbox");
        args.add("--disable-dev-shm-usage");
        args.add("--disable-gpu");
        args.add("--disable-features=TranslateUI");
        args.add("--disable-extensions");
        args.add("--disable-component-extensions-with-background-pages");
        args.add("--disable-default-apps");
        args.add("--mute-audio");
        args.add("--no-default-browser-check");
        args.add("--no-first-run");
        args.add("--disable-backgrounding-occluded-windows");
        args.add("--disable-renderer-backgrounding");
        args.add("--disable-background-timer-throttling");
        args.add("--disable-background-networking");
        args.add("--disable-breakpad");
        args.add("--disable-site-isolation-trials");
        args.add("--disable-ipc-flooding-protection");
        args.add("--disable-hang-monitor");
        args.add("--disable-client-side-phishing-detection");
        args.add("--disable-popup-blocking");
        args.add("--disable-prompt-on-repost");
        args.add("--metrics-recording-only");
        args.add("--safebrowsing-disable-auto-update");
        args.add("--password-store=basic");
        args.add("--use-mock-keychain");
        args.add("--enable-automation");
        args.add("--disable-blink-features=AutomationControlled");
        
        // Add browser-specific options from configuration
        Map<String, Object> chromiumOptions = browserTypeOptions.get("chromium");
        if (chromiumOptions.containsKey("args") && chromiumOptions.get("args") instanceof List) {
            args.addAll((List<String>) chromiumOptions.get("args"));
        }
        
        return args;
    }
    
    /**
     * Gets default Firefox preferences.
     *
     * @return Map of Firefox preferences
     */
    private Map<String, Object> getFirefoxPreferences() {
        Map<String, Object> prefs = new HashMap<>();
        
        // Add common Firefox preferences
        prefs.put("browser.shell.checkDefaultBrowser", false);
        prefs.put("browser.startup.homepage", "about:blank");
        prefs.put("browser.startup.page", 0);
        prefs.put("browser.sessionstore.resume_from_crash", false);
        prefs.put("browser.newtabpage.enabled", false);
        prefs.put("browser.tabs.warnOnClose", false);
        prefs.put("browser.tabs.warnOnCloseOtherTabs", false);
        prefs.put("browser.tabs.warnOnOpen", false);
        prefs.put("datareporting.policy.dataSubmissionEnabled", false);
        prefs.put("datareporting.healthreport.uploadEnabled", false);
        prefs.put("toolkit.telemetry.reportingpolicy.firstRun", false);
        prefs.put("toolkit.telemetry.enabled", false);
        prefs.put("toolkit.telemetry.rejected", true);
        prefs.put("toolkit.telemetry.server", "");
        prefs.put("privacy.trackingprotection.enabled", false);
        prefs.put("privacy.trackingprotection.pbmode.enabled", false);
        prefs.put("browser.crashReports.unsubmittedCheck.enabled", false);
        prefs.put("browser.safebrowsing.enabled", false);
        prefs.put("browser.safebrowsing.malware.enabled", false);
        prefs.put("browser.safebrowsing.phishing.enabled", false);
        prefs.put("browser.safebrowsing.downloads.enabled", false);
        prefs.put("dom.disable_window_flip", true);
        prefs.put("dom.disable_window_move_resize", true);
        prefs.put("media.autoplay.default", 5);
        prefs.put("media.volume_scale", "0.0");
        
        // Add browser-specific options from configuration
        Map<String, Object> firefoxOptions = browserTypeOptions.get("firefox");
        if (firefoxOptions.containsKey("prefs") && firefoxOptions.get("prefs") instanceof Map) {
            prefs.putAll((Map<String, Object>) firefoxOptions.get("prefs"));
        }
        
        return prefs;
    }
    
    /**
     * Configures device emulation for context options.
     *
     * @param options Context options to modify
     * @param deviceName Name of the device to emulate
     * @return The modified context options
     */
    public NewContextOptions configureDeviceEmulation(NewContextOptions options, String deviceName) {
        LOGGER.info("Configuring device emulation for: {}", deviceName);
        
        try {
            // Get device descriptor from Playwright
            try (Playwright playwright = Playwright.create()) {
                DeviceDescriptor device = playwright.devices().get(deviceName);
                if (device == null) {
                    LOGGER.warn("Device not found: {}. Using default settings.", deviceName);
                    return options;
                }
                
                // Apply device settings
                options.setUserAgent(device.userAgent);
                options.setDeviceScaleFactor(device.deviceScaleFactor);
                options.setIsMobile(device.isMobile);
                options.setHasTouch(device.hasTouch);
                options.setViewportSize(device.viewport.width, device.viewport.height);
                
                return options;
            }
        } catch (Exception e) {
            LOGGER.error("Failed to configure device emulation: {}", e.getMessage(), e);
            return options;
        }
    }
    
    /**
     * Configures geolocation for context options.
     *
     * @param options Context options to modify
     * @param latitude Latitude
     * @param longitude Longitude
     * @param accuracy Optional accuracy in meters
     * @return The modified context options
     */
    public NewContextOptions configureGeolocation(NewContextOptions options, 
                                                  double latitude, 
                                                  double longitude, 
                                                  Double accuracy) {
        Geolocation geolocation = new Geolocation(latitude, longitude);
        
        if (accuracy != null) {
            geolocation.accuracy = accuracy;
        }
        
        options.setGeolocation(geolocation);
        return options;
    }
    
    /**
     * Configures permissions for context options.
     *
     * @param options Context options to modify
     * @param permissions List of permissions to grant
     * @return The modified context options
     */
    public NewContextOptions configurePermissions(NewContextOptions options, List<String> permissions) {
        options.setPermissions(permissions);
        return options;
    }
    
    /**
     * Configures HTTP credentials for context options.
     *
     * @param options Context options to modify
     * @param username Username
     * @param password Password
     * @return The modified context options
     */
    public NewContextOptions configureHttpCredentials(NewContextOptions options, 
                                                     String username, 
                                                     String password) {
        options.setHttpCredentials(username, password);
        return options;
    }
    
    /**
     * Configures locale and timezone for context options.
     *
     * @param options Context options to modify
     * @param locale Locale (e.g., "en-US")
     * @param timezone Timezone (e.g., "America/New_York")
     * @return The modified context options
     */
    public NewContextOptions configureLocale(NewContextOptions options, 
                                            String locale, 
                                            String timezone) {
        if (locale != null && !locale.isEmpty()) {
            options.setLocale(locale);
        }
        
        if (timezone != null && !timezone.isEmpty()) {
            options.setTimezoneId(timezone);
        }
        
        return options;
    }
    
    /**
     * Inner class for viewport dimensions.
     */
    public static class Viewport {
        public final int width;
        public final int height;
        
        public Viewport(int width, int height) {
            this.width = width;
            this.height = height;
        }
    }
}



package com.cstestforge.framework.playwright.java.browser;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.*;
import com.microsoft.playwright.Browser.NewContextOptions;
import com.microsoft.playwright.options.*;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

/**
 * Manages BrowserContext instances for the CSTestForge framework.
 * This class provides methods for creating, configuring, and managing browser contexts.
 */
public class CSBrowserContextManager {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSBrowserContextManager.class);
    
    private final Browser browser;
    private final CSLaunchOptionsManager launchOptionsManager;
    private final Map<String, BrowserContext> contexts;
    private final ThreadLocal<BrowserContext> currentContext;
    private final CSPlaywrightManager playwrightManager;
    
    /**
     * Creates a browser context manager for the specified browser.
     *
     * @param browser Browser instance
     */
    public CSBrowserContextManager(Browser browser) {
        this.browser = browser;
        this.playwrightManager = CSPlaywrightManager.getInstance();
        this.launchOptionsManager = playwrightManager.getLaunchOptionsManager();
        this.contexts = new ConcurrentHashMap<>();
        this.currentContext = new ThreadLocal<>();
    }
    
    /**
     * Creates a browser context with default options.
     *
     * @return The created BrowserContext
     */
    public BrowserContext createContext() {
        return createContext(launchOptionsManager.getDefaultContextOptions());
    }
    
    /**
     * Creates a browser context with custom options.
     *
     * @param options Context options
     * @return The created BrowserContext
     */
    public BrowserContext createContext(NewContextOptions options) {
        String contextId = generateContextId();
        LOGGER.info("Creating browser context with ID: {}", contextId);
        
        try {
            BrowserContext context = browser.newContext(options);
            contexts.put(contextId, context);
            currentContext.set(context);
            
            // Configure default timeout if specified
            int defaultTimeout = ConfigurationManager.getInstance()
                    .getFrameworkConfig()
                    .getPropertyAsInteger("playwright.context.defaultTimeout", 30000);
            context.setDefaultTimeout(defaultTimeout);
            
            LOGGER.info("Created browser context with ID: {}", contextId);
            return context;
        } catch (Exception e) {
            LOGGER.error("Failed to create browser context: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create browser context: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a browser context with device emulation.
     *
     * @param deviceName Name of the device to emulate
     * @return The created BrowserContext
     */
    public BrowserContext createContextWithDeviceEmulation(String deviceName) {
        LOGGER.info("Creating browser context with device emulation: {}", deviceName);
        
        try {
            NewContextOptions options = launchOptionsManager.getDefaultContextOptions();
            options = launchOptionsManager.configureDeviceEmulation(options, deviceName);
            return createContext(options);
        } catch (Exception e) {
            LOGGER.error("Failed to create browser context with device emulation: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create browser context with device emulation: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a browser context with geolocation.
     *
     * @param latitude Latitude
     * @param longitude Longitude
     * @param accuracy Optional accuracy in meters
     * @return The created BrowserContext
     */
    public BrowserContext createContextWithGeolocation(double latitude, double longitude, Double accuracy) {
        LOGGER.info("Creating browser context with geolocation: lat={}, lon={}", latitude, longitude);
        
        try {
            NewContextOptions options = launchOptionsManager.getDefaultContextOptions();
            options = launchOptionsManager.configureGeolocation(options, latitude, longitude, accuracy);
            return createContext(options);
        } catch (Exception e) {
            LOGGER.error("Failed to create browser context with geolocation: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create browser context with geolocation: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a browser context with specific permissions.
     *
     * @param permissions List of permissions to grant
     * @return The created BrowserContext
     */
    public BrowserContext createContextWithPermissions(List<String> permissions) {
        LOGGER.info("Creating browser context with permissions: {}", permissions);
        
        try {
            NewContextOptions options = launchOptionsManager.getDefaultContextOptions();
            options = launchOptionsManager.configurePermissions(options, permissions);
            return createContext(options);
        } catch (Exception e) {
            LOGGER.error("Failed to create browser context with permissions: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create browser context with permissions: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a browser context with a storage state from a file.
     *
     * @param storageStatePath Path to storage state file
     * @return The created BrowserContext
     */
    public BrowserContext createContextWithStorageState(String storageStatePath) {
        LOGGER.info("Creating browser context with storage state from: {}", storageStatePath);
        
        try {
            NewContextOptions options = launchOptionsManager.getDefaultContextOptions();
            options.setStorageStatePath(Paths.get(storageStatePath));
            return createContext(options);
        } catch (Exception e) {
            LOGGER.error("Failed to create browser context with storage state: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create browser context with storage state: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a browser context with HTTP credentials.
     *
     * @param username Username
     * @param password Password
     * @return The created BrowserContext
     */
    public BrowserContext createContextWithHttpCredentials(String username, String password) {
        LOGGER.info("Creating browser context with HTTP credentials for user: {}", username);
        
        try {
            NewContextOptions options = launchOptionsManager.getDefaultContextOptions();
            options = launchOptionsManager.configureHttpCredentials(options, username, password);
            return createContext(options);
        } catch (Exception e) {
            LOGGER.error("Failed to create browser context with HTTP credentials: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create browser context with HTTP credentials: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a browser context with a specific locale and timezone.
     *
     * @param locale Locale (e.g., "en-US")
     * @param timezone Timezone (e.g., "America/New_York")
     * @return The created BrowserContext
     */
    public BrowserContext createContextWithLocale(String locale, String timezone) {
        LOGGER.info("Creating browser context with locale: {} and timezone: {}", locale, timezone);
        
        try {
            NewContextOptions options = launchOptionsManager.getDefaultContextOptions();
            options = launchOptionsManager.configureLocale(options, locale, timezone);
            return createContext(options);
        } catch (Exception e) {
            LOGGER.error("Failed to create browser context with locale and timezone: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create browser context with locale and timezone: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the current browser context for the current thread.
     *
     * @return The current BrowserContext
     * @throws IllegalStateException if no context has been created for the current thread
     */
    public BrowserContext getCurrentContext() {
        BrowserContext context = currentContext.get();
        if (context == null) {
            throw new IllegalStateException("No browser context has been created for the current thread");
        }
        return context;
    }
    
    /**
     * Sets the current browser context for the current thread.
     *
     * @param context BrowserContext to set as current
     */
    public void setCurrentContext(BrowserContext context) {
        currentContext.set(context);
    }
    
    /**
     * Gets all browser contexts managed by this instance.
     *
     * @return Map of context IDs to BrowserContext instances
     */
    public Map<String, BrowserContext> getAllContexts() {
        return Collections.unmodifiableMap(contexts);
    }
    
    /**
     * Configures route handling for the specified context.
     *
     * @param context BrowserContext to configure
     * @param routeHandler Route handler to apply
     */
    public void configureRoutes(BrowserContext context, Consumer<Route> routeHandler) {
        LOGGER.info("Configuring route handler for browser context");
        
        try {
            context.route("**/*", routeHandler::accept);
        } catch (Exception e) {
            LOGGER.error("Failed to configure route handler: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to configure route handler: " + e.getMessage(), e);
        }
    }
    
    /**
     * Configures request interception for the specified context.
     *
     * @param context BrowserContext to configure
     * @param requestHandler Request handler to apply
     */
    public void configureRequestInterception(BrowserContext context, Consumer<Request> requestHandler) {
        LOGGER.info("Configuring request interception for browser context");
        
        try {
            context.onRequest(requestHandler::accept);
        } catch (Exception e) {
            LOGGER.error("Failed to configure request interception: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to configure request interception: " + e.getMessage(), e);
        }
    }
    
    /**
     * Configures response interception for the specified context.
     *
     * @param context BrowserContext to configure
     * @param responseHandler Response handler to apply
     */
    public void configureResponseInterception(BrowserContext context, Consumer<Response> responseHandler) {
        LOGGER.info("Configuring response interception for browser context");
        
        try {
            context.onResponse(responseHandler::accept);
        } catch (Exception e) {
            LOGGER.error("Failed to configure response interception: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to configure response interception: " + e.getMessage(), e);
        }
    }
    
    /**
     * Configures dialog handling for the specified context.
     *
     * @param context BrowserContext to configure
     * @param dialogHandler Dialog handler to apply
     */
    public void configureDialogHandling(BrowserContext context, Consumer<Dialog> dialogHandler) {
        LOGGER.info("Configuring dialog handling for browser context");
        
        try {
            context.onDialog(dialogHandler::accept);
        } catch (Exception e) {
            LOGGER.error("Failed to configure dialog handling: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to configure dialog handling: " + e.getMessage(), e);
        }
    }
    
    /**
     * Adds a cookie to the specified context.
     *
     * @param context BrowserContext to modify
     * @param name Cookie name
     * @param value Cookie value
     * @param domain Cookie domain
     * @param path Cookie path
     * @param expires Expiration time in seconds since the UNIX epoch
     * @param httpOnly Whether the cookie is HTTP-only
     * @param secure Whether the cookie is secure
     */
    public void addCookie(BrowserContext context, 
                         String name, 
                         String value, 
                         String domain, 
                         String path, 
                         Double expires, 
                         boolean httpOnly, 
                         boolean secure) {
        LOGGER.info("Adding cookie to browser context: name={}, domain={}", name, domain);
        
        try {
            Cookie cookie = new Cookie(name, value)
                    .setDomain(domain)
                    .setPath(path != null ? path : "/");
            
            if (expires != null) {
                cookie.setExpires(expires);
            }
            
            cookie.setHttpOnly(httpOnly);
            cookie.setSecure(secure);
            
            context.addCookies(Arrays.asList(cookie));
        } catch (Exception e) {
            LOGGER.error("Failed to add cookie: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to add cookie: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clears all cookies from the specified context.
     *
     * @param context BrowserContext to modify
     */
    public void clearCookies(BrowserContext context) {
        LOGGER.info("Clearing all cookies from browser context");
        
        try {
            context.clearCookies();
        } catch (Exception e) {
            LOGGER.error("Failed to clear cookies: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to clear cookies: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets all cookies from the specified context.
     *
     * @param context BrowserContext to query
     * @return List of cookies
     */
    public List<Cookie> getCookies(BrowserContext context) {
        LOGGER.info("Getting all cookies from browser context");
        
        try {
            return context.cookies();
        } catch (Exception e) {
            LOGGER.error("Failed to get cookies: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to get cookies: " + e.getMessage(), e);
        }
    }
    
    /**
     * Exports storage state from the specified context to a file.
     *
     * @param context BrowserContext to export from
     * @param filePath Path to save storage state
     */
    public void exportStorageState(BrowserContext context, String filePath) {
        LOGGER.info("Exporting storage state to: {}", filePath);
        
        try {
            context.storageState(new BrowserContext.StorageStateOptions().setPath(Paths.get(filePath)));
        } catch (Exception e) {
            LOGGER.error("Failed to export storage state: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to export storage state: " + e.getMessage(), e);
        }
    }
    
    /**
     * Configures offline mode for the specified context.
     *
     * @param context BrowserContext to configure
     * @param offline Whether to enable offline mode
     */
    public void setOffline(BrowserContext context, boolean offline) {
        LOGGER.info("Setting offline mode to: {}", offline);
        
        try {
            context.setOffline(offline);
        } catch (Exception e) {
            LOGGER.error("Failed to set offline mode: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to set offline mode: " + e.getMessage(), e);
        }
    }
    
    /**
     * Closes all managed browser contexts.
     */
    public void closeAllContexts() {
        LOGGER.info("Closing all browser contexts");
        
        for (Map.Entry<String, BrowserContext> entry : contexts.entrySet()) {
            String contextId = entry.getKey();
            BrowserContext context = entry.getValue();
            
            try {
                LOGGER.info("Closing browser context with ID: {}", contextId);
                context.close();
            } catch (Exception e) {
                LOGGER.warn("Failed to close browser context with ID {}: {}", contextId, e.getMessage());
            }
        }
        
        contexts.clear();
        currentContext.remove();
    }
    
    /**
     * Closes the specified browser context.
     *
     * @param context BrowserContext to close
     */
    public void closeContext(BrowserContext context) {
        LOGGER.info("Closing browser context");
        
        try {
            context.close();
            
            // Remove from contexts map
            for (Map.Entry<String, BrowserContext> entry : contexts.entrySet()) {
                if (entry.getValue() == context) {
                    contexts.remove(entry.getKey());
                    break;
                }
            }
            
            // Clear thread-local if this was the current context
            if (context == currentContext.get()) {
                currentContext.remove();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to close browser context: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to close browser context: " + e.getMessage(), e);
        }
    }
    
    /**
     * Generates a unique ID for a browser context.
     *
     * @return A unique context ID
     */
    private String generateContextId() {
        return "context_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
    }
}


package com.cstestforge.framework.playwright.java.browser;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSScreenshotManager;
import com.microsoft.playwright.*;
import com.microsoft.playwright.options.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.regex.Pattern;

/**
 * Manages Page instances for the CSTestForge framework.
 * This class provides methods for creating, interacting with, and managing browser pages.
 */
public class CSPageManager {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSPageManager.class);
    
    private final BrowserContext context;
    private final Map<String, Page> pages;
    private final ThreadLocal<Page> currentPage;
    private final CSBrowserContextManager contextManager;
    
    private int defaultNavigationTimeout;
    private int defaultTimeout;
    private boolean autoScreenshotOnFailure;
    private String screenshotPath;
    
    /**
     * Creates a page manager for the specified browser context.
     *
     * @param context BrowserContext to manage pages for
     * @param contextManager Browser context manager
     */
    public CSPageManager(BrowserContext context, CSBrowserContextManager contextManager) {
        this.context = context;
        this.contextManager = contextManager;
        this.pages = new ConcurrentHashMap<>();
        this.currentPage = new ThreadLocal<>();
        
        // Load default settings from framework configuration
        FrameworkConfig config = ConfigurationManager.getInstance().getFrameworkConfig();
        this.defaultNavigationTimeout = config.getPropertyAsInteger("playwright.page.defaultNavigationTimeout", 30000);
        this.defaultTimeout = config.getPropertyAsInteger("playwright.page.defaultTimeout", 30000);
        this.autoScreenshotOnFailure = config.getPropertyAsBoolean("playwright.page.autoScreenshotOnFailure", true);
        this.screenshotPath = config.getProperty("playwright.page.screenshotPath", 
                System.getProperty("user.dir") + File.separator + "target" + File.separator + "screenshots");
    }
    
    /**
     * Creates a new page in the managed browser context.
     *
     * @return The created Page
     */
    public Page createPage() {
        String pageId = generatePageId();
        LOGGER.info("Creating page with ID: {}", pageId);
        
        try {
            Page page = context.newPage();
            configurePage(page);
            
            pages.put(pageId, page);
            currentPage.set(page);
            
            LOGGER.info("Created page with ID: {}", pageId);
            return page;
        } catch (Exception e) {
            LOGGER.error("Failed to create page: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to create page: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the current page for the current thread.
     *
     * @return The current Page
     * @throws IllegalStateException if no page has been created for the current thread
     */
    public Page getCurrentPage() {
        Page page = currentPage.get();
        if (page == null) {
            throw new IllegalStateException("No page has been created for the current thread");
        }
        return page;
    }
    
    /**
     * Sets the current page for the current thread.
     *
     * @param page Page to set as current
     */
    public void setCurrentPage(Page page) {
        currentPage.set(page);
    }
    
    /**
     * Gets all pages managed by this instance.
     *
     * @return Map of page IDs to Page instances
     */
    public Map<String, Page> getAllPages() {
        return Collections.unmodifiableMap(pages);
    }
    
    /**
     * Configures default settings for a newly created page.
     *
     * @param page Page to configure
     */
    private void configurePage(Page page) {
        // Set default timeouts
        page.setDefaultNavigationTimeout(defaultNavigationTimeout);
        page.setDefaultTimeout(defaultTimeout);
        
        // Set error handler for auto-screenshots
        if (autoScreenshotOnFailure) {
            page.onPageError(exception -> {
                LOGGER.error("Page error: {}", exception);
                takeScreenshot(page, "error_" + System.currentTimeMillis());
            });
        }
    }
    
    /**
     * Navigates to the specified URL on the current page.
     *
     * @param url URL to navigate to
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response navigate(String url) {
        return navigate(getCurrentPage(), url);
    }
    
    /**
     * Navigates to the specified URL on the specified page.
     *
     * @param page Page to navigate with
     * @param url URL to navigate to
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response navigate(Page page, String url) {
        LOGGER.info("Navigating to URL: {}", url);
        
        try {
            Response response = page.navigate(url);
            LOGGER.info("Navigated to URL: {}", url);
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to navigate to URL {}: {}", url, e.getMessage(), e);
            throw new RuntimeException("Failed to navigate to URL: " + e.getMessage(), e);
        }
    }
    
    /**
     * Navigates to the specified URL with custom options on the current page.
     *
     * @param url URL to navigate to
     * @param options Navigation options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response navigate(String url, NavigateOptions options) {
        return navigate(getCurrentPage(), url, options);
    }
    
    /**
     * Navigates to the specified URL with custom options on the specified page.
     *
     * @param page Page to navigate with
     * @param url URL to navigate to
     * @param options Navigation options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response navigate(Page page, String url, NavigateOptions options) {
        LOGGER.info("Navigating to URL: {} with options: {}", url, options);
        
        try {
            Response response = page.navigate(url, options);
            LOGGER.info("Navigated to URL: {}", url);
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to navigate to URL {}: {}", url, e.getMessage(), e);
            throw new RuntimeException("Failed to navigate to URL: " + e.getMessage(), e);
        }
    }
    
    /**
     * Reloads the current page.
     *
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response reload() {
        return reload(getCurrentPage());
    }
    
    /**
     * Reloads the specified page.
     *
     * @param page Page to reload
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response reload(Page page) {
        LOGGER.info("Reloading page");
        
        try {
            Response response = page.reload();
            LOGGER.info("Page reloaded");
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to reload page: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to reload page: " + e.getMessage(), e);
        }
    }
    
    /**
     * Reloads the current page with custom options.
     *
     * @param options Reload options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response reload(ReloadOptions options) {
        return reload(getCurrentPage(), options);
    }
    
    /**
     * Reloads the specified page with custom options.
     *
     * @param page Page to reload
     * @param options Reload options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response reload(Page page, ReloadOptions options) {
        LOGGER.info("Reloading page with options: {}", options);
        
        try {
            Response response = page.reload(options);
            LOGGER.info("Page reloaded");
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to reload page: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to reload page: " + e.getMessage(), e);
        }
    }
    
    /**
     * Goes back in the browser history on the current page.
     *
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response goBack() {
        return goBack(getCurrentPage());
    }
    
    /**
     * Goes back in the browser history on the specified page.
     *
     * @param page Page to navigate with
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response goBack(Page page) {
        LOGGER.info("Going back in browser history");
        
        try {
            Response response = page.goBack();
            LOGGER.info("Went back in browser history");
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to go back in browser history: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to go back in browser history: " + e.getMessage(), e);
        }
    }
    
    /**
     * Goes back in the browser history on the current page with custom options.
     *
     * @param options Navigation options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response goBack(NavigateOptions options) {
        return goBack(getCurrentPage(), options);
    }
    
    /**
     * Goes back in the browser history on the specified page with custom options.
     *
     * @param page Page to navigate with
     * @param options Navigation options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response goBack(Page page, NavigateOptions options) {
        LOGGER.info("Going back in browser history with options: {}", options);
        
        try {
            Response response = page.goBack(options);
            LOGGER.info("Went back in browser history");
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to go back in browser history: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to go back in browser history: " + e.getMessage(), e);
        }
    }
    
    /**
     * Goes forward in the browser history on the current page.
     *
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response goForward() {
        return goForward(getCurrentPage());
    }
    
    /**
     * Goes forward in the browser history on the specified page.
     *
     * @param page Page to navigate with
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response goForward(Page page) {
        LOGGER.info("Going forward in browser history");
        
        try {
            Response response = page.goForward();
            LOGGER.info("Went forward in browser history");
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to go forward in browser history: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to go forward in browser history: " + e.getMessage(), e);
        }
    }
    
    /**
     * Goes forward in the browser history on the current page with custom options.
     *
     * @param options Navigation options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response goForward(NavigateOptions options) {
        return goForward(getCurrentPage(), options);
    }
    
    /**
     * Goes forward in the browser history on the specified page with custom options.
     *
     * @param page Page to navigate with
     * @param options Navigation options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response goForward(Page page, NavigateOptions options) {
        LOGGER.info("Going forward in browser history with options: {}", options);
        
        try {
            Response response = page.goForward(options);
            LOGGER.info("Went forward in browser history");
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to go forward in browser history: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to go forward in browser history: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for navigation to complete on the current page.
     *
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response waitForNavigation() {
        return waitForNavigation(getCurrentPage());
    }
    
    /**
     * Waits for navigation to complete on the specified page.
     *
     * @param page Page to wait on
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response waitForNavigation(Page page) {
        LOGGER.info("Waiting for navigation to complete");
        
        try {
            Response response = page.waitForNavigation();
            LOGGER.info("Navigation completed");
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to wait for navigation: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to wait for navigation: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for navigation to complete on the current page with custom options.
     *
     * @param options Wait for navigation options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response waitForNavigation(WaitForNavigationOptions options) {
        return waitForNavigation(getCurrentPage(), options);
    }
    
    /**
     * Waits for navigation to complete on the specified page with custom options.
     *
     * @param page Page to wait on
     * @param options Wait for navigation options
     * @return The Response object, or null if the navigation resulted in no server response
     */
    public Response waitForNavigation(Page page, WaitForNavigationOptions options) {
        LOGGER.info("Waiting for navigation to complete with options: {}", options);
        
        try {
            Response response = page.waitForNavigation(options);
            LOGGER.info("Navigation completed");
            return response;
        } catch (Exception e) {
            LOGGER.error("Failed to wait for navigation: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to wait for navigation: " + e.getMessage(), e);
        }
    }
    
    /**
     * Executes JavaScript code on the current page.
     *
     * @param script JavaScript code to execute
     * @param args Arguments to pass to the script
     * @return The result of the script execution
     */
    public Object evaluate(String script, Object... args) {
        return evaluate(getCurrentPage(), script, args);
    }
    
    /**
     * Executes JavaScript code on the specified page.
     *
     * @param page Page to execute script on
     * @param script JavaScript code to execute
     * @param args Arguments to pass to the script
     * @return The result of the script execution
     */
    public Object evaluate(Page page, String script, Object... args) {
        LOGGER.debug("Executing JavaScript: {}", script);
        
        try {
            Object result = page.evaluate(script, args);
            LOGGER.debug("JavaScript execution completed");
            return result;
        } catch (Exception e) {
            LOGGER.error("Failed to execute JavaScript: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to execute JavaScript: " + e.getMessage(), e);
        }
    }
    
    /**
     * Takes a screenshot of the current page.
     *
     * @param fileName Base file name (without extension)
     * @return Path to the saved screenshot
     */
    public String takeScreenshot(String fileName) {
        return takeScreenshot(getCurrentPage(), fileName);
    }
    
    /**
     * Takes a screenshot of the specified page.
     *
     * @param page Page to take screenshot of
     * @param fileName Base file name (without extension)
     * @return Path to the saved screenshot
     */
    public String takeScreenshot(Page page, String fileName) {
        LOGGER.info("Taking screenshot: {}", fileName);
        
        try {
            // Create screenshots directory if it doesn't exist
            File screenshotDir = new File(screenshotPath);
            if (!screenshotDir.exists()) {
                screenshotDir.mkdirs();
            }
            
            // Generate screenshot path
            String timestamp = String.valueOf(System.currentTimeMillis());
            String screenshotFile = fileName + "_" + timestamp + ".png";
            Path fullPath = Paths.get(screenshotPath, screenshotFile);
            
            // Take screenshot
            page.screenshot(new Page.ScreenshotOptions().setPath(fullPath).setFullPage(true));
            
            LOGGER.info("Screenshot saved to: {}", fullPath);
            return fullPath.toString();
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshot: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to take screenshot: " + e.getMessage(), e);
        }
    }
    
    /**
     * Takes a screenshot of the current page with custom options.
     *
     * @param fileName Base file name (without extension)
     * @param options Screenshot options
     * @return Path to the saved screenshot
     */
    public String takeScreenshot(String fileName, Page.ScreenshotOptions options) {
        return takeScreenshot(getCurrentPage(), fileName, options);
    }
    
    /**
     * Takes a screenshot of the specified page with custom options.
     *
     * @param page Page to take screenshot of
     * @param fileName Base file name (without extension)
     * @param options Screenshot options
     * @return Path to the saved screenshot
     */
    public String takeScreenshot(Page page, String fileName, Page.ScreenshotOptions options) {
        LOGGER.info("Taking screenshot with options: {}", options);
        
        try {
            // Create screenshots directory if it doesn't exist
            File screenshotDir = new File(screenshotPath);
            if (!screenshotDir.exists()) {
                screenshotDir.mkdirs();
            }
            
            // Generate screenshot path
            String timestamp = String.valueOf(System.currentTimeMillis());
            String screenshotFile = fileName + "_" + timestamp + ".png";
            Path fullPath = Paths.get(screenshotPath, screenshotFile);
            
            // Set path in options
            options.setPath(fullPath);
            
            // Take screenshot
            page.screenshot(options);
            
            LOGGER.info("Screenshot saved to: {}", fullPath);
            return fullPath.toString();
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshot: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to take screenshot: " + e.getMessage(), e);
        }
    }
    
    /**
     * Takes a screenshot of the specified element on the current page.
     *
     * @param selector Element selector
     * @param fileName Base file name (without extension)
     * @return Path to the saved screenshot
     */
    public String takeElementScreenshot(String selector, String fileName) {
        return takeElementScreenshot(getCurrentPage(), selector, fileName);
    }
    
    /**
     * Takes a screenshot of the specified element on the specified page.
     *
     * @param page Page to take screenshot on
     * @param selector Element selector
     * @param fileName Base file name (without extension)
     * @return Path to the saved screenshot
     */
    public String takeElementScreenshot(Page page, String selector, String fileName) {
        LOGGER.info("Taking screenshot of element {}: {}", selector, fileName);
        
        try {
            // Create screenshots directory if it doesn't exist
            File screenshotDir = new File(screenshotPath);
            if (!screenshotDir.exists()) {
                screenshotDir.mkdirs();
            }
            
            // Generate screenshot path
            String timestamp = String.valueOf(System.currentTimeMillis());
            String screenshotFile = fileName + "_" + timestamp + ".png";
            Path fullPath = Paths.get(screenshotPath, screenshotFile);
            
            // Get element and take screenshot
            Locator element = page.locator(selector);
            element.screenshot(new Locator.ScreenshotOptions().setPath(fullPath));
            
            LOGGER.info("Element screenshot saved to: {}", fullPath);
            return fullPath.toString();
        } catch (Exception e) {
            LOGGER.error("Failed to take element screenshot: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to take element screenshot: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for a selector to be present on the current page.
     *
     * @param selector Element selector
     * @return The first element that matches the selector
     */
    public Locator waitForSelector(String selector) {
        return waitForSelector(getCurrentPage(), selector);
    }
    
    /**
     * Waits for a selector to be present on the specified page.
     *
     * @param page Page to wait on
     * @param selector Element selector
     * @return The first element that matches the selector
     */
    public Locator waitForSelector(Page page, String selector) {
        LOGGER.info("Waiting for selector: {}", selector);
        
        try {
            page.waitForSelector(selector);
            LOGGER.info("Selector found: {}", selector);
            return page.locator(selector);
        } catch (Exception e) {
            LOGGER.error("Failed to wait for selector {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to wait for selector: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for a selector to be present on the current page with custom options.
     *
     * @param selector Element selector
     * @param options Wait for selector options
     * @return The first element that matches the selector
     */
    public Locator waitForSelector(String selector, Page.WaitForSelectorOptions options) {
        return waitForSelector(getCurrentPage(), selector, options);
    }
    
    /**
     * Waits for a selector to be present on the specified page with custom options.
     *
     * @param page Page to wait on
     * @param selector Element selector
     * @param options Wait for selector options
     * @return The first element that matches the selector
     */
    public Locator waitForSelector(Page page, String selector, Page.WaitForSelectorOptions options) {
        LOGGER.info("Waiting for selector {} with options: {}", selector, options);
        
        try {
            page.waitForSelector(selector, options);
            LOGGER.info("Selector found: {}", selector);
            return page.locator(selector);
        } catch (Exception e) {
            LOGGER.error("Failed to wait for selector {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to wait for selector: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for a function to evaluate to a truthy value on the current page.
     *
     * @param predicate JavaScript function to evaluate
     * @param args Arguments to pass to the function
     */
    public void waitForFunction(String predicate, Object... args) {
        waitForFunction(getCurrentPage(), predicate, args);
    }
    
    /**
     * Waits for a function to evaluate to a truthy value on the specified page.
     *
     * @param page Page to wait on
     * @param predicate JavaScript function to evaluate
     * @param args Arguments to pass to the function
     */
    public void waitForFunction(Page page, String predicate, Object... args) {
        LOGGER.info("Waiting for function to evaluate to truthy value");
        
        try {
            page.waitForFunction(predicate, args);
            LOGGER.info("Function evaluated to truthy value");
        } catch (Exception e) {
            LOGGER.error("Failed to wait for function: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to wait for function: " + e.getMessage(), e);
        }
    }
    
    /**
     * Sets the default navigation timeout for the current page.
     *
     * @param timeout Timeout in milliseconds
     */
    public void setDefaultNavigationTimeout(int timeout) {
        setDefaultNavigationTimeout(getCurrentPage(), timeout);
    }
    
    /**
     * Sets the default navigation timeout for the specified page.
     *
     * @param page Page to configure
     * @param timeout Timeout in milliseconds
     */
    public void setDefaultNavigationTimeout(Page page, int timeout) {
        LOGGER.info("Setting default navigation timeout to {} ms", timeout);
        
        try {
            page.setDefaultNavigationTimeout(timeout);
        } catch (Exception e) {
            LOGGER.error("Failed to set default navigation timeout: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to set default navigation timeout: " + e.getMessage(), e);
        }
    }
    
    /**
     * Sets the default timeout for the current page.
     *
     * @param timeout Timeout in milliseconds
     */
    public void setDefaultTimeout(int timeout) {
        setDefaultTimeout(getCurrentPage(), timeout);
    }
    
    /**
     * Sets the default timeout for the specified page.
     *
     * @param page Page to configure
     * @param timeout Timeout in milliseconds
     */
    public void setDefaultTimeout(Page page, int timeout) {
        LOGGER.info("Setting default timeout to {} ms", timeout);
        
        try {
            page.setDefaultTimeout(timeout);
        } catch (Exception e) {
            LOGGER.error("Failed to set default timeout: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to set default timeout: " + e.getMessage(), e);
        }
    }
    
    /**
     * Closes all managed pages.
     */
    public void closeAllPages() {
        LOGGER.info("Closing all pages");
        
        for (Map.Entry<String, Page> entry : pages.entrySet()) {
            String pageId = entry.getKey();
            Page page = entry.getValue();
            
            try {
                LOGGER.info("Closing page with ID: {}", pageId);
                page.close();
            } catch (Exception e) {
                LOGGER.warn("Failed to close page with ID {}: {}", pageId, e.getMessage());
            }
        }
        
        pages.clear();
        currentPage.remove();
    }
    
    /**
     * Closes the specified page.
     *
     * @param page Page to close
     */
    public void closePage(Page page) {
        LOGGER.info("Closing page");
        
        try {
            page.close();
            
            // Remove from pages map
            for (Map.Entry<String, Page> entry : pages.entrySet()) {
                if (entry.getValue() == page) {
                    pages.remove(entry.getKey());
                    break;
                }
            }
            
            // Clear thread-local if this was the current page
            if (page == currentPage.get()) {
                currentPage.remove();
            }
        } catch (Exception e) {
            LOGGER.error("Failed to close page: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to close page: " + e.getMessage(), e);
        }
    }
    
    /**
     * Sets the auto-screenshot on failure flag.
     *
     * @param autoScreenshot Whether to automatically take screenshots on failure
     */
    public void setAutoScreenshotOnFailure(boolean autoScreenshot) {
        this.autoScreenshotOnFailure = autoScreenshot;
    }
    
    /**
     * Sets the screenshot path.
     *
     * @param path Path to save screenshots
     */
    public void setScreenshotPath(String path) {
        this.screenshotPath = path;
    }
    
    /**
     * Generates a unique ID for a page.
     *
     * @return A unique page ID
     */
    private String generatePageId() {
        return "page_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
    }
}



package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.browser.CSPageManager;
import com.microsoft.playwright.*;
import com.microsoft.playwright.options.*;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.regex.Pattern;

/**
 * Enhanced wrapper for Playwright Locator.
 * Provides additional functionality and error handling for element operations.
 */
public class CSElement {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSElement.class);
    
    private final Page page;
    private final Locator locator;
    private final String selector;
    private final CSPageManager pageManager;
    
    private int defaultTimeout = 30000; // Default timeout in milliseconds
    
    /**
     * Creates a new CSElement with the specified page and selector.
     *
     * @param page Page that contains the element
     * @param selector Selector to locate the element
     * @param pageManager Page manager
     */
    public CSElement(Page page, String selector, CSPageManager pageManager) {
        this.page = page;
        this.selector = selector;
        this.locator = page.locator(selector);
        this.pageManager = pageManager;
    }
    
    /**
     * Creates a new CSElement with the specified page and Locator.
     *
     * @param page Page that contains the element
     * @param locator Locator for the element
     * @param selector Selector string used to create the locator
     * @param pageManager Page manager
     */
    public CSElement(Page page, Locator locator, String selector, CSPageManager pageManager) {
        this.page = page;
        this.locator = locator;
        this.selector = selector;
        this.pageManager = pageManager;
    }
    
    /**
     * Gets the underlying Playwright Locator.
     *
     * @return The Locator object
     */
    public Locator getLocator() {
        return locator;
    }
    
    /**
     * Gets the selector used to create this element.
     *
     * @return The selector string
     */
    public String getSelector() {
        return selector;
    }
    
    /**
     * Sets the default timeout for element operations.
     *
     * @param timeoutMs Timeout in milliseconds
     * @return This CSElement instance for method chaining
     */
    public CSElement setTimeout(int timeoutMs) {
        this.defaultTimeout = timeoutMs;
        return this;
    }
    
    /**
     * Clicks on the element.
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement click() {
        LOGGER.info("Clicking on element: {}", selector);
        
        try {
            locator.click(new Locator.ClickOptions().setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to click on element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to click on element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clicks on the element with custom options.
     *
     * @param options Click options
     * @return This CSElement instance for method chaining
     */
    public CSElement click(Locator.ClickOptions options) {
        LOGGER.info("Clicking on element {} with options: {}", selector, options);
        
        try {
            locator.click(options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to click on element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to click on element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Double-clicks on the element.
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement dblclick() {
        LOGGER.info("Double-clicking on element: {}", selector);
        
        try {
            locator.dblclick(new Locator.DblclickOptions().setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to double-click on element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to double-click on element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Double-clicks on the element with custom options.
     *
     * @param options Double-click options
     * @return This CSElement instance for method chaining
     */
    public CSElement dblclick(Locator.DblclickOptions options) {
        LOGGER.info("Double-clicking on element {} with options: {}", selector, options);
        
        try {
            locator.dblclick(options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to double-click on element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to double-click on element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Types text into the element.
     *
     * @param text Text to type
     * @return This CSElement instance for method chaining
     */
    public CSElement fill(String text) {
        LOGGER.info("Filling element {} with text: {}", selector, text);
        
        try {
            locator.fill(text, new Locator.FillOptions().setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to fill element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to fill element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Types text into the element with custom options.
     *
     * @param text Text to type
     * @param options Fill options
     * @return This CSElement instance for method chaining
     */
    public CSElement fill(String text, Locator.FillOptions options) {
        LOGGER.info("Filling element {} with text: {} and options: {}", selector, text, options);
        
        try {
            locator.fill(text, options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to fill element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to fill element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Types text into the element character by character.
     *
     * @param text Text to type
     * @return This CSElement instance for method chaining
     */
    public CSElement type(String text) {
        LOGGER.info("Typing text in element {}: {}", selector, text);
        
        try {
            locator.type(text, new Locator.TypeOptions().setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to type text in element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to type text in element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Types text into the element character by character with custom options.
     *
     * @param text Text to type
     * @param options Type options
     * @return This CSElement instance for method chaining
     */
    public CSElement type(String text, Locator.TypeOptions options) {
        LOGGER.info("Typing text in element {} with options: {}", selector, options);
        
        try {
            locator.type(text, options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to type text in element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to type text in element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Presses a key on the element.
     *
     * @param key Key to press (e.g., "Enter", "ArrowDown")
     * @return This CSElement instance for method chaining
     */
    public CSElement press(String key) {
        LOGGER.info("Pressing key {} on element: {}", key, selector);
        
        try {
            locator.press(key, new Locator.PressOptions().setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to press key {} on element {}: {}", key, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to press key on element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Presses a key on the element with custom options.
     *
     * @param key Key to press (e.g., "Enter", "ArrowDown")
     * @param options Press options
     * @return This CSElement instance for method chaining
     */
    public CSElement press(String key, Locator.PressOptions options) {
        LOGGER.info("Pressing key {} on element {} with options: {}", key, selector, options);
        
        try {
            locator.press(key, options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to press key {} on element {}: {}", key, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to press key on element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Hovers over the element.
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement hover() {
        LOGGER.info("Hovering over element: {}", selector);
        
        try {
            locator.hover(new Locator.HoverOptions().setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to hover over element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to hover over element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Hovers over the element with custom options.
     *
     * @param options Hover options
     * @return This CSElement instance for method chaining
     */
    public CSElement hover(Locator.HoverOptions options) {
        LOGGER.info("Hovering over element {} with options: {}", selector, options);
        
        try {
            locator.hover(options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to hover over element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to hover over element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the text content of the element.
     *
     * @return The text content
     */
    public String getText() {
        LOGGER.debug("Getting text from element: {}", selector);
        
        try {
            String text = locator.textContent();
            LOGGER.debug("Got text from element {}: {}", selector, text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get text from element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get text from element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the inner text of the element.
     *
     * @return The inner text
     */
    public String getInnerText() {
        LOGGER.debug("Getting inner text from element: {}", selector);
        
        try {
            String text = locator.innerText();
            LOGGER.debug("Got inner text from element {}: {}", selector, text);
            return text;
        } catch (Exception e) {
            LOGGER.error("Failed to get inner text from element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get inner text from element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the inner HTML of the element.
     *
     * @return The inner HTML
     */
    public String getInnerHTML() {
        LOGGER.debug("Getting inner HTML from element: {}", selector);
        
        try {
            String html = locator.innerHTML();
            LOGGER.debug("Got inner HTML from element {}: {}", selector, html);
            return html;
        } catch (Exception e) {
            LOGGER.error("Failed to get inner HTML from element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get inner HTML from element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the value of an attribute.
     *
     * @param name Attribute name
     * @return The attribute value
     */
    public String getAttribute(String name) {
        LOGGER.debug("Getting attribute {} from element: {}", name, selector);
        
        try {
            String value = locator.getAttribute(name);
            LOGGER.debug("Got attribute {} from element {}: {}", name, selector, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get attribute {} from element {}: {}", name, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get attribute from element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the value of a property.
     *
     * @param name Property name
     * @return The property value
     */
    public Object getProperty(String name) {
        LOGGER.debug("Getting property {} from element: {}", name, selector);
        
        try {
            String expression = "element => element." + name;
            Object value = locator.evaluate(expression);
            LOGGER.debug("Got property {} from element {}: {}", name, selector, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get property {} from element {}: {}", name, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get property from element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if the element is visible.
     *
     * @return True if the element is visible
     */
    public boolean isVisible() {
        LOGGER.debug("Checking if element is visible: {}", selector);
        
        try {
            boolean visible = locator.isVisible();
            LOGGER.debug("Element {} is visible: {}", selector, visible);
            return visible;
        } catch (Exception e) {
            LOGGER.error("Failed to check if element {} is visible: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to check if element is visible: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if the element is enabled.
     *
     * @return True if the element is enabled
     */
    public boolean isEnabled() {
        LOGGER.debug("Checking if element is enabled: {}", selector);
        
        try {
            boolean enabled = locator.isEnabled();
            LOGGER.debug("Element {} is enabled: {}", selector, enabled);
            return enabled;
        } catch (Exception e) {
            LOGGER.error("Failed to check if element {} is enabled: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to check if element is enabled: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if the element is checked (for checkboxes and radio buttons).
     *
     * @return True if the element is checked
     */
    public boolean isChecked() {
        LOGGER.debug("Checking if element is checked: {}", selector);
        
        try {
            boolean checked = locator.isChecked();
            LOGGER.debug("Element {} is checked: {}", selector, checked);
            return checked;
        } catch (Exception e) {
            LOGGER.error("Failed to check if element {} is checked: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to check if element is checked: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks or unchecks the element (for checkboxes and radio buttons).
     *
     * @param checked Whether to check or uncheck
     * @return This CSElement instance for method chaining
     */
    public CSElement setChecked(boolean checked) {
        LOGGER.info("Setting element {} checked state to: {}", selector, checked);
        
        try {
            locator.setChecked(checked, new Locator.SetCheckedOptions().setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to set checked state for element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to set checked state for element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks or unchecks the element (for checkboxes and radio buttons) with custom options.
     *
     * @param checked Whether to check or uncheck
     * @param options Set checked options
     * @return This CSElement instance for method chaining
     */
    public CSElement setChecked(boolean checked, Locator.SetCheckedOptions options) {
        LOGGER.info("Setting element {} checked state to {} with options: {}", selector, checked, options);
        
        try {
            locator.setChecked(checked, options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to set checked state for element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to set checked state for element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Scrolls the element into view.
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement scrollIntoView() {
        LOGGER.info("Scrolling element into view: {}", selector);
        
        try {
            locator.scrollIntoViewIfNeeded();
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to scroll element {} into view: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to scroll element into view: " + e.getMessage(), e);
        }
    }
    
    /**
     * Takes a screenshot of the element.
     *
     * @param fileName Base file name (without extension)
     * @return Path to the saved screenshot
     */
    public String takeScreenshot(String fileName) {
        LOGGER.info("Taking screenshot of element {}: {}", selector, fileName);
        
        try {
            // Generate screenshot path
            String timestamp = String.valueOf(System.currentTimeMillis());
            String screenshotFile = fileName + "_" + timestamp + ".png";
            Path fullPath = Paths.get(System.getProperty("user.dir"), "target", "screenshots", screenshotFile);
            
            // Take screenshot
            locator.screenshot(new Locator.ScreenshotOptions().setPath(fullPath));
            
            LOGGER.info("Element screenshot saved to: {}", fullPath);
            return fullPath.toString();
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshot of element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to take screenshot of element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Takes a screenshot of the element with custom options.
     *
     * @param fileName Base file name (without extension)
     * @param options Screenshot options
     * @return Path to the saved screenshot
     */
    public String takeScreenshot(String fileName, Locator.ScreenshotOptions options) {
        LOGGER.info("Taking screenshot of element {} with options: {}", selector, options);
        
        try {
            // Generate screenshot path
            String timestamp = String.valueOf(System.currentTimeMillis());
            String screenshotFile = fileName + "_" + timestamp + ".png";
            Path fullPath = Paths.get(System.getProperty("user.dir"), "target", "screenshots", screenshotFile);
            
            // Set path in options
            options.setPath(fullPath);
            
            // Take screenshot
            locator.screenshot(options);
            
            LOGGER.info("Element screenshot saved to: {}", fullPath);
            return fullPath.toString();
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshot of element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to take screenshot of element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the count of elements matching the selector.
     *
     * @return The number of matching elements
     */
    public int count() {
        LOGGER.debug("Counting elements matching selector: {}", selector);
        
        try {
            int count = locator.count();
            LOGGER.debug("Found {} elements matching selector: {}", count, selector);
            return count;
        } catch (Exception e) {
            LOGGER.error("Failed to count elements matching selector {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to count elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets a list of elements matching the selector.
     *
     * @return List of CSElement instances
     */
    public List<CSElement> all() {
        LOGGER.debug("Getting all elements matching selector: {}", selector);
        
        try {
            int count = locator.count();
            List<CSElement> elements = new java.util.ArrayList<>(count);
            
            for (int i = 0; i < count; i++) {
                Locator childLocator = locator.nth(i);
                String childSelector = selector + ":nth-child(" + (i + 1) + ")";
                elements.add(new CSElement(page, childLocator, childSelector, pageManager));
            }
            
            LOGGER.debug("Found {} elements matching selector: {}", count, selector);
            return elements;
        } catch (Exception e) {
            LOGGER.error("Failed to get all elements matching selector {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get all elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the first element matching the selector.
     *
     * @return The first CSElement
     */
    public CSElement first() {
        LOGGER.debug("Getting first element matching selector: {}", selector);
        
        try {
            Locator firstLocator = locator.first();
            String firstSelector = selector + ":first-child";
            return new CSElement(page, firstLocator, firstSelector, pageManager);
        } catch (Exception e) {
            LOGGER.error("Failed to get first element matching selector {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get first element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the last element matching the selector.
     *
     * @return The last CSElement
     */
    public CSElement last() {
        LOGGER.debug("Getting last element matching selector: {}", selector);
        
        try {
            Locator lastLocator = locator.last();
            String lastSelector = selector + ":last-child";
            return new CSElement(page, lastLocator, lastSelector, pageManager);
        } catch (Exception e) {
            LOGGER.error("Failed to get last element matching selector {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get last element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets an element at the specified index.
     *
     * @param index Zero-based index
     * @return The CSElement at the specified index
     */
    public CSElement nth(int index) {
        LOGGER.debug("Getting element at index {} matching selector: {}", index, selector);
        
        try {
            Locator nthLocator = locator.nth(index);
            String nthSelector = selector + ":nth-child(" + (index + 1) + ")";
            return new CSElement(page, nthLocator, nthSelector, pageManager);
        } catch (Exception e) {
            LOGGER.error("Failed to get element at index {} matching selector {}: {}", index, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get element at index: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets a child element matching the specified selector.
     *
     * @param childSelector Selector for the child element
     * @return The child CSElement
     */
    public CSElement locator(String childSelector) {
        LOGGER.debug("Getting child element with selector {} from parent {}", childSelector, selector);
        
        try {
            Locator childLocator = locator.locator(childSelector);
            String fullSelector = selector + " " + childSelector;
            return new CSElement(page, childLocator, fullSelector, pageManager);
        } catch (Exception e) {
            LOGGER.error("Failed to get child element with selector {} from parent {}: {}", 
                    childSelector, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get child element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for the element to be visible.
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement waitForVisible() {
        LOGGER.info("Waiting for element to be visible: {}", selector);
        
        try {
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to wait for element {} to be visible: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to wait for element to be visible: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for the element to be hidden.
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement waitForHidden() {
        LOGGER.info("Waiting for element to be hidden: {}", selector);
        
        try {
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.HIDDEN)
                    .setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to wait for element {} to be hidden: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to wait for element to be hidden: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for the element to be enabled.
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement waitForEnabled() {
        LOGGER.info("Waiting for element to be enabled: {}", selector);
        
        try {
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.ENABLED)
                    .setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to wait for element {} to be enabled: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to wait for element to be enabled: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for the element to be stable (not moving).
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement waitForStable() {
        LOGGER.info("Waiting for element to be stable: {}", selector);
        
        try {
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.STABLE)
                    .setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to wait for element {} to be stable: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to wait for element to be stable: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for the element to match the specified state.
     *
     * @param state Desired state
     * @return This CSElement instance for method chaining
     */
    public CSElement waitFor(WaitForSelectorState state) {
        LOGGER.info("Waiting for element {} to be in state: {}", selector, state);
        
        try {
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(state)
                    .setTimeout(defaultTimeout));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to wait for element {} to be in state {}: {}", selector, state, e.getMessage(), e);
            throw new RuntimeException("Failed to wait for element state: " + e.getMessage(), e);
        }
    }
    
    /**
     * Waits for the element to match the specified state with custom options.
     *
     * @param state Desired state
     * @param options Wait for options
     * @return This CSElement instance for method chaining
     */
    public CSElement waitFor(WaitForSelectorState state, Locator.WaitForOptions options) {
        LOGGER.info("Waiting for element {} to be in state {} with options: {}", selector, state, options);
        
        try {
            options.setState(state);
            locator.waitFor(options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to wait for element {} to be in state {}: {}", selector, state, e.getMessage(), e);
            throw new RuntimeException("Failed to wait for element state: " + e.getMessage(), e);
        }
    }
    
    /**
     * Executes JavaScript on the element.
     *
     * @param script JavaScript code to execute
     * @param args Arguments to pass to the script
     * @return Result of the script evaluation
     */
    public Object evaluate(String script, Object... args) {
        LOGGER.debug("Evaluating JavaScript on element {}: {}", selector, script);
        
        try {
            Object result = locator.evaluate(script, args);
            LOGGER.debug("JavaScript evaluation on element {} completed", selector);
            return result;
        } catch (Exception e) {
            LOGGER.error("Failed to evaluate JavaScript on element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to evaluate JavaScript on element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Dispatches an event on the element.
     *
     * @param type Event type
     * @return This CSElement instance for method chaining
     */
    public CSElement dispatchEvent(String type) {
        LOGGER.info("Dispatching event {} on element: {}", type, selector);
        
        try {
            locator.dispatchEvent(type);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to dispatch event {} on element {}: {}", type, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to dispatch event on element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Dispatches an event on the element with event init.
     *
     * @param type Event type
     * @param eventInit Event initialization data
     * @return This CSElement instance for method chaining
     */
    public CSElement dispatchEvent(String type, Object eventInit) {
        LOGGER.info("Dispatching event {} with init data on element: {}", type, selector);
        
        try {
            locator.dispatchEvent(type, eventInit);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to dispatch event {} with init data on element {}: {}", 
                    type, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to dispatch event on element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Focuses the element.
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement focus() {
        LOGGER.info("Focusing element: {}", selector);
        
        try {
            locator.focus();
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to focus element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to focus element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the bounding box of the element.
     *
     * @return The element's bounding box
     */
    public ElementHandle.BoundingBox getBoundingBox() {
        LOGGER.debug("Getting bounding box of element: {}", selector);
        
        try {
            ElementHandle.BoundingBox boundingBox = locator.boundingBox();
            LOGGER.debug("Got bounding box of element {}: {}", selector, boundingBox);
            return boundingBox;
        } catch (Exception e) {
            LOGGER.error("Failed to get bounding box of element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get bounding box of element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects an option from a select element by value.
     *
     * @param value Option value
     * @return Selected option values
     */
    public List<String> selectOption(String value) {
        LOGGER.info("Selecting option with value {} from element: {}", value, selector);
        
        try {
            List<String> values = locator.selectOption(value);
            LOGGER.info("Selected option with value {} from element {}", value, selector);
            return values;
        } catch (Exception e) {
            LOGGER.error("Failed to select option with value {} from element {}: {}", 
                    value, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to select option: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects multiple options from a select element by values.
     *
     * @param values Option values
     * @return Selected option values
     */
    public List<String> selectOption(String[] values) {
        LOGGER.info("Selecting options with values {} from element: {}", values, selector);
        
        try {
            List<String> selectedValues = locator.selectOption(values);
            LOGGER.info("Selected options with values {} from element {}", values, selector);
            return selectedValues;
        } catch (Exception e) {
            LOGGER.error("Failed to select options with values {} from element {}: {}", 
                    values, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to select options: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects an option from a select element by label.
     *
     * @param label Option label
     * @return Selected option values
     */
    public List<String> selectOptionByLabel(String label) {
        LOGGER.info("Selecting option with label {} from element: {}", label, selector);
        
        try {
            SelectOption option = new SelectOption();
            option.setLabel(label);
            List<String> values = locator.selectOption(new SelectOption[] { option });
            LOGGER.info("Selected option with label {} from element {}", label, selector);
            return values;
        } catch (Exception e) {
            LOGGER.error("Failed to select option with label {} from element {}: {}", 
                    label, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to select option by label: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects an option from a select element by index.
     *
     * @param index Option index
     * @return Selected option values
     */
    public List<String> selectOptionByIndex(int index) {
        LOGGER.info("Selecting option with index {} from element: {}", index, selector);
        
        try {
            SelectOption option = new SelectOption();
            option.setIndex(index);
            List<String> values = locator.selectOption(new SelectOption[] { option });
            LOGGER.info("Selected option with index {} from element {}", index, selector);
            return values;
        } catch (Exception e) {
            LOGGER.error("Failed to select option with index {} from element {}: {}", 
                    index, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to select option by index: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clears the input or textarea element.
     *
     * @return This CSElement instance for method chaining
     */
    public CSElement clear() {
        LOGGER.info("Clearing element: {}", selector);
        
        try {
            locator.clear();
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to clear element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to clear element: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the value of the input or textarea element.
     *
     * @return The input value
     */
    public String getValue() {
        LOGGER.debug("Getting value from element: {}", selector);
        
        try {
            String value = locator.inputValue();
            LOGGER.debug("Got value from element {}: {}", selector, value);
            return value;
        } catch (Exception e) {
            LOGGER.error("Failed to get value from element {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get value from element: " + e.getMessage(), e);
        }
    }
}



package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.browser.CSPageManager;
import com.microsoft.playwright.*;
import com.microsoft.playwright.options.*;

import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Enhanced wrapper for a list of Playwright elements.
 * Provides collection-based operations for element groups.
 */
public class CSElementList implements Iterable<CSElement> {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSElementList.class);
    
    private final Page page;
    private final Locator locator;
    private final String selector;
    private final CSPageManager pageManager;
    private final List<CSElement> elements;
    
    /**
     * Creates a new CSElementList with the specified page and selector.
     *
     * @param page Page that contains the elements
     * @param selector Selector to locate the elements
     * @param pageManager Page manager
     */
    public CSElementList(Page page, String selector, CSPageManager pageManager) {
        this.page = page;
        this.selector = selector;
        this.locator = page.locator(selector);
        this.pageManager = pageManager;
        this.elements = loadElements();
    }
    
    /**
     * Creates a new CSElementList with the specified page and locator.
     *
     * @param page Page that contains the elements
     * @param locator Locator for the elements
     * @param selector Selector string used to create the locator
     * @param pageManager Page manager
     */
    public CSElementList(Page page, Locator locator, String selector, CSPageManager pageManager) {
        this.page = page;
        this.locator = locator;
        this.selector = selector;
        this.pageManager = pageManager;
        this.elements = loadElements();
    }
    
    /**
     * Creates a new CSElementList with the specified elements.
     *
     * @param page Page that contains the elements
     * @param elements List of CSElement instances
     * @param selector Selector description (for logging)
     * @param pageManager Page manager
     */
    public CSElementList(Page page, List<CSElement> elements, String selector, CSPageManager pageManager) {
        this.page = page;
        this.locator = null;
        this.selector = selector;
        this.pageManager = pageManager;
        this.elements = new ArrayList<>(elements);
    }
    
    /**
     * Loads all elements matching the selector into the elements list.
     *
     * @return List of CSElement instances
     */
    private List<CSElement> loadElements() {
        LOGGER.debug("Loading elements for selector: {}", selector);
        
        try {
            if (locator == null) {
                return Collections.emptyList();
            }
            
            int count = locator.count();
            List<CSElement> result = new ArrayList<>(count);
            
            for (int i = 0; i < count; i++) {
                Locator childLocator = locator.nth(i);
                String childSelector = selector + ":nth-child(" + (i + 1) + ")";
                result.add(new CSElement(page, childLocator, childSelector, pageManager));
            }
            
            LOGGER.debug("Loaded {} elements for selector: {}", count, selector);
            return result;
        } catch (Exception e) {
            LOGGER.error("Failed to load elements for selector {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to load elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the number of elements in the list.
     *
     * @return The number of elements
     */
    public int size() {
        return elements.size();
    }
    
    /**
     * Checks if the list is empty.
     *
     * @return True if the list contains no elements
     */
    public boolean isEmpty() {
        return elements.isEmpty();
    }
    
    /**
     * Gets the element at the specified index.
     *
     * @param index Zero-based index
     * @return The CSElement at the specified index
     * @throws IndexOutOfBoundsException if the index is out of range
     */
    public CSElement get(int index) {
        if (index < 0 || index >=elements.size()) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + elements.size());
        }
        return elements.get(index);
    }
    
    /**
     * Gets the first element in the list.
     *
     * @return The first CSElement
     * @throws NoSuchElementException if the list is empty
     */
    public CSElement first() {
        if (elements.isEmpty()) {
            throw new NoSuchElementException("Element list is empty");
        }
        return elements.get(0);
    }
    
    /**
     * Gets the last element in the list.
     *
     * @return The last CSElement
     * @throws NoSuchElementException if the list is empty
     */
    public CSElement last() {
        if (elements.isEmpty()) {
            throw new NoSuchElementException("Element list is empty");
        }
        return elements.get(elements.size() - 1);
    }
    
    /**
     * Clicks on all elements in the list.
     *
     * @return This CSElementList instance for method chaining
     */
    public CSElementList clickAll() {
        LOGGER.info("Clicking on all elements: {}", selector);
        
        try {
            for (int i = 0; i < elements.size(); i++) {
                LOGGER.debug("Clicking on element {} of {}: {}", i + 1, elements.size(), selector);
                elements.get(i).click();
            }
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to click on all elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to click on all elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clicks on an element at the specified index.
     *
     * @param index Zero-based index
     * @return This CSElementList instance for method chaining
     * @throws IndexOutOfBoundsException if the index is out of range
     */
    public CSElementList clickAt(int index) {
        LOGGER.info("Clicking on element at index {}: {}", index, selector);
        
        if (index < 0 || index >= elements.size()) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + elements.size());
        }
        
        try {
            elements.get(index).click();
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to click on element at index {}: {}", index, e.getMessage(), e);
            throw new RuntimeException("Failed to click on element at index: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the text content of all elements as a list.
     *
     * @return List of text content for each element
     */
    public List<String> getAllTexts() {
        LOGGER.debug("Getting text from all elements: {}", selector);
        
        try {
            List<String> texts = new ArrayList<>(elements.size());
            for (CSElement element : elements) {
                texts.add(element.getText());
            }
            return texts;
        } catch (Exception e) {
            LOGGER.error("Failed to get text from all elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get text from all elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the inner text of all elements as a list.
     *
     * @return List of inner text for each element
     */
    public List<String> getAllInnerTexts() {
        LOGGER.debug("Getting inner text from all elements: {}", selector);
        
        try {
            List<String> texts = new ArrayList<>(elements.size());
            for (CSElement element : elements) {
                texts.add(element.getInnerText());
            }
            return texts;
        } catch (Exception e) {
            LOGGER.error("Failed to get inner text from all elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get inner text from all elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the value of a specific attribute from all elements as a list.
     *
     * @param attributeName Name of the attribute
     * @return List of attribute values for each element
     */
    public List<String> getAllAttributes(String attributeName) {
        LOGGER.debug("Getting attribute {} from all elements: {}", attributeName, selector);
        
        try {
            List<String> attributes = new ArrayList<>(elements.size());
            for (CSElement element : elements) {
                attributes.add(element.getAttribute(attributeName));
            }
            return attributes;
        } catch (Exception e) {
            LOGGER.error("Failed to get attribute {} from all elements {}: {}", 
                    attributeName, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to get attribute from all elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets all elements that satisfy the given predicate.
     *
     * @param predicate Predicate to test each element
     * @return A new CSElementList containing only the elements that satisfy the predicate
     */
    public CSElementList filter(Predicate<CSElement> predicate) {
        LOGGER.debug("Filtering elements: {}", selector);
        
        try {
            List<CSElement> filteredElements = elements.stream()
                    .filter(predicate)
                    .collect(Collectors.toList());
            
            LOGGER.debug("Filtered elements from {} to {}: {}", 
                    elements.size(), filteredElements.size(), selector);
            
            return new CSElementList(page, filteredElements, selector + " (filtered)", pageManager);
        } catch (Exception e) {
            LOGGER.error("Failed to filter elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to filter elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds the first element that satisfies the given predicate.
     *
     * @param predicate Predicate to test each element
     * @return The first element that satisfies the predicate, or null if none found
     */
    public CSElement find(Predicate<CSElement> predicate) {
        LOGGER.debug("Finding element matching predicate: {}", selector);
        
        try {
            return elements.stream()
                    .filter(predicate)
                    .findFirst()
                    .orElse(null);
        } catch (Exception e) {
            LOGGER.error("Failed to find element matching predicate {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to find element matching predicate: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if at least one element satisfies the given predicate.
     *
     * @param predicate Predicate to test each element
     * @return True if at least one element satisfies the predicate
     */
    public boolean anyMatch(Predicate<CSElement> predicate) {
        LOGGER.debug("Checking if any element matches predicate: {}", selector);
        
        try {
            return elements.stream().anyMatch(predicate);
        } catch (Exception e) {
            LOGGER.error("Failed to check if any element matches predicate {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to check if any element matches predicate: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if all elements satisfy the given predicate.
     *
     * @param predicate Predicate to test each element
     * @return True if all elements satisfy the predicate
     */
    public boolean allMatch(Predicate<CSElement> predicate) {
        LOGGER.debug("Checking if all elements match predicate: {}", selector);
        
        try {
            return elements.stream().allMatch(predicate);
        } catch (Exception e) {
            LOGGER.error("Failed to check if all elements match predicate {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to check if all elements match predicate: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if all elements are visible.
     *
     * @return True if all elements are visible
     */
    public boolean allVisible() {
        LOGGER.debug("Checking if all elements are visible: {}", selector);
        
        try {
            return allMatch(CSElement::isVisible);
        } catch (Exception e) {
            LOGGER.error("Failed to check if all elements are visible {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to check if all elements are visible: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if at least one element is visible.
     *
     * @return True if at least one element is visible
     */
    public boolean anyVisible() {
        LOGGER.debug("Checking if any element is visible: {}", selector);
        
        try {
            return anyMatch(CSElement::isVisible);
        } catch (Exception e) {
            LOGGER.error("Failed to check if any element is visible {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to check if any element is visible: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if all elements are enabled.
     *
     * @return True if all elements are enabled
     */
    public boolean allEnabled() {
        LOGGER.debug("Checking if all elements are enabled: {}", selector);
        
        try {
            return allMatch(CSElement::isEnabled);
        } catch (Exception e) {
            LOGGER.error("Failed to check if all elements are enabled {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to check if all elements are enabled: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if at least one element is enabled.
     *
     * @return True if at least one element is enabled
     */
    public boolean anyEnabled() {
        LOGGER.debug("Checking if any element is enabled: {}", selector);
        
        try {
            return anyMatch(CSElement::isEnabled);
        } catch (Exception e) {
            LOGGER.error("Failed to check if any element is enabled {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to check if any element is enabled: " + e.getMessage(), e);
        }
    }
    
    /**
     * Performs an action on each element in the list.
     *
     * @param action Action to perform on each element
     * @return This CSElementList instance for method chaining
     */
    public CSElementList forEach(Consumer<CSElement> action) {
        LOGGER.debug("Executing action on each element: {}", selector);
        
        try {
            for (CSElement element : elements) {
                action.accept(element);
            }
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to execute action on elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to execute action on elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Maps each element to a value using the provided function.
     *
     * @param <R> The type of the resulting values
     * @param mapper Function to apply to each element
     * @return List of the resulting values
     */
    public <R> List<R> map(Function<CSElement, R> mapper) {
        LOGGER.debug("Mapping elements to values: {}", selector);
        
        try {
            return elements.stream()
                    .map(mapper)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            LOGGER.error("Failed to map elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to map elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Hovers over all elements in sequence.
     *
     * @return This CSElementList instance for method chaining
     */
    public CSElementList hoverAll() {
        LOGGER.info("Hovering over all elements: {}", selector);
        
        try {
            for (int i = 0; i < elements.size(); i++) {
                LOGGER.debug("Hovering over element {} of {}: {}", i + 1, elements.size(), selector);
                elements.get(i).hover();
            }
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to hover over all elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to hover over all elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Hovers over an element at the specified index.
     *
     * @param index Zero-based index
     * @return This CSElementList instance for method chaining
     * @throws IndexOutOfBoundsException if the index is out of range
     */
    public CSElementList hoverAt(int index) {
        LOGGER.info("Hovering over element at index {}: {}", index, selector);
        
        if (index < 0 || index >= elements.size()) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + elements.size());
        }
        
        try {
            elements.get(index).hover();
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to hover over element at index {}: {}", index, e.getMessage(), e);
            throw new RuntimeException("Failed to hover over element at index: " + e.getMessage(), e);
        }
    }
    
    /**
     * Sets checked state for all checkbox or radio elements.
     *
     * @param checked Whether to check or uncheck
     * @return This CSElementList instance for method chaining
     */
    public CSElementList setCheckedAll(boolean checked) {
        LOGGER.info("Setting checked state to {} for all elements: {}", checked, selector);
        
        try {
            for (int i = 0; i < elements.size(); i++) {
                LOGGER.debug("Setting checked state for element {} of {}: {}", i + 1, elements.size(), selector);
                elements.get(i).setChecked(checked);
            }
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to set checked state for all elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to set checked state for all elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Takes a screenshot of all elements and returns the paths.
     *
     * @param baseFileName Base file name (without extension)
     * @return List of paths to the saved screenshots
     */
    public List<String> takeScreenshotAll(String baseFileName) {
        LOGGER.info("Taking screenshots of all elements: {}", selector);
        
        try {
            List<String> screenshotPaths = new ArrayList<>(elements.size());
            for (int i = 0; i < elements.size(); i++) {
                String fileName = baseFileName + "_" + i;
                String path = elements.get(i).takeScreenshot(fileName);
                screenshotPaths.add(path);
            }
            return screenshotPaths;
        } catch (Exception e) {
            LOGGER.error("Failed to take screenshots of all elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to take screenshots of all elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets all elements as a standard Java List.
     *
     * @return List of CSElement instances
     */
    public List<CSElement> asList() {
        return new ArrayList<>(elements);
    }
    
    /**
     * Returns an iterator over the elements in this list.
     *
     * @return An iterator over the elements
     */
    @Override
    public Iterator<CSElement> iterator() {
        return elements.iterator();
    }
    
    /**
     * Finds elements that contain the specified text.
     *
     * @param text Text to search for
     * @return A new CSElementList containing only the elements that contain the text
     */
    public CSElementList withText(String text) {
        LOGGER.debug("Finding elements containing text '{}': {}", text, selector);
        
        try {
            List<CSElement> matchingElements = elements.stream()
                    .filter(element -> {
                        String elementText = element.getText();
                        return elementText != null && elementText.contains(text);
                    })
                    .collect(Collectors.toList());
            
            LOGGER.debug("Found {} elements containing text '{}': {}", 
                    matchingElements.size(), text, selector);
            
            return new CSElementList(page, matchingElements, 
                    selector + " (withText: '" + text + "')", pageManager);
        } catch (Exception e) {
            LOGGER.error("Failed to find elements containing text '{}' {}: {}", 
                    text, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to find elements containing text: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds elements that have the specified attribute value.
     *
     * @param attributeName Name of the attribute
     * @param attributeValue Expected attribute value
     * @return A new CSElementList containing only the elements with the specified attribute value
     */
    public CSElementList withAttribute(String attributeName, String attributeValue) {
        LOGGER.debug("Finding elements with attribute '{}={}': {}", attributeName, attributeValue, selector);
        
        try {
            List<CSElement> matchingElements = elements.stream()
                    .filter(element -> {
                        String value = element.getAttribute(attributeName);
                        return value != null && value.equals(attributeValue);
                    })
                    .collect(Collectors.toList());
            
            LOGGER.debug("Found {} elements with attribute '{}={}': {}", 
                    matchingElements.size(), attributeName, attributeValue, selector);
            
            return new CSElementList(page, matchingElements, 
                    selector + " (withAttribute: '" + attributeName + "=" + attributeValue + "')", 
                    pageManager);
        } catch (Exception e) {
            LOGGER.error("Failed to find elements with attribute '{}={}' {}: {}", 
                    attributeName, attributeValue, selector, e.getMessage(), e);
            throw new RuntimeException("Failed to find elements with attribute: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds elements that are visible.
     *
     * @return A new CSElementList containing only the visible elements
     */
    public CSElementList visible() {
        LOGGER.debug("Finding visible elements: {}", selector);
        
        try {
            List<CSElement> visibleElements = elements.stream()
                    .filter(CSElement::isVisible)
                    .collect(Collectors.toList());
            
            LOGGER.debug("Found {} visible elements: {}", visibleElements.size(), selector);
            
            return new CSElementList(page, visibleElements, 
                    selector + " (visible)", pageManager);
        } catch (Exception e) {
            LOGGER.error("Failed to find visible elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to find visible elements: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds elements that are enabled.
     *
     * @return A new CSElementList containing only the enabled elements
     */
    public CSElementList enabled() {
        LOGGER.debug("Finding enabled elements: {}", selector);
        
        try {
            List<CSElement> enabledElements = elements.stream()
                    .filter(CSElement::isEnabled)
                    .collect(Collectors.toList());
            
            LOGGER.debug("Found {} enabled elements: {}", enabledElements.size(), selector);
            
            return new CSElementList(page, enabledElements, 
                    selector + " (enabled)", pageManager);
        } catch (Exception e) {
            LOGGER.error("Failed to find enabled elements {}: {}", selector, e.getMessage(), e);
            throw new RuntimeException("Failed to find enabled elements: " + e.getMessage(), e);
        }
    }
}


package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.browser.CSPageManager;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.SelectOption;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Enhanced wrapper for a Playwright select element.
 * Provides additional functionality for interacting with select dropdowns.
 */
public class CSSelect extends CSElement {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSSelect.class);
    
    /**
     * Creates a new CSSelect with the specified page and selector.
     *
     * @param page Page that contains the select element
     * @param selector Selector to locate the select element
     * @param pageManager Page manager
     */
    public CSSelect(Page page, String selector, CSPageManager pageManager) {
        super(page, selector, pageManager);
    }
    
    /**
     * Creates a new CSSelect with the specified page and Locator.
     *
     * @param page Page that contains the select element
     * @param locator Locator for the select element
     * @param selector Selector string used to create the locator
     * @param pageManager Page manager
     */
    public CSSelect(Page page, Locator locator, String selector, CSPageManager pageManager) {
        super(page, locator, selector, pageManager);
    }
    
    /**
     * Selects an option by its value.
     *
     * @param value Option value
     * @return This CSSelect instance for method chaining
     */
    public CSSelect selectByValue(String value) {
        LOGGER.info("Selecting option with value '{}' from select: {}", value, getSelector());
        
        try {
            getLocator().selectOption(value);
            LOGGER.info("Selected option with value '{}'", value);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to select option with value '{}' from {}: {}", 
                    value, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to select option by value: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects multiple options by their values.
     *
     * @param values Option values
     * @return This CSSelect instance for method chaining
     */
    public CSSelect selectByValues(String... values) {
        LOGGER.info("Selecting options with values {} from select: {}", Arrays.toString(values), getSelector());
        
        try {
            getLocator().selectOption(values);
            LOGGER.info("Selected options with values {}", Arrays.toString(values));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to select options with values {} from {}: {}", 
                    Arrays.toString(values), getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to select options by values: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects an option by its visible text/label.
     *
     * @param label Option label
     * @return This CSSelect instance for method chaining
     */
    public CSSelect selectByLabel(String label) {
        LOGGER.info("Selecting option with label '{}' from select: {}", label, getSelector());
        
        try {
            SelectOption option = new SelectOption();
            option.setLabel(label);
            getLocator().selectOption(new SelectOption[] { option });
            LOGGER.info("Selected option with label '{}'", label);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to select option with label '{}' from {}: {}", 
                    label, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to select option by label: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects multiple options by their visible text/labels.
     *
     * @param labels Option labels
     * @return This CSSelect instance for method chaining
     */
    public CSSelect selectByLabels(String... labels) {
        LOGGER.info("Selecting options with labels {} from select: {}", Arrays.toString(labels), getSelector());
        
        try {
            SelectOption[] options = new SelectOption[labels.length];
            for (int i = 0; i < labels.length; i++) {
                options[i] = new SelectOption();
                options[i].setLabel(labels[i]);
            }
            getLocator().selectOption(options);
            LOGGER.info("Selected options with labels {}", Arrays.toString(labels));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to select options with labels {} from {}: {}", 
                    Arrays.toString(labels), getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to select options by labels: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects an option by its index.
     *
     * @param index Zero-based index of the option
     * @return This CSSelect instance for method chaining
     */
    public CSSelect selectByIndex(int index) {
        LOGGER.info("Selecting option at index {} from select: {}", index, getSelector());
        
        try {
            SelectOption option = new SelectOption();
            option.setIndex(index);
            getLocator().selectOption(new SelectOption[] { option });
            LOGGER.info("Selected option at index {}", index);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to select option at index {} from {}: {}", 
                    index, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to select option by index: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects multiple options by their indices.
     *
     * @param indices Zero-based indices of the options
     * @return This CSSelect instance for method chaining
     */
    public CSSelect selectByIndices(int... indices) {
        LOGGER.info("Selecting options at indices {} from select: {}", Arrays.toString(indices), getSelector());
        
        try {
            SelectOption[] options = new SelectOption[indices.length];
            for (int i = 0; i < indices.length; i++) {
                options[i] = new SelectOption();
                options[i].setIndex(indices[i]);
            }
            getLocator().selectOption(options);
            LOGGER.info("Selected options at indices {}", Arrays.toString(indices));
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to select options at indices {} from {}: {}", 
                    Arrays.toString(indices), getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to select options by indices: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets all options as elements.
     *
     * @return List of option elements
     */
    public CSElementList getAllOptions() {
        LOGGER.debug("Getting all options from select: {}", getSelector());
        
        try {
            Locator optionsLocator = getLocator().locator("option");
            String optionsSelector = getSelector() + " > option";
            return new CSElementList(getLocator().page(), optionsLocator, optionsSelector, null);
        } catch (Exception e) {
            LOGGER.error("Failed to get all options from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get all options: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets all option values.
     *
     * @return List of option values
     */
    public List<String> getAllValues() {
        LOGGER.debug("Getting all option values from select: {}", getSelector());
        
        try {
            CSElementList options = getAllOptions();
            return options.map(option -> option.getAttribute("value"));
        } catch (Exception e) {
            LOGGER.error("Failed to get all option values from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get all option values: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets all option labels.
     *
     * @return List of option labels
     */
    public List<String> getAllLabels() {
        LOGGER.debug("Getting all option labels from select: {}", getSelector());
        
        try {
            CSElementList options = getAllOptions();
            return options.map(CSElement::getText);
        } catch (Exception e) {
            LOGGER.error("Failed to get all option labels from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get all option labels: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the currently selected options as elements.
     *
     * @return List of selected option elements
     */
    public CSElementList getSelectedOptions() {
        LOGGER.debug("Getting selected options from select: {}", getSelector());
        
        try {
            Locator selectedOptionsLocator = getLocator().locator("option:checked");
            String selectedOptionsSelector = getSelector() + " > option:checked";
            return new CSElementList(getLocator().page(), selectedOptionsLocator, selectedOptionsSelector, null);
        } catch (Exception e) {
            LOGGER.error("Failed to get selected options from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get selected options: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the values of the currently selected options.
     *
     * @return List of selected option values
     */
    public List<String> getSelectedValues() {
        LOGGER.debug("Getting selected option values from select: {}", getSelector());
        
        try {
            CSElementList selectedOptions = getSelectedOptions();
            return selectedOptions.map(option -> option.getAttribute("value"));
        } catch (Exception e) {
            LOGGER.error("Failed to get selected option values from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get selected option values: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the labels of the currently selected options.
     *
     * @return List of selected option labels
     */
    public List<String> getSelectedLabels() {
        LOGGER.debug("Getting selected option labels from select: {}", getSelector());
        
        try {
            CSElementList selectedOptions = getSelectedOptions();
            return selectedOptions.map(CSElement::getText);
        } catch (Exception e) {
            LOGGER.error("Failed to get selected option labels from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get selected option labels: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the first selected option's value.
     *
     * @return The value of the first selected option, or null if nothing is selected
     */
    public String getFirstSelectedValue() {
        LOGGER.debug("Getting first selected option value from select: {}", getSelector());
        
        try {
            List<String> selectedValues = getSelectedValues();
            return selectedValues.isEmpty() ? null : selectedValues.get(0);
        } catch (Exception e) {
            LOGGER.error("Failed to get first selected option value from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get first selected option value: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the first selected option's label.
     *
     * @return The label of the first selected option, or null if nothing is selected
     */
    public String getFirstSelectedLabel() {
        LOGGER.debug("Getting first selected option label from select: {}", getSelector());
        
        try {
            List<String> selectedLabels = getSelectedLabels();
            return selectedLabels.isEmpty() ? null : selectedLabels.get(0);
        } catch (Exception e) {
            LOGGER.error("Failed to get first selected option label from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get first selected option label: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if the select element allows multiple selections.
     *
     * @return True if multiple selections are allowed
     */
    public boolean isMultiple() {
        LOGGER.debug("Checking if select allows multiple selections: {}", getSelector());
        
        try {
            String multiple = getAttribute("multiple");
            return multiple != null;
        } catch (Exception e) {
            LOGGER.error("Failed to check if select allows multiple selections {}: {}", 
                    getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to check if select allows multiple selections: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the number of options.
     *
     * @return The number of options
     */
    public int getOptionCount() {
        LOGGER.debug("Getting option count from select: {}", getSelector());
        
        try {
            return getLocator().locator("option").count();
        } catch (Exception e) {
            LOGGER.error("Failed to get option count from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get option count: " + e.getMessage(), e);
        }
    }
    
    /**
     * Deselects all options (for multi-select elements).
     *
     * @return This CSSelect instance for method chaining
     */
    public CSSelect deselectAll() {
        LOGGER.info("Deselecting all options from select: {}", getSelector());
        
        try {
            // Check if it's a multi-select
            if (!isMultiple()) {
                LOGGER.warn("Cannot deselect all options from single-select element: {}", getSelector());
                return this;
            }
            
            // Get all options and deselect them
            CSElementList selectedOptions = getSelectedOptions();
            SelectOption[] emptyArray = new SelectOption[0];
            getLocator().selectOption(emptyArray);
            
            LOGGER.info("Deselected all options from select");
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to deselect all options from {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to deselect all options: " + e.getMessage(), e);
        }
    }
    
    /**
     * Deselects an option by its value (for multi-select elements).
     *
     * @param value Option value to deselect
     * @return This CSSelect instance for method chaining
     */
    public CSSelect deselectByValue(String value) {
        LOGGER.info("Deselecting option with value '{}' from select: {}", value, getSelector());
        
        try {
            // Check if it's a multi-select
            if (!isMultiple()) {
                LOGGER.warn("Cannot deselect option from single-select element: {}", getSelector());
                return this;
            }
            
            // Get currently selected values
            List<String> currentValues = getSelectedValues();
            
            // Remove the specified value
            List<String> newValues = currentValues.stream()
                    .filter(v -> !v.equals(value))
                    .collect(Collectors.toList());
            
            // Select the new set of values
            if (newValues.size() < currentValues.size()) {
                getLocator().selectOption(newValues.toArray(new String[0]));
                LOGGER.info("Deselected option with value '{}'", value);
            } else {
                LOGGER.info("Option with value '{}' was not selected", value);
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to deselect option with value '{}' from {}: {}", 
                    value, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to deselect option by value: " + e.getMessage(), e);
        }
    }
    
    /**
     * Deselects an option by its label (for multi-select elements).
     *
     * @param label Option label to deselect
     * @return This CSSelect instance for method chaining
     */
    public CSSelect deselectByLabel(String label) {
        LOGGER.info("Deselecting option with label '{}' from select: {}", label, getSelector());
        
        try {
            // Check if it's a multi-select
            if (!isMultiple()) {
                LOGGER.warn("Cannot deselect option from single-select element: {}", getSelector());
                return this;
            }
            
            // Find the option by label to get its value
            CSElementList options = getAllOptions();
            String valueToDeselect = null;
            
            for (CSElement option : options) {
                if (label.equals(option.getText())) {
                    valueToDeselect = option.getAttribute("value");
                    break;
                }
            }
            
            if (valueToDeselect == null) {
                LOGGER.info("Option with label '{}' not found", label);
                return this;
            }
            
            // Get currently selected values
            List<String> currentValues = getSelectedValues();
            
            // Remove the specified value
            List<String> newValues = currentValues.stream()
                    .filter(v -> !v.equals(valueToDeselect))
                    .collect(Collectors.toList());
            
            // Select the new set of values
            if (newValues.size() < currentValues.size()) {
                getLocator().selectOption(newValues.toArray(new String[0]));
                LOGGER.info("Deselected option with label '{}'", label);
            } else {
                LOGGER.info("Option with label '{}' was not selected", label);
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to deselect option with label '{}' from {}: {}", 
                    label, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to deselect option by label: " + e.getMessage(), e);
        }
    }
    
    /**
     * Deselects an option by its index (for multi-select elements).
     *
     * @param index Zero-based index of the option to deselect
     * @return This CSSelect instance for method chaining
     */
    public CSSelect deselectByIndex(int index) {
        LOGGER.info("Deselecting option at index {} from select: {}", index, getSelector());
        
        try {
            // Check if it's a multi-select
            if (!isMultiple()) {
                LOGGER.warn("Cannot deselect option from single-select element: {}", getSelector());
                return this;
            }
            
            // Find the option by index to get its value
            CSElementList options = getAllOptions();
            
            if (index < 0 || index >= options.size()) {
                LOGGER.warn("Option index {} out of bounds (0-{})", index, options.size() - 1);
                return this;
            }
            
            String valueToDeselect = options.get(index).getAttribute("value");
            
            // Get currently selected values
            List<String> currentValues = getSelectedValues();
            
            // Remove the specified value
            List<String> newValues = currentValues.stream()
                    .filter(v -> !v.equals(valueToDeselect))
                    .collect(Collectors.toList());
            
            // Select the new set of values
            if (newValues.size() < currentValues.size()) {
                getLocator().selectOption(newValues.toArray(new String[0]));
                LOGGER.info("Deselected option at index {}", index);
            } else {
                LOGGER.info("Option at index {} was not selected", index);
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to deselect option at index {} from {}: {}", 
                    index, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to deselect option by index: " + e.getMessage(), e);
        }
    }
}



package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.browser.CSPageManager;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Enhanced wrapper for HTML table elements.
 * Provides methods for table data extraction and manipulation.
 */
public class CSTable extends CSElement {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSTable.class);
    
    private String rowSelector = "tr";
    private String headerRowSelector = "thead tr";
    private String bodyRowSelector = "tbody tr";
    private String headerCellSelector = "th";
    private String bodyCellSelector = "td";
    private boolean hasHeaderRow = true;
    private boolean cacheData = false;
    
    private List<List<String>> cachedData = null;
    private List<String> cachedHeaders = null;
    
    /**
     * Creates a new CSTable with the specified page and selector.
     *
     * @param page Page that contains the table
     * @param selector Selector to locate the table
     * @param pageManager Page manager
     */
    public CSTable(Page page, String selector, CSPageManager pageManager) {
        super(page, selector, pageManager);
    }
    
    /**
     * Creates a new CSTable with the specified page and Locator.
     *
     * @param page Page that contains the table
     * @param locator Locator for the table
     * @param selector Selector string used to create the locator
     * @param pageManager Page manager
     */
    public CSTable(Page page, Locator locator, String selector, CSPageManager pageManager) {
        super(page, locator, selector, pageManager);
    }
    
    /**
     * Sets the row selector.
     *
     * @param rowSelector CSS selector for rows
     * @return This CSTable instance for method chaining
     */
    public CSTable withRowSelector(String rowSelector) {
        this.rowSelector = rowSelector;
        resetCache();
        return this;
    }
    
    /**
     * Sets the header row selector.
     *
     * @param headerRowSelector CSS selector for header rows
     * @return This CSTable instance for method chaining
     */
    public CSTable withHeaderRowSelector(String headerRowSelector) {
        this.headerRowSelector = headerRowSelector;
        resetCache();
        return this;
    }
    
    /**
     * Sets the body row selector.
     *
     * @param bodyRowSelector CSS selector for body rows
     * @return This CSTable instance for method chaining
     */
    public CSTable withBodyRowSelector(String bodyRowSelector) {
        this.bodyRowSelector = bodyRowSelector;
        resetCache();
        return this;
    }
    
    /**
     * Sets the header cell selector.
     *
     * @param headerCellSelector CSS selector for header cells
     * @return This CSTable instance for method chaining
     */
    public CSTable withHeaderCellSelector(String headerCellSelector) {
        this.headerCellSelector = headerCellSelector;
        resetCache();
        return this;
    }
    
    /**
     * Sets the body cell selector.
     *
     * @param bodyCellSelector CSS selector for body cells
     * @return This CSTable instance for method chaining
     */
    public CSTable withBodyCellSelector(String bodyCellSelector) {
        this.bodyCellSelector = bodyCellSelector;
        resetCache();
        return this;
    }
    
    /**
     * Sets whether the table has a header row.
     *
     * @param hasHeaderRow Whether the table has a header row
     * @return This CSTable instance for method chaining
     */
    public CSTable withHeaderRow(boolean hasHeaderRow) {
        this.hasHeaderRow = hasHeaderRow;
        resetCache();
        return this;
    }
    
    /**
     * Sets whether to cache table data.
     *
     * @param cacheData Whether to cache table data
     * @return This CSTable instance for method chaining
     */
    public CSTable withCacheData(boolean cacheData) {
        this.cacheData = cacheData;
        return this;
    }
    
    /**
     * Resets the cached data.
     */
    private void resetCache() {
        cachedData = null;
        cachedHeaders = null;
    }
    
    /**
     * Gets the number of rows in the table (excluding header row if present).
     *
     * @return The number of data rows
     */
    public int getRowCount() {
        LOGGER.debug("Getting row count from table: {}", getSelector());
        
        try {
            Locator rowsLocator = getLocator().locator(bodyRowSelector);
            int count = rowsLocator.count();
            LOGGER.debug("Table has {} rows", count);
            return count;
        } catch (Exception e) {
            LOGGER.error("Failed to get row count from table {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get row count: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the number of columns in the table.
     *
     * @return The number of columns
     */
    public int getColumnCount() {
        LOGGER.debug("Getting column count from table: {}", getSelector());
        
        try {
            if (hasHeaderRow) {
                Locator headerRowLocator = getLocator().locator(headerRowSelector).first();
                int count = headerRowLocator.locator(headerCellSelector).count();
                LOGGER.debug("Table has {} columns", count);
                return count;
            } else {
                // Use the first data row to determine column count
                Locator firstRowLocator = getLocator().locator(bodyRowSelector).first();
                int count = firstRowLocator.locator(bodyCellSelector).count();
                LOGGER.debug("Table has {} columns", count);
                return count;
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get column count from table {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get column count: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the header cell text.
     *
     * @return List of header text
     */
    public List<String> getHeaderTexts() {
        LOGGER.debug("Getting header texts from table: {}", getSelector());
        
        if (!hasHeaderRow) {
            LOGGER.warn("Table {} is configured with no header row", getSelector());
            return Collections.emptyList();
        }
        
        if (cacheData && cachedHeaders != null) {
            return new ArrayList<>(cachedHeaders);
        }
        
        try {
            Locator headerRowLocator = getLocator().locator(headerRowSelector).first();
            Locator headerCellsLocator = headerRowLocator.locator(headerCellSelector);
            
            int cellCount = headerCellsLocator.count();
            List<String> headers = new ArrayList<>(cellCount);
            
            for (int i = 0; i < cellCount; i++) {
                String text = headerCellsLocator.nth(i).textContent().trim();
                headers.add(text);
            }
            
            if (cacheData) {
                cachedHeaders = new ArrayList<>(headers);
            }
            
            LOGGER.debug("Got {} header texts from table", headers.size());
            return headers;
        } catch (Exception e) {
            LOGGER.error("Failed to get header texts from table {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get header texts: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets a cell by row and column indices.
     *
     * @param rowIndex Zero-based row index (excluding header row)
     * @param columnIndex Zero-based column index
     * @return The cell element
     */
    public CSElement getCell(int rowIndex, int columnIndex) {
        LOGGER.debug("Getting cell at row {}, column {} from table: {}", rowIndex, columnIndex, getSelector());
        
        try {
            Locator rowsLocator = getLocator().locator(bodyRowSelector);
            
            if (rowIndex < 0 || rowIndex >= rowsLocator.count()) {
                throw new IndexOutOfBoundsException("Row index " + rowIndex + " out of bounds for table with " + 
                        rowsLocator.count() + " rows");
            }
            
            Locator rowLocator = rowsLocator.nth(rowIndex);
            Locator cellsLocator = rowLocator.locator(bodyCellSelector);
            
            if (columnIndex < 0 || columnIndex >= cellsLocator.count()) {
                throw new IndexOutOfBoundsException("Column index " + columnIndex + " out of bounds for row with " + 
                        cellsLocator.count() + " cells");
            }
            
            Locator cellLocator = cellsLocator.nth(columnIndex);
            String cellSelector = getSelector() + " " + bodyRowSelector + ":nth-child(" + (rowIndex + 1) + ") " + 
                    bodyCellSelector + ":nth-child(" + (columnIndex + 1) + ")";
            
            return new CSElement(getLocator().page(), cellLocator, cellSelector, null);
        } catch (Exception e) {
            LOGGER.error("Failed to get cell at row {}, column {} from table {}: {}", 
                    rowIndex, columnIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get cell: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets a cell by row index and column name.
     *
     * @param rowIndex Zero-based row index (excluding header row)
     * @param columnName Column name (header text)
     * @return The cell element
     */
    public CSElement getCell(int rowIndex, String columnName) {
        LOGGER.debug("Getting cell at row {}, column '{}' from table: {}", rowIndex, columnName, getSelector());
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot get cell by column name in table without header row");
        }
        
        try {
            List<String> headers = getHeaderTexts();
            int columnIndex = headers.indexOf(columnName);
            
            if (columnIndex == -1) {
                throw new NoSuchElementException("Column with name '" + columnName + "' not found in table");
            }
            
            return getCell(rowIndex, columnIndex);
        } catch (Exception e) {
            LOGGER.error("Failed to get cell at row {}, column '{}' from table {}: {}", 
                    rowIndex, columnName, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get cell by column name: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the text of a cell by row and column indices.
     *
     * @param rowIndex Zero-based row index (excluding header row)
     * @param columnIndex Zero-based column index
     * @return The cell text
     */
    public String getCellText(int rowIndex, int columnIndex) {
        LOGGER.debug("Getting cell text at row {}, column {} from table: {}", rowIndex, columnIndex, getSelector());
        
        try {
            return getCell(rowIndex, columnIndex).getText();
        } catch (Exception e) {
            LOGGER.error("Failed to get cell text at row {}, column {} from table {}: {}", 
                    rowIndex, columnIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get cell text: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the text of a cell by row index and column name.
     *
     * @param rowIndex Zero-based row index (excluding header row)
     * @param columnName Column name (header text)
     * @return The cell text
     */
    public String getCellText(int rowIndex, String columnName) {
        LOGGER.debug("Getting cell text at row {}, column '{}' from table: {}", rowIndex, columnName, getSelector());
        
        try {
            return getCell(rowIndex, columnName).getText();
        } catch (Exception e) {
            LOGGER.error("Failed to get cell text at row {}, column '{}' from table {}: {}", 
                    rowIndex, columnName, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get cell text by column name: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets a row by index.
     *
     * @param rowIndex Zero-based row index (excluding header row)
     * @return List of cell elements in the row
     */
    public List<CSElement> getRow(int rowIndex) {
        LOGGER.debug("Getting row at index {} from table: {}", rowIndex, getSelector());
        
        try {
            Locator rowsLocator = getLocator().locator(bodyRowSelector);
            
            if (rowIndex < 0 || rowIndex >= rowsLocator.count()) {
                throw new IndexOutOfBoundsException("Row index " + rowIndex + " out of bounds for table with " + 
                        rowsLocator.count() + " rows");
            }
            
            Locator rowLocator = rowsLocator.nth(rowIndex);
            Locator cellsLocator = rowLocator.locator(bodyCellSelector);
            
            int cellCount = cellsLocator.count();
            List<CSElement> cells = new ArrayList<>(cellCount);
            
            for (int i = 0; i < cellCount; i++) {
                Locator cellLocator = cellsLocator.nth(i);
                String cellSelector = getSelector() + " " + bodyRowSelector + ":nth-child(" + (rowIndex + 1) + ") " + 
                        bodyCellSelector + ":nth-child(" + (i + 1) + ")";
                cells.add(new CSElement(getLocator().page(), cellLocator, cellSelector, null));
            }
            
            LOGGER.debug("Got row with {} cells", cells.size());
            return cells;
        } catch (Exception e) {
            LOGGER.error("Failed to get row at index {} from table {}: {}", 
                    rowIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get row: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the texts of a row by index.
     *
     * @param rowIndex Zero-based row index (excluding header row)
     * @return List of cell texts in the row
     */
    public List<String> getRowTexts(int rowIndex) {
        LOGGER.debug("Getting row texts at index {} from table: {}", rowIndex, getSelector());
        
        try {
            List<CSElement> cells = getRow(rowIndex);
            return cells.stream()
                    .map(CSElement::getText)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            LOGGER.error("Failed to get row texts at index {} from table {}: {}", 
                    rowIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get row texts: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets a column by index.
     *
     * @param columnIndex Zero-based column index
     * @return List of cell elements in the column (excluding header cell)
     */
    public List<CSElement> getColumn(int columnIndex) {
        LOGGER.debug("Getting column at index {} from table: {}", columnIndex, getSelector());
        
        try {
            Locator rowsLocator = getLocator().locator(bodyRowSelector);
            int rowCount = rowsLocator.count();
            
            if (columnIndex < 0 || columnIndex >= getColumnCount()) {
                throw new IndexOutOfBoundsException("Column index " + columnIndex + " out of bounds for table with " + 
                        getColumnCount() + " columns");
            }
            
            List<CSElement> cells = new ArrayList<>(rowCount);
            
            for (int i = 0; i < rowCount; i++) {
                cells.add(getCell(i, columnIndex));
            }
            
            LOGGER.debug("Got column with {} cells", cells.size());
            return cells;
        } catch (Exception e) {
            LOGGER.error("Failed to get column at index {} from table {}: {}", 
                    columnIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get column: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets a column by name.
     *
     * @param columnName Column name (header text)
     * @return List of cell elements in the column (excluding header cell)
     */
    public List<CSElement> getColumn(String columnName) {
        LOGGER.debug("Getting column with name '{}' from table: {}", columnName, getSelector());
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot get column by name in table without header row");
        }
        
        try {
            List<String> headers = getHeaderTexts();
            int columnIndex = headers.indexOf(columnName);
            
            if (columnIndex == -1) {
                throw new NoSuchElementException("Column with name '" + columnName + "' not found in table");
            }
            
            return getColumn(columnIndex);
        } catch (Exception e) {
            LOGGER.error("Failed to get column with name '{}' from table {}: {}", 
                    columnName, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get column by name: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the texts of a column by index.
     *
     * @param columnIndex Zero-based column index
     * @return List of cell texts in the column (excluding header cell)
     */
    public List<String> getColumnTexts(int columnIndex) {
        LOGGER.debug("Getting column texts at index {} from table: {}", columnIndex, getSelector());
        
        try {
            List<CSElement> cells = getColumn(columnIndex);
            return cells.stream()
                    .map(CSElement::getText)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            LOGGER.error("Failed to get column texts at index {} from table {}: {}", 
                    columnIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get column texts: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the texts of a column by name.
     *
     * @param columnName Column name (header text)
     * @return List of cell texts in the column (excluding header cell)
     */
    public List<String> getColumnTexts(String columnName) {
        LOGGER.debug("Getting column texts with name '{}' from table: {}", columnName, getSelector());
        
        try {
            List<CSElement> cells = getColumn(columnName);
            return cells.stream()
                    .map(CSElement::getText)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            LOGGER.error("Failed to get column texts with name '{}' from table {}: {}", 
                    columnName, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get column texts by name: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets all table data as a list of rows, each containing a list of cell texts.
     *
     * @return List of rows, each containing a list of cell texts
     */
    public List<List<String>> getAllData() {
        LOGGER.debug("Getting all data from table: {}", getSelector());
        
        if (cacheData && cachedData != null) {
            // Return a deep copy of the cached data
            return cachedData.stream()
                    .map(ArrayList::new)
                    .collect(Collectors.toList());
        }
        
        try {
            Locator rowsLocator = getLocator().locator(bodyRowSelector);
            int rowCount = rowsLocator.count();
            
            List<List<String>> data = new ArrayList<>(rowCount);
            
            for (int i = 0; i < rowCount; i++) {
                data.add(getRowTexts(i));
            }
            
            if (cacheData) {
                // Store a deep copy of the data
                cachedData = data.stream()
                        .map(ArrayList::new)
                        .collect(Collectors.toList());
            }
            
            LOGGER.debug("Got table data with {} rows", data.size());
            return data;
        } catch (Exception e) {
            LOGGER.error("Failed to get all data from table {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get all table data: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets all table data as a list of maps, with keys being column names and values being cell texts.
     *
     * @return List of maps, each representing a row
     */
    public List<Map<String, String>> getAllDataAsMaps() {
        LOGGER.debug("Getting all data as maps from table: {}", getSelector());
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot get data as maps in table without header row");
        }
        
        try {
            List<String> headers = getHeaderTexts();
            List<List<String>> data = getAllData();
            
            List<Map<String, String>> maps = new ArrayList<>(data.size());
            
            for (List<String> row : data) {
                Map<String, String> rowMap = new LinkedHashMap<>();
                
                for (int i = 0; i < Math.min(headers.size(), row.size()); i++) {
                    rowMap.put(headers.get(i), row.get(i));
                }
                
                maps.add(rowMap);
            }
            
            LOGGER.debug("Got table data as {} maps", maps.size());
            return maps;
        } catch (Exception e) {
            LOGGER.error("Failed to get all data as maps from table {}: {}", getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get table data as maps: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds rows that match the specified criteria.
     *
     * @param columnName Column name to search in
     * @param value Value to search for
     * @return List of row indices that match the criteria
     */
    public List<Integer> findRows(String columnName, String value) {
        LOGGER.debug("Finding rows where column '{}' equals '{}' in table: {}", columnName, value, getSelector());
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot find rows by column name in table without header row");
        }
        
        try {
            List<String> headers = getHeaderTexts();
            int columnIndex = headers.indexOf(columnName);
            
            if (columnIndex == -1) {
                throw new NoSuchElementException("Column with name '" + columnName + "' not found in table");
            }
            
            return findRows(columnIndex, value);
        } catch (Exception e) {
            LOGGER.error("Failed to find rows where column '{}' equals '{}' in table {}: {}", 
                    columnName, value, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to find rows by column name: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds rows that match the specified criteria.
     *
     * @param columnIndex Column index to search in
     * @param value Value to search for
     * @return List of row indices that match the criteria
     */
    public List<Integer> findRows(int columnIndex, String value) {
        LOGGER.debug("Finding rows where column {} equals '{}' in table: {}", columnIndex, value, getSelector());
        
        try {
            if (columnIndex < 0 || columnIndex >= getColumnCount()) {
                throw new IndexOutOfBoundsException("Column index " + columnIndex + " out of bounds for table with " + 
                        getColumnCount() + " columns");
            }
            
            Locator rowsLocator = getLocator().locator(bodyRowSelector);
            int rowCount = rowsLocator.count();
            
            List<Integer> matchingRows = new ArrayList<>();
            
            for (int i = 0; i < rowCount; i++) {
                String cellText = getCellText(i, columnIndex);
                if (value.equals(cellText)) {
                    matchingRows.add(i);
                }
            }
            
            LOGGER.debug("Found {} matching rows", matchingRows.size());
            return matchingRows;
        } catch (Exception e) {
            LOGGER.error("Failed to find rows where column {} equals '{}' in table {}: {}", 
                    columnIndex, value, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to find rows by column index: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds rows that match the specified criteria with a custom matcher function.
     *
     * @param columnName Column name to search in
     * @param matcher Function that evaluates whether a cell text matches the criteria
     * @return List of row indices that match the criteria
     */
    public List<Integer> findRows(String columnName, Function<String, Boolean> matcher) {
        LOGGER.debug("Finding rows where column '{}' matches custom criteria in table: {}", columnName, getSelector());
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot find rows by column name in table without header row");
        }
        
        try {
            List<String> headers = getHeaderTexts();
            int columnIndex = headers.indexOf(columnName);
            
            if (columnIndex == -1) {
                throw new NoSuchElementException("Column with name '" + columnName + "' not found in table");
            }
            
            return findRows(columnIndex, matcher);
        } catch (Exception e) {
            LOGGER.error("Failed to find rows where column '{}' matches custom criteria in table {}: {}", 
                    columnName, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to find rows by column name with custom matcher: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds rows that match the specified criteria with a custom matcher function.
     *
     * @param columnIndex Column index to search in
     * @param matcher Function that evaluates whether a cell text matches the criteria
     * @return List of row indices that match the criteria
     */
    public List<Integer> findRows(int columnIndex, Function<String, Boolean> matcher) {
        LOGGER.debug("Finding rows where column {} matches custom criteria in table: {}", columnIndex, getSelector());
        
        try {
            if (columnIndex < 0 || columnIndex >= getColumnCount()) {
                throw new IndexOutOfBoundsException("Column index " + columnIndex + " out of bounds for table with " + 
                        getColumnCount() + " columns");
            }
            
            Locator rowsLocator = getLocator().locator(bodyRowSelector);
            int rowCount = rowsLocator.count();
            
            List<Integer> matchingRows = new ArrayList<>();
            
            for (int i = 0; i < rowCount; i++) {
                String cellText = getCellText(i, columnIndex);
                if (matcher.apply(cellText)) {
                    matchingRows.add(i);
                }
            }
            
            LOGGER.debug("Found {} matching rows", matchingRows.size());
            return matchingRows;
        } catch (Exception e) {
            LOGGER.error("Failed to find rows where column {} matches custom criteria in table {}: {}", 
                    columnIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to find rows by column index with custom matcher: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the row as a map for the specified row index.
     *
     * @param rowIndex Zero-based row index (excluding header row)
     * @return Map with column names as keys and cell texts as values
     */
    public Map<String, String> getRowAsMap(int rowIndex) {
        LOGGER.debug("Getting row as map at index {} from table: {}", rowIndex, getSelector());
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot get row as map in table without header row");
        }
        
        try {
            List<String> headers = getHeaderTexts();
            List<String> rowTexts = getRowTexts(rowIndex);
            
            Map<String, String> rowMap = new LinkedHashMap<>();
            
            for (int i = 0; i < Math.min(headers.size(), rowTexts.size()); i++) {
                rowMap.put(headers.get(i), rowTexts.get(i));
            }
            
            LOGGER.debug("Got row as map with {} entries", rowMap.size());
            return rowMap;
        } catch (Exception e) {
            LOGGER.error("Failed to get row as map at index {} from table {}: {}", 
                    rowIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to get row as map: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clicks on a cell by row and column indices.
     *
     * @param rowIndex Zero-based row index (excluding header row)
     * @param columnIndex Zero-based column index
     * @return This CSTable instance for method chaining
     */
    public CSTable clickCell(int rowIndex, int columnIndex) {
        LOGGER.info("Clicking cell at row {}, column {} in table: {}", rowIndex, columnIndex, getSelector());
        
        try {
            getCell(rowIndex, columnIndex).click();
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to click cell at row {}, column {} in table {}: {}", 
                    rowIndex, columnIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to click cell: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clicks on a cell by row index and column name.
     *
     * @param rowIndex Zero-based row index (excluding header row)
     * @param columnName Column name (header text)
     * @return This CSTable instance for method chaining
     */
    public CSTable clickCell(int rowIndex, String columnName) {
        LOGGER.info("Clicking cell at row {}, column '{}' in table: {}", rowIndex, columnName, getSelector());
        
        try {
            getCell(rowIndex, columnName).click();
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to click cell at row {}, column '{}' in table {}: {}", 
                    rowIndex, columnName, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to click cell by column name: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clicks on a header cell by index.
     *
     * @param columnIndex Zero-based column index
     * @return This CSTable instance for method chaining
     */
    public CSTable clickHeader(int columnIndex) {
        LOGGER.info("Clicking header at column {} in table: {}", columnIndex, getSelector());
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot click header in table without header row");
        }
        
        try {
            Locator headerRowLocator = getLocator().locator(headerRowSelector).first();
            Locator headerCellsLocator = headerRowLocator.locator(headerCellSelector);
            
            if (columnIndex < 0 || columnIndex >= headerCellsLocator.count()) {
                throw new IndexOutOfBoundsException("Column index " + columnIndex + " out of bounds for table with " + 
                        headerCellsLocator.count() + " columns");
            }
            
            Locator headerCellLocator = headerCellsLocator.nth(columnIndex);
            headerCellLocator.click();
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to click header at column {} in table {}: {}", 
                    columnIndex, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to click header: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clicks on a header cell by name.
     *
     * @param columnName Column name (header text)
     * @return This CSTable instance for method chaining
     */
    public CSTable clickHeader(String columnName) {
        LOGGER.info("Clicking header '{}' in table: {}", columnName, getSelector());
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot click header in table without header row");
        }
        
        try {
            List<String> headers = getHeaderTexts();
            int columnIndex = headers.indexOf(columnName);
            
            if (columnIndex == -1) {
                throw new NoSuchElementException("Column with name '" + columnName + "' not found in table");
            }
            
            return clickHeader(columnIndex);
        } catch (Exception e) {
            LOGGER.error("Failed to click header '{}' in table {}: {}", 
                    columnName, getSelector(), e.getMessage(), e);
            throw new RuntimeException("Failed to click header by name: " + e.getMessage(), e);
        }
    }
    
    /**
     * Sorts the table data in memory by the specified column.
     *
     * @param columnName Column name to sort by
     * @param ascending Whether to sort in ascending order
     * @return List of sorted row data
     */
    public List<Map<String, String>> sortDataByColumn(String columnName, boolean ascending) {
        LOGGER.debug("Sorting table data by column '{}' in {} order", columnName, ascending ? "ascending" : "descending");
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot sort by column name in table without header row");
        }
        
        try {
            List<Map<String, String>> data = getAllDataAsMaps();
            
            data.sort((row1, row2) -> {
                String value1 = row1.get(columnName);
                String value2 = row2.get(columnName);
                
                if (value1 == null && value2 == null) {
                    return 0;
                } else if (value1 == null) {
                    return ascending ? -1 : 1;
                } else if (value2 == null) {
                    return ascending ? 1 : -1;
                }
                
                int result = value1.compareTo(value2);
                return ascending ? result : -result;
            });
            
            LOGGER.debug("Sorted {} rows", data.size());
            return data;
        } catch (Exception e) {
            LOGGER.error("Failed to sort table data by column '{}': {}", columnName, e.getMessage(), e);
            throw new RuntimeException("Failed to sort table data: " + e.getMessage(), e);
        }
    }
    
    /**
     * Exports the table data to a CSV file.
     *
     * @param filePath Path to save the CSV file
     * @return This CSTable instance for method chaining
     */
    public CSTable exportToCsv(String filePath) {
        LOGGER.info("Exporting table data to CSV file: {}", filePath);
        
        try {
            List<String> headers = hasHeaderRow ? getHeaderTexts() : new ArrayList<>();
            List<List<String>> data = getAllData();
            
            File file = new File(filePath);
            FileWriter writer = new FileWriter(file);
            
            // Write headers if available
            if (hasHeaderRow && !headers.isEmpty()) {
                writer.write(String.join(",", escapeValues(headers)));
                writer.write("\n");
            }
            
            // Write data rows
            for (List<String> row : data) {
                writer.write(String.join(",", escapeValues(row)));
                writer.write("\n");
            }
            
            writer.close();
            
            LOGGER.info("Exported table data to CSV file: {}", filePath);
            return this;
        } catch (IOException e) {
            LOGGER.error("Failed to export table data to CSV file {}: {}", filePath, e.getMessage(), e);
            throw new RuntimeException("Failed to export table data to CSV: " + e.getMessage(), e);
        }
    }
    
    /**
     * Escapes values for CSV export.
     *
     * @param values List of values to escape
     * @return List of escaped values
     */
    private List<String> escapeValues(List<String> values) {
        return values.stream()
                .map(this::escapeCsvValue)
                .collect(Collectors.toList());
    }
    
    /**
     * Escapes a single value for CSV export.
     *
     * @param value Value to escape
     * @return Escaped value
     */
    private String escapeCsvValue(String value) {
        if (value == null) {
            return "";
        }
        
        value = value.replace("\"", "\"\"");
        return "\"" + value + "\"";
    }
    
    /**
     * Gets a specific cell value in a table where values are indexed by row and column names.
     *
     * @param rowKey Value in the first column that identifies the row
     * @param columnName Column name (header text)
     * @return The cell text
     */
    public String getValueFromTable(String rowKey, String columnName) {
        LOGGER.debug("Getting value from table where row key '{}' and column '{}'", rowKey, columnName);
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot get value by row key and column name in table without header row");
        }
        
        try {
            List<String> headers = getHeaderTexts();
            int columnIndex = headers.indexOf(columnName);
            
            if (columnIndex == -1) {
                throw new NoSuchElementException("Column with name '" + columnName + "' not found in table");
            }
            
            // Find the row with the specified key (assuming key is in the first column)
            List<Integer> matchingRows = findRows(0, rowKey);
            
            if (matchingRows.isEmpty()) {
                throw new NoSuchElementException("Row with key '" + rowKey + "' not found in table");
            }
            
            // Use the first matching row
            int rowIndex = matchingRows.get(0);
            
            return getCellText(rowIndex, columnIndex);
        } catch (Exception e) {
            LOGGER.error("Failed to get value from table where row key '{}' and column '{}': {}", 
                    rowKey, columnName, e.getMessage(), e);
            throw new RuntimeException("Failed to get value from table: " + e.getMessage(), e);
        }
    }
    
    /**
     * Filters the table data by the specified column and value.
     *
     * @param columnName Column name to filter by
     * @param value Value to filter for
     * @return List of maps representing the filtered rows
     */
    public List<Map<String, String>> filterDataByColumn(String columnName, String value) {
        LOGGER.debug("Filtering table data where column '{}' equals '{}'", columnName, value);
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot filter by column name in table without header row");
        }
        
        try {
            List<Map<String, String>> data = getAllDataAsMaps();
            
            List<Map<String, String>> filteredData = data.stream()
                    .filter(row -> value.equals(row.get(columnName)))
                    .collect(Collectors.toList());
            
            LOGGER.debug("Filtered to {} rows", filteredData.size());
            return filteredData;
        } catch (Exception e) {
            LOGGER.error("Failed to filter table data where column '{}' equals '{}': {}", 
                    columnName, value, e.getMessage(), e);
            throw new RuntimeException("Failed to filter table data: " + e.getMessage(), e);
        }
    }
    
    /**
     * Filters the table data by the specified column with a custom matcher function.
     *
     * @param columnName Column name to filter by
     * @param matcher Function that evaluates whether a cell text matches the criteria
     * @return List of maps representing the filtered rows
     */
    public List<Map<String, String>> filterDataByColumn(String columnName, Function<String, Boolean> matcher) {
        LOGGER.debug("Filtering table data where column '{}' matches custom criteria", columnName);
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot filter by column name in table without header row");
        }
        
        try {
            List<Map<String, String>> data = getAllDataAsMaps();
            
            List<Map<String, String>> filteredData = data.stream()
                    .filter(row -> {
                        String cellValue = row.get(columnName);
                        return cellValue != null && matcher.apply(cellValue);
                    })
                    .collect(Collectors.toList());
            
            LOGGER.debug("Filtered to {} rows", filteredData.size());
            return filteredData;
        } catch (Exception e) {
            LOGGER.error("Failed to filter table data where column '{}' matches custom criteria: {}", 
                    columnName, e.getMessage(), e);
            throw new RuntimeException("Failed to filter table data: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets summary statistics for a numeric column.
     *
     * @param columnName Column name to analyze
     * @return Map with summary statistics (min, max, average, sum, count)
     */
    public Map<String, Double> getColumnStatistics(String columnName) {
        LOGGER.debug("Getting statistics for column '{}'", columnName);
        
        if (!hasHeaderRow) {
            throw new IllegalStateException("Cannot get column statistics by name in table without header row");
        }
        
        try {
            List<String> columnTexts = getColumnTexts(columnName);
            List<Double> numericValues = new ArrayList<>();
            
            // Convert text values to numbers
            for (String text : columnTexts) {
                try {
                    double value = Double.parseDouble(text.replaceAll("[^0-9.\\-+]", ""));
                    numericValues.add(value);
                } catch (NumberFormatException e) {
                    // Skip non-numeric values
                }
            }
            
            if (numericValues.isEmpty()) {
                throw new IllegalArgumentException("No numeric values found in column '" + columnName + "'");
            }
            
            // Calculate statistics
            Map<String, Double> statistics = new HashMap<>();
            
            double min = numericValues.stream().mapToDouble(Double::doubleValue).min().orElse(0);
            double max = numericValues.stream().mapToDouble(Double::doubleValue).max().orElse(0);
            double sum = numericValues.stream().mapToDouble(Double::doubleValue).sum();
            double average = sum / numericValues.size();
            
            statistics.put("min", min);
            statistics.put("max", max);
            statistics.put("sum", sum);
            statistics.put("average", average);
            statistics.put("count", (double) numericValues.size());
            
            LOGGER.debug("Got statistics for column '{}'", columnName);
            return statistics;
        } catch (Exception e) {
            LOGGER.error("Failed to get statistics for column '{}': {}", columnName, e.getMessage(), e);
            throw new RuntimeException("Failed to get column statistics: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds the first row index where a certain condition is true.
     *
     * @param columnName Column name to check
     * @param matcher Function that evaluates whether a cell text matches the criteria
     * @return The first matching row index, or -1 if not found
     */
    public int findFirstRowIndex(String columnName, Function<String, Boolean> matcher) {
        LOGGER.debug("Finding first row where column '{}' matches criteria", columnName);
        
        try {
            List<Integer> matchingRows = findRows(columnName, matcher);
            return matchingRows.isEmpty() ? -1 : matchingRows.get(0);
        } catch (Exception e) {
            LOGGER.error("Failed to find first row where column '{}' matches criteria: {}", 
                    columnName, e.getMessage(), e);
            throw new RuntimeException("Failed to find first row index: " + e.getMessage(), e);
        }
    }
}


package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.browser.CSPageManager;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;

import java.util.HashMap;
import java.util.Map;

/**
 * Enhanced wrapper for HTML form elements.
 * Provides methods for form filling and submission.
 */
public class CSForm extends CSElement {
    
    private static final CSLogger LOGGER = CSLogger.getLogger(CSForm.class);
    
    /**
     * Creates a new CSForm with the specified page and selector.
     *
     * @param page Page that contains the form
     * @param selector Selector to locate the form
     * @param pageManager Page manager
     */
    public CSForm(Page page, String selector, CSPageManager pageManager) {
        super(page, selector, pageManager);
    }
    
    /**
     * Creates a new CSForm with the specified page and Locator.
     *
     * @param page Page that contains the form
     * @param locator Locator for the form
     * @param selector Selector string used to create the locator
     * @param pageManager Page manager
     */
    public CSForm(Page page, Locator locator, String selector, CSPageManager pageManager) {
        super(page, locator, selector, pageManager);
    }
    
    /**
     * Fills a text field in the form.
     *
     * @param fieldName Field name, id, or selector
     * @param value Value to fill
     * @return This CSForm instance for method chaining
     */
    public CSForm fillField(String fieldName, String value) {
        LOGGER.info("Filling field '{}' with value '{}'", fieldName, value);
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            fieldLocator.fill(value);
            
            LOGGER.info("Filled field '{}'", fieldName);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to fill field '{}': {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to fill field: " + e.getMessage(), e);
        }
    }
    
    /**
     * Types slowly into a text field in the form.
     *
     * @param fieldName Field name, id, or selector
     * @param value Value to type
     * @return This CSForm instance for method chaining
     */
    public CSForm typeInField(String fieldName, String value) {
        LOGGER.info("Typing in field '{}' with value '{}'", fieldName, value);
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            fieldLocator.type(value);
            
            LOGGER.info("Typed in field '{}'", fieldName);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to type in field '{}': {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to type in field: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks or unchecks a checkbox in the form.
     *
     * @param fieldName Field name, id, or selector
     * @param checked Whether to check (true) or uncheck (false)
     * @return This CSForm instance for method chaining
     */
    public CSForm checkField(String fieldName, boolean checked) {
        LOGGER.info("Setting checkbox '{}' to {}", fieldName, checked ? "checked" : "unchecked");
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            fieldLocator.setChecked(checked);
            
            LOGGER.info("Set checkbox '{}' to {}", fieldName, checked ? "checked" : "unchecked");
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to set checkbox '{}': {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to set checkbox: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects an option from a select field in the form by value.
     *
     * @param fieldName Field name, id, or selector
     * @param value Option value to select
     * @return This CSForm instance for method chaining
     */
    public CSForm selectOption(String fieldName, String value) {
        LOGGER.info("Selecting option with value '{}' in select field '{}'", value, fieldName);
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            fieldLocator.selectOption(value);
            
            LOGGER.info("Selected option in field '{}'", fieldName);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to select option in field '{}': {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to select option: " + e.getMessage(), e);
        }
    }
    
    /**
     * Selects multiple options from a select field in the form by values.
     *
     * @param fieldName Field name, id, or selector
     * @param values Option values to select
     * @return This CSForm instance for method chaining
     */
    public CSForm selectOptions(String fieldName, String[] values) {
        LOGGER.info("Selecting multiple options in select field '{}'", fieldName);
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            fieldLocator.selectOption(values);
            
            LOGGER.info("Selected multiple options in field '{}'", fieldName);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to select multiple options in field '{}': {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to select multiple options: " + e.getMessage(), e);
        }
    }
    
    /**
     * Uploads a file to a file input field in the form.
     *
     * @param fieldName Field name, id, or selector
     * @param filePath Path to the file to upload
     * @return This CSForm instance for method chaining
     */
    public CSForm uploadFile(String fieldName, String filePath) {
        LOGGER.info("Uploading file '{}' to field '{}'", filePath, fieldName);
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            fieldLocator.setInputFiles(filePath);
            
            LOGGER.info("Uploaded file to field '{}'", fieldName);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to upload file to field '{}': {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to upload file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Uploads multiple files to a file input field in the form.
     *
     * @param fieldName Field name, id, or selector
     * @param filePaths Paths to the files to upload
     * @return This CSForm instance for method chaining
     */
    public CSForm uploadFiles(String fieldName, String[] filePaths) {
        LOGGER.info("Uploading multiple files to field '{}'", fieldName);
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            fieldLocator.setInputFiles(filePaths);
            
            LOGGER.info("Uploaded multiple files to field '{}'", fieldName);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to upload multiple files to field '{}': {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to upload multiple files: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clears a text field in the form.
     *
     * @param fieldName Field name, id, or selector
     * @return This CSForm instance for method chaining
     */
    public CSForm clearField(String fieldName) {
        LOGGER.info("Clearing field '{}'", fieldName);
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            fieldLocator.clear();
            
            LOGGER.info("Cleared field '{}'", fieldName);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to clear field '{}': {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to clear field: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets the value of a field in the form.
     *
     * @param fieldName Field name, id, or selector
     * @return The field value
     */
    public String getFieldValue(String fieldName) {
        LOGGER.debug("Getting value from field '{}'", fieldName);
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            String tagName = fieldLocator.evaluate("el => el.tagName.toLowerCase()").toString();
            
            if ("input".equals(tagName) || "textarea".equals(tagName)) {
                String value = fieldLocator.inputValue();
                LOGGER.debug("Got value from field '{}': {}", fieldName, value);
                return value;
            } else if ("select".equals(tagName)) {
                String value = fieldLocator.evaluate("el => Array.from(el.selectedOptions).map(o => o.value)[0]").toString();
                LOGGER.debug("Got selected value from field '{}': {}", fieldName, value);
                return value;
            } else {
                String value = fieldLocator.textContent();
                LOGGER.debug("Got text content from field '{}': {}", fieldName, value);
                return value;
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get value from field '{}': {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to get field value: " + e.getMessage(), e);
        }
    }
    
    /**
     * Checks if a checkbox or radio button is checked.
     *
     * @param fieldName Field name, id, or selector
     * @return True if the field is checked
     */
    public boolean isFieldChecked(String fieldName) {
        LOGGER.debug("Checking if field '{}' is checked", fieldName);
        
        try {
            Locator fieldLocator = findFieldLocator(fieldName);
            boolean checked = fieldLocator.isChecked();
            
            LOGGER.debug("Field '{}' is {}", fieldName, checked ? "checked" : "not checked");
            return checked;
        } catch (Exception e) {
            LOGGER.error("Failed to check if field '{}' is checked: {}", fieldName, e.getMessage(), e);
            throw new RuntimeException("Failed to check if field is checked: " + e.getMessage(), e);
        }
    }
    
    /**
     * Submits the form.
     *
     * @return This CSForm instance for method chaining
     */
    public CSForm submit() {
        LOGGER.info("Submitting form: {}", getSelector());
        
        try {
            getLocator().evaluate("form => form.submit()");
            LOGGER.info("Submitted form");
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to submit form: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to submit form: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clicks the submit button in the form.
     *
     * @return This CSForm instance for method chaining
     */
    public CSForm clickSubmitButton() {
        LOGGER.info("Clicking submit button in form: {}", getSelector());
        
        try {
            // Try to find the submit button
            Locator submitButton = getLocator().locator("input[type='submit'], button[type='submit']");
            
            if (submitButton.count() > 0) {
                submitButton.first().click();
                LOGGER.info("Clicked submit button");
            } else {
                LOGGER.warn("No submit button found, submitting form using JavaScript");
                submit();
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to click submit button: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to click submit button: " + e.getMessage(), e);
        }
    }
    
    /**
     * Fills all fields in the form with the specified values.
     *
     * @param values Map of field names/selectors to values
     * @return This CSForm instance for method chaining
     */
    public CSForm fillForm(Map<String, String> values) {
        LOGGER.info("Filling form with {} values", values.size());
        
        try {
            for (Map.Entry<String, String> entry : values.entrySet()) {
                String fieldName = entry.getKey();
                String value = entry.getValue();
                
                fillField(fieldName, value);
            }
            
            LOGGER.info("Filled form with {} values", values.size());
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to fill form: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to fill form: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets all field values from the form.
     *
     * @return Map of field names to values
     */
    public Map<String, String> getAllFieldValues() {
        LOGGER.debug("Getting all field values from form: {}", getSelector());
        
        try {
            Map<String, String> values = new HashMap<>();
            
            // Get all input fields
            Locator inputFields = getLocator().locator("input:not([type='submit']):not([type='button']):not([type='reset']):not([type='image']):not([type='file']), textarea, select");
            
            int count = inputFields.count();
            
            for (int i = 0; i < count; i++) {
                Locator field = inputFields.nth(i);
                
                String name = field.getAttribute("name");
                String id = field.getAttribute("id");
                
                if (name == null && id == null) {
                    continue;
                }
                
                String fieldIdentifier = name != null ? name : id;
                String tagName = field.evaluate("el => el.tagName.toLowerCase()").toString();
                
                if ("input".equals(tagName)) {
                    String type = field.getAttribute("type");
                    
                    if ("checkbox".equals(type) || "radio".equals(type)) {
                        if (field.isChecked()) {
                            values.put(fieldIdentifier, field.getAttribute("value"));
                        }
                    } else {
                        values.put(fieldIdentifier, field.inputValue());
                    }
                } else if ("textarea".equals(tagName)) {
                    values.put(fieldIdentifier, field.inputValue());
                } else if ("select".equals(tagName)) {
                    // For multi-select, this will only get the first selected value
                    Object selectedValue = field.evaluate("el => Array.from(el.selectedOptions).map(o => o.value)[0]");
                    if (selectedValue != null) {
                        values.put(fieldIdentifier, selectedValue.toString());
                    }
                }
            }
            
            LOGGER.debug("Got {} field values from form", values.size());
            return values;
        } catch (Exception e) {
            LOGGER.error("Failed to get all field values from form: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to get all field values: " + e.getMessage(), e);
        }
    }
    
    /**
     * Resets the form.
     *
     * @return This CSForm instance for method chaining
     */
    public CSForm reset() {
        LOGGER.info("Resetting form: {}", getSelector());
        
        try {
            getLocator().evaluate("form => form.reset()");
            LOGGER.info("Reset form");
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to reset form: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to reset form: " + e.getMessage(), e);
        }
    }
    
    /**
     * Clicks a button or link in the form.
     *
     * @param buttonText Text of the button or link
     * @return This CSForm instance for method chaining
     */
    public CSForm clickButton(String buttonText) {
        LOGGER.info("Clicking button or link with text '{}' in form", buttonText);
        
        try {
            Locator buttonLocator = getLocator().locator("button, input[type='button'], input[type='submit'], input[type='reset'], a")
                    .filter(new Locator.FilterOptions().setHasText(buttonText));
            
            if (buttonLocator.count() == 0) {
                throw new RuntimeException("Button or link with text '" + buttonText + "' not found in form");
            }
            
            buttonLocator.first().click();
            
            LOGGER.info("Clicked button or link with text '{}'", buttonText);
            return this;
        } catch (Exception e) {
            LOGGER.error("Failed to click button or link with text '{}': {}", buttonText, e.getMessage(), e);
            throw new RuntimeException("Failed to click button or link: " + e.getMessage(), e);
        }
    }
    
    /**
     * Finds a field locator by name, id, or selector.
     *
     * @param fieldName Field name, id, or selector
     * @return Locator for the field
     */
    private Locator findFieldLocator(String fieldName) {
        // Try by name
        Locator byName = getLocator().locator("[name='" + fieldName + "']");
        if (byName.count() > 0) {
            return byName.first();
        }
        
        // Try by id
        Locator byId = getLocator().locator("#" + fieldName);
        if (byId.count() > 0) {
            return byId.first();
        }
        
        // Try as a selector
        Locator bySelector = getLocator().locator(fieldName);
        if (bySelector.count() > 0) {
            return bySelector.first();
        }
        
        // Try by label text
        Locator byLabel = getLocator().locator("label")
                .filter(new Locator.FilterOptions().setHasText(fieldName));
        
        if (byLabel.count() > 0) {
            String forAttr = byLabel.first().getAttribute("for");
            if (forAttr != null && !forAttr.isEmpty()) {
                Locator byLabelFor = getLocator().locator("#" + forAttr);
                if (byLabelFor.count() > 0) {
                    return byLabelFor.first();
                }
            }
        }
        
        throw new RuntimeException("Field '" + fieldName + "' not found in form");
    }
    
    /**
     * Checks if a field exists in the form.
     *
     * @param fieldName Field name, id, or selector
     * @return True if the field exists
     */
    public boolean fieldExists(String fieldName) {
        LOGGER.debug("Checking if field '{}' exists in form", fieldName);
        
        try {
            // Try by name
            Locator byName = getLocator().locator("[name='" + fieldName + "']");
            if (byName.count() > 0) {
                return true;
            }
            
            // Try by id
            Locator byId = getLocator().locator("#" + fieldName);
            if (byId.count() > 0) {
                return true;
            }
            
            // Try as a selector
            Locator bySelector = getLocator().locator(fieldName);
            if (bySelector.count() > 0) {
                return true;
            }
            
            // Try by label text
            Locator byLabel = getLocator().locator("label")
                    .filter(new Locator.FilterOptions().setHasText(fieldName));
            
            if (byLabel.count() > 0) {
                String forAttr = byLabel.first().getAttribute("for");
                if (forAttr != null && !forAttr.isEmpty()) {
                    Locator byLabelFor = getLocator().locator("#" + forAttr);
                    if (byLabelFor.count() > 0) {
                        return true;
                    }
                }
            }
            
            return false;
        } catch (Exception e) {
            LOGGER.error("Error checking if field '{}' exists: {}", fieldName, e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Validates if required fields are filled.
     *
     * @return True if all required fields are filled
     */
    public boolean validateRequiredFields() {
        LOGGER.info("Validating required fields in form: {}", getSelector());
        
        try {
            Locator requiredFields = getLocator().locator("[required]");
            int count = requiredFields.count();
            
            for (int i = 0; i < count; i++) {
                Locator field = requiredFields.nth(i);
                String tagName = field.evaluate("el => el.tagName.toLowerCase()").toString();
                
                if ("input".equals(tagName)) {
                    String type = field.getAttribute("type");
                    
                    if ("checkbox".equals(type) || "radio".equals(type)) {
                        // For checkbox/radio groups, at least one should be checked
                        String name = field.getAttribute("name");
                        if (name != null) {
                            Locator group = getLocator().locator("[name='" + name + "']:checked");
                            if (group.count() == 0) {
                                LOGGER.debug("Required checkbox/radio group '{}' is not checked", name);
                                return false;
                            }
                        }
                    } else if ("file".equals(type)) {
                        // For file inputs, can't reliably check if files are selected
                        continue;
                    } else {
                        // For other inputs, check value
                        String value = field.inputValue();
                        if (value == null || value.isEmpty()) {
                            LOGGER.debug("Required field is empty");
                            return false;
                        }
                    }
                } else if ("textarea".equals(tagName)) {
                    String value = field.inputValue();
                    if (value == null || value.isEmpty()) {
                        LOGGER.debug("Required textarea is empty");
                        return false;
                    }
                } else if ("select".equals(tagName)) {
                    Object selectedValue = field.evaluate("el => el.value");
                    if (selectedValue == null || selectedValue.toString().isEmpty()) {
                        LOGGER.debug("Required select has no selection");
                        return false;
                    }
                }
            }
            
            LOGGER.info("All required fields are valid");
            return true;
        } catch (Exception e) {
            LOGGER.error("Failed to validate required fields: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to validate required fields: " + e.getMessage(), e);
        }
    }
}



