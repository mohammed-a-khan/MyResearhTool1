/**
 * DatePicker.tsx
 * 
 * Custom date picker component for the CSTestForge framework.
 * Provides a customizable calendar with range selection, time picking, and more.
 */

import React, { useState, useRef, useEffect, useCallback } from 'react';
import './DatePicker.scss';

/**
 * Date change handler type
 */
export type DateChangeHandler = (date: Date | null) => void;

/**
 * Date range change handler type
 */
export type DateRangeChangeHandler = (dates: [Date | null, Date | null]) => void;

/**
 * Date picker props interface
 */
export interface DatePickerProps {
  /**
   * Selected date (controlled component)
   */
  value?: Date | null;
  
  /**
   * Default date (uncontrolled component)
   */
  defaultValue?: Date | null;
  
  /**
   * Selected date range (controlled component)
   */
  rangeValue?: [Date | null, Date | null];
  
  /**
   * Default date range (uncontrolled component)
   */
  defaultRangeValue?: [Date | null, Date | null];
  
  /**
   * Callback when date changes
   */
  onChange?: DateChangeHandler;
  
  /**
   * Callback when date range changes
   */
  onRangeChange?: DateRangeChangeHandler;
  
  /**
   * Whether the date picker is disabled
   */
  disabled?: boolean;
  
  /**
   * Custom placeholder text
   */
  placeholder?: string;
  
  /**
   * Whether to display a clear button
   */
  allowClear?: boolean;
  
  /**
   * Whether to include time selection
   */
  showTime?: boolean;
  
  /**
   * Custom time format
   */
  timeFormat?: string;
  
  /**
   * Custom date format for display
   */
  dateFormat?: string;
  
  /**
   * Whether to show today button
   */
  showToday?: boolean;
  
  /**
   * Whether to show now button (when showTime is true)
   */
  showNow?: boolean;
  
  /**
   * Minimum selectable date
   */
  minDate?: Date;
  
  /**
   * Maximum selectable date
   */
  maxDate?: Date;
  
  /**
   * Whether to auto-focus the input
   */
  autoFocus?: boolean;
  
  /**
   * Whether to open the calendar on focus
   */
  openOnFocus?: boolean;
  
  /**
   * Custom rendering of date cells
   */
  dateRender?: (date: Date) => React.ReactNode;
  
  /**
   * Whether to disable weekends
   */
  disableWeekends?: boolean;
  
  /**
   * Array of disabled dates
   */
  disabledDates?: Date[];
  
  /**
   * Additional dates to highlight
   */
  highlightDates?: Date[];
  
  /**
   * Whether to use range selection
   */
  range?: boolean;
  
  /**
   * First day of the week (0 = Sunday, 1 = Monday, etc.)
   */
  firstDayOfWeek?: number;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Callback when calendar panel opens
   */
  onOpenChange?: (open: boolean) => void;
  
  /**
   * Callback when focus changes
   */
  onFocus?: React.FocusEventHandler<HTMLInputElement>;
  
  /**
   * Callback when blur occurs
   */
  onBlur?: React.FocusEventHandler<HTMLInputElement>;
  
  /**
   * Month names for localization
   */
  monthNames?: string[];
  
  /**
   * Day names for localization
   */
  dayNames?: string[];
  
  /**
   * Abbreviated day names for localization
   */
  dayNamesShort?: string[];
  
  /**
   * Custom today button text
   */
  todayButtonLabel?: string;
  
  /**
   * Custom clear button text
   */
  clearButtonLabel?: string;
  
  /**
   * Custom now button text
   */
  nowButtonLabel?: string;
  
  /**
   * Position of the calendar popup
   */
  popupPosition?: 'top' | 'bottom' | 'auto';
  
  /**
   * Whether to display month and year dropdowns
   */
  showMonthYearDropdowns?: boolean;
  
  /**
   * Whether to display week numbers
   */
  showWeekNumbers?: boolean;
  
  /**
   * Whether the input is required
   */
  required?: boolean;
  
  /**
   * Input name attribute
   */
  name?: string;
  
  /**
   * Input id attribute
   */
  id?: string;
}

/**
 * Day info interface
 */
interface DayInfo {
  /**
   * Date object
   */
  date: Date;
  
  /**
   * Day number
   */
  day: number;
  
  /**
   * Whether the day is in the current month
   */
  isCurrentMonth: boolean;
  
  /**
   * Whether the day is today
   */
  isToday: boolean;
  
  /**
   * Whether the day is selected
   */
  isSelected: boolean;
  
  /**
   * Whether the day is in the selection range
   */
  isInRange: boolean;
  
  /**
   * Whether the day is the range start
   */
  isRangeStart: boolean;
  
  /**
   * Whether the day is the range end
   */
  isRangeEnd: boolean;
  
  /**
   * Whether the day is disabled
   */
  isDisabled: boolean;
  
  /**
   * Whether the day is highlighted
   */
  isHighlighted: boolean;
  
  /**
   * Whether the day is a weekend
   */
  isWeekend: boolean;
}

/**
 * Week info interface
 */
interface WeekInfo {
  /**
   * Week number
   */
  weekNumber: number;
  
  /**
   * Days in the week
   */
  days: DayInfo[];
}

/**
 * Month info interface
 */
interface MonthInfo {
  /**
   * Month number (0-11)
   */
  month: number;
  
  /**
   * Year number
   */
  year: number;
  
  /**
   * Weeks in the month
   */
  weeks: WeekInfo[];
}

/**
 * DatePicker component
 */
const DatePicker: React.FC<DatePickerProps> = (props) => {
  const {
    value,
    defaultValue,
    rangeValue,
    defaultRangeValue,
    onChange,
    onRangeChange,
    disabled = false,
    placeholder = 'Select date',
    allowClear = true,
    showTime = false,
    timeFormat = 'HH:mm:ss',
    dateFormat = 'MM/DD/YYYY',
    showToday = true,
    showNow = false,
    minDate,
    maxDate,
    autoFocus = false,
    openOnFocus = true,
    dateRender,
    disableWeekends = false,
    disabledDates = [],
    highlightDates = [],
    range = false,
    firstDayOfWeek = 0,
    className = '',
    style,
    onOpenChange,
    onFocus,
    onBlur,
    monthNames = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ],
    dayNames = [
      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
    ],
    dayNamesShort = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    todayButtonLabel = 'Today',
    clearButtonLabel = 'Clear',
    nowButtonLabel = 'Now',
    popupPosition = 'auto',
    showMonthYearDropdowns = false,
    showWeekNumbers = false,
    required = false,
    name,
    id
  } = props;

  // Component state
  const [isOpen, setIsOpen] = useState<boolean>(false);
  const [inputValue, setInputValue] = useState<string>('');
  const [rangeInputValue, setRangeInputValue] = useState<string[]>(['', '']);
  const [selectedDate, setSelectedDate] = useState<Date | null>(defaultValue || null);
  const [selectedRange, setSelectedRange] = useState<[Date | null, Date | null]>(defaultRangeValue || [null, null]);
  const [viewDate, setViewDate] = useState<Date>(
    (value || defaultValue || range ? (rangeValue || defaultRangeValue || [])[0] : null) || new Date()
  );
  const [hoverDate, setHoverDate] = useState<Date | null>(null);
  const [activeInput, setActiveInput] = useState<0 | 1>(0);
  const [hours, setHours] = useState<number>(0);
  const [minutes, setMinutes] = useState<number>(0);
  const [seconds, setSeconds] = useState<number>(0);
  
  // Refs
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const startInputRef = useRef<HTMLInputElement>(null);
  const endInputRef = useRef<HTMLInputElement>(null);
  const calendarRef = useRef<HTMLDivElement>(null);
  
  // Effect for controlled component (single date)
  useEffect(() => {
    if (value !== undefined) {
      setSelectedDate(value);
      setInputValue(formatDate(value, dateFormat));
    }
  }, [value, dateFormat]);
  
  // Effect for controlled component (date range)
  useEffect(() => {
    if (rangeValue !== undefined) {
      setSelectedRange(rangeValue);
      setRangeInputValue([
        formatDate(rangeValue[0], dateFormat),
        formatDate(rangeValue[1], dateFormat)
      ]);
    }
  }, [rangeValue, dateFormat]);
  
  // Effect for handling clicks outside the component to close the calendar
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        containerRef.current &&
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
        if (onOpenChange) {
          onOpenChange(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [onOpenChange]);
  
  // Effect for positioning the calendar popup
  useEffect(() => {
    if (isOpen && calendarRef.current && containerRef.current) {
      const containerRect = containerRef.current.getBoundingClientRect();
      const calendarRect = calendarRef.current.getBoundingClientRect();
      
      const spaceBelow = window.innerHeight - containerRect.bottom;
      const spaceAbove = containerRect.top;
      
      let position = popupPosition;
      
      if (position === 'auto') {
        if (spaceBelow >= calendarRect.height || spaceBelow >= spaceAbove) {
          position = 'bottom';
        } else {
          position = 'top';
        }
      }
      
      if (position === 'bottom') {
        calendarRef.current.style.top = `${containerRect.height}px`;
        calendarRef.current.style.bottom = 'auto';
      } else {
        calendarRef.current.style.bottom = `${containerRect.height}px`;
        calendarRef.current.style.top = 'auto';
      }
    }
  }, [isOpen, popupPosition]);
  
  // Calculated state for month view
  const monthInfo = useCallback((): MonthInfo => {
    const year = viewDate.getFullYear();
    const month = viewDate.getMonth();
    
    // First day of the month
    const firstDay = new Date(year, month, 1);
    const firstDayOfWeekIndex = (firstDay.getDay() - firstDayOfWeek + 7) % 7;
    
    // Last day of the month
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    
    // Last day of the previous month
    const prevMonthLastDay = new Date(year, month, 0).getDate();
    
    // Current date for highlighting today
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Initialize weeks array
    const weeks: WeekInfo[] = [];
    let days: DayInfo[] = [];
    let weekNumber = getWeekNumber(new Date(year, month, 1 - firstDayOfWeekIndex));
    
    // Add days from previous month
    for (let i = 0; i < firstDayOfWeekIndex; i++) {
      const date = new Date(year, month - 1, prevMonthLastDay - firstDayOfWeekIndex + i + 1);
      days.push(createDayInfo(date, false));
    }
    
    // Add days from current month
    for (let i = 1; i <= daysInMonth; i++) {
      const date = new Date(year, month, i);
      days.push(createDayInfo(date, true));
      
      // If we have 7 days or it's the last day of the month, add a week
      if (days.length === 7 || i === daysInMonth) {
        weeks.push({
          weekNumber,
          days: [...days]
        });
        
        // Reset days array and increment week number
        days = [];
        weekNumber = getWeekNumber(new Date(year, month, i + 1));
      }
    }
    
    // Add days from next month if needed
    if (days.length > 0) {
      const daysToAdd = 7 - days.length;
      for (let i = 1; i <= daysToAdd; i++) {
        const date = new Date(year, month + 1, i);
        days.push(createDayInfo(date, false));
      }
      
      weeks.push({
        weekNumber,
        days
      });
    }
    
    return {
      month,
      year,
      weeks
    };
  }, [viewDate, firstDayOfWeek, disableWeekends, disabledDates, highlightDates, selectedDate, selectedRange, hoverDate]);
  
  // Helper function to create day info object
  const createDayInfo = (date: Date, isCurrentMonth: boolean): DayInfo => {
    const day = date.getDate();
    const isWeekend = date.getDay() === 0 || date.getDay() === 6;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const isToday = date.getTime() === today.getTime();
    
    // Check if date is disabled
    let isDisabled = false;
    
    // Check min/max dates
    if (minDate && date < minDate) {
      isDisabled = true;
    }
    
    if (maxDate && date > maxDate) {
      isDisabled = true;
    }
    
    // Check if weekend and should be disabled
    if (disableWeekends && isWeekend) {
      isDisabled = true;
    }
    
    // Check if date is in disabled dates array
    if (disabledDates.some(disabledDate => isSameDay(disabledDate, date))) {
      isDisabled = true;
    }
    
    // Check if date is selected
    let isSelected = false;
    if (selectedDate && isSameDay(date, selectedDate)) {
      isSelected = true;
    }
    
    // Check if date is in range
    let isInRange = false;
    let isRangeStart = false;
    let isRangeEnd = false;
    
    if (range && selectedRange[0] && selectedRange[1]) {
      const rangeStart = selectedRange[0];
      const rangeEnd = selectedRange[1];
      
      if (rangeStart && rangeEnd) {
        if (date >= rangeStart && date <= rangeEnd) {
          isInRange = true;
          isRangeStart = isSameDay(date, rangeStart);
          isRangeEnd = isSameDay(date, rangeEnd);
        }
      } else if (rangeStart && hoverDate) {
        const start = rangeStart < hoverDate ? rangeStart : hoverDate;
        const end = rangeStart < hoverDate ? hoverDate : rangeStart;
        
        if (date >= start && date <= end) {
          isInRange = true;
          isRangeStart = isSameDay(date, rangeStart);
        }
      }
    }
    
    // Check if date is highlighted
    const isHighlighted = highlightDates.some(highlightDate => isSameDay(highlightDate, date));
    
    return {
      date,
      day,
      isCurrentMonth,
      isToday,
      isSelected,
      isInRange,
      isRangeStart,
      isRangeEnd,
      isDisabled,
      isHighlighted,
      isWeekend
    };
  };
  
  // Helper function to check if two dates are the same day
  const isSameDay = (date1: Date | null, date2: Date | null): boolean => {
    if (!date1 || !date2) return false;
    return (
      date1.getFullYear() === date2.getFullYear() &&
      date1.getMonth() === date2.getMonth() &&
      date1.getDate() === date2.getDate()
    );
  };
  
  // Helper function to get week number
  const getWeekNumber = (date: Date): number => {
    const target = new Date(date.valueOf());
    const dayNumber = (date.getDay() + 6) % 7;
    target.setDate(target.getDate() - dayNumber + 3);
    const firstThursday = target.valueOf();
    target.setMonth(0, 1);
    if (target.getDay() !== 4) {
      target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
    }
    return 1 + Math.ceil((firstThursday - target.valueOf()) / 604800000);
  };
  
  // Helper function to format date
  const formatDate = (date: Date | null, format: string): string => {
    if (!date) return '';
    
    let formattedDate = format;
    
    // Replace year
    formattedDate = formattedDate.replace(/YYYY/g, date.getFullYear().toString());
    formattedDate = formattedDate.replace(/YY/g, date.getFullYear().toString().slice(-2));
    
    // Replace month
    formattedDate = formattedDate.replace(/MM/g, (date.getMonth() + 1).toString().padStart(2, '0'));
    formattedDate = formattedDate.replace(/M/g, (date.getMonth() + 1).toString());
    
    // Replace day
    formattedDate = formattedDate.replace(/DD/g, date.getDate().toString().padStart(2, '0'));
    formattedDate = formattedDate.replace(/D/g, date.getDate().toString());
    
    // Add time if showing time
    if (showTime) {
      // Replace hours
      formattedDate = formattedDate.replace(/HH/g, date.getHours().toString().padStart(2, '0'));
      formattedDate = formattedDate.replace(/H/g, date.getHours().toString());
      
      // Replace minutes
      formattedDate = formattedDate.replace(/mm/g, date.getMinutes().toString().padStart(2, '0'));
      formattedDate = formattedDate.replace(/m/g, date.getMinutes().toString());
      
      // Replace seconds
      formattedDate = formattedDate.replace(/ss/g, date.getSeconds().toString().padStart(2, '0'));
      formattedDate = formattedDate.replace(/s/g, date.getSeconds().toString());
    }
    
    return formattedDate;
  };
  
  // Helper function to parse date from string
  const parseDate = (dateString: string, format: string): Date | null => {
    if (!dateString) return null;
    
    // Default values
    let year = new Date().getFullYear();
    let month = 0;
    let day = 1;
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    
    // Match patterns for year, month, and day
    const yearPattern = /YYYY|YY/;
    const monthPattern = /MM|M/;
    const dayPattern = /DD|D/;
    const hourPattern = /HH|H/;
    const minutePattern = /mm|m/;
    const secondPattern = /ss|s/;
    
    // Extract year
    if (format.match(yearPattern)) {
      const yearIndex = format.indexOf(format.match(yearPattern)![0]);
      const yearLength = format.match(yearPattern)![0].length;
      const yearString = dateString.substring(yearIndex, yearIndex + yearLength);
      
      if (yearLength === 2) {
        // Two-digit year
        const century = Math.floor(new Date().getFullYear() / 100) * 100;
        year = century + parseInt(yearString, 10);
      } else {
        // Four-digit year
        year = parseInt(yearString, 10);
      }
    }
    
    // Extract month
    if (format.match(monthPattern)) {
      const monthIndex = format.indexOf(format.match(monthPattern)![0]);
      const monthLength = format.match(monthPattern)![0].length;
      const monthString = dateString.substring(monthIndex, monthIndex + monthLength);
      
      month = parseInt(monthString, 10) - 1; // JavaScript months are 0-indexed
    }
    
    // Extract day
    if (format.match(dayPattern)) {
      const dayIndex = format.indexOf(format.match(dayPattern)![0]);
      const dayLength = format.match(dayPattern)![0].length;
      const dayString = dateString.substring(dayIndex, dayIndex + dayLength);
      
      day = parseInt(dayString, 10);
    }
    
    // Extract hours, minutes, and seconds if showing time
    if (showTime) {
      // Extract hours
      if (format.match(hourPattern)) {
        const hourIndex = format.indexOf(format.match(hourPattern)![0]);
        const hourLength = format.match(hourPattern)![0].length;
        const hourString = dateString.substring(hourIndex, hourIndex + hourLength);
        
        hours = parseInt(hourString, 10);
      }
      
      // Extract minutes
      if (format.match(minutePattern)) {
        const minuteIndex = format.indexOf(format.match(minutePattern)![0]);
        const minuteLength = format.match(minutePattern)![0].length;
        const minuteString = dateString.substring(minuteIndex, minuteIndex + minuteLength);
        
        minutes = parseInt(minuteString, 10);
      }
      
      // Extract seconds
      if (format.match(secondPattern)) {
        const secondIndex = format.indexOf(format.match(secondPattern)![0]);
        const secondLength = format.match(secondPattern)![0].length;
        const secondString = dateString.substring(secondIndex, secondIndex + secondLength);
        
        seconds = parseInt(secondString, 10);
      }
    }
    
    // Create date object
    const date = new Date(year, month, day, hours, minutes, seconds);
    
    // Check if date is valid
    if (isNaN(date.getTime())) {
      return null;
    }
    
    return date;
  };
  
  // Event handlers
  const handleInputClick = () => {
    if (!disabled) {
      setIsOpen(!isOpen);
      if (onOpenChange) {
        onOpenChange(!isOpen);
      }
    }
  };
  
  const handleInputFocus = (e: React.FocusEvent<HTMLInputElement>) => {
    if (openOnFocus && !disabled) {
      setIsOpen(true);
      if (onOpenChange) {
        onOpenChange(true);
      }
    }
    
    if (onFocus) {
      onFocus(e);
    }
  };
  
  const handleInputBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    // Do not close calendar on input blur
    // The calendar will be closed by clicking outside
    
    if (onBlur) {
      onBlur(e);
    }
  };
  
  const handleRangeInputFocus = (index: 0 | 1) => (e: React.FocusEvent<HTMLInputElement>) => {
    setActiveInput(index);
    
    if (openOnFocus && !disabled) {
      setIsOpen(true);
      if (onOpenChange) {
        onOpenChange(true);
      }
    }
    
    if (onFocus) {
      onFocus(e);
    }
  };
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    
    const date = parseDate(value, dateFormat);
    if (date) {
      setSelectedDate(date);
      setViewDate(date);
      
      if (onChange) {
        onChange(date);
      }
    }
  };
  
  const handleRangeInputChange = (index: 0 | 1) => (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    const newRangeInputValue = [...rangeInputValue];
    newRangeInputValue[index] = value;
    setRangeInputValue(newRangeInputValue);
    
    const date = parseDate(value, dateFormat);
    if (date) {
      const newRange: [Date | null, Date | null] = [...selectedRange];
      newRange[index] = date;
      
      if (index === 0 && newRange[1] && date > newRange[1]) {
        newRange[1] = null;
        newRangeInputValue[1] = '';
      } else if (index === 1 && newRange[0] && date < newRange[0]) {
        newRange[0] = null;
        newRangeInputValue[0] = '';
      }
      
      setSelectedRange(newRange);
      setRangeInputValue(newRangeInputValue);
      setViewDate(date);
      
      if (onRangeChange) {
        onRangeChange(newRange);
      }
    }
  };
  
  const handleDayClick = (day: DayInfo) => {
    if (day.isDisabled) return;
    
    if (range) {
      const newRange: [Date | null, Date | null] = [...selectedRange];
      
      if (!newRange[0] || (newRange[0] && newRange[1])) {
        // Start a new range
        newRange[0] = day.date;
        newRange[1] = null;
        setActiveInput(1);
      } else {
        // Complete the range
        if (day.date < newRange[0]) {
          newRange[1] = newRange[0];
          newRange[0] = day.date;
        } else {
          newRange[1] = day.date;
        }
        
        // Close calendar after selecting the end date
        setIsOpen(false);
        if (onOpenChange) {
          onOpenChange(false);
        }
      }
      
      setSelectedRange(newRange);
      setRangeInputValue([
        formatDate(newRange[0], dateFormat),
        formatDate(newRange[1], dateFormat)
      ]);
      
      if (onRangeChange) {
        onRangeChange(newRange);
      }
    } else {
      const newDate = day.date;
      let finalDate = newDate;
      
      // If showing time, set the time fields
      if (showTime) {
        finalDate = new Date(
          newDate.getFullYear(),
          newDate.getMonth(),
          newDate.getDate(),
          hours,
          minutes,
          seconds
        );
      }
      
      setSelectedDate(finalDate);
      setInputValue(formatDate(finalDate, dateFormat));
      
      if (!showTime) {
        // Close calendar after selecting a date (unless showing time)
        setIsOpen(false);
        if (onOpenChange) {
          onOpenChange(false);
        }
      }
      
      if (onChange) {
        onChange(finalDate);
      }
    }
  };
  
  const handleDayMouseEnter = (day: DayInfo) => {
    if (range && selectedRange[0] && !selectedRange[1]) {
      setHoverDate(day.date);
    }
  };
  
  const handleDayMouseLeave = () => {
    setHoverDate(null);
  };
  
  const handlePrevMonth = () => {
    setViewDate(new Date(viewDate.getFullYear(), viewDate.getMonth() - 1, 1));
  };
  
  const handleNextMonth = () => {
    setViewDate(new Date(viewDate.getFullYear(), viewDate.getMonth() + 1, 1));
  };
  
  const handlePrevYear = () => {
    setViewDate(new Date(viewDate.getFullYear() - 1, viewDate.getMonth(), 1));
  };
  
  const handleNextYear = () => {
    setViewDate(new Date(viewDate.getFullYear() + 1, viewDate.getMonth(), 1));
  };
  
  const handleMonthChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const month = parseInt(e.target.value, 10);
    setViewDate(new Date(viewDate.getFullYear(), month, 1));
  };
  
  const handleYearChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const year = parseInt(e.target.value, 10);
    setViewDate(new Date(year, viewDate.getMonth(), 1));
  };
  
  const handleTodayClick = () => {
    const today = new Date();
    setViewDate(today);
    
    if (!range) {
      if (showTime) {
        const todayWithTime = new Date(
          today.getFullYear(),
          today.getMonth(),
          today.getDate(),
          hours,
          minutes,
          seconds
        );
        
        setSelectedDate(todayWithTime);
        setInputValue(formatDate(todayWithTime, dateFormat));
        
        if (onChange) {
          onChange(todayWithTime);
        }
      } else {
        setSelectedDate(today);
        setInputValue(formatDate(today, dateFormat));
        
        if (onChange) {
          onChange(today);
        }
        
        // Close calendar after selecting today (unless showing time)
        setIsOpen(false);
        if (onOpenChange) {
          onOpenChange(false);
        }
      }
    }
  };
  
  const handleNowClick = () => {
    const now = new Date();
    setHours(now.getHours());
    setMinutes(now.getMinutes());
    setSeconds(now.getSeconds());
    
    if (!range) {
      const updatedDate = selectedDate
        ? new Date(
            selectedDate.getFullYear(),
            selectedDate.getMonth(),
            selectedDate.getDate(),
            now.getHours(),
            now.getMinutes(),
            now.getSeconds()
          )
        : now;
      
      setSelectedDate(updatedDate);
      setInputValue(formatDate(updatedDate, dateFormat));
      
      if (onChange) {
        onChange(updatedDate);
      }
    }
  };
  
  const handleClearClick = () => {
    if (range) {
      setSelectedRange([null, null]);
      setRangeInputValue(['', '']);
      
      if (onRangeChange) {
        onRangeChange([null, null]);
      }
    } else {
      setSelectedDate(null);
      setInputValue('');
      
      if (onChange) {
        onChange(null);
      }
    }
    
    setIsOpen(false);
    if (onOpenChange) {
      onOpenChange(false);
    }
  };
  
  const handleHoursChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const value = parseInt(e.target.value, 10);
    setHours(value);
    
    if (selectedDate) {
      const updatedDate = new Date(
        selectedDate.getFullYear(),
        selectedDate.getMonth(),
        selectedDate.getDate(),
        value,
        minutes,
        seconds
      );
      
      setSelectedDate(updatedDate);
      setInputValue(formatDate(updatedDate, dateFormat));
      
      if (onChange) {
        onChange(updatedDate);
      }
    }
  };
  
  const handleMinutesChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const value = parseInt(e.target.value, 10);
    setMinutes(value);
    
    if (selectedDate) {
      const updatedDate = new Date(
        selectedDate.getFullYear(),
        selectedDate.getMonth(),
        selectedDate.getDate(),
        hours,
        value,
        seconds
      );
      
      setSelectedDate(updatedDate);
      setInputValue(formatDate(updatedDate, dateFormat));
      
      if (onChange) {
        onChange(updatedDate);
      }
    }
  };
  
  const handleSecondsChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const value = parseInt(e.target.value, 10);
    setSeconds(value);
    
    if (selectedDate) {
      const updatedDate = new Date(
        selectedDate.getFullYear(),
        selectedDate.getMonth(),
        selectedDate.getDate(),
        hours,
        minutes,
        value
      );
      
      setSelectedDate(updatedDate);
      setInputValue(formatDate(updatedDate, dateFormat));
      
      if (onChange) {
        onChange(updatedDate);
      }
    }
  };
  
  // Generate years array for dropdown
  const years = Array.from({ length: 21 }, (_, i) => viewDate.getFullYear() - 10 + i);
  
  // Generate hours, minutes, and seconds arrays for time dropdowns
  const hoursArray = Array.from({ length: 24 }, (_, i) => i);
  const minutesArray = Array.from({ length: 60 }, (_, i) => i);
  const secondsArray = Array.from({ length: 60 }, (_, i) => i);
  
  // Render functions
  
  // Render month header with navigation
  const renderMonthHeader = () => (
    <div className="cs-datepicker-header">
      <div className="cs-datepicker-header-left">
        <button
          type="button"
          className="cs-datepicker-prev-year"
          onClick={handlePrevYear}
          aria-label="Previous Year"
        >
          &laquo;
        </button>
        <button
          type="button"
          className="cs-datepicker-prev-month"
          onClick={handlePrevMonth}
          aria-label="Previous Month"
        >
          &lsaquo;
        </button>
      </div>
      <div className="cs-datepicker-header-content">
        {showMonthYearDropdowns ? (
          <>
            <select
              className="cs-datepicker-month-select"
              value={viewDate.getMonth()}
              onChange={handleMonthChange}
              aria-label="Select Month"
            >
              {monthNames.map((month, index) => (
                <option key={month} value={index}>
                  {month}
                </option>
              ))}
            </select>
            <select
              className="cs-datepicker-year-select"
              value={viewDate.getFullYear()}
              onChange={handleYearChange}
              aria-label="Select Year"
            >
              {years.map(year => (
                <option key={year} value={year}>
                  {year}
                </option>
              ))}
            </select>
          </>
        ) : (
          <div className="cs-datepicker-current-month">
            {monthNames[viewDate.getMonth()]} {viewDate.getFullYear()}
          </div>
        )}
      </div>
      <div className="cs-datepicker-header-right">
        <button
          type="button"
          className="cs-datepicker-next-month"
          onClick={handleNextMonth}
          aria-label="Next Month"
        >
          &rsaquo;
        </button>
        <button
          type="button"
          className="cs-datepicker-next-year"
          onClick={handleNextYear}
          aria-label="Next Year"
        >
          &raquo;
        </button>
      </div>
    </div>
  );
  
  // Render day names row
  const renderDayNames = () => {
    // Reorder day names based on firstDayOfWeek
    const orderedDayNames = [...dayNamesShort];
    const orderedNamesPrefix = orderedDayNames.splice(0, firstDayOfWeek);
    orderedDayNames.push(...orderedNamesPrefix);
    
    return (
      <div className="cs-datepicker-weekdays">
        {showWeekNumbers && <div className="cs-datepicker-weekday cs-datepicker-week-number"></div>}
        {orderedDayNames.map(dayName => (
          <div key={dayName} className="cs-datepicker-weekday">
            {dayName}
          </div>
        ))}
      </div>
    );
  };
  
  // Render calendar days
  const renderDays = () => {
    const { weeks } = monthInfo();
    
    return (
      <div className="cs-datepicker-days">
        {weeks.map(week => (
          <div key={`week-${week.weekNumber}`} className="cs-datepicker-week">
            {showWeekNumbers && (
              <div className="cs-datepicker-week-number">{week.weekNumber}</div>
            )}
            {week.days.map(day => (
              <button
                key={`day-${day.date.getTime()}`}
                type="button"
                className={`
                  cs-datepicker-day
                  ${day.isCurrentMonth ? 'cs-datepicker-day-current-month' : 'cs-datepicker-day-other-month'}
                  ${day.isToday ? 'cs-datepicker-day-today' : ''}
                  ${day.isSelected ? 'cs-datepicker-day-selected' : ''}
                  ${day.isInRange ? 'cs-datepicker-day-in-range' : ''}
                  ${day.isRangeStart ? 'cs-datepicker-day-range-start' : ''}
                  ${day.isRangeEnd ? 'cs-datepicker-day-range-end' : ''}
                  ${day.isDisabled ? 'cs-datepicker-day-disabled' : ''}
                  ${day.isHighlighted ? 'cs-datepicker-day-highlighted' : ''}
                  ${day.isWeekend ? 'cs-datepicker-day-weekend' : ''}
                `}
                disabled={day.isDisabled}
                onClick={() => handleDayClick(day)}
                onMouseEnter={() => handleDayMouseEnter(day)}
                onMouseLeave={handleDayMouseLeave}
                aria-label={formatDate(day.date, 'MMMM D, YYYY')}
                aria-selected={day.isSelected}
                aria-disabled={day.isDisabled}
              >
                {dateRender ? dateRender(day.date) : day.day}
              </button>
            ))}
          </div>
        ))}
      </div>
    );
  };
  
  // Render time picker
  const renderTimePicker = () => {
    if (!showTime) return null;
    
    return (
      <div className="cs-datepicker-time">
        <div className="cs-datepicker-time-label">Time:</div>
        <div className="cs-datepicker-time-selects">
          <select
            className="cs-datepicker-select cs-datepicker-hour-select"
            value={hours}
            onChange={handleHoursChange}
            aria-label="Hours"
          >
            {hoursArray.map(hour => (
              <option key={`hour-${hour}`} value={hour}>
                {hour.toString().padStart(2, '0')}
              </option>
            ))}
          </select>
          <span className="cs-datepicker-time-separator">:</span>
          <select
            className="cs-datepicker-select cs-datepicker-minute-select"
            value={minutes}
            onChange={handleMinutesChange}
            aria-label="Minutes"
          >
            {minutesArray.map(minute => (
              <option key={`minute-${minute}`} value={minute}>
                {minute.toString().padStart(2, '0')}
              </option>
            ))}
          </select>
          <span className="cs-datepicker-time-separator">:</span>
          <select
            className="cs-datepicker-select cs-datepicker-second-select"
            value={seconds}
            onChange={handleSecondsChange}
            aria-label="Seconds"
          >
            {secondsArray.map(second => (
              <option key={`second-${second}`} value={second}>
                {second.toString().padStart(2, '0')}
              </option>
            ))}
          </select>
        </div>
      </div>
    );
  };
  
  // Render footer with buttons
  const renderFooter = () => {
    return (
      <div className="cs-datepicker-footer">
        <div className="cs-datepicker-footer-buttons">
          {showToday && (
            <button
              type="button"
              className="cs-datepicker-today-button"
              onClick={handleTodayClick}
              aria-label={todayButtonLabel}
            >
              {todayButtonLabel}
            </button>
          )}
          {showTime && showNow && (
            <button
              type="button"
              className="cs-datepicker-now-button"
              onClick={handleNowClick}
              aria-label={nowButtonLabel}
            >
              {nowButtonLabel}
            </button>
          )}
          {allowClear && (selectedDate || selectedRange[0] || selectedRange[1]) && (
            <button
              type="button"
              className="cs-datepicker-clear-button"
              onClick={handleClearClick}
              aria-label={clearButtonLabel}
            >
              {clearButtonLabel}
            </button>
          )}
        </div>
      </div>
    );
  };
  
  // Render single date picker
  const renderSingleDatePicker = () => (
    <div
      className={`cs-datepicker ${className}`}
      style={style}
      ref={containerRef}
    >
      <div className="cs-datepicker-input-wrapper">
        <input
          id={id}
          name={name}
          ref={inputRef}
          type="text"
          className="cs-datepicker-input"
          value={inputValue}
          onChange={handleInputChange}
          onClick={handleInputClick}
          onFocus={handleInputFocus}
          onBlur={handleInputBlur}
          placeholder={placeholder}
          disabled={disabled}
          autoFocus={autoFocus}
          required={required}
          aria-haspopup="true"
          aria-expanded={isOpen}
          aria-disabled={disabled}
        />
        {allowClear && inputValue && (
          <button
            type="button"
            className="cs-datepicker-clear-input"
            onClick={handleClearClick}
            aria-label="Clear date"
          >
            &times;
          </button>
        )}
      </div>
      
      {isOpen && (
        <div className="cs-datepicker-calendar" ref={calendarRef}>
          {renderMonthHeader()}
          {renderDayNames()}
          {renderDays()}
          {renderTimePicker()}
          {renderFooter()}
        </div>
      )}
    </div>
  );
  
  // Render range date picker
  const renderRangeDatePicker = () => (
    <div
      className={`cs-datepicker cs-datepicker-range ${className}`}
      style={style}
      ref={containerRef}
    >
      <div className="cs-datepicker-range-inputs">
        <div className="cs-datepicker-input-wrapper">
          <input
            id={id ? `${id}-start` : undefined}
            name={name ? `${name}-start` : undefined}
            ref={startInputRef}
            type="text"
            className={`cs-datepicker-input cs-datepicker-range-start ${activeInput === 0 ? 'cs-datepicker-input-active' : ''}`}
            value={rangeInputValue[0]}
            onChange={handleRangeInputChange(0)}
            onClick={handleInputClick}
            onFocus={handleRangeInputFocus(0)}
            onBlur={handleInputBlur}
            placeholder="Start date"
            disabled={disabled}
            autoFocus={autoFocus}
            required={required}
            aria-haspopup="true"
            aria-expanded={isOpen}
            aria-disabled={disabled}
          />
        </div>
        <div className="cs-datepicker-range-separator">to</div>
        <div className="cs-datepicker-input-wrapper">
          <input
            id={id ? `${id}-end` : undefined}
            name={name ? `${name}-end` : undefined}
            ref={endInputRef}
            type="text"
            className={`cs-datepicker-input cs-datepicker-range-end ${activeInput === 1 ? 'cs-datepicker-input-active' : ''}`}
            value={rangeInputValue[1]}
            onChange={handleRangeInputChange(1)}
            onClick={handleInputClick}
            onFocus={handleRangeInputFocus(1)}
            onBlur={handleInputBlur}
            placeholder="End date"
            disabled={disabled}
            required={required}
            aria-haspopup="true"
            aria-expanded={isOpen}
            aria-disabled={disabled}
          />
        </div>
        {allowClear && (rangeInputValue[0] || rangeInputValue[1]) && (
          <button
            type="button"
            className="cs-datepicker-clear-input"
            onClick={handleClearClick}
            aria-label="Clear dates"
          >
            &times;
          </button>
        )}
      </div>
      
      {isOpen && (
        <div className="cs-datepicker-calendar" ref={calendarRef}>
          {renderMonthHeader()}
          {renderDayNames()}
          {renderDays()}
          {renderFooter()}
        </div>
      )}
    </div>
  );
  
  // Return range picker or single date picker based on range prop
  return range ? renderRangeDatePicker() : renderSingleDatePicker();
};

export default DatePicker;


/**
 * DatePicker.scss
 * 
 * Styles for the custom date picker component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$info: #17a2b8;
$warning: #ffc107;
$danger: #dc3545;

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius: 4px;

// Transitions
$transition-base: all 0.2s ease-in-out;

// Base DatePicker styles
.cs-datepicker {
  position: relative;
  display: inline-block;
  font-family: $font-family;
  font-size: $font-size-base;
  line-height: $line-height-base;
  color: $gray-700;
  width: 280px;

  *, *::before, *::after {
    box-sizing: border-box;
  }

  // Input wrapper
  &-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    width: 100%;
  }

  // Input field
  &-input {
    display: block;
    width: 100%;
    height: calc(#{$spacer} * 4);
    padding: $spacer calc(#{$spacer} * 1.5);
    font-size: $font-size-base;
    font-family: $font-family;
    line-height: $line-height-base;
    color: $gray-700;
    background-color: $white;
    background-clip: padding-box;
    border: 1px solid $gray-400;
    border-radius: $border-radius;
    transition: $transition-base;
    appearance: none;

    &:focus {
      outline: none;
      border-color: $primary-color;
      box-shadow: 0 0 0 2px $primary-alpha;
    }

    &:disabled {
      background-color: $gray-200;
      opacity: 0.7;
      cursor: not-allowed;
    }

    &::placeholder {
      color: $gray-500;
      opacity: 1;
    }

    &-active {
      border-color: $primary-color;
      box-shadow: 0 0 0 2px $primary-alpha;
    }
  }

  // Clear input button
  &-clear-input {
    position: absolute;
    right: $spacer;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    padding: 0;
    font-size: 18px;
    line-height: 1;
    color: $gray-600;
    background: none;
    border: none;
    border-radius: 50%;
    cursor: pointer;

    &:hover {
      color: $danger;
    }

    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px $primary-alpha;
    }
  }

  // Calendar
  &-calendar {
    position: absolute;
    left: 0;
    z-index: 1000;
    width: 280px;
    padding: calc(#{$spacer} * 1.5);
    background-color: $white;
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    opacity: 1;
    visibility: visible;
  }

  // Header
  &-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: $spacer;

    &-left, &-right {
      display: flex;
    }

    &-content {
      display: flex;
      align-items: center;
      font-weight: bold;
    }
  }

  // Month and year dropdowns
  &-month-select, &-year-select {
    padding: $spacer/2 $spacer;
    margin: 0 $spacer/2;
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    background-color: $white;
    font-size: $font-size-base;
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23343a40' d='M6 8.825L1.175 4 2.238 2.938 6 6.7l3.763-3.763L10.825 4z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right $spacer center;
    background-size: 8px;
    padding-right: calc(#{$spacer} * 3);

    &:focus {
      outline: none;
      border-color: $primary-color;
    }
  }

  // Navigation buttons
  &-prev-year, &-prev-month, &-next-month, &-next-year {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    padding: 0;
    margin: 0 $spacer/4;
    background: none;
    border: none;
    border-radius: $border-radius;
    font-size: 16px;
    line-height: 1;
    color: $gray-600;
    cursor: pointer;
    transition: $transition-base;

    &:hover {
      background-color: $gray-200;
      color: $primary-color;
    }

    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px $primary-alpha;
    }
  }

  // Current month display
  &-current-month {
    font-weight: bold;
    font-size: $font-size-base;
    text-align: center;
    min-width: 120px;
  }

  // Weekdays row
  &-weekdays {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    margin-bottom: $spacer;

    &.show-week-numbers {
      grid-template-columns: auto repeat(7, 1fr);
    }
  }

  // Weekday name
  &-weekday {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 30px;
    font-size: 12px;
    font-weight: bold;
    color: $gray-600;

    &.cs-datepicker-week-number {
      color: $gray-500;
    }
  }

  // Days grid
  &-days {
    display: flex;
    flex-direction: column;
  }

  // Week row
  &-week {
    display: grid;
    grid-template-columns: repeat(7, 1fr);

    &.show-week-numbers {
      grid-template-columns: auto repeat(7, 1fr);
    }
  }

  // Week number
  &-week-number {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 32px;
    font-size: 12px;
    color: $gray-500;
  }

  // Day cell
  &-day {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 32px;
    padding: 0;
    border: none;
    background: none;
    font-size: $font-size-base;
    line-height: 1;
    border-radius: 50%;
    cursor: pointer;
    transition: $transition-base;

    &:hover:not(.cs-datepicker-day-disabled) {
      background-color: $gray-200;
    }

    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px $primary-alpha;
    }

    // Day states
    &-other-month {
      color: $gray-500;
    }

    &-today {
      font-weight: bold;
      color: $primary-color;
    }

    &-selected {
      background-color: $primary-color;
      color: $white;

      &:hover {
        background-color: $primary-dark;
      }
    }

    &-in-range {
      background-color: $primary-alpha;
      border-radius: 0;
    }

    &-range-start, &-range-end {
      background-color: $primary-color;
      color: $white;
      z-index: 1;
    }

    &-range-start {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }

    &-range-end {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    &-disabled {
      color: $gray-400;
      cursor: not-allowed;
      pointer-events: none;
    }

    &-highlighted {
      background-color: $primary-alpha-medium;
    }

    &-weekend {
      color: $gray-600;
    }
  }

  // Time picker
  &-time {
    border-top: 1px solid $gray-300;
    padding-top: $spacer;
    margin-top: $spacer;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  &-time-label {
    margin-bottom: $spacer/2;
    font-weight: bold;
    font-size: 12px;
    color: $gray-600;
  }

  &-time-selects {
    display: flex;
    align-items: center;
  }

  &-time-separator {
    margin: 0 $spacer/2;
    color: $gray-500;
  }

  &-select {
    padding: $spacer/2;
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    background-color: $white;
    font-size: 14px;
    appearance: none;
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23343a40' d='M6 8.825L1.175 4 2.238 2.938 6 6.7l3.763-3.763L10.825 4z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right $spacer/2 center;
    background-size: 8px;
    padding-right: calc(#{$spacer} * 2);
    width: 70px;

    &:focus {
      outline: none;
      border-color: $primary-color;
    }
  }

  // Footer
  &-footer {
    border-top: 1px solid $gray-300;
    padding-top: $spacer;
    margin-top: $spacer;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  &-footer-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: $spacer;
  }

  // Footer buttons
  &-today-button, &-now-button, &-clear-button {
    padding: $spacer/2 $spacer;
    background-color: $white;
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    font-size: 12px;
    cursor: pointer;
    transition: $transition-base;

    &:hover {
      background-color: $gray-200;
      border-color: $gray-400;
    }

    &:focus {
      outline: none;
      border-color: $primary-color;
      box-shadow: 0 0 0 2px $primary-alpha;
    }
  }

  &-today-button, &-now-button {
    color: $primary-color;
    
    &:hover {
      color: $primary-dark;
    }
  }

  &-clear-button {
    color: $gray-700;
    
    &:hover {
      color: $danger;
    }
  }

  // Range picker specific styles
  &-range {
    width: 340px;

    .cs-datepicker-calendar {
      width: 340px;}
  }

  &-range-inputs {
    display: flex;
    align-items: center;
    width: 100%;
  }

  &-range-separator {
    padding: 0 $spacer;
    color: $gray-600;
  }

  &-range-start, &-range-end {
    flex: 1;
  }

  // Screen reader helpers
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  // Responsive styles
  @media (max-width: 576px) {
    width: 100%;
    
    &-calendar {
      width: 100%;
    }
    
    &-range {
      width: 100%;
      
      .cs-datepicker-calendar {
        width: 100%;
      }
      
      &-inputs {
        flex-direction: column;
        align-items: stretch;
      }
      
      &-separator {
        padding: $spacer 0;
        text-align: center;
      }
    }
  }

  // Animation for calendar opening/closing
  &-calendar {
    transform-origin: top center;
    animation: cs-datepicker-open 0.2s ease-out;
  }

  @keyframes cs-datepicker-open {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  // Dark mode support
  &.cs-datepicker-dark {
    color: $gray-300;
    
    .cs-datepicker-input {
      color: $gray-300;
      background-color: $gray-800;
      border-color: $gray-700;
      
      &:focus {
        border-color: $primary-color;
        box-shadow: 0 0 0 2px rgba($primary-color, 0.3);
      }
      
      &:disabled {
        background-color: $gray-700;
      }
      
      &::placeholder {
        color: $gray-600;
      }
    }
    
    .cs-datepicker-clear-input {
      color: $gray-500;
      
      &:hover {
        color: $danger;
      }
    }
    
    .cs-datepicker-calendar {
      background-color: $gray-800;
      border-color: $gray-700;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .cs-datepicker-prev-year,
    .cs-datepicker-prev-month,
    .cs-datepicker-next-month,
    .cs-datepicker-next-year {
      color: $gray-500;
      
      &:hover {
        background-color: $gray-700;
        color: $primary-light;
      }
    }
    
    .cs-datepicker-current-month {
      color: $gray-300;
    }
    
    .cs-datepicker-weekday {
      color: $gray-500;
    }
    
    .cs-datepicker-day {
      color: $gray-300;
      
      &:hover:not(.cs-datepicker-day-disabled) {
        background-color: $gray-700;
      }
      
      &-other-month {
        color: $gray-600;
      }
      
      &-today {
        color: $primary-light;
      }
      
      &-selected {
        background-color: $primary-color;
        color: $white;
        
        &:hover {
          background-color: $primary-dark;
        }
      }
      
      &-in-range {
        background-color: rgba($primary-color, 0.3);
      }
      
      &-disabled {
        color: $gray-700;
      }
      
      &-highlighted {
        background-color: rgba($primary-color, 0.5);
      }
      
      &-weekend {
        color: $gray-500;
      }
    }
    
    .cs-datepicker-time {
      border-top-color: $gray-700;
    }
    
    .cs-datepicker-time-label {
      color: $gray-500;
    }
    
    .cs-datepicker-time-separator {
      color: $gray-600;
    }
    
    .cs-datepicker-select {
      border-color: $gray-700;
      background-color: $gray-800;
      color: $gray-300;
      
      option {
        background-color: $gray-800;
      }
    }
    
    .cs-datepicker-footer {
      border-top-color: $gray-700;
    }
    
    .cs-datepicker-today-button,
    .cs-datepicker-now-button,
    .cs-datepicker-clear-button {
      background-color: $gray-800;
      border-color: $gray-700;
      
      &:hover {
        background-color: $gray-700;
        border-color: $gray-600;
      }
    }
    
    .cs-datepicker-today-button,
    .cs-datepicker-now-button {
      color: $primary-light;
      
      &:hover {
        color: $primary-lighter;
      }
    }
    
    .cs-datepicker-clear-button {
      color: $gray-400;
      
      &:hover {
        color: $danger;
      }
    }
    
    .cs-datepicker-month-select,
    .cs-datepicker-year-select {
      border-color: $gray-700;
      background-color: $gray-800;
      color: $gray-300;
      
      option {
        background-color: $gray-800;
      }
    }
  }

  // High contrast mode for accessibility
  &.cs-datepicker-high-contrast {
    .cs-datepicker-input {
      border-width: 2px;
    }
    
    .cs-datepicker-day {
      &-selected {
        box-shadow: 0 0 0 2px $black;
      }
      
      &-in-range {
        border: 1px dashed $black;
      }
      
      &-today {
        text-decoration: underline;
      }
    }
    
    .cs-datepicker-today-button,
    .cs-datepicker-now-button,
    .cs-datepicker-clear-button {
      border-width: 2px;
    }
  }

  // RTL support
  &.cs-datepicker-rtl {
    direction: rtl;
    
    .cs-datepicker-input {
      padding-right: calc(#{$spacer} * 1.5);
      padding-left: calc(#{$spacer} * 3);
    }
    
    .cs-datepicker-clear-input {
      right: auto;
      left: $spacer;
    }
    
    .cs-datepicker-prev-year,
    .cs-datepicker-prev-month,
    .cs-datepicker-next-month,
    .cs-datepicker-next-year {
      transform: scaleX(-1);
    }
    
    .cs-datepicker-day {
      &-range-start {
        border-top-right-radius: 50%;
        border-bottom-right-radius: 50%;
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
      }
      
      &-range-end {
        border-top-left-radius: 50%;
        border-bottom-left-radius: 50%;
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
      }
    }
    
    .cs-datepicker-month-select,
    .cs-datepicker-year-select,
    .cs-datepicker-select {
      background-position: left $spacer/2 center;
      padding-right: $spacer;
      padding-left: calc(#{$spacer} * 2);
    }
  }

  // Print styles
  @media print {
    .cs-datepicker-calendar {
      display: none !important;
    }
    
    .cs-datepicker-input {
      border: 1px solid $gray-400 !important;
      box-shadow: none !important;
    }
  }

  // Focus-visible polyfill
  &-day:focus:not(:focus-visible) {
    box-shadow: none;
  }
  
  &-day:focus-visible {
    box-shadow: 0 0 0 2px $primary-alpha;
  }
  
  // Month view transition animation
  .cs-datepicker-month-animation-right {
    animation: cs-datepicker-slide-right 0.3s ease forwards;
  }
  
  .cs-datepicker-month-animation-left {
    animation: cs-datepicker-slide-left 0.3s ease forwards;
  }
  
  @keyframes cs-datepicker-slide-right {
    from {
      transform: translateX(-20px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
  
  @keyframes cs-datepicker-slide-left {
    from {
      transform: translateX(20px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  // Accessibility improvements
  &-day, 
  &-prev-year, 
  &-prev-month, 
  &-next-month, 
  &-next-year,
  &-today-button,
  &-now-button,
  &-clear-button,
  &-month-select,
  &-year-select,
  &-select {
    &:focus-visible {
      outline: 2px solid $primary-color;
      outline-offset: 2px;
    }
  }

  // Keyboard navigation indicators
  .cs-datepicker-keyboard-selected {
    box-shadow: 0 0 0 2px $primary-color;
  }

  // Touch device optimizations
  @media (pointer: coarse) {
    &-day,
    &-prev-year, 
    &-prev-month, 
    &-next-month, 
    &-next-year,
    &-today-button,
    &-now-button,
    &-clear-button {
      min-height: 44px;
      min-width: 44px;
    }
    
    &-day {
      padding: $spacer * 0.75;
    }
    
    &-weekday {
      height: 44px;
    }
    
    &-select {
      height: 44px;
    }
  }

  // iOS-specific fixes
  @supports (-webkit-touch-callout: none) {
    &-input {
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
    }
    
    &-select {
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
    }
  }

  // Custom themes
  &.cs-datepicker-primary {
    --cs-datepicker-primary: #{$primary-color};
    --cs-datepicker-primary-light: #{$primary-light};
    --cs-datepicker-primary-lighter: #{$primary-lighter};
    --cs-datepicker-primary-dark: #{$primary-dark};
    --cs-datepicker-primary-darker: #{$primary-darker};
    --cs-datepicker-primary-alpha: #{$primary-alpha};
  }
  
  &.cs-datepicker-success {
    --cs-datepicker-primary: #{$success};
    --cs-datepicker-primary-light: #{lighten($success, 20%)};
    --cs-datepicker-primary-lighter: #{lighten($success, 35%)};
    --cs-datepicker-primary-dark: #{darken($success, 10%)};
    --cs-datepicker-primary-darker: #{darken($success, 20%)};
    --cs-datepicker-primary-alpha: #{rgba($success, 0.2)};
    
    .cs-datepicker-input:focus,
    .cs-datepicker-day-selected,
    .cs-datepicker-day-in-range,
    .cs-datepicker-day-today,
    .cs-datepicker-today-button, 
    .cs-datepicker-now-button {
      border-color: var(--cs-datepicker-primary);
      color: var(--cs-datepicker-primary);
    }
    
    .cs-datepicker-day-selected {
      background-color: var(--cs-datepicker-primary);
      color: $white;
    }
    
    .cs-datepicker-day-in-range {
      background-color: var(--cs-datepicker-primary-alpha);
    }
  }
  
  &.cs-datepicker-info {
    --cs-datepicker-primary: #{$info};
    --cs-datepicker-primary-light: #{lighten($info, 20%)};
    --cs-datepicker-primary-lighter: #{lighten($info, 35%)};
    --cs-datepicker-primary-dark: #{darken($info, 10%)};
    --cs-datepicker-primary-darker: #{darken($info, 20%)};
    --cs-datepicker-primary-alpha: #{rgba($info, 0.2)};
    
    .cs-datepicker-input:focus,
    .cs-datepicker-day-selected,
    .cs-datepicker-day-in-range,
    .cs-datepicker-day-today,
    .cs-datepicker-today-button, 
    .cs-datepicker-now-button {
      border-color: var(--cs-datepicker-primary);
      color: var(--cs-datepicker-primary);
    }
    
    .cs-datepicker-day-selected {
      background-color: var(--cs-datepicker-primary);
      color: $white;
    }
    
    .cs-datepicker-day-in-range {
      background-color: var(--cs-datepicker-primary-alpha);
    }
  }
  
  &.cs-datepicker-warning {
    --cs-datepicker-primary: #{$warning};
    --cs-datepicker-primary-light: #{lighten($warning, 20%)};
    --cs-datepicker-primary-lighter: #{lighten($warning, 35%)};
    --cs-datepicker-primary-dark: #{darken($warning, 10%)};
    --cs-datepicker-primary-darker: #{darken($warning, 20%)};
    --cs-datepicker-primary-alpha: #{rgba($warning, 0.2)};
    
    .cs-datepicker-input:focus,
    .cs-datepicker-day-selected,
    .cs-datepicker-day-in-range,
    .cs-datepicker-day-today,
    .cs-datepicker-today-button, 
    .cs-datepicker-now-button {
      border-color: var(--cs-datepicker-primary);
      color: var(--cs-datepicker-primary);
    }
    
    .cs-datepicker-day-selected {
      background-color: var(--cs-datepicker-primary);
      color: $gray-900;
    }
    
    .cs-datepicker-day-in-range {
      background-color: var(--cs-datepicker-primary-alpha);
    }
  }
  
  &.cs-datepicker-danger {
    --cs-datepicker-primary: #{$danger};
    --cs-datepicker-primary-light: #{lighten($danger, 20%)};
    --cs-datepicker-primary-lighter: #{lighten($danger, 35%)};
    --cs-datepicker-primary-dark: #{darken($danger, 10%)};
    --cs-datepicker-primary-darker: #{darken($danger, 20%)};
    --cs-datepicker-primary-alpha: #{rgba($danger, 0.2)};
    
    .cs-datepicker-input:focus,
    .cs-datepicker-day-selected,
    .cs-datepicker-day-in-range,
    .cs-datepicker-day-today,
    .cs-datepicker-today-button, 
    .cs-datepicker-now-button {
      border-color: var(--cs-datepicker-primary);
      color: var(--cs-datepicker-primary);
    }
    
    .cs-datepicker-day-selected {
      background-color: var(--cs-datepicker-primary);
      color: $white;
    }
    
    .cs-datepicker-day-in-range {
      background-color: var(--cs-datepicker-primary-alpha);
    }
  }
}


/**
 * TimePicker.tsx
 * 
 * Custom time picker component for the CSTestForge framework.
 * Provides a customizable time picker with hours, minutes, and seconds selection.
 */

import React, { useState, useRef, useEffect, useCallback } from 'react';
import './TimePicker.scss';

/**
 * Time change handler type
 */
export type TimeChangeHandler = (time: { hours: number; minutes: number; seconds: number } | null) => void;

/**
 * Time picker props interface
 */
export interface TimePickerProps {
  /**
   * Selected time (controlled component)
   */
  value?: { hours: number; minutes: number; seconds: number } | null;
  
  /**
   * Default time (uncontrolled component)
   */
  defaultValue?: { hours: number; minutes: number; seconds: number } | null;
  
  /**
   * Callback when time changes
   */
  onChange?: TimeChangeHandler;
  
  /**
   * Whether the time picker is disabled
   */
  disabled?: boolean;
  
  /**
   * Custom placeholder text
   */
  placeholder?: string;
  
  /**
   * Whether to display a clear button
   */
  allowClear?: boolean;
  
  /**
   * Whether to show seconds
   */
  showSeconds?: boolean;
  
  /**
   * Whether to use 12-hour format
   */
  use12Hours?: boolean;
  
  /**
   * Custom time format
   */
  format?: string;
  
  /**
   * Hour step
   */
  hourStep?: number;
  
  /**
   * Minute step
   */
  minuteStep?: number;
  
  /**
   * Second step
   */
  secondStep?: number;
  
  /**
   * Minimum selectable time
   */
  minTime?: { hours: number; minutes: number; seconds: number };
  
  /**
   * Maximum selectable time
   */
  maxTime?: { hours: number; minutes: number; seconds: number };
  
  /**
   * Whether to auto-focus the input
   */
  autoFocus?: boolean;
  
  /**
   * Whether to open the picker on focus
   */
  openOnFocus?: boolean;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Callback when panel opens
   */
  onOpenChange?: (open: boolean) => void;
  
  /**
   * Callback when focus changes
   */
  onFocus?: React.FocusEventHandler<HTMLInputElement>;
  
  /**
   * Callback when blur occurs
   */
  onBlur?: React.FocusEventHandler<HTMLInputElement>;
  
  /**
   * Custom now button text
   */
  nowButtonLabel?: string;
  
  /**
   * Custom clear button text
   */
  clearButtonLabel?: string;
  
  /**
   * Position of the popup
   */
  popupPosition?: 'top' | 'bottom' | 'auto';
  
  /**
   * Whether the input is required
   */
  required?: boolean;
  
  /**
   * Input name attribute
   */
  name?: string;
  
  /**
   * Input id attribute
   */
  id?: string;
}

/**
 * TimePicker component
 */
const TimePicker: React.FC<TimePickerProps> = (props) => {
  const {
    value,
    defaultValue,
    onChange,
    disabled = false,
    placeholder = 'Select time',
    allowClear = true,
    showSeconds = true,
    use12Hours = false,
    format = use12Hours ? 'hh:mm:ss A' : 'HH:mm:ss',
    hourStep = 1,
    minuteStep = 1,
    secondStep = 1,
    minTime,
    maxTime,
    autoFocus = false,
    openOnFocus = true,
    className = '',
    style,
    onOpenChange,
    onFocus,
    onBlur,
    nowButtonLabel = 'Now',
    clearButtonLabel = 'Clear',
    popupPosition = 'auto',
    required = false,
    name,
    id
  } = props;

  // Component state
  const [isOpen, setIsOpen] = useState<boolean>(false);
  const [inputValue, setInputValue] = useState<string>('');
  const [selectedTime, setSelectedTime] = useState<{ hours: number; minutes: number; seconds: number } | null>(
    defaultValue || null
  );
  const [hours, setHours] = useState<number>(defaultValue?.hours || 0);
  const [minutes, setMinutes] = useState<number>(defaultValue?.minutes || 0);
  const [seconds, setSeconds] = useState<number>(defaultValue?.seconds || 0);
  const [ampm, setAmpm] = useState<'AM' | 'PM'>(
    defaultValue ? (defaultValue.hours >= 12 ? 'PM' : 'AM') : 'AM'
  );
  
  // Refs
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const panelRef = useRef<HTMLDivElement>(null);
  
  // Effect for controlled component
  useEffect(() => {
    if (value !== undefined) {
      setSelectedTime(value);
      setInputValue(formatTime(value));
      
      if (value) {
        setHours(value.hours);
        setMinutes(value.minutes);
        setSeconds(value.seconds);
        setAmpm(value.hours >= 12 ? 'PM' : 'AM');
      }
    }
  }, [value, format, use12Hours]);
  
  // Effect for handling clicks outside the component to close the panel
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        containerRef.current &&
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
        if (onOpenChange) {
          onOpenChange(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [onOpenChange]);
  
  // Effect for positioning the popup
  useEffect(() => {
    if (isOpen && panelRef.current && containerRef.current) {
      const containerRect = containerRef.current.getBoundingClientRect();
      const panelRect = panelRef.current.getBoundingClientRect();
      
      const spaceBelow = window.innerHeight - containerRect.bottom;
      const spaceAbove = containerRect.top;
      
      let position = popupPosition;
      
      if (position === 'auto') {
        if (spaceBelow >= panelRect.height || spaceBelow >= spaceAbove) {
          position = 'bottom';
        } else {
          position = 'top';
        }
      }
      
      if (position === 'bottom') {
        panelRef.current.style.top = `${containerRect.height}px`;
        panelRef.current.style.bottom = 'auto';
      } else {
        panelRef.current.style.bottom = `${containerRect.height}px`;
        panelRef.current.style.top = 'auto';
      }
    }
  }, [isOpen, popupPosition]);
  
  // Helper function to check if a time is valid
  const isTimeValid = (hours: number, minutes: number, seconds: number): boolean => {
    // Check if time is within min/max range
    if (minTime) {
      const minTotalSeconds = minTime.hours * 3600 + minTime.minutes * 60 + minTime.seconds;
      const currentTotalSeconds = hours * 3600 + minutes * 60 + seconds;
      
      if (currentTotalSeconds < minTotalSeconds) {
        return false;
      }
    }
    
    if (maxTime) {
      const maxTotalSeconds = maxTime.hours * 3600 + maxTime.minutes * 60 + maxTime.seconds;
      const currentTotalSeconds = hours * 3600 + minutes * 60 + seconds;
      
      if (currentTotalSeconds > maxTotalSeconds) {
        return false;
      }
    }
    
    return true;
  };
  
  // Helper function to format time
  const formatTime = (time: { hours: number; minutes: number; seconds: number } | null): string => {
    if (!time) return '';
    
    let { hours, minutes, seconds } = time;
    let formattedTime = format;
    
    // Handle 12-hour format
    if (use12Hours) {
      const period = hours >= 12 ? 'PM' : 'AM';
      const hours12 = hours % 12 || 12;
      
      // Replace hours
      formattedTime = formattedTime.replace(/hh/g, hours12.toString().padStart(2, '0'));
      formattedTime = formattedTime.replace(/h/g, hours12.toString());
      
      // Replace AM/PM
      formattedTime = formattedTime.replace(/A/g, period);
    } else {
      // Replace hours
      formattedTime = formattedTime.replace(/HH/g, hours.toString().padStart(2, '0'));
      formattedTime = formattedTime.replace(/H/g, hours.toString());
    }
    
    // Replace minutes
    formattedTime = formattedTime.replace(/mm/g, minutes.toString().padStart(2, '0'));
    formattedTime = formattedTime.replace(/m/g, minutes.toString());
    
    // Replace seconds
    formattedTime = formattedTime.replace(/ss/g, seconds.toString().padStart(2, '0'));
    formattedTime = formattedTime.replace(/s/g, seconds.toString());
    
    return formattedTime;
  };
  
  // Helper function to parse time from string
  const parseTime = (timeString: string): { hours: number; minutes: number; seconds: number } | null => {
    if (!timeString) return null;
    
    // Initialize values
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    let isPM = false;
    
    // Check if the format includes AM/PM
    if (timeString.toLowerCase().includes('am') || timeString.toLowerCase().includes('pm')) {
      isPM = timeString.toLowerCase().includes('pm');
      timeString = timeString.replace(/am|pm/i, '').trim();
    }
    
    // Split the time string by colons
    const parts = timeString.split(':');
    
    // Parse hours
    if (parts.length > 0) {
      hours = parseInt(parts[0], 10);
      
      // Convert to 24-hour format if necessary
      if (isPM && hours < 12) {
        hours += 12;
      } else if (!isPM && hours === 12) {
        hours = 0;
      }
    }
    
    // Parse minutes
    if (parts.length > 1) {
      minutes = parseInt(parts[1], 10);
    }
    
    // Parse seconds
    if (parts.length > 2) {
      seconds = parseInt(parts[2], 10);
    }
    
    // Validate the parsed time
    if (
      isNaN(hours) || isNaN(minutes) || isNaN(seconds) ||
      hours < 0 || hours > 23 ||
      minutes < 0 || minutes > 59 ||
      seconds < 0 || seconds > 59
    ) {
      return null;
    }
    
    return { hours, minutes, seconds };
  };
  
  // Event handlers
  const handleInputClick = () => {
    if (!disabled) {
      setIsOpen(!isOpen);
      if (onOpenChange) {
        onOpenChange(!isOpen);
      }
    }
  };
  
  const handleInputFocus = (e: React.FocusEvent<HTMLInputElement>) => {
    if (openOnFocus && !disabled) {
      setIsOpen(true);
      if (onOpenChange) {
        onOpenChange(true);
      }
    }
    
    if (onFocus) {
      onFocus(e);
    }
  };
  
  const handleInputBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    // Do not close panel on input blur
    // The panel will be closed by clicking outside
    
    if (onBlur) {
      onBlur(e);
    }
  };
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    
    const time = parseTime(value);
    if (time) {
      setSelectedTime(time);
      setHours(time.hours);
      setMinutes(time.minutes);
      setSeconds(time.seconds);
      setAmpm(time.hours >= 12 ? 'PM' : 'AM');
      
      if (onChange) {
        onChange(time);
      }
    }
  };
  
  const handleHoursChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    let newHours = parseInt(e.target.value, 10);
    
    // Adjust for 12-hour format if necessary
    if (use12Hours && ampm === 'PM' && newHours < 12) {
      newHours += 12;
    } else if (use12Hours && ampm === 'AM' && newHours === 12) {
      newHours = 0;
    }
    
    if (!isTimeValid(newHours, minutes, seconds)) {
      return;
    }
    
    setHours(newHours);
    
    const newTime = { hours: newHours, minutes, seconds };
    setSelectedTime(newTime);
    setInputValue(formatTime(newTime));
    
    if (onChange) {
      onChange(newTime);
    }
  };
  
  const handleMinutesChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newMinutes = parseInt(e.target.value, 10);
    
    if (!isTimeValid(hours, newMinutes, seconds)) {
      return;
    }
    
    setMinutes(newMinutes);
    
    const newTime = { hours, minutes: newMinutes, seconds };
    setSelectedTime(newTime);
    setInputValue(formatTime(newTime));
    
    if (onChange) {
      onChange(newTime);
    }
  };
  
  const handleSecondsChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newSeconds = parseInt(e.target.value, 10);
    
    if (!isTimeValid(hours, minutes, newSeconds)) {
      return;
    }
    
    setSeconds(newSeconds);
    
    const newTime = { hours, minutes, seconds: newSeconds };
    setSelectedTime(newTime);
    setInputValue(formatTime(newTime));
    
    if (onChange) {
      onChange(newTime);
    }
  };
  
  const handleAmPmChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newAmPm = e.target.value as 'AM' | 'PM';
    setAmpm(newAmPm);
    
    let newHours = hours;
    if (newAmPm === 'PM' && hours < 12) {
      newHours = hours + 12;
    } else if (newAmPm === 'AM' && hours >= 12) {
      newHours = hours - 12;
    }
    
    if (!isTimeValid(newHours, minutes, seconds)) {
      return;
    }
    
    setHours(newHours);
    
    const newTime = { hours: newHours, minutes, seconds };
    setSelectedTime(newTime);
    setInputValue(formatTime(newTime));
    
    if (onChange) {
      onChange(newTime);
    }
  };
  
  const handleNowClick = () => {
    const now = new Date();
    const newHours = now.getHours();
    const newMinutes = now.getMinutes();
    const newSeconds = now.getSeconds();
    
    setHours(newHours);
    setMinutes(newMinutes);
    setSeconds(newSeconds);
    setAmpm(newHours >= 12 ? 'PM' : 'AM');
    
    const newTime = { hours: newHours, minutes: newMinutes, seconds: newSeconds };
    setSelectedTime(newTime);
    setInputValue(formatTime(newTime));
    
    if (onChange) {
      onChange(newTime);
    }
  };
  
  const handleClearClick = () => {
    setSelectedTime(null);
    setInputValue('');
    
    if (onChange) {
      onChange(null);
    }
    
    setIsOpen(false);
    if (onOpenChange) {
      onOpenChange(false);
    }
  };
  
  // Generate arrays for time dropdowns
  const hoursArray = Array.from(
    { length: use12Hours ? 12 : 24 / hourStep },
    (_, i) => use12Hours ? (i === 0 ? 12 : i * hourStep) : i * hourStep
  );
  
  const minutesArray = Array.from(
    { length: 60 / minuteStep },
    (_, i) => i * minuteStep
  );
  
  const secondsArray = Array.from(
    { length: 60 / secondStep },
    (_, i) => i * secondStep
  );
  
  // Helper to get display hour in 12-hour format
  const getDisplayHour = (hour: number): number => {
    if (!use12Hours) return hour;
    
    if (hour === 0) {
      return 12;
    } else if (hour > 12) {
      return hour - 12;
    } else {
      return hour;
    }
  };
  
  // Render time picker panel
  const renderTimePickerPanel = () => {
    return (
      <div className="cs-timepicker-panel" ref={panelRef}>
        <div className="cs-timepicker-content">
          <div className="cs-timepicker-selects">
            {/* Hours Select */}
            <div className="cs-timepicker-select-container">
              <div className="cs-timepicker-select-label">Hours</div>
              <select
                className="cs-timepicker-select"
                value={getDisplayHour(hours)}
                onChange={handleHoursChange}
                aria-label="Hours"
              >
                {hoursArray.map(hour => (
                  <option key={`hour-${hour}`} value={hour}>
                    {hour.toString().padStart(2, '0')}
                  </option>
                ))}
              </select>
            </div>
            
            {/* Minutes Select */}
            <div className="cs-timepicker-select-container">
              <div className="cs-timepicker-select-label">Minutes</div>
              <select
                className="cs-timepicker-select"
                value={minutes}
                onChange={handleMinutesChange}
                aria-label="Minutes"
              >
                {minutesArray.map(minute => (
                  <option key={`minute-${minute}`} value={minute}>
                    {minute.toString().padStart(2, '0')}
                  </option>
                ))}
              </select>
            </div>
            
            {/* Seconds Select (if enabled) */}
            {showSeconds && (
              <div className="cs-timepicker-select-container">
                <div className="cs-timepicker-select-label">Seconds</div>
                <select
                  className="cs-timepicker-select"
                  value={seconds}
                  onChange={handleSecondsChange}
                  aria-label="Seconds"
                >
                  {secondsArray.map(second => (
                    <option key={`second-${second}`} value={second}>
                      {second.toString().padStart(2, '0')}
                    </option>
                  ))}
                </select>
              </div>
            )}
            
            {/* AM/PM Select (if using 12-hour format) */}
            {use12Hours && (
              <div className="cs-timepicker-select-container">
                <div className="cs-timepicker-select-label">AM/PM</div>
                <select
                  className="cs-timepicker-select"
                  value={ampm}
                  onChange={handleAmPmChange}
                  aria-label="AM/PM"
                >
                  <option value="AM">AM</option>
                  <option value="PM">PM</option>
                </select>
              </div>
            )}
          </div>
          
          {/* Footer with buttons */}
          <div className="cs-timepicker-footer">
            <div className="cs-timepicker-footer-buttons">
              <button
                type="button"
                className="cs-timepicker-now-button"
                onClick={handleNowClick}
                aria-label={nowButtonLabel}
              >
                {nowButtonLabel}
              </button>
              
              {allowClear && selectedTime && (
                <button
                  type="button"
                  className="cs-timepicker-clear-button"
                  onClick={handleClearClick}
                  aria-label={clearButtonLabel}
                >
                  {clearButtonLabel}
                </button>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  };
  
  // Render the component
  return (
    <div
      className={`cs-timepicker ${className}`}
      style={style}
      ref={containerRef}
    >
      <div className="cs-timepicker-input-wrapper">
        <input
          id={id}
          name={name}
          ref={inputRef}
          type="text"
          className="cs-timepicker-input"
          value={inputValue}
          onChange={handleInputChange}
          onClick={handleInputClick}
          onFocus={handleInputFocus}
          onBlur={handleInputBlur}
          placeholder={placeholder}
          disabled={disabled}
          autoFocus={autoFocus}
          required={required}
          aria-haspopup="true"
          aria-expanded={isOpen}
          aria-disabled={disabled}
        />
        {allowClear && inputValue && (
          <button
            type="button"
            className="cs-timepicker-clear-input"
            onClick={handleClearClick}
            aria-label="Clear time"
          >
            &times;
          </button>
        )}
      </div>
      
      {isOpen && renderTimePickerPanel()}
    </div>
  );
};

export default TimePicker;


/**
 * TimePicker.scss
 * 
 * Styles for the custom time picker component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$info: #17a2b8;
$warning: #ffc107;
$danger: #dc3545;

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius: 4px;

// Transitions
$transition-base: all 0.2s ease-in-out;

// Base TimePicker styles
.cs-timepicker {
  position: relative;
  display: inline-block;
  font-family: $font-family;
  font-size: $font-size-base;
  line-height: $line-height-base;
  color: $gray-700;
  width: 200px;

  *, *::before, *::after {
    box-sizing: border-box;
  }

  // Input wrapper
  &-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    width: 100%;
  }

  // Input field
  &-input {
    display: block;
    width: 100%;
    height: calc(#{$spacer} * 4);
    padding: $spacer calc(#{$spacer} * 1.5);
    font-size: $font-size-base;
    font-family: $font-family;
    line-height: $line-height-base;
    color: $gray-700;
    background-color: $white;
    background-clip: padding-box;
    border: 1px solid $gray-400;
    border-radius: $border-radius;
    transition: $transition-base;
    appearance: none;

    &:focus {
      outline: none;
      border-color: $primary-color;
      box-shadow: 0 0 0 2px $primary-alpha;
    }

    &:disabled {
      background-color: $gray-200;
      opacity: 0.7;
      cursor: not-allowed;
    }

    &::placeholder {
      color: $gray-500;
      opacity: 1;
    }
  }

  // Clear input button
  &-clear-input {
    position: absolute;
    right: $spacer;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    padding: 0;
    font-size: 18px;
    line-height: 1;
    color: $gray-600;
    background: none;
    border: none;
    border-radius: 50%;
    cursor: pointer;

    &:hover {
      color: $danger;
    }

    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px $primary-alpha;
    }
  }

  // Panel
  &-panel {
    position: absolute;
    left: 0;
    z-index: 1000;
    min-width: 250px;
    padding: calc(#{$spacer} * 1.5);
    background-color: $white;
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    opacity: 1;
    visibility: visible;
    transform-origin: top center;
    animation: cs-timepicker-open 0.2s ease-out;
  }

  // Panel content
  &-content {
    display: flex;
    flex-direction: column;
  }

  // Selects container
  &-selects {
    display: flex;
    justify-content: space-between;
    margin-bottom: $spacer * 2;
  }

  // Select container
  &-select-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 $spacer/2;
  }

  // Select label
  &-select-label {
    margin-bottom: $spacer/2;
    font-size: 12px;
    color: $gray-600;
  }

  // Select dropdown
  &-select {
    width: 60px;
    padding: $spacer/2 $spacer;
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    background-color: $white;
    font-size: $font-size-base;
    text-align: center;
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23343a40' d='M6 8.825L1.175 4 2.238 2.938 6 6.7l3.763-3.763L10.825 4z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right $spacer/2 center;
    background-size: 8px;
    padding-right: calc(#{$spacer} * 2);

    &:focus {
      outline: none;
      border-color: $primary-color;
      box-shadow: 0 0 0 2px $primary-alpha;
    }

    &:disabled {
      background-color: $gray-200;
      opacity: 0.7;
      cursor: not-allowed;
    }
  }

  // Footer
  &-footer {
    display: flex;
    justify-content: space-between;
    border-top: 1px solid $gray-300;
    padding-top: $spacer;
    margin-top: $spacer;
  }

  // Footer buttons
  &-footer-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: $spacer;
  }

  // Button styles
  &-now-button, &-clear-button {
    padding: $spacer/2 $spacer;
    background-color: $white;
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    font-size: 12px;
    cursor: pointer;
    transition: $transition-base;

    &:hover {
      background-color: $gray-200;
      border-color: $gray-400;
    }

    &:focus {
      outline: none;
      border-color: $primary-color;
      box-shadow: 0 0 0 2px $primary-alpha;
    }
  }

  &-now-button {
    color: $primary-color;
    
    &:hover {
      color: $primary-dark;
    }
  }

  &-clear-button {
    color: $gray-700;
    
    &:hover {
      color: $danger;
    }
  }

  // Animation for panel opening/closing
  @keyframes cs-timepicker-open {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  // Dark mode support
  &.cs-timepicker-dark {
    color: $gray-300;
    
    .cs-timepicker-input {
      color: $gray-300;
      background-color: $gray-800;
      border-color: $gray-700;
      
      &:focus {
        border-color: $primary-color;
        box-shadow: 0 0 0 2px rgba($primary-color, 0.3);
      }
      
      &:disabled {
        background-color: $gray-700;
      }
      
      &::placeholder {
        color: $gray-600;
      }
    }
    
    .cs-timepicker-clear-input {
      color: $gray-500;
      
      &:hover {
        color: $danger;
      }
    }
    
    .cs-timepicker-panel {
      background-color: $gray-800;
      border-color: $gray-700;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .cs-timepicker-select-label {
      color: $gray-500;
    }
    
    .cs-timepicker-select {
      border-color: $gray-700;
      background-color: $gray-800;
      color: $gray-300;
      
      option {
        background-color: $gray-800;
      }
    }
    
    .cs-timepicker-footer {
      border-top-color: $gray-700;
    }
    
    .cs-timepicker-now-button,
    .cs-timepicker-clear-button {
      background-color: $gray-800;
      border-color: $gray-700;
      
      &:hover {
        background-color: $gray-700;
        border-color: $gray-600;
      }
    }
    
    .cs-timepicker-now-button {
      color: $primary-light;
      
      &:hover {
        color: $primary-lighter;
      }
    }
    
    .cs-timepicker-clear-button {
      color: $gray-400;
      
      &:hover {
        color: $danger;
      }
    }
  }

  // High contrast mode for accessibility
  &.cs-timepicker-high-contrast {
    .cs-timepicker-input {
      border-width: 2px;
    }
    
    .cs-timepicker-select {
      border-width: 2px;
    }
    
    .cs-timepicker-now-button,
    .cs-timepicker-clear-button {
      border-width: 2px;
    }
  }

  // RTL support
  &.cs-timepicker-rtl {
    direction: rtl;
    
    .cs-timepicker-input {
      padding-right: calc(#{$spacer} * 1.5);
      padding-left: calc(#{$spacer} * 3);
    }
    
    .cs-timepicker-clear-input {
      right: auto;
      left: $spacer;
    }
    
    .cs-timepicker-select {
      background-position: left $spacer/2 center;
      padding-right: $spacer;
      padding-left: calc(#{$spacer} * 2);
    }
  }

  // Print styles
  @media print {
    .cs-timepicker-panel {
      display: none !important;
    }
    
    .cs-timepicker-input {
      border: 1px solid $gray-400 !important;
      box-shadow: none !important;
    }
  }

  // Accessibility improvements
  &-now-button,
  &-clear-button,
  &-select {
    &:focus-visible {
      outline: 2px solid $primary-color;
      outline-offset: 2px;
    }
  }

  // Touch device optimizations
  @media (pointer: coarse) {
    &-now-button,
    &-clear-button {
      min-height: 44px;
      min-width: 44px;
    }
    
    &-select {
      height: 44px;
      padding-top: $spacer;
      padding-bottom: $spacer;
    }
  }

  // iOS-specific fixes
  @supports (-webkit-touch-callout: none) {
    &-input {
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
    }
    
    &-select {
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
    }
  }

  // Custom themes
  &.cs-timepicker-primary {
    --cs-timepicker-primary: #{$primary-color};
    --cs-timepicker-primary-light: #{$primary-light};
    --cs-timepicker-primary-lighter: #{$primary-lighter};
    --cs-timepicker-primary-dark: #{$primary-dark};
    --cs-timepicker-primary-darker: #{$primary-darker};
    --cs-timepicker-primary-alpha: #{$primary-alpha};
  }
  
  &.cs-timepicker-success {
    --cs-timepicker-primary: #{$success};
    --cs-timepicker-primary-light: #{lighten($success, 20%)};
    --cs-timepicker-primary-lighter: #{lighten($success, 35%)};
    --cs-timepicker-primary-dark: #{darken($success, 10%)};
    --cs-timepicker-primary-darker: #{darken($success, 20%)};
    --cs-timepicker-primary-alpha: #{rgba($success, 0.2)};
    
    .cs-timepicker-input:focus,
    .cs-timepicker-now-button {
      border-color: var(--cs-timepicker-primary);
      color: var(--cs-timepicker-primary);
    }
  }
  
  &.cs-timepicker-info {
    --cs-timepicker-primary: #{$info};
    --cs-timepicker-primary-light: #{lighten($info, 20%)};
    --cs-timepicker-primary-lighter: #{lighten($info, 35%)};
    --cs-timepicker-primary-dark: #{darken($info, 10%)};
    --cs-timepicker-primary-darker: #{darken($info, 20%)};
    --cs-timepicker-primary-alpha: #{rgba($info, 0.2)};
    
    .cs-timepicker-input:focus,
    .cs-timepicker-now-button {
      border-color: var(--cs-timepicker-primary);
      color: var(--cs-timepicker-primary);
    }
  }
  
  &.cs-timepicker-warning {
    --cs-timepicker-primary: #{$warning};
    --cs-timepicker-primary-light: #{lighten($warning, 20%)};
    --cs-timepicker-primary-lighter: #{lighten($warning, 35%)};
    --cs-timepicker-primary-dark: #{darken($warning, 10%)};
    --cs-timepicker-primary-darker: #{darken($warning, 20%)};
    --cs-timepicker-primary-alpha: #{rgba($warning, 0.2)};
    
    .cs-timepicker-input:focus,
    .cs-timepicker-now-button {
      border-color: var(--cs-timepicker-primary);
      color: var(--cs-timepicker-primary);
    }
  }
  
  &.cs-timepicker-danger {
    --cs-timepicker-primary: #{$danger};
    --cs-timepicker-primary-light: #{lighten($danger, 20%)};
    --cs-timepicker-primary-lighter: #{lighten($danger, 35%)};
    --cs-timepicker-primary-dark: #{darken($danger, 10%)};
    --cs-timepicker-primary-darker: #{darken($danger, 20%)};
    --cs-timepicker-primary-alpha: #{rgba($danger, 0.2)};
    
    .cs-timepicker-input:focus,
    .cs-timepicker-now-button {
      border-color: var(--cs-timepicker-primary);
      color: var(--cs-timepicker-primary);
    }
  }

  // Responsive styles
  @media (max-width: 576px) {
    width: 100%;
    
    &-panel {
      width: 100%;
      min-width: unset;
    }
    
    &-selects {
      flex-direction: column;
      align-items: center;
    }
    
    &-select-container {
      margin: $spacer 0;
      width: 100%;
    }
    
    &-select {
      width: 100%;
    }
  }
}


/**
 * FileUpload.tsx
 * 
 * Custom file upload component for the CSTestForge framework.
 * Provides a customizable file upload with drag and drop, preview, and validation.
 */

import React, { useState, useRef, useEffect, useCallback } from 'react';
import './FileUpload.scss';

/**
 * File types enum
 */
export enum FileType {
  ANY = 'any',
  IMAGE = 'image',
  DOCUMENT = 'document',
  VIDEO = 'video',
  AUDIO = 'audio',
  ARCHIVE = 'archive',
  SPREADSHEET = 'spreadsheet'
}

/**
 * File status enum
 */
export enum FileStatus {
  READY = 'ready',
  UPLOADING = 'uploading',
  DONE = 'done',
  ERROR = 'error'
}

/**
 * File info interface
 */
export interface FileInfo {
  /**
   * File object
   */
  file: File;
  
  /**
   * File unique id
   */
  uid: string;
  
  /**
   * File status
   */
  status: FileStatus;
  
  /**
   * Error message (if status is ERROR)
   */
  error?: string;
  
  /**
   * Upload progress (0-100)
   */
  progress: number;
  
  /**
   * Preview URL
   */
  previewUrl?: string;
}

/**
 * File validation result interface
 */
export interface FileValidationResult {
  /**
   * Whether the file is valid
   */
  isValid: boolean;
  
  /**
   * Error message (if not valid)
   */
  errorMessage?: string;
}

/**
 * File size units
 */
export type FileSizeUnit = 'B' | 'KB' | 'MB' | 'GB';

/**
 * File upload props interface
 */
export interface FileUploadProps {
  /**
   * Callback when files change
   */
  onChange?: (fileList: FileInfo[]) => void;
  
  /**
   * Callback when file upload starts
   */
  onUploadStart?: (file: FileInfo) => void;
  
  /**
   * Callback when file upload progresses
   */
  onUploadProgress?: (file: FileInfo, percent: number) => void;
  
  /**
   * Callback when file upload completes
   */
  onUploadComplete?: (file: FileInfo) => void;
  
  /**
   * Callback when file upload fails
   */
  onUploadError?: (file: FileInfo, error: Error) => void;
  
  /**
   * Callback when file preview is generated
   */
  onPreviewGenerated?: (file: FileInfo, previewUrl: string) => void;
  
  /**
   * Whether the file upload is disabled
   */
  disabled?: boolean;
  
  /**
   * Whether to accept multiple files
   */
  multiple?: boolean;
  
  /**
   * Whether to allow drag and drop
   */
  dragDrop?: boolean;
  
  /**
   * Custom placeholder text for drag area
   */
  dragPlaceholder?: string;
  
  /**
   * Custom text for the drop area when dragging
   */
  dropPlaceholder?: string;
  
  /**
   * Custom button text
   */
  buttonText?: string;
  
  /**
   * Whether to show file preview
   */
  showPreview?: boolean;
  
  /**
   * Preview sizes
   */
  previewSize?: number;
  
  /**
   * Whether to show file list
   */
  showFileList?: boolean;
  
  /**
   * Whether to automatically upload files
   */
  autoUpload?: boolean;
  
  /**
   * Upload URL
   */
  uploadUrl?: string;
  
  /**
   * HTTP method for upload
   */
  method?: 'POST' | 'PUT';
  
  /**
   * Name of the file field in form data
   */
  fieldName?: string;
  
  /**
   * Additional headers for upload
   */
  headers?: Record<string, string>;
  
  /**
   * Additional form data for upload
   */
  data?: Record<string, string>;
  
  /**
   * Max count of files to upload
   */
  maxCount?: number;
  
  /**
   * File types to accept
   */
  accept?: string;
  
  /**
   * Whether to filter accepted files (in addition to accept attribute)
   */
  acceptType?: FileType | FileType[];
  
  /**
   * Minimum file size
   */
  minSize?: number;
  
  /**
   * Minimum file size unit
   */
  minSizeUnit?: FileSizeUnit;
  
  /**
   * Maximum file size
   */
  maxSize?: number;
  
  /**
   * Maximum file size unit
   */
  maxSizeUnit?: FileSizeUnit;
  
  /**
   * Custom validation function
   */
  customValidation?: (file: File) => FileValidationResult;
  
  /**
   * Custom HTTP request function
   * If provided, will override the default XHR upload
   */
  customRequest?: (options: {
    file: File;
    onProgress: (percent: number) => void;
    onSuccess: (response: any) => void;
    onError: (error: Error) => void;
  }) => void;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Custom icon component
   */
  customIcon?: React.ReactNode;
  
  /**
   * Custom file item render function
   */
  customItemRender?: (file: FileInfo, remove: () => void) => React.ReactNode;
  
  /**
   * Additional props to pass to input element
   */
  inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
  
  /**
   * Whether to show remove button for each file
   */
  showRemoveButton?: boolean;
  
  /**
   * Custom remove icon
   */
  removeIcon?: React.ReactNode;
  
  /**
   * Callback when file is removed
   */
  onRemove?: (file: FileInfo) => void;
  
  /**
   * Whether files are required
   */
  required?: boolean;
  
  /**
   * Input name attribute
   */
  name?: string;
  
  /**
   * Input id attribute
   */
  id?: string;
}

/**
 * FileUpload component
 */
const FileUpload: React.FC<FileUploadProps> = (props) => {
  const {
    onChange,
    onUploadStart,
    onUploadProgress,
    onUploadComplete,
    onUploadError,
    onPreviewGenerated,
    disabled = false,
    multiple = false,
    dragDrop = true,
    dragPlaceholder = 'Drag files here or click to upload',
    dropPlaceholder = 'Drop files here to upload',
    buttonText = 'Upload',
    showPreview = true,
    previewSize = 64,
    showFileList = true,
    autoUpload = false,
    uploadUrl,
    method = 'POST',
    fieldName = 'file',
    headers = {},
    data = {},
    maxCount,
    accept,
    acceptType,
    minSize,
    minSizeUnit = 'B',
    maxSize,
    maxSizeUnit = 'MB',
    customValidation,
    customRequest,
    className = '',
    style,
    customIcon,
    customItemRender,
    inputProps = {},
    showRemoveButton = true,
    removeIcon,
    onRemove,
    required = false,
    name,
    id
  } = props;

  // Component state
  const [fileList, setFileList] = useState<FileInfo[]>([]);
  const [isDragging, setIsDragging] = useState<boolean>(false);
  const [dragCounter, setDragCounter] = useState<number>(0);
  
  // Refs
  const inputRef = useRef<HTMLInputElement>(null);
  const dropAreaRef = useRef<HTMLDivElement>(null);
  
  // Generate a unique ID for files
  const generateUid = (): string => {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  };
  
  // Convert file size to bytes based on unit
  const convertToBytes = (size: number, unit: FileSizeUnit): number => {
    switch (unit) {
      case 'B':
        return size;
      case 'KB':
        return size * 1024;
      case 'MB':
        return size * 1024 * 1024;
      case 'GB':
        return size * 1024 * 1024 * 1024;
      default:
        return size;
    }
  };
  
  // Format file size
  const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) {
      return `${bytes} B`;
    } else if (bytes < 1024 * 1024) {
      return `${(bytes / 1024).toFixed(2)} KB`;
    } else if (bytes < 1024 * 1024 * 1024) {
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    } else {
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }
  };
  
  // Get file type group based on mime type
  const getFileTypeGroup = (file: File): FileType => {
    const mimeType = file.type;
    
    if (mimeType.startsWith('image/')) {
      return FileType.IMAGE;
    } else if (mimeType.startsWith('video/')) {
      return FileType.VIDEO;
    } else if (mimeType.startsWith('audio/')) {
      return FileType.AUDIO;
    } else if (
      mimeType === 'application/pdf' ||
      mimeType === 'application/msword' ||
      mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
      mimeType === 'text/plain' ||
      mimeType === 'text/rtf'
    ) {
      return FileType.DOCUMENT;
    } else if (
      mimeType === 'application/zip' ||
      mimeType === 'application/x-7z-compressed' ||
      mimeType === 'application/x-rar-compressed' ||
      mimeType === 'application/x-tar' ||
      mimeType === 'application/gzip'
    ) {
      return FileType.ARCHIVE;
    } else if (
      mimeType === 'application/vnd.ms-excel' ||
      mimeType === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
      mimeType === 'text/csv'
    ) {
      return FileType.SPREADSHEET;
    } else {
      return FileType.ANY;
    }
  };
  
  // Validate a file
  const validateFile = (file: File): FileValidationResult => {
    // Check file size
    if (minSize !== undefined) {
      const minBytes = convertToBytes(minSize, minSizeUnit);
      if (file.size < minBytes) {
        return {
          isValid: false,
          errorMessage: `File size must be at least ${formatFileSize(minBytes)}`
        };
      }
    }
    
    if (maxSize !== undefined) {
      const maxBytes = convertToBytes(maxSize, maxSizeUnit);
      if (file.size > maxBytes) {
        return {
          isValid: false,
          errorMessage: `File size must not exceed ${formatFileSize(maxBytes)}`
        };
      }
    }
    
    // Check file type
    if (acceptType) {
      const fileTypeGroup = getFileTypeGroup(file);
      const acceptTypes = Array.isArray(acceptType) ? acceptType : [acceptType];
      
      if (!acceptTypes.includes(FileType.ANY) && !acceptTypes.includes(fileTypeGroup)) {
        return {
          isValid: false,
          errorMessage: `File type not accepted. Accepted types: ${acceptTypes.join(', ')}`
        };
      }
    }
    
    // Run custom validation if provided
    if (customValidation) {
      return customValidation(file);
    }
    
    return { isValid: true };
  };
  
  // Generate a preview for a file
  const generatePreview = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      if (!file.type.startsWith('image/')) {
        resolve('');
        return;
      }
      
      const reader = new FileReader();
      
      reader.onload = () => {
        resolve(reader.result as string);
      };
      
      reader.onerror = () => {
        reject(new Error('Failed to generate preview'));
      };
      
      reader.readAsDataURL(file);
    });
  };
  
  // Upload a file
  const uploadFile = (fileInfo: FileInfo): void => {
    if (!uploadUrl && !customRequest) {
      console.error('Upload URL or custom request function is required for upload');
      return;
    }
    
    // Update file status to uploading
    updateFileStatus(fileInfo.uid, {
      status: FileStatus.UPLOADING,
      progress: 0
    });
    
    if (onUploadStart) {
      onUploadStart(fileInfo);
    }
    
    if (customRequest) {
      // Use custom request function
      customRequest({
        file: fileInfo.file,
        onProgress: (percent) => {
          updateFileStatus(fileInfo.uid, {
            progress: percent
          });
          
          if (onUploadProgress) {
            const updatedFile = fileList.find(f => f.uid === fileInfo.uid);
            if (updatedFile) {
              onUploadProgress(updatedFile, percent);
            }
          }
        },
        onSuccess: (response) => {
          updateFileStatus(fileInfo.uid, {
            status: FileStatus.DONE,
            progress: 100
          });
          
          if (onUploadComplete) {
            const updatedFile = fileList.find(f => f.uid === fileInfo.uid);
            if (updatedFile) {
              onUploadComplete(updatedFile);
            }
          }
        },
        onError: (error) => {
          updateFileStatus(fileInfo.uid, {
            status: FileStatus.ERROR,
            error: error.message,
            progress: 0
          });
          
          if (onUploadError) {
            const updatedFile = fileList.find(f => f.uid === fileInfo.uid);
            if (updatedFile) {
              onUploadError(updatedFile, error);
            }
          }
        }
      });
    } else {
      // Use default XHR upload
      const xhr = new XMLHttpRequest();
      const formData = new FormData();
      
      // Add file to form data
      formData.append(fieldName, fileInfo.file);
      
      // Add additional form data
      Object.keys(data).forEach(key => {
        formData.append(key, data[key]);
      });
      
      // Set up upload progress
      xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable) {
          const percent = Math.round((event.loaded / event.total) * 100);
          
          updateFileStatus(fileInfo.uid, {
            progress: percent
          });
          
          if (onUploadProgress) {
            const updatedFile = fileList.find(f => f.uid === fileInfo.uid);
            if (updatedFile) {
              onUploadProgress(updatedFile, percent);
            }
          }
        }
      });
      
      // Set up completion handler
      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          updateFileStatus(fileInfo.uid, {
            status: FileStatus.DONE,
            progress: 100
          });
          
          if (onUploadComplete) {
            const updatedFile = fileList.find(f => f.uid === fileInfo.uid);
            if (updatedFile) {
              onUploadComplete(updatedFile);
            }
          }
        } else {
          const errorMessage = `Upload failed with status ${xhr.status}`;
          
          updateFileStatus(fileInfo.uid, {
            status: FileStatus.ERROR,
            error: errorMessage,
            progress: 0
          });
          
          if (onUploadError) {
            const updatedFile = fileList.find(f => f.uid === fileInfo.uid);
            if (updatedFile) {
              onUploadError(updatedFile, new Error(errorMessage));
            }
          }
        }
      });
      
      // Set up error handler
      xhr.addEventListener('error', () => {
        const errorMessage = 'Network error occurred during upload';
        
        updateFileStatus(fileInfo.uid, {
          status: FileStatus.ERROR,
          error: errorMessage,
          progress: 0
        });
        
        if (onUploadError) {
          const updatedFile = fileList.find(f => f.uid === fileInfo.uid);
          if (updatedFile) {
            onUploadError(updatedFile, new Error(errorMessage));
          }
        }
      });
      
      // Set up abort handler
      xhr.addEventListener('abort', () => {
        const errorMessage = 'Upload aborted';
        
        updateFileStatus(fileInfo.uid, {
          status: FileStatus.ERROR,
          error: errorMessage,
          progress: 0
        });
        
        if (onUploadError) {
          const updatedFile = fileList.find(f => f.uid === fileInfo.uid);
          if (updatedFile) {
            onUploadError(updatedFile, new Error(errorMessage));
          }
        }
      });
      
      // Open the request
      xhr.open(method, uploadUrl as string, true);
      
      // Set headers
      Object.keys(headers).forEach(key => {
        xhr.setRequestHeader(key, headers[key]);
      });
      
      // Send the request
      xhr.send(formData);
    }
  };
  
  // Update file status
  const updateFileStatus = (uid: string, updates: Partial<FileInfo>): void => {
    setFileList(prevList => {
      const newList = [...prevList];
      const fileIndex = newList.findIndex(f => f.uid === uid);
      
      if (fileIndex >= 0) {
        newList[fileIndex] = { ...newList[fileIndex], ...updates };
      }
      
      return newList;
    });
  };
  
  // Process files
  const processFiles = async (files: File[]): Promise<void> => {
    if (disabled) return;
    
    // Check if max count is reached
    if (maxCount !== undefined && fileList.length + files.length > maxCount) {
      const remainingSlots = Math.max(0, maxCount - fileList.length);
      files = files.slice(0, remainingSlots);
      
      if (files.length === 0) {
        // No slots available
        return;
      }
    }
    
    const newFiles: FileInfo[] = [];
    
    for (const file of files) {
      // Validate file
      const validationResult = validateFile(file);
      
      if (!validationResult.isValid) {
        // Create file info with error status
        const fileInfo: FileInfo = {
          file,
          uid: generateUid(),
          status: FileStatus.ERROR,
          error: validationResult.errorMessage,
          progress: 0
        };
        
        newFiles.push(fileInfo);
        continue;
      }
      
      // Create file info with ready status
      const fileInfo: FileInfo = {
        file,
        uid: generateUid(),
        status: FileStatus.READY,
        progress: 0
      };
      
      // Generate preview if needed
      if (showPreview) {
        try {
          const previewUrl = await generatePreview(file);
          fileInfo.previewUrl = previewUrl;
          
          if (onPreviewGenerated && previewUrl) {
            onPreviewGenerated(fileInfo, previewUrl);
          }
        } catch (error) {
          console.error('Preview generation failed:', error);
        }
      }
      
      newFiles.push(fileInfo);
      
      // Upload file if auto upload is enabled
      if (autoUpload && fileInfo.status === FileStatus.READY) {
        uploadFile(fileInfo);
      }
    }
    
    // Update file list
    setFileList(prevList => {
      const newList = [...prevList, ...newFiles];
      
      // Call onChange callback
      if (onChange) {
        onChange(newList);
      }
      
      return newList;
    });
  };
  
  // Handle file selection
  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>): void => {
    const files = event.target.files;
    
    if (files && files.length > 0) {
      processFiles(Array.from(files));
      
      // Reset the input value to allow selecting the same file again
      if (inputRef.current) {
        inputRef.current.value = '';
      }
    }
  };
  
  // Handle click on the upload area
  const handleUploadClick = (): void => {
    if (!disabled && inputRef.current) {
      inputRef.current.click();
    }
  };
  
  // Handle file removal
  const handleRemove = (file: FileInfo): void => {
    setFileList(prevList => {
      const newList = prevList.filter(f => f.uid !== file.uid);
      
      // Call onChange callback
      if (onChange) {
        onChange(newList);
      }
      
      // Call onRemove callback
      if (onRemove) {
        onRemove(file);
      }
      
      return newList;
    });
  };
  
  // Handle manual upload button click
  const handleUploadButtonClick = (file: FileInfo): void => {
    if (file.status === FileStatus.READY) {
      uploadFile(file);
    }
  };
  
  // Handle drag events
  const handleDragEnter = (e: React.DragEvent<HTMLDivElement>): void => {
    e.preventDefault();
    e.stopPropagation();
    
    setDragCounter(prevCounter => prevCounter + 1);
    
    if (!isDragging) {
      setIsDragging(true);
    }
  };
  
  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>): void => {
    e.preventDefault();
    e.stopPropagation();
    
    setDragCounter(prevCounter => prevCounter - 1);
    
    if (dragCounter === 1) {
      setIsDragging(false);
    }
  };
  
  const handleDragOver = (e: React.DragEvent<HTMLDivElement>): void => {
    e.preventDefault();
    e.stopPropagation();
  };
  
  const handleDrop = (e: React.DragEvent<HTMLDivElement>): void => {
    e.preventDefault();
    e.stopPropagation();
    
    setIsDragging(false);
    setDragCounter(0);
    
    if (disabled) return;
    
    const dt = e.dataTransfer;
    const files = dt.files;
    
    if (files && files.length > 0) {
      processFiles(Array.from(files));
    }
  };
  
  // Reset drag counter when component unmounts
  useEffect(() => {
    return () => {
      setDragCounter(0);
      setIsDragging(false);
    };
  }, []);
  
  // Render icons based on file type
  const renderFileIcon = (file: FileInfo): React.ReactNode => {
    if (customIcon) {
      return customIcon;
    }
    
    if (!file.file.type) {
      return <span className="cs-fileupload-file-icon cs-fileupload-file-icon-unknown">?</span>;
    }
    
    const fileType = getFileTypeGroup(file.file);
    
    switch (fileType) {
      case FileType.IMAGE:
        return <span className="cs-fileupload-file-icon cs-fileupload-file-icon-image">🖼️</span>;
      case FileType.DOCUMENT:
        return <span className="cs-fileupload-file-icon cs-fileupload-file-icon-document">📄</span>;
      case FileType.VIDEO:
        return <span className="cs-fileupload-file-icon cs-fileupload-file-icon-video">🎬</span>;
      case FileType.AUDIO:
        return <span className="cs-fileupload-file-icon cs-fileupload-file-icon-audio">🎵</span>;
      case FileType.ARCHIVE:
        return <span className="cs-fileupload-file-icon cs-fileupload-file-icon-archive">🗄️</span>;
      case FileType.SPREADSHEET:
        return <span className="cs-fileupload-file-icon cs-fileupload-file-icon-spreadsheet">📊</span>;
      default:
        return <span className="cs-fileupload-file-icon cs-fileupload-file-icon-file">📁</span>;
    }
  };
  
  // Render file item
  const renderFileItem = (file: FileInfo): React.ReactNode => {
    if (customItemRender) {
      return customItemRender(file, () => handleRemove(file));
    }
    
    return (
      <div
        key={file.uid}
        className={`cs-fileupload-file-item cs-fileupload-file-item-${file.status}`}
      >
        {/* File preview */}
        <div className="cs-fileupload-file-preview">
          {showPreview && file.previewUrl ? (
            <img
              src={file.previewUrl}
              alt={file.file.name}
              style={{ width: previewSize, height: previewSize }}
            />
          ) : (
            renderFileIcon(file)
          )}
        </div>
        
        {/* File info */}
        <div className="cs-fileupload-file-info">
          <div className="cs-fileupload-file-name" title={file.file.name}>
            {file.file.name}
          </div>
          <div className="cs-fileupload-file-size">
            {formatFileSize(file.file.size)}
          </div>
          {file.status === FileStatus.ERROR && (
            <div className="cs-fileupload-file-error">
              {file.error || 'Upload failed'}
            </div>
          )}
        </div>
        
        {/* File progress */}
        {file.status === FileStatus.UPLOADING && (
          <div className="cs-fileupload-file-progress">
            <div
              className="cs-fileupload-file-progress-bar"
              style={{ width: `${file.progress}%` }}
            />
            <div className="cs-fileupload-file-progress-text">
              {file.progress}%
            </div>
          </div>
        )}
        
        {/* File actions */}
        <div className="cs-fileupload-file-actions">
          {file.status === FileStatus.READY && !autoUpload && uploadUrl && (
            <button
              type="button"
              className="cs-fileupload-file-upload-button"
              onClick={() => handleUploadButtonClick(file)}
              aria-label="Upload file"
            >
              📤
            </button>
          )}
          
          {showRemoveButton && (
            <button
              type="button"
              className="cs-fileupload-file-remove-button"
              onClick={() => handleRemove(file)}
              aria-label="Remove file"
            >
              {removeIcon || '×'}
            </button>
          )}
        </div>
      </div>
    );
  };
  
  // Render upload area
  const renderUploadArea = (): React.ReactNode => {
    return (
      <div
        ref={dropAreaRef}
        className={`cs-fileupload-upload-area ${isDragging ? 'cs-fileupload-dragging' : ''} ${disabled ? 'cs-fileupload-disabled' : ''}`}
        onClick={handleUploadClick}
        onDragEnter={dragDrop ? handleDragEnter : undefined}
        onDragOver={dragDrop ? handleDragOver : undefined}
        onDragLeave={dragDrop ? handleDragLeave : undefined}
        onDrop={dragDrop ? handleDrop : undefined}
      >
        <input
          ref={inputRef}
          type="file"
          className="cs-fileupload-input"
          onChange={handleFileSelect}
          accept={accept}
          multiple={multiple}
          disabled={disabled}
          required={required}
          name={name}
          id={id}
          {...inputProps}
          style={{ display: 'none' }}
        />
        <div className="cs-fileupload-placeholder">
          {isDragging ? dropPlaceholder : dragPlaceholder}
        </div>
        <button
          type="button"
          className="cs-fileupload-button"
          disabled={disabled}
        >
          {buttonText}
        </button>
      </div>
    );
  };
  
  // Render file list
  const renderFileList = (): React.ReactNode => {
    if (!showFileList || fileList.length === 0) {
      return null;
    }
    
    return (
      <div className="cs-fileupload-file-list">
        {fileList.map(file => renderFileItem(file))}
      </div>
    );
  };
  
  // Render component
  return (
    <div
      className={`cs-fileupload ${className}`}
      style={style}
    >
      {renderUploadArea()}
      {renderFileList()}
    </div>
  );
};

export default FileUpload;


/**
 * FileUpload.scss
 * 
 * Styles for the custom file upload component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$info: #17a2b8;
$warning: #ffc107;
$danger: #dc3545;

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius: 4px;

// Transitions
$transition-base: all 0.2s ease-in-out;

// Base FileUpload styles
.cs-fileupload {
  font-family: $font-family;
  font-size: $font-size-base;
  line-height: $line-height-base;
  color: $gray-700;
  width: 100%;
  max-width: 600px;

  *, *::before, *::after {
    box-sizing: border-box;
  }

  // Upload area
  &-upload-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: calc(#{$spacer} * 3);
    border: 2px dashed $gray-400;
    border-radius: $border-radius;
    background-color: $gray-100;
    transition: $transition-base;
    cursor: pointer;
    text-align: center;
    min-height: 150px;

    &:hover {
      border-color: $primary-color;
      background-color: $primary-alpha;
    }

    &.cs-fileupload-dragging {
      border-color: $primary-color;
      background-color: $primary-alpha-medium;
    }

    &.cs-fileupload-disabled {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: $gray-400;
      background-color: $gray-200;

      &:hover {
        border-color: $gray-400;
        background-color: $gray-200;
      }
    }
  }

  // Placeholder text
  &-placeholder {
    margin-bottom: calc(#{$spacer} * 2);
    color: $gray-700;
    font-size: $font-size-base;
  }

  // Upload button
  &-button {
    padding: $spacer calc(#{$spacer} * 2);
    background-color: $primary-color;
    color: $white;
    border: none;
    border-radius: $border-radius;
    font-size: $font-size-base;
    cursor: pointer;
    transition: $transition-base;

    &:hover {
      background-color: $primary-dark;
    }

    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px $primary-alpha;
    }

    &:disabled {
      background-color: $gray-500;
      cursor: not-allowed;
    }
  }

  // File list
  &-file-list {
    margin-top: calc(#{$spacer} * 2);
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    overflow: hidden;
  }

  // File item
  &-file-item {
    display: flex;
    align-items: center;
    padding: $spacer;
    border-bottom: 1px solid $gray-300;
    background-color: $white;
    transition: $transition-base;

    &:last-child {
      border-bottom: none;
    }

    &:hover {
      background-color: $gray-100;
    }

    &-ready {
      // Default style
    }

    &-uploading {
      background-color: $primary-alpha;
    }

    &-done {
      background-color: rgba($success, 0.1);
    }

    &-error {
      background-color: rgba($danger, 0.1);
    }
  }

  // File preview
  &-file-preview {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 64px;
    height: 64px;
    margin-right: $spacer;
    border-radius: $border-radius;
    overflow: hidden;
    background-color: $gray-200;

    img {
      max-width: 100%;
      max-height: 100%;
      object-fit: cover;
    }
  }

  // File icon
  &-file-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    font-size: 24px;
    color: $gray-700;

    &-image {
      color: $primary-color;
    }

    &-document {
      color: $info;
    }

    &-video {
      color: $danger;
    }

    &-audio {
      color: $warning;
    }

    &-archive {
      color: $gray-600;
    }

    &-spreadsheet {
      color: $success;
    }

    &-file, &-unknown {
      color: $gray-500;
    }
  }

  // File info
  &-file-info {
    flex: 1;
    min-width: 0;
    margin-right: $spacer;
  }

  // File name
  &-file-name {
    font-weight: bold;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: $spacer/2;
  }

  // File size
  &-file-size {
    font-size: 12px;
    color: $gray-600;
  }

  // File error
  &-file-error {
    font-size: 12px;
    color: $danger;
    margin-top: $spacer/2;
  }

  // File progress
  &-file-progress {
    position: relative;
    margin-top: $spacer/2;
    height: 4px;
    width: 100%;
    background-color: $gray-300;
    border-radius: 2px;
    overflow: hidden;
  }

  // Progress bar
  &-file-progress-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: $primary-color;
    transition: width 0.2s ease;
  }

  // Progress text
  &-file-progress-text {
    position: absolute;
    top: -16px;
    right: 0;
    font-size: 12px;
    color: $gray-600;
  }

  // File actions
  &-file-actions {
    display: flex;
    align-items: center;
  }

  // File action buttons
  &-file-upload-button,
  &-file-remove-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    padding: 0;
    margin-left: $spacer/2;
    background: none;
    border: 1px solid $gray-300;
    border-radius: 50%;
    font-size: 16px;
    line-height: 1;
    cursor: pointer;
    transition: $transition-base;

    &:hover {
      background-color: $gray-200;
    }

    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px $primary-alpha;
    }
  }

  &-file-upload-button {
    color: $primary-color;

    &:hover {
      border-color: $primary-color;
    }
  }

  &-file-remove-button {
    color: $danger;

    &:hover {
      border-color: $danger;
      background-color: rgba($danger, 0.1);
    }
  }

  // Dark mode support
  &.cs-fileupload-dark {
    color: $gray-300;
    
    .cs-fileupload-upload-area {
      background-color: $gray-800;
      border-color: $gray-700;
      
      &:hover {
        border-color: $primary-color;
        background-color: rgba($primary-color, 0.1);
      }
      
      &.cs-fileupload-dragging {
        border-color: $primary-color;
        background-color: rgba($primary-color, 0.2);
      }
      
      &.cs-fileupload-disabled {
        background-color: $gray-900;
        border-color: $gray-800;
        
        &:hover {
          background-color: $gray-900;
          border-color: $gray-800;
        }
      }
    }
    
    .cs-fileupload-placeholder {
      color: $gray-400;
    }
    
    .cs-fileupload-button {
      background-color: $primary-color;
      
      &:hover {
        background-color: $primary-dark;
      }
      
      &:disabled {
        background-color: $gray-700;
      }
    }
    
    .cs-fileupload-file-list {
      border-color: $gray-700;
    }
    
    .cs-fileupload-file-item {
      background-color: $gray-800;
      border-color: $gray-700;
      
      &:hover {
        background-color: $gray-700;
      }
      
      &-uploading {
        background-color: rgba($primary-color, 0.2);
      }
      
      &-done {
        background-color: rgba($success, 0.2);
      }
      
      &-error {
        background-color: rgba($danger, 0.2);
      }
    }
    
    .cs-fileupload-file-preview {
      background-color: $gray-900;
    }
    
    .cs-fileupload-file-icon {
      color: $gray-400;
      
      &-file, &-unknown {
        color: $gray-500;
      }
    }
    
    .cs-fileupload-file-name {
      color: $gray-300;
    }
    
    .cs-fileupload-file-size {
      color: $gray-500;
    }
    
    .cs-fileupload-file-progress {
      background-color: $gray-700;
    }
    
    .cs-fileupload-file-progress-text {
      color: $gray-400;
    }
    
    .cs-fileupload-file-upload-button,
    .cs-fileupload-file-remove-button {
      border-color: $gray-600;
      
      &:hover {
        background-color: $gray-700;
      }
    }
  }

  // High contrast mode
  &.cs-fileupload-high-contrast {
    .cs-fileupload-upload-area {
      border-width: 3px;
    }
    
    .cs-fileupload-button {
      border: 2px solid $black;
    }
    
    .cs-fileupload-file-item {
      border-width: 2px;
    }
    
    .cs-fileupload-file-upload-button,
    .cs-fileupload-file-remove-button {
      border-width: 2px;
    }
  }

  // Touch device optimizations
  @media (pointer: coarse) {
    .cs-fileupload-upload-area {
      min-height: 200px;
    }
    
    .cs-fileupload-button {
      padding: calc(#{$spacer} * 1.5) calc(#{$spacer} * 3);
      font-size: 16px;
    }
    
    .cs-fileupload-file-upload-button,
    .cs-fileupload-file-remove-button {
      width: 40px;
      height: 40px;
      font-size: 20px;
    }
  }

  // Responsive styles
  @media (max-width: 576px) {
    .cs-fileupload-file-item {
      flex-wrap: wrap;
    }
    
    .cs-fileupload-file-preview {
      margin-right: $spacer;
      margin-bottom: $spacer;
    }
    
    .cs-fileupload-file-info {
      width: calc(100% - 72px);
      margin-right: 0;
      margin-bottom: $spacer;
    }
    
    .cs-fileupload-file-actions {
      width: 100%;
      justify-content: flex-end;
    }
  }

  // Focus outline
  &:focus-within {
    .cs-fileupload-upload-area {
      border-color: $primary-color;
      box-shadow: 0 0 0 3px $primary-alpha;
    }
  }

  // Animation for upload area
  @keyframes cs-fileupload-pulse {
    0% {
      box-shadow: 0 0 0 0 $primary-alpha-medium;
    }
    70% {
      box-shadow: 0 0 0 10px rgba($primary-color, 0);
    }
    100% {
      box-shadow: 0 0 0 0 rgba($primary-color, 0);
    }
  }

  .cs-fileupload-dragging .cs-fileupload-upload-area {
    animation: cs-fileupload-pulse 1.5s infinite;
  }

  // Custom theming options
  &.cs-fileupload-primary {
    --cs-fileupload-primary: #{$primary-color};
    --cs-fileupload-primary-light: #{$primary-light};
    --cs-fileupload-primary-lighter: #{$primary-lighter};
    --cs-fileupload-primary-dark: #{$primary-dark};
    --cs-fileupload-primary-darker: #{$primary-darker};
    --cs-fileupload-primary-alpha: #{$primary-alpha};
  }
  
  &.cs-fileupload-success {
    --cs-fileupload-primary: #{$success};
    --cs-fileupload-primary-light: #{lighten($success, 20%)};
    --cs-fileupload-primary-lighter: #{lighten($success, 35%)};
    --cs-fileupload-primary-dark: #{darken($success, 10%)};
    --cs-fileupload-primary-darker: #{darken($success, 20%)};
    --cs-fileupload-primary-alpha: #{rgba($success, 0.2)};
    
    .cs-fileupload-button,
    .cs-fileupload-file-progress-bar,
    .cs-fileupload-file-upload-button {
      background-color: var(--cs-fileupload-primary);
      
      &:hover {
        background-color: var(--cs-fileupload-primary-dark);
      }
    }
    
    .cs-fileupload-upload-area:hover,
    .cs-fileupload-upload-area:focus-within {
      border-color: var(--cs-fileupload-primary);
      background-color: var(--cs-fileupload-primary-alpha);
    }
  }
  
  &.cs-fileupload-info {
    --cs-fileupload-primary: #{$info};
    --cs-fileupload-primary-light: #{lighten($info, 20%)};
    --cs-fileupload-primary-lighter: #{lighten($info, 35%)};
    --cs-fileupload-primary-dark: #{darken($info, 10%)};
    --cs-fileupload-primary-darker: #{darken($info, 20%)};
    --cs-fileupload-primary-alpha: #{rgba($info, 0.2)};
    
    .cs-fileupload-button,
    .cs-fileupload-file-progress-bar,
    .cs-fileupload-file-upload-button {
      background-color: var(--cs-fileupload-primary);
      
      &:hover {
        background-color: var(--cs-fileupload-primary-dark);
      }
    }
    
    .cs-fileupload-upload-area:hover,
    .cs-fileupload-upload-area:focus-within {
      border-color: var(--cs-fileupload-primary);
      background-color: var(--cs-fileupload-primary-alpha);
    }
  }
  
  &.cs-fileupload-warning {
    --cs-fileupload-primary: #{$warning};
    --cs-fileupload-primary-light: #{lighten($warning, 20%)};
    --cs-fileupload-primary-lighter: #{lighten($warning, 35%)};
    --cs-fileupload-primary-dark: #{darken($warning, 10%)};
    --cs-fileupload-primary-darker: #{darken($warning, 20%)};
    --cs-fileupload-primary-alpha: #{rgba($warning, 0.2)};
    
    .cs-fileupload-button,
    .cs-fileupload-file-progress-bar,
    .cs-fileupload-file-upload-button {
      background-color: var(--cs-fileupload-primary);
      color: $gray-900;
      
      &:hover {
        background-color: var(--cs-fileupload-primary-dark);
      }
    }
    
    .cs-fileupload-upload-area:hover,
    .cs-fileupload-upload-area:focus-within {
      border-color: var(--cs-fileupload-primary);
      background-color: var(--cs-fileupload-primary-alpha);
    }
  }
  
  &.cs-fileupload-danger {
    --cs-fileupload-primary: #{$danger};
    --cs-fileupload-primary-light: #{lighten($danger, 20%)};
    --cs-fileupload-primary-lighter: #{lighten($danger, 35%)};
    --cs-fileupload-primary-dark: #{darken($danger, 10%)};
    --cs-fileupload-primary-darker: #{darken($danger, 20%)};
    --cs-fileupload-primary-alpha: #{rgba($danger, 0.2)};
    
    .cs-fileupload-button,
    .cs-fileupload-file-progress-bar,
    .cs-fileupload-file-upload-button {
      background-color: var(--cs-fileupload-primary);
      
      &:hover {
        background-color: var(--cs-fileupload-primary-dark);
      }
    }
    
    .cs-fileupload-upload-area:hover,
    .cs-fileupload-upload-area:focus-within {
      border-color: var(--cs-fileupload-primary);
      background-color: var(--cs-fileupload-primary-alpha);
    }
  }
}


/**
 * Toast.tsx
 * 
 * Custom toast notification component for the CSTestForge framework.
 * Provides customizable toast notifications with different types, positions, and animations.
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';
import './Toast.scss';

/**
 * Toast type enum
 */
export enum ToastType {
  INFO = 'info',
  SUCCESS = 'success',
  WARNING = 'warning',
  ERROR = 'error'
}

/**
 * Toast position enum
 */
export enum ToastPosition {
  TOP_LEFT = 'top-left',
  TOP_CENTER = 'top-center',
  TOP_RIGHT = 'top-right',
  BOTTOM_LEFT = 'bottom-left',
  BOTTOM_CENTER = 'bottom-center',
  BOTTOM_RIGHT = 'bottom-right'
}

/**
 * Toast props interface
 */
export interface ToastProps {
  /**
   * Toast message
   */
  message: string;
  
  /**
   * Toast type
   */
  type?: ToastType;
  
  /**
   * Toast position
   */
  position?: ToastPosition;
  
  /**
   * Toast duration in milliseconds
   */
  duration?: number;
  
  /**
   * Whether to show close button
   */
  showCloseButton?: boolean;
  
  /**
   * Whether to show an icon based on type
   */
  showIcon?: boolean;
  
  /**
   * Callback when toast is closed
   */
  onClose?: () => void;
  
  /**
   * Whether the toast is visible
   */
  visible?: boolean;
  
  /**
   * Custom close button content
   */
  closeButton?: React.ReactNode;
  
  /**
   * Custom icon
   */
  icon?: React.ReactNode;
  
  /**
   * Whether the toast is dismissible by clicking
   */
  dismissible?: boolean;
  
  /**
   * Whether to pause the timer on hover
   */
  pauseOnHover?: boolean;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Toast animation type
   */
  animation?: 'fade' | 'slide' | 'bounce';
  
  /**
   * Toast ID (for toast manager)
   */
  id?: string;
}

/**
 * Toast component
 */
const Toast: React.FC<ToastProps> = (props) => {
  const {
    message,
    type = ToastType.INFO,
    position = ToastPosition.TOP_RIGHT,
    duration = 3000,
    showCloseButton = true,
    showIcon = true,
    onClose,
    visible = true,
    closeButton,
    icon,
    dismissible = true,
    pauseOnHover = true,
    className = '',
    style,
    animation = 'fade',
    id
  } = props;

  // Component state
  const [isVisible, setIsVisible] = useState<boolean>(visible);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  
  // Refs
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const remainingTimeRef = useRef<number>(duration);
  const startTimeRef = useRef<number>(0);
  
  // Start timer
  const startTimer = useCallback(() => {
    if (duration === Infinity) return;
    
    startTimeRef.current = Date.now();
    
    timerRef.current = setTimeout(() => {
      handleClose();
    }, remainingTimeRef.current);
  }, [duration]);
  
  // Pause timer
  const pauseTimer = useCallback(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
      
      // Calculate remaining time
      const elapsedTime = Date.now() - startTimeRef.current;
      remainingTimeRef.current = Math.max(0, remainingTimeRef.current - elapsedTime);
    }
  }, []);
  
  // Handle close
  const handleClose = useCallback(() => {
    setIsVisible(false);
    
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
    
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  
  // Handle mouse enter
  const handleMouseEnter = useCallback(() => {
    if (pauseOnHover) {
      setIsPaused(true);
      pauseTimer();
    }
  }, [pauseOnHover, pauseTimer]);
  
  // Handle mouse leave
  const handleMouseLeave = useCallback(() => {
    if (pauseOnHover) {
      setIsPaused(false);
      startTimer();
    }
  }, [pauseOnHover, startTimer]);
  
  // Handle click
  const handleClick = useCallback(() => {
    if (dismissible) {
      handleClose();
    }
  }, [dismissible, handleClose]);
  
  // Effect to start/stop timer based on visibility
  useEffect(() => {
    setIsVisible(visible);
    
    if (visible) {
      remainingTimeRef.current = duration;
      startTimer();
    } else {
      pauseTimer();
    }
    
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, [visible, duration, startTimer, pauseTimer]);
  
  // Render icon based on type
  const renderIcon = (): React.ReactNode => {
    if (!showIcon) {
      return null;
    }
    
    if (icon) {
      return <div className="cs-toast-icon">{icon}</div>;
    }
    
    let iconContent = '';
    
    switch (type) {
      case ToastType.SUCCESS:
        iconContent = '✓';
        break;
      case ToastType.WARNING:
        iconContent = '⚠️';
        break;
      case ToastType.ERROR:
        iconContent = '✕';
        break;
      case ToastType.INFO:
      default:
        iconContent = 'ℹ';
        break;
    }
    
    return <div className={`cs-toast-icon cs-toast-icon-${type}`}>{iconContent}</div>;
  };
  
  // Render close button
  const renderCloseButton = (): React.ReactNode => {
    if (!showCloseButton) {
      return null;
    }
    
    return (
      <button
        type="button"
        className="cs-toast-close-button"
        onClick={handleClose}
        aria-label="Close"
      >
        {closeButton || '×'}
      </button>
    );
  };
  
  // Get animation class
  const getAnimationClass = (): string => {
    if (!isVisible) {
      return `cs-toast-animation-${animation}-exit`;
    }
    
    return `cs-toast-animation-${animation}-enter`;
  };
  
  // Get position class
  const getPositionClass = (): string => {
    return `cs-toast-position-${position}`;
  };
  
  // If not visible, don't render
  if (!isVisible && !visible) {
    return null;
  }
  
  // Render component
  return (
    <div
      className={`cs-toast cs-toast-${type} ${getPositionClass()} ${getAnimationClass()} ${className}`}
      style={style}
      role="alert"
      aria-live="assertive"
      onClick={handleClick}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      data-testid="cs-toast"
      data-id={id}
    >
      {renderIcon()}
      <div className="cs-toast-content">{message}</div>
      {renderCloseButton()}
      {duration !== Infinity && !isPaused && (
        <div className="cs-toast-progress">
          <div
            className="cs-toast-progress-bar"
            style={{
              animationDuration: `${duration}ms`,
              animationPlayState: isPaused ? 'paused' : 'running'
            }}
          />
        </div>
      )}
    </div>
  );
};

export default Toast;

/**
 * Toast container props interface
 */
export interface ToastContainerProps {
  /**
   * Position for all toasts
   */
  position?: ToastPosition;
  
  /**
   * Maximum number of toasts to show
   */
  limit?: number;
  
  /**
   * Whether to automatically dismiss toasts
   */
  autoDismiss?: boolean;
  
  /**
   * Default duration for toasts
   */
  defaultDuration?: number;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Children
   */
  children?: React.ReactNode;
}

/**
 * Toast data interface
 */
export interface ToastData extends Omit<ToastProps, 'onClose'> {
  /**
   * Unique ID
   */
  id: string;
  
  /**
   * Creation timestamp
   */
  timestamp: number;
}

/**
 * Toast service options interface
 */
export interface ToastOptions extends Omit<ToastProps, 'message' | 'visible' | 'id'> {}

/**
 * Toast container component
 */
export const ToastContainer: React.FC<ToastContainerProps> = (props) => {
  const {
    position = ToastPosition.TOP_RIGHT,
    limit = 5,
    autoDismiss = true,
    defaultDuration = 3000,
    className = '',
    style,
    children
  } = props;

  // Toasts state
  const [toasts, setToasts] = useState<ToastData[]>([]);
  
  // Remove toast
  const removeToast = (id: string) => {
    setToasts(prevToasts => prevToasts.filter(toast => toast.id !== id));
  };
  
  // Render toasts
  const renderToasts = () => {
    // Get toasts to display based on limit
    const visibleToasts = toasts.slice(0, limit);
    
    return visibleToasts.map(toast => (
      <Toast
        key={toast.id}
        id={toast.id}
        message={toast.message}
        type={toast.type}
        position={toast.position || position}
        duration={toast.duration || (autoDismiss ? defaultDuration : Infinity)}
        showCloseButton={toast.showCloseButton}
        showIcon={toast.showIcon}
        icon={toast.icon}
        closeButton={toast.closeButton}
        dismissible={toast.dismissible}
        pauseOnHover={toast.pauseOnHover}
        className={toast.className}
        style={toast.style}
        animation={toast.animation}
        onClose={() => removeToast(toast.id)}
        visible
      />
    ));
  };
  
  // Render component
  return (
    <div className={`cs-toast-container cs-toast-position-${position} ${className}`} style={style}>
      {renderToasts()}
      {children}
    </div>
  );
};

/**
 * Toast service
 */
export class ToastService {
  private static instance: ToastService;
  private toasts: ToastData[] = [];
  private listeners: Set<(toasts: ToastData[]) => void> = new Set();
  private counter = 0;
  
  /**
   * Get toast service instance (singleton)
   */
  public static getInstance(): ToastService {
    if (!ToastService.instance) {
      ToastService.instance = new ToastService();
    }
    
    return ToastService.instance;
  }
  
  /**
   * Generate unique ID
   */
  private generateId(): string {
    return `toast-${Date.now()}-${this.counter++}`;
  }
  
  /**
   * Add new toast
   */
  private addToast(message: string, type: ToastType, options?: ToastOptions): string {
    const id = this.generateId();
    
    const toast: ToastData = {
      id,
      message,
      type,
      timestamp: Date.now(),
      ...options
    };
    
    this.toasts = [toast, ...this.toasts];
    this.notifyListeners();
    
    return id;
  }
  
  /**
   * Remove toast by ID
   */
  public removeToast(id: string): void {
    this.toasts = this.toasts.filter(toast => toast.id !== id);
    this.notifyListeners();
  }
  
  /**
   * Clear all toasts
   */
  public clearToasts(): void {
    this.toasts = [];
    this.notifyListeners();
  }
  
  /**
   * Notify listeners of toast changes
   */
  private notifyListeners(): void {
    this.listeners.forEach(listener => listener([...this.toasts]));
  }
  
  /**
   * Add listener
   */
  public addListener(listener: (toasts: ToastData[]) => void): () => void {
    this.listeners.add(listener);
    listener([...this.toasts]);
    
    // Return unsubscribe function
    return () => {
      this.listeners.delete(listener);
    };
  }
  
  /**
   * Show info toast
   */
  public info(message: string, options?: ToastOptions): string {
    return this.addToast(message, ToastType.INFO, options);
  }
  
  /**
   * Show success toast
   */
  public success(message: string, options?: ToastOptions): string {
    return this.addToast(message, ToastType.SUCCESS, options);
  }
  
  /**
   * Show warning toast
   */
  public warning(message: string, options?: ToastOptions): string {
    return this.addToast(message, ToastType.WARNING, options);
  }
  
  /**
   * Show error toast
   */
  public error(message: string, options?: ToastOptions): string {
    return this.addToast(message, ToastType.ERROR, options);
  }
  
  /**
   * Show custom toast
   */
  public show(message: string, type: ToastType = ToastType.INFO, options?: ToastOptions): string {
    return this.addToast(message, type, options);
  }
  
  /**
   * Get all toasts
   */
  public getToasts(): ToastData[] {
    return [...this.toasts];
  }
}

/**
 * Toast context
 */
export const ToastContext = React.createContext<ToastService>(ToastService.getInstance());

/**
 * Toast provider props
 */
export interface ToastProviderProps {
  /**
   * Children
   */
  children: React.ReactNode;
  
  /**
   * Container props
   */
  containerProps?: ToastContainerProps;
}

/**
 * Toast provider component
 */
export const ToastProvider: React.FC<ToastProviderProps> = ({ children, containerProps }) => {
  const toastService = ToastService.getInstance();
  const [toasts, setToasts] = useState<ToastData[]>([]);
  
  // Subscribe to toast changes
  useEffect(() => {
    const unsubscribe = toastService.addListener(setToasts);
    return unsubscribe;
  }, [toastService]);
  
  return (
    <ToastContext.Provider value={toastService}>
      {children}
      <ToastContainer {...containerProps}>
        {toasts.map(toast => (
          <Toast
            key={toast.id}
            id={toast.id}
            message={toast.message}
            type={toast.type}
            position={toast.position}
            duration={toast.duration}
            showCloseButton={toast.showCloseButton}
            showIcon={toast.showIcon}
            icon={toast.icon}
            closeButton={toast.closeButton}
            dismissible={toast.dismissible}
            pauseOnHover={toast.pauseOnHover}
            className={toast.className}
            style={toast.style}
            animation={toast.animation}
            onClose={() => toastService.removeToast(toast.id)}
            visible
          />
        ))}
      </ToastContainer>
    </ToastContext.Provider>
  );
};

/**
 * Custom hook to use toast
 */
export const useToast = (): ToastService => {
  const toastService = React.useContext(ToastContext);
  return toastService;
};



/**
 * Toast.scss
 * 
 * Styles for the custom toast notification component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$info: #17a2b8;
$warning: #ffc107;
$danger: #dc3545;

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius: 4px;

// Transitions
$transition-base: all 0.2s ease-in-out;

// Shadows
$shadow-sm: 0 .125rem .25rem rgba($black, .075);
$shadow: 0 .5rem 1rem rgba($black, .15);

// Z-index
$z-index-toast: 9999;

// Toast dimensions
$toast-width: 320px;
$toast-min-height: 48px;
$toast-max-height: 800px;
$toast-spacing: $spacer * 2;

// Base Toast styles
.cs-toast-container {
  position: fixed;
  z-index: $z-index-toast;
  display: flex;
  flex-direction: column;
  max-width: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
  pointer-events: none;
  
  // Position variants
  &.cs-toast-position-top-left {
    top: $toast-spacing;
    left: $toast-spacing;
    align-items: flex-start;
  }
  
  &.cs-toast-position-top-center {
    top: $toast-spacing;
    left: 50%;
    transform: translateX(-50%);
    align-items: center;
  }
  
  &.cs-toast-position-top-right {
    top: $toast-spacing;
    right: $toast-spacing;
    align-items: flex-end;
  }
  
  &.cs-toast-position-bottom-left {
    bottom: $toast-spacing;
    left: $toast-spacing;
    align-items: flex-start;
    flex-direction: column-reverse;
  }
  
  &.cs-toast-position-bottom-center {
    bottom: $toast-spacing;
    left: 50%;
    transform: translateX(-50%);
    align-items: center;
    flex-direction: column-reverse;
  }
  
  &.cs-toast-position-bottom-right {
    bottom: $toast-spacing;
    right: $toast-spacing;
    align-items: flex-end;
    flex-direction: column-reverse;
  }
}

.cs-toast {
  position: relative;
  display: flex;
  align-items: center;
  min-height: $toast-min-height;
  max-height: $toast-max-height;
  width: $toast-width;
  max-width: 100%;
  margin-bottom: $spacer;
  padding: $spacer $spacer * 1.5;
  border-radius: $border-radius;
  box-shadow: $shadow;
  background-color: $white;
  color: $gray-700;
  font-family: $font-family;
  font-size: $font-size-base;
  line-height: $line-height-base;
  pointer-events: auto;
  cursor: pointer;
  overflow: hidden;
  
  // Toast type variants
  &.cs-toast-info {
    border-left: 4px solid $info;
    
    .cs-toast-icon {
      color: $info;
    }
    
    .cs-toast-progress-bar {
      background-color: $info;
    }
  }
  
  &.cs-toast-success {
    border-left: 4px solid $success;
    
    .cs-toast-icon {
      color: $success;
    }
    
    .cs-toast-progress-bar {
      background-color: $success;
    }
  }
  
  &.cs-toast-warning {
    border-left: 4px solid $warning;
    
    .cs-toast-icon {
      color: $warning;
    }
    
    .cs-toast-progress-bar {
      background-color: $warning;
    }
  }
  
  &.cs-toast-error {
    border-left: 4px solid $danger;
    
    .cs-toast-icon {
      color: $danger;
    }
    
    .cs-toast-progress-bar {
      background-color: $danger;
    }
  }
  
  // Icon
  &-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    width: 24px;
    height: 24px;
    margin-right: $spacer;
    font-size: 16px;
    
    &-info {
      color: $info;
    }
    
    &-success {
      color: $success;
    }
    
    &-warning {
      color: $warning;
    }
    
    &-error {
      color: $danger;
    }
  }
  
  // Content
  &-content {
    flex: 1;
    min-width: 0;
    padding-right: $spacer * 2;
  }
  
  // Close button
  &-close-button {
    position: absolute;
    top: $spacer / 2;
    right: $spacer / 2;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 50%;
    color: $gray-600;
    font-size: 18px;
    line-height: 1;
    cursor: pointer;
    transition: $transition-base;
    
    &:hover {
      color: $gray-900;
      background-color: $gray-200;
    }
    
    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px $primary-alpha;
    }
  }
  
  // Progress bar
  &-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 4px;
    background-color: $gray-200;
  }
  
  &-progress-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    transform-origin: left;
    animation: cs-toast-progress 3000ms linear forwards;
  }
  
  // Animation keyframes
  @keyframes cs-toast-progress {
    from {
      transform: scaleX(1);
    }
    to {
      transform: scaleX(0);
    }
  }
  
  // Animation variants
  &-animation-fade-enter {
    animation: cs-toast-fade-in 0.3s ease forwards;
  }
  
  &-animation-fade-exit {
    animation: cs-toast-fade-out 0.3s ease forwards;
  }
  
  &-animation-slide-enter {
    animation: cs-toast-slide-in 0.3s ease forwards;
  }
  
  &-animation-slide-exit {
    animation: cs-toast-slide-out 0.3s ease forwards;
  }
  
  &-animation-bounce-enter {
    animation: cs-toast-bounce-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
  }
  
  &-animation-bounce-exit {
    animation: cs-toast-bounce-out 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
  }
}

// Animation keyframes
@keyframes cs-toast-fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes cs-toast-fade-out {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

@keyframes cs-toast-slide-in {
  from {
    transform: translateX(100%);
  }
  to {
    transform: translateX(0);
  }
}

@keyframes cs-toast-slide-out {
  from {
    transform: translateX(0);
  }
  to {
    transform: translateX(100%);
  }
}

@keyframes cs-toast-bounce-in {
  from {
    transform: scale(0.5);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes cs-toast-bounce-out {
  from {
    transform: scale(1);
    opacity: 1;
  }
  to {
    transform: scale(0.5);
    opacity: 0;
  }
}

// For RTL support
.cs-toast-container[dir="rtl"] {
  .cs-toast {
    border-left: none;
    border-right: 4px solid;
    
    &-icon {
      margin-right: 0;
      margin-left: $spacer;
    }
    
    &-content {
      padding-right: 0;
      padding-left: $spacer * 2;
    }
    
    &-close-button {
      right: auto;
      left: $spacer / 2;
    }
    
    &-progress-bar {
      transform-origin: right;
    }
    
    &-animation-slide-enter {
      animation-name: cs-toast-slide-in-rtl;
    }
    
    &-animation-slide-exit {
      animation-name: cs-toast-slide-out-rtl;
    }
  }
}

@keyframes cs-toast-slide-in-rtl {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0);
  }
}

@keyframes cs-toast-slide-out-rtl {
  from {
    transform: translateX(0);
  }
  to {
    transform: translateX(-100%);
  }
}

// Dark mode support
.cs-toast.cs-toast-dark {
  background-color: $gray-800;
  color: $gray-300;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  
  .cs-toast-close-button {
    color: $gray-400;
    
    &:hover {
      color: $white;
      background-color: $gray-700;
    }
  }
  
  .cs-toast-progress {
    background-color: $gray-700;
  }
}

// High contrast mode
.cs-toast.cs-toast-high-contrast {
  border-width: 2px;
  
  .cs-toast-close-button {
    border: 1px solid currentColor;
  }
  
  .cs-toast-progress {
    height: 6px;
  }
}

// Mobile styles
@media (max-width: 576px) {
  .cs-toast-container {
    &.cs-toast-position-top-left,
    &.cs-toast-position-top-center,
    &.cs-toast-position-top-right {
      top: $spacer;
      left: $spacer;
      right: $spacer;
      align-items: stretch;
    }
    
    &.cs-toast-position-bottom-left,
    &.cs-toast-position-bottom-center,
    &.cs-toast-position-bottom-right {
      bottom: $spacer;
      left: $spacer;
      right: $spacer;
      align-items: stretch;
    }
  }
  
  .cs-toast {
    width: 100%;
  }
}

// Print styles
@media print {
  .cs-toast-container {
    display: none !important;
  }
}

// Accessibility focus styles
.cs-toast:focus-visible {
  outline: 2px solid $primary-color;
  outline-offset: 2px;
}

// Custom themes
.cs-toast {
  &.cs-toast-primary {
    --cs-toast-primary: #{$primary-color};
    border-left-color: var(--cs-toast-primary);
    
    .cs-toast-icon,
    .cs-toast-progress-bar {
      color: var(--cs-toast-primary);
      background-color: var(--cs-toast-primary);
    }
  }
  
  &.cs-toast-custom-info {
    --cs-toast-color: #{$info};
    border-left-color: var(--cs-toast-color);
    
    .cs-toast-icon,
    .cs-toast-progress-bar {
      color: var(--cs-toast-color);
      background-color: var(--cs-toast-color);
    }
  }
  
  &.cs-toast-custom-success {
    --cs-toast-color: #{$success};
    border-left-color: var(--cs-toast-color);
    
    .cs-toast-icon,
    .cs-toast-progress-bar {
      color: var(--cs-toast-color);
      background-color: var(--cs-toast-color);
    }
  }
  
  &.cs-toast-custom-warning {
    --cs-toast-color: #{$warning};
    border-left-color: var(--cs-toast-color);
    
    .cs-toast-icon,
    .cs-toast-progress-bar {
      color: var(--cs-toast-color);
      background-color: var(--cs-toast-color);
    }
  }
  
  &.cs-toast-custom-error {
    --cs-toast-color: #{$danger};
    border-left-color: var(--cs-toast-color);
    
    .cs-toast-icon,
    .cs-toast-progress-bar {
      color: var(--cs-toast-color);
      background-color: var(--cs-toast-color);
    }
  }
}


/**
 * Alert.tsx
 * 
 * Custom alert component for the CSTestForge framework.
 * Provides customizable alerts with different types, icons, and actions.
 */

import React, { useState, useEffect, useRef } from 'react';
import './Alert.scss';

/**
 * Alert type enum
 */
export enum AlertType {
  INFO = 'info',
  SUCCESS = 'success',
  WARNING = 'warning',
  ERROR = 'error'
}

/**
 * Alert props interface
 */
export interface AlertProps {
  /**
   * Alert title
   */
  title?: string;
  
  /**
   * Alert message
   */
  message: string;
  
  /**
   * Alert type
   */
  type?: AlertType;
  
  /**
   * Whether to show an icon based on type
   */
  showIcon?: boolean;
  
  /**
   * Custom icon
   */
  icon?: React.ReactNode;
  
  /**
   * Whether the alert is closable
   */
  closable?: boolean;
  
  /**
   * Custom close icon
   */
  closeIcon?: React.ReactNode;
  
  /**
   * Whether the alert should be shown
   */
  visible?: boolean;
  
  /**
   * Callback when alert is closed
   */
  onClose?: () => void;
  
  /**
   * Whether to automatically close the alert after a certain duration
   */
  autoClose?: boolean;
  
  /**
   * Duration in milliseconds before auto-closing
   */
  duration?: number;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Banner mode (full width)
   */
  banner?: boolean;
  
  /**
   * Whether the alert is outlined
   */
  outlined?: boolean;
  
  /**
   * Whether the alert is filled
   */
  filled?: boolean;
  
  /**
   * Whether the alert has a progress bar for auto-close
   */
  showProgress?: boolean;
  
  /**
   * Additional action button content
   */
  action?: React.ReactNode;
  
  /**
   * Callback when action button is clicked
   */
  onAction?: () => void;
  
  /**
   * Whether the alert should animate when shown/hidden
   */
  animate?: boolean;
  
  /**
   * Animation duration in milliseconds
   */
  animationDuration?: number;
  
  /**
   * Whether the alert should be displayed as a toast-like notification
   */
  toast?: boolean;
  
  /**
   * Whether the alert should expand on hover
   */
  expandOnHover?: boolean;
  
  /**
   * Whether the alert should be dismissible by clicking
   */
  dismissible?: boolean;
  
  /**
   * Children
   */
  children?: React.ReactNode;
}

/**
 * Alert component
 */
const Alert: React.FC<AlertProps> = (props) => {
  const {
    title,
    message,
    type = AlertType.INFO,
    showIcon = true,
    icon,
    closable = true,
    closeIcon,
    visible = true,
    onClose,
    autoClose = false,
    duration = 5000,
    className = '',
    style,
    banner = false,
    outlined = false,
    filled = false,
    showProgress = true,
    action,
    onAction,
    animate = true,
    animationDuration = 300,
    toast = false,
    expandOnHover = false,
    dismissible = false,
    children
  } = props;

  // Component state
  const [isVisible, setIsVisible] = useState<boolean>(visible);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const [animationState, setAnimationState] = useState<'entering' | 'entered' | 'exiting' | 'exited'>(
    visible ? 'entered' : 'exited'
  );
  
  // Refs
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const remainingTimeRef = useRef<number>(duration);
  const startTimeRef = useRef<number>(0);
  const alertRef = useRef<HTMLDivElement>(null);
  
  // Start timer for auto-close
  const startTimer = () => {
    if (!autoClose || isPaused) return;
    
    startTimeRef.current = Date.now();
    
    timerRef.current = setTimeout(() => {
      handleClose();
    }, remainingTimeRef.current);
  };
  
  // Pause timer
  const pauseTimer = () => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
      
      // Calculate remaining time
      const elapsedTime = Date.now() - startTimeRef.current;
      remainingTimeRef.current = Math.max(0, remainingTimeRef.current - elapsedTime);
    }
  };
  
  // Handle mouse enter to pause timer
  const handleMouseEnter = () => {
    if (autoClose && expandOnHover) {
      setIsPaused(true);
      pauseTimer();
    }
  };
  
  // Handle mouse leave to resume timer
  const handleMouseLeave = () => {
    if (autoClose && expandOnHover) {
      setIsPaused(false);
      startTimer();
    }
  };
  
  // Handle alert click if dismissible
  const handleClick = () => {
    if (dismissible) {
      handleClose();
    }
  };
  
  // Handle close action
  const handleClose = () => {
    if (animate) {
      setAnimationState('exiting');
      
      // Wait for animation to complete before removing from DOM
      setTimeout(() => {
        setIsVisible(false);
        setAnimationState('exited');
        
        if (onClose) {
          onClose();
        }
      }, animationDuration);
    } else {
      setIsVisible(false);
      setAnimationState('exited');
      
      if (onClose) {
        onClose();
      }
    }
    
    // Clear any existing timers
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
  };
  
  // Handle action button click
  const handleAction = () => {
    if (onAction) {
      onAction();
    }
  };
  
  // Effect to start/stop timer based on visibility
  useEffect(() => {
    if (visible && isVisible && autoClose) {
      remainingTimeRef.current = duration;
      startTimer();
    } else {
      pauseTimer();
    }
    
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, [visible, isVisible, autoClose, duration]);
  
  // Effect to handle visibility prop changes
  useEffect(() => {
    if (visible && !isVisible) {
      setIsVisible(true);
      setAnimationState(animate ? 'entering' : 'entered');
      
      if (animate) {
        setTimeout(() => {
          setAnimationState('entered');
        }, animationDuration);
      }
    } else if (!visible && isVisible) {
      if (animate) {
        setAnimationState('exiting');
        
        setTimeout(() => {
          setIsVisible(false);
          setAnimationState('exited');
        }, animationDuration);
      } else {
        setIsVisible(false);
        setAnimationState('exited');
      }
    }
  }, [visible, animate, animationDuration]);
  
  // Render icon based on type
  const renderIcon = () => {
    if (!showIcon) {
      return null;
    }
    
    if (icon) {
      return <div className="cs-alert-icon">{icon}</div>;
    }
    
    let iconContent = '';
    
    switch (type) {
      case AlertType.SUCCESS:
        iconContent = '✓';
        break;
      case AlertType.WARNING:
        iconContent = '⚠️';
        break;
      case AlertType.ERROR:
        iconContent = '✕';
        break;
      case AlertType.INFO:
      default:
        iconContent = 'ℹ';
        break;
    }
    
    return <div className={`cs-alert-icon cs-alert-icon-${type}`}>{iconContent}</div>;
  };
  
  // Render close button if closable
  const renderCloseButton = () => {
    if (!closable) {
      return null;
    }
    
    return (
      <button
        type="button"
        className="cs-alert-close"
        onClick={handleClose}
        aria-label="Close"
      >
        {closeIcon || '×'}
      </button>
    );
  };
  
  // Render action button if provided
  const renderAction = () => {
    if (!action) {
      return null;
    }
    
    return (
      <div className="cs-alert-action">
        {typeof action === 'string' ? (
          <button
            type="button"
            className="cs-alert-action-button"
            onClick={handleAction}
          >
            {action}
          </button>
        ) : (
          <div onClick={handleAction}>{action}</div>
        )}
      </div>
    );
  };
  
  // Render progress bar if auto-close and showProgress
  const renderProgressBar = () => {
    if (!autoClose || !showProgress) {
      return null;
    }
    
    return (
      <div className="cs-alert-progress">
        <div
          className="cs-alert-progress-bar"
          style={{
            animationDuration: `${duration}ms`,
            animationPlayState: isPaused ? 'paused' : 'running'
          }}
        />
      </div>
    );
  };
  
  // If not visible, don't render
  if (!isVisible && animationState === 'exited') {
    return null;
  }
  
  // Build class names
  const alertClassNames = [
    'cs-alert',
    `cs-alert-${type}`,
    animationState === 'entering' ? 'cs-alert-entering' : '',
    animationState === 'exiting' ? 'cs-alert-exiting' : '',
    banner ? 'cs-alert-banner' : '',
    outlined ? 'cs-alert-outlined' : '',
    filled ? 'cs-alert-filled' : '',
    toast ? 'cs-alert-toast' : '',
    expandOnHover ? 'cs-alert-expandable' : '',
    className
  ].filter(Boolean).join(' ');
  
  // Render component
  return (
    <div
      ref={alertRef}
      className={alertClassNames}
      style={{
        ...style,
        animationDuration: `${animationDuration}ms`
      }}
      role="alert"
      aria-live="polite"
      onClick={handleClick}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      {renderIcon()}
      
      <div className="cs-alert-content">
        {title && <div className="cs-alert-title">{title}</div>}
        <div className="cs-alert-message">{message}</div>
        {children && <div className="cs-alert-children">{children}</div>}
      </div>
      
      {renderAction()}
      {renderCloseButton()}
      {renderProgressBar()}
    </div>
  );
};

export default Alert;


/**
 * Alert.scss
 * 
 * Styles for the custom alert component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$success-light: lighten($success, 40%);
$success-dark: darken($success, 10%);
$info: #17a2b8;
$info-light: lighten($info, 40%);
$info-dark: darken($info, 10%);
$warning: #ffc107;
$warning-light: lighten($warning, 40%);
$warning-dark: darken($warning, 10%);
$danger: #dc3545;
$danger-light: lighten($danger, 40%);
$danger-dark: darken($danger, 10%);

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius: 4px;

// Transitions
$transition-base: all 0.2s ease-in-out;

// Base Alert styles
.cs-alert {
  display: flex;
  align-items: flex-start;
  width: 100%;
  padding: $spacer * 1.5;
  margin-bottom: $spacer * 2;
  border-radius: $border-radius;
  font-family: $font-family;
  font-size: $font-size-base;
  line-height: $line-height-base;
  position: relative;
  overflow: hidden;
  
  // Type variants with default soft background
  &.cs-alert-info {
    background-color: $info-light;
    border-left: 4px solid $info;
    color: $info-dark;
  }
  
  &.cs-alert-success {
    background-color: $success-light;
    border-left: 4px solid $success;
    color: $success-dark;
  }
  
  &.cs-alert-warning {
    background-color: $warning-light;
    border-left: 4px solid $warning;
    color: $warning-dark;
  }
  
  &.cs-alert-error {
    background-color: $danger-light;
    border-left: 4px solid $danger;
    color: $danger-dark;
  }
  
  // Outlined variant
  &.cs-alert-outlined {
    background-color: transparent;
    
    &.cs-alert-info {
      border: 1px solid $info;
      border-left-width: 4px;
    }
    
    &.cs-alert-success {
      border: 1px solid $success;
      border-left-width: 4px;
    }
    
    &.cs-alert-warning {
      border: 1px solid $warning;
      border-left-width: 4px;
    }
    
    &.cs-alert-error {
      border: 1px solid $danger;
      border-left-width: 4px;
    }
  }
  
  // Filled variant
  &.cs-alert-filled {
    color: $white;
    
    &.cs-alert-info {
      background-color: $info;
      border-left: none;
    }
    
    &.cs-alert-success {
      background-color: $success;
      border-left: none;
    }
    
    &.cs-alert-warning {
      background-color: $warning;
      border-left: none;
      color: $gray-900; // Better contrast for warning
    }
    
    &.cs-alert-error {
      background-color: $danger;
      border-left: none;
    }
  }
  
  // Banner variant (full width)
  &.cs-alert-banner {
    border-radius: 0;
    border-left: none;
    border-right: none;
    margin-left: 0;
    margin-right: 0;
  }
  
  // Toast variant
  &.cs-alert-toast {
    position: fixed;
    top: $spacer * 2;
    right: $spacer * 2;
    width: 300px;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
    z-index: 9999;
  }
  
  // Expandable variant
  &.cs-alert-expandable {
    transition: transform 0.3s ease;
    
    &:hover {
      transform: scale(1.02);
    }
  }
  
  // Icon
  &-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    width: 24px;
    height: 24px;
    margin-right: $spacer * 1.5;
    font-size: 18px;
    
    &-info {
      color: $info;
    }
    
    &-success {
      color: $success;
    }
    
    &-warning {
      color: $warning;
    }
    
    &-error {
      color: $danger;
    }
  }
  
  &.cs-alert-filled &-icon {
    color: $white;
    
    &-warning {
      color: $gray-900;
    }
  }
  
  // Content
  &-content {
    flex: 1;
    min-width: 0;
  }
  
  // Title
  &-title {
    margin-bottom: $spacer / 2;
    font-weight: bold;
  }
  
  // Message
  &-message {
    margin-bottom: 0;
  }
  
  // Children
  &-children {
    margin-top: $spacer;
  }
  
  // Close button
  &-close {
    position: absolute;
    top: $spacer;
    right: $spacer;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    padding: 0;
    background: none;
    border: none;
    border-radius: 50%;
    font-size: 18px;
    line-height: 1;
    cursor: pointer;
    transition: $transition-base;
    opacity: 0.7;
    
    &:hover {
      opacity: 1;
      background-color: rgba(0, 0, 0, 0.1);
    }
    
    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
    }
  }
  
  &.cs-alert-filled &-close {
    color: $white;
    
    &:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    &:focus {
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
    }
  }
  
  &.cs-alert-warning.cs-alert-filled &-close {
    color: $gray-900;
  }
  
  // Action
  &-action {
    margin-left: $spacer * 1.5;
    display: flex;
    align-items: center;
  }
  
  &-action-button {
    padding: $spacer / 2 $spacer;
    background-color: rgba(0, 0, 0, 0.1);
    border: none;
    border-radius: $border-radius;
    cursor: pointer;
    transition: $transition-base;
    
    &:hover {
      background-color: rgba(0, 0, 0, 0.2);
    }
    
    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
    }
  }
  
  &.cs-alert-filled &-action-button {
    background-color: rgba(255, 255, 255, 0.2);
    color: $white;
    
    &:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }
    
    &:focus {
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
    }
  }
  
  &.cs-alert-warning.cs-alert-filled &-action-button {
    color: $gray-900;
  }
  
  // Progress bar
  &-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 4px;
    background-color: rgba(0, 0, 0, 0.1);
  }
  
  &-progress-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    transform-origin: left;
    animation: cs-alert-progress 5000ms linear forwards;
    
    .cs-alert-info & {
      background-color: $info;
    }
    
    .cs-alert-success & {
      background-color: $success;
    }
    
    .cs-alert-warning & {
      background-color: $warning;
    }
    
    .cs-alert-error & {
      background-color: $danger;
    }
  }
  
  @keyframes cs-alert-progress {
    from {
      transform: scaleX(1);
    }
    to {
      transform: scaleX(0);
    }
  }
  
  // Animations
  &-entering {
    animation: cs-alert-fade-in 0.3s ease forwards;
  }
  
  &-exiting {
    animation: cs-alert-fade-out 0.3s ease forwards;
  }
  
  @keyframes cs-alert-fade-in {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  @keyframes cs-alert-fade-out {
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(-10px);
    }
  }
}

// RTL support
[dir="rtl"] .cs-alert {
  text-align: right;
  
  &:not(.cs-alert-filled) {
    border-left: none;
    border-right: 4px solid;
  }
  
  &-icon {
    margin-right: 0;
    margin-left: $spacer * 1.5;
  }
  
  &-close {
    right: auto;
    left: $spacer;
  }
  
  &-action {
    margin-left: 0;
    margin-right: $spacer * 1.5;
  }
  
  &-progress-bar {
    transform-origin: right;
  }
  
  &.cs-alert-toast {
    right: auto;
    left: $spacer * 2;
  }
  
  &.cs-alert-outlined {
    &:not(.cs-alert-filled) {
      border-right-width: 4px;
    }
  }
}

// Dark mode support
.cs-alert.cs-alert-dark {
  // Type variants in dark mode
  &.cs-alert-info {
    background-color: rgba($info, 0.2);
    color: lighten($info, 20%);
  }
  
  &.cs-alert-success {
    background-color: rgba($success, 0.2);
    color: lighten($success, 20%);
  }
  
  &.cs-alert-warning {
    background-color: rgba($warning, 0.2);
    color: $warning;
  }
  
  &.cs-alert-error {
    background-color: rgba($danger, 0.2);
    color: lighten($danger, 20%);
  }
  
  // Outlined variant in dark mode
  &.cs-alert-outlined {
    background-color: transparent;
  }
  
  // Filled variant in dark mode
  &.cs-alert-filled {
    &.cs-alert-info {
      background-color: darken($info, 10%);
    }
    
    &.cs-alert-success {
      background-color: darken($success, 10%);
    }
    
    &.cs-alert-warning {
      background-color: darken($warning, 10%);
    }
    
    &.cs-alert-error {
      background-color: darken($danger, 10%);
    }
  }
  
  // Close button in dark mode
  &-close {
    opacity: 0.8;
    
    &:hover {
      opacity: 1;
      background-color: rgba(255, 255, 255, 0.1);
    }
  }
  
  // Action button in dark mode
  &-action-button {
    background-color: rgba(255, 255, 255, 0.1);
    
    &:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
  }
  
  // Progress bar in dark mode
  &-progress {
    background-color: rgba(255, 255, 255, 0.1);
  }
}

// High contrast mode
.cs-alert.cs-alert-high-contrast {
  border-width: 2px;
  
  &.cs-alert-filled {
    border: 2px solid $black;
  }
  
  &-close {
    border: 1px solid currentColor;
  }
  
  &-action-button {
    border: 1px solid currentColor;
  }
  
  &-progress {
    height: 6px;
  }
}

// Mobile styles
@media (max-width: 576px) {
  .cs-alert {
    flex-direction: column;
    
    &-icon {
      margin-right: 0;
      margin-bottom: $spacer;
    }
    
    &-action {
      margin-left: 0;
      margin-top: $spacer;
      align-self: flex-end;
    }
    
    &-close {
      top: $spacer / 2;
      right: $spacer / 2;
    }
    
    &.cs-alert-toast {
      width: calc(100% - #{$spacer * 4});
      left: $spacer * 2;
      right: $spacer * 2;
    }
  }
  
  [dir="rtl"] .cs-alert {
    &-icon {
      margin-left: 0;
    }
    
    &-action {
      margin-right: 0;
      align-self: flex-start;
    }
    
    &-close {
      left: $spacer / 2;
    }
  }
}

// Print styles
@media print {
  .cs-alert.cs-alert-toast {
    display: none !important;
  }
}

// Focus styles for accessibility
.cs-alert {
  &:focus-within {
    outline: 2px solid rgba(0, 0, 0, 0.2);
    outline-offset: 2px;
  }
  
  &.cs-alert-filled:focus-within {
    outline-color: rgba(255, 255, 255, 0.5);
  }
  
  // Keyboard focus styles
  &-close:focus-visible,
  &-action-button:focus-visible {
    outline: 2px solid $primary-color;
    outline-offset: 2px;
  }
}


/**
 * Progress.tsx
 * 
 * Custom progress indicator component for the CSTestForge framework.
 * Provides customizable progress bars and circular progress indicators.
 */

import React, { useState, useEffect, useRef } from 'react';
import './Progress.scss';

/**
 * Progress type enum
 */
export enum ProgressType {
  LINE = 'line',
  CIRCLE = 'circle',
  DASHBOARD = 'dashboard'
}

/**
 * Progress status enum
 */
export enum ProgressStatus {
  NORMAL = 'normal',
  EXCEPTION = 'exception',
  SUCCESS = 'success',
  ACTIVE = 'active'
}

/**
 * Progress size enum
 */
export enum ProgressSize {
  SMALL = 'small',
  DEFAULT = 'default',
  LARGE = 'large'
}

/**
 * Progress bar stroke linecap
 */
export type StrokeLinecap = 'butt' | 'round' | 'square';

/**
 * Progress gradient colors
 */
export interface GradientColor {
  /**
   * Color stop percentage
   */
  offset: string;
  
  /**
   * Color value
   */
  color: string;
}

/**
 * Progress props interface
 */
export interface ProgressProps {
  /**
   * Progress type (line, circle, dashboard)
   */
  type?: ProgressType;
  
  /**
   * Progress percentage (0-100)
   */
  percent?: number;
  
  /**
   * Progress status
   */
  status?: ProgressStatus;
  
  /**
   * Show info (percent or icon)
   */
  showInfo?: boolean;
  
  /**
   * Progress stroke width
   */
  strokeWidth?: number;
  
  /**
   * Stroke line cap style
   */
  strokeLinecap?: StrokeLinecap;
  
  /**
   * Progress stroke color
   */
  strokeColor?: string | GradientColor[] | { from: string; to: string };
  
  /**
   * Trail stroke color
   */
  trailColor?: string;
  
  /**
   * Trail stroke width
   */
  trailWidth?: number;
  
  /**
   * Progress width (for circle/dashboard)
   */
  width?: number;
  
  /**
   * Progress size
   */
  size?: ProgressSize | number;
  
  /**
   * Dashboard gapDegree (0-360)
   */
  gapDegree?: number;
  
  /**
   * Dashboard gap position
   */
  gapPosition?: 'top' | 'bottom' | 'left' | 'right';
  
  /**
   * Custom format function for info
   */
  format?: (percent?: number) => React.ReactNode;
  
  /**
   * Progress steps count
   */
  steps?: number;
  
  /**
   * Whether to animate progress
   */
  animate?: boolean;
  
  /**
   * Animation duration in milliseconds
   */
  animationDuration?: number;
  
  /**
   * Whether to show success or exception icon
   */
  showStatusIcon?: boolean;
  
  /**
   * Custom success icon
   */
  successIcon?: React.ReactNode;
  
  /**
   * Custom exception icon
   */
  exceptionIcon?: React.ReactNode;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Callback when progress status changes
   */
  onStatusChange?: (status: ProgressStatus) => void;
  
  /**
   * Callback when progress is completed (100%)
   */
  onComplete?: () => void;
}

/**
 * Progress component
 */
const Progress: React.FC<ProgressProps> = (props) => {
  const {
    type = ProgressType.LINE,
    percent = 0,
    status = ProgressStatus.NORMAL,
    showInfo = true,
    strokeWidth = 6,
    strokeLinecap = 'round',
    strokeColor = '#C54B8C', // Primary brand color
    trailColor = '#f5f5f5',
    trailWidth,
    width = 120,
    size = ProgressSize.DEFAULT,
    gapDegree = 0,
    gapPosition = 'top',
    format,
    steps,
    animate = true,
    animationDuration = 1000,
    showStatusIcon = true,
    successIcon,
    exceptionIcon,
    className = '',
    style,
    onStatusChange,
    onComplete
  } = props;

  // Component state
  const [displayPercent, setDisplayPercent] = useState<number>(animate ? 0 : percent);
  const [currentStatus, setCurrentStatus] = useState<ProgressStatus>(status);
  const [prevPercent, setPrevPercent] = useState<number>(0);
  
  // Refs
  const progressRef = useRef<HTMLDivElement>(null);
  const animationRef = useRef<number | null>(null);
  const completedRef = useRef<boolean>(false);
  
  // Effect to handle percent and animation
  useEffect(() => {
    if (!animate) {
      setDisplayPercent(percent);
      return;
    }
    
    if (prevPercent === percent) {
      return;
    }
    
    setPrevPercent(percent);
    
    const startAnimationTime = Date.now();
    const startValue = displayPercent;
    const endValue = percent;
    const change = endValue - startValue;
    
    // Clear any existing animation
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    
    // Animation function
    const animateProgress = () => {
      const currentTime = Date.now();
      const elapsed = currentTime - startAnimationTime;
      
      if (elapsed >= animationDuration) {
        setDisplayPercent(endValue);
        
        // Check if completed
        if (endValue >= 100 && !completedRef.current) {
          completedRef.current = true;
          
          if (onComplete) {
            onComplete();
          }
        } else if (endValue < 100) {
          completedRef.current = false;
        }
        
        return;
      }
      
      // Calculate progress with easing function (ease-out)
      const progress = 1 - Math.pow(1 - elapsed / animationDuration, 2);
      const newValue = startValue + change * progress;
      
      setDisplayPercent(newValue);
      
      // Continue animation
      animationRef.current = requestAnimationFrame(animateProgress);
    };
    
    // Start animation
    animationRef.current = requestAnimationFrame(animateProgress);
    
    // Cleanup
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [percent, animate, animationDuration]);
  
  // Effect to handle status changes
  useEffect(() => {
    if (status !== currentStatus) {
      setCurrentStatus(status);
      
      if (onStatusChange) {
        onStatusChange(status);
      }
    } else if (percent >= 100 && currentStatus === ProgressStatus.NORMAL) {
      setCurrentStatus(ProgressStatus.SUCCESS);
      
      if (onStatusChange) {
        onStatusChange(ProgressStatus.SUCCESS);
      }
    } else if (percent < 100 && (currentStatus === ProgressStatus.SUCCESS || currentStatus === ProgressStatus.EXCEPTION)) {
      setCurrentStatus(ProgressStatus.NORMAL);
      
      if (onStatusChange) {
        onStatusChange(ProgressStatus.NORMAL);
      }
    }
  }, [percent, status, currentStatus, onStatusChange]);
  
  // Get size in pixels
  const getSize = (): number => {
    if (typeof size === 'number') {
      return size;
    }
    
    switch (size) {
      case ProgressSize.SMALL:
        return 80;
      case ProgressSize.LARGE:
        return 160;
      case ProgressSize.DEFAULT:
      default:
        return 120;
    }
  };
  
  // Get stroke width based on size
  const getStrokeWidth = (): number => {
    if (strokeWidth) {
      return strokeWidth;
    }
    
    if (typeof size === 'number') {
      return Math.max(6, size / 20);
    }
    
    switch (size) {
      case ProgressSize.SMALL:
        return 4;
      case ProgressSize.LARGE:
        return 8;
      case ProgressSize.DEFAULT:
      default:
        return 6;
    }
  };
  
  // Get trail width
  const getTrailWidth = (): number => {
    return trailWidth || getStrokeWidth();
  };
  
  // Get progress stroke color with gradient support
  const getStrokeColor = (): string | React.ReactNode => {
    // Handle exception and success status
    if (currentStatus === ProgressStatus.EXCEPTION) {
      return '#dc3545'; // Red color for exception
    }
    
    if (currentStatus === ProgressStatus.SUCCESS) {
      return '#28a745'; // Green color for success
    }
    
    // Handle gradient color
    if (typeof strokeColor === 'object') {
      if (Array.isArray(strokeColor)) {
        // Array of gradient colors
        if (type === ProgressType.LINE) {
          // Linear gradient for line progress
          return (
            <linearGradient id="progress-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
              {strokeColor.map((color, index) => (
                <stop
                  key={index}
                  offset={color.offset}
                  stopColor={color.color}
                />
              ))}
            </linearGradient>
          );
        } else {
          // Radial gradient for circle/dashboard progress
          return (
            <linearGradient
              id="progress-gradient"
              x1="100%"
              y1="0%"
              x2="0%"
              y2="0%"
            >
              {strokeColor.map((color, index) => (
                <stop
                  key={index}
                  offset={color.offset}
                  stopColor={color.color}
                />
              ))}
            </linearGradient>
          );
        }
      } else {
        // From-to gradient
        if (type === ProgressType.LINE) {
          // Linear gradient for line progress
          return (
            <linearGradient id="progress-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stopColor={strokeColor.from} />
              <stop offset="100%" stopColor={strokeColor.to} />
            </linearGradient>
          );
        } else {
          // Radial gradient for circle/dashboard progress
          return (
            <linearGradient
              id="progress-gradient"
              x1="100%"
              y1="0%"
              x2="0%"
              y2="0%"
            >
              <stop offset="0%" stopColor={strokeColor.from} />
              <stop offset="100%" stopColor={strokeColor.to} />
            </linearGradient>
          );
        }
      }
    }
    
    // Single color
    return strokeColor;
  };
  
  // Get info content
  const getInfo = (): React.ReactNode => {
    if (!showInfo) {
      return null;
    }
    
    // Format function
    if (format) {
      return format(displayPercent);
    }
    
    // Show icon for success/exception status
    if (showStatusIcon) {
      if (currentStatus === ProgressStatus.EXCEPTION) {
        return exceptionIcon || <span className="cs-progress-icon cs-progress-icon-exception">✕</span>;
      }
      
      if (currentStatus === ProgressStatus.SUCCESS) {
        return successIcon || <span className="cs-progress-icon cs-progress-icon-success">✓</span>;
      }
    }
    
    // Show percentage
    return <span className="cs-progress-text">{Math.round(displayPercent)}%</span>;
  };
  
  // Render steps progress
  const renderStepsProgress = (): React.ReactNode => {
    if (!steps || steps <= 0) {
      return null;
    }
    
    const stepsArray = Array.from({ length: steps }, (_, i) => i);
    const stepWidth = 100 / steps;
    const currentStep = Math.floor(displayPercent / stepWidth);
    
    return (
      <div className="cs-progress-steps">
        {stepsArray.map((step) => {
          const isActive = step <= currentStep;
          
          return (
            <div
              key={step}
              className={`cs-progress-step ${isActive ? 'cs-progress-step-active' : ''}`}
              style={{
                width: `calc(${100 / steps}% - 4px)`,
                backgroundColor: isActive ? (typeof strokeColor === 'string' ? strokeColor : undefined) : trailColor
              }}
            />
          );
        })}
      </div>
    );
  };
  
  // Render line progress
  const renderLineProgress = (): React.ReactNode => {
    if (steps && steps > 0) {
      return renderStepsProgress();
    }
    
    const trackWidth = displayPercent + '%';
    const trackStyle: React.CSSProperties = {
      width: trackWidth,
      height: strokeWidth,
      borderRadius: strokeLinecap === 'round' ? strokeWidth / 2 : 0
    };
    
    // Gradient color support
    let trackColor: string | undefined;
    
    if (typeof strokeColor === 'object') {
      trackColor = 'url(#progress-gradient)';
    } else {
      trackColor = getStrokeColor() as string;
    }
    
    return (
      <div
        className="cs-progress-outer"
        style={{ height: strokeWidth, backgroundColor: trailColor }}
      >
        <div
          className={`cs-progress-inner cs-progress-status-${currentStatus}`}
          style={{
            ...trackStyle,
            backgroundColor: trackColor
          }}
        />
        
        {/* SVG for gradient definition */}
        {typeof strokeColor === 'object' && (
          <svg width="0" height="0">
            {getStrokeColor()}
          </svg>
        )}
      </div>
    );
  };
  
  // Render circle/dashboard progress
  const renderCircleProgress = (): React.ReactNode => {
    const strokeWidth = getStrokeWidth();
    const trailWidth = getTrailWidth();
    const sizeValue = getSize();
    const radius = (sizeValue - strokeWidth) / 2;
    const circumference = 2 * Math.PI * radius;
    
    // Calculate dash values
    let dashOffset = 0;
    let dashArray = circumference;
    
    if (type === ProgressType.DASHBOARD) {
      // Dashboard gap
      const gap = gapDegree / 360;
      dashArray = circumference * (1 - gap);
      
      // Determine starting position based on gap position
      switch (gapPosition) {
        case 'left':
          dashOffset = circumference * (1 / 4 - gap / 2);
          break;
        case 'right':
          dashOffset = circumference * (3 / 4 - gap / 2);
          break;
        case 'bottom':
          dashOffset = circumference * (1 / 2 - gap / 2);
          break;
        case 'top':
        default:
          dashOffset = circumference * (0 - gap / 2);
          break;
      }
    }
    
    // Calculate progress
    const progressOffset = dashArray - (dashArray * displayPercent) / 100;
    
    // Gradient color support
    let progressColor: string;
    
    if (typeof strokeColor === 'object') {
      progressColor = 'url(#progress-gradient)';
    } else {
      progressColor = getStrokeColor() as string;
    }
    
    return (
      <div
        className="cs-progress-circle-outer"
        style={{
          width: sizeValue,
          height: sizeValue
        }}
      >
        <svg
          viewBox={`0 0 ${sizeValue} ${sizeValue}`}
          width={sizeValue}
          height={sizeValue}
        >
          {/* Gradient definition */}
          {typeof strokeColor === 'object' && getStrokeColor()}
          
          {/* Background track */}
          <circle
            className="cs-progress-circle-trail"
            cx={sizeValue / 2}
            cy={sizeValue / 2}
            r={radius}
            fill="none"
            strokeWidth={trailWidth}
            stroke={trailColor}
            strokeLinecap={strokeLinecap}
            strokeDasharray={dashArray}
            strokeDashoffset={dashOffset}
            style={{
              transform: 'rotate(-90deg)',
              transformOrigin: 'center'
            }}
          />
          
          {/* Progress track */}
          <circle
            className={`cs-progress-circle-path cs-progress-status-${currentStatus}`}
            cx={sizeValue / 2}
            cy={sizeValue / 2}
            r={radius}
            fill="none"
            strokeWidth={strokeWidth}
            stroke={progressColor}
            strokeLinecap={strokeLinecap}
            strokeDasharray={dashArray}
            strokeDashoffset={progressOffset + dashOffset}
            style={{
              transform: 'rotate(-90deg)',
              transformOrigin: 'center',
              transition: animate ? `stroke-dashoffset ${animationDuration}ms ease-out` : 'none'
            }}
          />
        </svg>
        
        {/* Info text in center */}
        {showInfo && (
          <div className="cs-progress-circle-info">
            {getInfo()}
          </div>
        )}
      </div>
    );
  };
  
  // Build component class names
  const componentClassNames = [
    'cs-progress',
    `cs-progress-${type}`,
    `cs-progress-status-${currentStatus}`,
    typeof size === 'string' ? `cs-progress-${size}` : '',
    className
  ].filter(Boolean).join(' ');
  
  // Render component
  return (
    <div
      ref={progressRef}
      className={componentClassNames}
      style={style}
      role="progressbar"
      aria-valuenow={Math.round(displayPercent)}
      aria-valuemin={0}
      aria-valuemax={100}
    >
      {/* Render progress based on type */}
      {(type === ProgressType.LINE) && renderLineProgress()}
      {(type === ProgressType.CIRCLE || type === ProgressType.DASHBOARD) && renderCircleProgress()}
      
      {/* Info text (only for line progress outside the bar) */}
      {showInfo && type === ProgressType.LINE && (
        <div className="cs-progress-info">
          {getInfo()}
        </div>
      )}
    </div>
  );
};

export default Progress;


/**
 * Spinner.tsx
 * 
 * Custom spinner component for the CSTestForge framework.
 * Provides customizable loading spinners with different types, sizes, and colors.
 */

import React from 'react';
import './Spinner.scss';

/**
 * Spinner type enum
 */
export enum SpinnerType {
  BORDER = 'border',
  GROW = 'grow',
  CHASE = 'chase',
  BOUNCE = 'bounce',
  PULSE = 'pulse',
  WAVE = 'wave',
  RING = 'ring',
  DUAL_RING = 'dual-ring',
  RIPPLE = 'ripple',
  GRID = 'grid'
}

/**
 * Spinner size enum
 */
export enum SpinnerSize {
  SMALL = 'small',
  MEDIUM = 'medium',
  LARGE = 'large'
}

/**
 * Spinner props interface
 */
export interface SpinnerProps {
  /**
   * Spinner type
   */
  type?: SpinnerType;
  
  /**
   * Spinner size
   */
  size?: SpinnerSize | number;
  
  /**
   * Spinner color
   */
  color?: string;
  
  /**
   * Whether to show text
   */
  showText?: boolean;
  
  /**
   * Loading text
   */
  text?: string;
  
  /**
   * Text position
   */
  textPosition?: 'left' | 'right' | 'top' | 'bottom';
  
  /**
   * Whether to center the spinner
   */
  centered?: boolean;
  
  /**
   * Whether to show fullscreen overlay
   */
  fullscreen?: boolean;
  
  /**
   * Overlay background color
   */
  overlayColor?: string;
  
  /**
   * Whether to show spinner in a container
   */
  container?: boolean;
  
  /**
   * Container height
   */
  containerHeight?: number | string;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Delay before showing spinner (ms)
   */
  delay?: number;
  
  /**
   * Speed of animation
   */
  speed?: 'slow' | 'normal' | 'fast' | number;
  
  /**
   * Accessibility indicator label
   */
  ariaLabel?: string;
  
  /**
   * Spinner thickness (for border, ring types)
   */
  thickness?: number | string;
  
  /**
   * Whether the spinner is visible
   */
  visible?: boolean;
  
  /**
   * Additional inner content
   */
  children?: React.ReactNode;
}

/**
 * Spinner component
 */
const Spinner: React.FC<SpinnerProps> = (props) => {
  const {
    type = SpinnerType.BORDER,
    size = SpinnerSize.MEDIUM,
    color = '#C54B8C', // Primary brand color
    showText = false,
    text = 'Loading...',
    textPosition = 'right',
    centered = false,
    fullscreen = false,
    overlayColor = 'rgba(255, 255, 255, 0.8)',
    container = false,
    containerHeight = 200,
    className = '',
    style,
    delay = 0,
    speed = 'normal',
    ariaLabel = 'Loading',
    thickness,
    visible = true,
    children
  } = props;

  // If not visible, don't render
  if (!visible) {
    return null;
  }
  
  // Get size in pixels
  const getSize = (): number | string => {
    if (typeof size === 'number') {
      return size;
    }
    
    switch (size) {
      case SpinnerSize.SMALL:
        return 16;
      case SpinnerSize.LARGE:
        return 48;
      case SpinnerSize.MEDIUM:
      default:
        return 32;
    }
  };
  
  // Get animation duration based on speed
  const getAnimationDuration = (): string => {
    if (typeof speed === 'number') {
      return `${speed}ms`;
    }
    
    switch (speed) {
      case 'slow':
        return '1.5s';
      case 'fast':
        return '0.5s';
      case 'normal':
      default:
        return '1s';
    }
  };
  
  // Get spinner thickness
  const getThickness = (): number | string => {
    if (thickness !== undefined) {
      return thickness;
    }
    
    const sizeValue = getSize();
    
    if (typeof sizeValue === 'number') {
      return Math.max(2, sizeValue / 8);
    }
    
    return '0.25em';
  };
  
  // Render border spinner
  const renderBorderSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    const borderWidth = getThickness();
    
    return (
      <div
        className="cs-spinner-border"
        style={{
          width: sizeValue,
          height: sizeValue,
          borderWidth: borderWidth,
          borderTopColor: color,
          animationDuration: getAnimationDuration()
        }}
      />
    );
  };
  
  // Render grow spinner
  const renderGrowSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    
    return (
      <div
        className="cs-spinner-grow"
        style={{
          width: sizeValue,
          height: sizeValue,
          backgroundColor: color,
          animationDuration: getAnimationDuration()
        }}
      />
    );
  };
  
  // Render chase spinner
  const renderChaseSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    const dotSize = typeof sizeValue === 'number' ? sizeValue / 4 : '25%';
    
    return (
      <div
        className="cs-spinner-chase"
        style={{
          width: sizeValue,
          height: sizeValue
        }}
      >
        {[...Array(6)].map((_, index) => (
          <div
            key={index}
            className="cs-spinner-chase-dot"
            style={{
              width: dotSize,
              height: dotSize,
              backgroundColor: color,
              animationDuration: getAnimationDuration()
            }}
          />
        ))}
      </div>
    );
  };
  
  // Render bounce spinner
  const renderBounceSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    
    return (
      <div
        className="cs-spinner-bounce"
        style={{
          width: sizeValue,
          height: sizeValue
        }}
      >
        <div
          className="cs-spinner-bounce-dot"
          style={{
            backgroundColor: color,
            animationDuration: getAnimationDuration()
          }}
        />
        <div
          className="cs-spinner-bounce-dot"
          style={{
            backgroundColor: color,
            animationDuration: getAnimationDuration()
          }}
        />
      </div>
    );
  };
  
  // Render pulse spinner
  const renderPulseSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    
    return (
      <div
        className="cs-spinner-pulse"
        style={{
          width: sizeValue,
          height: sizeValue,
          backgroundColor: color,
          animationDuration: getAnimationDuration()
        }}
      />
    );
  };
  
  // Render wave spinner
  const renderWaveSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    const actualSize = typeof sizeValue === 'number' ? sizeValue : 32;
    const barWidth = Math.max(2, actualSize / 12);
    const barHeight = typeof sizeValue === 'number' ? sizeValue : 32;
    const barMargin = barWidth / 2;
    
    return (
      <div
        className="cs-spinner-wave"
        style={{
          width: sizeValue,
          height: sizeValue
        }}
      >
        {[...Array(5)].map((_, index) => (
          <div
            key={index}
            className="cs-spinner-wave-bar"
            style={{
              width: barWidth,
              height: barHeight,
              marginRight: barMargin,
              backgroundColor: color,
              animationDuration: getAnimationDuration()
            }}
          />
        ))}
      </div>
    );
  };
  
  // Render ring spinner
  const renderRingSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    const borderWidth = getThickness();
    
    return (
      <div
        className="cs-spinner-ring"
        style={{
          width: sizeValue,
          height: sizeValue,
          borderWidth: borderWidth,
          borderColor: `${color} transparent transparent transparent`,
          animationDuration: getAnimationDuration()
        }}
      />
    );
  };
  
  // Render dual ring spinner
  const renderDualRingSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    const borderWidth = getThickness();
    
    return (
      <div
        className="cs-spinner-dual-ring"
        style={{
          width: sizeValue,
          height: sizeValue,
          borderWidth: borderWidth,
          borderColor: `${color} transparent ${color} transparent`,
          animationDuration: getAnimationDuration()
        }}
      />
    );
  };
  
  // Render ripple spinner
  const renderRippleSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    
    return (
      <div
        className="cs-spinner-ripple"
        style={{
          width: sizeValue,
          height: sizeValue
        }}
      >
        <div
          className="cs-spinner-ripple-circle"
          style={{
            borderColor: color,
            animationDuration: getAnimationDuration()
          }}
        />
        <div
          className="cs-spinner-ripple-circle"
          style={{
            borderColor: color,
            animationDuration: getAnimationDuration()
          }}
        />
      </div>
    );
  };
  
  // Render grid spinner
  const renderGridSpinner = (): React.ReactNode => {
    const sizeValue = getSize();
    const actualSize = typeof sizeValue === 'number' ? sizeValue : 32;
    const cellSize = actualSize / 3 - 2;
    
    return (
      <div
        className="cs-spinner-grid"
        style={{
          width: sizeValue,
          height: sizeValue
        }}
      >
        {[...Array(9)].map((_, index) => (
          <div
            key={index}
            className="cs-spinner-grid-cube"
            style={{
              width: cellSize,
              height: cellSize,
              backgroundColor: color,
              margin: 1,
              animationDuration: getAnimationDuration()
            }}
          />
        ))}
      </div>
    );
  };
  
  // Render spinner based on type
  const renderSpinner = (): React.ReactNode => {
    switch (type) {
      case SpinnerType.GROW:
        return renderGrowSpinner();
      case SpinnerType.CHASE:
        return renderChaseSpinner();
      case SpinnerType.BOUNCE:
        return renderBounceSpinner();
      case SpinnerType.PULSE:
        return renderPulseSpinner();
      case SpinnerType.WAVE:
        return renderWaveSpinner();
      case SpinnerType.RING:
        return renderRingSpinner();
      case SpinnerType.DUAL_RING:
        return renderDualRingSpinner();
      case SpinnerType.RIPPLE:
        return renderRippleSpinner();
      case SpinnerType.GRID:
        return renderGridSpinner();
      case SpinnerType.BORDER:
      default:
        return renderBorderSpinner();
    }
  };
  
  // Render text
  const renderText = (): React.ReactNode => {
    if (!showText) {
      return null;
    }
    
    return (
      <div className={`cs-spinner-text cs-spinner-text-${textPosition}`}>
        {text}
      </div>
    );
  };
  
  // Prepare class names
  const spinnerClassNames = [
    'cs-spinner',
    `cs-spinner-type-${type}`,
    typeof size === 'string' ? `cs-spinner-size-${size}` : '',
    centered ? 'cs-spinner-centered' : '',
    fullscreen ? 'cs-spinner-fullscreen' : '',
    container ? 'cs-spinner-container' : '',
    delay > 0 ? 'cs-spinner-delayed' : '',
    className
  ].filter(Boolean).join(' ');
  
  // Prepare styles
  const spinnerStyles: React.CSSProperties = {
    ...style,
    animationDelay: delay > 0 ? `${delay}ms` : undefined,
    ...(fullscreen ? { backgroundColor: overlayColor } : {})
  };
  
  // Prepare container styles
  const containerStyles: React.CSSProperties = container
    ? { height: containerHeight }
    : {};
  
  // Render component
  return (
    <div
      className={spinnerClassNames}
      style={{
        ...spinnerStyles,
        ...containerStyles
      }}
      role="status"
      aria-label={ariaLabel}
      aria-live="polite"
    >
      <div className="cs-spinner-wrapper">
        {textPosition === 'left' && renderText()}
        {textPosition === 'top' && renderText()}
        
        <div className="cs-spinner-element">
          {renderSpinner()}
          {children}
        </div>
        
        {textPosition === 'right' && renderText()}
        {textPosition === 'bottom' && renderText()}
      </div>
      
      <span className="cs-spinner-sr-only">{ariaLabel}</span>
    </div>
  );
};

export default Spinner;


/**
 * Spinner.scss
 * 
 * Styles for the custom spinner component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$info: #17a2b8;
$warning: #ffc107;
$danger: #dc3545;

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Z-index
$z-index-overlay: 9000;

// Base Spinner styles
.cs-spinner {
  display: inline-block;
  position: relative;
  
  // Center the spinner
  &-centered {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }
  
  // Fullscreen overlay
  &-fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: $z-index-overlay;
    background-color: rgba(255, 255, 255, 0.8);
  }
  
  // Container with fixed height
  &-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    overflow: hidden;
  }
  
  // Delayed appearance
  &-delayed {
    animation: cs-spinner-fade-in 0.3s ease forwards;
    animation-delay: 0.5s; // Default delay, overridden by inline style
    opacity: 0;
  }
  
  @keyframes cs-spinner-fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  
  // Wrapper for spinner element and text
  &-wrapper {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    flex-direction: row;
  }
  
  // Element containing the spinner itself
  &-element {
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  
  // Text positions
  &-text {
    font-family: $font-family;
    font-size: $font-size-base;
    line-height: $line-height-base;
    color: $gray-700;
    
    &-left {
      margin-right: $spacer;
    }
    
    &-right {
      margin-left: $spacer;
    }
    
    &-top {
      margin-bottom: $spacer;
    }
    
    &-bottom {
      margin-top: $spacer;
    }
  }
  
  &-text-top, &-text-bottom {
    .cs-spinner-wrapper {
      flex-direction: column;
    }
  }
  
  // Screen reader only text
  &-sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }
  
  // Size variations
  &-size-small {
    font-size: 12px;
    
    .cs-spinner-text {
      font-size: 12px;
    }
  }
  
  &-size-large {
    font-size: 16px;
    
    .cs-spinner-text {
      font-size: 16px;
    }
  }
  
  // Border spinner
  &-border {
    display: inline-block;
    width: 2rem;
    height: 2rem;
    border: 0.25em solid $gray-200;
    border-right-color: transparent;
    border-radius: 50%;
    animation: cs-spinner-border 1s linear infinite;
  }
  
  @keyframes cs-spinner-border {
    to {
      transform: rotate(360deg);
    }
  }
  
  // Grow spinner
  &-grow {
    display: inline-block;
    width: 2rem;
    height: 2rem;
    background-color: currentColor;
    border-radius: 50%;
    opacity: 0;
    animation: cs-spinner-grow 1s linear infinite;
  }
  
  @keyframes cs-spinner-grow {
    0% {
      transform: scale(0);
      opacity: 0;
    }
    50% {
      opacity: 1;
      transform: scale(1);
    }
    100% {
      opacity: 0;
      transform: scale(0);
    }
  }
  
  // Chase spinner
  &-chase {
    position: relative;
    width: 40px;
    height: 40px;
    animation: cs-spinner-chase 2.5s infinite linear both;
    
    &-dot {
      position: absolute;
      width: 100%;
      height: 100%;
      animation: cs-spinner-chase-dot 2s infinite ease-in-out both;
      
      &:nth-child(1) { animation-delay: -1.1s; }
      &:nth-child(2) { animation-delay: -1.0s; }
      &:nth-child(3) { animation-delay: -0.9s; }
      &:nth-child(4) { animation-delay: -0.8s; }
      &:nth-child(5) { animation-delay: -0.7s; }
      &:nth-child(6) { animation-delay: -0.6s; }
      
      &:nth-child(1) { transform: rotate(0deg); }
      &:nth-child(2) { transform: rotate(30deg); }
      &:nth-child(3) { transform: rotate(60deg); }
      &:nth-child(4) { transform: rotate(90deg); }
      &:nth-child(5) { transform: rotate(120deg); }
      &:nth-child(6) { transform: rotate(150deg); }
      
      &::before {
        content: '';
        display: block;
        width: 25%;
        height: 25%;
        background-color: currentColor;
        border-radius: 100%;
        animation: cs-spinner-chase-dot-before 2s infinite ease-in-out both;
        
        .cs-spinner-chase-dot:nth-child(1) & { animation-delay: -1.1s; }
        .cs-spinner-chase-dot:nth-child(2) & { animation-delay: -1.0s; }
        .cs-spinner-chase-dot:nth-child(3) & { animation-delay: -0.9s; }
        .cs-spinner-chase-dot:nth-child(4) & { animation-delay: -0.8s; }
        .cs-spinner-chase-dot:nth-child(5) & { animation-delay: -0.7s; }
        .cs-spinner-chase-dot:nth-child(6) & { animation-delay: -0.6s; }
      }
    }
  }
  
  @keyframes cs-spinner-chase {
    100% { transform: rotate(360deg); }
  }
  
  @keyframes cs-spinner-chase-dot {
    80%, 100% { transform: rotate(360deg); }
  }
  
  @keyframes cs-spinner-chase-dot-before {
    50% {
      transform: scale(0.4);
    }
    100%, 0% {
      transform: scale(1);
    }
  }
  
  // Bounce spinner
  &-bounce {
    position: relative;
    width: 40px;
    height: 40px;
    
    &-dot {
      position: absolute;
      top: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: currentColor;
      opacity: 0.6;
      animation: cs-spinner-bounce 2s infinite ease-in-out;
      
      &:nth-child(2) {
        animation-delay: -1s;
      }
    }
  }
  
  @keyframes cs-spinner-bounce {
    0%, 100% {
      transform: scale(0);
    }
    50% {
      transform: scale(1);
    }
  }
  
  // Pulse spinner
  &-pulse {
    display: inline-block;
    width: 2rem;
    height: 2rem;
    background-color: currentColor;
    border-radius: 50%;
    animation: cs-spinner-pulse 1.2s infinite cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  @keyframes cs-spinner-pulse {
    0% {
      transform: scale(0.85);
      opacity: 1;
    }
    50% {
      transform: scale(1);
      opacity: 0.7;
    }
    100% {
      transform: scale(0.85);
      opacity: 1;
    }
  }
  
  // Wave spinner
  &-wave {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 50px;
    height: 40px;
    
    &-bar {
      display: inline-block;
      width: 4px;
      height: 35px;
      margin: 0 2px;
      border-radius: 1px;
      background-color: currentColor;
      animation: cs-spinner-wave 1.2s ease-in-out infinite;
      
      &:nth-child(1) { animation-delay: 0s; }
      &:nth-child(2) { animation-delay: 0.1s; }
      &:nth-child(3) { animation-delay: 0.2s; }
      &:nth-child(4) { animation-delay: 0.3s; }
      &:nth-child(5) { animation-delay: 0.4s; }
    }
  }
  
  @keyframes cs-spinner-wave {
    0%, 40%, 100% {
      transform: scaleY(0.4);
    }
    20% {
      transform: scaleY(1);
    }
  }
  
  // Ring spinner
  &-ring {
    display: inline-block;
    width: 40px;
    height: 40px;
    border: 4px solid currentColor;
    border-radius: 50%;
    animation: cs-spinner-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    border-color: currentColor transparent transparent transparent;
  }
  
  @keyframes cs-spinner-ring {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
  
  // Dual ring spinner
  &-dual-ring {
    display: inline-block;
    width: 40px;
    height: 40px;
    border: 4px solid transparent;
    border-radius: 50%;
    border-color: currentColor transparent currentColor transparent;
    animation: cs-spinner-dual-ring 1.2s linear infinite;
  }
  
  @keyframes cs-spinner-dual-ring {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
  
  // Ripple spinner
  &-ripple {
    position: relative;
    width: 40px;
    height: 40px;
    
    &-circle {
      position: absolute;
      border: 4px solid currentColor;
      opacity: 1;
      border-radius: 50%;
      animation: cs-spinner-ripple 1s cubic-bezier(0, 0.2, 0.8, 1) infinite;
      
      &:nth-child(2) {
        animation-delay: -0.5s;
      }
    }
  }
  
  @keyframes cs-spinner-ripple {
    0% {
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      opacity: 1;
    }
    100% {
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
    }
  }
  
  // Grid spinner
  &-grid {
    display: inline-block;
    width: 40px;
    height: 40px;
    
    &-cube {
      float: left;
      width: 33.33%;
      height: 33.33%;
      background-color: currentColor;
      animation: cs-spinner-grid 1.3s infinite ease-in-out;
      
      &:nth-child(1) { animation-delay: 0.2s; }
      &:nth-child(2) { animation-delay: 0.3s; }
      &:nth-child(3) { animation-delay: 0.4s; }
      &:nth-child(4) { animation-delay: 0.1s; }
      &:nth-child(5) { animation-delay: 0.2s; }
      &:nth-child(6) { animation-delay: 0.3s; }
      &:nth-child(7) { animation-delay: 0.0s; }
      &:nth-child(8) { animation-delay: 0.1s; }
      &:nth-child(9) { animation-delay: 0.2s; }
    }
  }
  
  @keyframes cs-spinner-grid {
    0%, 70%, 100% {
      transform: scale3D(1, 1, 1);
    }
    35% {
      transform: scale3D(0, 0, 1);
    }
  }
}

// RTL support
[dir="rtl"] .cs-spinner {
  &-text {
    &-left {
      margin-right: 0;
      margin-left: $spacer;
    }
    
    &-right {
      margin-left: 0;
      margin-right: $spacer;
    }
  }
}

// Dark mode support
.cs-spinner-dark {
  .cs-spinner-text {
    color: $gray-300;
  }
  
  .cs-spinner-border {
    border-color: $gray-700;
    border-right-color: transparent;
  }
  
  &.cs-spinner-fullscreen {
    background-color: rgba(0, 0, 0, 0.7);
  }
}

// High contrast mode
.cs-spinner-high-contrast {
  .cs-spinner-text {
    font-weight: bold;
  }
  
  .cs-spinner-border {
    border-width: 0.35em;
  }
  
  .cs-spinner-ring, .cs-spinner-dual-ring {
    border-width: 0.35em;
  }
  
  .cs-spinner-ripple-circle {
    border-width: 6px;
  }
}

// Mobile styles
@media (max-width: 576px) {
  .cs-spinner {
    &-fullscreen {
      .cs-spinner-wrapper {
        flex-direction: column;
      }
      
      .cs-spinner-text {
        margin: $spacer 0 0 0;
        text-align: center;
        
        &-left, &-right, &-top, &-bottom {
          margin: $spacer 0 0 0;
        }
      }
    }
    
    &-type-wave {
      .cs-spinner-wave {
        width: 40px;
        
        &-bar {
          width: 4px;
          margin: 0 1px;
        }
      }
    }
  }
  
  [dir="rtl"] .cs-spinner-fullscreen .cs-spinner-text {
    &-left, &-right {
      margin: $spacer 0 0 0;
    }
  }
}

// Print styles
@media print {
  .cs-spinner {
    display: none !important;
  }
}

// Accessibility focus styles
.cs-spinner:focus-visible {
  outline: 2px solid $primary-color;
  outline-offset: 2px;
}

// Custom animation durations
.cs-spinner {
  &-speed-slow {
    .cs-spinner-border,
    .cs-spinner-grow,
    .cs-spinner-chase,
    .cs-spinner-chase-dot,
    .cs-spinner-chase-dot::before,
    .cs-spinner-bounce-dot,
    .cs-spinner-pulse,
    .cs-spinner-wave-bar,
    .cs-spinner-ring,
    .cs-spinner-dual-ring,
    .cs-spinner-ripple-circle,
    .cs-spinner-grid-cube {
      animation-duration: 1.5s;
    }
  }
  
  &-speed-fast {
    .cs-spinner-border,
    .cs-spinner-grow,
    .cs-spinner-chase,
    .cs-spinner-chase-dot,
    .cs-spinner-chase-dot::before,
    .cs-spinner-bounce-dot,
    .cs-spinner-pulse,
    .cs-spinner-wave-bar,
    .cs-spinner-ring,
    .cs-spinner-dual-ring,
    .cs-spinner-ripple-circle,
    .cs-spinner-grid-cube {
      animation-duration: 0.5s;
    }
  }
}

// Custom colors for component themes
.cs-spinner {
  &-color-primary {
    color: $primary-color;
    
    .cs-spinner-border {
      border-color: $primary-alpha;
      border-right-color: transparent;
    }
    
    .cs-spinner-grow,
    .cs-spinner-chase-dot::before,
    .cs-spinner-bounce-dot,
    .cs-spinner-pulse,
    .cs-spinner-wave-bar,
    .cs-spinner-grid-cube {
      background-color: $primary-color;
    }
    
    .cs-spinner-ring,
    .cs-spinner-dual-ring,
    .cs-spinner-ripple-circle {
      border-color: $primary-color transparent transparent transparent;
    }
    
    .cs-spinner-dual-ring {
      border-color: $primary-color transparent $primary-color transparent;
    }
  }
  
  &-color-success {
    color: $success;
    
    .cs-spinner-border {
      border-color: lighten($success, 30%);
      border-right-color: transparent;
    }
    
    .cs-spinner-grow,
    .cs-spinner-chase-dot::before,
    .cs-spinner-bounce-dot,
    .cs-spinner-pulse,
    .cs-spinner-wave-bar,
    .cs-spinner-grid-cube {
      background-color: $success;
    }
    
    .cs-spinner-ring,
    .cs-spinner-dual-ring,
    .cs-spinner-ripple-circle {
      border-color: $success transparent transparent transparent;
    }
    
    .cs-spinner-dual-ring {
      border-color: $success transparent $success transparent;
    }
  }
  
  &-color-info {
    color: $info;
    
    .cs-spinner-border {
      border-color: lighten($info, 30%);
      border-right-color: transparent;
    }
    
    .cs-spinner-grow,
    .cs-spinner-chase-dot::before,
    .cs-spinner-bounce-dot,
    .cs-spinner-pulse,
    .cs-spinner-wave-bar,
    .cs-spinner-grid-cube {
      background-color: $info;
    }
    
    .cs-spinner-ring,
    .cs-spinner-dual-ring,
    .cs-spinner-ripple-circle {
      border-color: $info transparent transparent transparent;
    }
    
    .cs-spinner-dual-ring {
      border-color: $info transparent $info transparent;
    }
  }
  
  &-color-warning {
    color: $warning;
    
    .cs-spinner-border {
      border-color: lighten($warning, 30%);
      border-right-color: transparent;
    }
    
    .cs-spinner-grow,
    .cs-spinner-chase-dot::before,
    .cs-spinner-bounce-dot,
    .cs-spinner-pulse,
    .cs-spinner-wave-bar,
    .cs-spinner-grid-cube {
      background-color: $warning;
    }
    
    .cs-spinner-ring,
    .cs-spinner-dual-ring,
    .cs-spinner-ripple-circle {
      border-color: $warning transparent transparent transparent;
    }
    
    .cs-spinner-dual-ring {
      border-color: $warning transparent $warning transparent;
    }
  }
  
  &-color-danger {
    color: $danger;
    
    .cs-spinner-border {
      border-color: lighten($danger, 30%);
      border-right-color: transparent;
    }
    
    .cs-spinner-grow,
    .cs-spinner-chase-dot::before,
    .cs-spinner-bounce-dot,
    .cs-spinner-pulse,
    .cs-spinner-wave-bar,
    .cs-spinner-grid-cube {
      background-color: $danger;
    }
    
    .cs-spinner-ring,
    .cs-spinner-dual-ring,
    .cs-spinner-ripple-circle {
      border-color: $danger transparent transparent transparent;
    }
    
    .cs-spinner-dual-ring {
      border-color: $danger transparent $danger transparent;
    }
  }
}

// Reduced motion support
@media (prefers-reduced-motion: reduce) {
  .cs-spinner {
    &-border,
    &-grow,
    &-chase,
    &-chase-dot,
    &-bounce-dot,
    &-pulse,
    &-wave-bar,
    &-ring,
    &-dual-ring,
    &-ripple-circle,
    &-grid-cube {
      animation-duration: 0s !important;
      transition-duration: 0s !important;
    }
    
    &-border {
      border-right-color: transparent !important;
    }
    
    &-grow {
      opacity: 0.5 !important;
      transform: scale(0.8) !important;
    }
    
    &-chase-dot::before {
      opacity: 0.7 !important;
      transform: scale(1) !important;
    }
    
    &-bounce-dot {
      &:first-child {
        opacity: 0.7 !important;
        transform: scale(0.7) !important;
      }
      
      &:last-child {
        opacity: 0.5 !important;
        transform: scale(0.5) !important;
      }
    }
    
    &-pulse {
      opacity: 0.7 !important;
      transform: scale(0.8) !important;
    }
    
    &-wave-bar {
      &:nth-child(1) { transform: scaleY(0.4) !important; }
      &:nth-child(2) { transform: scaleY(0.6) !important; }
      &:nth-child(3) { transform: scaleY(0.8) !important; }
      &:nth-child(4) { transform: scaleY(0.6) !important; }
      &:nth-child(5) { transform: scaleY(0.4) !important; }
    }
    
    &-ripple-circle {
      &:first-child {
        opacity: 0.3 !important;
        transform: scale(0.3) !important;
      }
      
      &:last-child {
        opacity: 0.1 !important;
        transform: scale(0.5) !important;
      }
    }
    
    &-grid-cube {
      opacity: 0.6 !important;
    }
  }
}

/**
 * Skeleton.tsx
 * 
 * Custom skeleton loading component for the CSTestForge framework.
 * Provides customizable loading placeholders with different shapes and animations.
 */

import React from 'react';
import './Skeleton.scss';

/**
 * Skeleton avatar shape enum
 */
export enum AvatarShape {
  CIRCLE = 'circle',
  SQUARE = 'square'
}

/**
 * Skeleton animation enum
 */
export enum SkeletonAnimation {
  PULSE = 'pulse',
  WAVE = 'wave',
  NONE = 'none'
}

/**
 * Base skeleton props interface
 */
export interface BaseSkeletonProps {
  /**
   * Animation type
   */
  animation?: SkeletonAnimation;
  
  /**
   * Custom width
   */
  width?: number | string;
  
  /**
   * Custom height
   */
  height?: number | string;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Whether skeleton is active
   */
  active?: boolean;
  
  /**
   * Border radius
   */
  borderRadius?: number | string;
  
  /**
   * Skeleton background color
   */
  backgroundColor?: string;
  
  /**
   * Highlight color for wave animation
   */
  highlightColor?: string;
}

/**
 * Skeleton avatar props interface
 */
export interface SkeletonAvatarProps extends BaseSkeletonProps {
  /**
   * Avatar shape
   */
  shape?: AvatarShape;
  
  /**
   * Avatar size
   */
  size?: number | 'small' | 'default' | 'large';
}

/**
 * Skeleton text props interface
 */
export interface SkeletonTextProps extends BaseSkeletonProps {
  /**
   * Number of rows
   */
  rows?: number;
  
  /**
   * Width(s) of rows (string, number, or array of string/number)
   */
  rowWidths?: (string | number)[] | string | number;
  
  /**
   * Row spacing
   */
  rowSpacing?: number | string;
}

/**
 * Skeleton image props interface
 */
export interface SkeletonImageProps extends BaseSkeletonProps {
  /**
   * Show icon in the center
   */
  showIcon?: boolean;
  
  /**
   * Custom icon
   */
  icon?: React.ReactNode;
}

/**
 * Skeleton input props interface
 */
export interface SkeletonInputProps extends BaseSkeletonProps {
  /**
   * Input size
   */
  size?: 'small' | 'default' | 'large';
}

/**
 * Skeleton button props interface
 */
export interface SkeletonButtonProps extends BaseSkeletonProps {
  /**
   * Button shape
   */
  shape?: 'default' | 'circle' | 'round';
  
  /**
   * Button size
   */
  size?: 'small' | 'default' | 'large';
}

/**
 * Skeleton list props interface
 */
export interface SkeletonListProps extends BaseSkeletonProps {
  /**
   * Number of items
   */
  rows?: number;
  
  /**
   * Whether to show avatar
   */
  avatar?: boolean;
  
  /**
   * Avatar props
   */
  avatarProps?: SkeletonAvatarProps;
  
  /**
   * Whether to show title
   */
  title?: boolean;
  
  /**
   * Title props
   */
  titleProps?: SkeletonTextProps;
  
  /**
   * Whether to show paragraph
   */
  paragraph?: boolean;
  
  /**
   * Paragraph props
   */
  paragraphProps?: SkeletonTextProps;
  
  /**
   * Whether to show action
   */
  action?: boolean;
  
  /**
   * Action props
   */
  actionProps?: SkeletonButtonProps;
  
  /**
   * Item spacing
   */
  itemSpacing?: number | string;
}

/**
 * Skeleton props interface
 */
export interface SkeletonProps extends BaseSkeletonProps {
  /**
   * Component variant
   */
  variant?: 'text' | 'rectangular' | 'circular' | 'rounded' | 'avatar' | 'button' | 'input' | 'image' | 'list';
  
  /**
   * Children to render when not loading
   */
  children?: React.ReactNode;
  
  /**
   * Whether content is loading
   */
  loading?: boolean;
  
  /**
   * Number of rows for text variant
   */
  rows?: number;
  
  /**
   * Whether to hide animation when the system has reduced motion settings
   */
  respectReducedMotion?: boolean;
  
  /**
   * Variant-specific props
   */
  avatarProps?: SkeletonAvatarProps;
  textProps?: SkeletonTextProps;
  imageProps?: SkeletonImageProps;
  inputProps?: SkeletonInputProps;
  buttonProps?: SkeletonButtonProps;
  listProps?: SkeletonListProps;
}

/**
 * Base Skeleton component
 */
const BaseSkeleton: React.FC<BaseSkeletonProps> = ({
  animation = SkeletonAnimation.PULSE,
  width,
  height,
  className = '',
  style = {},
  active = true,
  borderRadius,
  backgroundColor,
  highlightColor
}) => {
  // Build class names
  const skeletonClassNames = [
    'cs-skeleton',
    animation !== SkeletonAnimation.NONE ? `cs-skeleton-animation-${animation}` : '',
    active ? 'cs-skeleton-active' : '',
    className
  ].filter(Boolean).join(' ');
  
  // Combine styles
  const combinedStyles: React.CSSProperties = {
    ...style,
    width,
    height,
    borderRadius,
    backgroundColor,
    '--cs-skeleton-highlight-color': highlightColor
  };
  
  return (
    <div className={skeletonClassNames} style={combinedStyles} aria-hidden="true" />
  );
};

/**
 * Skeleton Avatar component
 */
export const SkeletonAvatar: React.FC<SkeletonAvatarProps> = ({
  shape = AvatarShape.CIRCLE,
  size = 'default',
  animation = SkeletonAnimation.PULSE,
  width,
  height,
  className = '',
  style = {},
  active = true,
  borderRadius,
  backgroundColor,
  highlightColor
}) => {
  // Calculate size in pixels
  const getSize = (): number => {
    if (typeof size === 'number') {
      return size;
    }
    
    switch (size) {
      case 'small':
        return 24;
      case 'large':
        return 48;
      case 'default':
      default:
        return 32;
    }
  };
  
  // Determine dimensions based on size prop
  const sizeValue = getSize();
  const sizeWidth = width ?? sizeValue;
  const sizeHeight = height ?? sizeValue;
  
  // Set border radius based on shape
  const shapeBorderRadius = borderRadius ?? (shape === AvatarShape.CIRCLE ? '50%' : '4px');
  
  // Build class names
  const avatarClassNames = [
    'cs-skeleton-avatar',
    `cs-skeleton-avatar-${shape}`,
    typeof size === 'string' ? `cs-skeleton-avatar-${size}` : '',
    className
  ].filter(Boolean).join(' ');
  
  return (
    <BaseSkeleton
      animation={animation}
      width={sizeWidth}
      height={sizeHeight}
      className={avatarClassNames}
      style={style}
      active={active}
      borderRadius={shapeBorderRadius}
      backgroundColor={backgroundColor}
      highlightColor={highlightColor}
    />
  );
};

/**
 * Skeleton Text component
 */
export const SkeletonText: React.FC<SkeletonTextProps> = ({
  rows = 3,
  rowWidths,
  rowSpacing = 8,
  animation = SkeletonAnimation.PULSE,
  width = '100%',
  height = 16,
  className = '',
  style = {},
  active = true,
  borderRadius = 4,
  backgroundColor,
  highlightColor
}) => {
  // Generate array of row widths
  const getRowWidths = (): (string | number)[] => {
    if (Array.isArray(rowWidths)) {
      return rowWidths;
    }
    
    if (rowWidths !== undefined) {
      return Array(rows).fill(rowWidths);
    }
    
    // Default pattern: last row is 80% if multiple rows exist
    return Array(rows).fill('100%').map((w, i) => {
      if (rows > 1 && i === rows - 1) {
        return '80%';
      }
      return w;
    });
  };
  
  const rowWidthsArray = getRowWidths();
  
  // Build class names
  const textClassNames = [
    'cs-skeleton-text',
    className
  ].filter(Boolean).join(' ');
  
  return (
    <div className={textClassNames} style={style}>
      {Array.from({ length: rows }).map((_, index) => (
        <BaseSkeleton
          key={index}
          animation={animation}
          width={rowWidthsArray[index % rowWidthsArray.length]}
          height={height}
          className="cs-skeleton-text-row"
          style={{ marginBottom: index < rows - 1 ? rowSpacing : 0 }}
          active={active}
          borderRadius={borderRadius}
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
        />
      ))}
    </div>
  );
};

/**
 * Skeleton Image component
 */
export const SkeletonImage: React.FC<SkeletonImageProps> = ({
  showIcon = true,
  icon,
  animation = SkeletonAnimation.PULSE,
  width = 200,
  height = 150,
  className = '',
  style = {},
  active = true,
  borderRadius = 4,
  backgroundColor,
  highlightColor
}) => {
  // Build class names
  const imageClassNames = [
    'cs-skeleton-image',
    className
  ].filter(Boolean).join(' ');
  
  // Icon element
  const iconElement = showIcon && (
    <div className="cs-skeleton-image-icon">
      {icon || (
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
          <circle cx="8.5" cy="8.5" r="1.5" />
          <polyline points="21 15 16 10 5 21" />
        </svg>
      )}
    </div>
  );
  
  return (
    <div className={imageClassNames} style={{ ...style, width, height }}>
      <BaseSkeleton
        animation={animation}
        width="100%"
        height="100%"
        className="cs-skeleton-image-base"
        active={active}
        borderRadius={borderRadius}
        backgroundColor={backgroundColor}
        highlightColor={highlightColor}
      />
      {iconElement}
    </div>
  );
};

/**
 * Skeleton Input component
 */
export const SkeletonInput: React.FC<SkeletonInputProps> = ({
  size = 'default',
  animation = SkeletonAnimation.PULSE,
  width = '100%',
  height,
  className = '',
  style = {},
  active = true,
  borderRadius = 4,
  backgroundColor,
  highlightColor
}) => {
  // Calculate height based on size
  const getHeight = (): number => {
    if (height !== undefined) {
      return typeof height === 'number' ? height : parseInt(height as string, 10);
    }
    
    switch (size) {
      case 'small':
        return 24;
      case 'large':
        return 40;
      case 'default':
      default:
        return 32;
    }
  };
  
  // Build class names
  const inputClassNames = [
    'cs-skeleton-input',
    `cs-skeleton-input-${size}`,
    className
  ].filter(Boolean).join(' ');
  
  return (
    <BaseSkeleton
      animation={animation}
      width={width}
      height={getHeight()}
      className={inputClassNames}
      style={style}
      active={active}
      borderRadius={borderRadius}
      backgroundColor={backgroundColor}
      highlightColor={highlightColor}
    />
  );
};

/**
 * Skeleton Button component
 */
export const SkeletonButton: React.FC<SkeletonButtonProps> = ({
  shape = 'default',
  size = 'default',
  animation = SkeletonAnimation.PULSE,
  width,
  height,
  className = '',
  style = {},
  active = true,
  borderRadius,
  backgroundColor,
  highlightColor
}) => {
  // Calculate dimensions based on size and shape
  const getHeight = (): number => {
    if (height !== undefined) {
      return typeof height === 'number' ? height : parseInt(height as string, 10);
    }
    
    switch (size) {
      case 'small':
        return 24;
      case 'large':
        return 40;
      case 'default':
      default:
        return 32;
    }
  };
  
  const getWidth = (): number | string => {
    if (width !== undefined) {
      return width;
    }
    
    if (shape === 'circle') {
      return getHeight();
    }
    
    switch (size) {
      case 'small':
        return 80;
      case 'large':
        return 120;
      case 'default':
      default:
        return 100;
    }
  };
  
  // Determine border radius based on shape
  const getBorderRadius = (): string | number => {
    if (borderRadius !== undefined) {
      return borderRadius;
    }
    
    switch (shape) {
      case 'circle':
        return '50%';
      case 'round':
        return 999;
      case 'default':
      default:
        return 4;
    }
  };
  
  // Build class names
  const buttonClassNames = [
    'cs-skeleton-button',
    `cs-skeleton-button-${shape}`,
    `cs-skeleton-button-${size}`,
    className
  ].filter(Boolean).join(' ');
  
  return (
    <BaseSkeleton
      animation={animation}
      width={getWidth()}
      height={getHeight()}
      className={buttonClassNames}
      style={style}
      active={active}
      borderRadius={getBorderRadius()}
      backgroundColor={backgroundColor}
      highlightColor={highlightColor}
    />
  );
};

/**
 * Skeleton List component
 */
export const SkeletonList: React.FC<SkeletonListProps> = ({
  rows = 3,
  avatar = true,
  avatarProps,
  title = true,
  titleProps,
  paragraph = true,
  paragraphProps,
  action = false,
  actionProps,
  itemSpacing = 16,
  animation = SkeletonAnimation.PULSE,
  width = '100%',
  height,
  className = '',
  style = {},
  active = true,
  backgroundColor,
  highlightColor
}) => {
  // Build class names
  const listClassNames = [
    'cs-skeleton-list',
    className
  ].filter(Boolean).join(' ');
  
  return (
    <div 
      className={listClassNames} 
      style={{ ...style, width }}
      aria-busy={active}
      aria-live="polite"
    >
      {Array.from({ length: rows }).map((_, index) => (
        <div 
          key={index} 
          className="cs-skeleton-list-item"
          style={{ marginBottom: index < rows - 1 ? itemSpacing : 0 }}
        >
          <div className="cs-skeleton-list-item-content">
            {avatar && (
              <div className="cs-skeleton-list-item-avatar">
                <SkeletonAvatar 
                  {...avatarProps} 
                  animation={animation} 
                  active={active}
                  backgroundColor={backgroundColor}
                  highlightColor={highlightColor}
                />
              </div>
            )}
            
            <div className="cs-skeleton-list-item-main">
              {title && (
                <div className="cs-skeleton-list-item-title">
                  <SkeletonText 
                    rows={1} 
                    rowWidths="60%" 
                    {...titleProps} 
                    animation={animation} 
                    active={active}
                    backgroundColor={backgroundColor}
                    highlightColor={highlightColor}
                  />
                </div>
              )}
              
              {paragraph && (
                <div className="cs-skeleton-list-item-paragraph">
                  <SkeletonText 
                    rows={2} 
                    {...paragraphProps} 
                    animation={animation} 
                    active={active}
                    backgroundColor={backgroundColor}
                    highlightColor={highlightColor}
                  />
                </div>
              )}
            </div>
          </div>
          
          {action && (
            <div className="cs-skeleton-list-item-action">
              <SkeletonButton 
                {...actionProps} 
                animation={animation} 
                active={active}
                backgroundColor={backgroundColor}
                highlightColor={highlightColor}
              />
            </div>
          )}
        </div>
      ))}
    </div>
  );
};

/**
 * Skeleton component
 */
const Skeleton: React.FC<SkeletonProps> = ({
  variant = 'text',
  children,
  loading = true,
  animation = SkeletonAnimation.PULSE,
  width,
  height,
  className = '',
  style = {},
  active = true,
  borderRadius,
  backgroundColor,
  highlightColor,
  rows = 3,
  respectReducedMotion = true,
  avatarProps,
  textProps,
  imageProps,
  inputProps,
  buttonProps,
  listProps
}) => {
  // Check if reduced motion is preferred
  const prefersReducedMotion = typeof window !== 'undefined' &&
    window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  
  // Determine animation mode
  const effectiveAnimation = (respectReducedMotion && prefersReducedMotion)
    ? SkeletonAnimation.NONE
    : animation;
  
  // If not loading, render children
  if (!loading && children) {
    return <>{children}</>;
  }
  
  // Render variant-specific skeleton
  switch (variant) {
    case 'avatar':
      return (
        <SkeletonAvatar
          animation={effectiveAnimation}
          width={width}
          height={height}
          className={className}
          style={style}
          active={active}
          borderRadius={borderRadius}
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
          {...avatarProps}
        />
      );
    
    case 'circular':
      return (
        <BaseSkeleton
          animation={effectiveAnimation}
          width={width || 40}
          height={height || 40}
          className={className}
          style={style}
          active={active}
          borderRadius="50%"
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
        />
      );
    
    case 'rectangular':
      return (
        <BaseSkeleton
          animation={effectiveAnimation}
          width={width || '100%'}
          height={height || 100}
          className={className}
          style={style}
          active={active}
          borderRadius={0}
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
        />
      );
    
    case 'rounded':
      return (
        <BaseSkeleton
          animation={effectiveAnimation}
          width={width || '100%'}
          height={height || 100}
          className={className}
          style={style}
          active={active}
          borderRadius={borderRadius || 8}
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
        />
      );
    
    case 'image':
      return (
        <SkeletonImage
          animation={effectiveAnimation}
          width={width}
          height={height}
          className={className}
          style={style}
          active={active}
          borderRadius={borderRadius}
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
          {...imageProps}
        />
      );
    
    case 'input':
      return (
        <SkeletonInput
          animation={effectiveAnimation}
          width={width}
          height={height}
          className={className}
          style={style}
          active={active}
          borderRadius={borderRadius}
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
          {...inputProps}
        />
      );
    
    case 'button':
      return (
        <SkeletonButton
          animation={effectiveAnimation}
          width={width}
          height={height}
          className={className}
          style={style}
          active={active}
          borderRadius={borderRadius}
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
          {...buttonProps}
        />
      );
    
    case 'list':
      return (
        <SkeletonList
          rows={rows}
          animation={effectiveAnimation}
          width={width}
          height={height}
          className={className}
          style={style}
          active={active}
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
          {...listProps}
        />
      );
    
    case 'text':
    default:
      return (
        <SkeletonText
          rows={rows}
          animation={effectiveAnimation}
          width={width}
          height={height}
          className={className}
          style={style}
          active={active}
          borderRadius={borderRadius}
          backgroundColor={backgroundColor}
          highlightColor={highlightColor}
          {...textProps}
        />
      );
  }
};

export default Skeleton;


/**
 * Skeleton.scss
 * 
 * Styles for the custom skeleton loading component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$info: #17a2b8;
$warning: #ffc107;
$danger: #dc3545;

// Base skeleton colors
$skeleton-bg: $gray-200;
$skeleton-highlight: rgba(255, 255, 255, 0.7);

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius: 4px;

// Base Skeleton styles
.cs-skeleton {
  position: relative;
  display: block;
  overflow: hidden;
  background-color: var(--cs-skeleton-background, $skeleton-bg);
  border-radius: var(--cs-skeleton-border-radius, $border-radius);
  
  // Default width and height
  width: 100%;
  height: 16px;
  
  // Skeleton pulse animation
  &-animation-pulse {
    &::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: $skeleton-bg;
      animation: cs-skeleton-pulse 1.5s ease-in-out 0.5s infinite;
    }
    
    @keyframes cs-skeleton-pulse {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.4;
      }
      100% {
        opacity: 1;
      }
    }
  }
  
  // Skeleton wave animation
  &-animation-wave {
    &::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
        90deg,
        transparent,
        var(--cs-skeleton-highlight-color, $skeleton-highlight),
        transparent
      );
      animation: cs-skeleton-wave 1.6s linear 0.5s infinite;
    }
    
    @keyframes cs-skeleton-wave {
      0% {
        transform: translateX(-100%);
      }
      50%, 100% {
        transform: translateX(100%);
      }
    }
  }
  
  // Not active state
  &:not(.cs-skeleton-active) {
    &::after {
      animation: none;
    }
  }
  
  // Avatar skeleton
  &-avatar {
    display: inline-block;
    vertical-align: middle;
    
    // Shape variations
    &-circle {
      border-radius: 50%;
    }
    
    &-square {
      border-radius: $border-radius;
    }
    
    // Size variations
    &-small {
      width: 24px;
      height: 24px;
    }
    
    &-default {
      width: 32px;
      height: 32px;
    }
    
    &-large {
      width: 48px;
      height: 48px;
    }
  }
  
  // Text skeleton
  &-text {
    display: block;
    width: 100%;
    
    &-row {
      width: 100%;
      
      &:last-child {
        width: 80%; // Last row is shorter by default
      }
    }
  }
  
  // Image skeleton
  &-image {
    position: relative;
    display: inline-block;
    overflow: hidden;
    
    &-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: $gray-500;
      
      svg {
        width: 32px;
        height: 32px;
      }
    }
  }
  
  // Input skeleton
  &-input {
    display: block;
    width: 100%;
    
    // Size variations
    &-small {
      height: 24px;
    }
    
    &-default {
      height: 32px;
    }
    
    &-large {
      height: 40px;
    }
  }
  
  // Button skeleton
  &-button {
    display: inline-block;
    vertical-align: middle;
    
    // Shape variations
    &-circle {
      border-radius: 50%;
    }
    
    &-round {
      border-radius: 999px;
    }
    
    &-default {
      border-radius: $border-radius;
    }
    
    // Size variations
    &-small {
      height: 24px;
      min-width: 80px;
    }
    
    &-default {
      height: 32px;
      min-width: 100px;
    }
    
    &-large {
      height: 40px;
      min-width: 120px;
    }
  }
  
  // List skeleton
  &-list {
    display: block;
    width: 100%;
    
    &-item {
      display: flex;
      flex-direction: column;
      margin-bottom: $spacer * 2;
      
      &:last-child {
        margin-bottom: 0;
      }
      
      &-content {
        display: flex;
        align-items: flex-start;
      }
      
      &-avatar {
        margin-right: $spacer * 1.5;
        flex-shrink: 0;
      }
      
      &-main {
        flex: 1;
        min-width: 0;
      }
      
      &-title {
        margin-bottom: $spacer;
      }
      
      &-paragraph {
        margin-bottom: 0;
      }
      
      &-action {
        align-self: flex-end;
        margin-top: $spacer;
      }
    }
  }
}

// RTL support
[dir="rtl"] .cs-skeleton {
  &-list-item {
    &-avatar {
      margin-right: 0;
      margin-left: $spacer * 1.5;
    }
    
    &-action {
      align-self: flex-start;
    }
  }
  
  &-animation-wave {
    &::after {
      animation-direction: reverse;
    }
  }
}

// Dark mode support
.cs-skeleton-dark {
  --cs-skeleton-background: #3a3a3a;
  --cs-skeleton-highlight-color: rgba(255, 255, 255, 0.15);
  
  .cs-skeleton-image-icon {
    color: $gray-400;
  }
}

// High contrast mode
.cs-skeleton-high-contrast {
  --cs-skeleton-background: #444;
  --cs-skeleton-highlight-color: rgba(255, 255, 255, 0.4);
  --cs-skeleton-border-radius: 0;
  
  .cs-skeleton {
    border: 1px solid $black;
    
    &-avatar, &-button {
      &-circle {
        border-radius: 50%;
      }
    }
  }
}

// Mobile styles
@media (max-width: 576px) {
  .cs-skeleton {
    &-list-item {
      &-content {
        flex-direction: column;
      }
      
      &-avatar {
        margin-right: 0;
        margin-bottom: $spacer;
      }
    }
  }
  
  [dir="rtl"] .cs-skeleton-list-item-avatar {
    margin-left: 0;
  }
}

// Reduced motion support
@media (prefers-reduced-motion: reduce) {
  .cs-skeleton {
    &-animation-pulse,
    &-animation-wave {
      &::after {
        animation: none !important;
        opacity: 0.5;
      }
    }
  }
}

// Print styles
@media print {
  .cs-skeleton {
    &-animation-pulse,
    &-animation-wave {
      &::after {
        animation: none !important;
        opacity: 0;
        background: none;
      }
    }
    
    // Use pattern instead of color in print
    background-image: repeating-linear-gradient(
      -45deg,
      transparent,
      transparent 5px,
      rgba(0, 0, 0, 0.1) 5px,
      rgba(0, 0, 0, 0.1) 10px
    ) !important;
  }
}

// Customization through CSS variables
.cs-skeleton {
  // Default CSS variables for customization
  --cs-skeleton-background: #{$skeleton-bg};
  --cs-skeleton-highlight-color: #{$skeleton-highlight};
  --cs-skeleton-border-radius: #{$border-radius};
  
  &-primary {
    --cs-skeleton-background: #{$primary-alpha};
    --cs-skeleton-highlight-color: #{rgba($primary-color, 0.2)};
  }
  
  &-success {
    --cs-skeleton-background: #{rgba($success, 0.2)};
    --cs-skeleton-highlight-color: #{rgba($success, 0.3)};
  }
  
  &-info {
    --cs-skeleton-background: #{rgba($info, 0.2)};
    --cs-skeleton-highlight-color: #{rgba($info, 0.3)};
  }
  
  &-warning {
    --cs-skeleton-background: #{rgba($warning, 0.2)};
    --cs-skeleton-highlight-color: #{rgba($warning, 0.3)};
  }
  
  &-danger {
    --cs-skeleton-background: #{rgba($danger, 0.2)};
    --cs-skeleton-highlight-color: #{rgba($danger, 0.3)};
  }
}

// Accessibility styles
[role="status"].cs-skeleton {
  pointer-events: none;
}


/**
 * Card.tsx
 * 
 * Custom card component for the CSTestForge framework.
 * Provides a customizable card container with header, body, and footer sections.
 */

import React, { useState, useRef } from 'react';
import './Card.scss';

/**
 * Card size enum
 */
export enum CardSize {
  SMALL = 'small',
  DEFAULT = 'default',
  LARGE = 'large'
}

/**
 * Card type enum
 */
export enum CardType {
  DEFAULT = 'default',
  PRIMARY = 'primary',
  SUCCESS = 'success',
  WARNING = 'warning',
  DANGER = 'danger',
  INFO = 'info'
}

/**
 * Card action shape enum
 */
export enum ActionShape {
  CIRCLE = 'circle',
  SQUARE = 'square',
  ROUND = 'round'
}

/**
 * Card action props interface
 */
export interface CardActionProps {
  /**
   * Action label
   */
  label?: string;
  
  /**
   * Action icon
   */
  icon?: React.ReactNode;
  
  /**
   * Action click handler
   */
  onClick?: (event: React.MouseEvent<HTMLElement>) => void;
  
  /**
   * Whether action is disabled
   */
  disabled?: boolean;
  
  /**
   * Action shape
   */
  shape?: ActionShape;
  
  /**
   * Action tooltip
   */
  tooltip?: string;
  
  /**
   * Action key (for identification)
   */
  key?: string | number;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
}

/**
 * Card media props interface
 */
export interface CardMediaProps {
  /**
   * Media source (URL)
   */
  src: string;
  
  /**
   * Media alt text
   */
  alt?: string;
  
  /**
   * Media height
   */
  height?: number | string;
  
  /**
   * Media component ('img' or 'video')
   */
  component?: 'img' | 'video';
  
  /**
   * Whether to overlay content
   */
  overlay?: boolean;
  
  /**
   * Overlay content
   */
  overlayContent?: React.ReactNode;
  
  /**
   * Media position ('top' or 'bottom')
   */
  position?: 'top' | 'bottom';
  
  /**
   * Whether to cover the container
   */
  cover?: boolean;
  
  /**
   * Object fit style ('cover', 'contain', 'fill', etc.)
   */
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Media click handler
   */
  onClick?: (event: React.MouseEvent<HTMLElement>) => void;
}

/**
 * Card props interface
 */
export interface CardProps {
  /**
   * Card title
   */
  title?: React.ReactNode;
  
  /**
   * Card subtitle
   */
  subtitle?: React.ReactNode;
  
  /**
   * Card size
   */
  size?: CardSize;
  
  /**
   * Card type
   */
  type?: CardType;
  
  /**
   * Whether the card is hoverable
   */
  hoverable?: boolean;
  
  /**
   * Card actions (buttons, etc.)
   */
  actions?: CardActionProps[];
  
  /**
   * Card header (overrides title and subtitle)
   */
  header?: React.ReactNode;
  
  /**
   * Card footer
   */
  footer?: React.ReactNode;
  
  /**
   * Card media
   */
  media?: CardMediaProps;
  
  /**
   * Whether the card is bordered
   */
  bordered?: boolean;
  
  /**
   * Whether the card has shadow
   */
  shadow?: boolean | 'hover';
  
  /**
   * Card radius ('none', 'small', 'default', 'large', 'full')
   */
  radius?: 'none' | 'small' | 'default' | 'large' | 'full';
  
  /**
   * Card padding ('none', 'small', 'default', 'large')
   */
  padding?: 'none' | 'small' | 'default' | 'large';
  
  /**
   * Card background color
   */
  backgroundColor?: string;
  
  /**
   * Card width
   */
  width?: number | string;
  
  /**
   * Card height
   */
  height?: number | string;
  
  /**
   * Card loading state
   */
  loading?: boolean;
  
  /**
   * Loading skeleton rows
   */
  loadingRows?: number;
  
  /**
   * Whether the header is sticky
   */
  stickyHeader?: boolean;
  
  /**
   * Whether the footer is sticky
   */
  stickyFooter?: boolean;
  
  /**
   * Card click handler
   */
  onClick?: (event: React.MouseEvent<HTMLElement>) => void;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Card children
   */
  children?: React.ReactNode;
  
  /**
   * Whether the card is collapsible
   */
  collapsible?: boolean;
  
  /**
   * Whether the card is collapsed by default
   */
  defaultCollapsed?: boolean;
  
  /**
   * Whether the card is collapsed (controlled)
   */
  collapsed?: boolean;
  
  /**
   * Callback when collapse state changes
   */
  onCollapseChange?: (collapsed: boolean) => void;
  
  /**
   * Whether the card is selectable
   */
  selectable?: boolean;
  
  /**
   * Whether the card is selected (controlled)
   */
  selected?: boolean;
  
  /**
   * Callback when selection state changes
   */
  onSelectChange?: (selected: boolean) => void;
  
  /**
   * Card orientation ('horizontal' or 'vertical')
   */
  orientation?: 'horizontal' | 'vertical';
  
  /**
   * Custom collapse icon
   */
  collapseIcon?: React.ReactNode;
  
  /**
   * Custom expand icon
   */
  expandIcon?: React.ReactNode;
}

/**
 * Card component
 */
const Card: React.FC<CardProps> = (props) => {
  const {
    title,
    subtitle,
    size = CardSize.DEFAULT,
    type = CardType.DEFAULT,
    hoverable = false,
    actions = [],
    header,
    footer,
    media,
    bordered = true,
    shadow = false,
    radius = 'default',
    padding = 'default',
    backgroundColor,
    width,
    height,
    loading = false,
    loadingRows = 3,
    stickyHeader = false,
    stickyFooter = false,
    onClick,
    className = '',
    style,
    children,
    collapsible = false,
    defaultCollapsed = false,
    collapsed: controlledCollapsed,
    onCollapseChange,
    selectable = false,
    selected: controlledSelected,
    onSelectChange,
    orientation = 'vertical',
    collapseIcon,
    expandIcon
  } = props;

  // State for collapsible card
  const [isCollapsed, setIsCollapsed] = useState<boolean>(
    controlledCollapsed !== undefined ? controlledCollapsed : defaultCollapsed
  );
  
  // State for selectable card
  const [isSelected, setIsSelected] = useState<boolean>(
    controlledSelected !== undefined ? controlledSelected : false
  );
  
  // Reference to the card body for animation
  const cardBodyRef = useRef<HTMLDivElement>(null);
  
  // Handle collapse toggle
  const handleCollapseToggle = (event: React.MouseEvent<HTMLElement>) => {
    event.stopPropagation();
    
    const newCollapsedState = !isCollapsed;
    
    if (controlledCollapsed === undefined) {
      setIsCollapsed(newCollapsedState);
    }
    
    if (onCollapseChange) {
      onCollapseChange(newCollapsedState);
    }
  };
  
  // Handle card click
  const handleCardClick = (event: React.MouseEvent<HTMLElement>) => {
    // Handle selection
    if (selectable) {
      const newSelectedState = !isSelected;
      
      if (controlledSelected === undefined) {
        setIsSelected(newSelectedState);
      }
      
      if (onSelectChange) {
        onSelectChange(newSelectedState);
      }
    }
    
    // Call onClick handler
    if (onClick) {
      onClick(event);
    }
  };
  
  // Handle action click
  const handleActionClick = (action: CardActionProps) => (event: React.MouseEvent<HTMLElement>) => {
    event.stopPropagation();
    
    if (action.onClick && !action.disabled) {
      action.onClick(event);
    }
  };
  
  // Render media
  const renderMedia = () => {
    if (!media) return null;
    
    const {
      src,
      alt = '',
      height: mediaHeight,
      component = 'img',
      overlay = false,
      overlayContent,
      position = 'top',
      cover = false,
      objectFit = 'cover',
      className: mediaClassName = '',
      style: mediaStyle,
      onClick: mediaOnClick
    } = media;
    
    const mediaClassNames = [
      'cs-card-media',
      `cs-card-media-${position}`,
      cover ? 'cs-card-media-cover' : '',
      overlay ? 'cs-card-media-overlay' : '',
      mediaClassName
    ].filter(Boolean).join(' ');
    
    const mediaStyles: React.CSSProperties = {
      ...mediaStyle,
      height: mediaHeight,
      objectFit
    };
    
    const mediaComponent = component === 'img' ? (
      <img 
        src={src} 
        alt={alt} 
        className={mediaClassNames}
        style={mediaStyles}
        onClick={mediaOnClick}
      />
    ) : (
      <video 
        src={src} 
        className={mediaClassNames}
        style={mediaStyles}
        onClick={mediaOnClick}
        controls
      />
    );
    
    if (overlay && overlayContent) {
      return (
        <div className="cs-card-media-container">
          {mediaComponent}
          <div className="cs-card-media-overlay-content">
            {overlayContent}
          </div>
        </div>
      );
    }
    
    return mediaComponent;
  };
  
  // Render header (title, subtitle, and actions)
  const renderHeader = () => {
    if (header) {
      return (
        <div 
          className={`cs-card-header ${stickyHeader ? 'cs-card-header-sticky' : ''}`}
        >
          {header}
        </div>
      );
    }
    
    if (!title && !subtitle && actions.length === 0 && !collapsible) {
      return null;
    }
    
    return (
      <div 
        className={`cs-card-header ${stickyHeader ? 'cs-card-header-sticky' : ''}`}
      >
        <div className="cs-card-header-content">
          {title && <div className="cs-card-title">{title}</div>}
          {subtitle && <div className="cs-card-subtitle">{subtitle}</div>}
        </div>
        
        <div className="cs-card-header-actions">
          {actions.map((action, index) => renderAction(action, index))}
          
          {collapsible && (
            <div 
              className="cs-card-collapse-action"
              onClick={handleCollapseToggle}
              aria-expanded={!isCollapsed}
              role="button"
              tabIndex={0}
              aria-label={isCollapsed ? 'Expand' : 'Collapse'}
            >
              {isCollapsed ? expandIcon || '▼' : collapseIcon || '▲'}
            </div>
          )}
        </div>
      </div>
    );
  };
  
  // Render an action button
  const renderAction = (action: CardActionProps, index: number) => {
    const {
      label,
      icon,
      onClick: actionOnClick,
      disabled = false,
      shape = ActionShape.SQUARE,
      tooltip,
      key,
      className: actionClassName = '',
      style: actionStyle
    } = action;
    
    const actionClassNames = [
      'cs-card-action',
      `cs-card-action-${shape}`,
      disabled ? 'cs-card-action-disabled' : '',
      actionClassName
    ].filter(Boolean).join(' ');
    
    return (
      <div
        key={key ?? index}
        className={actionClassNames}
        style={actionStyle}
        onClick={handleActionClick(action)}
        aria-disabled={disabled}
        title={tooltip}
        role="button"
        tabIndex={disabled ? -1 : 0}
      >
        {icon && <span className="cs-card-action-icon">{icon}</span>}
        {label && <span className="cs-card-action-label">{label}</span>}
      </div>
    );
  };
  
  // Render footer
  const renderFooter = () => {
    if (!footer) return null;
    
    return (
      <div 
        className={`cs-card-footer ${stickyFooter ? 'cs-card-footer-sticky' : ''}`}
      >
        {footer}
      </div>
    );
  };
  
  // Render body
  const renderBody = () => {
    // Don't render body if collapsed
    if (collapsible && isCollapsed) {
      return null;
    }
    
    // Handle loading state
    if (loading) {
      // We would normally import the Skeleton component here,
      // but for this implementation, we'll use a simple div structure
      return (
        <div className="cs-card-body">
          <div className="cs-card-loading">
            {Array.from({ length: loadingRows }).map((_, index) => (
              <div key={index} className="cs-card-loading-row" style={{ width: `${100 - (index * 10)}%` }} />
            ))}
          </div>
        </div>
      );
    }
    
    return (
      <div 
        className="cs-card-body" 
        ref={cardBodyRef}
        style={{ 
          display: orientation === 'horizontal' ? 'flex' : 'block',
          flexDirection: orientation === 'horizontal' ? 'row' : 'column'
        }}
      >
        {children}
      </div>
    );
  };
  
  // Prepare class names
  const cardClassNames = [
    'cs-card',
    `cs-card-${size}`,
    `cs-card-${type}`,
    hoverable ? 'cs-card-hoverable' : '',
    bordered ? 'cs-card-bordered' : '',
    shadow === true ? 'cs-card-shadow' : '',
    shadow === 'hover' ? 'cs-card-shadow-hover' : '',
    `cs-card-radius-${radius}`,
    `cs-card-padding-${padding}`,
    orientation === 'horizontal' ? 'cs-card-horizontal' : 'cs-card-vertical',
    collapsible ? 'cs-card-collapsible' : '',
    isCollapsed ? 'cs-card-collapsed' : '',
    selectable ? 'cs-card-selectable' : '',
    isSelected ? 'cs-card-selected' : '',
    className
  ].filter(Boolean).join(' ');
  
  // Prepare inline styles
  const cardStyles: React.CSSProperties = {
    ...style,
    backgroundColor,
    width,
    height,
    cursor: (selectable || onClick) ? 'pointer' : undefined
  };
  
  // Render component
  return (
    <div 
      className={cardClassNames}
      style={cardStyles}
      onClick={handleCardClick}
      role={selectable ? 'checkbox' : onClick ? 'button' : undefined}
      aria-checked={selectable ? isSelected : undefined}
      tabIndex={selectable || onClick ? 0 : undefined}
    >
      {media && media.position === 'top' && renderMedia()}
      {renderHeader()}
      {renderBody()}
      {renderFooter()}
      {media && media.position === 'bottom' && renderMedia()}
    </div>
  );
};

export default Card;


/**
 * Card.scss
 * 
 * Styles for the custom card component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$success-light: rgba($success, 0.1);
$success-border: rgba($success, 0.5);
$info: #17a2b8;
$info-light: rgba($info, 0.1);
$info-border: rgba($info, 0.5);
$warning: #ffc107;
$warning-light: rgba($warning, 0.1);
$warning-border: rgba($warning, 0.5);
$danger: #dc3545;
$danger-light: rgba($danger, 0.1);
$danger-border: rgba($danger, 0.5);

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius-sm: 2px;
$border-radius: 4px;
$border-radius-lg: 8px;
$border-radius-xl: 16px;

// Shadows
$shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
$shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
$shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
$shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
$shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);

// Transitions
$transition-base: all 0.2s ease-in-out;
$transition-fade: opacity 0.15s linear;
$transition-collapse: height 0.35s ease;

// Base Card styles
.cs-card {
  position: relative;
  display: flex;
  flex-direction: column;
  background-color: $white;
  font-family: $font-family;
  font-size: $font-size-base;
  line-height: $line-height-base;
  box-sizing: border-box;
  width: 100%;
  
  &:focus {
    outline: none;
  }
  
  &:focus-visible {
    outline: 2px solid $primary-color;
    outline-offset: 2px;
  }
  
  // Border variations
  &-bordered {
    border: 1px solid $gray-300;
  }
  
  // Shadow variations
  &-shadow {
    box-shadow: $shadow;
  }
  
  &-shadow-hover {
    transition: $transition-base;
    
    &:hover {
      box-shadow: $shadow;
    }
  }
  
  // Type variations
  &-default {
    // Default styles already applied
  }
  
  &-primary {
    border-color: $primary-color;
    background-color: $primary-alpha;
    
    .cs-card-title {
      color: $primary-dark;
    }
  }
  
  &-success {
    border-color: $success-border;
    background-color: $success-light;
    
    .cs-card-title {
      color: $success;
    }
  }
  
  &-info {
    border-color: $info-border;
    background-color: $info-light;
    
    .cs-card-title {
      color: $info;
    }
  }
  
  &-warning {
    border-color: $warning-border;
    background-color: $warning-light;
    
    .cs-card-title {
      color: darken($warning, 10%);
    }
  }
  
  &-danger {
    border-color: $danger-border;
    background-color: $danger-light;
    
    .cs-card-title {
      color: $danger;
    }
  }
  
  // Size variations
  &-small {
    .cs-card-header, .cs-card-footer {
      padding: $spacer;
    }
    
    .cs-card-body {
      padding: $spacer;
    }
    
    .cs-card-title {
      font-size: 16px;
    }
    
    .cs-card-subtitle {
      font-size: 12px;
    }
  }
  
  &-default {
    .cs-card-header, .cs-card-footer {
      padding: $spacer * 1.5;
    }
    
    .cs-card-body {
      padding: $spacer * 1.5;
    }
    
    .cs-card-title {
      font-size: 18px;
    }
    
    .cs-card-subtitle {
      font-size: 14px;
    }
  }
  
  &-large {
    .cs-card-header, .cs-card-footer {
      padding: $spacer * 2;
    }
    
    .cs-card-body {
      padding: $spacer * 2;
    }
    
    .cs-card-title {
      font-size: 20px;
    }
    
    .cs-card-subtitle {
      font-size: 16px;
    }
  }
  
  // Padding variations
  &-padding-none {
    .cs-card-header, .cs-card-body, .cs-card-footer {
      padding: 0;
    }
  }
  
  &-padding-small {
    .cs-card-header, .cs-card-body, .cs-card-footer {
      padding: $spacer;
    }
  }
  
  &-padding-large {
    .cs-card-header, .cs-card-body, .cs-card-footer {
      padding: $spacer * 2;
    }
  }
  
  // Radius variations
  &-radius-none {
    border-radius: 0;
  }
  
  &-radius-small {
    border-radius: $border-radius-sm;
  }
  
  &-radius-default {
    border-radius: $border-radius;
  }
  
  &-radius-large {
    border-radius: $border-radius-lg;
  }
  
  &-radius-full {
    border-radius: $border-radius-xl;
  }
  
  // Hoverable card
  &-hoverable {
    cursor: pointer;
    transition: $transition-base;
    
    &:hover {
      transform: translateY(-4px);
      box-shadow: $shadow-md;
    }
  }
  
  // Orientation
  &-horizontal {
    flex-direction: row;
    
    .cs-card-body {
      display: flex;
      flex-direction: row;
    }
    
    .cs-card-media {
      width: auto;
      height: 100%;
      
      &-container {
        width: auto;
        height: 100%;
      }
    }
  }
  
  &-vertical {
    flex-direction: column;
  }
  
  // Card header
  &-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: $spacer * 1.5;
    border-bottom: 1px solid $gray-200;
    
    &-sticky {
      position: sticky;
      top: 0;
      z-index: 1;
      background-color: inherit;
    }
    
    &-content {
      flex: 1;
      min-width: 0;
    }
    
    &-actions {
      display: flex;
      gap: $spacer;
      margin-left: $spacer;
    }
  }
  
  // Card title
  &-title {
    font-weight: 600;
    margin: 0 0 $spacer / 2 0;
  }
  
  // Card subtitle
  &-subtitle {
    color: $gray-600;
    margin: 0;
  }
  
  // Card action
  &-action {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: $spacer / 2 $spacer;
    background-color: transparent;
    border-radius: $border-radius;
    cursor: pointer;
    transition: $transition-base;
    user-select: none;
    
    &:hover {
      background-color: $gray-200;
    }
    
    &:focus {
      outline: none;
      box-shadow: 0 0 0 2px $primary-alpha;
    }
    
    &-circle {
      border-radius: 50%;
      width: 32px;
      height: 32px;
      padding: 0;
    }
    
    &-square {
      border-radius: $border-radius;
    }
    
    &-round {
      border-radius: 999px;
    }
    
    &-disabled {
      opacity: 0.5;
      pointer-events: none;
      cursor: not-allowed;
    }
    
    &-icon {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    &-label {
      margin-left: $spacer / 2;
    }
  }
  
  // Collapse action
  &-collapse-action {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    cursor: pointer;
    transition: $transition-base;
    
    &:hover {
      color: $primary-color;
    }
  }
  
  // Card body
  &-body {
    flex: 1;
    padding: $spacer * 1.5;
  }
  
  // Card footer
  &-footer {
    padding: $spacer * 1.5;
    border-top: 1px solid $gray-200;
    
    &-sticky {
      position: sticky;
      bottom: 0;
      z-index: 1;
      background-color: inherit;
    }
  }
  
  // Card media
  &-media {
    display: block;
    width: 100%;
    object-fit: cover;
    
    &-container {
      position: relative;
      width: 100%;
    }
    
    &-overlay {
      &::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
      }
    }
    
    &-overlay-content {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: $white;
    }
    
    &-cover {
      height: 100%;
    }
    
    &-top {
      border-top-left-radius: inherit;
      border-top-right-radius: inherit;
    }
    
    &-bottom {
      border-bottom-left-radius: inherit;
      border-bottom-right-radius: inherit;
    }
  }
  
  // Collapsible card
  &-collapsible {
    .cs-card-body {
      transition: $transition-collapse;
      overflow: hidden;
    }
  }
  
  &-collapsed {
    .cs-card-body {
      display: none;
    }
  }
  
  // Selectable card
  &-selectable {
    cursor: pointer;
    transition: $transition-base;
    
    &:hover {
      border-color: $primary-color;
    }
  }
  
  &-selected {
    border-color: $primary-color;
    background-color: $primary-alpha;
    
    &::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 0 24px 24px 0;
      border-color: transparent $primary-color transparent transparent;
    }
  }
  
  // Loading state
  &-loading {
    display: flex;
    flex-direction: column;
    gap: $spacer;
    
    &-row {
      height: 16px;
      background-color: $gray-200;
      border-radius: $border-radius;
      animation: cs-card-loading-pulse 1.5s ease-in-out infinite;
    }
  }
  
  @keyframes cs-card-loading-pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.4;
    }
    100% {
      opacity: 1;
    }
  }
}

// RTL support
[dir="rtl"] .cs-card {
  &-header {
    &-actions {
      margin-left: 0;
      margin-right: $spacer;
    }
  }
  
  &-action {
    &-label {
      margin-left: 0;
      margin-right: $spacer / 2;
    }
  }
  
  &-selected {
    &::after {
      right: auto;
      left: 0;
      border-width: 24px 24px 0 0;
      border-color: $primary-color transparent transparent transparent;
    }
  }
}

// Dark mode support
.cs-card-dark {
  background-color: $gray-800;
  color: $gray-300;
  border-color: $gray-700;
  
  .cs-card-header, .cs-card-footer {
    border-color: $gray-700;
  }
  
  .cs-card-title {
    color: $white;
  }
  
  .cs-card-subtitle {
    color: $gray-400;
  }
  
  .cs-card-action {
    color: $gray-300;
    
    &:hover {
      background-color: $gray-700;
    }
    
    &:focus {
      box-shadow: 0 0 0 2px rgba($primary-color, 0.5);
    }
  }
  
  .cs-card-loading-row {
    background-color: $gray-700;
  }
  
  &.cs-card-primary {
    background-color: rgba($primary-color, 0.15);
  }
  
  &.cs-card-success {
    background-color: rgba($success, 0.15);
  }
  
  &.cs-card-info {
    background-color: rgba($info, 0.15);
  }
  
  &.cs-card-warning {
    background-color: rgba($warning, 0.15);
  }
  
  &.cs-card-danger {
    background-color: rgba($danger, 0.15);
  }
}

// High contrast mode
.cs-card-high-contrast {
  border-width: 2px;
  
  .cs-card-header, .cs-card-footer {
    border-width: 2px;
  }
  
  .cs-card-action {
    border: 1px solid currentColor;
    
    &:focus {
      outline: 2px solid $black;
      outline-offset: 2px;
    }
  }
  
  .cs-card-selected::after {
    border-width: 0 30px 30px 0;
  }
  
  &.cs-card-primary, &.cs-card-success, &.cs-card-info, &.cs-card-warning, &.cs-card-danger {
    border-width: 2px;
  }
}

// Mobile styles
@media (max-width: 576px) {
  .cs-card {
    &-horizontal {
      flex-direction: column;
      
      .cs-card-body {
        flex-direction: column;
      }
    }
    
    &-header {
      flex-direction: column;
      align-items: flex-start;
      
      &-actions {
        margin-left: 0;
        margin-top: $spacer;
        align-self: flex-end;
      }
    }
  }
  
  [dir="rtl"] .cs-card-header-actions {
    margin-right: 0;
  }
}

// Print styles
@media print {
  .cs-card {
    box-shadow: none !important;
    border: 1px solid $gray-300 !important;
    break-inside: avoid;
    
    &-hoverable:hover {
      transform: none !important;
    }
    
    &-loading-row {
      animation: none !important;
      background-color: $gray-300 !important;
      border: 1px dashed $gray-500 !important;
    }
  }
}

// Responsive card grid
.cs-card-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: $spacer * 2;
}


/**
 * Accordion.tsx
 * 
 * Custom accordion component for the CSTestForge framework.
 * Provides collapsible content panels for presenting information in a limited space.
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';
import './Accordion.scss';

/**
 * Accordion item icon position enum
 */
export enum IconPosition {
  LEFT = 'left',
  RIGHT = 'right'
}

/**
 * Accordion expand mode enum
 */
export enum ExpandMode {
  SINGLE = 'single',
  MULTIPLE = 'multiple'
}

/**
 * Accordion size enum
 */
export enum AccordionSize {
  SMALL = 'small',
  DEFAULT = 'default',
  LARGE = 'large'
}

/**
 * Accordion variant enum
 */
export enum AccordionVariant {
  DEFAULT = 'default',
  BORDERED = 'bordered',
  GHOST = 'ghost'
}

/**
 * Accordion item props interface
 */
export interface AccordionItemProps {
  /**
   * Item key
   */
  key: string | number;
  
  /**
   * Item header/title
   */
  header: React.ReactNode;
  
  /**
   * Item content
   */
  children: React.ReactNode;
  
  /**
   * Whether item is disabled
   */
  disabled?: boolean;
  
  /**
   * Whether item is expanded (controlled)
   */
  expanded?: boolean;
  
  /**
   * Whether item should be initially expanded
   */
  defaultExpanded?: boolean;
  
  /**
   * Custom expand icon
   */
  expandIcon?: React.ReactNode;
  
  /**
   * Custom collapse icon
   */
  collapseIcon?: React.ReactNode;
  
  /**
   * Additional header actions
   */
  extra?: React.ReactNode;
  
  /**
   * Whether to show border
   */
  bordered?: boolean;
  
  /**
   * Header class name
   */
  headerClassName?: string;
  
  /**
   * Content class name
   */
  contentClassName?: string;
  
  /**
   * Additional header style
   */
  headerStyle?: React.CSSProperties;
  
  /**
   * Additional content style
   */
  contentStyle?: React.CSSProperties;
  
  /**
   * Callback when expanded state changes
   */
  onExpand?: (expanded: boolean) => void;
}

/**
 * Accordion props interface
 */
export interface AccordionProps {
  /**
   * Accordion children (AccordionItem components)
   */
  children: React.ReactNode;
  
  /**
   * Default active item keys
   */
  defaultActiveKeys?: (string | number)[];
  
  /**
   * Active item keys (controlled)
   */
  activeKeys?: (string | number)[];
  
  /**
   * Expand mode (single or multiple items)
   */
  expandMode?: ExpandMode;
  
  /**
   * Whether to show borders
   */
  bordered?: boolean;
  
  /**
   * Accordion size
   */
  size?: AccordionSize;
  
  /**
   * Accordion variant
   */
  variant?: AccordionVariant;
  
  /**
   * Icon position in header
   */
  iconPosition?: IconPosition;
  
  /**
   * Custom expand icon
   */
  expandIcon?: React.ReactNode;
  
  /**
   * Custom collapse icon
   */
  collapseIcon?: React.ReactNode;
  
  /**
   * Whether to enable accordion animation
   */
  animated?: boolean;
  
  /**
   * Whether to collapse items when clicking outside
   */
  collapseOnOutsideClick?: boolean;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Callback when active keys change
   */
  onChange?: (activeKeys: (string | number)[]) => void;
}

/**
 * Accordion Item component
 */
export const AccordionItem: React.FC<AccordionItemProps> = ({
  header,
  children,
  disabled = false,
  expanded,
  defaultExpanded = false,
  expandIcon,
  collapseIcon,
  extra,
  bordered,
  headerClassName = '',
  contentClassName = '',
  headerStyle,
  contentStyle,
  onExpand
}) => {
  // This is just a wrapper component for structure
  // The implementation is handled in the Accordion component
  return (
    <div>
      {header}
      <div>{children}</div>
    </div>
  );
};

/**
 * Accordion component
 */
const Accordion: React.FC<AccordionProps> = (props) => {
  const {
    children,
    defaultActiveKeys = [],
    activeKeys,
    expandMode = ExpandMode.SINGLE,
    bordered = true,
    size = AccordionSize.DEFAULT,
    variant = AccordionVariant.DEFAULT,
    iconPosition = IconPosition.RIGHT,
    expandIcon,
    collapseIcon,
    animated = true,
    collapseOnOutsideClick = false,
    className = '',
    style,
    onChange
  } = props;

  // State for active keys
  const [activeKeysState, setActiveKeysState] = useState<(string | number)[]>(
    activeKeys !== undefined ? activeKeys : defaultActiveKeys
  );
  
  // Reference to accordion element
  const accordionRef = useRef<HTMLDivElement>(null);
  
  // References to content elements
  const contentRefs = useRef<Map<string | number, HTMLDivElement>>(new Map());
  
  // Update controlled active keys
  useEffect(() => {
    if (activeKeys !== undefined) {
      setActiveKeysState(activeKeys);
    }
  }, [activeKeys]);
  
  // Handle outside clicks
  useEffect(() => {
    if (collapseOnOutsideClick) {
      const handleClickOutside = (event: MouseEvent) => {
        if (
          accordionRef.current &&
          !accordionRef.current.contains(event.target as Node)
        ) {
          if (activeKeys === undefined) {
            setActiveKeysState([]);
            
            if (onChange) {
              onChange([]);
            }
          }
        }
      };
      
      document.addEventListener('mousedown', handleClickOutside);
      
      return () => {
        document.removeEventListener('mousedown', handleClickOutside);
      };
    }
  }, [collapseOnOutsideClick, onChange, activeKeys]);
  
  // Toggle item expansion
  const toggleItem = useCallback((key: string | number, itemOnExpand?: (expanded: boolean) => void) => {
    if (activeKeys === undefined) {
      setActiveKeysState(prevKeys => {
        const isActive = prevKeys.includes(key);
        let newKeys: (string | number)[];
        
        if (expandMode === ExpandMode.SINGLE) {
          // Single mode: replace previous key
          newKeys = isActive ? [] : [key];
        } else {
          // Multiple mode: toggle key
          newKeys = isActive
            ? prevKeys.filter(k => k !== key)
            : [...prevKeys, key];
        }
        
        if (onChange) {
          onChange(newKeys);
        }
        
        if (itemOnExpand) {
          itemOnExpand(!isActive);
        }
        
        return newKeys;
      });
    } else if (itemOnExpand) {
      // For controlled component, still call individual item's onExpand
      itemOnExpand(!activeKeysState.includes(key));
    }
  }, [activeKeys, expandMode, onChange, activeKeysState]);
  
  // Get content height for animation
  const getContentHeight = useCallback((key: string | number) => {
    const contentElement = contentRefs.current.get(key);
    
    if (contentElement) {
      const contentHeight = contentElement.scrollHeight;
      return contentHeight;
    }
    
    return 0;
  }, []);
  
  // Set content element reference
  const setContentRef = useCallback((element: HTMLDivElement | null, key: string | number) => {
    if (element) {
      contentRefs.current.set(key, element);
    } else {
      contentRefs.current.delete(key);
    }
  }, []);
  
  // Register item props for iteration
  interface ItemPropsWithKey extends AccordionItemProps {
    key: string | number;
  }
  
  // Extract and process accordion items
  const items: ItemPropsWithKey[] = React.Children.toArray(children)
    .filter((child): child is React.ReactElement<AccordionItemProps> => 
      React.isValidElement(child) && child.type === AccordionItem
    )
    .map(child => ({
      ...child.props,
      key: child.key !== null ? child.key.toString().replace('.$', '') : ''
    }));
  
  // Determine if item is expanded
  const isItemExpanded = (key: string | number, itemExpanded?: boolean, itemDefaultExpanded?: boolean) => {
    // If item has controlled expanded prop, use it
    if (itemExpanded !== undefined) {
      return itemExpanded;
    }
    
    // Otherwise check if key is in active keys
    return activeKeysState.includes(key);
  };
  
  // Render accordion item
  const renderItem = (item: ItemPropsWithKey) => {
    const {
      key,
      header,
      children: itemChildren,
      disabled = false,
      expanded: itemExpanded,
      defaultExpanded: itemDefaultExpanded,
      expandIcon: itemExpandIcon,
      collapseIcon: itemCollapseIcon,
      extra,
      bordered: itemBordered,
      headerClassName,
      contentClassName,
      headerStyle,
      contentStyle,
      onExpand
    } = item;
    
    const isExpanded = isItemExpanded(key, itemExpanded, itemDefaultExpanded);
    const itemBorderedStyle = itemBordered !== undefined ? itemBordered : bordered;
    
    // Determine which icons to use (item props take precedence)
    const actualExpandIcon = itemExpandIcon ?? expandIcon ?? (
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>
    );
    
    const actualCollapseIcon = itemCollapseIcon ?? collapseIcon ?? (
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="18 15 12 9 6 15"></polyline>
      </svg>
    );
    
    // Build class names
    const itemClassNames = [
      'cs-accordion-item',
      disabled ? 'cs-accordion-item-disabled' : '',
      isExpanded ? 'cs-accordion-item-expanded' : '',
      itemBorderedStyle ? 'cs-accordion-item-bordered' : ''
    ].filter(Boolean).join(' ');
    
    const headerClassNames = [
      'cs-accordion-header',
      `cs-accordion-header-${size}`,
      disabled ? 'cs-accordion-header-disabled' : '',
      isExpanded ? 'cs-accordion-header-expanded' : '',
      headerClassName
    ].filter(Boolean).join(' ');
    
    const contentClassNames = [
      'cs-accordion-content',
      isExpanded ? 'cs-accordion-content-expanded' : '',
      animated ? 'cs-accordion-content-animated' : '',
      contentClassName
    ].filter(Boolean).join(' ');
    
    // Handle header click
    const handleHeaderClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      
      if (!disabled) {
        toggleItem(key, onExpand);
      }
    };
    
    // Get icon based on expansion state
    const icon = isExpanded ? actualCollapseIcon : actualExpandIcon;
    
    return (
      <div key={key} className={itemClassNames}>
        <div 
          className={headerClassNames}
          onClick={handleHeaderClick}
          style={headerStyle}
          aria-expanded={isExpanded}
          aria-disabled={disabled}
          role="button"
          tabIndex={disabled ? -1 : 0}
        >
          {iconPosition === IconPosition.LEFT && (
            <div className="cs-accordion-icon cs-accordion-icon-left">
              {icon}
            </div>
          )}
          
          <div className="cs-accordion-header-text">
            {header}
          </div>
          
          <div className="cs-accordion-header-extra">
            {extra && <div className="cs-accordion-extra">{extra}</div>}
            
            {iconPosition === IconPosition.RIGHT && (
              <div className="cs-accordion-icon cs-accordion-icon-right">
                {icon}
              </div>
            )}
          </div>
        </div>
        
        <div 
          className={contentClassNames}
          style={{
            ...contentStyle,
            height: animated && isExpanded ? getContentHeight(key) : undefined,
            display: !animated && !isExpanded ? 'none' : undefined
          }}
        >
          <div 
            className="cs-accordion-content-inner"
            ref={el => setContentRef(el, key)}
          >
            {itemChildren}
          </div>
        </div>
      </div>
    );
  };
  
  // Build class names
  const accordionClassNames = [
    'cs-accordion',
    `cs-accordion-${size}`,
    `cs-accordion-${variant}`,
    className
  ].filter(Boolean).join(' ');
  
  // Render component
  return (
    <div 
      ref={accordionRef} 
      className={accordionClassNames} 
      style={style}
    >
      {items.map(renderItem)}
    </div>
  );
};

Accordion.Item = AccordionItem;

export default Accordion;

/**
 * Accordion.scss
 * 
 * Styles for the custom accordion component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$info: #17a2b8;
$warning: #ffc107;
$danger: #dc3545;

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius: 4px;

// Transitions
$transition-base: all 0.2s ease-in-out;
$transition-collapse: height 0.35s ease;
$transition-transform: transform 0.2s ease;

// Base Accordion styles
.cs-accordion {
  width: 100%;
  font-family: $font-family;
  font-size: $font-size-base;
  line-height: $line-height-base;
  
  // Accordion variants
  &-default {
    background-color: $white;
  }
  
  &-bordered {
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    
    .cs-accordion-item-bordered:not(:last-child) {
      border-bottom: 1px solid $gray-300;
    }
  }
  
  &-ghost {
    background-color: transparent;
    
    .cs-accordion-header {
      background-color: transparent;
      
      &:hover {
        background-color: rgba($black, 0.02);
      }
    }
    
    .cs-accordion-content {
      background-color: transparent;
    }
  }
  
  // Accordion sizes
  &-small {
    .cs-accordion-header {
      padding: $spacer;
      min-height: 40px;
      
      &-text {
        font-size: $font-size-base;
      }
    }
    
    .cs-accordion-content-inner {
      padding: $spacer;
    }
    
    .cs-accordion-icon {
      svg {
        width: 14px;
        height: 14px;
      }
    }
  }
  
  &-default {
    .cs-accordion-header {
      padding: $spacer * 1.5;
      min-height: 48px;
      
      &-text {
        font-size: $font-size-base;
      }
    }
    
    .cs-accordion-content-inner {
      padding: $spacer * 1.5;
    }
    
    .cs-accordion-icon {
      svg {
        width: 16px;
        height: 16px;
      }
    }
  }
  
  &-large {
    .cs-accordion-header {
      padding: $spacer * 2;
      min-height: 56px;
      
      &-text {
        font-size: $font-size-base * 1.1;
      }
    }
    
    .cs-accordion-content-inner {
      padding: $spacer * 2;
    }
    
    .cs-accordion-icon {
      svg {
        width: 18px;
        height: 18px;
      }
    }
  }
  
  // Accordion item
  &-item {
    width: 100%;
    overflow: hidden;
    
    &-bordered {
      &:first-child {
        border-top-left-radius: $border-radius;
        border-top-right-radius: $border-radius;
      }
      
      &:last-child {
        border-bottom-left-radius: $border-radius;
        border-bottom-right-radius: $border-radius;
      }
    }
    
    &-disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  }
  
  // Accordion header
  &-header {
    display: flex;
    align-items: center;
    background-color: $white;
    cursor: pointer;
    user-select: none;
    transition: $transition-base;
    position: relative;
    
    &:hover {
      background-color: $gray-100;
    }
    
    &:focus {
      outline: none;
      background-color: $gray-100;
    }
    
    &:focus-visible {
      box-shadow: 0 0 0 2px $primary-alpha;
      z-index: 1;
    }
    
    &-text {
      flex: 1;
      min-width: 0;
      margin-right: $spacer;
    }
    
    &-extra {
      display: flex;
      align-items: center;
    }
    
    &-expanded {
      font-weight: 500;
    }
    
    &-disabled {
      cursor: not-allowed;
      
      &:hover {
        background-color: $white;
      }
    }
  }
  
  // Accordion icon
  &-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    color: $gray-600;
    transition: $transition-transform;
    
    &-left {
      margin-right: $spacer;
    }
    
    &-right {
      margin-left: $spacer;
    }
    
    .cs-accordion-item-expanded & {
      color: $primary-color;
    }
  }
  
  // Extra elements in header
  &-extra {
    margin-right: $spacer;
  }
  
  // Accordion content
  &-content {
    overflow: hidden;
    background-color: $white;
    
    &-animated {
      height: 0;
      transition: $transition-collapse;
    }
    
    &-expanded {
      height: auto;
      
      &:not(.cs-accordion-content-animated) {
        height: auto;
      }
    }
    
    &-inner {
      width: 100%;
    }
  }
}

// RTL support
[dir="rtl"] .cs-accordion {
  &-header {
    &-text {
      margin-right: 0;
      margin-left: $spacer;
    }
  }
  
  &-icon {
    &-left {
      margin-right: 0;
      margin-left: $spacer;
    }
    
    &-right {
      margin-left: 0;
      margin-right: $spacer;
    }
  }
  
  &-extra {
    margin-right: 0;
    margin-left: $spacer;
  }
}

// Dark mode support
.cs-accordion-dark {
  .cs-accordion-header {
    background-color: $gray-800;
    color: $gray-300;
    
    &:hover {
      background-color: $gray-700;
    }
    
    &:focus-visible {
      box-shadow: 0 0 0 2px rgba($primary-color, 0.5);
    }
    
    &-expanded {
      background-color: $gray-700;
    }
    
    &-disabled:hover {
      background-color: $gray-800;
    }
  }
  
  .cs-accordion-content {
    background-color: $gray-800;
    color: $gray-300;
  }
  
  .cs-accordion-icon {
    color: $gray-500;
  }
  
  &.cs-accordion-bordered {
    border-color: $gray-700;
    
    .cs-accordion-item-bordered:not(:last-child) {
      border-color: $gray-700;
    }
  }
  
  &.cs-accordion-ghost {
    .cs-accordion-header {
      background-color: transparent;
      
      &:hover {
        background-color: rgba($white, 0.05);
      }
      
      &-expanded {
        background-color: rgba($white, 0.05);
      }
    }
  }
}

// High contrast mode
.cs-accordion-high-contrast {
  border: 2px solid $black;
  
  .cs-accordion-header {
    font-weight: bold;
    
    &:focus-visible {
      outline: 2px solid $black;
      outline-offset: -2px;
    }
    
    &-expanded {
      background-color: $gray-200;
    }
  }
  
  .cs-accordion-item-bordered:not(:last-child) {
    border-bottom: 2px solid $black;
  }
  
  .cs-accordion-icon {
    color: $black;
  }
  
  &.cs-accordion-ghost {
    .cs-accordion-header-expanded {
      background-color: $gray-200;
    }
  }
}

// Mobile styles
@media (max-width: 576px) {
  .cs-accordion {
    &-header {
      padding: $spacer;
      
      &-text {
        font-size: $font-size-base;
      }
    }
    
    &-content-inner {
      padding: $spacer;
    }
    
    &-large {
      .cs-accordion-header {
        padding: $spacer * 1.5;
      }
      
      .cs-accordion-content-inner {
        padding: $spacer * 1.5;
      }
    }
  }
}

// Print styles
@media print {
  .cs-accordion {
    &-content {
      height: auto !important;
      display: block !important;
    }
    
    &-icon {
      display: none !important;
    }
    
    &-header {
      background-color: $white !important;
      font-weight: bold !important;
    }
  }
}

// Reduced motion support
@media (prefers-reduced-motion: reduce) {
  .cs-accordion {
    &-content {
      transition: none !important;
    }
    
    &-icon {
      transition: none !important;
    }
  }
}

// Animation keyframes
@keyframes cs-accordion-slide-down {
  0% {
    opacity: 0;
    transform: translateY(-10px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes cs-accordion-slide-up {
  0% {
    opacity: 1;
    transform: translateY(0);
  }
  100% {
    opacity: 0;
    transform: translateY(-10px);
  }
}

// Animation classes
.cs-accordion-animated-item {
  .cs-accordion-content-inner {
    animation: cs-accordion-slide-down 0.3s ease forwards;
  }
  
  &.cs-accordion-item-expanded {
    .cs-accordion-content-inner {
      animation: cs-accordion-slide-down 0.3s ease forwards;
    }
  }
  
  &:not(.cs-accordion-item-expanded) {
    .cs-accordion-content-inner {
      animation: cs-accordion-slide-up 0.3s ease forwards;
    }
  }
}

// Different styles for accordion icon types
.cs-accordion-icon-types {
  // Plus/minus
  &-plus {
    .cs-accordion-icon {
      position: relative;
      width: 16px;
      height: 16px;
      
      &::before,
      &::after {
        content: '';
        position: absolute;
        background-color: currentColor;
      }
      &::before {
        width: 16px;
        height: 2px;
        top: 7px;
        left: 0;
      }
      
      &::after {
        width: 2px;
        height: 16px;
        top: 0;
        left: 7px;
        transition: transform 0.2s ease;
      }
    }
    
    .cs-accordion-item-expanded .cs-accordion-icon::after {
      transform: scaleY(0);
    }
  }
  
  // Arrow
  &-arrow {
    .cs-accordion-icon {
      svg {
        transition: transform 0.2s ease;
      }
    }
    
    .cs-accordion-item-expanded .cs-accordion-icon svg {
      transform: rotate(180deg);
    }
  }
  
  // Chevron
  &-chevron {
    .cs-accordion-icon {
      svg {
        transition: transform 0.2s ease;
      }
    }
    
    .cs-accordion-item-expanded .cs-accordion-icon svg {
      transform: rotate(-180deg);
    }
  }
  
  // Circle plus/minus
  &-circle {
    .cs-accordion-icon {
      position: relative;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 1px solid currentColor;
      
      &::before,
      &::after {
        content: '';
        position: absolute;
        background-color: currentColor;
      }
      
      &::before {
        width: 10px;
        height: 2px;
        top: 7px;
        left: 3px;
      }
      
      &::after {
        width: 2px;
        height: 10px;
        top: 3px;
        left: 7px;
        transition: transform 0.2s ease;
      }
    }
    
    .cs-accordion-item-expanded .cs-accordion-icon::after {
      transform: scaleY(0);
    }
  }
}

// Custom accordion themes
.cs-accordion {
  // Primary theme
  &-theme-primary {
    .cs-accordion-header-expanded {
      color: $primary-color;
    }
    
    .cs-accordion-item-expanded .cs-accordion-icon {
      color: $primary-color;
    }
  }
  
  // Success theme
  &-theme-success {
    .cs-accordion-header-expanded {
      color: $success;
    }
    
    .cs-accordion-item-expanded .cs-accordion-icon {
      color: $success;
    }
  }
  
  // Info theme
  &-theme-info {
    .cs-accordion-header-expanded {
      color: $info;
    }
    
    .cs-accordion-item-expanded .cs-accordion-icon {
      color: $info;
    }
  }
  
  // Warning theme
  &-theme-warning {
    .cs-accordion-header-expanded {
      color: $warning;
    }
    
    .cs-accordion-item-expanded .cs-accordion-icon {
      color: $warning;
    }
  }
  
  // Danger theme
  &-theme-danger {
    .cs-accordion-header-expanded {
      color: $danger;
    }
    
    .cs-accordion-item-expanded .cs-accordion-icon {
      color: $danger;
    }
  }
}

// Nested accordions
.cs-accordion {
  .cs-accordion {
    margin: $spacer 0;
    
    &:first-child {
      margin-top: 0;
    }
    
    &:last-child {
      margin-bottom: 0;
    }
  }
}

// Accordion group (multiple accordions stacked)
.cs-accordion-group {
  display: flex;
  flex-direction: column;
  gap: $spacer * 2;
}

// Accordion with custom content styling
.cs-accordion-with-rich-content {
  .cs-accordion-content-inner {
    h1, h2, h3, h4, h5, h6 {
      margin-top: 0;
      margin-bottom: $spacer;
    }
    
    p {
      margin-bottom: $spacer;
      
      &:last-child {
        margin-bottom: 0;
      }
    }
    
    ul, ol {
      margin-top: 0;
      margin-bottom: $spacer;
      padding-left: $spacer * 2.5;
      
      &:last-child {
        margin-bottom: 0;
      }
    }
    
    code {
      padding: 2px 4px;
      background-color: $gray-100;
      border-radius: $border-radius;
    }
    
    pre {
      padding: $spacer;
      background-color: $gray-100;
      border-radius: $border-radius;
      overflow: auto;
      margin-bottom: $spacer;
      
      &:last-child {
        margin-bottom: 0;
      }
      
      code {
        padding: 0;
        background-color: transparent;
      }
    }
    
    blockquote {
      padding-left: $spacer;
      border-left: 4px solid $gray-300;
      margin-left: 0;
      margin-right: 0;
      margin-bottom: $spacer;
      
      &:last-child {
        margin-bottom: 0;
      }
    }
    
    img {
      max-width: 100%;
      height: auto;
      border-radius: $border-radius;
      margin-bottom: $spacer;
      
      &:last-child {
        margin-bottom: 0;
      }
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: $spacer;
      
      &:last-child {
        margin-bottom: 0;
      }
      
      th, td {
        border: 1px solid $gray-300;
        padding: $spacer / 2;
        text-align: left;
      }
      
      th {
        background-color: $gray-100;
        font-weight: 600;
      }
      
      tr:nth-child(even) {
        background-color: $gray-100;
      }
    }
  }
  
  &.cs-accordion-dark {
    .cs-accordion-content-inner {
      code {
        background-color: $gray-700;
      }
      
      pre {
        background-color: $gray-700;
      }
      
      blockquote {
        border-left-color: $gray-600;
      }
      
      table {
        th, td {
          border-color: $gray-600;
        }
        
        th {
          background-color: $gray-700;
        }
        
        tr:nth-child(even) {
          background-color: $gray-700;
        }
      }
    }
  }
}

// Accordion content transitions for smoother animations
.cs-accordion-content-transition {
  &-enter {
    max-height: 0;
    overflow: hidden;
  }
  
  &-enter-active {
    max-height: 1000px;
    overflow: hidden;
    transition: max-height 0.5s ease-in;
  }
  
  &-exit {
    max-height: 1000px;
    overflow: hidden;
  }
  
  &-exit-active {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.5s ease-out;
  }
}

// Accessibility enhancements
.cs-accordion-a11y {
  .cs-accordion-header {
    &:focus-visible {
      outline: 2px solid $primary-color;
      outline-offset: 2px;
      position: relative;
      z-index: 1;
    }
  }
  
  .cs-accordion-content {
    &[aria-hidden="true"] {
      display: none;
    }
  }
}


/**
 * List.tsx
 * 
 * Custom list component for the CSTestForge framework.
 * Provides customizable list display with various styling options.
 */

import React, { useCallback } from 'react';
import './List.scss';

/**
 * List size enum
 */
export enum ListSize {
  SMALL = 'small',
  DEFAULT = 'default',
  LARGE = 'large'
}

/**
 * List type enum
 */
export enum ListType {
  DEFAULT = 'default',
  PRIMARY = 'primary',
  SUCCESS = 'success',
  WARNING = 'warning',
  DANGER = 'danger',
  INFO = 'info'
}

/**
 * List layout enum
 */
export enum ListLayout {
  VERTICAL = 'vertical',
  HORIZONTAL = 'horizontal',
  GRID = 'grid'
}

/**
 * List header position enum
 */
export enum HeaderPosition {
  TOP = 'top',
  BOTTOM = 'bottom',
  LEFT = 'left',
  RIGHT = 'right'
}

/**
 * List footer position enum
 */
export enum FooterPosition {
  TOP = 'top',
  BOTTOM = 'bottom',
  LEFT = 'left',
  RIGHT = 'right'
}

/**
 * Item meta props interface
 */
export interface ItemMetaProps {
  /**
   * Item title
   */
  title?: React.ReactNode;
  
  /**
   * Item description
   */
  description?: React.ReactNode;
  
  /**
   * Item avatar
   */
  avatar?: React.ReactNode;
  
  /**
   * Item extra content
   */
  extra?: React.ReactNode;
}

/**
 * List item props interface
 */
export interface ListItemProps {
  /**
   * Item key
   */
  key?: string | number;
  
  /**
   * Item content
   */
  children?: React.ReactNode;
  
  /**
   * Item actions
   */
  actions?: React.ReactNode[];
  
  /**
   * Item meta
   */
  meta?: ItemMetaProps;
  
  /**
   * Item extra content
   */
  extra?: React.ReactNode;
  
  /**
   * Whether item is disabled
   */
  disabled?: boolean;
  
  /**
   * Whether item is selected
   */
  selected?: boolean;
  
  /**
   * Whether item is clickable
   */
  clickable?: boolean;
  
  /**
   * Click handler
   */
  onClick?: (event: React.MouseEvent<HTMLLIElement>) => void;
  
  /**
   * Mouse enter handler
   */
  onMouseEnter?: (event: React.MouseEvent<HTMLLIElement>) => void;
  
  /**
   * Mouse leave handler
   */
  onMouseLeave?: (event: React.MouseEvent<HTMLLIElement>) => void;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
}

/**
 * List props interface
 */
export interface ListProps {
  /**
   * List header
   */
  header?: React.ReactNode;
  
  /**
   * List footer
   */
  footer?: React.ReactNode;
  
  /**
   * List items
   */
  dataSource?: any[];
  
  /**
   * Render function for list items
   */
  renderItem?: (item: any, index: number) => React.ReactNode;
  
  /**
   * List size
   */
  size?: ListSize;
  
  /**
   * List type
   */
  type?: ListType;
  
  /**
   * List layout
   */
  layout?: ListLayout;
  
  /**
   * Whether list has borders
   */
  bordered?: boolean;
  
  /**
   * Whether list items have separators
   */
  split?: boolean;
  
  /**
   * Whether list has striped rows
   */
  striped?: boolean;
  
  /**
   * Whether list is loading
   */
  loading?: boolean;
  
  /**
   * Number of loading items
   */
  loadingRows?: number;
  
  /**
   * List empty state content
   */
  empty?: React.ReactNode;
  
  /**
   * List item width (for grid layout)
   */
  itemWidth?: number | string;
  
  /**
   * Grid columns count
   */
  grid?: number;
  
  /**
   * Grid gap
   */
  gridGap?: number | string;
  
  /**
   * Whether list header is sticky
   */
  stickyHeader?: boolean;
  
  /**
   * Whether list footer is sticky
   */
  stickyFooter?: boolean;
  
  /**
   * Header position
   */
  headerPosition?: HeaderPosition;
  
  /**
   * Footer position
   */
  footerPosition?: FooterPosition;
  
  /**
   * Whether to show item hover effect
   */
  hoverable?: boolean;
  
  /**
   * Whether to show item click effect
   */
  clickable?: boolean;
  
  /**
   * Whether list is scrollable
   */
  scrollable?: boolean;
  
  /**
   * List height (for scrollable lists)
   */
  height?: number | string;
  
  /**
   * Whether to show item numbers
   */
  numbered?: boolean;
  
  /**
   * Function to get item key
   */
  rowKey?: string | ((item: any) => string);
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * List children (alternative to dataSource + renderItem)
   */
  children?: React.ReactNode;
}

/**
 * List.Item.Meta component
 */
export const ListItemMeta: React.FC<ItemMetaProps> = ({
  title,
  description,
  avatar,
  extra
}) => {
  // This is just a wrapper component for structure
  // The implementation is handled in the ListItem component
  return null;
};

/**
 * List.Item component
 */
export const ListItem: React.FC<ListItemProps> = ({
  children,
  actions,
  meta,
  extra,
  disabled = false,
  selected = false,
  clickable = false,
  onClick,
  onMouseEnter,
  onMouseLeave,
  className = '',
  style
}) => {
  // This is just a wrapper component for structure
  // The implementation is handled in the List component
  return null;
};

/**
 * List component
 */
const List: React.FC<ListProps> = (props) => {
  const {
    header,
    footer,
    dataSource,
    renderItem,
    size = ListSize.DEFAULT,
    type = ListType.DEFAULT,
    layout = ListLayout.VERTICAL,
    bordered = false,
    split = true,
    striped = false,
    loading = false,
    loadingRows = 3,
    empty,
    itemWidth,
    grid,
    gridGap = 16,
    stickyHeader = false,
    stickyFooter = false,
    headerPosition = HeaderPosition.TOP,
    footerPosition = FooterPosition.BOTTOM,
    hoverable = false,
    clickable = false,
    scrollable = false,
    height,
    numbered = false,
    rowKey,
    className = '',
    style,
    children
  } = props;

  // Get item key
  const getItemKey = useCallback((item: any, index: number): string => {
    if (rowKey) {
      if (typeof rowKey === 'function') {
        return rowKey(item);
      }
      
      return item[rowKey];
    }
    
    return `item-${index}`;
  }, [rowKey]);
  
  // Render list item meta
  const renderItemMeta = (meta?: ItemMetaProps) => {
    if (!meta) return null;
    
    const { title, description, avatar, extra } = meta;
    
    return (
      <div className="cs-list-item-meta">
        {avatar && (
          <div className="cs-list-item-meta-avatar">
            {avatar}
          </div>
        )}
        
        <div className="cs-list-item-meta-content">
          {title && (
            <div className="cs-list-item-meta-title">
              {title}
            </div>
          )}
          
          {description && (
            <div className="cs-list-item-meta-description">
              {description}
            </div>
          )}
        </div>
        
        {extra && (
          <div className="cs-list-item-meta-extra">
            {extra}
          </div>
        )}
      </div>
    );
  };
  
  // Render list item actions
  const renderItemActions = (actions?: React.ReactNode[]) => {
    if (!actions || actions.length === 0) return null;
    
    return (
      <ul className="cs-list-item-actions">
        {actions.map((action, index) => (
          <li key={`action-${index}`} className="cs-list-item-action">
            {action}
            {index !== actions.length - 1 && (
              <span className="cs-list-item-action-separator" />
            )}
          </li>
        ))}
      </ul>
    );
  };
  
  // Render list item
  const renderListItem = (item: ListItemProps, index: number) => {
    const {
      key,
      children: itemChildren,
      actions,
      meta,
      extra,
      disabled = false,
      selected = false,
      clickable: itemClickable = clickable,
      onClick,
      onMouseEnter,
      onMouseLeave,
      className: itemClassName = '',
      style: itemStyle
    } = item;
    
    const itemClassNames = [
      'cs-list-item',
      disabled ? 'cs-list-item-disabled' : '',
      selected ? 'cs-list-item-selected' : '',
      (itemClickable || onClick) ? 'cs-list-item-clickable' : '',
      hoverable ? 'cs-list-item-hoverable' : '',
      striped && index % 2 === 1 ? 'cs-list-item-striped' : '',
      itemClassName
    ].filter(Boolean).join(' ');
    
    // Handle item click
    const handleClick = (event: React.MouseEvent<HTMLLIElement>) => {
      if (disabled) return;
      
      if (onClick) {
        onClick(event);
      }
    };
    
    // Handle item mouse enter
    const handleMouseEnter = (event: React.MouseEvent<HTMLLIElement>) => {
      if (disabled) return;
      
      if (onMouseEnter) {
        onMouseEnter(event);
      }
    };
    
    // Handle item mouse leave
    const handleMouseLeave = (event: React.MouseEvent<HTMLLIElement>) => {
      if (disabled) return;
      
      if (onMouseLeave) {
        onMouseLeave(event);
      }
    };
    
    return (
      <li
        key={key ?? `item-${index}`}
        className={itemClassNames}
        style={{
          ...itemStyle,
          width: layout === ListLayout.GRID ? itemWidth : undefined
        }}
        onClick={handleClick}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        aria-disabled={disabled}
        aria-selected={selected}
      >
        {numbered && (
          <div className="cs-list-item-number">
            {index + 1}.
          </div>
        )}
        
        <div className="cs-list-item-content">
          {meta && renderItemMeta(meta)}
          
          {itemChildren && (
            <div className="cs-list-item-main">
              {itemChildren}
            </div>
          )}
          
          {actions && renderItemActions(actions)}
        </div>
        
        {extra && (
          <div className="cs-list-item-extra">
            {extra}
          </div>
        )}
      </li>
    );
  };
  
  // Render list header
  const renderHeader = () => {
    if (!header) return null;
    
    const headerClassNames = [
      'cs-list-header',
      `cs-list-header-${headerPosition}`,
      stickyHeader ? 'cs-list-header-sticky' : ''
    ].filter(Boolean).join(' ');
    
    return (
      <div className={headerClassNames}>
        {header}
      </div>
    );
  };
  
  // Render list footer
  const renderFooter = () => {
    if (!footer) return null;
    
    const footerClassNames = [
      'cs-list-footer',
      `cs-list-footer-${footerPosition}`,
      stickyFooter ? 'cs-list-footer-sticky' : ''
    ].filter(Boolean).join(' ');
    
    return (
      <div className={footerClassNames}>
        {footer}
      </div>
    );
  };
  
  // Render empty state
  const renderEmpty = () => {
    if (!empty) {
      return (
        <div className="cs-list-empty">
          No data
        </div>
      );
    }
    
    return (
      <div className="cs-list-empty">
        {empty}
      </div>
    );
  };
  
  // Render loading state
  const renderLoading = () => {
    return (
      <div className="cs-list-loading">
        {Array.from({ length: loadingRows }).map((_, index) => (
          <div key={`loading-${index}`} className="cs-list-loading-item">
            <div className="cs-list-loading-avatar" />
            <div className="cs-list-loading-content">
              <div className="cs-list-loading-title" />
              <div className="cs-list-loading-description" />
            </div>
          </div>
        ))}
      </div>
    );
  };
  
  // Get list items
  const getItems = () => {
    // If children are provided, use them directly
    if (children) {
      return React.Children.map(children, (child, index) => {
        if (React.isValidElement(child) && child.type === ListItem) {
          return renderListItem({ ...child.props }, index);
        }
        
        return child;
      });
    }
    
    // If dataSource and renderItem are provided, use them
    if (dataSource && renderItem) {
      return dataSource.map((item, index) => {
        const renderedItem = renderItem(item, index);
        
        if (React.isValidElement(renderedItem) && renderedItem.type === ListItem) {
          return renderListItem({ ...renderedItem.props, key: getItemKey(item, index) }, index);
        }
        
        return (
          <li 
            key={getItemKey(item, index)} 
            className="cs-list-item"
            style={{
              width: layout === ListLayout.GRID ? itemWidth : undefined
            }}
          >
            {renderedItem}
          </li>
        );
      });
    }
    
    return null;
  };
  
  // Get list content
  const getListContent = () => {
    if (loading) {
      return renderLoading();
    }
    
    const items = getItems();
    
    if (!items || (Array.isArray(items) && items.length === 0)) {
      return renderEmpty();
    }
    
    const listClassNames = [
      'cs-list-items',
      layout === ListLayout.HORIZONTAL ? 'cs-list-items-horizontal' : '',
      layout === ListLayout.GRID ? 'cs-list-items-grid' : ''
    ].filter(Boolean).join(' ');
    
    const listStyles: React.CSSProperties = {
      gridTemplateColumns: layout === ListLayout.GRID && grid ? `repeat(${grid}, 1fr)` : undefined,
      gap: layout === ListLayout.GRID ? gridGap : undefined
    };
    
    return (
      <ul className={listClassNames} style={listStyles}>
        {items}
      </ul>
    );
  };
  
  // Build list class names
  const listClassNames = [
    'cs-list',
    `cs-list-${size}`,
    `cs-list-${type}`,
    `cs-list-${layout}`,
    bordered ? 'cs-list-bordered' : '',
    split ? 'cs-list-split' : '',
    hoverable ? 'cs-list-hoverable' : '',
    scrollable ? 'cs-list-scrollable' : '',
    headerPosition === HeaderPosition.LEFT || headerPosition === HeaderPosition.RIGHT ? 'cs-list-header-side' : '',
    footerPosition === FooterPosition.LEFT || footerPosition === FooterPosition.RIGHT ? 'cs-list-footer-side' : '',
    className
  ].filter(Boolean).join(' ');
  
  // Build list styles
  const listStyles: React.CSSProperties = {
    ...style,
    height: scrollable ? height : undefined
  };
  
  // Render component
  return (
    <div className={listClassNames} style={listStyles}>
      {headerPosition === HeaderPosition.TOP && renderHeader()}
      {footerPosition === FooterPosition.TOP && renderFooter()}
      
      <div className="cs-list-content">
        {headerPosition === HeaderPosition.LEFT && renderHeader()}
        {footerPosition === FooterPosition.LEFT && renderFooter()}
        
        {getListContent()}
        
        {headerPosition === HeaderPosition.RIGHT && renderHeader()}
        {footerPosition === FooterPosition.RIGHT && renderFooter()}
      </div>
      
      {headerPosition === HeaderPosition.BOTTOM && renderHeader()}
      {footerPosition === FooterPosition.BOTTOM && renderFooter()}
    </div>
  );
};

// Add component properties
List.Item = ListItem;
ListItem.Meta = ListItemMeta;

export default List;


/**
 * List.scss
 * 
 * Styles for the custom list component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$success-light: rgba($success, 0.1);
$info: #17a2b8;
$info-light: rgba($info, 0.1);
$warning: #ffc107;
$warning-light: rgba($warning, 0.1);
$danger: #dc3545;
$danger-light: rgba($danger, 0.1);

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius: 4px;

// Transitions
$transition-base: all 0.2s ease-in-out;

// Base List styles
.cs-list {
  font-family: $font-family;
  font-size: $font-size-base;
  line-height: $line-height-base;
  position: relative;
  color: $gray-900;
  background-color: $white;
  
  // Type variations
  &-default {
    // Default styles already applied
  }
  
  &-primary {
    .cs-list-header, .cs-list-footer {
      color: $primary-color;
    }
    
    .cs-list-item-selected {
      background-color: $primary-alpha;
      border-left: 3px solid $primary-color;
    }
  }
  
  &-success {
    .cs-list-header, .cs-list-footer {
      color: $success;
    }
    
    .cs-list-item-selected {
      background-color: $success-light;
      border-left: 3px solid $success;
    }
  }
  
  &-info {
    .cs-list-header, .cs-list-footer {
      color: $info;
    }
    
    .cs-list-item-selected {
      background-color: $info-light;
      border-left: 3px solid $info;
    }
  }
  
  &-warning {
    .cs-list-header, .cs-list-footer {
      color: $warning;
    }
    
    .cs-list-item-selected {
      background-color: $warning-light;
      border-left: 3px solid $warning;
    }
  }
  
  &-danger {
    .cs-list-header, .cs-list-footer {
      color: $danger;
    }
    
    .cs-list-item-selected {
      background-color: $danger-light;
      border-left: 3px solid $danger;
    }
  }
  
  // Size variations
  &-small {
    .cs-list-header, .cs-list-footer {
      padding: $spacer;
      font-size: $font-size-base - 1px;
    }
    
    .cs-list-item {
      padding: $spacer;
      
      &-meta {
        &-title {
          font-size: $font-size-base;
        }
        
        &-description {
          font-size: $font-size-base - 2px;
        }
      }
    }
  }
  
  &-default {
    .cs-list-header, .cs-list-footer {
      padding: $spacer * 1.5;
    }
    
    .cs-list-item {
      padding: $spacer * 1.5;
      
      &-meta {
        &-title {
          font-size: $font-size-base + 1px;
        }
        
        &-description {
          font-size: $font-size-base - 1px;
        }
      }
    }
  }
  
  &-large {
    .cs-list-header, .cs-list-footer {
      padding: $spacer * 2;
      font-size: $font-size-base + 2px;
    }
    
    .cs-list-item {
      padding: $spacer * 2;
      
      &-meta {
        &-title {
          font-size: $font-size-base + 2px;
        }
        
        &-description {
          font-size: $font-size-base;
        }
      }
    }
  }
  
  // Layout variations
  &-vertical {
    .cs-list-items {
      display: flex;
      flex-direction: column;
    }
  }
  
  &-horizontal {
    .cs-list-items-horizontal {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      
      .cs-list-item {
        flex: 0 0 auto;
      }
    }
  }
  
  &-items-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: $spacer * 2;
  }
  
  // Border and split variations
  &-bordered {
    border: 1px solid $gray-300;
    border-radius: $border-radius;
    
    .cs-list-header {
      border-bottom: 1px solid $gray-300;
    }
    
    .cs-list-footer {
      border-top: 1px solid $gray-300;
    }
  }
  
  &-split {
    .cs-list-item:not(:last-child) {
      border-bottom: 1px solid $gray-200;
    }
  }
  
  // Hover and clickable variations
  &-hoverable {
    .cs-list-item:not(.cs-list-item-disabled):hover {
      background-color: $gray-100;
    }
  }
  
  // Scrollable list
  &-scrollable {
    overflow-y: auto;
    
    .cs-list-content {
      overflow-y: auto;
    }
    
    .cs-list-header-sticky {
      position: sticky;
      top: 0;
      z-index: 1;
      background-color: $white;
    }
    
    .cs-list-footer-sticky {
      position: sticky;
      bottom: 0;
      z-index: 1;
      background-color: $white;
    }
  }
  
  // Header and footer positions
  &-header, &-footer {
    padding: $spacer * 1.5;
    font-weight: 500;
    
    &-top, &-bottom {
      width: 100%;
    }
    
    &-left, &-right {
      width: auto;
      padding: $spacer;
    }
    
    &-sticky {
      position: sticky;
      z-index: 1;
      background-color: $white;
    }
  }
  
  &-header-top {
    border-bottom: 1px solid $gray-200;
  }
  
  &-header-bottom {
    border-top: 1px solid $gray-200;
  }
  
  &-footer-top {
    border-bottom: 1px solid $gray-200;
  }
  
  &-footer-bottom {
    border-top: 1px solid $gray-200;
  }
  
  // Side header and footer layout
  &-header-side, &-footer-side {
    .cs-list-content {
      display: flex;
      flex-direction: row;
    }
  }
  
  // List content
  &-content {
    flex: 1;
    min-width: 0;
  }
  
  // List items
  &-items {
    list-style: none;
    margin: 0;
    padding: 0;
  }
  
  // List item
  &-item {
    position: relative;
    display: flex;
    align-items: flex-start;
    padding: $spacer * 1.5;
    transition: $transition-base;
    
    &-content {
      flex: 1;
      min-width: 0;
    }
    
    &-main {
      margin-top: $spacer;
    }
    
    &-extra {
      margin-left: $spacer * 2;
    }
    
    &-number {
      flex-shrink: 0;
      margin-right: $spacer;
      color: $gray-600;
    }
    
    // Item states
    &-disabled {
      opacity: 0.5;
      cursor: not-allowed;
      
      &:hover {
        background-color: transparent;
      }
    }
    
    &-selected {
      background-color: $gray-100;
    }
    
    &-clickable {
      cursor: pointer;
    }
    
    &-striped:nth-child(even) {
      background-color: $gray-100;
    }
    
    // Item meta
    &-meta {
      display: flex;
      align-items: flex-start;
      
      &-avatar {
        flex-shrink: 0;
        margin-right: $spacer * 1.5;
      }
      
      &-content {
        flex: 1;
        min-width: 0;
      }
      
      &-title {
        color: $gray-900;
        font-weight: 500;
        margin-bottom: $spacer / 2;
      }
      
      &-description {
        color: $gray-600;
      }
      
      &-extra {
        margin-left: $spacer * 2;
      }
    }
    
    // Item actions
    &-actions {
      display: flex;
      flex-wrap: wrap;
      gap: $spacer;
      margin-top: $spacer;
      padding: 0;
      list-style: none;
    }
    
    &-action {
      display: flex;
      align-items: center;
      
      &-separator {
        margin: 0 $spacer;
        width: 1px;
        height: 14px;
        background-color: $gray-300;
      }
    }
  }
  
  // Empty state
  &-empty {
    padding: $spacer * 4;
    text-align: center;
    color: $gray-600;
  }
  
  // Loading state
  &-loading {
    padding: $spacer * 1.5;
    
    &-item {
      display: flex;
      align-items: flex-start;
      margin-bottom: $spacer * 2;
      
      &:last-child {
        margin-bottom: 0;
      }
    }
    
    &-avatar {
      flex-shrink: 0;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: $gray-200;
      margin-right: $spacer * 1.5;
      animation: cs-list-loading-pulse 1.5s infinite ease-in-out;
    }
    
    &-content {
      flex: 1;
      min-width: 0;
    }
    
    &-title {
      width: 60%;
      height: 16px;
      background-color: $gray-200;
      margin-bottom: $spacer;
      border-radius: $border-radius;
      animation: cs-list-loading-pulse 1.5s infinite ease-in-out;
    }
    
    &-description {
      width: 90%;
      height: 12px;
      background-color: $gray-200;
      border-radius: $border-radius;
      animation: cs-list-loading-pulse 1.5s infinite ease-in-out;
    }
  }
  
  @keyframes cs-list-loading-pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.4;
    }
    100% {
      opacity: 1;
    }
  }
}

// RTL support
[dir="rtl"] .cs-list {
  &-item {
    &-extra {
      margin-left: 0;
      margin-right: $spacer * 2;
    }
    
    &-number {
      margin-right: 0;
      margin-left: $spacer;
    }
    
    &-selected {
      border-left: none;
      border-right: 3px solid $primary-color;
    }
    
    &-meta {
      &-avatar {
        margin-right: 0;
        margin-left: $spacer * 1.5;
      }
      
      &-extra {
        margin-left: 0;
        margin-right: $spacer * 2;
      }
    }
  }
}

// Dark mode support
.cs-list-dark {
  background-color: $gray-800;
  color: $gray-300;
  
  .cs-list-header, .cs-list-footer {
    background-color: $gray-800;
    color: $gray-300;
    border-color: $gray-700;
  }
  
  .cs-list-item {
    &:not(:last-child) {
      border-color: $gray-700;
    }
    
    &-meta {
      &-title {
        color: $white;
      }
      
      &-description {
        color: $gray-500;
      }
    }
    
    &-action {
      &-separator {
        background-color: $gray-700;
      }
    }
    
    &-hoverable:hover {
      background-color: $gray-700;
    }
    
    &-striped:nth-child(even) {
      background-color: rgba($gray-700, 0.5);
    }
  }
  
  .cs-list-empty {
    color: $gray-500;
  }
  
  .cs-list-loading {
    &-avatar, &-title, &-description {
      background-color: $gray-700;
    }
  }
  
  &.cs-list-bordered {
    border-color: $gray-700;
  }
}

// High contrast mode
.cs-list-high-contrast {
  border: 2px solid $black !important;
  
  .cs-list-header, .cs-list-footer {
    border-color: $black !important;
    font-weight: bold;
  }
  
  .cs-list-item {
    &:not(:last-child) {
      border-color: $black !important;
      border-width: 2px !important;
    }
    
    &-selected {
      border-left-width: 4px !important;
      font-weight: bold;
    }
  }
}

// Mobile styles
@media (max-width: 576px) {
  .cs-list {
    &-horizontal {
      .cs-list-items-horizontal {
        flex-direction: column;
      }
    }
    
    &-header-side, &-footer-side {
      .cs-list-content {
        flex-direction: column;
      }
    }
    
    &-item {
      flex-direction: column;
      
      &-extra {
        margin-left: 0;
        margin-top: $spacer;
        width: 100%;
      }
      
      &-meta {
        flex-direction: column;
        
        &-avatar {
          margin-right: 0;
          margin-bottom: $spacer;
        }
        
        &-extra {
          margin-left: 0;
          margin-top: $spacer;
          width: 100%;
        }
      }
    }
  }
  
  [dir="rtl"] .cs-list {
    &-item {
      &-extra {
        margin-right: 0;
      }
      
      &-meta {
        &-avatar {
          margin-left: 0;
        }
        
        &-extra {
          margin-right: 0;
        }
      }
    }
  }
}

// Print styles
@media print {
  .cs-list {
    border: 1px solid $gray-300 !important;
    
    &-header, &-footer {
      padding: $spacer !important;
      break-inside: avoid;
    }
    
    &-item {
      padding: $spacer !important;
      break-inside: avoid;
      
      &-hoverable:hover {
        background-color: transparent !important;
      }
    }
    
    &-empty, &-loading {
      display: none !important;
    }
  }
}

// Animations
@keyframes cs-list-item-fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

// Animated list items
.cs-list-animated {
  .cs-list-item {
    animation: cs-list-item-fade-in 0.3s ease-out;
    animation-fill-mode: both;
    
    @for $i from 1 through 20 {
      &:nth-child(#{$i}) {
        animation-delay: #{$i * 0.05}s;
      }
    }
  }
}

// List group for multiple lists
.cs-list-group {
  display: flex;
  flex-direction: column;
  gap: $spacer * 2;
}

// List tree (nested lists)
.cs-list-tree {
  .cs-list-item {
    &-children {
      margin-top: $spacer;
      margin-left: $spacer * 2;
      border-left: 1px solid $gray-300;
      padding-left: $spacer;
    }
  }
  
  &.cs-list-dark {
    .cs-list-item-children {
      border-left-color: $gray-700;
    }
  }
}

// Responsive list grid
.cs-list-responsive-grid {
  .cs-list-items {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: $spacer * 2;
  }
}


/**
 * Header.tsx
 * 
 * Custom header component for the CSTestForge framework.
 * Provides a responsive application header with logo, navigation, and actions.
 */

import React, { useState, useEffect, useRef } from 'react';
import './Header.scss';

/**
 * Header size enum
 */
export enum HeaderSize {
  SMALL = 'small',
  DEFAULT = 'default',
  LARGE = 'large'
}

/**
 * Header type enum
 */
export enum HeaderType {
  DEFAULT = 'default',
  PRIMARY = 'primary',
  TRANSPARENT = 'transparent',
  DARK = 'dark',
  LIGHT = 'light'
}

/**
 * Header navigation item interface
 */
export interface HeaderNavItem {
  /**
   * Item key
   */
  key: string;
  
  /**
   * Item label
   */
  label: React.ReactNode;
  
  /**
   * Item URL
   */
  url?: string;
  
  /**
   * Item icon
   */
  icon?: React.ReactNode;
  
  /**
   * Whether item is active
   */
  active?: boolean;
  
  /**
   * Whether item is disabled
   */
  disabled?: boolean;
  
  /**
   * Item children (for dropdown)
   */
  children?: HeaderNavItem[];
  
  /**
   * Item onClick handler
   */
  onClick?: (key: string) => void;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Badge content
   */
  badge?: React.ReactNode;
  
  /**
   * Target attribute for links
   */
  target?: string;
}

/**
 * Header action interface
 */
export interface HeaderAction {
  /**
   * Action key
   */
  key: string;
  
  /**
   * Action icon
   */
  icon: React.ReactNode;
  
  /**
   * Action label
   */
  label?: string;
  
  /**
   * Action tooltip
   */
  tooltip?: string;
  
  /**
   * Action onClick handler
   */
  onClick?: () => void;
  
  /**
   * Whether action is active
   */
  active?: boolean;
  
  /**
   * Whether action is disabled
   */
  disabled?: boolean;
  
  /**
   * Badge content
   */
  badge?: React.ReactNode;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
}

/**
 * Header props interface
 */
export interface HeaderProps {
  /**
   * Header logo
   */
  logo?: React.ReactNode;
  
  /**
   * Header logo URL
   */
  logoUrl?: string;
  
  /**
   * Header title
   */
  title?: React.ReactNode;
  
  /**
   * Header subtitle
   */
  subtitle?: React.ReactNode;
  
  /**
   * Header navigation items
   */
  navigation?: HeaderNavItem[];
  
  /**
   * Header actions
   */
  actions?: HeaderAction[];
  
  /**
   * Header user avatar
   */
  avatar?: React.ReactNode;
  
  /**
   * Header user name
   */
  userName?: string;
  
  /**
   * Header user menu items
   */
  userMenu?: HeaderNavItem[];
  
  /**
   * Header size
   */
  size?: HeaderSize;
  
  /**
   * Header type
   */
  type?: HeaderType;
  
  /**
   * Whether header is fixed at the top
   */
  fixed?: boolean;
  
  /**
   * Whether to show border
   */
  bordered?: boolean;
  
  /**
   * Whether to show shadow
   */
  shadow?: boolean;
  
  /**
   * Whether header is compact
   */
  compact?: boolean;
  
  /**
   * Whether header is collapsible on mobile
   */
  collapsible?: boolean;
  
  /**
   * Default collapsed state
   */
  defaultCollapsed?: boolean;
  
  /**
   * Collapsed state (controlled)
   */
  collapsed?: boolean;
  
  /**
   * Callback when collapsed state changes
   */
  onCollapsedChange?: (collapsed: boolean) => void;
  
  /**
   * Whether to show hamburger menu on mobile
   */
  hamburger?: boolean;
  
  /**
   * Custom hamburger icon
   */
  hamburgerIcon?: React.ReactNode;
  
  /**
   * Custom close icon
   */
  closeIcon?: React.ReactNode;
  
  /**
   * Override mobile breakpoint
   */
  mobileBreakpoint?: number;
  
  /**
   * Custom mobile navigation
   */
  mobileNavigation?: React.ReactNode;
  
  /**
   * Left side content
   */
  left?: React.ReactNode;
  
  /**
   * Center content
   */
  center?: React.ReactNode;
  
  /**
   * Right side content
   */
  right?: React.ReactNode;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Header children
   */
  children?: React.ReactNode;
  
  /**
   * Search component
   */
  search?: React.ReactNode;
  
  /**
   * Whether to show search
   */
  showSearch?: boolean;
  
  /**
   * Search placeholder
   */
  searchPlaceholder?: string;
  
  /**
   * Search callback
   */
  onSearch?: (value: string) => void;
  
  /**
   * Active navigation item key
   */
  activeKey?: string;
  
  /**
   * Navigation item click handler
   */
  onNavItemClick?: (key: string) => void;
  
  /**
   * Action click handler
   */
  onActionClick?: (key: string) => void;
}

/**
 * Header component
 */
const Header: React.FC<HeaderProps> = (props) => {
  const {
    logo,
    logoUrl,
    title,
    subtitle,
    navigation = [],
    actions = [],
    avatar,
    userName,
    userMenu = [],
    size = HeaderSize.DEFAULT,
    type = HeaderType.DEFAULT,
    fixed = false,
    bordered = true,
    shadow = false,
    compact = false,
    collapsible = true,
    defaultCollapsed = true,
    collapsed: controlledCollapsed,
    onCollapsedChange,
    hamburger = true,
    hamburgerIcon,
    closeIcon,
    mobileBreakpoint = 768,
    mobileNavigation,
    left,
    center,
    right,
    className = '',
    style,
    children,
    search,
    showSearch = false,
    searchPlaceholder = 'Search...',
    onSearch,
    activeKey,
    onNavItemClick,
    onActionClick
  } = props;

  // State for collapsed menu
  const [isCollapsed, setIsCollapsed] = useState<boolean>(
    controlledCollapsed !== undefined ? controlledCollapsed : defaultCollapsed
  );
  
  // State for user menu
  const [isUserMenuOpen, setIsUserMenuOpen] = useState<boolean>(false);
  
  // State for dropdown menus
  const [openDropdownKey, setOpenDropdownKey] = useState<string | null>(null);
  
  // State for search input
  const [searchValue, setSearchValue] = useState<string>('');
  
  // State for mobile view
  const [isMobileView, setIsMobileView] = useState<boolean>(
    typeof window !== 'undefined' ? window.innerWidth <= mobileBreakpoint : false
  );
  
  // Refs
  const headerRef = useRef<HTMLDivElement>(null);
  const userMenuRef = useRef<HTMLDivElement>(null);
  const dropdownRefs = useRef<Map<string, HTMLDivElement>>(new Map());
  
  // Effect to update mobile view
  useEffect(() => {
    const handleResize = () => {
      setIsMobileView(window.innerWidth <= mobileBreakpoint);
      
      // Close mobile menu when resizing to desktop
      if (window.innerWidth > mobileBreakpoint && !isCollapsed) {
        handleToggleCollapse();
      }
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, [mobileBreakpoint, isCollapsed]);
  
  // Effect to handle outside clicks for user menu
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        isUserMenuOpen &&
        userMenuRef.current &&
        !userMenuRef.current.contains(event.target as Node)
      ) {
        setIsUserMenuOpen(false);
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isUserMenuOpen]);
  
  // Effect to handle outside clicks for dropdowns
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (openDropdownKey && !dropdownRefs.current.get(openDropdownKey)?.contains(event.target as Node)) {
        setOpenDropdownKey(null);
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [openDropdownKey]);
  
  // Effect to handle controlled collapse state
  useEffect(() => {
    if (controlledCollapsed !== undefined) {
      setIsCollapsed(controlledCollapsed);
    }
  }, [controlledCollapsed]);
  
  // Effect to update fixed header padding
  useEffect(() => {
    if (fixed && headerRef.current) {
      const headerHeight = headerRef.current.offsetHeight;
      document.body.style.paddingTop = `${headerHeight}px`;
      
      return () => {
        document.body.style.paddingTop = '';
      };
    }
  }, [fixed]);
  
  // Toggle collapse state
  const handleToggleCollapse = () => {
    const newCollapsedState = !isCollapsed;
    
    if (controlledCollapsed === undefined) {
      setIsCollapsed(newCollapsedState);
    }
    
    if (onCollapsedChange) {
      onCollapsedChange(newCollapsedState);
    }
  };
  
  // Toggle user menu
  const handleToggleUserMenu = () => {
    setIsUserMenuOpen(!isUserMenuOpen);
  };
  
  // Toggle dropdown
  const handleToggleDropdown = (key: string) => {
    setOpenDropdownKey(openDropdownKey === key ? null : key);
  };
  
  // Set dropdown ref
  const setDropdownRef = (element: HTMLDivElement | null, key: string) => {
    if (element) {
      dropdownRefs.current.set(key, element);
    } else {
      dropdownRefs.current.delete(key);
    }
  };
  
  // Handle navigation item click
  const handleNavItemClick = (item: HeaderNavItem) => {
    if (item.disabled) return;
    
    // Close mobile menu if needed
    if (isMobileView && !isCollapsed) {
      handleToggleCollapse();
    }
    
    // Call item's onClick handler
    if (item.onClick) {
      item.onClick(item.key);
    }
    
    // Call parent's onNavItemClick handler
    if (onNavItemClick) {
      onNavItemClick(item.key);
    }
  };
  
  // Handle action click
  const handleActionClick = (action: HeaderAction) => {
    if (action.disabled) return;
    
    // Call action's onClick handler
    if (action.onClick) {
      action.onClick();
    }
    
    // Call parent's onActionClick handler
    if (onActionClick) {
      onActionClick(action.key);
    }
  };
  
  // Handle search input change
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchValue(e.target.value);
  };
  
  // Handle search submit
  const handleSearchSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (onSearch) {
      onSearch(searchValue);
    }
  };
  
  // Render logo
  const renderLogo = () => {
    if (!logo && !title) return null;
    
    return (
      <div className="cs-header-logo">
        {logoUrl ? (
          <a href={logoUrl} className="cs-header-logo-link">
            {logo && <div className="cs-header-logo-image">{logo}</div>}
            {title && (
              <div className="cs-header-title">
                {title}
                {subtitle && <div className="cs-header-subtitle">{subtitle}</div>}
              </div>
            )}
          </a>
        ) : (
          <>
            {logo && <div className="cs-header-logo-image">{logo}</div>}
            {title && (
              <div className="cs-header-title">
                {title}
                {subtitle && <div className="cs-header-subtitle">{subtitle}</div>}
              </div>
            )}
          </>
        )}
      </div>
    );
  };
  
  // Render navigation item
  const renderNavItem = (item: HeaderNavItem) => {
    const {
      key,
      label,
      url,
      icon,
      active: itemActive,
      disabled,
      children,
      className: itemClassName = '',
      style: itemStyle,
      badge
    } = item;
    
    const isActive = itemActive || activeKey === key;
    const hasDropdown = children && children.length > 0;
    const isDropdownOpen = openDropdownKey === key;
    
    const itemClassNames = [
      'cs-header-nav-item',
      isActive ? 'cs-header-nav-item-active' : '',
      disabled ? 'cs-header-nav-item-disabled' : '',
      hasDropdown ? 'cs-header-nav-item-dropdown' : '',
      isDropdownOpen ? 'cs-header-nav-item-dropdown-open' : '',
      itemClassName
    ].filter(Boolean).join(' ');
    
    // Render item content
    const itemContent = (
      <>
        {icon && <span className="cs-header-nav-item-icon">{icon}</span>}
        <span className="cs-header-nav-item-label">{label}</span>
        {badge && <span className="cs-header-nav-item-badge">{badge}</span>}
        {hasDropdown && (
          <span className="cs-header-nav-item-arrow">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </span>
        )}
      </>
    );
    
    // Render dropdown
    const dropdown = hasDropdown ? (
      <div
        className={`cs-header-dropdown ${isDropdownOpen ? 'cs-header-dropdown-open' : ''}`}
        ref={(el) => setDropdownRef(el, key)}
      >
        <ul className="cs-header-dropdown-menu">
          {children?.map((childItem) => (
            <li
              key={childItem.key}
              className={`cs-header-dropdown-item ${childItem.active ? 'cs-header-dropdown-item-active' : ''} ${
                childItem.disabled ? 'cs-header-dropdown-item-disabled' : ''
              }`}
              onClick={() => !childItem.disabled && handleNavItemClick(childItem)}
            >
              {childItem.icon && <span className="cs-header-dropdown-item-icon">{childItem.icon}</span>}
              <span className="cs-header-dropdown-item-label">{childItem.label}</span>
              {childItem.badge && <span className="cs-header-dropdown-item-badge">{childItem.badge}</span>}
            </li>
          ))}
        </ul>
      </div>
    ) : null;
    
    // Return list item
    return (
      <li
        key={key}
        className={itemClassNames}
        style={itemStyle}
        onClick={() => (hasDropdown ? handleToggleDropdown(key) : handleNavItemClick(item))}
      >
        {url ? (
          <a
            href={url}
            className="cs-header-nav-item-link"
            target={item.target}
            onClick={(e) => {
              // Prevent default if dropdown or disabled
              if (hasDropdown || disabled) {
                e.preventDefault();
              }
            }}
          >
            {itemContent}
          </a>
        ) : (
          <div className="cs-header-nav-item-content">{itemContent}</div>
        )}
        {dropdown}
      </li>
    );
  };
  
  // Render navigation
  const renderNavigation = () => {
    if (navigation.length === 0) return null;
    
    return (
      <nav className="cs-header-nav">
        <ul className="cs-header-nav-list">
          {navigation.map((item) => renderNavItem(item))}
        </ul>
      </nav>
    );
  };
  
  // Render mobile navigation
  const renderMobileNavigation = () => {
    if (mobileNavigation) {
      return mobileNavigation;
    }
    
    return (
      <div className={`cs-header-mobile-nav ${isCollapsed ? 'cs-header-mobile-nav-collapsed' : ''}`}>
        <nav className="cs-header-nav cs-header-nav-mobile">
          <ul className="cs-header-nav-list cs-header-nav-list-mobile">
            {navigation.map((item) => renderNavItem(item))}
          </ul>
        </nav>
        {showSearch && (
          <div className="cs-header-search cs-header-search-mobile">
            {renderSearch()}
          </div>
        )}
      </div>
    );
  };
  
  // Render action
  const renderAction = (action: HeaderAction) => {
    const {
      key,
      icon,
      label,
      tooltip,
      active,
      disabled,
      badge,
      className: actionClassName = '',
      style: actionStyle
    } = action;
    
    const actionClassNames = [
      'cs-header-action',
      active ? 'cs-header-action-active' : '',
      disabled ? 'cs-header-action-disabled' : '',
      actionClassName
    ].filter(Boolean).join(' ');
    
    return (
      <div
        key={key}
        className={actionClassNames}
        style={actionStyle}
        onClick={() => !disabled && handleActionClick(action)}
        title={tooltip || label}
      >
        <span className="cs-header-action-icon">{icon}</span>
        {label && <span className="cs-header-action-label">{label}</span>}
        {badge && <span className="cs-header-action-badge">{badge}</span>}
      </div>
    );
  };
  
  // Render actions
  const renderActions = () => {
    if (actions.length === 0) return null;
    
    return (
      <div className="cs-header-actions">
        {actions.map((action) => renderAction(action))}
      </div>
    );
  };
  
  // Render user menu
  const renderUserMenu = () => {
    if (!avatar && !userName && userMenu.length === 0) return null;
    
    return (
      <div className="cs-header-user" ref={userMenuRef}>
        <div
          className={`cs-header-user-trigger ${isUserMenuOpen ? 'cs-header-user-trigger-active' : ''}`}
          onClick={handleToggleUserMenu}
        >
          {avatar && <div className="cs-header-user-avatar">{avatar}</div>}
          {userName && <div className="cs-header-user-name">{userName}</div>}
          <span className="cs-header-user-arrow">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </span>
        </div>
        
        {isUserMenuOpen && (
          <div className="cs-header-user-menu">
            <ul className="cs-header-user-menu-list">
              {userMenu.map((item) => (
                <li
                  key={item.key}
                  className={`cs-header-user-menu-item ${item.active ? 'cs-header-user-menu-item-active' : ''} ${
                    item.disabled ? 'cs-header-user-menu-item-disabled' : ''
                  }`}
                  onClick={() => !item.disabled && handleNavItemClick(item)}
                >
                  {item.icon && <span className="cs-header-user-menu-item-icon">{item.icon}</span>}
                  <span className="cs-header-user-menu-item-label">{item.label}</span>
                  {item.badge && <span className="cs-header-user-menu-item-badge">{item.badge}</span>}
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    );
  };
  
  // Render search
  const renderSearch = () => {
    if (search) {
      return search;
    }
    
    return (
      <form className="cs-header-search-form" onSubmit={handleSearchSubmit}>
        <input
          type="text"
          className="cs-header-search-input"
          placeholder={searchPlaceholder}
          value={searchValue}
          onChange={handleSearchChange}
        />
        <button type="submit" className="cs-header-search-button">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <circle cx="11" cy="11" r="8"></circle>
            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          </svg>
        </button>
      </form>
    );
  };
  
  // Render hamburger menu
  const renderHamburgerMenu = () => {
    if (!hamburger || !isMobileView) return null;
    
    return (
      <div
        className={`cs-header-hamburger ${!isCollapsed ? 'cs-header-hamburger-active' : ''}`}
        onClick={handleToggleCollapse}
      >
        {!isCollapsed && closeIcon ? (
          closeIcon
        ) : isCollapsed && hamburgerIcon ? (
          hamburgerIcon
        ) : (
          <div className="cs-header-hamburger-icon">
            <span className="cs-header-hamburger-line"></span>
            <span className="cs-header-hamburger-line"></span>
            <span className="cs-header-hamburger-line"></span>
          </div>
        )}
      </div>
    );
  };
  
  // Render left section
  const renderLeft = () => {
    if (left) {
      return left;
    }
    
    return (
      <>
        {renderLogo()}
        {!isMobileView && renderNavigation()}
      </>
    );
  };
  
  // Render center section
  const renderCenter = () => {
    if (center) {
      return center;
    }
    
    return (
      <>
        {!isMobileView && showSearch && renderSearch()}
      </>
    );
  };
  
  // Render right section
  const renderRight = () => {
    if (right) {
      return right;
    }
    
    return (
      <>
        {!isMobileView && renderActions()}
        {renderUserMenu()}
        {renderHamburgerMenu()}
      </>
    );
  };
  
  // Build header class names
  const headerClassNames = [
    'cs-header',
    `cs-header-${size}`,
    `cs-header-${type}`,
    fixed ? 'cs-header-fixed' : '',
    bordered ? 'cs-header-bordered' : '',
    shadow ? 'cs-header-shadow' : '',
    compact ? 'cs-header-compact' : '',
    isMobileView ? 'cs-header-mobile' : '',
    className
  ].filter(Boolean).join(' ');
  
  // Render component
  return (
    <header ref={headerRef} className={headerClassNames} style={style}>
      <div className="cs-header-inner">
        <div className="cs-header-left">{renderLeft()}</div>
        <div className="cs-header-center">{renderCenter()}</div>
        <div className="cs-header-right">{renderRight()}</div>
      </div>
      
      {isMobileView && renderMobileNavigation()}
      
      {children && <div className="cs-header-content">{children}</div>}
    </header>
  );
};

export default Header;

/**
 * Header.scss
 * 
 * Styles for the custom header component for the CSTestForge framework.
 */

// Primary brand color
$primary-color: #C54B8C;

// Derived colors using color theory
$primary-light: lighten($primary-color, 20%);
$primary-lighter: lighten($primary-color, 35%);
$primary-dark: darken($primary-color, 10%);
$primary-darker: darken($primary-color, 20%);
$primary-alpha: rgba($primary-color, 0.2);
$primary-alpha-medium: rgba($primary-color, 0.5);

// Grays
$gray-100: #f8f9fa;
$gray-200: #e9ecef;
$gray-300: #dee2e6;
$gray-400: #ced4da;
$gray-500: #adb5bd;
$gray-600: #6c757d;
$gray-700: #495057;
$gray-800: #343a40;
$gray-900: #212529;

// Other colors
$white: #fff;
$black: #000;
$success: #28a745;
$info: #17a2b8;
$warning: #ffc107;
$danger: #dc3545;

// Typography
$font-family: 'Helvetica Neue', Arial, sans-serif;
$font-size-base: 14px;
$line-height-base: 1.5;

// Spacing
$spacer: 8px;

// Border radius
$border-radius: 4px;

// Transitions
$transition-base: all 0.2s ease-in-out;

// Z-index
$z-index-header: 1000;
$z-index-dropdown: 1050;

// Mobile breakpoint
$mobile-breakpoint: 768px;

// Header heights
$header-height-small: 48px;
$header-height-default: 64px;
$header-height-large: 80px;

// Base Header styles
.cs-header {
  position: relative;
  display: flex;
  flex-direction: column;
  width: 100%;
  background-color: $white;
  color: $gray-900;
  font-family: $font-family;
  font-size: $font-size-base;
  line-height: $line-height-base;
  box-sizing: border-box;
  z-index: $z-index-header;
  
  &-fixed {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
  }
  
  &-bordered {
    border-bottom: 1px solid $gray-300;
  }
  
  &-shadow {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }
  
  &-inner {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
  }
  
  // Header content (optional section below header)
  &-content {
    width: 100%;
    border-top: 1px solid $gray-200;
  }
  
  // Size variants
  &-small {
    height: $header-height-small;
    
    .cs-header-title {
      font-size: 16px;
    }
    
    .cs-header-subtitle {
      font-size: 12px;
    }
    
    .cs-header-nav-item {
      font-size: 13px;
      padding: $spacer;
    }
    
    .cs-header-dropdown-item {
      padding: $spacer;
    }
    
    .cs-header-action {
      padding: $spacer;
    }
    
    .cs-header-search-input {
      height: 32px;
    }
  }
  
  &-default {
    height: $header-height-default;
    
    .cs-header-title {
      font-size: 18px;
    }
    
    .cs-header-subtitle {
      font-size: 13px;
    }
    
    .cs-header-nav-item {
      font-size: 14px;
      padding: $spacer $spacer * 1.5;
    }
    
    .cs-header-dropdown-item {
      padding: $spacer $spacer * 1.5;
    }
    
    .cs-header-action {
      padding: $spacer $spacer * 1.5;
    }
    
    .cs-header-search-input {
      height: 36px;
    }
  }
  
  &-large {
    height: $header-height-large;
    
    .cs-header-title {
      font-size: 20px;
    }
    
    .cs-header-subtitle {
      font-size: 14px;
    }
    
    .cs-header-nav-item {
      font-size: 15px;
      padding: $spacer * 1.5 $spacer * 2;
    }
    
    .cs-header-dropdown-item {
      padding: $spacer * 1.5 $spacer * 2;
    }
    
    .cs-header-action {
      padding: $spacer * 1.5 $spacer * 2;
    }
    
    .cs-header-search-input {
      height: 40px;
    }
  }
  
  // Type variants
  &-default {
    // Default styles already applied
  }
  
  &-primary {
    background-color: $primary-color;
    color: $white;
    
    .cs-header-nav-item {
      color: $white;
      
      &:hover {
        background-color: rgba($white, 0.1);
      }
      
      &-active {
        background-color: rgba($white, 0.2);
      }
    }
    
    .cs-header-action {
      color: $white;
      
      &:hover {
        background-color: rgba($white, 0.1);
      }
      
      &-active {
        background-color: rgba($white, 0.2);
      }
    }
    
    .cs-header-search-input {
      background-color: rgba($white, 0.2);
      color: $white;
      
      &::placeholder {
        color: rgba($white, 0.7);
      }
    }
    
    .cs-header-search-button {
      color: $white;
    }
    
    .cs-header-hamburger-line {
      background-color: $white;
    }
    
    &.cs-header-bordered {
      border-bottom-color: rgba($white, 0.2);
    }
  }
  
  &-transparent {
    background-color: transparent;
    
    &.cs-header-bordered {
      border-bottom-color: rgba($black, 0.1);
    }
  }
  
  &-dark {
    background-color: $gray-900;
    color: $white;
    
    .cs-header-nav-item {
      color: $white;
      
      &:hover {
        background-color: rgba($white, 0.1);
      }
      
      &-active {
        background-color: rgba($white, 0.2);
      }
    }
    
    .cs-header-action {
      color: $white;
      
      &:hover {
        background-color: rgba($white, 0.1);
      }
      
      &-active {
        background-color: rgba($white, 0.2);
      }
    }
    
    .cs-header-search-input {
      background-color: rgba($white, 0.2);
      color: $white;
      
      &::placeholder {
        color: rgba($white, 0.7);
      }
    }
    
    .cs-header-search-button {
      color: $white;
    }
    
    .cs-header-hamburger-line {
      background-color: $white;
    }
    
    &.cs-header-bordered {
      border-bottom-color: rgba($white, 0.2);
    }
  }
  
  &-light {
    background-color: $gray-100;
    
    &.cs-header-bordered {
      border-bottom-color: $gray-300;
    }
  }
  
  // Compact variant
  &-compact {
    .cs-header-logo {
      padding-left: $spacer;
    }
    
    .cs-header-nav-item {
      padding-left: $spacer;
      padding-right: $spacer;
    }
    
    .cs-header-action {
      padding-left: $spacer;
      padding-right: $spacer;
    }
  }
  
  // Left section
  &-left {
    display: flex;
    align-items: center;
    flex-shrink: 0;
  }
  
  // Center section
  &-center {
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
  }
  
  // Right section
  &-right {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    flex-shrink: 0;
  }
  
  // Logo
  &-logo {
    display: flex;
    align-items: center;
    padding: 0 $spacer * 1.5;
    
    &-link {
      display: flex;
      align-items: center;
      text-decoration: none;
      color: inherit;
    }
    
    &-image {
      display: flex;
      align-items: center;
      margin-right: $spacer;
    }
  }
  
  // Title and subtitle
  &-title {
    font-weight: 600;
  }
  
  &-subtitle {
    color: $gray-600;
    margin-top: $spacer / 4;
  }
  
  // Navigation
  &-nav {
    display: flex;
    
    &-list {
      display: flex;
      list-style: none;
      margin: 0;
      padding: 0;
    }
    
    &-item {
      position: relative;
      display: flex;
      align-items: center;
      cursor: pointer;
      transition: $transition-base;
      
      &:hover {
        background-color: $gray-100;
      }
      
      &-active {
        color: $primary-color;
        
        &::after {
          content: '';
          position: absolute;
          bottom: 0;
          left: 15%;
          width: 70%;
          height: 2px;
          background-color: $primary-color;
        }
      }
      
      &-disabled {
        opacity: 0.5;
        cursor: not-allowed;
        
        &:hover {
          background-color: transparent;
        }
      }
      
      &-link {
        display: flex;
        align-items: center;
        color: inherit;
        text-decoration: none;
        height: 100%;
        width: 100%;
      }
      
      &-content {
        display: flex;
        align-items: center;
        height: 100%;
        width: 100%;
      }
      
      &-icon {
        display: flex;
        align-items: center;
        margin-right: $spacer / 2;
      }
      
      &-label {
        white-space: nowrap;
      }
      
      &-badge {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-left: $spacer / 2;
        padding: 0 $spacer / 2;
        min-width: 18px;
        height: 18px;
        border-radius: 9px;
        background-color: $primary-color;
        color: $white;
        font-size: 12px;
        font-weight: 600;
        line-height: 1;
      }
      
      &-arrow {
        display: flex;
        align-items: center;
        margin-left: $spacer / 2;
        transition: transform 0.2s;
      }
      
      &-dropdown-open {
        .cs-header-nav-item-arrow {
          transform: rotate(180deg);
        }
      }
    }
  }
  
  // Dropdown
  &-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    min-width: 160px;
    background-color: $white;
    border: 1px solid $gray-200;
    border-radius: $border-radius;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: $z-index-dropdown;
    
    &-menu {
      list-style: none;
      margin: 0;
      padding: $spacer / 2 0;
    }
    
    &-item {
      display: flex;
      align-items: center;
      cursor: pointer;
      transition: $transition-base;
      white-space: nowrap;
      
      &:hover {
        background-color: $gray-100;
      }
      
      &-active {
        color: $primary-color;
        background-color: $primary-alpha;
      }
      
      &-disabled {
        opacity: 0.5;
        cursor: not-allowed;
        
        &:hover {
          background-color: transparent;
        }
      }
      
      &-icon {
        display: flex;
        align-items: center;
        margin-right: $spacer / 2;
      }
      
      &-badge {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-left: $spacer / 2;
        padding: 0 $spacer / 2;
        min-width: 18px;
        height: 18px;
        border-radius: 9px;
        background-color: $primary-color;
        color: $white;
        font-size: 12px;
        font-weight: 600;
        line-height: 1;
      }
    }
  }
  
  // Actions
  &-actions {
    display: flex;
    align-items: center;
  }
  
  &-action {
    display: flex;
    align-items: center;
    cursor: pointer;
    transition: $transition-base;
    
    &:hover {
      background-color: $gray-100;
    }
    
    &-active {
      color: $primary-color;
    }
    
    &-disabled {
      opacity: 0.5;
      cursor: not-allowed;
      
      &:hover {
        background-color: transparent;
      }
    }
    
    &-icon {
      display: flex;
      align-items: center;
    }
    
    &-label {
      margin-left: $spacer / 2;
      white-space: nowrap;
    }
    
    &-badge {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: $spacer / 2;
      padding: 0 $spacer / 2;
      min-width: 18px;
      height: 18px;
      border-radius: 9px;
      background-color: $primary-color;
      color: $white;
      font-size: 12px;
      font-weight: 600;
      line-height: 1;
    }
  }
  
  // User menu
  &-user {
    position: relative;
    display: flex;
    align-items: center;
    padding: 0 $spacer * 1.5;
    
    &-trigger {
      display: flex;
      align-items: center;
      cursor: pointer;
      
      &-active {
        .cs-header-user-arrow {
          transform: rotate(180deg);
        }
      }
    }
    
    &-avatar {
      display: flex;
      align-items: center;
      margin-right: $spacer;
    }
    
    &-name {
      margin-right: $spacer / 2;
      font-weight: 500;
    }
    
    &-arrow {
      display: flex;
      align-items: center;
      transition: transform 0.2s;
    }
    
    &-menu {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 160px;
      background-color: $white;
      border: 1px solid $gray-200;
      border-radius: $border-radius;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: $z-index-dropdown;
      
      &-list {
        list-style: none;
        margin: 0;
        padding: $spacer / 2 0;
      }
      
      &-item {
        display: flex;
        align-items: center;
        padding: $spacer $spacer * 1.5;
        cursor: pointer;
        transition: $transition-base;
        
        &:hover {
          background-color: $gray-100;
        }
        
        &-active {
          color: $primary-color;
          background-color: $primary-alpha;
        }
        
        &-disabled {
          opacity: 0.5;
          cursor: not-allowed;
          
          &:hover {
            background-color: transparent;
          }
        }
        
        &-icon {
          display: flex;
          align-items: center;
          margin-right: $spacer;
        }
        
        &-badge {
          display: flex;
          align-items: center;
          justify-content: center;
          margin-left: $spacer;
          padding: 0 $spacer / 2;
          min-width: 18px;
          height: 18px;
          border-radius: 9px;
          background-color: $primary-color;
          color: $white;
          font-size: 12px;
          font-weight: 600;
          line-height: 1;
        }
      }
    }
  }
  
  // Search
  &-search {
    padding: 0 $spacer * 1.5;
    
    &-form {
      position: relative;
      display: flex;
      align-items: center;
    }
    
    &-input {
      width: 200px;
      padding: $spacer $spacer * 3 $spacer $spacer;
      border: 1px solid $gray-300;
      border-radius: $border-radius;
      font-family: $font-family;
      font-size: $font-size-base;
      color: $gray-900;
      transition: $transition-base;
      
      &:focus {
        outline: none;
        border-color: $primary-color;
        box-shadow: 0 0 0 2px $primary-alpha;
      }
      
      &::placeholder {
        color: $gray-500;
      }
    }
    
    &-button {
      position: absolute;
      right: $spacer;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      padding: 0;
      cursor: pointer;
      color: $gray-600;
      
      &:hover {
        color: $primary-color;
      }
      
      &:focus {
        outline: none;
      }
    }
  }
  
  // Hamburger menu
  &-hamburger {
    display: none;
    align-items: center;
    justify-content: center;
    padding: $spacer * 1.5;
    cursor: pointer;
    transition: $transition-base;
    
    &:hover {
      background-color: $gray-100;
    }
    
    &-icon {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      width: 24px;
      height: 18px;
    }
    
    &-line {
      width: 100%;
      height: 2px;
      background-color: $gray-900;
      transition: $transition-base;
    }
    
    &-active {
      .cs-header-hamburger-line {
        &:nth-child(1) {
          transform: translateY(8px) rotate(45deg);
        }
        
        &:nth-child(2) {
          opacity: 0;
        }
        
        &:nth-child(3) {
          transform: translateY(-8px) rotate(-45deg);
        }
      }
    }
  }
  
  // Mobile navigation
  &-mobile-nav {
    display: none;
    flex-direction: column;
    background-color: $white;
    border-top: 1px solid $gray-200;
    padding: $spacer 0;
    
    &-collapsed {
      display: none;
    }
  }
  
  // Mobile styles
  &-mobile {
    .cs-header-hamburger {
      display: flex;
    }
    
    .cs-header-mobile-nav {
      display: flex;
    }
    
    .cs-header-nav {
      &-mobile {
        width: 100%;
      }
      
      &-list-mobile {
        flex-direction: column;
        width: 100%;
      }
      
      &-item {
        width: 100%;
        
        &-active::after {
          display: none;
        }
      }
    }
    
    .cs-header-dropdown {
      position: static;
      width: 100%;
      border: none;
      box-shadow: none;
      background-color: $gray-100;
      
      &-item {
        padding-left: $spacer * 3;
      }
    }
    
    .cs-header-search {
      &-mobile {
        width: 100%;
        padding: $spacer * 1.5;
      }
      
      &-input {
        width: 100%;
      }
    }
  }
}

// RTL support
[dir="rtl"] .cs-header {
  &-logo {
    &-image {
      margin-right: 0;
      margin-left: $spacer;
    }
  }
  
  &-nav-item {
    &-icon {
      margin-right: 0;
      margin-left: $spacer / 2;
    }
    
    &-badge {
      margin-left: 0;
      margin-right: $spacer / 2;
    }
    
    &-arrow {
      margin-left: 0;
      margin-right: $spacer / 2;
    }
    
    &-active::after {
      left: auto;
      right: 15%;
    }
  }
  
  &-dropdown {
    left: auto;
    right: 0;
    
    &-item-icon {
      margin-right: 0;
      margin-left: $spacer / 2;
    }
    
    &-item-badge {
      margin-left: 0;
      margin-right: $spacer / 2;
    }
  }
  
  &-action {
    &-label {
      margin-left: 0;
      margin-right: $spacer / 2;
    }
    
    &-badge {
      margin-left: 0;
      margin-right: $spacer / 2;
    }
  }
  
  &-user {
    &-avatar {
      margin-right: 0;
      margin-left: $spacer;
    }
    
    &-name {
      margin-right: 0;
      margin-left: $spacer / 2;
    }
    
    &-menu {
      right: auto;
      left: 0;
    }
    
    &-menu-item-icon {
      margin-right: 0;
      margin-left: $spacer;
    }
    
    &-menu-item-badge {
      margin-left: 0;
      margin-right: $spacer;
    }
  }
  
  &-search {
    &-button {
      right: auto;
      left: $spacer;
    }
    
    &-input {
      padding: $spacer $spacer $spacer $spacer * 3;
    }
  }
  
  &-mobile {
    .cs-header-dropdown-item {
      padding-left: $spacer * 1.5;
      padding-right: $spacer * 3;
    }
  }
}

// Dark mode support
.cs-header-dark {
  background-color: $gray-900;
  color: $white;
  
  .cs-header-bordered {
    border-bottom-color: $gray-700;
  }
  
  .cs-header-subtitle {
    color: $gray-400;
  }
  
  .cs-header-nav-item {
    &:hover {
      background-color: $gray-800;
    }
    
    &-active {
      color: $primary-light;
      
      &::after {
        background-color: $primary-light;
      }
    }
  }
  
  .cs-header-dropdown {
    background-color: $gray-800;
    border-color: $gray-700;
    
    &-item:hover {
      background-color: $gray-700;
    }
  }
  
  .cs-header-action:hover {
    background-color: $gray-800;
  }
  
  .cs-header-user-menu {
    background-color: $gray-800;
    border-color: $gray-700;
    
    &-item:hover {
      background-color: $gray-700;
    }
  }
  
  .cs-header-search-input {
    background-color: $gray-800;
    border-color: $gray-700;
    color: $white;
    
    &::placeholder {
      color: $gray-500;
    }
    
    &:focus {
      border-color: $primary-light;
      box-shadow: 0 0 0 2px rgba($primary-light, 0.3);
    }
  }
  
  .cs-header-search-button {
    color: $gray-400;
    
    &:hover {
      color: $primary-light;
    }
  }
  
  .cs-header-hamburger:hover {
    background-color: $gray-800;
  }
  
  .cs-header-hamburger-line {
    background-color: $white;
  }
  
  .cs-header-mobile-nav {
    background-color: $gray-900;
    border-top-color: $gray-700;
  }
}

// Print styles
@media print {
  .cs-header {
    display: none !important;
  }
}

// Animation for mobile menu
@keyframes cs-header-mobile-nav-slide-down {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

// Animate mobile nav
.cs-header-mobile-nav:not(.cs-header-mobile-nav-collapsed) {
  animation: cs-header-mobile-nav-slide-down 0.3s ease forwards;
}

// High contrast mode
.cs-header-high-contrast {
  border-bottom-width: 2px;
  
  .cs-header-nav-item-active::after {
    height: 3px;
  }
  
  .cs-header-search-input {
    border-width: 2px;
  }
  
  .cs-header-dropdown, .cs-header-user-menu {
    border-width: 2px;
  }
}

// Reduced motion support
@media (prefers-reduced-motion: reduce) {
  .cs-header {
    * {
      transition: none !important;
      animation: none !important;
    }
  }
}


