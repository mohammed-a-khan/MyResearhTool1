
templates/projects/selenium/java/testng/src/test/pages/BasePage.java.template
----------------------------------------------------------------------------------------------

package ${package}.pages;

import java.time.Duration;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.FluentWait;
import org.openqa.selenium.support.ui.Select;
import org.openqa.selenium.support.ui.Wait;
import org.openqa.selenium.support.ui.WebDriverWait;

import ${package}.core.config.ConfigurationManager;
import ${package}.core.reporting.CSReporter;
import ${package}.core.utils.CSConstants;
import ${package}.core.utils.CSLogger;
import ${package}.core.utils.CSScreenshotManager;
import ${package}.selenium.java.testng.annotations.CSFindBy;
import ${package}.selenium.java.testng.browser.BrowserManager;
import ${package}.selenium.java.testng.wait.CSVisibilityWait;
import ${package}.selenium.java.testng.wait.CSClickableWait;
import ${package}.selenium.java.testng.wait.CSWaitFactory;
import ${package}.selenium.java.testng.wait.CSWaitStrategy;
import ${package}.core.ai.SmartLocatorService;
import ${package}.core.ai.SelfHealingLocatorService;

/**
 * Base Page Object class that provides common functionality for all page objects.
 * This class includes enhanced element interaction methods with built-in waiting,
 * reporting, and self-healing capabilities.
 */
public class BasePage {
    
    protected WebDriver driver;
    protected CSReporter reporter;
    protected SmartLocatorService smartLocatorService;
    protected SelfHealingLocatorService selfHealingLocatorService;
    protected CSScreenshotManager screenshotManager;
    protected int defaultTimeout;
    protected int pollingInterval;
    protected boolean autoHeal;
    
    /**
     * Constructor for BasePage
     */
    public BasePage() {
        this.driver = BrowserManager.getDriver();
        this.reporter = CSReporter.getInstance();
        this.smartLocatorService = SmartLocatorService.getInstance();
        this.selfHealingLocatorService = SelfHealingLocatorService.getInstance();
        this.screenshotManager = CSScreenshotManager.getInstance();
        this.defaultTimeout = ConfigurationManager.getInstance().getFrameworkConfig().getDefaultTimeoutInSeconds();
        this.pollingInterval = ConfigurationManager.getInstance().getFrameworkConfig().getPollingIntervalInMillis();
        this.autoHeal = ConfigurationManager.getInstance().getFrameworkConfig().isAutoHealEnabled();
        
        // Initialize elements using enhanced page factory with smart locator processing
        PageFactory.initElements(driver, this);
    }
    
    /**
     * Constructor for BasePage with custom driver
     * 
     * @param driver WebDriver instance
     */
    public BasePage(WebDriver driver) {
        this.driver = driver;
        this.reporter = CSReporter.getInstance();
        this.smartLocatorService = SmartLocatorService.getInstance();
        this.selfHealingLocatorService = SelfHealingLocatorService.getInstance();
        this.screenshotManager = CSScreenshotManager.getInstance();
        this.defaultTimeout = ConfigurationManager.getInstance().getFrameworkConfig().getDefaultTimeoutInSeconds();
        this.pollingInterval = ConfigurationManager.getInstance().getFrameworkConfig().getPollingIntervalInMillis();
        this.autoHeal = ConfigurationManager.getInstance().getFrameworkConfig().isAutoHealEnabled();
        
        // Initialize elements using enhanced page factory with smart locator processing
        PageFactory.initElements(driver, this);
    }
    
    /**
     * Waits for the page to load completely
     * 
     * @return this page object instance
     */
    public BasePage waitForPageLoad() {
        new WebDriverWait(driver, Duration.ofSeconds(defaultTimeout)).until(
            driver -> ((JavascriptExecutor) driver).executeScript("return document.readyState").equals("complete"));
        return this;
    }
    
    /**
     * Waits for an element to be visible on the page
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return the WebElement once it is visible
     */
    protected WebElement waitForVisibility(By locator, int timeoutInSeconds) {
        CSWaitStrategy waitStrategy = CSWaitFactory.getInstance().createWaitStrategy(CSVisibilityWait.class);
        try {
            return waitStrategy.waitForElement(driver, locator, timeoutInSeconds);
        } catch (TimeoutException e) {
            if (autoHeal) {
                By healedLocator = selfHealingLocatorService.healLocator(driver, locator);
                if (healedLocator != null && !healedLocator.equals(locator)) {
                    CSLogger.info("Self-healed locator from " + locator + " to " + healedLocator);
                    reporter.logInfo("Self-healed locator", "Original: " + locator + " → Healed: " + healedLocator);
                    return waitStrategy.waitForElement(driver, healedLocator, timeoutInSeconds);
                }
            }
            screenshotManager.captureScreenshot(driver, "waitForVisibilityFailed");
            reporter.logFailure("Element not visible", "Element with locator " + locator + " not visible after " + timeoutInSeconds + " seconds");
            throw e;
        }
    }
    
    /**
     * Waits for an element to be clickable on the page
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return the WebElement once it is clickable
     */
    protected WebElement waitForClickability(By locator, int timeoutInSeconds) {
        CSWaitStrategy waitStrategy = CSWaitFactory.getInstance().createWaitStrategy(CSClickableWait.class);
        try {
            return waitStrategy.waitForElement(driver, locator, timeoutInSeconds);
        } catch (TimeoutException e) {
            if (autoHeal) {
                By healedLocator = selfHealingLocatorService.healLocator(driver, locator);
                if (healedLocator != null && !healedLocator.equals(locator)) {
                    CSLogger.info("Self-healed locator from " + locator + " to " + healedLocator);
                    reporter.logInfo("Self-healed locator", "Original: " + locator + " → Healed: " + healedLocator);
                    return waitStrategy.waitForElement(driver, healedLocator, timeoutInSeconds);
                }
            }
            screenshotManager.captureScreenshot(driver, "waitForClickabilityFailed");
            reporter.logFailure("Element not clickable", "Element with locator " + locator + " not clickable after " + timeoutInSeconds + " seconds");
            throw e;
        }
    }
    
    /**
     * Clicks an element with built-in waiting, reporting, and self-healing
     * 
     * @param locator the element locator
     * @return this page object instance
     */
    public BasePage click(By locator) {
        return click(locator, defaultTimeout);
    }
    
    /**
     * Clicks an element with custom timeout and built-in waiting, reporting, and self-healing
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage click(By locator, int timeoutInSeconds) {
        try {
            WebElement element = waitForClickability(locator, timeoutInSeconds);
            String elementText = element.getText().isEmpty() ? element.getAttribute("name") : element.getText();
            elementText = elementText.isEmpty() ? locator.toString() : elementText;
            element.click();
            reporter.logInfo("Click", "Clicked on element: " + elementText);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "clickFailed");
            reporter.logFailure("Click failed", "Failed to click on element with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to click on element with locator " + locator, e);
        }
    }
    
    /**
     * Types text into an input field with built-in waiting, reporting, and self-healing
     * 
     * @param locator the element locator
     * @param text the text to type
     * @return this page object instance
     */
    public BasePage type(By locator, String text) {
        return type(locator, text, defaultTimeout);
    }
    
    /**
     * Types text into an input field with custom timeout and built-in waiting, reporting, and self-healing
     * 
     * @param locator the element locator
     * @param text the text to type
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage type(By locator, String text, int timeoutInSeconds) {
        try {
            WebElement element = waitForVisibility(locator, timeoutInSeconds);
            element.clear();
            element.sendKeys(text);
            reporter.logInfo("Type", "Typed '" + text + "' in element: " + locator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "typeFailed");
            reporter.logFailure("Type failed", "Failed to type '" + text + "' in element with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to type in element with locator " + locator, e);
        }
    }
    
    /**
     * Selects an option from a dropdown by visible text
     * 
     * @param locator the element locator
     * @param visibleText the visible text to select
     * @return this page object instance
     */
    public BasePage selectByVisibleText(By locator, String visibleText) {
        return selectByVisibleText(locator, visibleText, defaultTimeout);
    }
    
    /**
     * Selects an option from a dropdown by visible text with custom timeout
     * 
     * @param locator the element locator
     * @param visibleText the visible text to select
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage selectByVisibleText(By locator, String visibleText, int timeoutInSeconds) {
        try {
            WebElement element = waitForVisibility(locator, timeoutInSeconds);
            Select select = new Select(element);
            select.selectByVisibleText(visibleText);
            reporter.logInfo("Select", "Selected option '" + visibleText + "' from dropdown: " + locator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "selectFailed");
            reporter.logFailure("Select failed", "Failed to select '" + visibleText + "' from dropdown with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to select from dropdown with locator " + locator, e);
        }
    }
    
    /**
     * Checks if an element is displayed on the page
     * 
     * @param locator the element locator
     * @return true if the element is displayed, false otherwise
     */
    public boolean isDisplayed(By locator) {
        try {
            return driver.findElement(locator).isDisplayed();
        } catch (NoSuchElementException e) {
            return false;
        }
    }
    
    /**
     * Checks if an element is displayed on the page with timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return true if the element is displayed within the timeout, false otherwise
     */
    public boolean isDisplayed(By locator, int timeoutInSeconds) {
        try {
            Wait<WebDriver> wait = new FluentWait<>(driver)
                    .withTimeout(Duration.ofSeconds(timeoutInSeconds))
                    .pollingEvery(Duration.ofMillis(pollingInterval))
                    .ignoring(NoSuchElementException.class);
            
            return wait.until(driver -> {
                try {
                    return driver.findElement(locator).isDisplayed();
                } catch (NoSuchElementException e) {
                    return false;
                }
            });
        } catch (TimeoutException e) {
            return false;
        }
    }
    
    /**
     * Performs a hover action on an element
     * 
     * @param locator the element locator
     * @return this page object instance
     */
    public BasePage hover(By locator) {
        return hover(locator, defaultTimeout);
    }
    
    /**
     * Performs a hover action on an element with custom timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage hover(By locator, int timeoutInSeconds) {
        try {
            WebElement element = waitForVisibility(locator, timeoutInSeconds);
            Actions actions = new Actions(driver);
            actions.moveToElement(element).perform();
            reporter.logInfo("Hover", "Hovered over element: " + locator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "hoverFailed");
            reporter.logFailure("Hover failed", "Failed to hover over element with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to hover over element with locator " + locator, e);
        }
    }
    
    /**
     * Gets the text of an element
     * 
     * @param locator the element locator
     * @return the text of the element
     */
    public String getText(By locator) {
        return getText(locator, defaultTimeout);
    }
    
    /**
     * Gets the text of an element with custom timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return the text of the element
     */
    public String getText(By locator, int timeoutInSeconds) {
        try {
            WebElement element = waitForVisibility(locator, timeoutInSeconds);
            String text = element.getText();
            reporter.logInfo("Get Text", "Retrieved text '" + text + "' from element: " + locator);
            return text;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "getTextFailed");
            reporter.logFailure("Get Text failed", "Failed to get text from element with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to get text from element with locator " + locator, e);
        }
    }
    
    /**
     * Gets the value of an attribute of an element
     * 
     * @param locator the element locator
     * @param attribute the attribute name
     * @return the attribute value
     */
    public String getAttribute(By locator, String attribute) {
        return getAttribute(locator, attribute, defaultTimeout);
    }
    
    /**
     * Gets the value of an attribute of an element with custom timeout
     * 
     * @param locator the element locator
     * @param attribute the attribute name
     * @param timeoutInSeconds timeout in seconds
     * @return the attribute value
     */
    public String getAttribute(By locator, String attribute, int timeoutInSeconds) {
        try {
            WebElement element = waitForVisibility(locator, timeoutInSeconds);
            String value = element.getAttribute(attribute);
            reporter.logInfo("Get Attribute", "Retrieved attribute '" + attribute + "' with value '" + value + "' from element: " + locator);
            return value;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "getAttributeFailed");
            reporter.logFailure("Get Attribute failed", "Failed to get attribute '" + attribute + "' from element with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to get attribute from element with locator " + locator, e);
        }
    }
    
    /**
     * Executes JavaScript on the page
     * 
     * @param script the JavaScript to execute
     * @param args the arguments to pass to the script
     * @return the result of the script execution
     */
    public Object executeScript(String script, Object... args) {
        try {
            JavascriptExecutor jsExecutor = (JavascriptExecutor) driver;
            Object result = jsExecutor.executeScript(script, args);
            reporter.logInfo("Execute Script", "Executed JavaScript: " + script);
            return result;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "executeScriptFailed");
            reporter.logFailure("Execute Script failed", "Failed to execute JavaScript: " + script + " - " + e.getMessage());
            throw new RuntimeException("Failed to execute JavaScript", e);
        }
    }
    
    /**
     * Waits for a custom condition with default timeout
     * 
     * @param <T> the expected return type
     * @param condition the condition to wait for
     * @return the result of the condition
     */
    public <T> T waitFor(ExpectedCondition<T> condition) {
        return waitFor(condition, defaultTimeout);
    }
    
    /**
     * Waits for a custom condition with custom timeout
     * 
     * @param <T> the expected return type
     * @param condition the condition to wait for
     * @param timeoutInSeconds timeout in seconds
     * @return the result of the condition
     */
    public <T> T waitFor(ExpectedCondition<T> condition, int timeoutInSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
            return wait.until(condition);
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "waitForConditionFailed");
            reporter.logFailure("Wait for condition failed", "Failed to wait for condition: " + e.getMessage());
            throw new RuntimeException("Failed to wait for condition", e);
        }
    }
    
    /**
     * Waits for text to be present in an element
     * 
     * @param locator the element locator
     * @param text the text to wait for
     * @return this page object instance
     */
    public BasePage waitForTextToBePresent(By locator, String text) {
        return waitForTextToBePresent(locator, text, defaultTimeout);
    }
    
    /**
     * Waits for text to be present in an element with custom timeout
     * 
     * @param locator the element locator
     * @param text the text to wait for
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage waitForTextToBePresent(By locator, String text, int timeoutInSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
            wait.until(ExpectedConditions.textToBePresentInElementLocated(locator, text));
            reporter.logInfo("Wait for Text", "Text '" + text + "' is present in element: " + locator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "waitForTextFailed");
            reporter.logFailure("Wait for Text failed", "Text '" + text + "' not present in element with locator " + locator + " after " + timeoutInSeconds + " seconds");
            throw new RuntimeException("Failed to wait for text in element with locator " + locator, e);
        }
    }
    
    /**
     * Finds all elements matching a locator
     * 
     * @param locator the element locator
     * @return list of matching WebElements
     */
    public List<WebElement> findElements(By locator) {
        return findElements(locator, defaultTimeout);
    }
    
    /**
     * Finds all elements matching a locator with custom timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return list of matching WebElements
     */
    public List<WebElement> findElements(By locator, int timeoutInSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
            wait.until(ExpectedConditions.presenceOfAllElementsLocatedBy(locator));
            List<WebElement> elements = driver.findElements(locator);
            reporter.logInfo("Find Elements", "Found " + elements.size() + " elements matching locator: " + locator);
            return elements;
        } catch (TimeoutException e) {
            if (autoHeal) {
                By healedLocator = selfHealingLocatorService.healLocator(driver, locator);
                if (healedLocator != null && !healedLocator.equals(locator)) {
                    CSLogger.info("Self-healed locator from " + locator + " to " + healedLocator);
                    reporter.logInfo("Self-healed locator", "Original: " + locator + " → Healed: " + healedLocator);
                    return findElements(healedLocator, timeoutInSeconds);
                }
            }
            reporter.logWarning("Find Elements", "No elements found matching locator: " + locator);
            return List.of();
        }
    }
    
    /**
     * Gets the text of all elements matching a locator
     * 
     * @param locator the element locator
     * @return list of element texts
     */
    public List<String> getElementsText(By locator) {
        return getElementsText(locator, defaultTimeout);
    }
    
    /**
     * Gets the text of all elements matching a locator with custom timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return list of element texts
     */
    public List<String> getElementsText(By locator, int timeoutInSeconds) {
        List<WebElement> elements = findElements(locator, timeoutInSeconds);
        List<String> texts = elements.stream()
                .map(WebElement::getText)
                .collect(Collectors.toList());
        reporter.logInfo("Get Elements Text", "Retrieved text from " + texts.size() + " elements matching locator: " + locator);
        return texts;
    }
    
    /**
     * Scrolls to an element
     * 
     * @param locator the element locator
     * @return this page object instance
     */
    public BasePage scrollToElement(By locator) {
        return scrollToElement(locator, defaultTimeout);
    }
    
    /**
     * Scrolls to an element with custom timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage scrollToElement(By locator, int timeoutInSeconds) {
        try {
            WebElement element = waitForVisibility(locator, timeoutInSeconds);
            executeScript("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", element);
            reporter.logInfo("Scroll", "Scrolled to element: " + locator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "scrollToElementFailed");
            reporter.logFailure("Scroll failed", "Failed to scroll to element with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to scroll to element with locator " + locator, e);
        }
    }
    
    /**
     * Takes a screenshot of the current page state
     * 
     * @param screenshotName the name for the screenshot
     * @return this page object instance
     */
    public BasePage takeScreenshot(String screenshotName) {
        try {
            String screenshotPath = screenshotManager.captureScreenshot(driver, screenshotName);
            reporter.logInfo("Screenshot", "Screenshot captured: " + screenshotPath);
            return this;
        } catch (Exception e) {
            reporter.logWarning("Screenshot failed", "Failed to capture screenshot: " + e.getMessage());
            return this;
        }
    }
    
    /**
     * Waits for an element to be present in the DOM
     * 
     * @param locator the element locator
     * @return the WebElement once it is present
     */
    protected WebElement waitForPresence(By locator) {
        return waitForPresence(locator, defaultTimeout);
    }
    
    /**
     * Waits for an element to be present in the DOM with custom timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return the WebElement once it is present
     */
    protected WebElement waitForPresence(By locator, int timeoutInSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
            return wait.until(ExpectedConditions.presenceOfElementLocated(locator));
        } catch (TimeoutException e) {
            if (autoHeal) {
                By healedLocator = selfHealingLocatorService.healLocator(driver, locator);
                if (healedLocator != null && !healedLocator.equals(locator)) {
                    CSLogger.info("Self-healed locator from " + locator + " to " + healedLocator);
                    reporter.logInfo("Self-healed locator", "Original: " + locator + " → Healed: " + healedLocator);
                    return waitForPresence(healedLocator, timeoutInSeconds);
                }
            }
            screenshotManager.captureScreenshot(driver, "waitForPresenceFailed");
            reporter.logFailure("Element not present", "Element with locator " + locator + " not present after " + timeoutInSeconds + " seconds");
            throw e;
        }
    }
    
    /**
     * Waits for an element to disappear from the page
     * 
     * @param locator the element locator
     * @return this page object instance
     */
    public BasePage waitForElementToDisappear(By locator) {
        return waitForElementToDisappear(locator, defaultTimeout);
    }
    
    /**
     * Waits for an element to disappear from the page with custom timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage waitForElementToDisappear(By locator, int timeoutInSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
            wait.until(ExpectedConditions.invisibilityOfElementLocated(locator));
            reporter.logInfo("Wait for Disappear", "Element with locator " + locator + " is no longer visible");
            return this;
        } catch (TimeoutException e) {
            screenshotManager.captureScreenshot(driver, "waitForDisappearFailed");
            reporter.logFailure("Element still visible", "Element with locator " + locator + " still visible after " + timeoutInSeconds + " seconds");
            throw new RuntimeException("Failed to wait for element to disappear with locator " + locator, e);
        }
    }
    
    /**
     * Navigates to a URL
     * 
     * @param url the URL to navigate to
     * @return this page object instance
     */
    public BasePage navigateTo(String url) {
        try {
            driver.get(url);
            reporter.logInfo("Navigate", "Navigated to URL: " + url);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "navigationFailed");
            reporter.logFailure("Navigation failed", "Failed to navigate to URL " + url + ": " + e.getMessage());
            throw new RuntimeException("Failed to navigate to URL " + url, e);
        }
    }
    
    /**
     * Refreshes the current page
     * 
     * @return this page object instance
     */
    public BasePage refreshPage() {
        try {
            driver.navigate().refresh();
            reporter.logInfo("Refresh", "Page refreshed");
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "refreshFailed");
            reporter.logFailure("Refresh failed", "Failed to refresh page: " + e.getMessage());
            throw new RuntimeException("Failed to refresh page", e);
        }
    }
    
    /**
     * Navigates back to the previous page
     * 
     * @return this page object instance
     */
    public BasePage navigateBack() {
        try {
            driver.navigate().back();
            reporter.logInfo("Navigate Back", "Navigated back to previous page");
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "navigateBackFailed");
            reporter.logFailure("Navigate Back failed", "Failed to navigate back: " + e.getMessage());
            throw new RuntimeException("Failed to navigate back", e);
        }
    }
    
    /**
     * Gets the current URL
     * 
     * @return the current URL
     */
    public String getCurrentUrl() {
        try {
            String url = driver.getCurrentUrl();
            reporter.logInfo("Get URL", "Current URL: " + url);
            return url;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "getCurrentUrlFailed");
            reporter.logFailure("Get URL failed", "Failed to get current URL: " + e.getMessage());
            throw new RuntimeException("Failed to get current URL", e);
        }
    }
    
    /**
     * Gets the current page title
     * 
     * @return the current page title
     */
    public String getTitle() {
        try {
            String title = driver.getTitle();
            reporter.logInfo("Get Title", "Current title: " + title);
            return title;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "getTitleFailed");
            reporter.logFailure("Get Title failed", "Failed to get page title: " + e.getMessage());
            throw new RuntimeException("Failed to get page title", e);
        }
    }
    
    /**
     * Custom wait method that polls for a condition to be met
     * 
     * @param <T> the expected return type
     * @param condition the function that checks the condition
     * @param timeoutInSeconds timeout in seconds
     * @return the result of the condition function
     */
    public <T> T customWait(Function<WebDriver, T> condition, int timeoutInSeconds) {
        try {
            Wait<WebDriver> wait = new FluentWait<>(driver)
                    .withTimeout(Duration.ofSeconds(timeoutInSeconds))
                    .pollingEvery(Duration.ofMillis(pollingInterval))
                    .ignoring(Exception.class);
            
            return wait.until(condition);
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "customWaitFailed");
            reporter.logFailure("Custom Wait failed", "Custom wait condition not met after " + timeoutInSeconds + " seconds: " + e.getMessage());
            throw new RuntimeException("Custom wait condition not met", e);
        }
    }
    
    /**
     * Checks if a page contains specific text
     * 
     * @param text the text to check for
     * @return true if the page contains the text, false otherwise
     */
    public boolean pageContainsText(String text) {
        try {
            return driver.getPageSource().contains(text);
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "pageContainsTextFailed");
            reporter.logFailure("Page Contains Text check failed", "Failed to check if page contains text '" + text + "': " + e.getMessage());
            throw new RuntimeException("Failed to check if page contains text", e);
        }
    }
    
    /**
     * Switches to a frame
     * 
     * @param locator the frame locator
     * @return this page object instance
     */
    public BasePage switchToFrame(By locator) {
        return switchToFrame(locator, defaultTimeout);
    }
    
    /**
     * Switches to a frame with custom timeout
     * 
     * @param locator the frame locator
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage switchToFrame(By locator, int timeoutInSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutInSeconds));
            wait.until(ExpectedConditions.frameToBeAvailableAndSwitchToIt(locator));
            reporter.logInfo("Switch Frame", "Switched to frame with locator: " + locator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "switchToFrameFailed");
            reporter.logFailure("Switch Frame failed", "Failed to switch to frame with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to switch to frame with locator " + locator, e);
        }
    }
    
    /**
     * Switches back to the default content (main document)
     * 
     * @return this page object instance
     */
    public BasePage switchToDefaultContent() {
        try {
            driver.switchTo().defaultContent();
            reporter.logInfo("Switch Default", "Switched to default content");
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "switchToDefaultContentFailed");
            reporter.logFailure("Switch Default failed", "Failed to switch to default content: " + e.getMessage());
            throw new RuntimeException("Failed to switch to default content", e);
        }
    }
    
    /**
     * Performs a double-click action on an element
     * 
     * @param locator the element locator
     * @return this page object instance
     */
    public BasePage doubleClick(By locator) {
        return doubleClick(locator, defaultTimeout);
    }
    
    /**
     * Performs a double-click action on an element with custom timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage doubleClick(By locator, int timeoutInSeconds) {
        try {
            WebElement element = waitForClickability(locator, timeoutInSeconds);
            Actions actions = new Actions(driver);
            actions.doubleClick(element).perform();
            reporter.logInfo("Double Click", "Double-clicked on element: " + locator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "doubleClickFailed");
            reporter.logFailure("Double Click failed", "Failed to double-click on element with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to double-click on element with locator " + locator, e);
        }
    }
    
    /**
     * Performs a right-click action on an element
     * 
     * @param locator the element locator
     * @return this page object instance
     */
    public BasePage rightClick(By locator) {
        return rightClick(locator, defaultTimeout);
    }
    
    /**
     * Performs a right-click action on an element with custom timeout
     * 
     * @param locator the element locator
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage rightClick(By locator, int timeoutInSeconds) {
        try {
            WebElement element = waitForClickability(locator, timeoutInSeconds);
            Actions actions = new Actions(driver);
            actions.contextClick(element).perform();
            reporter.logInfo("Right Click", "Right-clicked on element: " + locator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "rightClickFailed");
            reporter.logFailure("Right Click failed", "Failed to right-click on element with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to right-click on element with locator " + locator, e);
        }
    }
    
    /**
     * Performs a drag-and-drop action from one element to another
     * 
     * @param sourceLocator the source element locator
     * @param targetLocator the target element locator
     * @return this page object instance
     */
    public BasePage dragAndDrop(By sourceLocator, By targetLocator) {
        return dragAndDrop(sourceLocator, targetLocator, defaultTimeout);
    }
    
    /**
     * Performs a drag-and-drop action from one element to another with custom timeout
     * 
     * @param sourceLocator the source element locator
     * @param targetLocator the target element locator
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage dragAndDrop(By sourceLocator, By targetLocator, int timeoutInSeconds) {
        try {
            WebElement sourceElement = waitForClickability(sourceLocator, timeoutInSeconds);
            WebElement targetElement = waitForVisibility(targetLocator, timeoutInSeconds);
            
            Actions actions = new Actions(driver);
            actions.dragAndDrop(sourceElement, targetElement).perform();
            
            reporter.logInfo("Drag and Drop", "Dragged element with locator " + sourceLocator + " to element with locator " + targetLocator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "dragAndDropFailed");
            reporter.logFailure("Drag and Drop failed", "Failed to drag element with locator " + sourceLocator + " to element with locator " + targetLocator + ": " + e.getMessage());
            throw new RuntimeException("Failed to perform drag and drop", e);
        }
    }
    
    /**
     * Uploads a file to a file input element
     * 
     * @param locator the file input element locator
     * @param filePath the absolute path of the file to upload
     * @return this page object instance
     */
    public BasePage uploadFile(By locator, String filePath) {
        return uploadFile(locator, filePath, defaultTimeout);
    }
    
    /**
     * Uploads a file to a file input element with custom timeout
     * 
     * @param locator the file input element locator
     * @param filePath the absolute path of the file to upload
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage uploadFile(By locator, String filePath, int timeoutInSeconds) {
        try {
            WebElement fileInput = waitForPresence(locator, timeoutInSeconds);
            fileInput.sendKeys(filePath);
            reporter.logInfo("Upload File", "Uploaded file " + filePath + " to element with locator " + locator);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "uploadFileFailed");
            reporter.logFailure("Upload File failed", "Failed to upload file " + filePath + " to element with locator " + locator + ": " + e.getMessage());
            throw new RuntimeException("Failed to upload file", e);
        }
    }
    
    /**
     * Accepts a JavaScript alert
     * 
     * @return this page object instance
     */
    public BasePage acceptAlert() {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(defaultTimeout));
            wait.until(ExpectedConditions.alertIsPresent());
            driver.switchTo().alert().accept();
            reporter.logInfo("Alert", "Accepted alert");
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "acceptAlertFailed");
            reporter.logFailure("Accept Alert failed", "Failed to accept alert: " + e.getMessage());
            throw new RuntimeException("Failed to accept alert", e);
        }
    }
    
    /**
     * Dismisses a JavaScript alert
     * 
     * @return this page object instance
     */
    public BasePage dismissAlert() {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(defaultTimeout));
            wait.until(ExpectedConditions.alertIsPresent());
            driver.switchTo().alert().dismiss();
            reporter.logInfo("Alert", "Dismissed alert");
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "dismissAlertFailed");
            reporter.logFailure("Dismiss Alert failed", "Failed to dismiss alert: " + e.getMessage());
            throw new RuntimeException("Failed to dismiss alert", e);
        }
    }
    
    /**
     * Gets the text from a JavaScript alert
     * 
     * @return the alert text
     */
    public String getAlertText() {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(defaultTimeout));
            wait.until(ExpectedConditions.alertIsPresent());
            String text = driver.switchTo().alert().getText();
            reporter.logInfo("Alert", "Got alert text: " + text);
            return text;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "getAlertTextFailed");
            reporter.logFailure("Get Alert Text failed", "Failed to get alert text: " + e.getMessage());
            throw new RuntimeException("Failed to get alert text", e);
        }
    }
    
    /**
     * Sends text to a JavaScript prompt
     * 
     * @param text the text to send
     * @return this page object instance
     */
    public BasePage sendKeysToAlert(String text) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(defaultTimeout));
            wait.until(ExpectedConditions.alertIsPresent());
            driver.switchTo().alert().sendKeys(text);
            reporter.logInfo("Alert", "Sent text to alert: " + text);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "sendKeysToAlertFailed");
            reporter.logFailure("Send Keys to Alert failed", "Failed to send text to alert: " + e.getMessage());
            throw new RuntimeException("Failed to send text to alert", e);
        }
    }
    
    /**
     * Switches to a window by title
     * 
     * @param title the window title
     * @return this page object instance
     */
    public BasePage switchToWindowByTitle(String title) {
        return switchToWindowByTitle(title, defaultTimeout);
    }
    
    /**
     * Switches to a window by title with custom timeout
     * 
     * @param title the window title
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage switchToWindowByTitle(String title, int timeoutInSeconds) {
        try {
            String originalHandle = driver.getWindowHandle();
            Wait<WebDriver> wait = new FluentWait<>(driver)
                    .withTimeout(Duration.ofSeconds(timeoutInSeconds))
                    .pollingEvery(Duration.ofMillis(pollingInterval))
                    .ignoring(Exception.class);
            
            boolean switched = wait.until(driver -> {
                for (String handle : driver.getWindowHandles()) {
                    driver.switchTo().window(handle);
                    if (driver.getTitle().equals(title)) {
                        return true;
                    }
                }
                driver.switchTo().window(originalHandle);
                return false;
            });
            
            if (switched) {
                reporter.logInfo("Switch Window", "Switched to window with title: " + title);
                return this;
            } else {
                throw new TimeoutException("No window with title '" + title + "' found after " + timeoutInSeconds + " seconds");
            }
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "switchToWindowByTitleFailed");
            reporter.logFailure("Switch Window failed", "Failed to switch to window with title '" + title + "': " + e.getMessage());
            throw new RuntimeException("Failed to switch to window with title '" + title + "'", e);
        }
    }
    
    /**
     * Switches to a window by URL containing a specific string
     * 
     * @param urlContains the string the URL should contain
     * @return this page object instance
     */
    public BasePage switchToWindowByUrlContaining(String urlContains) {
        return switchToWindowByUrlContaining(urlContains, defaultTimeout);
    }
    
    /**
     * Switches to a window by URL containing a specific string with custom timeout
     * 
     * @param urlContains the string the URL should contain
     * @param timeoutInSeconds timeout in seconds
     * @return this page object instance
     */
    public BasePage switchToWindowByUrlContaining(String urlContains, int timeoutInSeconds) {
        try {
            String originalHandle = driver.getWindowHandle();
            Wait<WebDriver> wait = new FluentWait<>(driver)
                    .withTimeout(Duration.ofSeconds(timeoutInSeconds))
                    .pollingEvery(Duration.ofMillis(pollingInterval))
                    .ignoring(Exception.class);
            
            boolean switched = wait.until(driver -> {
                for (String handle : driver.getWindowHandles()) {
                    driver.switchTo().window(handle);
                    if (driver.getCurrentUrl().contains(urlContains)) {
                        return true;
                    }
                }
                driver.switchTo().window(originalHandle);
                return false;
            });
            
            if (switched) {
                reporter.logInfo("Switch Window", "Switched to window with URL containing: " + urlContains);
                return this;
            } else {
                throw new TimeoutException("No window with URL containing '" + urlContains + "' found after " + timeoutInSeconds + " seconds");
            }
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "switchToWindowByUrlContainingFailed");
            reporter.logFailure("Switch Window failed", "Failed to switch to window with URL containing '" + urlContains + "': " + e.getMessage());
            throw new RuntimeException("Failed to switch to window with URL containing '" + urlContains + "'", e);
        }
    }
    
    /**
     * Closes the current window and switches back to the original window
     * 
     * @return this page object instance
     */
    public BasePage closeCurrentWindowAndSwitchToOriginal() {
        try {
            // Store all window handles
            String currentHandle = driver.getWindowHandle();
            String originalHandle = null;
            for (String handle : driver.getWindowHandles()) {
                if (!handle.equals(currentHandle)) {
                    originalHandle = handle;
                    break;
                }
            }
            
            if (originalHandle == null) {
                reporter.logWarning("Close Window", "No original window found to switch to after closing the current window");
                return this;
            }
            
            // Close the current window
            driver.close();
            
            // Switch to the original window
            driver.switchTo().window(originalHandle);
            reporter.logInfo("Close Window", "Closed current window and switched to original window");
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(driver, "closeCurrentWindowAndSwitchToOriginalFailed");
            reporter.logFailure("Close Window failed", "Failed to close current window and switch to original: " + e.getMessage());
            throw new RuntimeException("Failed to close current window and switch to original", e);
        }
    }
    
    /**
     * Gets the value of a cookie by name
     * 
     * @param cookieName the cookie name
     * @return the cookie value, or null if the cookie doesn't exist
     */
    public String getCookieValue(String cookieName) {
        try {
            return driver.manage().getCookieNamed(cookieName) != null ? driver.manage().getCookieNamed(cookieName).getValue() : null;
        } catch (Exception e) {
            reporter.logWarning("Get Cookie failed", "Failed to get cookie '" + cookieName + "': " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Sets a cookie
     * 
     * @param cookieName the cookie name
     * @param cookieValue the cookie value
     * @return this page object instance
     */
    public BasePage setCookie(String cookieName, String cookieValue) {
        try {
            org.openqa.selenium.Cookie cookie = new org.openqa.selenium.Cookie(cookieName, cookieValue);
            driver.manage().addCookie(cookie);
            reporter.logInfo("Set Cookie", "Set cookie: " + cookieName + "=" + cookieValue);
            return this;
        } catch (Exception e) {
            reporter.logWarning("Set Cookie failed", "Failed to set cookie '" + cookieName + "': " + e.getMessage());
            return this;
        }
    }
    
    /**
     * Deletes a cookie
     * 
     * @param cookieName the cookie name
     * @return this page object instance
     */
    public BasePage deleteCookie(String cookieName) {
        try {
            driver.manage().deleteCookieNamed(cookieName);
            reporter.logInfo("Delete Cookie", "Deleted cookie: " + cookieName);
            return this;
        } catch (Exception e) {
            reporter.logWarning("Delete Cookie failed", "Failed to delete cookie '" + cookieName + "': " + e.getMessage());
            return this;
        }
    }
    
    /**
     * Deletes all cookies
     * 
     * @return this page object instance
     */
    public BasePage deleteAllCookies() {
        try {
            driver.manage().deleteAllCookies();
            reporter.logInfo("Delete Cookies", "Deleted all cookies");
            return this;
        } catch (Exception e) {
            reporter.logWarning("Delete Cookies failed", "Failed to delete all cookies: " + e.getMessage());
            return this;
        }
    }
    
    /**
     * Checks if an element has a specific class
     * 
     * @param locator the element locator
     * @param className the class name to check for
     * @return true if the element has the class, false otherwise
     */
    public boolean hasClass(By locator, String className) {
        try {
            WebElement element = waitForVisibility(locator, defaultTimeout);
            String classes = element.getAttribute("class");
            return classes != null && Arrays.asList(classes.split("\\s+")).contains(className);
        } catch (Exception e) {
            reporter.logWarning("Has Class check failed", "Failed to check if element has class '" + className + "': " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Creates a By locator based on a CSFindBy annotation
     * 
     * @param csFindBy the CSFindBy annotation
     * @return the By locator
     */
    protected By createByFromCSFindBy(CSFindBy csFindBy) {
        if (!csFindBy.id().isEmpty()) {
            return By.id(csFindBy.id());
        } else if (!csFindBy.css().isEmpty()) {
            return By.cssSelector(csFindBy.css());
        } else if (!csFindBy.xpath().isEmpty()) {
            return By.xpath(csFindBy.xpath());
        } else if (!csFindBy.name().isEmpty()) {
            return By.name(csFindBy.name());
        } else if (!csFindBy.className().isEmpty()) {
            return By.className(csFindBy.className());
        } else if (!csFindBy.linkText().isEmpty()) {
            return By.linkText(csFindBy.linkText());
        } else if (!csFindBy.partialLinkText().isEmpty()) {
            return By.partialLinkText(csFindBy.partialLinkText());
        } else if (!csFindBy.tagName().isEmpty()) {
            return By.tagName(csFindBy.tagName());
        } else {
            throw new IllegalArgumentException("Cannot create By locator from CSFindBy: no locator strategy specified");
        }
    }
    
    /**
     * Creates a By locator based on a locator string and type
     * 
     * @param locatorType the locator type (id, css, xpath, etc.)
     * @param locatorValue the locator value
     * @return the By locator
     */
    protected By createByFromString(String locatorType, String locatorValue) {
        switch (locatorType.toLowerCase()) {
            case "id":
                return By.id(locatorValue);
            case "css":
            case "cssselector":
                return By.cssSelector(locatorValue);
            case "xpath":
                return By.xpath(locatorValue);
            case "name":
                return By.name(locatorValue);
            case "classname":
                return By.className(locatorValue);
            case "linktext":
                return By.linkText(locatorValue);
            case "partiallinktext":
                return By.partialLinkText(locatorValue);
            case "tagname":
                return By.tagName(locatorValue);
            default:
                throw new IllegalArgumentException("Unsupported locator type: " + locatorType);
        }
    }
}



recorder/chrome/content-script.js
---------------------------------------------

/**
 * CSTestForge Chrome Extension Content Script
 * 
 * This script is injected into web pages to enable test recording capabilities.
 * It captures user interactions, observes DOM changes, and communicates with
 * the background script via Chrome's messaging API.
 */

(function() {
    'use strict';
    
    // Configuration
    const config = {
        enabled: false,
        captureClicks: true,
        captureInputs: true,
        captureSelects: true,
        captureHovers: true,
        captureKeyPresses: true,
        captureNavigation: true,
        captureFocus: true,
        highlightElements: true,
        screenshotOnAction: false,
        domObservationEnabled: true,
        networkMonitoringEnabled: true,
        smartLocatorEnabled: true,
        selfHealingEnabled: true,
        debugMode: false,
        extensionId: chrome.runtime.id,
        extensionVersion: chrome.runtime.getManifest().version,
        recordingSessionId: null,
        frameId: null,
        isMainFrame: window === window.top,
        browserInfo: {
            name: 'Chrome',
            version: navigator.userAgent.match(/Chrome\/([0-9.]+)/)[1]
        }
    };
    
    // Action types
    const ACTION_TYPES = {
        CLICK: 'click',
        INPUT: 'input',
        SELECT: 'select',
        HOVER: 'hover',
        KEY_PRESS: 'keyPress',
        NAVIGATE: 'navigate',
        FOCUS: 'focus',
        BLUR: 'blur',
        SUBMIT: 'submit',
        CONTEXT_MENU: 'contextMenu',
        DOUBLE_CLICK: 'doubleClick',
        DRAG_START: 'dragStart',
        DRAG_END: 'dragEnd',
        DROP: 'drop',
        SCROLL: 'scroll',
        URL_CHANGE: 'urlChange',
        WINDOW_RESIZE: 'windowResize',
        ASSERT: 'assert'
    };
    
    // Stores a unique identifier for each element to track across DOM changes
    const elementRegistry = new Map();
    let registryCounter = 0;
    
    // Track the last interacted element
    let lastInteractedElement = null;
    
    // Store the current page URL
    let currentUrl = window.location.href;
    
    // Store session information
    let sessionInfo = {
        startTime: null,
        frameTree: [],
        recordedActions: [],
        smartLocators: new Map(),
        failedLocators: new Map(),
        healedLocators: new Map(),
        domChanges: []
    };
    
    // Network monitoring data
    let networkRequests = [];
    
    // Performance timing data
    let perfTimings = {};
    
    // DOM Observer instance
    let domObserver = null;
    
    // The element currently being highlighted
    let highlightedElement = null;
    
    // Highlight overlay element
    let highlightOverlay = null;
    
    // Smart locator strategies in order of preference
    const locatorStrategies = [
        { name: 'id', fn: getIdLocator },
        { name: 'name', fn: getNameLocator },
        { name: 'dataTestId', fn: getDataTestIdLocator },
        { name: 'linkText', fn: getLinkTextLocator },
        { name: 'buttonText', fn: getButtonTextLocator },
        { name: 'labelFor', fn: getLabelForLocator },
        { name: 'cssSelector', fn: getCssSelectorLocator },
        { name: 'xpath', fn: getXPathLocator }
    ];
    
    /**
     * Initialize the content script
     */
    function initialize() {
        if (config.debugMode) {
            console.log('CSTestForge Content Script initialized', window.location.href);
        }
        
        // Generate a unique ID for this frame
        config.frameId = generateUUID();
        
        // Initialize element highlight overlay
        initializeHighlightOverlay();
        
        // Set up message listeners for communication with background script
        setupMessageListeners();
        
        // Notify background script that content script is loaded
        sendMessage('contentScriptLoaded', {
            url: window.location.href,
            frameId: config.frameId,
            isMainFrame: config.isMainFrame,
            browserInfo: config.browserInfo
        });
        
        // Initialize network monitoring if enabled
        if (config.networkMonitoringEnabled) {
            initializeNetworkMonitoring();
        }
        
        // Initialize performance monitoring
        initializePerformanceMonitoring();
        
        // Track URL changes
        trackUrlChanges();
    }
    
    /**
     * Set up message listeners for communication with the background script
     */
    function setupMessageListeners() {
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
            if (config.debugMode) {
                console.log('Received message:', message);
            }
            
            // Only process messages intended for this frame or all frames
            if (message.frameId && message.frameId !== config.frameId && !message.allFrames) {
                return;
            }
            
            switch (message.command) {
                case 'startRecording':
                    startRecording(message.data);
                    sendResponse({ success: true });
                    break;
                    
                case 'stopRecording':
                    stopRecording();
                    sendResponse({ success: true });
                    break;
                    
                case 'pauseRecording':
                    config.enabled = false;
                    sendResponse({ success: true });
                    break;
                    
                case 'resumeRecording':
                    config.enabled = true;
                    sendResponse({ success: true });
                    break;
                    
                case 'updateConfig':
                    updateConfig(message.data);
                    sendResponse({ success: true });
                    break;
                    
                case 'highlightElement':
                    highlightElement(message.data.selector, message.data.duration);
                    sendResponse({ success: true });
                    break;
                    
                case 'getFrameInfo':
                    sendResponse({
                        frameId: config.frameId,
                        url: window.location.href,
                        title: document.title,
                        isMainFrame: config.isMainFrame
                    });
                    break;
                    
                case 'executeScript':
                    try {
                        const result = eval(message.data.script);
                        sendResponse({ success: true, result });
                    } catch (error) {
                        sendResponse({ success: false, error: error.message });
                    }
                    break;
                    
                case 'captureScreenshot':
                    // Handled by background script, just acknowledge
                    sendResponse({ success: true });
                    break;
                    
                case 'findElement':
                    const elements = findElementsBySelectorOrXPath(message.data.selector);
                    sendResponse({ 
                        success: true, 
                        count: elements.length,
                        firstElement: elements.length > 0 ? serializeElement(elements[0]) : null
                    });
                    break;
                    
                case 'getSmartLocator':
                    const element = findElementsBySelectorOrXPath(message.data.selector)[0];
                    if (element) {
                        const smartLocators = generateSmartLocators(element);
                        sendResponse({ success: true, locators: smartLocators });
                    } else {
                        sendResponse({ success: false, error: 'Element not found' });
                    }
                    break;
                    
                case 'getNetworkRequests':
                    sendResponse({ success: true, requests: networkRequests });
                    break;
                    
                case 'getPerformanceTimings':
                    sendResponse({ success: true, timings: perfTimings });
                    break;
                    
                case 'getPageSource':
                    sendResponse({ success: true, source: document.documentElement.outerHTML });
                    break;
                    
                case 'healLocator':
                    const healResult = healLocator(message.data.brokenSelector);
                    sendResponse({ 
                        success: healResult.success, 
                        healedSelector: healResult.healedSelector,
                        selectorType: healResult.selectorType
                    });
                    break;
                    
                case 'assertElementState':
                    const assertResult = assertElementState(
                        message.data.selector, 
                        message.data.state, 
                        message.data.expectedValue
                    );
                    sendResponse(assertResult);
                    break;
                    
                default:
                    sendResponse({ success: false, error: 'Unknown command' });
            }
            
            return true; // Required for async response
        });
    }
    
    /**
     * Start recording user interactions
     * @param {Object} options - Recording options
     */
    function startRecording(options = {}) {
        // Stop any existing recording first
        stopRecording();
        
        // Update configuration with provided options
        updateConfig(options);
        
        // Create a new recording session
        config.recordingSessionId = generateUUID();
        sessionInfo.startTime = new Date().toISOString();
        sessionInfo.recordedActions = [];
        
        // Enable recording
        config.enabled = true;
        
        // Attach event listeners
        attachEventListeners();
        
        // Start DOM observation if enabled
        if (config.domObservationEnabled) {
            startDOMObservation();
        }
        
        // Notify background script that recording has started
        sendMessage('recordingStarted', {
            sessionId: config.recordingSessionId,
            url: window.location.href,
            frameId: config.frameId,
            isMainFrame: config.isMainFrame,
            startTime: sessionInfo.startTime,
            title: document.title
        });
        
        if (config.debugMode) {
            console.log('CSTestForge recording started', config);
        }
    }
    
    /**
     * Stop recording user interactions
     */
    function stopRecording() {
        // Disable recording
        config.enabled = false;
        
        // Detach event listeners
        detachEventListeners();
        
        // Stop DOM observation
        stopDOMObservation();
        
        // Remove any active highlights
        removeHighlight();
        
        // Notify background script that recording has stopped
        if (config.recordingSessionId) {
            sendMessage('recordingStopped', {
                sessionId: config.recordingSessionId,
                url: window.location.href,
                frameId: config.frameId,
                isMainFrame: config.isMainFrame,
                endTime: new Date().toISOString(),
                actionsCount: sessionInfo.recordedActions.length
            });
        }
        
        // Reset session info
        config.recordingSessionId = null;
        
        if (config.debugMode) {
            console.log('CSTestForge recording stopped');
        }
    }
    
    /**
     * Update the configuration with new options
     * @param {Object} newConfig - New configuration options
     */
    function updateConfig(newConfig) {
        Object.assign(config, newConfig);
        
        // Apply configuration changes
        if (config.domObservationEnabled && !domObserver) {
            startDOMObservation();
        } else if (!config.domObservationEnabled && domObserver) {
            stopDOMObservation();
        }
        
        if (config.debugMode) {
            console.log('CSTestForge configuration updated', config);
        }
    }
    
    /**
     * Attach event listeners to capture user interactions
     */
    function attachEventListeners() {
        if (config.captureClicks) {
            document.addEventListener('click', handleClick, true);
            document.addEventListener('contextmenu', handleContextMenu, true);
            document.addEventListener('dblclick', handleDoubleClick, true);
        }
        
        if (config.captureInputs) {
            document.addEventListener('input', handleInput, true);
            document.addEventListener('change', handleChange, true);
        }
        
        if (config.captureSelects) {
            document.addEventListener('change', handleSelectChange, true);
        }
        
        if (config.captureHovers) {
            document.addEventListener('mouseover', handleMouseOver, true);
        }
        
        if (config.captureKeyPresses) {
            document.addEventListener('keydown', handleKeyDown, true);
        }
        
        if (config.captureFocus) {
            document.addEventListener('focus', handleFocus, true);
            document.addEventListener('blur', handleBlur, true);
        }
        
        // Always capture these events
        document.addEventListener('submit', handleSubmit, true);
        document.addEventListener('dragstart', handleDragStart, true);
        document.addEventListener('dragend', handleDragEnd, true);
        document.addEventListener('drop', handleDrop, true);
        
        // Capture window events
        window.addEventListener('scroll', handleScroll, true);
        window.addEventListener('resize', handleResize, true);
    }
    
    /**
     * Detach all event listeners
     */
    function detachEventListeners() {
        document.removeEventListener('click', handleClick, true);
        document.removeEventListener('contextmenu', handleContextMenu, true);
        document.removeEventListener('dblclick', handleDoubleClick, true);
        document.removeEventListener('input', handleInput, true);
        document.removeEventListener('change', handleChange, true);
        document.removeEventListener('change', handleSelectChange, true);
        document.removeEventListener('mouseover', handleMouseOver, true);
        document.removeEventListener('keydown', handleKeyDown, true);
        document.removeEventListener('focus', handleFocus, true);
        document.removeEventListener('blur', handleBlur, true);
        document.removeEventListener('submit', handleSubmit, true);
        document.removeEventListener('dragstart', handleDragStart, true);
        document.removeEventListener('dragend', handleDragEnd, true);
        document.removeEventListener('drop', handleDrop, true);
        
        window.removeEventListener('scroll', handleScroll, true);
        window.removeEventListener('resize', handleResize, true);
    }
    
    /**
     * Handle click events
     * @param {Event} event - The click event
     */
    function handleClick(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Skip if the element is the document
        if (element === document) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(element);
        }
        
        // Take screenshot if enabled
        if (config.screenshotOnAction) {
            captureScreenshot();
        }
        
        // Create click action
        const clickAction = {
            type: ACTION_TYPES.CLICK,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            modifiers: {
                ctrlKey: event.ctrlKey,
                altKey: event.altKey,
                shiftKey: event.shiftKey,
                metaKey: event.metaKey
            }
        };
        
        // Record the action
        recordAction(clickAction);
        
        // Update last interacted element
        lastInteractedElement = element;
    }
    
    /**
     * Handle context menu events (right-clicks)
     * @param {Event} event - The context menu event
     */
    function handleContextMenu(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(element);
        }
        
        // Create context menu action
        const contextMenuAction = {
            type: ACTION_TYPES.CONTEXT_MENU,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            modifiers: {
                ctrlKey: event.ctrlKey,
                altKey: event.altKey,
                shiftKey: event.shiftKey,
                metaKey: event.metaKey
            }
        };
        
        // Record the action
        recordAction(contextMenuAction);
        
        // Update last interacted element
        lastInteractedElement = element;
    }
    
    /**
     * Handle double-click events
     * @param {Event} event - The double-click event
     */
    function handleDoubleClick(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(element);
        }
        
        // Create double-click action
        const doubleClickAction = {
            type: ACTION_TYPES.DOUBLE_CLICK,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            modifiers: {
                ctrlKey: event.ctrlKey,
                altKey: event.altKey,
                shiftKey: event.shiftKey,
                metaKey: event.metaKey
            }
        };
        
        // Record the action
        recordAction(doubleClickAction);
        
        // Update last interacted element
        lastInteractedElement = element;
    }
    
    /**
     * Handle input events for text fields
     * @param {Event} event - The input event
     */
    function handleInput(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Only process input elements
        if (!isInputElement(element)) return;
        
        // Process password fields specially - don't record actual password
        const isPassword = element.type === 'password';
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(element);
        }
        
        // Create input action
        const inputAction = {
            type: ACTION_TYPES.INPUT,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            value: isPassword ? '********' : element.value,
            isPassword: isPassword
        };
        
        // Record the action
        recordAction(inputAction);
        
        // Update last interacted element
        lastInteractedElement = element;
    }
    
    /**
     * Handle change events for non-select elements
     * @param {Event} event - The change event
     */
    function handleChange(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Skip select elements (handled separately)
        if (element.tagName.toLowerCase() === 'select') return;
        
        // Only process input elements
        if (!isInputElement(element)) return;
        
        // Skip checkboxes and radio buttons if change event is not triggered by user
        if ((element.type === 'checkbox' || element.type === 'radio') && !lastInteractedElement) return;
        
        // Process password fields specially - don't record actual password
        const isPassword = element.type === 'password';
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(element);
        }
        
        // Create input action for the change
        const inputAction = {
            type: ACTION_TYPES.INPUT,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            isInputChange: true,
            value: isPassword ? '********' : (element.type === 'checkbox' || element.type === 'radio') ? 
                element.checked : element.value,
            isPassword: isPassword,
            inputType: element.type
        };
        
        // Record the action
        recordAction(inputAction);
        
        // Update last interacted element
        lastInteractedElement = element;
    }
    
    /**
     * Handle change events for select elements
     * @param {Event} event - The change event
     */
    function handleSelectChange(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Only process select elements
        if (element.tagName.toLowerCase() !== 'select') return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(element);
        }
        
        // Get selected options
        const selectedOptions = Array.from(element.selectedOptions).map(option => {
            return {
                index: option.index,
                value: option.value,
                text: option.text
            };
        });
        
        // Create select action
        const selectAction = {
            type: ACTION_TYPES.SELECT,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            selectedOptions: selectedOptions,
            isMultiple: element.multiple
        };
        
        // Record the action
        recordAction(selectAction);
        
        // Update last interacted element
        lastInteractedElement = element;
    }
    
    /**
     * Handle mouse over events for hover recording
     * @param {Event} event - The mouseover event
     */
    function handleMouseOver(event) {
        if (!config.enabled) return;
        
        // Throttle hover events to reduce noise
        if (element === lastInteractedElement) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Skip if the element is the document or body
        if (element === document || element === document.body) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Create hover action
        const hoverAction = {
            type: ACTION_TYPES.HOVER,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo
        };
        
        // Record the action - only if significant (e.g., hovers over interactive elements)
        if (isSignificantHover(element)) {
            recordAction(hoverAction);
            
            // Highlight the element if enabled
            if (config.highlightElements) {
                highlightElement(element);
            }
            
            // Update last interacted element
            lastInteractedElement = element;
        }
    }
    
    /**
     * Handle key down events
     * @param {Event} event - The keydown event
     */
    function handleKeyDown(event) {
        if (!config.enabled) return;
        
        // Skip if the target is part of our extension UI
        if (isExtensionElement(event.target)) return;
        
        // Capture special key combinations (Ctrl+, Alt+, etc.)
        if (event.ctrlKey || event.altKey || event.metaKey || 
            event.key === 'Enter' || event.key === 'Tab' || 
            event.key === 'Escape' || event.key === 'ArrowUp' || 
            event.key === 'ArrowDown' || event.key === 'ArrowLeft' || 
            event.key === 'ArrowRight') {
            
            // Create key press action
            const keyPressAction = {
                type: ACTION_TYPES.KEY_PRESS,
                timestamp: new Date().toISOString(),
                url: window.location.href,
                frameId: config.frameId,
                key: event.key,
                modifiers: {
                    ctrlKey: event.ctrlKey,
                    altKey: event.altKey,
                    shiftKey: event.shiftKey,
                    metaKey: event.metaKey
                },
                targetElementInfo: event.target !== document ? 
                    captureElementInfo(event.target) : null
            };
            
            // Record the action
            recordAction(keyPressAction);
            
            // Highlight the target element if enabled
            if (config.highlightElements && event.target !== document) {
                highlightElement(event.target);
            }
        }
    }
    
    /**
     * Handle focus events
     * @param {Event} event - The focus event
     */
    function handleFocus(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Skip if the element is the document or window
        if (element === document || element === window) return;
        
        // Skip if not an interactive element
        if (!isInteractiveElement(element)) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Create focus action
        const focusAction = {
            type: ACTION_TYPES.FOCUS,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo
        };
        
        // Record the action
        recordAction(focusAction);
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(element);
        }
        
        // Update last interacted element
        lastInteractedElement = element;
    }
    
    /**
     * Handle blur events
     * @param {Event} event - The blur event
     */
    function handleBlur(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Skip if the element is the document or window
        if (element === document || element === window) return;
        
        // Skip if not an interactive element
        if (!isInteractiveElement(element)) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Create blur action
        const blurAction = {
            type: ACTION_TYPES.BLUR,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo
        };
        
        // Record the action
        recordAction(blurAction);
    }
    
    /**
     * Handle form submissions
     * @param {Event} event - The submit event
     */
    function handleSubmit(event) {
        if (!config.enabled) return;
        
        const form = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(form)) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(form);
        if (!elementInfo) return;
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(form);
        }
        
        // Take screenshot if enabled
        if (config.screenshotOnAction) {
            captureScreenshot();
        }
        
        // Collect form data (excluding passwords)
        const formData = collectFormData(form);
        
        // Create submit action
        const submitAction = {
            type: ACTION_TYPES.SUBMIT,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            formData: formData
        };
        
        // Record the action
        recordAction(submitAction);
    }
    
    /**
     * Handle drag start events
     * @param {Event} event - The dragstart event
     */
    function handleDragStart(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Create drag start action
        const dragStartAction = {
            type: ACTION_TYPES.DRAG_START,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            clientX: event.clientX,
            clientY: event.clientY
        };
        
        // Record the action
        recordAction(dragStartAction);
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(element);
        }
        
        // Update last interacted element
        lastInteractedElement = element;
    }
    
    /**
     * Handle drag end events
     * @param {Event} event - The dragend event
     */
    function handleDragEnd(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Create drag end action
        const dragEndAction = {
            type: ACTION_TYPES.DRAG_END,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            clientX: event.clientX,
            clientY: event.clientY
        };
        
        // Record the action
        recordAction(dragEndAction);
    }
    
    /**
     * Handle drop events
     * @param {Event} event - The drop event
     */
    function handleDrop(event) {
        if (!config.enabled) return;
        
        const element = event.target;
        
        // Skip if the element is part of our extension UI
        if (isExtensionElement(element)) return;
        
        // Capture element information and locators
        const elementInfo = captureElementInfo(element);
        if (!elementInfo) return;
        
        // Create drop action
        const dropAction = {
            type: ACTION_TYPES.DROP,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            frameId: config.frameId,
            elementInfo: elementInfo,
            clientX: event.clientX,
            clientY: event.clientY
        };
        
        // Record the action
        recordAction(dropAction);
        
        // Highlight the element if enabled
        if (config.highlightElements) {
            highlightElement(element);
        }
    }
    
    /**
     * Handle scroll events
     * @param {Event} event - The scroll event
     */
    function handleScroll(event) {
        if (!config.enabled) return;
        
        // Throttle scroll events to reduce noise
        if (scrollTimeout) return;
        
        scrollTimeout = setTimeout(() => {
            scrollTimeout = null;
            
            // Create scroll action
            const scrollAction = {
                type: ACTION_TYPES.SCROLL,
                timestamp: new Date().toISOString(),
                url: window.location.href,
                frameId: config.frameId,
                scrollX: window.scrollX,
                scrollY: window.scrollY
            };
            
            // Record the action
            recordAction(scrollAction);
        }, 500); // Throttle to one event every 500ms
    }
    
    /**
     * Handle window resize events
     * @param {Event} event - The resize event
     */
    function handleResize(event) {
        if (!config.enabled) return;
        
        // Throttle resize events to reduce noise
        if (resizeTimeout) return;
        
        resizeTimeout = setTimeout(() => {
            resizeTimeout = null;
            
            // Create resize action
            const resizeAction = {
                type: ACTION_TYPES.WINDOW_RESIZE,
                timestamp: new Date().toISOString(),
                url: window.location.href,
                frameId: config.frameId,
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight
            };
            
            // Record the action
            recordAction(resizeAction);
        }, 500); // Throttle to one event every 500ms
    }
    
    /**
     * Record an action and send it to the background script
     * @param {Object} action - The action to record
     */
    function recordAction(action) {
        if (!config.enabled || !config.recordingSessionId) return;
        
        // Add session ID to the action
        action.sessionId = config.recordingSessionId;
        
        // Add the action to the session info
        sessionInfo.recordedActions.push(action);
        
        // Send the action to the background script
        sendMessage('actionRecorded', action);
        
        if (config.debugMode) {
            console.log('Action recorded:', action);
        }
    }
    
    /**
     * Capture detailed information about an element
     * @param {Element} element - The DOM element
     * @return {Object|null} Element information object or null if it should be skipped
     */
    function captureElementInfo(element) {
        if (!element || element === document || element === window) return null;
        
        // Get or create unique ID for this element
        let elementId = elementRegistry.get(element);
        if (!elementId) {
            elementId = 'element-' + (++registryCounter);
            elementRegistry.set(element, elementId);
        }
        
        // Generate smart locators for the element
        const smartLocators = config.smartLocatorEnabled ? 
            generateSmartLocators(element) : null;
        
        // Store smart locators in session info
        if (smartLocators) {
            sessionInfo.smartLocators.set(elementId, smartLocators);
        }
        
        // Basic element information
        const elementInfo = {
            elementId: elementId,
            tagName: element.tagName.toLowerCase(),
            id: element.id,
            name: element.name,
            className: element.className,
            type: element.type,
            value: element.type === 'password' ? '********' : element.value,
            checked: element.checked,
            text: getElementText(element),
            attributes: getElementAttributes(element),
            position: getElementPosition(element),
            size: {
                width: element.offsetWidth,
                height: element.offsetHeight
            },
            xpath: smartLocators ? smartLocators.xpath : null,
            cssSelector: smartLocators ? smartLocators.cssSelector : null,
            locators: smartLocators
        };
        
        return elementInfo;
    }
    
    /**
     * Generate smart locators for an element
     * @param {Element} element - The DOM element
     * @return {Object} Object containing different locator strategies
     */
    function generateSmartLocators(element) {
        const locators = {};
        
        // Try each locator strategy in order of preference
        for (const strategy of locatorStrategies) {
            const locator = strategy.fn(element);
            if (locator) {
                locators[strategy.name] = locator;
            }
        }
        
        // Make sure we have at least one locator
        if (Object.keys(locators).length === 0) {
            // Fallback to a simple XPath if nothing else works
            locators.xpath = getXPathLocator(element);
        }
        
        return locators;
    }
    
    /**
     * Get an ID-based locator for an element
     * @param {Element} element - The DOM element
     * @return {Object|null} Locator info or null if not applicable
     */
    function getIdLocator(element) {
        if (element.id && element.id.trim()) {
            return {
                value: element.id,
                strategy: 'id',
                selenium: `By.id("${element.id}")`,
                playwright: `page.locator('#${element.id}')`,
                css: `#${element.id}`,
                xpath: `//*[@id="${element.id}"]`
            };
        }
        return null;
    }
    
    /**
     * Get a name-based locator for an element
     * @param {Element} element - The DOM element
     * @return {Object|null} Locator info or null if not applicable
     */
    function getNameLocator(element) {
        if (element.name && element.name.trim()) {
            return {
                value: element.name,
                strategy: 'name',
                selenium: `By.name("${element.name}")`,
                playwright: `page.locator('[name="${element.name}"]')`,
                css: `[name="${element.name}"]`,
                xpath: `//*[@name="${element.name}"]`
            };
        }
        return null;
    }
    
    /**
     * Get a data-testid-based locator for an element
     * @param {Element} element - The DOM element
     * @return {Object|null} Locator info or null if not applicable
     */
    function getDataTestIdLocator(element) {
        const testId = element.getAttribute('data-testid') || 
                     element.getAttribute('data-test-id') || 
                     element.getAttribute('data-test');
        
        if (testId && testId.trim()) {
            return {
                value: testId,
                strategy: 'dataTestId',
                selenium: `By.cssSelector("[data-testid='${testId}']")`,
                playwright: `page.locator('[data-testid="${testId}"]')`,
                css: `[data-testid="${testId}"]`,
                xpath: `//*[@data-testid="${testId}"]`
            };
        }
        return null;
    }
    
    /**
     * Get a link text locator for an element
     * @param {Element} element - The DOM element
     * @return {Object|null} Locator info or null if not applicable
     */
    function getLinkTextLocator(element) {
        if (element.tagName.toLowerCase() === 'a' && element.textContent.trim()) {
            const text = element.textContent.trim();
            return {
                value: text,
                strategy: 'linkText',
                selenium: `By.linkText("${text}")`,
                playwright: `page.locator('a:has-text("${text}")')`,
                css: null,
                xpath: `//a[text()="${text}"]`
            };
        }
        return null;
    }
    
    /**
     * Get a button text locator for an element
     * @param {Element} element - The DOM element
     * @return {Object|null} Locator info or null if not applicable
     */
    function getButtonTextLocator(element) {
        if ((element.tagName.toLowerCase() === 'button' || 
            (element.tagName.toLowerCase() === 'input' && 
             (element.type === 'button' || element.type === 'submit'))) && 
            (element.textContent.trim() || element.value)) {
            
            const text = element.textContent.trim() || element.value;
            return {
                value: text,
                strategy: 'buttonText',
                selenium: `By.xpath("//button[text()='${text}' or @value='${text}'] | //input[@type='button' or @type='submit'][@value='${text}']")`,
                playwright: `page.locator('button:has-text("${text}"), input[type="button"][value="${text}"], input[type="submit"][value="${text}"]')`,
                css: null,
                xpath: `//button[text()="${text}" or @value="${text}"] | //input[@type="button" or @type="submit"][@value="${text}"]`
            };
        }
        return null;
    }
    
    /**
     * Get a label-based locator for an element
     * @param {Element} element - The DOM element
     * @return {Object|null} Locator info or null if not applicable
     */
    function getLabelForLocator(element) {
        if (element.id) {
            const label = document.querySelector(`label[for="${element.id}"]`);
            if (label && label.textContent.trim()) {
                const text = label.textContent.trim();
                return {
                    value: text,
                    strategy: 'labelFor',
                    selenium: `By.xpath("//label[text()='${text}']/..//input | //label[contains(text(),'${text}')]/..//input | //label[text()='${text}']/following::input | //label[contains(text(),'${text}')]/following::input")`,
                    playwright: `page.locator('label:has-text("${text}") + input, label:has-text("${text}") ~ input')`,
                    css: null,
                    xpath: `//label[text()="${text}" or contains(text(),"${text}")]/following::input | //label[text()="${text}" or contains(text(),"${text}")]/..//input`
                };
            }
        }
        return null;
    }
    
    /**
     * Get a CSS selector for an element
     * @param {Element} element - The DOM element
     * @return {Object} CSS selector info
     */
    function getCssSelectorLocator(element) {
        let selector = '';
        let current = element;
        
        while (current && current !== document.documentElement) {
            let step = current.tagName.toLowerCase();
            
            // Add ID if available (most specific)
            if (current.id) {
                step += `#${current.id}`;
                selector = step + (selector ? ' > ' + selector : '');
                break;
            }
            
            // Add classes if available
            if (current.className) {
                const classes = current.className.trim().split(/\s+/);
                if (classes.length > 0 && classes[0] !== '') {
                    // Use up to 2 classes to avoid overly specific selectors
                    const classSelector = classes.slice(0, 2).map(c => `.${c}`).join('');
                    step += classSelector;
                }
            }
            
            // Add :nth-child if needed to make the selector more specific
            const parent = current.parentElement;
            if (parent && parent.children.length > 1) {
                const index = Array.prototype.indexOf.call(parent.children, current) + 1;
                step += `:nth-child(${index})`;
            }
            
            selector = step + (selector ? ' > ' + selector : '');
            
            // Move up the tree
            current = parent;
            
            // Limit the selector to 3-4 levels to keep it readable
            if (selector.split('>').length >= 4) {
                break;
            }
        }
        
        return {
            value: selector,
            strategy: 'cssSelector',
            selenium: `By.cssSelector("${selector}")`,
            playwright: `page.locator('${selector}')`,
            css: selector,
            xpath: null
        };
    }
    
    /**
     * Get an XPath for an element
     * @param {Element} element - The DOM element
     * @return {Object} XPath info
     */
    function getXPathLocator(element) {
        let xpath = '';
        let current = element;
        
        while (current && current !== document.documentElement) {
            let step = current.tagName.toLowerCase();
            
            // Add ID if available (most specific)
            if (current.id) {
                xpath = `//${step}[@id="${current.id}"]` + xpath;
                break;
            }
            
            // Add index to make the XPath unique
            const parent = current.parentElement;
            if (parent) {
                const siblings = Array.from(parent.children).filter(child => 
                    child.tagName.toLowerCase() === step);
                
                if (siblings.length > 1) {
                    const index = siblings.indexOf(current) + 1;
                    step += `[${index}]`;
                }
            }
            
            xpath = `/${step}` + xpath;
            
            // Move up the tree
            current = parent;
        }
        
        // Ensure the XPath starts with a single slash
        if (xpath.startsWith('//')) {
            // Already starts with //
        } else if (xpath.startsWith('/')) {
            xpath = '/' + xpath;
        } else {
            xpath = '//' + xpath;
        }
        
        return {
            value: xpath,
            strategy: 'xpath',
            selenium: `By.xpath("${xpath}")`,
            playwright: `page.locator('${xpath}')`,
            css: null,
            xpath: xpath
        };
    }
    
    /**
     * Get the text content of an element
     * @param {Element} element - The DOM element
     * @return {string} The visible text content
     */
    function getElementText(element) {
        // For input elements, use the value
        if (element.tagName.toLowerCase() === 'input' || 
            element.tagName.toLowerCase() === 'textarea') {
            if (element.type === 'password') {
                return '********';
            }
            return element.value || '';
        }
        
        // For select elements, get the selected option text
        if (element.tagName.toLowerCase() === 'select') {
            return Array.from(element.selectedOptions)
                .map(option => option.text)
                .join(', ');
        }
        
        // For other elements, get the visible text content
        return element.innerText || element.textContent || '';
    }
    
    /**
     * Get all attributes of an element
     * @param {Element} element - The DOM element
     * @return {Object} Object with attribute names and values
     */
    function getElementAttributes(element) {
        const attributes = {};
        
        for (const attr of element.attributes) {
            // Skip password values
            if ((attr.name === 'value' && element.type === 'password') ||
                (attr.name === 'placeholder' && element.type === 'password')) {
                attributes[attr.name] = '********';
            } else {
                attributes[attr.name] = attr.value;
            }
        }
        
        return attributes;
    }
    
    /**
     * Get the position of an element
     * @param {Element} element - The DOM element
     * @return {Object} The element's position
     */
    function getElementPosition(element) {
        const rect = element.getBoundingClientRect();
        
        return {
            x: rect.left + window.scrollX,
            y: rect.top + window.scrollY,
            viewport: {
                x: rect.left,
                y: rect.top
            }
        };
    }
    
    /**
     * Collect form data excluding password fields
     * @param {Element} form - The form element
     * @return {Object} Form data
     */
    function collectFormData(form) {
        const formData = {};
        
        // Process all form controls
        const elements = form.elements;
        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            
            // Skip buttons, fieldsets, disabled elements
            if (element.tagName.toLowerCase() === 'button' ||
                element.tagName.toLowerCase() === 'fieldset' ||
                element.disabled) {
                continue;
            }
            
            const name = element.name || element.id;
            if (!name) continue;
            
            // Handle different input types
            if (element.tagName.toLowerCase() === 'input') {
                if (element.type === 'password') {
                    formData[name] = '********';
                } else if (element.type === 'checkbox' || element.type === 'radio') {
                    if (element.checked) {
                        formData[name] = element.value || 'on';
                    }
                } else if (element.type !== 'submit' && element.type !== 'button' && 
                          element.type !== 'reset' && element.type !== 'image') {
                    formData[name] = element.value;
                }
            } else if (element.tagName.toLowerCase() === 'select') {
                if (element.multiple) {
                    formData[name] = Array.from(element.selectedOptions)
                        .map(option => option.value);
                } else {
                    formData[name] = element.value;
                }
            } else if (element.tagName.toLowerCase() === 'textarea') {
                formData[name] = element.value;
            }
        }
        
        return formData;
    }
    
    /**
     * Check if an element is an input element (input, textarea, select)
     * @param {Element} element - The DOM element
     * @return {boolean} True if it's an input element
     */
    function isInputElement(element) {
        const tag = element.tagName.toLowerCase();
        return tag === 'input' || tag === 'textarea' || tag === 'select';
    }
    
    /**
     * Check if an element is interactive (can receive focus)
     * @param {Element} element - The DOM element
     * @return {boolean} True if it's an interactive element
     */
    function isInteractiveElement(element) {
        const tag = element.tagName.toLowerCase();
        
        // Common interactive elements
        if (['a', 'button', 'input', 'textarea', 'select', 'details', 'summary'].includes(tag)) {
            return true;
        }
        
        // Elements with tabindex
        if (element.hasAttribute('tabindex')) {
            return parseInt(element.getAttribute('tabindex')) >= 0;
        }
        
        // Elements with click handler
        if (element.hasAttribute('onclick')) {
            return true;
        }
        
        // Elements with role attributes
        if (element.hasAttribute('role')) {
            const role = element.getAttribute('role');
            return ['button', 'link', 'checkbox', 'menuitem', 'menuitemcheckbox', 
                    'menuitemradio', 'option', 'radio', 'tab', 'textbox', 'switch',
                    'combobox', 'slider'].includes(role);
        }
        
        return false;
    }
    
    /**
     * Check if a hover is significant (worth recording)
     * @param {Element} element - The DOM element
     * @return {boolean} True if it's a significant hover
     */
    function isSignificantHover(element) {
        const tag = element.tagName.toLowerCase();
        
        // Hovers over interactive elements are significant
        if (isInteractiveElement(element)) {
            return true;
        }
        
        // Hovers over elements with hover effects
        const style = window.getComputedStyle(element);
        const hasHoverStyle = style.cursor === 'pointer';
        
        if (hasHoverStyle) {
            return true;
        }
        
        // Hovers over menu items
        if (['li', 'div', 'span'].includes(tag)) {
            const parentElement = element.parentElement;
            if (parentElement && 
                ['ul', 'ol', 'nav', 'menu'].includes(parentElement.tagName.toLowerCase())) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Check if an element is part of the extension UI
     * @param {Element} element - The DOM element
     * @return {boolean} True if it's part of the extension UI
     */
    function isExtensionElement(element) {
        // Check for extension markers
        if (!element || !element.hasAttribute) {
            return false;
        }
        
        // Check for extension attribute markers
        if (element.hasAttribute('data-cstestforge-ui')) {
            return true;
        }
        
        // Check if it's part of our overlay
        if (highlightOverlay && highlightOverlay.contains(element)) {
            return true;
        }
        
        // Check parent elements
        let parent = element.parentElement;
        while (parent) {
            if (parent.hasAttribute && parent.hasAttribute('data-cstestforge-ui')) {
                return true;
            }
            if (highlightOverlay && highlightOverlay === parent) {
                return true;
            }
            parent = parent.parentElement;
        }
        
        return false;
    }
    
    /**
     * Initialize the highlight overlay element
     */
    function initializeHighlightOverlay() {
        highlightOverlay = document.createElement('div');
        highlightOverlay.setAttribute('data-cstestforge-ui', 'true');
        highlightOverlay.style.position = 'absolute';
        highlightOverlay.style.pointerEvents = 'none';
        highlightOverlay.style.zIndex = '2147483647';
        highlightOverlay.style.border = `2px solid ${config.primaryBrandColor || '#C54B8C'}`;
        highlightOverlay.style.borderRadius = '2px';
        highlightOverlay.style.boxShadow = `0 0 5px ${config.primaryBrandColor || '#C54B8C'}`;
        highlightOverlay.style.display = 'none';
        
        document.body.appendChild(highlightOverlay);
    }
    
    /**
     * Highlight an element on the page
     * @param {Element|string} elementOrSelector - The element or selector to highlight
     * @param {number} duration - Duration in milliseconds (default: 1000)
     */
    function highlightElement(elementOrSelector, duration = 1000) {
        if (!highlightOverlay) {
            initializeHighlightOverlay();
        }
        
        // Remove existing highlight
        removeHighlight();
        
        // Find the element
        let element;
        if (typeof elementOrSelector === 'string') {
            element = findElementsBySelectorOrXPath(elementOrSelector)[0];
        } else {
            element = elementOrSelector;
        }
        
        if (!element) return;
        
        // Save the highlighted element
        highlightedElement = element;
        
        // Update overlay position to match the element
        const rect = element.getBoundingClientRect();
        highlightOverlay.style.left = `${rect.left + window.scrollX}px`;
        highlightOverlay.style.top = `${rect.top + window.scrollY}px`;
        highlightOverlay.style.width = `${rect.width}px`;
        highlightOverlay.style.height = `${rect.height}px`;
        highlightOverlay.style.display = 'block';
        
        // Auto-remove after duration
        if (duration > 0) {
            setTimeout(removeHighlight, duration);
        }
    }
    
    /**
     * Remove the element highlight
     */
    function removeHighlight() {
        if (highlightOverlay) {
            highlightOverlay.style.display = 'none';
        }
        highlightedElement = null;
    }
    
    /**
     * Find elements using CSS selector or XPath
     * @param {string} selectorOrXPath - CSS selector or XPath
     * @return {Element[]} Array of matching elements
     */
    function findElementsBySelectorOrXPath(selectorOrXPath) {
        try {
            // Try as CSS selector first
            const elements = Array.from(document.querySelectorAll(selectorOrXPath));
            if (elements.length > 0) {
                return elements;
            }
        } catch (e) {
            // Not a valid CSS selector
        }
        
        try {
            // Try as XPath
            const result = document.evaluate(
                selectorOrXPath, 
                document, 
                null, 
                XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, 
                null
            );
            
            const elements = [];
            for (let i = 0; i < result.snapshotLength; i++) {
                elements.push(result.snapshotItem(i));
            }
            
            return elements;
        } catch (e) {
            // Not a valid XPath
            return [];
        }
    }
    
    /**
     * Send a message to the background script
     * @param {string} messageType - Type of message
     * @param {Object} data - Message data
     * @return {Promise} Promise that resolves with the response
     */
    function sendMessage(messageType, data = {}) {
        return new Promise((resolve, reject) => {
            chrome.runtime.sendMessage({
                type: messageType,
                frameId: config.frameId,
                url: window.location.href,
                data: data
            }, response => {
                if (chrome.runtime.lastError) {
                    if (config.debugMode) {
                        console.error('Error sending message:', chrome.runtime.lastError);
                    }
                    reject(chrome.runtime.lastError);
                } else {
                    resolve(response);
                }
            });
        });
    }
    
    /**
     * Generate a UUID
     * @return {string} UUID
     */
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    
    /**
     * Start observing DOM changes
     */
    function startDOMObservation() {
        if (domObserver) return;
        
        // Create a new observer
        domObserver = new MutationObserver(mutations => {
            if (!config.enabled) return;
            
            // Process mutations
            const relevantMutations = processMutations(mutations);
            
            if (relevantMutations.length > 0) {
                // Add to session information
                sessionInfo.domChanges.push(...relevantMutations);
                
                // Send to background script if significant changes
                if (relevantMutations.filter(m => m.isSignificant).length > 0) {
                    sendMessage('domChanged', {
                        mutations: relevantMutations,
                        timestamp: new Date().toISOString(),
                        url: window.location.href,
                        sessionId: config.recordingSessionId
                    });
                }
            }
            
            // Update highlight position if element is still highlighted
            if (highlightedElement && highlightOverlay && highlightOverlay.style.display !== 'none') {
                const rect = highlightedElement.getBoundingClientRect();
                highlightOverlay.style.left = `${rect.left + window.scrollX}px`;
                highlightOverlay.style.top = `${rect.top + window.scrollY}px`;
                highlightOverlay.style.width = `${rect.width}px`;
                highlightOverlay.style.height = `${rect.height}px`;
            }
        });
        
        // Start observing
        domObserver.observe(document.documentElement, {
            childList: true,
            attributes: true,
            characterData: true,
            subtree: true,
            attributeOldValue: true,
            characterDataOldValue: true
        });
    }
    
    /**
     * Stop observing DOM changes
     */
    function stopDOMObservation() {
        if (domObserver) {
            domObserver.disconnect();
            domObserver = null;
        }
    }
    
    /**
     * Process DOM mutations to identify relevant changes
     * @param {MutationRecord[]} mutations - DOM mutations
     * @return {Object[]} Processed mutations
     */
    function processMutations(mutations) {
        const processedMutations = [];
        
        for (const mutation of mutations) {
            // Skip mutations of extension elements
            if (isExtensionElement(mutation.target)) continue;
            
            // Process based on mutation type
            let processedMutation;
            
            switch (mutation.type) {
                case 'childList':
                    processedMutation = processChildListMutation(mutation);
                    break;
                    
                case 'attributes':
                    processedMutation = processAttributeMutation(mutation);
                    break;
                    
                case 'characterData':
                    processedMutation = processCharacterDataMutation(mutation);
                    break;
            }
            
            if (processedMutation) {
                processedMutations.push(processedMutation);
            }
        }
        
        return processedMutations;
    }
    
    /**
     * Process a childList mutation
     * @param {MutationRecord} mutation - The mutation
     * @return {Object|null} Processed mutation or null
     */
    function processChildListMutation(mutation) {
        const addedNodes = Array.from(mutation.addedNodes)
            .filter(node => node.nodeType === Node.ELEMENT_NODE)
            .map(node => ({
                tagName: node.tagName.toLowerCase(),
                id: node.id,
                className: node.className,
                nodeType: node.nodeType,
                textContent: node.textContent?.substring(0, 100)
            }));
        
        const removedNodes = Array.from(mutation.removedNodes)
            .filter(node => node.nodeType === Node.ELEMENT_NODE)
            .map(node => ({
                tagName: node.tagName?.toLowerCase(),
                id: node.id,
                className: node.className,
                nodeType: node.nodeType,
                textContent: node.textContent?.substring(0, 100)
            }));
        
        // Skip if no elements were added or removed
        if (addedNodes.length === 0 && removedNodes.length === 0) {
            return null;
        }
        
        // Determine if this is a significant change (e.g., modal opening, content loading)
        const isSignificant = 
            // Added nodes significant if they are visible interactive elements
            addedNodes.some(node => 
                node.tagName && ['div', 'dialog', 'modal', 'iframe', 'form', 'button', 'a', 'input', 'select'].includes(node.tagName)
            ) ||
            // Removed nodes significant if they are visible interactive elements
            removedNodes.some(node => 
                node.tagName && ['div', 'dialog', 'modal', 'iframe', 'form', 'button', 'a', 'input', 'select'].includes(node.tagName)
            );
        
        return {
            type: 'childList',
            target: serializeNode(mutation.target),
            addedNodes,
            removedNodes,
            isSignificant,
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * Process an attributes mutation
     * @param {MutationRecord} mutation - The mutation
     * @return {Object|null} Processed mutation or null
     */
    function processAttributeMutation(mutation) {
        // Skip style and data-* attributes for non-interactive elements
        if (mutation.attributeName === 'style' && 
            !isInteractiveElement(mutation.target)) {
            return null;
        }
        
        // Skip non-visible elements
        if (mutation.target.nodeType === Node.ELEMENT_NODE && 
            !isElementVisible(mutation.target)) {
            return null;
        }
        
        // Determine if this is a significant change
        const isSignificant = 
            mutation.attributeName === 'disabled' ||
            mutation.attributeName === 'hidden' ||
            mutation.attributeName === 'aria-hidden' ||
            mutation.attributeName === 'class' && (
                mutation.oldValue?.includes('hidden') !== 
                mutation.target.className.includes('hidden') ||
                mutation.oldValue?.includes('show') !== 
                mutation.target.className.includes('show') ||
                mutation.oldValue?.includes('active') !== 
                mutation.target.className.includes('active') ||
                mutation.oldValue?.includes('open') !== 
                mutation.target.className.includes('open')
            );
        
        return {
            type: 'attribute',
            target: serializeNode(mutation.target),
            attributeName: mutation.attributeName,
            oldValue: mutation.oldValue,
            newValue: mutation.target.getAttribute(mutation.attributeName),
            isSignificant,
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * Process a characterData mutation
     * @param {MutationRecord} mutation - The mutation
     * @return {Object|null} Processed mutation or null
     */
    function processCharacterDataMutation(mutation) {
        // Skip non-significant text changes (too small)
        if (mutation.oldValue && mutation.target.textContent &&
            mutation.oldValue.length > 0 && mutation.target.textContent.length > 0 &&
            Math.abs(mutation.oldValue.length - mutation.target.textContent.length) < 5) {
            return null;
        }
        
        return {
            type: 'characterData',
            target: serializeNode(mutation.target),
            oldValue: mutation.oldValue?.substring(0, 100),
            newValue: mutation.target.textContent?.substring(0, 100),
            isSignificant: false,
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * Check if an element is visible
     * @param {Element} element - The DOM element
     * @return {boolean} True if the element is visible
     */
    function isElementVisible(element) {
        // Element must be part of the DOM
        if (!element || !element.parentElement) {
            return false;
        }
        
        // Check computed style
        const style = window.getComputedStyle(element);
        if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
            return false;
        }
        
        // Check element dimensions (must have size)
        const rect = element.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Serialize a node for transmission
     * @param {Node} node - The DOM node
     * @return {Object} Serialized node
     */
    function serializeNode(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            return {
                nodeType: Node.TEXT_NODE,
                textContent: node.textContent?.substring(0, 100)
            };
        }
        
        if (node.nodeType === Node.ELEMENT_NODE) {
            return serializeElement(node);
        }
        
        return {
            nodeType: node.nodeType
        };
    }
    
    /**
     * Serialize an element for transmission
     * @param {Element} element - The DOM element
     * @return {Object} Serialized element
     */
    function serializeElement(element) {
        return {
            nodeType: Node.ELEMENT_NODE,
            tagName: element.tagName.toLowerCase(),
            id: element.id,
            className: element.className,
            attributes: getElementAttributes(element),
            textContent: element.textContent?.substring(0, 100)
        };
    }
    
    /**
     * Initialize the network monitoring
     */
    function initializeNetworkMonitoring() {
        // Monkey-patch XMLHttpRequest
        monkeyPatchXMLHttpRequest();
        
        // Monkey-patch fetch
        monkeyPatchFetch();
    }
    
    /**
     * Monkey-patch XMLHttpRequest to monitor network requests
     */
    function monkeyPatchXMLHttpRequest() {
        const originalOpen = XMLHttpRequest.prototype.open;
        const originalSend = XMLHttpRequest.prototype.send;
        
        XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
            this._cstestforge_method = method;
            this._cstestforge_url = url;
            this._cstestforge_startTime = new Date().getTime();
            return originalOpen.apply(this, arguments);
        };
        
        XMLHttpRequest.prototype.send = function(data) {
            const xhr = this;
            const requestId = generateUUID();
            
            // Capture request information
            const requestInfo = {
                id: requestId,
                type: 'xhr',
                method: xhr._cstestforge_method,
                url: xhr._cstestforge_url,
                body: data ? truncateData(data) : null,
                startTime: xhr._cstestforge_startTime,
                endTime: null,
                duration: null,
                status: null,
                statusText: null,
                headers: {},
                response: null
            };
            
            // Add request to the list
            networkRequests.push(requestInfo);
            
            // Track the response
            xhr.addEventListener('load', function() {
                requestInfo.endTime = new Date().getTime();
                requestInfo.duration = requestInfo.endTime - requestInfo.startTime;
                requestInfo.status = xhr.status;
                requestInfo.statusText = xhr.statusText;
                
                // Get response headers
                const headers = xhr.getAllResponseHeaders();
                if (headers) {
                    headers.trim().split(/[\r\n]+/).forEach(line => {
                        const parts = line.split(': ');
                        const name = parts.shift();
                        const value = parts.join(': ');
                        requestInfo.headers[name] = value;
                    });
                }
                
                // Get response body if possible
                try {
                    if (xhr.responseType === '' || xhr.responseType === 'text') {
                        requestInfo.response = truncateData(xhr.responseText);
                    } else if (xhr.responseType === 'json') {
                        try {
                            requestInfo.response = truncateData(JSON.stringify(xhr.response));
                        } catch (e) {
                            requestInfo.response = '[JSON Response]';
                        }
                    } else {
                        requestInfo.response = `[${xhr.responseType} Response]`;
                    }
                } catch (e) {
                    requestInfo.response = '[Error accessing response]';
                }
                
                // Send network request information to background
                if (config.enabled && config.recordingSessionId) {
                    sendMessage('networkRequest', {
                        request: requestInfo,
                        sessionId: config.recordingSessionId,
                        timestamp: new Date().toISOString()
                    });
                }
            });
            
            xhr.addEventListener('error', function() {
                requestInfo.endTime = new Date().getTime();
                requestInfo.duration = requestInfo.endTime - requestInfo.startTime;
                requestInfo.status = 0;
                requestInfo.statusText = 'Error';
                
                // Send network request information to background
                if (config.enabled && config.recordingSessionId) {
                    sendMessage('networkRequest', {
                        request: requestInfo,
                        sessionId: config.recordingSessionId,
                        timestamp: new Date().toISOString()
                    });
                }
            });
            
            return originalSend.apply(this, arguments);
        };
    }
    
    /**
     * Monkey-patch fetch to monitor network requests
     */
    function monkeyPatchFetch() {
        const originalFetch = window.fetch;
        
        window.fetch = function(input, init) {
            const requestId = generateUUID();
            const startTime = new Date().getTime();
            
            let url;
            let method;
            let requestBody;
            
            // Extract request details
            if (typeof input === 'string') {
                url = input;
            } else if (input instanceof Request) {
                url = input.url;
                method = input.method;
            }
            
            if (init) {
                method = init.method || method || 'GET';
                requestBody = init.body || null;
            }
            
            // Capture request information
            const requestInfo = {
                id: requestId,
                type: 'fetch',
                method: method || 'GET',
                url: url,
                body: requestBody ? truncateData(requestBody) : null,
                startTime: startTime,
                endTime: null,
                duration: null,
                status: null,
                statusText: null,
                headers: {},
                response: null
            };
            
            // Add request to the list
            networkRequests.push(requestInfo);
            
            // Call the original fetch and track the response
            return originalFetch.apply(this, arguments)
                .then(response => {
                    const endTime = new Date().getTime();
                    
                    requestInfo.endTime = endTime;
                    requestInfo.duration = endTime - startTime;
                    requestInfo.status = response.status;
                    requestInfo.statusText = response.statusText;
                    
                    // Get response headers
                    response.headers.forEach((value, name) => {
                        requestInfo.headers[name] = value;
                    });
                    
                    // Clone the response to read the body without consuming it
                    const clonedResponse = response.clone();
                    
                    // Try to get the response body
                    if (clonedResponse.headers.get('content-type') && 
                        clonedResponse.headers.get('content-type').includes('application/json')) {
                        clonedResponse.json().then(json => {
                            requestInfo.response = truncateData(JSON.stringify(json));
                            
                            // Send network request information to background
                            if (config.enabled && config.recordingSessionId) {
                                sendMessage('networkRequest', {
                                    request: requestInfo,
                                    sessionId: config.recordingSessionId,
                                    timestamp: new Date().toISOString()
                                });
                            }
                        }).catch(() => {
                            requestInfo.response = '[Error parsing JSON]';
                            
                            // Send network request information to background
                            if (config.enabled && config.recordingSessionId) {
                                sendMessage('networkRequest', {
                                    request: requestInfo,
                                    sessionId: config.recordingSessionId,
                                    timestamp: new Date().toISOString()
                                });
                            }
                        });
                    } else if (clonedResponse.headers.get('content-type') && 
                               clonedResponse.headers.get('content-type').includes('text/')) {
                        clonedResponse.text().then(text => {
                            requestInfo.response = truncateData(text);
                            
                            // Send network request information to background
                            if (config.enabled && config.recordingSessionId) {
                                sendMessage('networkRequest', {
                                    request: requestInfo,
                                    sessionId: config.recordingSessionId,
                                    timestamp: new Date().toISOString()
                                });
                            }
                        }).catch(() => {
                            requestInfo.response = '[Error reading response text]';
                            
                            // Send network request information to background
                            if (config.enabled && config.recordingSessionId) {
                                sendMessage('networkRequest', {
                                    request: requestInfo,
                                    sessionId: config.recordingSessionId,
                                    timestamp: new Date().toISOString()
                                });
                            }
                        });
                    } else {
                        requestInfo.response = `[${clonedResponse.headers.get('content-type') || 'Unknown'} Response]`;
                        
                        // Send network request information to background
                        if (config.enabled && config.recordingSessionId) {
                            sendMessage('networkRequest', {
                                request: requestInfo,
                                sessionId: config.recordingSessionId,
                                timestamp: new Date().toISOString()
                            });
                        }
                    }
                    
                    return response;
                })
                .catch(error => {
                    const endTime = new Date().getTime();
                    
                    requestInfo.endTime = endTime;
                    requestInfo.duration = endTime - startTime;
                    requestInfo.status = 0;
                    requestInfo.statusText = 'Error';
                    requestInfo.response = error.message;
                    
                    // Send network request information to background
                    if (config.enabled && config.recordingSessionId) {
                        sendMessage('networkRequest', {
                            request: requestInfo,
                            sessionId: config.recordingSessionId,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    throw error;
                });
        };
    }
    
    /**
     * Truncate data to a reasonable size for storage
     * @param {string|object} data - The data to truncate
     * @param {number} maxLength - Maximum length (default: 4096)
     * @return {string} Truncated data as string
     */
    function truncateData(data, maxLength = 4096) {
        if (data === null || data === undefined) {
            return null;
        }
        
        let stringData;
        if (typeof data === 'string') {
            stringData = data;
        } else if (typeof data === 'object') {
            try {
                stringData = JSON.stringify(data);
            } catch (e) {
                stringData = String(data);
            }
        } else {
            stringData = String(data);
        }
        
        if (stringData.length <= maxLength) {
            return stringData;
        }
        
        return stringData.substring(0, maxLength) + `... [Truncated, original length: ${stringData.length}]`;
    }
    
    /**
     * Initialize performance monitoring
     */
    function initializePerformanceMonitoring() {
        // Collect initial performance data
        collectPerformanceData();
        
        // Listen for navigation events to collect performance data
        window.addEventListener('load', collectPerformanceData);
        
        // Track resource timing for dynamically loaded resources
        let resourceObserver = new PerformanceObserver(list => {
            const entries = list.getEntries();
            for (const entry of entries) {
                addResourceTiming(entry);
            }
        });
        
        try {
            resourceObserver.observe({entryTypes: ['resource']});
        } catch (e) {
            if (config.debugMode) {
                console.error('Error setting up PerformanceObserver:', e);
            }
        }
    }
    
    /**
     * Collect performance data
     */
    function collectPerformanceData() {
        if (!window.performance || !window.performance.timing) {
            return;
        }
        
        const timing = window.performance.timing;
        
        perfTimings = {
            navigationStart: timing.navigationStart,
            redirectStart: timing.redirectStart,
            redirectEnd: timing.redirectEnd,
            fetchStart: timing.fetchStart,
            domainLookupStart: timing.domainLookupStart,
            domainLookupEnd: timing.domainLookupEnd,
            connectStart: timing.connectStart,
            connectEnd: timing.connectEnd,
            secureConnectionStart: timing.secureConnectionStart,
            requestStart: timing.requestStart,
            responseStart: timing.responseStart,
            responseEnd: timing.responseEnd,
            domLoading: timing.domLoading,
            domInteractive: timing.domInteractive,
            domContentLoadedEventStart: timing.domContentLoadedEventStart,
            domContentLoadedEventEnd: timing.domContentLoadedEventEnd,
            domComplete: timing.domComplete,
            loadEventStart: timing.loadEventStart,
            loadEventEnd: timing.loadEventEnd,
            
            // Calculated metrics
            redirectTime: timing.redirectEnd - timing.redirectStart,
            dnsTime: timing.domainLookupEnd - timing.domainLookupStart,
            connectTime: timing.connectEnd - timing.connectStart,
            requestTime: timing.responseStart - timing.requestStart,
            responseTime: timing.responseEnd - timing.responseStart,
            domProcessingTime: timing.domComplete - timing.domLoading,
            pageLoadTime: timing.loadEventEnd - timing.navigationStart,
            
            // Resource timings
            resources: []
        };
        
        // Add resource timings
        if (window.performance.getEntriesByType) {
            const resourceEntries = window.performance.getEntriesByType('resource');
            resourceEntries.forEach(entry => {
                addResourceTiming(entry);
            });
        }
        
        // If recording is enabled, send performance data to background
        if (config.enabled && config.recordingSessionId) {
            sendMessage('performanceData', {
                perfData: perfTimings,
                sessionId: config.recordingSessionId,
                timestamp: new Date().toISOString(),
                url: window.location.href
            });
        }
    }
    
    /**
     * Add a resource timing to the performance data
     * @param {PerformanceResourceTiming} entry - The resource timing entry
     */
    function addResourceTiming(entry) {
        // Skip if not a resource timing
        if (entry.entryType !== 'resource') {
            return;
        }
        
        // Skip extension resources
        if (entry.name.includes(chrome.runtime.id)) {
            return;
        }
        
        // Add to performance timings
        perfTimings.resources.push({
            name: entry.name,
            entryType: entry.entryType,
            startTime: entry.startTime,
            duration: entry.duration,
            initiatorType: entry.initiatorType,
            transferSize: entry.transferSize,
            encodedBodySize: entry.encodedBodySize,
            decodedBodySize: entry.decodedBodySize
        });
    }
    
    /**
     * Track URL changes
     */
    function trackUrlChanges() {
        // Track URL changes via History API
        const originalPushState = history.pushState;
        const originalReplaceState = history.replaceState;
        
        history.pushState = function() {
            originalPushState.apply(this, arguments);
            handleUrlChange('pushState');
        };
        
        history.replaceState = function() {
            originalReplaceState.apply(this, arguments);
            handleUrlChange('replaceState');
        };
        
        // Track URL changes via navigation events
        window.addEventListener('popstate', () => {
            handleUrlChange('popstate');
        });
        
        // Check for hash changes
        window.addEventListener('hashchange', () => {
            handleUrlChange('hashchange');
        });
    }
    
    /**
     * Handle URL changes
     * @param {string} trigger - What triggered the URL change
     */
    function handleUrlChange(trigger) {
        const newUrl = window.location.href;
        
        // Skip if the URL hasn't actually changed
        if (newUrl === currentUrl) {
            return;
        }
        
        // Update current URL
        const oldUrl = currentUrl;
        currentUrl = newUrl;
        
        // Record the URL change action
        if (config.enabled && config.recordingSessionId) {
            const urlChangeAction = {
                type: ACTION_TYPES.URL_CHANGE,
                timestamp: new Date().toISOString(),
                oldUrl: oldUrl,
                newUrl: newUrl,
                frameId: config.frameId,
                isMainFrame: config.isMainFrame,
                trigger: trigger,
                sessionId: config.recordingSessionId
            };
            
            recordAction(urlChangeAction);
            
            // Notify background script about URL change for recorder UI updates
            sendMessage('urlChanged', {
                oldUrl: oldUrl,
                newUrl: newUrl,
                frameId: config.frameId,
                isMainFrame: config.isMainFrame,
                sessionId: config.recordingSessionId,
                timestamp: new Date().toISOString()
            });
        }
    }
    
    /**
     * Capture a screenshot of the current page
     */
    function captureScreenshot() {
        // Screenshot capture is done by the background script
        sendMessage('captureScreenshot', {
            reason: 'action',
            frameId: config.frameId,
            isMainFrame: config.isMainFrame,
            sessionId: config.recordingSessionId,
            timestamp: new Date().toISOString(),
            viewport: {
                width: window.innerWidth,
                height: window.innerHeight,
                scrollX: window.scrollX,
                scrollY: window.scrollY
            }
        });
    }
    
    /**
     * Heal a broken locator using the self-healing algorithm
     * @param {string} brokenSelector - The broken selector
     * @return {Object} Result with the healed selector and selector type
     */
    function healLocator(brokenSelector) {
        const result = {
            success: false,
            healedSelector: null,
            selectorType: null
        };
        
        // Check if we already have a healed version of this selector
        if (sessionInfo.healedLocators.has(brokenSelector)) {
            result.success = true;
            result.healedSelector = sessionInfo.healedLocators.get(brokenSelector).selector;
            result.selectorType = sessionInfo.healedLocators.get(brokenSelector).type;
            return result;
        }
        
        // Try to find the element using the broken selector
        try {
            const elements = findElementsBySelectorOrXPath(brokenSelector);
            if (elements.length > 0) {
                // Selector still works, no need to heal
                result.success = true;
                result.healedSelector = brokenSelector;
                result.selectorType = brokenSelector.startsWith('/') ? 'xpath' : 'css';
                return result;
            }
        } catch (e) {
            // Selector is broken, need to heal
        }
        
        // Add to failed locators if not already there
        if (!sessionInfo.failedLocators.has(brokenSelector)) {
            sessionInfo.failedLocators.set(brokenSelector, {
                failCount: 0,
                lastFailTime: new Date().toISOString()
            });
        } else {
            const failInfo = sessionInfo.failedLocators.get(brokenSelector);
            failInfo.failCount++;
            failInfo.lastFailTime = new Date().toISOString();
            sessionInfo.failedLocators.set(brokenSelector, failInfo);
        }
        
        // Determine if the selector is CSS or XPath
        const isCss = !brokenSelector.startsWith('/');
        
        // Try healing based on all previously interacted elements
        for (const action of sessionInfo.recordedActions) {
            if (!action.elementInfo) continue;
            
            // Skip if we don't have smart locators for this element
            if (!action.elementInfo.locators) continue;
            
            // Check if any of the element's locators might work
            for (const strategyName of Object.keys(action.elementInfo.locators)) {
                const locator = action.elementInfo.locators[strategyName];
                
                // Skip if the locator doesn't have the right type (css/xpath)
                if (isCss && !locator.css) continue;
                if (!isCss && !locator.xpath) continue;
                
                const selectorToTry = isCss ? locator.css : locator.xpath;
                
                try {
                    const elements = findElementsBySelectorOrXPath(selectorToTry);
                    if (elements.length === 1) {
                        // Check if this is likely the same element using various properties
                        const elementProperties = collectElementProperties(elements[0]);
                        
                        // Compare with the expected properties (if we have them)
                        if (action.elementInfo.id === elementProperties.id ||
                            action.elementInfo.text === elementProperties.text ||
                            (action.elementInfo.attributes.name && 
                             action.elementInfo.attributes.name === elementProperties.attributes.name)) {
                            
                            // We found a good match! Store the healed locator
                            result.success = true;
                            result.healedSelector = selectorToTry;
                            result.selectorType = isCss ? 'css' : 'xpath';
                            
                            // Save the healed locator
                            sessionInfo.healedLocators.set(brokenSelector, {
                                selector: selectorToTry,
                                type: isCss ? 'css' : 'xpath',
                                healTime: new Date().toISOString()
                            });
                            
                            // Log the healing
                            if (config.debugMode) {
                                console.log(`Healed selector "${brokenSelector}" to "${selectorToTry}"`);
                            }
                            
                            return result;
                        }
                    }
                } catch (e) {
                    // This locator strategy didn't work, try the next one
                }
            }
        }
        
        // If we got here, we couldn't heal the locator
        return result;
    }
    
    /**
     * Collect element properties for comparison
     * @param {Element} element - The DOM element
     * @return {Object} Element properties
     */
    function collectElementProperties(element) {
        return {
            tagName: element.tagName.toLowerCase(),
            id: element.id,
            text: getElementText(element),
            attributes: getElementAttributes(element),
            position: getElementPosition(element),
            size: {
                width: element.offsetWidth,
                height: element.offsetHeight
            }
        };
    }
    
    /**
     * Assert element state for test verification
     * @param {string} selector - The element selector
     * @param {string} state - The state to assert (visible, text, value, etc.)
     * @param {string} expectedValue - The expected value
     * @return {Object} Assert result
     */
    function assertElementState(selector, state, expectedValue) {
        const result = {
            success: false,
            actual: null,
            expected: expectedValue,
            message: '',
            timestamp: new Date().toISOString()
        };
        
        try {
            // Try to find the element
            const elements = findElementsBySelectorOrXPath(selector);
            
            if (elements.length === 0) {
                result.message = `Element not found using selector: ${selector}`;
                return result;
            }
            
            const element = elements[0];
            
            // Assert based on state
            switch (state.toLowerCase()) {
                case 'visible':
                    result.success = isElementVisible(element);
                    result.actual = result.success.toString();
                    result.message = result.success ? 
                        `Element is visible` : 
                        `Element is not visible`;
                    break;
                    
                case 'text':
                    const actualText = getElementText(element);
                    result.actual = actualText;
                    
                    if (expectedValue.startsWith('/') && expectedValue.endsWith('/')) {
                        // Regular expression matching
                        const regex = new RegExp(expectedValue.slice(1, -1));
                        result.success = regex.test(actualText);
                        result.message = result.success ? 
                            `Element text "${actualText}" matches ${expectedValue}` : 
                            `Element text "${actualText}" does not match ${expectedValue}`;
                    } else {
                        // Exact matching
                        result.success = actualText === expectedValue;
                        result.message = result.success ? 
                            `Element text is "${actualText}"` : 
                            `Element text is "${actualText}", expected "${expectedValue}"`;
                    }
                    break;
                    
                case 'value':
                    const actualValue = element.value;
                    result.actual = actualValue;
                    result.success = actualValue === expectedValue;
                    result.message = result.success ? 
                        `Element value is "${actualValue}"` : 
                        `Element value is "${actualValue}", expected "${expectedValue}"`;
                    break;
                    
                case 'attribute':
                    // expectedValue format: "name=value"
                    const [attrName, attrValue] = expectedValue.split('=');
                    const actualAttrValue = element.getAttribute(attrName);
                    result.actual = actualAttrValue;
                    result.success = actualAttrValue === attrValue;
                    result.message = result.success ? 
                        `Element attribute ${attrName} is "${actualAttrValue}"` : 
                        `Element attribute ${attrName} is "${actualAttrValue}", expected "${attrValue}"`;
                    break;
                    
                case 'enabled':
                    const isEnabled = !element.disabled;
                    result.actual = isEnabled.toString();
                    result.success = isEnabled.toString() === expectedValue.toLowerCase();
                    result.message = result.success ? 
                        `Element is ${isEnabled ? 'enabled' : 'disabled'}` : 
                        `Element is ${isEnabled ? 'enabled' : 'disabled'}, expected ${expectedValue}`;
                    break;
                    
                case 'checked':
                    const isChecked = element.checked;
                    result.actual = isChecked.toString();
                    result.success = isChecked.toString() === expectedValue.toLowerCase();
                    result.message = result.success ? 
                        `Element is ${isChecked ? 'checked' : 'unchecked'}` : 
                        `Element is ${isChecked ? 'checked' : 'unchecked'}, expected ${expectedValue}`;
                    break;
                    
                default:
                    result.message = `Unknown state "${state}"`;
            }
            
            // Record assertion action
            if (config.enabled && config.recordingSessionId) {
                const assertAction = {
                    type: ACTION_TYPES.ASSERT,
                    timestamp: new Date().toISOString(),
                    url: window.location.href,
                    frameId: config.frameId,
                    selector: selector,
                    state: state,
                    expectedValue: expectedValue,
                    actualValue: result.actual,
                    success: result.success,
                    message: result.message,
                    sessionId: config.recordingSessionId
                };
                
                recordAction(assertAction);
            }
            
            // Highlight element with green/red based on success
            if (config.highlightElements) {
                const originalBorderColor = highlightOverlay.style.border;
                const originalBoxShadow = highlightOverlay.style.boxShadow;
                
                highlightOverlay.style.border = `2px solid ${result.success ? '#44cc44' : '#ff4444'}`;
                highlightOverlay.style.boxShadow = `0 0 5px ${result.success ? '#44cc44' : '#ff4444'}`;
                
                highlightElement(element, 2000);
                
                // Reset to original colors after highlight
                setTimeout(() => {
                    if (highlightOverlay) {
                        highlightOverlay.style.border = originalBorderColor;
                        highlightOverlay.style.boxShadow = originalBoxShadow;
                    }
                }, 2000);
            }
            
            return result;
        } catch (e) {
            result.message = `Error during assertion: ${e.message}`;
            return result;
        }
    }
    
    // Initialize the content script when the page is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
})();



templates/projects/selenium/java/testng/README.md.templace
---------------------------------------------------------------------------

# ${project.name} - Selenium Java TestNG Test Automation Project

## Introduction

This test automation project was created with CSTestForge Framework, a powerful test automation solution for enterprise applications. The project is configured to use Selenium WebDriver with Java and TestNG for test execution.

## Table of Contents

- [Project Structure](#project-structure)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Configuration](#configuration)
- [Writing Tests](#writing-tests)
  - [Page Objects](#page-objects)
  - [Test Cases](#test-cases)
  - [Data-Driven Testing](#data-driven-testing)
- [Running Tests](#running-tests)
  - [Command Line Execution](#command-line-execution)
  - [IDE Execution](#ide-execution)
  - [CI/CD Integration](#cicd-integration)
- [Reporting](#reporting)
- [Logging](#logging)
- [Advanced Features](#advanced-features)
  - [Parallel Execution](#parallel-execution)
  - [Test Grouping](#test-grouping)
  - [Self-Healing Locators](#self-healing-locators)
  - [AI-Powered Element Recognition](#ai-powered-element-recognition)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)

## Project Structure

```
${project.name}/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── ${package.path}/
│   │   │       ├── core/
│   │   │       │   ├── config/
│   │   │       │   ├── utils/
│   │   │       │   ├── data/
│   │   │       │   ├── reporting/
│   │   │       │   └── ai/
│   │   │       └── selenium/
│   │   │           ├── browser/
│   │   │           ├── element/
│   │   │           └── wait/
│   │   └── resources/
│   │       ├── config/
│   │       │   ├── framework-config.properties
│   │       │   └── environment/
│   │       │       ├── dev.properties
│   │       │       ├── qa.properties
│   │       │       └── prod.properties
│   │       └── logback.xml
│   └── test/
│       ├── java/
│       │   └── ${package.path}/
│       │       ├── pages/
│       │       │   ├── BasePage.java
│       │       │   ├── LoginPage.java
│       │       │   └── ...
│       │       ├── tests/
│       │       │   ├── BaseTest.java
│       │       │   ├── LoginTest.java
│       │       │   └── ...
│       │       └── utils/
│       │           ├── TestListeners.java
│       │           └── TestUtils.java
│       └── resources/
│           ├── testdata/
│           │   ├── testdata.xlsx
│           │   ├── testdata.csv
│           │   └── testdata.json
│           ├── testng.xml
│           └── testng-parallel.xml
├── target/
│   └── reports/
│       ├── html/
│       ├── screenshots/
│       └── videos/
├── pom.xml
├── README.md
└── .gitignore
```

## Prerequisites

- Java 17 or higher
- Maven 3.8.0 or higher
- Latest version of Chrome, Firefox, or Edge browser
- IDE (IntelliJ IDEA, Eclipse, or VS Code recommended)

## Installation

1. Ensure you have the required prerequisites installed.
2. Clone this repository to your local machine:
   ```bash
   git clone https://your-repository-url/${project.name}.git
   cd ${project.name}
   ```
3. Install Maven dependencies:
   ```bash
   mvn clean install -DskipTests
   ```

## Configuration

The framework configuration is stored in property files located in the `src/main/resources/config` directory. The main configuration files are:

- `framework-config.properties` - Core framework configurations
- Environment-specific configuration files in the `environment` directory:
  - `dev.properties` - Development environment settings
  - `qa.properties` - QA environment settings
  - `prod.properties` - Production environment settings

To select an environment, set the `env` system property when running tests:

```bash
mvn test -Denv=qa
```

Key configuration properties include:

- `base.url` - The base URL of the application under test
- `browser` - The browser to use for testing (chrome, firefox, edge)
- `timeout.default` - Default element timeout in seconds
- `screenshotOnFailure` - Whether to capture screenshots on test failures
- `recordVideo` - Whether to record videos of test execution
- `autoHeal` - Enable/disable self-healing locators

## Writing Tests

### Page Objects

The framework follows the Page Object Model design pattern. Page objects should extend the `BasePage` class:

```java
import ${package}.pages.BasePage;
import org.openqa.selenium.By;
import ${package}.selenium.java.testng.annotations.CSFindBy;

public class LoginPage extends BasePage {
    
    @CSFindBy(id = "username")
    private By usernameField;
    
    @CSFindBy(id = "password")
    private By passwordField;
    
    @CSFindBy(css = "button[type='submit']")
    private By loginButton;
    
    public LoginPage() {
        super();
    }
    
    public LoginPage enterUsername(String username) {
        type(usernameField, username);
        return this;
    }
    
    public LoginPage enterPassword(String password) {
        type(passwordField, password);
        return this;
    }
    
    public DashboardPage clickLogin() {
        click(loginButton);
        return new DashboardPage();
    }
    
    public DashboardPage login(String username, String password) {
        enterUsername(username);
        enterPassword(password);
        return clickLogin();
    }
}
```

### Test Cases

Test classes should extend the `BaseTest` class and use TestNG annotations:

```java
import org.testng.annotations.Test;
import org.testng.Assert;
import ${package}.tests.BaseTest;
import ${package}.pages.LoginPage;
import ${package}.pages.DashboardPage;

public class LoginTest extends BaseTest {
    
    @Test(description = "Verify successful login with valid credentials")
    public void testValidLogin() {
        LoginPage loginPage = new LoginPage();
        DashboardPage dashboardPage = loginPage
            .navigateTo("/login")
            .login("validUser", "validPassword");
        
        Assert.assertTrue(dashboardPage.isUserLoggedIn(), "User should be logged in");
        Assert.assertEquals(dashboardPage.getWelcomeMessage(), "Welcome, validUser!");
    }
    
    @Test(description = "Verify login fails with invalid credentials")
    public void testInvalidLogin() {
        LoginPage loginPage = new LoginPage();
        loginPage
            .navigateTo("/login")
            .enterUsername("invalidUser")
            .enterPassword("invalidPassword")
            .clickLogin();
        
        Assert.assertTrue(loginPage.isErrorMessageDisplayed(), "Error message should be displayed");
        Assert.assertEquals(loginPage.getErrorMessage(), "Invalid username or password");
    }
}
```

### Data-Driven Testing

The framework supports data-driven testing using the `CSTestForgeDataProvider` annotation:

```java
import org.testng.annotations.Test;
import org.testng.Assert;
import ${package}.tests.BaseTest;
import ${package}.pages.LoginPage;
import ${package}.core.data.CSTestForgeDataProvider;

public class DataDrivenLoginTest extends BaseTest {
    
    @Test(dataProvider = "loginData")
    @CSTestForgeDataProvider(source = "testdata/login_data.xlsx", sheet = "Login")
    public void testLogin(String username, String password, boolean expectSuccess, String expectedMessage) {
        LoginPage loginPage = new LoginPage();
        loginPage
            .navigateTo("/login")
            .enterUsername(username)
            .enterPassword(password)
            .clickLogin();
        
        if (expectSuccess) {
            DashboardPage dashboardPage = new DashboardPage();
            Assert.assertTrue(dashboardPage.isUserLoggedIn(), "User should be logged in");
            Assert.assertEquals(dashboardPage.getWelcomeMessage(), expectedMessage);
        } else {
            Assert.assertTrue(loginPage.isErrorMessageDisplayed(), "Error message should be displayed");
            Assert.assertEquals(loginPage.getErrorMessage(), expectedMessage);
        }
    }
}
```

## Running Tests

### Command Line Execution

Run all tests:

```bash
mvn clean test
```

Run a specific test class:

```bash
mvn clean test -Dtest=LoginTest
```

Run a specific test method:

```bash
mvn clean test -Dtest=LoginTest#testValidLogin
```

Run tests in parallel:

```bash
mvn clean test -DsuiteXmlFile=testng-parallel.xml
```

### IDE Execution

#### IntelliJ IDEA

1. Right-click on a test class or method
2. Select "Run" or "Debug"

#### Eclipse

1. Right-click on a test class or method
2. Select "Run As" > "TestNG Test"

### CI/CD Integration

The project includes configuration files for popular CI/CD platforms:

- Azure DevOps: `azure-pipelines.yml`
- GitHub Actions: `.github/workflows/test.yml`
- Jenkins: `Jenkinsfile`

## Reporting

The framework generates detailed HTML reports with dashboards, screenshots, and videos. Reports are created in the `target/reports` directory after test execution.

To open the latest report:

```bash
mvn ${package}.reporting:open-report
```

## Logging

The framework uses Logback for logging. The configuration is in `src/main/resources/logback.xml`. Logs are generated to:

- Console - For real-time debug information
- `target/logs/test.log` - For detailed execution logs

## Advanced Features

### Parallel Execution

The framework supports parallel test execution at the class and method levels. To enable parallel execution, use the `testng-parallel.xml` configuration:

```bash
mvn clean test -DsuiteXmlFile=testng-parallel.xml
```

### Test Grouping

Tests can be organized using TestNG groups:

```java
@Test(groups = {"smoke", "login"})
public void testValidLogin() {
    // Test code
}
```

To run tests by group:

```bash
mvn clean test -Dgroups=smoke
```

### Self-Healing Locators

The framework includes self-healing locators that automatically recover from broken element locators during test execution. This feature is enabled by setting `autoHeal=true` in the configuration.

### AI-Powered Element Recognition

The framework includes a custom-built AI element recognition system that makes element identification more robust across application changes. This feature is enabled by setting `smartLocators=true` in the configuration.

## Troubleshooting

### Common Issues

1. **Tests fail with NoSuchElementException**
   - Increase the default timeout in `framework-config.properties`
   - Verify that the locators are correct
   - Enable self-healing locators with `autoHeal=true`

2. **WebDriverManager fails to download browser drivers**
   - Check your internet connection
   - Try specifying a browser version: `-Dwebdriver.chrome.version=115`

3. **Test reports are not generated**
   - Ensure you have write permissions to the `target/reports` directory
   - Make sure the test listener is properly registered in `testng.xml`

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the terms of the license provided by your organization. See the LICENSE file for details.

---

Generated by CSTestForge Framework v1.0.0



templates/projects/selenium//java/bdd/pom.xml.template
-------------------------------------------------------------------------------

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>${groupId}</groupId>
    <artifactId>${artifactId}</artifactId>
    <version>${version}</version>
    <packaging>jar</packaging>

    <name>${project.name}</name>
    <description>${project.description}</description>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>17</java.version>
        <maven.compiler.source>${java.version}</maven.compiler.source>
        <maven.compiler.target>${java.version}</maven.compiler.target>
        
        <!-- Dependencies Versions -->
        <selenium.version>4.14.1</selenium.version>
        <cucumber.version>7.14.0</cucumber.version>
        <webdrivermanager.version>5.5.3</webdrivermanager.version>
        <jackson.version>2.15.2</jackson.version>
        <slf4j.version>2.0.9</slf4j.version>
        <logback.version>1.4.11</logback.version>
        <commons-io.version>2.13.0</commons-io.version>
        <commons-lang3.version>3.13.0</commons-lang3.version>
        <commons-text.version>1.10.0</commons-text.version>
        <commons-csv.version>1.10.0</commons-csv.version>
        <poi.version>5.2.3</poi.version>
        <awaitility.version>4.2.0</awaitility.version>
        <assertj.version>3.24.2</assertj.version>
        <rest-assured.version>5.3.2</rest-assured.version>
        <extentreports.version>5.1.1</extentreports.version>
        <monte-screen-recorder.version>0.7.7.0</monte-screen-recorder.version>
        <commons-collections4.version>4.4</commons-collections4.version>
        <jaxb-api.version>2.4.0-b180830.0359</jaxb-api.version>
        <javax.activation.version>1.2.0</javax.activation.version>
        <mysql-connector.version>8.1.0</mysql-connector.version>
        <postgresql.version>42.6.0</postgresql.version>
        
        <!-- Plugin Versions -->
        <maven-compiler-plugin.version>3.11.0</maven-compiler-plugin.version>
        <maven-surefire-plugin.version>3.1.2</maven-surefire-plugin.version>
        <maven-resources-plugin.version>3.3.1</maven-resources-plugin.version>
        <maven-clean-plugin.version>3.3.1</maven-clean-plugin.version>
        <maven-jar-plugin.version>3.3.0</maven-jar-plugin.version>
        <cucumber-reporting.version>5.7.7</cucumber-reporting.version>
    </properties>

    <dependencies>
        <!-- Selenium WebDriver -->
        <dependency>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-java</artifactId>
            <version>${selenium.version}</version>
        </dependency>
        
        <!-- WebDriverManager -->
        <dependency>
            <groupId>io.github.bonigarcia</groupId>
            <artifactId>webdrivermanager</artifactId>
            <version>${webdrivermanager.version}</version>
        </dependency>
        
        <!-- Cucumber -->
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-java</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-junit</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-picocontainer</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-core</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        
        <!-- JSON Processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>
        
        <!-- Apache Commons -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>${commons-io.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>${commons-lang3.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-text</artifactId>
            <version>${commons-text.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>${commons-csv.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-collections4</artifactId>
            <version>${commons-collections4.version}</version>
        </dependency>
        
        <!-- Excel Processing -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>${poi.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>${poi.version}</version>
        </dependency>
        
        <!-- Assertion Utilities -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>${assertj.version}</version>
        </dependency>
        <dependency>
            <groupId>org.awaitility</groupId>
            <artifactId>awaitility</artifactId>
            <version>${awaitility.version}</version>
        </dependency>
        
        <!-- REST API Testing -->
        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <version>${rest-assured.version}</version>
        </dependency>
        
        <!-- Reporting -->
        <dependency>
            <groupId>com.aventstack</groupId>
            <artifactId>extentreports</artifactId>
            <version>${extentreports.version}</version>
        </dependency>
        
        <!-- Video Recording -->
        <dependency>
            <groupId>com.github.stephenc.monte</groupId>
            <artifactId>monte-screen-recorder</artifactId>
            <version>${monte-screen-recorder.version}</version>
        </dependency>
        
        <!-- JAXB and Activation for Java 11+ -->
        <dependency>
            <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>
            <version>${jaxb-api.version}</version>
        </dependency>
        <dependency>
            <groupId>com.sun.activation</groupId>
            <artifactId>javax.activation</artifactId>
            <version>${javax.activation.version}</version>
        </dependency>
        
        <!-- Database Connectors for Data-Driven Testing -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <version>${mysql-connector.version}</version>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>${postgresql.version}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Compiler Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven-compiler-plugin.version}</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>
            
            <!-- Surefire Plugin for running tests -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>${maven-surefire-plugin.version}</version>
                <configuration>
                    <includes>
                        <include>**/*RunnerTest.java</include>
                    </includes>
                    <testFailureIgnore>true</testFailureIgnore>
                    <systemPropertyVariables>
                        <cucumber.filter.tags>${cucumber.filter.tags}</cucumber.filter.tags>
                        <environment>${environment}</environment>
                        <browser>${browser}</browser>
                        <headless>${headless}</headless>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
            
            <!-- Cucumber Reporting Plugin -->
            <plugin>
                <groupId>net.masterthought</groupId>
                <artifactId>maven-cucumber-reporting</artifactId>
                <version>${cucumber-reporting.version}</version>
                <executions>
                    <execution>
                        <id>execution</id>
                        <phase>verify</phase>
                        <goals>
                            <goal>generate</goal>
                        </goals>
                        <configuration>
                            <projectName>${project.name}</projectName>
                            <outputDirectory>${project.build.directory}/cucumber-reports</outputDirectory>
                            <inputDirectory>${project.build.directory}/cucumber-reports</inputDirectory>
                            <jsonFiles>
                                <param>**/*.json</param>
                            </jsonFiles>
                            <checkBuildResult>false</checkBuildResult>
                            <classificationFiles>
                                <param>classifications.properties</param>
                            </classificationFiles>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            
            <!-- Resources Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <version>${maven-resources-plugin.version}</version>
                <configuration>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>
            
            <!-- Clean Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-clean-plugin</artifactId>
                <version>${maven-clean-plugin.version}</version>
            </plugin>
            
            <!-- Jar Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${maven-jar-plugin.version}</version>
            </plugin>
        </plugins>
        
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
            <resource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
    
    <profiles>
        <!-- Environment Profiles -->
        <profile>
            <id>dev</id>
            <properties>
                <environment>dev</environment>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>qa</id>
            <properties>
                <environment>qa</environment>
            </properties>
        </profile>
        <profile>
            <id>stage</id>
            <properties>
                <environment>stage</environment>
            </properties>
        </profile>
        <profile>
            <id>prod</id>
            <properties>
                <environment>prod</environment>
            </properties>
        </profile>
        
        <!-- Browser Profiles -->
        <profile>
            <id>chrome</id>
            <properties>
                <browser>chrome</browser>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>firefox</id>
            <properties>
                <browser>firefox</browser>
            </properties>
        </profile>
        <profile>
            <id>edge</id>
            <properties>
                <browser>edge</browser>
            </properties>
        </profile>
        <profile>
            <id>safari</id>
            <properties>
                <browser>safari</browser>
            </properties>
        </profile>
        
        <!-- Run Modes -->
        <profile>
            <id>headless</id>
            <properties>
                <headless>true</headless>
            </properties>
        </profile>
        <profile>
            <id>headed</id>
            <properties>
                <headless>false</headless>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        
        <!-- Test Scopes -->
        <profile>
            <id>smoke</id>
            <properties>
                <cucumber.filter.tags>@smoke</cucumber.filter.tags>
            </properties>
        </profile>
        <profile>
            <id>regression</id>
            <properties>
                <cucumber.filter.tags>@regression</cucumber.filter.tags>
            </properties>
        </profile>
        <profile>
            <id>sanity</id>
            <properties>
                <cucumber.filter.tags>@sanity</cucumber.filter.tags>
            </properties>
        </profile>
        <profile>
            <id>all</id>
            <properties>
                <cucumber.filter.tags>not @ignore</cucumber.filter.tags>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        
        <!-- Parallel Execution -->
        <profile>
            <id>parallel</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>${maven-surefire-plugin.version}</version>
                        <configuration>
                            <parallel>classes</parallel>
                            <threadCount>4</threadCount>
                            <perCoreThreadCount>true</perCoreThreadCount>
                            <includes>
                                <include>**/*RunnerTest.java</include>
                            </includes>
                            <systemPropertyVariables>
                                <cucumber.execution.parallel.enabled>true</cucumber.execution.parallel.enabled>
                                <cucumber.execution.parallel.config.strategy>fixed</cucumber.execution.parallel.config.strategy>
                                <cucumber.execution.parallel.config.fixed.parallelism>4</cucumber.execution.parallel.config.fixed.parallelism>
                                <cucumber.plugin>pretty,html:${project.build.directory}/cucumber-reports/cucumber-html-report.html,json:${project.build.directory}/cucumber-reports/cucumber.json</cucumber.plugin>
                                <cucumber.filter.tags>${cucumber.filter.tags}</cucumber.filter.tags>
                                <environment>${environment}</environment>
                                <browser>${browser}</browser>
                                <headless>${headless}</headless>
                            </systemPropertyVariables>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        
        <!-- CI/CD Profile -->
        <profile>
            <id>ci</id>
            <properties>
                <headless>true</headless>
                <cucumber.filter.tags>not @ignore</cucumber.filter.tags>
            </properties>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>${maven-surefire-plugin.version}</version>
                        <configuration>
                            <parallel>classes</parallel>
                            <threadCount>2</threadCount>
                            <perCoreThreadCount>true</perCoreThreadCount>
                            <includes>
                                <include>**/*RunnerTest.java</include>
                            </includes>
                            <systemPropertyVariables>
                                <cucumber.execution.parallel.enabled>true</cucumber.execution.parallel.enabled>
                                <cucumber.execution.parallel.config.strategy>fixed</cucumber.execution.parallel.config.strategy>
                                <cucumber.execution.parallel.config.fixed.parallelism>2</cucumber.execution.parallel.config.fixed.parallelism>
                                <cucumber.plugin>pretty,html:${project.build.directory}/cucumber-reports/cucumber-html-report.html,json:${project.build.directory}/cucumber-reports/cucumber.json</cucumber.plugin>
                                <cucumber.filter.tags>${cucumber.filter.tags}</cucumber.filter.tags>
                                <environment>${environment}</environment>
                                <browser>${browser}</browser>
                                <headless>${headless}</headless>
                                <video.recording>false</video.recording>
                            </systemPropertyVariables>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        
        <!-- Report Generation Only -->
        <profile>
            <id>report-only</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>net.masterthought</groupId>
                        <artifactId>maven-cucumber-reporting</artifactId>
                        <version>${cucumber-reporting.version}</version>
                        <executions>
                            <execution>
                                <id>execution</id>
                                <phase>verify</phase>
                                <goals>
                                    <goal>generate</goal>
                                </goals>
                                <configuration>
                                    <projectName>${project.name}</projectName>
                                    <outputDirectory>${project.build.directory}/cucumber-reports</outputDirectory>
                                    <inputDirectory>${project.build.directory}/cucumber-reports</inputDirectory>
                                    <jsonFiles>
                                        <param>**/*.json</param>
                                    </jsonFiles>
                                    <checkBuildResult>false</checkBuildResult>
                                    <classificationFiles>
                                        <param>classifications.properties</param>
                                    </classificationFiles>
                                </configuration>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
    
    <repositories>
        <repository>
            <id>central</id>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
        <repository>
            <id>github</id>
            <url>https://maven.pkg.github.com/${github.organization}/*</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
    </repositories>
</project>


templates/projects/selenium/java/bdd/src/test/java/stepdefs/BaseStepDef.java.template
-----------------------------------------------------------------------------------------------

package ${package}.stepdefs;

import io.cucumber.java.After;
import io.cucumber.java.AfterStep;
import io.cucumber.java.Before;
import io.cucumber.java.BeforeStep;
import io.cucumber.java.Scenario;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;

import ${package}.core.config.ConfigurationManager;
import ${package}.core.reporting.CSReporter;
import ${package}.core.utils.CSConstants;
import ${package}.core.utils.CSLogger;
import ${package}.core.utils.CSScreenshotManager;
import ${package}.selenium.java.testng.browser.BrowserManager;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Base Step Definition class that provides common functionality for all step definition classes.
 * This class handles WebDriver initialization, cleanup, and test execution hooks for Cucumber scenarios.
 */
public class BaseStepDef {

    protected WebDriver driver;
    protected CSReporter reporter;
    protected CSScreenshotManager screenshotManager;
    protected Map<String, Object> testContext;
    private static boolean videoRecordingEnabled;
    private static boolean screenshotOnStepEnabled;
    private static boolean screenshotOnFailureEnabled;
    private static String currentScenarioName;
    private static int stepCounter;
    private long scenarioStartTime;
    private static MonteScreenRecorder screenRecorder;
    private static final Object lock = new Object();
    private static boolean recordingInitialized = false;
    
    /**
     * Constructor for BaseStepDef
     */
    public BaseStepDef() {
        testContext = new HashMap<>();
        screenshotManager = CSScreenshotManager.getInstance();
        reporter = CSReporter.getInstance();
        
        // Load configuration settings
        loadConfigSettings();
    }
    
    /**
     * Load configuration settings from the framework configuration
     */
    private void loadConfigSettings() {
        ConfigurationManager configManager = ConfigurationManager.getInstance();
        videoRecordingEnabled = configManager.getFrameworkConfig().isVideoRecordingEnabled();
        screenshotOnStepEnabled = configManager.getFrameworkConfig().isScreenshotOnStepEnabled();
        screenshotOnFailureEnabled = configManager.getFrameworkConfig().isScreenshotOnFailureEnabled();
    }
    
    /**
     * Before hook that runs before each scenario
     * 
     * @param scenario The current Cucumber scenario
     */
    @Before
    public void setUp(Scenario scenario) {
        synchronized (lock) {
            currentScenarioName = scenario.getName().replaceAll("[^a-zA-Z0-9-_]", "_");
            stepCounter = 0;
            scenarioStartTime = System.currentTimeMillis();
            
            // Initialize WebDriver
            driver = BrowserManager.getDriver();
            driver.manage().timeouts().implicitlyWait(ConfigurationManager.getInstance().getFrameworkConfig().getDefaultTimeoutInSeconds(), TimeUnit.SECONDS);
            driver.manage().window().maximize();
            
            // Initialize recording if enabled
            if (videoRecordingEnabled && !recordingInitialized) {
                initializeRecording(currentScenarioName);
            }
            
            // Log scenario start
            CSLogger.info("Starting scenario: " + scenario.getName());
            reporter.startTest(scenario.getName(), scenario.getSourceTagNames().toString());
        }
    }
    
    /**
     * After hook that runs after each scenario
     * 
     * @param scenario The current Cucumber scenario
     */
    @After
    public void tearDown(Scenario scenario) {
        synchronized (lock) {
            try {
                // Take screenshot on failure if enabled
                if (scenario.isFailed() && screenshotOnFailureEnabled) {
                    takeScreenshot(scenario, "FAILURE");
                }
                
                // Stop recording if enabled
                if (videoRecordingEnabled && recordingInitialized) {
                    stopRecording();
                    attachRecordingToReport(scenario);
                }
                
                // Calculate and log execution time
                long executionTime = System.currentTimeMillis() - scenarioStartTime;
                String formattedTime = formatExecutionTime(executionTime);
                CSLogger.info("Scenario: " + scenario.getName() + " completed in " + formattedTime);
                
                // Log scenario result
                if (scenario.isFailed()) {
                    reporter.logFailure("Scenario Failed", scenario.getName() + " - " + getFailureMessage(scenario));
                } else {
                    reporter.logSuccess("Scenario Passed", scenario.getName() + " - Executed in " + formattedTime);
                }
                
                // Complete test in reporter
                reporter.endTest(scenario.getStatus().toString(), executionTime);
                
            } finally {
                // Always clean up WebDriver resources
                if (driver != null) {
                    BrowserManager.quitDriver();
                    driver = null;
                }
            }
        }
    }
    
    /**
     * Before step hook that runs before each step
     * 
     * @param scenario The current Cucumber scenario
     */
    @BeforeStep
    public void beforeStep(Scenario scenario) {
        stepCounter++;
        CSLogger.debug("Executing step " + stepCounter + " of scenario: " + scenario.getName());
    }
    
    /**
     * After step hook that runs after each step
     * 
     * @param scenario The current Cucumber scenario
     */
    @AfterStep
    public void afterStep(Scenario scenario) {
        // Take screenshot after each step if enabled
        if (screenshotOnStepEnabled) {
            takeScreenshot(scenario, "STEP_" + stepCounter);
        }
    }
    
    /**
     * Take a screenshot and attach it to the scenario
     * 
     * @param scenario The current Cucumber scenario
     * @param label Label for the screenshot
     */
    protected void takeScreenshot(Scenario scenario, String label) {
        if (driver instanceof TakesScreenshot) {
            try {
                final byte[] screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
                String timestamp = DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss").format(LocalDateTime.now());
                String screenshotName = currentScenarioName + "_" + label + "_" + timestamp;
                
                // Attach to Cucumber scenario
                scenario.attach(screenshot, "image/png", screenshotName);
                
                // Also save to file system
                String screenshotPath = screenshotManager.saveScreenshot(screenshot, screenshotName);
                CSLogger.info("Screenshot saved: " + screenshotPath);
                
                // Add to report
                reporter.logScreenshot("Screenshot: " + label, screenshotPath);
            } catch (Exception e) {
                CSLogger.error("Failed to capture screenshot: " + e.getMessage(), e);
            }
        }
    }
    
    /**
     * Initialize video recording for the scenario
     * 
     * @param scenarioName Name of the scenario
     */
    protected void initializeRecording(String scenarioName) {
        try {
            // Create recordings directory if it doesn't exist
            Path recordingsDir = Paths.get("target/recordings");
            if (!Files.exists(recordingsDir)) {
                Files.createDirectories(recordingsDir);
            }
            
            // Initialize screen recorder
            String timestamp = DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss").format(LocalDateTime.now());
            String fileName = scenarioName + "_" + timestamp;
            
            // Using reflection to avoid direct dependency on MonteScreenRecorder
            // This allows the framework to work even when video recording is disabled
            if (screenRecorder == null) {
                Class<?> recorderClass = Class.forName("com.github.stephenc.monte.screenrecorder.MonteScreenRecorder");
                screenRecorder = (MonteScreenRecorder) recorderClass
                    .getConstructor(GraphicsConfiguration.class, Rectangle.class, 
                                    Format.class, Format.class, 
                                    boolean.class, File.class)
                    .newInstance(null, null, null, null, false, new File(recordingsDir.toString(), fileName));
            }
            
            screenRecorder.start();
            recordingInitialized = true;
            CSLogger.info("Started video recording for scenario: " + scenarioName);
        } catch (Exception e) {
            CSLogger.error("Failed to initialize video recording: " + e.getMessage(), e);
            recordingInitialized = false;
        }
    }
    
    /**
     * Stop video recording
     */
    protected void stopRecording() {
        if (screenRecorder != null && recordingInitialized) {
            try {
                screenRecorder.stop();
                recordingInitialized = false;
                CSLogger.info("Stopped video recording");
            } catch (Exception e) {
                CSLogger.error("Failed to stop video recording: " + e.getMessage(), e);
            }
        }
    }
    
    /**
     * Attach video recording to the report
     * 
     * @param scenario The current Cucumber scenario
     */
    protected void attachRecordingToReport(Scenario scenario) {
        try {
            Path recordingsDir = Paths.get("target/recordings");
            Files.list(recordingsDir)
                .filter(path -> path.getFileName().toString().startsWith(currentScenarioName))
                .findFirst()
                .ifPresent(videoPath -> {
                    CSLogger.info("Video recording saved: " + videoPath);
                    reporter.logVideo("Video Recording", videoPath.toString());
                });
        } catch (Exception e) {
            CSLogger.error("Failed to attach video recording to report: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get the failure message from the scenario
     * 
     * @param scenario The current Cucumber scenario
     * @return The failure message
     */
    protected String getFailureMessage(Scenario scenario) {
        // This is a workaround as Cucumber doesn't provide direct access to failure messages
        // We extract it from the scenario name or status
        if (scenario.isFailed()) {
            return "Step failed during execution. See logs and screenshots for details.";
        }
        return "Scenario passed successfully";
    }
    
    /**
     * Format execution time in a human-readable format
     * 
     * @param milliseconds Execution time in milliseconds
     * @return Formatted execution time
     */
    protected String formatExecutionTime(long milliseconds) {
        long seconds = TimeUnit.MILLISECONDS.toSeconds(milliseconds) % 60;
        long minutes = TimeUnit.MILLISECONDS.toMinutes(milliseconds) % 60;
        long hours = TimeUnit.MILLISECONDS.toHours(milliseconds);
        
        if (hours > 0) {
            return String.format("%dh %dm %ds", hours, minutes, seconds);
        } else if (minutes > 0) {
            return String.format("%dm %ds", minutes, seconds);
        } else {
            return String.format("%ds", seconds);
        }
    }
    
    /**
     * Get the current WebDriver instance
     * 
     * @return The WebDriver instance
     */
    public WebDriver getDriver() {
        return driver;
    }
    
    /**
     * Store a value in the test context
     * 
     * @param key The key
     * @param value The value
     */
    public void storeInContext(String key, Object value) {
        testContext.put(key, value);
    }
    
    /**
     * Retrieve a value from the test context
     * 
     * @param key The key
     * @param <T> The type of the value
     * @return The value
     */
    @SuppressWarnings("unchecked")
    public <T> T getFromContext(String key) {
        return (T) testContext.get(key);
    }
    
    /**
     * Check if a key exists in the test context
     * 
     * @param key The key
     * @return True if the key exists, false otherwise
     */
    public boolean hasInContext(String key) {
        return testContext.containsKey(key);
    }
    
    /**
     * Remove a value from the test context
     * 
     * @param key The key
     */
    public void removeFromContext(String key) {
        testContext.remove(key);
    }
    
    /**
     * Clear the test context
     */
    public void clearContext() {
        testContext.clear();
    }
}


templates/projects/selenium/java/bdd/src/test/resources/features/sample.feature.template
----------------------------------------------------------------------------------------------------

Feature: ${feature.name}
  As a ${feature.userRole}
  I want to ${feature.userWant}
  So that ${feature.userBenefit}

  Background:
    Given the user is on the login page
    And the system is in a clean state

  @smoke @regression
  Scenario: Successful login with valid credentials
    When the user enters username "validuser" and password "validpassword"
    And the user clicks the login button
    Then the user should be redirected to the dashboard
    And the user should see a welcome message "Welcome, Valid User!"
    And the dashboard should display user-specific data

  @regression
  Scenario Outline: Failed login with invalid credentials
    When the user enters username "<username>" and password "<password>"
    And the user clicks the login button
    Then the user should remain on the login page
    And the user should see an error message "<error_message>"

    Examples:
      | username      | password      | error_message                   |
      | invaliduser   | validpassword | Invalid username or password    |
      | validuser     | invalidpassword | Invalid username or password  |
      | ""            | validpassword | Username cannot be empty        |
      | validuser     | ""            | Password cannot be empty        |
      | "!@#$%^"      | validpassword | Username contains invalid characters |

  @regression
  Scenario: User can reset password
    When the user clicks on the "Forgot Password" link
    Then the user should be redirected to the password reset page
    When the user enters their registered email "user@example.com"
    And the user clicks the reset button
    Then the user should see a confirmation message "Password reset instructions sent to your email"
    And the system should send a password reset email to "user@example.com"

  @smoke @regression
  Scenario: User can logout after successful login
    Given the user is logged in with username "validuser" and password "validpassword"
    When the user clicks on the profile dropdown
    And the user selects the logout option
    Then the user should be logged out
    And the user should be redirected to the login page
    And the user should see a message "You have been successfully logged out"

  @regression
  Scenario: Session expires after period of inactivity
    Given the user is logged in with username "validuser" and password "validpassword"
    When the session is inactive for 30 minutes
    And the user attempts to navigate to a secured page
    Then the user should be redirected to the login page
    And the user should see a message "Your session has expired. Please log in again."

  @regression
  Scenario: Brute force protection prevents multiple failed login attempts
    When the user attempts to log in with invalid credentials 5 times
    Then the account should be temporarily locked
    And the user should see a message "Account temporarily locked due to multiple failed login attempts"
    And the user should not be able to log in with correct credentials
    When the user waits for 10 minutes
    Then the user should be able to log in with correct credentials

  @wip @ignore
  Scenario: Social media login integration
    When the user clicks on "Login with Google" button
    Then the user should be redirected to Google login page
    When the user completes the Google authentication
    Then the user should be logged in
    And the user should be redirected to the dashboard



templates/projects/selenium/java/bdd/README.md.templace
--------------------------------------------------------

# ${project.name} - Selenium Java BDD Test Automation Framework

## Overview

This test automation framework combines Selenium WebDriver with Cucumber BDD to create powerful, maintainable, and business-friendly automated tests. Built with CSTestForge, it offers enhanced capabilities including AI-powered element recognition, self-healing locators, and comprehensive reporting.

## Table of Contents

- [Project Structure](#project-structure)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Configuration](#configuration)
- [Writing Tests](#writing-tests)
  - [Feature Files](#feature-files)
  - [Step Definitions](#step-definitions)
  - [Page Objects](#page-objects)
  - [Test Data Management](#test-data-management)
- [Running Tests](#running-tests)
  - [Command Line Execution](#command-line-execution)
  - [IDE Integration](#ide-integration)
  - [Test Profiles](#test-profiles)
  - [Parallel Execution](#parallel-execution)
- [Reporting](#reporting)
- [Advanced Features](#advanced-features)
  - [Self-Healing Locators](#self-healing-locators)
  - [AI-Enhanced Element Recognition](#ai-enhanced-element-recognition)
  - [Video Recording](#video-recording)
  - [Automated Screenshot Capture](#automated-screenshot-capture)
  - [API Testing Integration](#api-testing-integration)
- [CI/CD Integration](#cicd-integration)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)

## Project Structure

```
${project.name}/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── ${package.path}/
│   │   │       ├── core/
│   │   │       │   ├── config/
│   │   │       │   ├── utils/
│   │   │       │   ├── data/
│   │   │       │   ├── reporting/
│   │   │       │   └── ai/
│   │   │       └── selenium/
│   │   │           ├── browser/
│   │   │           ├── element/
│   │   │           └── wait/
│   │   └── resources/
│   │       ├── config/
│   │       │   ├── framework-config.properties
│   │       │   └── environment/
│   │       │       ├── dev.properties
│   │       │       ├── qa.properties
│   │       │       └── prod.properties
│   │       └── logback.xml
│   └── test/
│       ├── java/
│       │   └── ${package.path}/
│       │       ├── pages/
│       │       │   ├── BasePage.java
│       │       │   ├── LoginPage.java
│       │       │   └── ... (other page objects)
│       │       ├── stepdefs/
│       │       │   ├── BaseStepDef.java
│       │       │   ├── LoginStepDef.java
│       │       │   └── ... (other step definitions)
│       │       ├── runners/
│       │       │   ├── TestRunner.java
│       │       │   └── ParallelTestRunner.java
│       │       └── utils/
│       │           ├── TestContext.java
│       │           └── Hooks.java
│       └── resources/
│           ├── features/
│           │   ├── login.feature
│           │   └── ... (other feature files)
│           ├── testdata/
│           │   ├── users.json
│           │   ├── products.xlsx
│           │   └── ... (other test data)
│           └── cucumber.properties
├── target/
│   └── reports/
│       ├── cucumber-html-reports/
│       ├── screenshots/
│       └── videos/
├── pom.xml
├── README.md
└── .gitignore
```

## Prerequisites

- Java 17 or higher
- Maven 3.8.0 or higher
- Chrome, Firefox, or Edge browser
- IDE (IntelliJ IDEA, Eclipse, or VS Code recommended)

## Installation

1. Clone this repository:
   ```bash
   git clone https://your-repository-url/${project.name}.git
   cd ${project.name}
   ```

2. Install dependencies:
   ```bash
   mvn clean install -DskipTests
   ```

## Configuration

The framework uses a hierarchical configuration system:

1. **Base Configuration**: `src/main/resources/config/framework-config.properties`
2. **Environment-Specific Configurations**: `src/main/resources/config/environment/*.properties`
3. **Runtime Configuration**: System properties passed via command line

Key configuration properties:

```properties
# Framework Configuration
framework.browser=chrome                    # chrome, firefox, edge, safari
framework.headless=false                    # true/false
framework.timeout.default=30                # Default timeout in seconds
framework.screenshot.onFailure=true         # Capture screenshots on test failure
framework.screenshot.onStep=false           # Capture screenshots after each step
framework.video.enabled=false               # Enable video recording
framework.ai.smartLocators=true             # Enable AI-powered locators
framework.ai.selfHealing=true               # Enable self-healing locators

# Application Configuration
app.baseUrl=https://your-application-url.com
app.username=testuser
app.password=TestPassword123
```

To specify the environment:

```bash
mvn test -Denvironment=qa
```

## Writing Tests

### Feature Files

Feature files are written in Gherkin syntax and stored in `src/test/resources/features/`. They describe the behavior of the application from a business perspective:

```gherkin
Feature: User Authentication
  As a user of the application
  I want to log in with my credentials
  So that I can access my account

  Background:
    Given the user is on the login page

  @smoke @regression
  Scenario: Successful login with valid credentials
    When the user enters username "validuser" and password "validpassword"
    And the user clicks the login button
    Then the user should be redirected to the dashboard
    And the user should see a welcome message "Welcome, Valid User!"

  @regression
  Scenario Outline: Failed login with invalid credentials
    When the user enters username "<username>" and password "<password>"
    And the user clicks the login button
    Then the user should see an error message "<error_message>"

    Examples:
      | username    | password      | error_message                |
      | invaliduser | validpassword | Invalid username or password |
      | validuser   | invalidpass   | Invalid username or password |
      | ""          | validpassword | Username cannot be empty     |
```

### Step Definitions

Step definitions connect the Gherkin steps to Java code:

```java
package ${package}.stepdefs;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import ${package}.pages.LoginPage;
import ${package}.pages.DashboardPage;
import org.junit.Assert;

public class LoginStepDef extends BaseStepDef {
    
    private LoginPage loginPage;
    private DashboardPage dashboardPage;
    
    public LoginStepDef() {
        loginPage = new LoginPage();
        dashboardPage = new DashboardPage();
    }
    
    @Given("the user is on the login page")
    public void userIsOnLoginPage() {
        loginPage.navigateTo();
    }
    
    @When("the user enters username {string} and password {string}")
    public void userEntersCredentials(String username, String password) {
        loginPage.enterUsername(username)
                 .enterPassword(password);
    }
    
    @When("the user clicks the login button")
    public void userClicksLoginButton() {
        loginPage.clickLoginButton();
    }
    
    @Then("the user should be redirected to the dashboard")
    public void userShouldBeRedirectedToDashboard() {
        Assert.assertTrue("User should be on dashboard page", 
                          dashboardPage.isPageLoaded());
    }
    
    @Then("the user should see a welcome message {string}")
    public void userShouldSeeWelcomeMessage(String expectedMessage) {
        String actualMessage = dashboardPage.getWelcomeMessage();
        Assert.assertEquals("Welcome message should match", 
                            expectedMessage, actualMessage);
    }
    
    @Then("the user should see an error message {string}")
    public void userShouldSeeErrorMessage(String expectedError) {
        String actualError = loginPage.getErrorMessage();
        Assert.assertEquals("Error message should match", 
                            expectedError, actualError);
    }
}
```

### Page Objects

Page objects encapsulate page interactions and elements:

```java
package ${package}.pages;

import org.openqa.selenium.By;
import ${package}.selenium.java.testng.annotations.CSFindBy;

public class LoginPage extends BasePage {
    
    @CSFindBy(id = "username")
    private By usernameField;
    
    @CSFindBy(id = "password")
    private By passwordField;
    
    @CSFindBy(css = "button[type='submit']")
    private By loginButton;
    
    @CSFindBy(css = ".error-message")
    private By errorMessage;
    
    public LoginPage() {
        super();
    }
    
    public LoginPage navigateTo() {
        driver.get(ConfigurationManager.getInstance()
                    .getAppConfig().getBaseUrl() + "/login");
        waitForPageLoad();
        return this;
    }
    
    public LoginPage enterUsername(String username) {
        type(usernameField, username);
        return this;
    }
    
    public LoginPage enterPassword(String password) {
        type(passwordField, password);
        return this;
    }
    
    public void clickLoginButton() {
        click(loginButton);
    }
    
    public String getErrorMessage() {
        return getText(errorMessage);
    }
}
```

### Test Data Management

This framework supports multiple data sources:

1. **Feature File Examples**: Use Scenario Outline with Examples tables
2. **JSON Files**: `src/test/resources/testdata/*.json`
3. **Excel Files**: `src/test/resources/testdata/*.xlsx`
4. **CSV Files**: `src/test/resources/testdata/*.csv`
5. **Database**: Connect to MySQL, PostgreSQL, or other databases

Example with external data:

```java
@When("the user logs in with a valid user")
public void loginWithValidUser() {
    // Load from JSON
    User user = dataProvider.getUser("validUser");
    
    loginPage.enterUsername(user.getUsername())
             .enterPassword(user.getPassword())
             .clickLoginButton();
}
```

## Running Tests

### Command Line Execution

Run all tests:

```bash
mvn clean test
```

Run specific tags:

```bash
mvn clean test -Dcucumber.filter.tags="@smoke"
```

Run with specific browser and environment:

```bash
mvn clean test -Dbrowser=firefox -Denvironment=qa
```

### IDE Integration

#### IntelliJ IDEA

1. Install the Cucumber for Java plugin
2. Right-click on a feature file or TestRunner class
3. Select "Run" or "Debug"

#### Eclipse

1. Install the Cucumber Eclipse Plugin
2. Right-click on a feature file or TestRunner class
3. Select "Run As" > "Cucumber Feature" or "JUnit Test"

### Test Profiles

Predefined Maven profiles are available:

```bash
# Run smoke tests in Chrome on QA environment
mvn clean test -P smoke,chrome,qa

# Run regression tests in headless mode
mvn clean test -P regression,headless

# Run parallel tests
mvn clean test -P parallel
```

### Parallel Execution

Enable parallel execution:

```bash
mvn clean test -P parallel
```

Configure parallel threads in `pom.xml`:

```xml
<cucumber.execution.parallel.config.fixed.parallelism>4</cucumber.execution.parallel.config.fixed.parallelism>
```

## Reporting

This framework generates the following reports:

1. **Cucumber HTML Reports**: `target/cucumber-reports/advanced-reports/cucumber-html-reports/overview-features.html`
2. **JSON Reports**: `target/cucumber-reports/cucumber.json`
3. **Screenshots**: `target/reports/screenshots/`
4. **Videos**: `target/reports/videos/`

To generate reports after test execution:

```bash
mvn verify
```

## Advanced Features

### Self-Healing Locators

The framework includes self-healing locators that automatically recover from broken element locators during test execution:

```properties
# Enable in framework-config.properties
framework.ai.selfHealing=true
```

The self-healing mechanism will:
1. Try alternative locator strategies when an element is not found
2. Keep track of successful locators for each element
3. Learn from failures and suggest better locators
4. Save a history of healed locators for future test runs

### AI-Enhanced Element Recognition

AI algorithms for improved element detection:

```properties
# Enable in framework-config.properties
framework.ai.smartLocators=true
```

Benefits:
- More robust locators that resist UI changes
- Intelligent element identification based on visible text and context
- Automatic ranking of locator strategies by reliability

### Video Recording

Automatically record test execution:

```properties
# Enable in framework-config.properties
framework.video.enabled=true
```

Videos are saved to `target/reports/videos/` and attached to test reports.

### Automated Screenshot Capture

Configure screenshot capture behavior:

```properties
# Capture on failure only
framework.screenshot.onFailure=true
framework.screenshot.onStep=false

# Capture after each step
framework.screenshot.onStep=true
```

### API Testing Integration

The framework integrates with REST Assured for API testing within the BDD flow:

```java
@When("the user retrieves user profile via API")
public void getUserProfileViaApi() {
    response = given()
        .baseUri(apiBaseUrl)
        .header("Authorization", "Bearer " + authToken)
        .when()
        .get("/user/profile")
        .then()
        .statusCode(200)
        .extract().response();
    
    // Store in context for later steps
    storeInContext("userProfileResponse", response);
}
```

## CI/CD Integration

The framework includes configuration files for popular CI/CD platforms:

- **Azure DevOps**: `azure-pipelines.yml`
- **GitHub Actions**: `.github/workflows/test.yml`
- **Jenkins**: `Jenkinsfile`

Example GitHub Actions workflow:

```yaml
name: BDD Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    - name: Run Tests
      run: mvn clean test -P smoke,chrome,headless,ci
    - name: Generate Reports
      if: always()
      run: mvn verify -DskipTests
    - name: Upload Reports
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: cucumber-reports
        path: target/cucumber-reports
```

## Best Practices

1. **Keep features business-focused**: Write scenarios from a user's perspective
2. **One scenario per behavior**: Each scenario should test one specific behavior
3. **Consistent naming conventions**: Use descriptive names for features, scenarios, and steps
4. **Maintain test independence**: Tests should not depend on other tests
5. **Manage test data**: Create fresh test data or restore to a known state before each test
6. **Use appropriate tags**: Organize tests with tags (@smoke, @regression, etc.)
7. **Keep step definitions reusable**: Create generic steps that can be used across features
8. **Page Object encapsulation**: Don't expose WebElement fields directly
9. **Centralize configuration**: Use the configuration system rather than hardcoding values
10. **Comprehensive reporting**: Include screenshots, logs, and videos for failed tests

## Troubleshooting

### Common Issues

1. **Element not found exceptions**
   - Increase default timeout in framework-config.properties
   - Check if element locators are correct
   - Enable self-healing locators with `framework.ai.selfHealing=true`

2. **Flaky tests**
   - Add appropriate waits
   - Improve locator strategies
   - Check for timing issues or race conditions
   - Enable self-healing with `framework.ai.selfHealing=true`

3. **Report generation failures**
   - Ensure cucumber.properties is configured correctly
   - Verify JSON output is being generated
   - Check file permissions for target directory

### Debug Mode

Enable debug mode for more verbose logging:

```properties
# In logback.xml or command line
-Dlogging.level.${package}=DEBUG
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run tests and ensure they pass
5. Submit a pull request

---

Generated by CSTestForge Framework v1.0.0


templates/projects/selenium/typescript/testng/package.json.template
-------------------------------------------------------------


{
  "name": "${project.name}",
  "version": "${project.version}",
  "description": "${project.description}",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "clean": "rimraf ./dist ./coverage ./reports",
    "lint": "eslint --ext .ts ./src",
    "format": "prettier --write \"src/**/*.ts\"",
    "prebuild": "npm run clean && npm run format && npm run lint",
    "pretest": "npm run build",
    "test": "cross-env NODE_ENV=test ts-node ./src/runners/testng-runner.ts",
    "test:smoke": "cross-env NODE_ENV=test TAGS=smoke ts-node ./src/runners/testng-runner.ts",
    "test:regression": "cross-env NODE_ENV=test TAGS=regression ts-node ./src/runners/testng-runner.ts",
    "test:parallel": "cross-env NODE_ENV=test PARALLEL=true ts-node ./src/runners/testng-runner.ts",
    "test:chrome": "cross-env NODE_ENV=test BROWSER=chrome ts-node ./src/runners/testng-runner.ts",
    "test:firefox": "cross-env NODE_ENV=test BROWSER=firefox ts-node ./src/runners/testng-runner.ts",
    "test:edge": "cross-env NODE_ENV=test BROWSER=edge ts-node ./src/runners/testng-runner.ts",
    "test:headless": "cross-env NODE_ENV=test HEADLESS=true ts-node ./src/runners/testng-runner.ts",
    "test:ci": "cross-env NODE_ENV=test HEADLESS=true PARALLEL=true ts-node ./src/runners/testng-runner.ts",
    "report": "ts-node ./src/utils/generate-report.ts",
    "doc": "typedoc --out docs src",
    "prepare": "husky install"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/${github.organization}/${project.name}.git"
  },
  "keywords": [
    "selenium",
    "webdriver",
    "testing",
    "automation",
    "testng",
    "typescript",
    "cstestforge"
  ],
  "author": "${author.name} <${author.email}>",
  "license": "${license}",
  "bugs": {
    "url": "https://github.com/${github.organization}/${project.name}/issues"
  },
  "homepage": "https://github.com/${github.organization}/${project.name}#readme",
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  },
  "devDependencies": {
    "@types/chai": "^4.3.6",
    "@types/chai-as-promised": "^7.1.6",
    "@types/express": "^4.17.17",
    "@types/fs-extra": "^11.0.1",
    "@types/lodash": "^4.14.198",
    "@types/mocha": "^10.0.1",
    "@types/node": "^20.6.3",
    "@types/selenium-webdriver": "^4.1.16",
    "@types/uuid": "^9.0.4",
    "@typescript-eslint/eslint-plugin": "^6.7.2",
    "@typescript-eslint/parser": "^6.7.2",
    "chai": "^4.3.8",
    "chai-as-promised": "^7.1.1",
    "cross-env": "^7.0.3",
    "eslint": "^8.49.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "husky": "^8.0.3",
    "lint-staged": "^14.0.1",
    "mocha": "^10.2.0",
    "prettier": "^3.0.3",
    "rimraf": "^5.0.1",
    "ts-node": "^10.9.1",
    "typedoc": "^0.25.1",
    "typescript": "~5.2.2"
  },
  "dependencies": {
    "ajv": "^8.12.0",
    "axios": "^1.5.0",
    "chalk": "^4.1.2",
    "chromedriver": "^116.0.0",
    "config": "^3.3.9",
    "dayjs": "^1.11.9",
    "deep-equal": "^2.2.2",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "exceljs": "^4.3.0",
    "fast-csv": "^4.3.6",
    "fs-extra": "^11.1.1",
    "geckodriver": "^4.2.1",
    "js-yaml": "^4.1.0",
    "jsonpath": "^1.1.1",
    "lodash": "^4.17.21",
    "log4js": "^6.9.1",
    "msedgedriver": "^91.0.0",
    "reflect-metadata": "^0.1.13",
    "selenium-webdriver": "^4.12.0",
    "sqlite3": "^5.1.6",
    "uuid": "^9.0.1",
    "winston": "^3.10.0"
  },
  "lint-staged": {
    "*.ts": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md}": [
      "prettier --write"
    ]
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "config": {
    "browser": "chrome",
    "headless": false,
    "baseUrl": "https://your-application-url.com",
    "implicitTimeout": 10000,
    "explicitTimeout": 30000,
    "screenshotOnFailure": true,
    "screenshotOnStep": false,
    "videoRecording": false,
    "aiSmartLocators": true,
    "aiSelfHealing": true,
    "reportDir": "./reports",
    "dataDir": "./src/test/resources/testdata",
    "environments": {
      "dev": {
        "baseUrl": "https://dev.your-application-url.com",
        "apiBaseUrl": "https://dev-api.your-application-url.com",
        "username": "devuser",
        "password": "devpassword"
      },
      "qa": {
        "baseUrl": "https://qa.your-application-url.com",
        "apiBaseUrl": "https://qa-api.your-application-url.com",
        "username": "qauser",
        "password": "qapassword"
      },
      "stage": {
        "baseUrl": "https://stage.your-application-url.com",
        "apiBaseUrl": "https://stage-api.your-application-url.com",
        "username": "stageuser",
        "password": "stagepassword"
      },
      "prod": {
        "baseUrl": "https://your-application-url.com",
        "apiBaseUrl": "https://api.your-application-url.com",
        "username": "",
        "password": ""
      }
    }
  }
}


templates/projects/selenium/typescript/testng/tsconfig.json templage
---------------------------------------------------------------------------

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["es2020", "dom"],
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "moduleResolution": "node",
    "baseUrl": "./",
    "paths": {
      "@core/*": ["src/core/*"],
      "@selenium/*": ["src/selenium/*"],
      "@page-objects/*": ["src/test/pages/*"],
      "@tests/*": ["src/test/tests/*"],
      "@utils/*": ["src/utils/*"],
      "@testdata/*": ["src/test/resources/testdata/*"],
      "@config/*": ["src/core/config/*"]
    },
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "importHelpers": true,
    "pretty": true
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.json"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "reports",
    "coverage",
    "docs"
  ],
  "ts-node": {
    "require": ["tsconfig-paths/register"]
  }
}

templates/projects/selenium/typescript/testng/README.md.templage
-----------------------------------------------------------------------

# ${project.name} - Selenium TypeScript Test Automation Framework

## Overview

This test automation framework provides a robust, maintainable, and scalable solution for web application testing using Selenium WebDriver with TypeScript. Built with the CSTestForge framework, it implements the TestNG testing approach with advanced features such as AI-powered element recognition, self-healing locators, and comprehensive reporting.

## Table of Contents

- [Features](#features)
- [Project Structure](#project-structure)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Configuration](#configuration)
- [Writing Tests](#writing-tests)
  - [Test Classes](#test-classes)
  - [Page Objects](#page-objects)
  - [Data-Driven Testing](#data-driven-testing)
  - [Test Annotations](#test-annotations)
- [Running Tests](#running-tests)
- [Reporting](#reporting)
- [Advanced Features](#advanced-features)
- [CI/CD Integration](#cicd-integration)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Features

- **TypeScript Implementation**: Strongly-typed test code for improved maintainability and IDE support
- **TestNG Testing Approach**: Structured test classes with test annotations and lifecycle hooks
- **Page Object Model**: Enhanced page objects with fluent API and self-healing locators
- **Multi-Browser Support**: Run tests on Chrome, Firefox, Edge, and Safari
- **Smart Element Location**: AI-powered element identification with alternative locator strategies
- **Self-Healing Capabilities**: Automatic recovery from broken element locators
- **Parallel Execution**: Run tests in parallel to reduce execution time
- **Comprehensive Reporting**: Detailed reports with screenshots, videos, and timing information
- **Data-Driven Testing**: Support for multiple data sources including JSON, Excel, and CSV
- **Environment Management**: Easy configuration for different environments (dev, qa, staging, prod)
- **CI/CD Integration**: Built-in support for common CI/CD platforms

## Project Structure

```
${project.name}/
├── src/
│   ├── core/
│   │   ├── config/
│   │   │   ├── ConfigurationManager.ts
│   │   │   ├── EnvironmentConfig.ts
│   │   │   └── FrameworkConfig.ts
│   │   ├── utils/
│   │   │   ├── DateUtils.ts
│   │   │   ├── FileUtils.ts
│   │   │   ├── TextUtils.ts
│   │   │   ├── ScreenshotManager.ts
│   │   │   ├── Logger.ts
│   │   │   └── Constants.ts
│   │   ├── data/
│   │   │   ├── DataProvider.ts
│   │   │   ├── DataSourceFactory.ts
│   │   │   └── sources/
│   │   │       ├── JsonDataSource.ts
│   │   │       ├── ExcelDataSource.ts
│   │   │       ├── CsvDataSource.ts
│   │   │       └── DatabaseDataSource.ts
│   │   ├── reporting/
│   │   │   ├── Reporter.ts
│   │   │   ├── HtmlReportGenerator.ts
│   │   │   ├── TestResult.ts
│   │   │   ├── TestStep.ts
│   │   │   └── listeners/
│   │   │       └── TestListener.ts
│   │   └── ai/
│   │       ├── ElementRecognitionService.ts
│   │       ├── SmartLocatorService.ts
│   │       └── SelfHealingLocatorService.ts
│   ├── selenium/
│   │   ├── browser/
│   │   │   ├── BrowserManager.ts
│   │   │   ├── CapabilityManager.ts
│   │   │   └── WebDriverFactory.ts
│   │   ├── element/
│   │   │   ├── CSElement.ts
│   │   │   ├── CSElementList.ts
│   │   │   ├── CSSelect.ts
│   │   │   ├── CSForm.ts
│   │   │   └── CSTable.ts
│   │   └── wait/
│   │       ├── WaitStrategy.ts
│   │       ├── VisibilityWait.ts
│   │       ├── ClickableWait.ts
│   │       ├── TextWait.ts
│   │       └── WaitFactory.ts
│   ├── test/
│   │   ├── pages/
│   │   │   ├── BasePage.ts
│   │   │   ├── LoginPage.ts
│   │   │   ├── DashboardPage.ts
│   │   │   └── ... (other page objects)
│   │   ├── tests/
│   │   │   ├── BaseTest.ts
│   │   │   ├── LoginTest.ts
│   │   │   └── ... (other test classes)
│   │   └── resources/
│   │       └── testdata/
│   │           ├── users.json
│   │           ├── products.xlsx
│   │           └── ... (other test data)
│   ├── runners/
│   │   ├── testng-runner.ts
│   │   └── parallel-runner.ts
│   └── utils/
│       ├── generate-report.ts
│       └── test-utils.ts
├── reports/
│   ├── html/
│   ├── screenshots/
│   └── videos/
├── package.json
├── tsconfig.json
├── .eslintrc.json
├── .prettierrc
├── .gitignore
└── README.md
```

## Prerequisites

- Node.js (v16 or higher)
- npm (v8 or higher)
- Chrome, Firefox, or Edge browser
- TypeScript knowledge
- Selenium WebDriver knowledge

## Installation

1. Clone this repository:
   ```bash
   git clone https://github.com/${github.organization}/${project.name}.git
   cd ${project.name}
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Build the project:
   ```bash
   npm run build
   ```

## Configuration

The framework uses a configuration system defined in the `package.json` file under the `config` section. Environment-specific configurations are stored in the `environments` object.

You can override configuration values using:

1. Environment variables
2. Command line arguments
3. `.env` file in the project root

Example configuration:

```json
"config": {
  "browser": "chrome",
  "headless": false,
  "baseUrl": "https://your-application-url.com",
  "implicitTimeout": 10000,
  "explicitTimeout": 30000,
  "screenshotOnFailure": true,
  "screenshotOnStep": false,
  "videoRecording": false,
  "aiSmartLocators": true,
  "aiSelfHealing": true,
  "environments": {
    "dev": {
      "baseUrl": "https://dev.your-application-url.com"
    },
    "qa": {
      "baseUrl": "https://qa.your-application-url.com"
    }
  }
}
```

To run tests with a specific configuration:

```bash
# Using environment variable
NODE_ENV=qa npm test

# Using command line arguments
npm test -- --browser=firefox --headless=true
```

## Writing Tests

### Test Classes

Test classes should extend the `BaseTest` class and use the `@TestClass` and `@Test` decorators:

```typescript
import { TestClass, Test, BeforeTest, AfterTest } from '@core/testng';
import { BaseTest } from '@tests/BaseTest';
import { LoginPage } from '@page-objects/LoginPage';
import { DashboardPage } from '@page-objects/DashboardPage';
import { Assert } from '@core/assertions';

@TestClass('Login Tests')
export class LoginTest extends BaseTest {
  private loginPage!: LoginPage;
  private dashboardPage!: DashboardPage;

  @BeforeTest
  public async setUp(): Promise<void> {
    this.loginPage = new LoginPage();
    this.dashboardPage = new DashboardPage();
    await this.loginPage.navigateTo();
  }

  @Test('Verify successful login with valid credentials')
  public async testValidLogin(): Promise<void> {
    await this.loginPage
      .enterUsername('validuser')
      .enterPassword('validpassword')
      .clickLoginButton();

    Assert.isTrue(
      await this.dashboardPage.isUserLoggedIn(),
      'User should be logged in'
    );
    
    const welcomeMessage = await this.dashboardPage.getWelcomeMessage();
    Assert.equals(
      welcomeMessage,
      'Welcome, validuser!',
      'Welcome message should match'
    );
  }

  @Test('Verify login fails with invalid credentials')
  public async testInvalidLogin(): Promise<void> {
    await this.loginPage
      .enterUsername('invaliduser')
      .enterPassword('invalidpassword')
      .clickLoginButton();

    Assert.isTrue(
      await this.loginPage.isErrorMessageDisplayed(),
      'Error message should be displayed'
    );
    
    const errorMessage = await this.loginPage.getErrorMessage();
    Assert.equals(
      errorMessage,
      'Invalid username or password',
      'Error message should match'
    );
  }

  @AfterTest
  public async tearDown(): Promise<void> {
    await this.loginPage.logout();
  }
}
```

### Page Objects

Page objects should extend the `BasePage` class and use a fluent API:

```typescript
import { BasePage } from '@page-objects/BasePage';
import { CSElement } from '@selenium/element/CSElement';
import { By } from 'selenium-webdriver';
import { CSFindBy } from '@core/annotations';

export class LoginPage extends BasePage {
  @CSFindBy({ id: 'username' })
  private usernameField!: CSElement;

  @CSFindBy({ id: 'password' })
  private passwordField!: CSElement;

  @CSFindBy({ css: 'button[type="submit"]' })
  private loginButton!: CSElement;

  @CSFindBy({ css: '.error-message' })
  private errorMessage!: CSElement;

  constructor() {
    super();
  }

  public async navigateTo(): Promise<LoginPage> {
    await this.driver.get(`${this.config.baseUrl}/login`);
    await this.waitForPageLoad();
    return this;
  }

  public async enterUsername(username: string): Promise<LoginPage> {
    await this.usernameField.clear();
    await this.usernameField.sendKeys(username);
    return this;
  }

  public async enterPassword(password: string): Promise<LoginPage> {
    await this.passwordField.clear();
    await this.passwordField.sendKeys(password);
    return this;
  }

  public async clickLoginButton(): Promise<void> {
    await this.loginButton.click();
  }

  public async isErrorMessageDisplayed(): Promise<boolean> {
    return await this.errorMessage.isDisplayed();
  }

  public async getErrorMessage(): Promise<string> {
    return await this.errorMessage.getText();
  }

  public async login(username: string, password: string): Promise<void> {
    await this.enterUsername(username);
    await this.enterPassword(password);
    await this.clickLoginButton();
  }

  public async logout(): Promise<void> {
    // Implementation of logout
  }
}
```

### Data-Driven Testing

Use the `@DataProvider` decorator for data-driven tests:

```typescript
import { TestClass, Test, DataProvider } from '@core/testng';
import { BaseTest } from '@tests/BaseTest';
import { LoginPage } from '@page-objects/LoginPage';
import { Assert } from '@core/assertions';

@TestClass('Data Driven Login Tests')
export class DataDrivenLoginTest extends BaseTest {
  private loginPage!: LoginPage;

  @BeforeTest
  public async setUp(): Promise<void> {
    this.loginPage = new LoginPage();
    await this.loginPage.navigateTo();
  }

  @DataProvider('loginData')
  public getLoginData(): any[][] {
    return [
      ['validuser', 'validpassword', true, 'Welcome, validuser!'],
      ['invaliduser', 'invalidpassword', false, 'Invalid username or password'],
      ['', 'validpassword', false, 'Username cannot be empty'],
      ['validuser', '', false, 'Password cannot be empty']
    ];
  }

  @Test('Test login with different credentials', { dataProvider: 'loginData' })
  public async testLogin(
    username: string, 
    password: string, 
    expectSuccess: boolean, 
    expectedMessage: string
  ): Promise<void> {
    await this.loginPage
      .enterUsername(username)
      .enterPassword(password)
      .clickLoginButton();

    if (expectSuccess) {
      const dashboardPage = new DashboardPage();
      Assert.isTrue(
        await dashboardPage.isUserLoggedIn(), 
        'User should be logged in'
      );
      const welcomeMessage = await dashboardPage.getWelcomeMessage();
      Assert.equals(
        welcomeMessage, 
        expectedMessage, 
        'Welcome message should match'
      );
    } else {
      Assert.isTrue(
        await this.loginPage.isErrorMessageDisplayed(), 
        'Error message should be displayed'
      );
      const errorMessage = await this.loginPage.getErrorMessage();
      Assert.equals(
        errorMessage, 
        expectedMessage, 
        'Error message should match'
      );
    }
  }
}
```

You can also use external data sources:

```typescript
@DataProvider('usersFromJson')
public async getUsersFromJson(): Promise<any[][]> {
  const dataSource = DataSourceFactory.createDataSource('json', 'src/test/resources/testdata/users.json');
  const users = await dataSource.getData();
  return users.map(user => [user.username, user.password, user.expectSuccess, user.expectedMessage]);
}
```

### Test Annotations

The framework provides TestNG-inspired annotations:

- `@TestClass(name: string)`: Marks a class as a test class
- `@Test(name: string, options?: TestOptions)`: Marks a method as a test method
- `@BeforeTest`: Marks a method to run before each test method
- `@AfterTest`: Marks a method to run after each test method
- `@BeforeClass`: Marks a method to run once before any test method in the class
- `@AfterClass`: Marks a method to run once after all test methods in the class
- `@DataProvider(name: string)`: Marks a method as a data provider
- `@CSFindBy(locator: Locator)`: Marks a field as a web element with smart locator support

## Running Tests

To run all tests:

```bash
npm test
```

To run specific test groups:

```bash
npm run test:smoke
```

To run tests in a specific browser:

```bash
npm run test:chrome
npm run test:firefox
npm run test:edge
```

To run tests in headless mode:

```bash
npm run test:headless
```

To run tests in parallel:

```bash
npm run test:parallel
```

To run tests in CI environment:

```bash
npm run test:ci
```

## Reporting

The framework generates detailed HTML reports with screenshots, logs, and performance metrics. Reports are created in the `reports` directory after test execution.

To generate the report after test execution:

```bash
npm run report
```

The report includes:

- Test summary with pass/fail statistics
- Detailed test results with steps
- Screenshots for failures and steps (if enabled)
- Execution time and performance metrics
- Environment and browser information

## Advanced Features

### Self-Healing Locators

The framework includes self-healing locators that automatically recover from broken element locators during test execution:

```typescript
// In package.json config
"aiSelfHealing": true

// In your test code
const element = await this.page.findElement(By.id('login-button'));
```

If the locator is broken, the framework will:
1. Try alternative locator strategies
2. Use AI-powered element recognition
3. Log the recovery for future test runs

### AI-Enhanced Element Recognition

The framework uses advanced pattern matching to identify elements:

```typescript
// In package.json config
"aiSmartLocators": true

// The CSFindBy decorator leverages AI recognition
@CSFindBy({ css: 'button.submit' })
private submitButton!: CSElement;
```

This provides more robust element location even when the UI changes.

### Element Wait Strategies

The framework includes sophisticated wait strategies:

```typescript
// Wait for element to be visible
await this.element.waitForVisibility();

// Wait for element to be clickable
await this.element.waitForClickability();

// Wait for text to be present
await this.element.waitForText('Expected Text');

// Custom wait condition
await this.element.waitFor(async (element) => {
  const classes = await element.getAttribute('class');
  return classes.includes('active');
});
```

### Test Retry Mechanism

You can configure tests to automatically retry on failure:

```typescript
@Test('Test with retry', { retryCount: 3 })
public async testWithRetry(): Promise<void> {
  // Test implementation
}
```

## CI/CD Integration

The framework includes configuration for common CI/CD platforms:

### GitHub Actions

```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'npm'
      - run: npm ci
      - run: npm run test:ci
      - uses: actions/upload-artifact@v3
        with:
          name: reports
          path: reports
```

### Jenkins Pipeline

```groovy
// Jenkinsfile
pipeline {
    agent any
    
    stages {
        stage('Install') {
            steps {
                sh 'npm ci'
            }
        }
        stage('Test') {
            steps {
                sh 'npm run test:ci'
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: 'reports/**/*', fingerprint: true
        }
    }
}
```

### Azure DevOps Pipeline

```yaml
# azure-pipelines.yml
trigger:
  - main

pool:
  vmImage: 'ubuntu-latest'

steps:
  - task: NodeTool@0
    inputs:
      versionSpec: '16.x'
    displayName: 'Install Node.js'

  - script: npm ci
    displayName: 'Install dependencies'

  - script: npm run test:ci
    displayName: 'Run tests'

  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: 'reports'
      artifact: 'reports'
      publishLocation: 'pipeline'
    displayName: 'Publish reports'
```

## Best Practices

### Framework Usage

1. **Follow Page Object Model**: Keep UI interaction details in page objects, not tests
2. **Single Responsibility**: Each test should verify one feature or behavior
3. **Avoid Hard-Coded Data**: Use data providers or external data sources
4. **Use Fluent APIs**: Chain page object methods for readable test steps
5. **Handle Asynchronous Operations**: Use async/await for all asynchronous calls
6. **Proper Assertion Messages**: Include descriptive messages in assertions
7. **Maintain Test Independence**: Tests should not depend on each other

### Code Quality

1. **Type Everything**: Use TypeScript types and interfaces
2. **Code Formatting**: Use ESLint and Prettier to maintain code quality
3. **Avoid Duplicated Code**: Extract common functionality to utility methods
4. **Don't Sleep**: Use explicit waits instead of Thread.sleep/setTimeout
5. **Document Your Code**: Use JSDoc comments for methods and classes
6. **Follow the SOLID Principles**: Write maintainable, extensible code

## Troubleshooting

### Common Issues

1. **Element Not Found Exceptions**
   - Increase timeouts in the configuration
   - Verify element locators
   - Enable self-healing locators
   - Add explicit waits

2. **Timing Issues in Tests**
   - Add appropriate waits
   - Avoid race conditions with proper synchronization
   - Use wait strategies instead of fixed delays

3. **Test Failures in CI but Not Locally**
   - Run tests in headless mode locally
   - Check for resolution differences
   - Verify dependencies are identical

### Debugging

Enable verbose logging:

```bash
DEBUG=true npm test
```

Run a single test:

```bash
ts-node -r tsconfig-paths/register src/runners/testng-runner.ts --test=LoginTest
```

Use the inspector:

```bash
node --inspect-brk node_modules/ts-node/dist/bin.js -r tsconfig-paths/register src/runners/testng-runner.ts
```

---

Generated by CSTestForge Framework v1.0.0



templates/projects/selenium/typescript/bdd/package.json.template
---------------------------------------------------------------


{
  "name": "${project.name}",
  "version": "${project.version}",
  "description": "${project.description}",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "clean": "rimraf ./dist ./coverage ./reports",
    "lint": "eslint --ext .ts ./src",
    "format": "prettier --write \"src/**/*.ts\"",
    "prebuild": "npm run clean && npm run format && npm run lint",
    "pretest": "npm run build",
    "test": "cross-env NODE_ENV=test cucumber-js",
    "test:smoke": "cross-env NODE_ENV=test cucumber-js --tags @smoke",
    "test:regression": "cross-env NODE_ENV=test cucumber-js --tags @regression",
    "test:parallel": "cross-env NODE_ENV=test PARALLEL=true cucumber-js --parallel 4",
    "test:chrome": "cross-env NODE_ENV=test BROWSER=chrome cucumber-js",
    "test:firefox": "cross-env NODE_ENV=test BROWSER=firefox cucumber-js",
    "test:edge": "cross-env NODE_ENV=test BROWSER=edge cucumber-js",
    "test:headless": "cross-env NODE_ENV=test HEADLESS=true cucumber-js",
    "test:ci": "cross-env NODE_ENV=test HEADLESS=true PARALLEL=true cucumber-js --parallel 2",
    "report:generate": "ts-node ./src/utils/generate-report.ts",
    "report": "npm run test && npm run report:generate",
    "doc": "typedoc --out docs src",
    "prepare": "husky install"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/${github.organization}/${project.name}.git"
  },
  "keywords": [
    "selenium",
    "webdriver",
    "testing",
    "automation",
    "bdd",
    "cucumber",
    "typescript",
    "cstestforge"
  ],
  "author": "${author.name} <${author.email}>",
  "license": "${license}",
  "bugs": {
    "url": "https://github.com/${github.organization}/${project.name}/issues"
  },
  "homepage": "https://github.com/${github.organization}/${project.name}#readme",
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  },
  "devDependencies": {
    "@cucumber/cucumber": "^9.4.0",
    "@cucumber/pretty-formatter": "^1.0.0",
    "@types/chai": "^4.3.6",
    "@types/chai-as-promised": "^7.1.6",
    "@types/fs-extra": "^11.0.1",
    "@types/lodash": "^4.14.198",
    "@types/node": "^20.6.3",
    "@types/selenium-webdriver": "^4.1.16",
    "@types/uuid": "^9.0.4",
    "@typescript-eslint/eslint-plugin": "^6.7.2",
    "@typescript-eslint/parser": "^6.7.2",
    "chai": "^4.3.8",
    "chai-as-promised": "^7.1.1",
    "cross-env": "^7.0.3",
    "cucumber-html-reporter": "^7.1.1",
    "cucumber-junit": "^1.7.1",
    "eslint": "^8.49.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-cucumber": "^2.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "husky": "^8.0.3",
    "lint-staged": "^14.0.1",
    "multiple-cucumber-html-reporter": "^3.5.0",
    "prettier": "^3.0.3",
    "rimraf": "^5.0.1",
    "ts-node": "^10.9.1",
    "typedoc": "^0.25.1",
    "typescript": "~5.2.2"
  },
  "dependencies": {
    "ajv": "^8.12.0",
    "axios": "^1.5.0",
    "chalk": "^4.1.2",
    "chromedriver": "^116.0.0",
    "config": "^3.3.9",
    "dayjs": "^1.11.9",
    "deep-equal": "^2.2.2",
    "dotenv": "^16.3.1",
    "exceljs": "^4.3.0",
    "fast-csv": "^4.3.6",
    "fs-extra": "^11.1.1",
    "geckodriver": "^4.2.1",
    "handlebars": "^4.7.8",
    "js-yaml": "^4.1.0",
    "jsonpath": "^1.1.1",
    "lodash": "^4.17.21",
    "log4js": "^6.9.1",
    "msedgedriver": "^91.0.0",
    "reflect-metadata": "^0.1.13",
    "selenium-webdriver": "^4.12.0",
    "sqlite3": "^5.1.6",
    "uuid": "^9.0.1",
    "winston": "^3.10.0"
  },
  "cucumber": {
    "paths": [
      "src/test/features/**/*.feature"
    ],
    "require": [
      "src/test/stepdefs/**/*.ts",
      "src/test/support/**/*.ts"
    ],
    "requireModule": [
      "ts-node/register"
    ],
    "format": [
      "progress-bar",
      "html:reports/cucumber-report.html",
      "json:reports/cucumber-report.json",
      "junit:reports/cucumber-report.xml"
    ],
    "publishQuiet": true,
    "forceExit": true
  },
  "lint-staged": {
    "*.ts": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md,feature}": [
      "prettier --write"
    ]
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "config": {
    "browser": "chrome",
    "headless": false,
    "baseUrl": "https://your-application-url.com",
    "implicitTimeout": 10000,
    "explicitTimeout": 30000,
    "screenshotOnFailure": true,
    "screenshotOnStep": false,
    "videoRecording": false,
    "aiSmartLocators": true,
    "aiSelfHealing": true,
    "reportDir": "./reports",
    "dataDir": "./src/test/resources/testdata",
    "environments": {
      "dev": {
        "baseUrl": "https://dev.your-application-url.com",
        "apiBaseUrl": "https://dev-api.your-application-url.com",
        "username": "devuser",
        "password": "devpassword"
      },
      "qa": {
        "baseUrl": "https://qa.your-application-url.com",
        "apiBaseUrl": "https://qa-api.your-application-url.com",
        "username": "qauser",
        "password": "qapassword"
      },
      "stage": {
        "baseUrl": "https://stage.your-application-url.com",
        "apiBaseUrl": "https://stage-api.your-application-url.com",
        "username": "stageuser",
        "password": "stagepassword"
      },
      "prod": {
        "baseUrl": "https://your-application-url.com",
        "apiBaseUrl": "https://api.your-application-url.com",
        "username": "",
        "password": ""
      }
    }
  }
}


templates/projects/selenium/typescript/bdd/tsconfigjson.template
--------------------------------------------------------------------------

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["es2020", "dom"],
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "moduleResolution": "node",
    "baseUrl": "./",
    "paths": {
      "@core/*": ["src/core/*"],
      "@selenium/*": ["src/selenium/*"],
      "@pages/*": ["src/test/pages/*"],
      "@stepdefs/*": ["src/test/stepdefs/*"],
      "@support/*": ["src/test/support/*"],
      "@hooks/*": ["src/test/hooks/*"],
      "@utils/*": ["src/utils/*"],
      "@testdata/*": ["src/test/resources/testdata/*"],
      "@config/*": ["src/core/config/*"]
    },
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "importHelpers": true,
    "pretty": true
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.json",
    "src/**/*.feature"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "reports",
    "coverage",
    "docs"
  ],
  "ts-node": {
    "require": ["tsconfig-paths/register"],
    "transpileOnly": true
  }
}



templates/projects/selenium/typescript/bdd/README.md.template
-------------------------------------------------------------------------

# ${project.name} - Selenium TypeScript BDD Framework

## Overview

This Behavior-Driven Development (BDD) test automation framework combines Cucumber.js with Selenium WebDriver and TypeScript to create powerful, maintainable, and business-friendly automated tests. Built with CSTestForge, it offers enhanced capabilities like AI-powered element recognition, self-healing locators, and comprehensive reporting.

## Table of Contents

- [Features](#features)
- [Project Structure](#project-structure)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Configuration](#configuration)
- [Writing Tests](#writing-tests)
  - [Feature Files](#feature-files)
  - [Step Definitions](#step-definitions)
  - [Page Objects](#page-objects)
  - [Test Hooks](#test-hooks)
  - [Data Tables](#data-tables)
  - [Test Context](#test-context)
- [Running Tests](#running-tests)
- [Reporting](#reporting)
- [Advanced Features](#advanced-features)
- [CI/CD Integration](#cicd-integration)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Features

- **BDD with Cucumber.js**: Write tests in plain language that stakeholders can understand
- **TypeScript**: Strongly-typed test code for improved maintainability and IDE support
- **Page Object Model**: Enhanced page objects with fluent API and self-healing locators
- **Multi-Browser Support**: Run tests on Chrome, Firefox, Edge, and Safari
- **Smart Element Location**: AI-powered element identification with alternative locator strategies
- **Self-Healing Capabilities**: Automatic recovery from broken element locators
- **Parallel Execution**: Run scenarios in parallel to reduce execution time
- **Comprehensive Reporting**: Detailed reports with screenshots, videos, and timing information
- **External Data Sources**: Support for JSON, Excel, and CSV data sources
- **Environment Management**: Easy configuration for different environments (dev, qa, staging, prod)
- **CI/CD Integration**: Built-in support for common CI/CD platforms

## Project Structure

```
${project.name}/
├── src/
│   ├── core/
│   │   ├── config/
│   │   │   ├── ConfigurationManager.ts
│   │   │   ├── EnvironmentConfig.ts
│   │   │   └── FrameworkConfig.ts
│   │   ├── utils/
│   │   │   ├── DateUtils.ts
│   │   │   ├── FileUtils.ts
│   │   │   ├── TextUtils.ts
│   │   │   ├── ScreenshotManager.ts
│   │   │   ├── Logger.ts
│   │   │   └── Constants.ts
│   │   ├── data/
│   │   │   ├── DataProvider.ts
│   │   │   ├── DataSourceFactory.ts
│   │   │   └── sources/
│   │   │       ├── JsonDataSource.ts
│   │   │       ├── ExcelDataSource.ts
│   │   │       ├── CsvDataSource.ts
│   │   │       └── DatabaseDataSource.ts
│   │   ├── reporting/
│   │   │   ├── Reporter.ts
│   │   │   ├── HtmlReportGenerator.ts
│   │   │   ├── TestResult.ts
│   │   │   └── TestStep.ts
│   │   └── ai/
│   │       ├── ElementRecognitionService.ts
│   │       ├── SmartLocatorService.ts
│   │       └── SelfHealingLocatorService.ts
│   ├── selenium/
│   │   ├── browser/
│   │   │   ├── BrowserManager.ts
│   │   │   ├── CapabilityManager.ts
│   │   │   └── WebDriverFactory.ts
│   │   ├── element/
│   │   │   ├── CSElement.ts
│   │   │   ├── CSElementList.ts
│   │   │   ├── CSSelect.ts
│   │   │   ├── CSForm.ts
│   │   │   └── CSTable.ts
│   │   └── wait/
│   │       ├── WaitStrategy.ts
│   │       ├── VisibilityWait.ts
│   │       ├── ClickableWait.ts
│   │       ├── TextWait.ts
│   │       └── WaitFactory.ts
│   ├── test/
│   │   ├── features/
│   │   │   ├── login.feature
│   │   │   ├── dashboard.feature
│   │   │   └── ... (other feature files)
│   │   ├── pages/
│   │   │   ├── BasePage.ts
│   │   │   ├── LoginPage.ts
│   │   │   ├── DashboardPage.ts
│   │   │   └── ... (other page objects)
│   │   ├── stepdefs/
│   │   │   ├── common/
│   │   │   │   └── CommonSteps.ts
│   │   │   ├── login/
│   │   │   │   └── LoginSteps.ts
│   │   │   └── dashboard/
│   │   │       └── DashboardSteps.ts
│   │   ├── support/
│   │   │   ├── env.ts
│   │   │   └── World.ts
│   │   ├── hooks/
│   │   │   └── Hooks.ts
│   │   └── resources/
│   │       └── testdata/
│   │           ├── users.json
│   │           ├── products.xlsx
│   │           └── ... (other test data)
│   └── utils/
│       ├── generate-report.ts
│       └── test-utils.ts
├── reports/
│   ├── html/
│   ├── screenshots/
│   └── videos/
├── package.json
├── tsconfig.json
├── cucumber.js
├── .eslintrc.json
├── .prettierrc
├── .gitignore
└── README.md
```

## Prerequisites

- Node.js (v16 or higher)
- npm (v8 or higher)
- Chrome, Firefox, or Edge browser
- TypeScript knowledge
- Cucumber.js knowledge
- Selenium WebDriver knowledge

## Installation

1. Clone this repository:
   ```bash
   git clone https://github.com/${github.organization}/${project.name}.git
   cd ${project.name}
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Build the project:
   ```bash
   npm run build
   ```

## Configuration

The framework uses a configuration system defined in the `package.json` file under the `config` section. Environment-specific configurations are stored in the `environments` object.

You can override configuration values using:

1. Environment variables
2. Command line arguments
3. `.env` file in the project root

Example configuration:

```json
"config": {
  "browser": "chrome",
  "headless": false,
  "baseUrl": "https://your-application-url.com",
  "implicitTimeout": 10000,
  "explicitTimeout": 30000,
  "screenshotOnFailure": true,
  "screenshotOnStep": false,
  "videoRecording": false,
  "aiSmartLocators": true,
  "aiSelfHealing": true,
  "environments": {
    "dev": {
      "baseUrl": "https://dev.your-application-url.com"
    },
    "qa": {
      "baseUrl": "https://qa.your-application-url.com"
    }
  }
}
```

To run tests with a specific configuration:

```bash
# Using environment variable
NODE_ENV=qa npm test

# Using command line arguments
npm test -- --browser=firefox --headless=true
```

## Writing Tests

### Feature Files

Feature files are written in Gherkin syntax and stored in `src/test/features/`. They describe the behavior of the application from a business perspective:

```gherkin
Feature: User Authentication
  As a user of the application
  I want to log in with my credentials
  So that I can access my account

  Background:
    Given the user is on the login page

  @smoke @regression
  Scenario: Successful login with valid credentials
    When the user enters username "validuser" and password "validpassword"
    And the user clicks the login button
    Then the user should be redirected to the dashboard
    And the user should see a welcome message "Welcome, Valid User!"

  @regression
  Scenario Outline: Failed login with invalid credentials
    When the user enters username "<username>" and password "<password>"
    And the user clicks the login button
    Then the user should see an error message "<error_message>"

    Examples:
      | username    | password      | error_message                |
      | invaliduser | validpassword | Invalid username or password |
      | validuser   | invalidpass   | Invalid username or password |
      | ""          | validpassword | Username cannot be empty     |
```

### Step Definitions

Step definitions connect the Gherkin steps to TypeScript code:

```typescript
// src/test/stepdefs/login/LoginSteps.ts
import { Given, When, Then } from '@cucumber/cucumber';
import { LoginPage } from '@pages/LoginPage';
import { DashboardPage } from '@pages/DashboardPage';
import { expect } from 'chai';
import { World } from '@support/World';

// Get pages from World
const getPages = (world: World) => {
  return {
    loginPage: world.pages.loginPage as LoginPage,
    dashboardPage: world.pages.dashboardPage as DashboardPage
  };
};

Given('the user is on the login page', async function(this: World) {
  const { loginPage } = getPages(this);
  await loginPage.navigateTo();
});

When('the user enters username {string} and password {string}', async function(this: World, username: string, password: string) {
  const { loginPage } = getPages(this);
  await loginPage.enterUsername(username);
  await loginPage.enterPassword(password);
});

When('the user clicks the login button', async function(this: World) {
  const { loginPage } = getPages(this);
  await loginPage.clickLoginButton();
});

Then('the user should be redirected to the dashboard', async function(this: World) {
  const { dashboardPage } = getPages(this);
  const isLoaded = await dashboardPage.isPageLoaded();
  expect(isLoaded).to.be.true;
});

Then('the user should see a welcome message {string}', async function(this: World, expectedMessage: string) {
  const { dashboardPage } = getPages(this);
  const actualMessage = await dashboardPage.getWelcomeMessage();
  expect(actualMessage).to.equal(expectedMessage);
});

Then('the user should see an error message {string}', async function(this: World, expectedError: string) {
  const { loginPage } = getPages(this);
  const isDisplayed = await loginPage.isErrorMessageDisplayed();
  expect(isDisplayed).to.be.true;
  
  const actualError = await loginPage.getErrorMessage();
  expect(actualError).to.equal(expectedError);
});
```

### Page Objects

Page objects encapsulate page interactions and elements:

```typescript
// src/test/pages/LoginPage.ts
import { BasePage } from './BasePage';
import { CSElement } from '@selenium/element/CSElement';
import { By } from 'selenium-webdriver';
import { CSFindBy } from '@core/annotations';

export class LoginPage extends BasePage {
  @CSFindBy({ id: 'username' })
  private usernameField!: CSElement;

  @CSFindBy({ id: 'password' })
  private passwordField!: CSElement;

  @CSFindBy({ css: 'button[type="submit"]' })
  private loginButton!: CSElement;

  @CSFindBy({ css: '.error-message' })
  private errorMessage!: CSElement;

  constructor() {
    super();
  }

  public async navigateTo(): Promise<void> {
    await this.driver.get(`${this.config.baseUrl}/login`);
    await this.waitForPageLoad();
  }

  public async enterUsername(username: string): Promise<void> {
    await this.usernameField.clear();
    await this.usernameField.sendKeys(username);
  }

  public async enterPassword(password: string): Promise<void> {
    await this.passwordField.clear();
    await this.passwordField.sendKeys(password);
  }

  public async clickLoginButton(): Promise<void> {
    await this.loginButton.click();
  }

  public async isErrorMessageDisplayed(): Promise<boolean> {
    return await this.errorMessage.isDisplayed();
  }

  public async getErrorMessage(): Promise<string> {
    return await this.errorMessage.getText();
  }

  public async login(username: string, password: string): Promise<void> {
    await this.enterUsername(username);
    await this.enterPassword(password);
    await this.clickLoginButton();
  }
}
```

### Test Hooks

Hooks allow you to perform actions before and after scenarios:

```typescript
// src/test/hooks/Hooks.ts
import { Before, After, BeforeAll, AfterAll, Status } from '@cucumber/cucumber';
import { World } from '@support/World';
import { BrowserManager } from '@selenium/browser/BrowserManager';
import { Reporter } from '@core/reporting/Reporter';
import { ScreenshotManager } from '@core/utils/ScreenshotManager';

// Initialize services
const reporter = Reporter.getInstance();
const screenshotManager = ScreenshotManager.getInstance();

// Run once before any tests
BeforeAll(async function() {
  reporter.initializeReport();
});

// Run once after all tests
AfterAll(async function() {
  reporter.finalizeReport();
});

// Run before each scenario
Before(async function(this: World, scenario) {
  // Set up the browser
  const driver = await BrowserManager.getDriver();
  this.driver = driver;
  
  // Initialize pages
  this.initializePages();
  
  // Start scenario in reporter
  reporter.startTest(scenario.pickle.name, scenario.pickle.tags.map(tag => tag.name).join(', '));
  
  // Record scenario start time
  this.scenarioStartTime = Date.now();
});

// Run after each scenario
After(async function(this: World, scenario) {
  try {
    // Take screenshot on failure
    if (scenario.result?.status === Status.FAILED) {
      const screenshot = await screenshotManager.captureScreenshot(this.driver, 'failure');
      reporter.attachScreenshot(screenshot);
    }
    
    // Calculate execution time
    const executionTime = Date.now() - this.scenarioStartTime;
    
    // Record scenario result
    reporter.endTest(scenario.result?.status || 'UNDEFINED', executionTime);
    
  } finally {
    // Clean up
    await BrowserManager.quitDriver();
    this.driver = undefined;
  }
});
```

### World Context

The `World` class provides context for your step definitions:

```typescript
// src/test/support/World.ts
import { setWorldConstructor } from '@cucumber/cucumber';
import { WebDriver } from 'selenium-webdriver';
import { LoginPage } from '@pages/LoginPage';
import { DashboardPage } from '@pages/DashboardPage';

export interface Pages {
  loginPage?: LoginPage;
  dashboardPage?: DashboardPage;
  [key: string]: any;
}

export class World {
  driver?: WebDriver;
  pages: Pages = {};
  scenarioStartTime: number = 0;
  testData: Map<string, any> = new Map();
  
  constructor() {
    // Empty constructor
  }
  
  initializePages(): void {
    this.pages.loginPage = new LoginPage();
    this.pages.dashboardPage = new DashboardPage();
  }
  
  // Store data in the test context
  set<T>(key: string, value: T): void {
    this.testData.set(key, value);
  }
  
  // Retrieve data from the test context
  get<T>(key: string): T | undefined {
    return this.testData.get(key) as T;
  }
}

setWorldConstructor(World);
```

### Data Tables

Use Cucumber data tables for structured test data:

```gherkin
Scenario: User can add multiple items to cart
  Given the user is logged in
  When the user adds the following items to the cart
    | productName    | quantity | price   |
    | Product A      | 2        | $10.99  |
    | Product B      | 1        | $24.99  |
    | Product C      | 3        | $5.49   |
  Then the cart should contain 6 items
  And the cart total should be $63.44
```

Step definition for data tables:

```typescript
When('the user adds the following items to the cart', async function(this: World, dataTable) {
  const { cartPage } = getPages(this);
  
  // Convert data table to array of objects
  const items = dataTable.hashes();
  
  // Process each item
  for (const item of items) {
    await cartPage.addItemToCart(item.productName, parseInt(item.quantity));
  }
});
```

## Running Tests

To run all tests:

```bash
npm test
```

To run specific tags:

```bash
npm run test:smoke
npm run test:regression
```

To run tests in a specific browser:

```bash
npm run test:chrome
npm run test:firefox
npm run test:edge
```

To run tests in headless mode:

```bash
npm run test:headless
```

To run tests in parallel:

```bash
npm run test:parallel
```

To run tests in CI environment:

```bash
npm run test:ci
```

You can also add custom parameters:

```bash
npm test -- --tags @smoke,@regression --format=json:results.json
```

## Reporting

The framework generates detailed HTML reports with screenshots, logs, and performance metrics. Reports are created in the `reports` directory after test execution.

To generate the report after test execution:

```bash
npm run report
```

The HTML report includes:

- Feature summary with pass/fail statistics
- Scenario details with steps and execution status
- Screenshots for failed scenarios
- Execution time and performance metrics
- Environment and browser information

## Advanced Features

### Self-Healing Locators

The framework includes self-healing locators that automatically recover from broken element locators during test execution:

```typescript
// In package.json config
"aiSelfHealing": true

// The CSFindBy decorator automatically applies self-healing
@CSFindBy({ id: 'login-button' })
private loginButton!: CSElement;
```

If the locator breaks due to UI changes, the framework will:
1. Try alternative locator strategies (ID, name, CSS, XPath)
2. Use AI-powered element recognition to find the element
3. Log the recovered locator for future test runs

### AI-Enhanced Element Recognition

The framework uses advanced pattern matching to identify elements:

```typescript
// In package.json config
"aiSmartLocators": true

// The CSFindBy decorator leverages AI recognition
@CSFindBy({ css: 'button.submit', smartLocator: true })
private submitButton!: CSElement;
```

This provides more robust element location even when the UI changes.

### Element Wait Strategies

The framework includes sophisticated wait strategies:

```typescript
// Wait for element to be visible
await this.element.waitForVisibility();

// Wait for element to be clickable
await this.element.waitForClickability();

// Wait for text to be present
await this.element.waitForText('Expected Text');

// Custom wait condition
await this.element.waitFor(async (element) => {
  const classes = await element.getAttribute('class');
  return classes.includes('active');
});
```

### Running Scenarios in Parallel

To enable parallel execution, use the `--parallel` flag:

```bash
npm run test:parallel
```

You can configure the number of parallel instances in `package.json`:

```json
"test:parallel": "cross-env NODE_ENV=test PARALLEL=true cucumber-js --parallel 4"
```

## CI/CD Integration

The framework includes configuration for common CI/CD platforms:

### GitHub Actions

```yaml
# .github/workflows/test.### GitHub Actions

```yaml
# .github/workflows/test.yml
name: BDD Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16.x'
        cache: 'npm'
    - name: Install dependencies
      run: npm ci
    - name: Run tests
      run: npm run test:ci
    - name: Generate report
      if: always()
      run: npm run report:generate
    - name: Upload reports
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: cucumber-reports
        path: reports
```

### Jenkins Pipeline

```groovy
// Jenkinsfile
pipeline {
    agent any
    
    stages {
        stage('Install') {
            steps {
                sh 'npm ci'
            }
        }
        stage('Test') {
            steps {
                sh 'npm run test:ci'
            }
        }
        stage('Report') {
            steps {
                sh 'npm run report:generate'
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: 'reports/**/*', fingerprint: true
        }
    }
}
```

### Azure DevOps Pipeline

```yaml
# azure-pipelines.yml
trigger:
  - main

pool:
  vmImage: 'ubuntu-latest'

steps:
  - task: NodeTool@0
    inputs:
      versionSpec: '16.x'
    displayName: 'Install Node.js'

  - script: npm ci
    displayName: 'Install dependencies'

  - script: npm run test:ci
    displayName: 'Run tests'

  - script: npm run report:generate
    displayName: 'Generate report'
    condition: always()

  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: 'reports'
      artifact: 'cucumber-reports'
      publishLocation: 'pipeline'
    displayName: 'Publish reports'
    condition: always()
```

## Best Practices

### Writing Feature Files

1. **Business Focus**: Write features from a business perspective, not technical implementation
2. **Consistent Language**: Use a consistent vocabulary throughout feature files
3. **Single Feature per File**: Keep one feature per file for better organization
4. **Descriptive Titles**: Use descriptive feature and scenario titles
5. **Use Background**: Use Background for common setup steps
6. **Proper Tagging**: Tag scenarios for organization (@smoke, @regression, etc.)
7. **Scenario Outlines**: Use Scenario Outlines for data-driven tests

### Writing Step Definitions

1. **Reusable Steps**: Create generic steps that can be reused across features
2. **Page Object Pattern**: Delegate UI interactions to page objects
3. **Simple Assertions**: Keep assertions simple and focused
4. **Proper Sharing**: Use World context to share state between steps
5. **Avoid Hardcoding**: Use parameters instead of hardcoded values
6. **Error Handling**: Include proper error handling and reporting

### Code Quality

1. **Type Everything**: Use TypeScript types and interfaces
2. **Code Formatting**: Use ESLint and Prettier to maintain code quality
3. **Avoid Duplicated Code**: Extract common functionality to utility methods
4. **Don't Sleep**: Use explicit waits instead of Thread.sleep/setTimeout
5. **Document Your Code**: Use JSDoc comments for methods and classes
6. **Follow the SOLID Principles**: Write maintainable, extensible code

## Troubleshooting

### Common Issues

1. **Element Not Found Exceptions**
   - Increase timeouts in the configuration
   - Verify element locators
   - Enable self-healing locators with `aiSelfHealing: true`
   - Add explicit waits

2. **No Such Session Errors**
   - Ensure the driver is properly initialized
   - Check that hooks are correctly closing/creating browser sessions
   - Verify there are no leftover browser processes

3. **Step Undefined Errors**
   - Check that your step definition regex matches the Gherkin step
   - Verify that step definition files are included in the `require` path
   - Ensure `ts-node/register` is in the `requireModule` array

4. **Test Failures in CI but Not Locally**
   - Run tests in headless mode locally
   - Check for resolution differences
   - Verify that environment variables are properly set
   - Consider using Docker for consistent environments

### Debugging

Enable verbose logging:

```bash
DEBUG=true npm test
```

Debug a specific feature:

```bash
npm test -- features/login.feature --tags @debug
```

Use Chrome's DevTools for debugging:

```bash
node --inspect-brk node_modules/.bin/cucumber-js
```

Then open Chrome and navigate to `chrome://inspect` to connect to the debugger.

## Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/my-feature`
3. Make your changes
4. Run tests: `npm test`
5. Commit your changes: `git commit -am 'Add new feature'`
6. Push to the branch: `git push origin feature/my-feature`
7. Submit a pull request

## License

This project is licensed under the ${license} - see the LICENSE file for details.

---

Generated by CSTestForge Framework v1.0.0



templates/projects/playwright/java/testng/pom.xml.templage
-------------------------------------------------------------------

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>${groupId}</groupId>
    <artifactId>${artifactId}</artifactId>
    <version>${version}</version>
    <packaging>jar</packaging>

    <name>${project.name}</name>
    <description>${project.description}</description>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>17</java.version>
        <maven.compiler.source>${java.version}</maven.compiler.source>
        <maven.compiler.target>${java.version}</maven.compiler.target>
        
        <!-- Dependencies Versions -->
        <playwright.version>1.36.0</playwright.version>
        <testng.version>7.8.0</testng.version>
        <extentreports.version>5.1.1</extentreports.version>
        <log4j.version>2.20.0</log4j.version>
        <slf4j.version>2.0.9</slf4j.version>
        <logback.version>1.4.11</logback.version>
        <jackson.version>2.15.2</jackson.version>
        <commons-io.version>2.13.0</commons-io.version>
        <commons-lang3.version>3.13.0</commons-lang3.version>
        <commons-text.version>1.10.0</commons-text.version>
        <commons-csv.version>1.10.0</commons-csv.version>
        <commons-collections4.version>4.4</commons-collections4.version>
        <poi.version>5.2.3</poi.version>
        <rest-assured.version>5.3.2</rest-assured.version>
        <gson.version>2.10.1</gson.version>
        <lombok.version>1.18.28</lombok.version>
        <assertj.version>3.24.2</assertj.version>
        <awaitility.version>4.2.0</awaitility.version>
        <monte-screen-recorder.version>0.7.7.0</monte-screen-recorder.version>
        
        <!-- Plugin Versions -->
        <maven-compiler-plugin.version>3.11.0</maven-compiler-plugin.version>
        <maven-surefire-plugin.version>3.1.2</maven-surefire-plugin.version>
        <maven-resources-plugin.version>3.3.1</maven-resources-plugin.version>
        <maven-clean-plugin.version>3.3.1</maven-clean-plugin.version>
        <maven-jar-plugin.version>3.3.0</maven-jar-plugin.version>
        <maven-source-plugin.version>3.3.0</maven-source-plugin.version>
        <maven-javadoc-plugin.version>3.5.0</maven-javadoc-plugin.version>
        <jacoco-maven-plugin.version>0.8.10</jacoco-maven-plugin.version>
    </properties>

    <dependencies>
        <!-- Playwright -->
        <dependency>
            <groupId>com.microsoft.playwright</groupId>
            <artifactId>playwright</artifactId>
            <version>${playwright.version}</version>
        </dependency>
        
        <!-- TestNG -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>${testng.version}</version>
        </dependency>
        
        <!-- Reporting -->
        <dependency>
            <groupId>com.aventstack</groupId>
            <artifactId>extentreports</artifactId>
            <version>${extentreports.version}</version>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>${log4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>${log4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>
        
        <!-- JSON Processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>${gson.version}</version>
        </dependency>
        
        <!-- Apache Commons -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>${commons-io.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>${commons-lang3.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-text</artifactId>
            <version>${commons-text.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>${commons-csv.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-collections4</artifactId>
            <version>${commons-collections4.version}</version>
        </dependency>
        
        <!-- Excel Processing -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>${poi.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>${poi.version}</version>
        </dependency>
        
        <!-- REST API Testing -->
        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <version>${rest-assured.version}</version>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope>
        </dependency>
        
        <!-- Assertions -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>${assertj.version}</version>
        </dependency>
        
        <!-- Waiting Utilities -->
        <dependency>
            <groupId>org.awaitility</groupId>
            <artifactId>awaitility</artifactId>
            <version>${awaitility.version}</version>
        </dependency>
        
        <!-- Video Recording -->
        <dependency>
            <groupId>com.github.stephenc.monte</groupId>
            <artifactId>monte-screen-recorder</artifactId>
            <version>${monte-screen-recorder.version}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Compiler Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven-compiler-plugin.version}</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            
            <!-- Surefire Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>${maven-surefire-plugin.version}</version>
                <configuration>
                    <suiteXmlFiles>
                        <suiteXmlFile>src/test/resources/testng.xml</suiteXmlFile>
                    </suiteXmlFiles>
                    <systemPropertyVariables>
                        <browser>${browser}</browser>
                        <headless>${headless}</headless>
                        <environment>${environment}</environment>
                        <testng.dtd.http>true</testng.dtd.http>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
            
            <!-- Resources Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <version>${maven-resources-plugin.version}</version>
                <configuration>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>
            
            <!-- Playwright Install -->
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>3.1.0</version>
                <executions>
                    <execution>
                        <id>playwright-install</id>
                        <phase>process-resources</phase>
                        <goals>
                            <goal>java</goal>
                        </goals>
                        <configuration>
                            <mainClass>com.microsoft.playwright.CLI</mainClass>
                            <arguments>
                                <argument>install</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            
            <!-- JaCoCo Plugin for Code Coverage -->
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>${jacoco-maven-plugin.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>report</id>
                        <phase>test</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <!-- Source Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>${maven-source-plugin.version}</version>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <!-- JavaDoc Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>${maven-javadoc-plugin.version}</version>
                <executions>
                    <execution>
                        <id>attach-javadocs</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
            <resource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
    
    <profiles>
        <!-- Environment Profiles -->
        <profile>
            <id>dev</id>
            <properties>
                <environment>dev</environment>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>qa</id>
            <properties>
                <environment>qa</environment>
            </properties>
        </profile>
        <profile>
            <id>stage</id>
            <properties>
                <environment>stage</environment>
            </properties>
        </profile>
        <profile>
            <id>prod</id>
            <properties>
                <environment>prod</environment>
            </properties>
        </profile>
        
        <!-- Browser Profiles -->
        <profile>
            <id>chromium</id>
            <properties>
                <browser>chromium</browser>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>firefox</id>
            <properties>
                <browser>firefox</browser>
            </properties>
        </profile>
        <profile>
            <id>webkit</id>
            <properties>
                <browser>webkit</browser>
            </properties>
        </profile>
        
        <!-- Execution Mode Profiles -->
        <profile>
            <id>headless</id>
            <properties>
                <headless>true</headless>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>headed</id>
            <properties>
                <headless>false</headless>
            </properties>
        </profile>
        
        <!-- Test Scope Profiles -->
        <profile>
            <id>smoke</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>${maven-surefire-plugin.version}</version>
                        <configuration>
                            <groups>smoke</groups>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        <profile>
            <id>regression</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>${maven-surefire-plugin.version}</version>
                        <configuration>
                            <groups>regression</groups>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        <profile>
            <id>sanity</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>${maven-surefire-plugin.version}</version>
                        <configuration>
                            <groups>sanity</groups>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        
        <!-- Parallel Execution Profile -->
        <profile>
            <id>parallel</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>${maven-surefire-plugin.version}</version>
                        <configuration>
                            <suiteXmlFiles>
                                <suiteXmlFile>src/test/resources/testng-parallel.xml</suiteXmlFile>
                            </suiteXmlFiles>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        
        <!-- CI/CD Profile -->
        <profile>
            <id>ci</id>
            <properties>
                <headless>true</headless>
            </properties>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>${maven-surefire-plugin.version}</version>
                        <configuration>
                            <suiteXmlFiles>
                                <suiteXmlFile>src/test/resources/testng-parallel.xml</suiteXmlFile>
                            </suiteXmlFiles>
                            <systemPropertyVariables>
                                <browser>chromium</browser>
                                <headless>true</headless>
                                <environment>${environment}</environment>
                                <testng.dtd.http>true</testng.dtd.http>
                                <video.recording>false</video.recording>
                            </systemPropertyVariables>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
    
    <repositories>
        <repository>
            <id>central</id>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
        <repository>
            <id>github</id>
            <url>https://maven.pkg.github.com/${github.organization}/*</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
    </repositories>
</project>



templates/projects/playwright/testng/sr/test/java/BaseTest.java.templage
----------------------------------------------------------------------


package ${package}.tests;

import com.microsoft.playwright.*;
import org.testng.ITestResult;
import org.testng.annotations.*;

import ${package}.core.config.ConfigurationManager;
import ${package}.core.reporting.CSReporter;
import ${package}.core.utils.CSConstants;
import ${package}.core.utils.CSLogger;
import ${package}.core.utils.CSScreenshotManager;
import ${package}.playwright.java.testng.browser.BrowserManager;

import java.lang.reflect.Method;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Base Test class for all Playwright tests, providing shared functionality and test lifecycle management.
 * This class handles browser initialization, cleanup, and test execution hooks for TestNG.
 */
public class BaseTest {
    
    protected Playwright playwright;
    protected Browser browser;
    protected BrowserContext context;
    protected Page page;
    protected CSReporter reporter;
    protected CSScreenshotManager screenshotManager;
    protected Map<String, Object> testContext;
    protected long testStartTime;
    protected String currentTestName;
    protected String currentTestDescription;
    protected static boolean videoRecordingEnabled;
    protected static boolean traceEnabled;
    protected static boolean screenshotOnFailureEnabled;
    protected static String currentClassName;
    protected static boolean isClassSetupDone = false;
    
    /**
     * Constructor for BaseTest
     */
    public BaseTest() {
        testContext = new HashMap<>();
        reporter = CSReporter.getInstance();
        screenshotManager = CSScreenshotManager.getInstance();
        
        // Load configuration settings
        loadConfigSettings();
    }
    
    /**
     * Load configuration settings from the framework configuration
     */
    private void loadConfigSettings() {
        ConfigurationManager configManager = ConfigurationManager.getInstance();
        videoRecordingEnabled = configManager.getFrameworkConfig().isVideoRecordingEnabled();
        traceEnabled = configManager.getFrameworkConfig().isTraceEnabled();
        screenshotOnFailureEnabled = configManager.getFrameworkConfig().isScreenshotOnFailureEnabled();
    }
    
    /**
     * Method executed before each test class
     */
    @BeforeClass(alwaysRun = true)
    public void beforeClass() {
        currentClassName = this.getClass().getSimpleName();
        CSLogger.info("Starting test class: " + currentClassName);
        
        try {
            // Initialize Playwright and browser only once per class
            if (!isClassSetupDone) {
                initializePlaywright();
                isClassSetupDone = true;
            }
            
        } catch (Exception e) {
            CSLogger.error("Failed to initialize Playwright in beforeClass: " + e.getMessage(), e);
            throw new RuntimeException("Failed to initialize Playwright", e);
        }
    }
    
    /**
     * Method executed after each test class
     */
    @AfterClass(alwaysRun = true)
    public void afterClass() {
        CSLogger.info("Finished test class: " + currentClassName);
        
        try {
            // Clean up Playwright resources
            closePlaywright();
            isClassSetupDone = false;
            
        } catch (Exception e) {
            CSLogger.error("Failed to clean up Playwright in afterClass: " + e.getMessage(), e);
        }
    }
    
    /**
     * Method executed before each test method
     * 
     * @param method Test method
     * @param testParams Test parameters
     */
    @BeforeMethod(alwaysRun = true)
    public void beforeTest(Method method, Object[] testParams) {
        // Get test information
        currentTestName = method.getName();
        Test testAnnotation = method.getAnnotation(Test.class);
        currentTestDescription = testAnnotation != null && !testAnnotation.description().isEmpty() ? 
                                 testAnnotation.description() : currentTestName;
        
        // Initialize test start time
        testStartTime = System.currentTimeMillis();
        
        CSLogger.info("Starting test: " + currentTestName + " - " + currentTestDescription);
        
        try {
            // Create new browser context for each test method
            initializeContext();
            
            // Start test in reporter
            reporter.startTest(currentTestName, currentTestDescription);
            
        } catch (Exception e) {
            CSLogger.error("Failed to initialize context in beforeTest: " + e.getMessage(), e);
            throw new RuntimeException("Failed to initialize context", e);
        }
    }
    
    /**
     * Method executed after each test method
     * 
     * @param result Test result
     */
    @AfterMethod(alwaysRun = true)
    public void afterTest(ITestResult result) {
        try {
            // Calculate test execution time
            long executionTime = System.currentTimeMillis() - testStartTime;
            String formattedTime = formatExecutionTime(executionTime);
            
            if (result.getStatus() == ITestResult.FAILURE) {
                // Handle test failure
                handleTestFailure(result);
                CSLogger.error("Test FAILED: " + currentTestName + " - " + result.getThrowable().getMessage());
                reporter.logFailure("Test Failed", result.getThrowable().getMessage());
            } else if (result.getStatus() == ITestResult.SUCCESS) {
                CSLogger.info("Test PASSED: " + currentTestName + " - Execution time: " + formattedTime);
                reporter.logSuccess("Test Passed", "Execution time: " + formattedTime);
            } else if (result.getStatus() == ITestResult.SKIP) {
                CSLogger.warn("Test SKIPPED: " + currentTestName);
                reporter.logWarning("Test Skipped", result.getThrowable() != null ? 
                                    result.getThrowable().getMessage() : "Test was skipped");
            }
            
            // End test in reporter
            reporter.endTest(getTestStatusText(result.getStatus()), executionTime);
            
        } catch (Exception e) {
            CSLogger.error("Error in afterTest: " + e.getMessage(), e);
        } finally {
            // Always clean up context
            cleanupContext();
        }
    }
    
    /**
     * Initialize Playwright and Browser
     */
    protected void initializePlaywright() {
        CSLogger.info("Initializing Playwright...");
        
        // Create Playwright instance
        playwright = Playwright.create();
        
        // Get browser type based on configuration
        String browserType = System.getProperty("browser", ConfigurationManager.getInstance()
                            .getFrameworkConfig().getBrowser());
        boolean headless = Boolean.parseBoolean(System.getProperty("headless", String.valueOf(
                          ConfigurationManager.getInstance().getFrameworkConfig().isHeadless())));
        
        // Launch browser
        browser = launchBrowser(browserType, headless);
        
        CSLogger.info("Playwright initialized with browser: " + browserType + ", headless: " + headless);
    }
    
    /**
     * Initialize browser context and page
     */
    protected void initializeContext() {
        CSLogger.debug("Initializing browser context and page...");
        
        // Create browser context with recording options if enabled
        BrowserContext.CreateOptions contextOptions = new BrowserContext.CreateOptions();
        
        if (videoRecordingEnabled) {
            Path videoDir = Paths.get("target/playwright-videos");
            contextOptions.setRecordVideoDir(videoDir);
            CSLogger.info("Video recording enabled to directory: " + videoDir);
        }
        
        if (traceEnabled) {
            contextOptions.setRecordVideoSize(1280, 720);
        }
        
        // Create context
        context = browser.newContext(contextOptions);
        
        // Start tracing if enabled
        if (traceEnabled) {
            context.tracing().start(new Tracing.StartOptions()
                    .setScreenshots(true)
                    .setSnapshots(true));
            CSLogger.info("Tracing enabled for context");
        }
        
        // Create page
        page = context.newPage();
        
        // Set default timeout
        page.setDefaultTimeout(ConfigurationManager.getInstance()
                              .getFrameworkConfig().getDefaultTimeoutInMillis());
        
        CSLogger.debug("Browser context and page initialized");
    }
    
    /**
     * Launch the browser based on type and headless mode
     * 
     * @param browserType Type of browser (chromium, firefox, webkit)
     * @param headless Whether to run in headless mode
     * @return Browser instance
     */
    protected Browser launchBrowser(String browserType, boolean headless) {
        CSLogger.debug("Launching browser: " + browserType + ", headless: " + headless);
        
        BrowserType.LaunchOptions launchOptions = new BrowserType.LaunchOptions()
                .setHeadless(headless)
                .setSlowMo(50);
        
        // Set browser arguments based on browser type
        switch (browserType.toLowerCase()) {
            case "chromium":
                launchOptions.setArgs(getBrowserArgs(browserType));
                return playwright.chromium().launch(launchOptions);
            case "firefox":
                return playwright.firefox().launch(launchOptions);
            case "webkit":
                return playwright.webkit().launch(launchOptions);
            default:
                CSLogger.warn("Unknown browser type: " + browserType + ", defaulting to Chromium");
                return playwright.chromium().launch(launchOptions);
        }
    }
    
    /**
     * Get browser arguments based on browser type
     * 
     * @param browserType Type of browser
     * @return Array of browser arguments
     */
    protected String[] getBrowserArgs(String browserType) {
        if ("chromium".equalsIgnoreCase(browserType)) {
            return new String[] {
                "--disable-gpu",
                "--no-sandbox",
                "--disable-dev-shm-usage",
                "--disable-setuid-sandbox",
                "--disable-web-security",
                "--disable-features=IsolateOrigins,site-per-process"
            };
        }
        return new String[] {};
    }
    
    /**
     * Clean up context and page
     */
    protected void cleanupContext() {
        CSLogger.debug("Cleaning up browser context and page...");
        
        try {
            if (context != null) {
                // Save trace if enabled
                if (traceEnabled) {
                    Path tracePath = Paths.get("target/playwright-traces", 
                                   currentClassName + "_" + currentTestName + ".zip");
                    context.tracing().stop(new Tracing.StopOptions()
                            .setPath(tracePath));
                    reporter.logTrace("Trace captured", tracePath.toString());
                    CSLogger.info("Trace saved to: " + tracePath);
                }
                
                // Close context
                context.close();
                context = null;
                page = null;
                CSLogger.debug("Browser context and page closed");
            }
        } catch (Exception e) {
            CSLogger.error("Error cleaning up context: " + e.getMessage(), e);
        }
    }
    
    /**
     * Close Playwright and browser
     */
    protected void closePlaywright() {
        CSLogger.debug("Closing Playwright resources...");
        
        try {
            if (browser != null) {
                browser.close();
                browser = null;
                CSLogger.debug("Browser closed");
            }
            
            if (playwright != null) {
                playwright.close();
                playwright = null;
                CSLogger.debug("Playwright closed");
            }
        } catch (Exception e) {
            CSLogger.error("Error closing Playwright: " + e.getMessage(), e);
        }
    }
    
    /**
     * Handle test failure - capture screenshot, record info
     * 
     * @param result Test result
     */
    protected void handleTestFailure(ITestResult result) {
        try {
            // Capture screenshot if enabled
            if (screenshotOnFailureEnabled && page != null) {
                String screenshotName = currentClassName + "_" + currentTestName + "_failure";
                byte[] screenshot = page.screenshot(new Page.ScreenshotOptions()
                        .setFullPage(true)
                        .setPath(Paths.get("target/screenshots", screenshotName + ".png")));
                
                String screenshotPath = screenshotManager.saveScreenshot(screenshot, screenshotName);
                reporter.logScreenshot("Failure Screenshot", screenshotPath);
                CSLogger.info("Failure screenshot captured: " + screenshotPath);
            }
            
            // Log exception details
            if (result.getThrowable() != null) {
                reporter.logFailure("Exception", result.getThrowable().toString());
                
                // Record page error details if present
                if (page != null) {
                    String pageUrl = page.url();
                    String pageTitle = page.title();
                    String pageContent = page.content();
                    
                    reporter.logInfo("Page Details", "URL: " + pageUrl + ", Title: " + pageTitle);
                    CSLogger.info("Failure occurred on page: " + pageUrl + ", Title: " + pageTitle);
                    
                    // Save page DOM for debugging
                    String domPath = screenshotManager.savePageDom(pageContent, 
                                   currentClassName + "_" + currentTestName + "_dom.html");
                    reporter.logInfo("Page DOM", domPath);
                }
            }
        } catch (Exception e) {
            CSLogger.error("Error handling test failure: " + e.getMessage(), e);
        }
    }
    
    /**
     * Format execution time in a human-readable format
     * 
     * @param milliseconds Time in milliseconds
     * @return Formatted time string
     */
    protected String formatExecutionTime(long milliseconds) {
        long seconds = TimeUnit.MILLISECONDS.toSeconds(milliseconds) % 60;
        long minutes = TimeUnit.MILLISECONDS.toMinutes(milliseconds) % 60;
        long hours = TimeUnit.MILLISECONDS.toHours(milliseconds);
        
        if (hours > 0) {
            return String.format("%dh %dm %ds", hours, minutes, seconds);
        } else if (minutes > 0) {
            return String.format("%dm %ds", minutes, seconds);
        } else {
            return String.format("%ds", seconds);
        }
    }
    
    /**
     * Get test status as text
     * 
     * @param status Test status code
     * @return Status text
     */
    protected String getTestStatusText(int status) {
        switch (status) {
            case ITestResult.SUCCESS:
                return "PASSED";
            case ITestResult.FAILURE:
                return "FAILED";
            case ITestResult.SKIP:
                return "SKIPPED";
            default:
                return "UNKNOWN";
        }
    }
    
    /**
     * Navigate to a URL
     * 
     * @param url URL to navigate to
     */
    protected void navigateTo(String url) {
        CSLogger.info("Navigating to URL: " + url);
        page.navigate(url);
        reporter.logInfo("Navigation", "Navigated to URL: " + url);
    }
    
    /**
     * Store a value in the test context
     * 
     * @param key The key
     * @param value The value
     */
    protected void storeInContext(String key, Object value) {
        testContext.put(key, value);
    }
    
    /**
     * Retrieve a value from the test context
     * 
     * @param key The key
     * @param <T> The type of the value
     * @return The value
     */
    @SuppressWarnings("unchecked")
    protected <T> T getFromContext(String key) {
        return (T) testContext.get(key);
    }
    
    /**
     * Check if a key exists in the test context
     * 
     * @param key The key
     * @return True if the key exists, false otherwise
     */
    protected boolean hasInContext(String key) {
        return testContext.containsKey(key);
    }
    
    /**
     * Remove a value from the test context
     * 
     * @param key The key
     */
    protected void removeFromContext(String key) {
        testContext.remove(key);
    }
    
    /**
     * Clear the test context
     */
    protected void clearContext() {
        testContext.clear();
    }
    
    /**
     * Take a screenshot with a custom name
     * 
     * @param screenshotName Name of the screenshot
     * @return Path to the saved screenshot
     */
    protected String takeScreenshot(String screenshotName) {
        try {
            if (page != null) {
                byte[] screenshot = page.screenshot(new Page.ScreenshotOptions()
                        .setFullPage(true));
                
                String screenshotPath = screenshotManager.saveScreenshot(screenshot, screenshotName);
                reporter.logScreenshot("Screenshot: " + screenshotName, screenshotPath);
                return screenshotPath;
            }
        } catch (Exception e) {
            CSLogger.error("Failed to take screenshot: " + e.getMessage(), e);
        }
        return null;
    }
}


templates/projects/playwright/java/testng/src/test/java/pages/BasePage.java.templae
-----------------------------------------------------------------------------------------------

package ${package}.pages;

import com.microsoft.playwright.*;
import com.microsoft.playwright.options.*;

import ${package}.core.config.ConfigurationManager;
import ${package}.core.reporting.CSReporter;
import ${package}.core.utils.CSConstants;
import ${package}.core.utils.CSLogger;
import ${package}.core.utils.CSScreenshotManager;
import ${package}.playwright.java.testng.annotations.CSFindBy;
import ${package}.playwright.java.testng.browser.BrowserManager;
import ${package}.core.ai.SmartLocatorService;
import ${package}.core.ai.SelfHealingLocatorService;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Base Page Object class that provides common functionality for all page objects.
 * This class includes enhanced element interaction methods with built-in waiting,
 * reporting, and self-healing capabilities.
 */
public class BasePage {
    
    protected Page page;
    protected CSReporter reporter;
    protected SmartLocatorService smartLocatorService;
    protected SelfHealingLocatorService selfHealingLocatorService;
    protected CSScreenshotManager screenshotManager;
    protected int defaultTimeout;
    protected boolean autoHeal;
    protected ConfigurationManager configManager;
    
    /**
     * Constructor for BasePage
     */
    public BasePage() {
        this.page = BrowserManager.getPage();
        this.reporter = CSReporter.getInstance();
        this.smartLocatorService = SmartLocatorService.getInstance();
        this.selfHealingLocatorService = SelfHealingLocatorService.getInstance();
        this.screenshotManager = CSScreenshotManager.getInstance();
        this.configManager = ConfigurationManager.getInstance();
        this.defaultTimeout = configManager.getFrameworkConfig().getDefaultTimeoutInSeconds();
        this.autoHeal = configManager.getFrameworkConfig().isAutoHealEnabled();
        
        initPage();
    }
    
    /**
     * Constructor for BasePage with custom page
     * 
     * @param page Page instance
     */
    public BasePage(Page page) {
        this.page = page;
        this.reporter = CSReporter.getInstance();
        this.smartLocatorService = SmartLocatorService.getInstance();
        this.selfHealingLocatorService = SelfHealingLocatorService.getInstance();
        this.screenshotManager = CSScreenshotManager.getInstance();
        this.configManager = ConfigurationManager.getInstance();
        this.defaultTimeout = configManager.getFrameworkConfig().getDefaultTimeoutInSeconds();
        this.autoHeal = configManager.getFrameworkConfig().isAutoHealEnabled();
        
        initPage();
    }
    
    /**
     * Initialize page settings and event listeners
     */
    protected void initPage() {
        // Set default timeout
        page.setDefaultTimeout(defaultTimeout * 1000);
        
        // Add event listeners for logging
        page.onConsoleMessage(msg -> {
            if (msg.type().equals("error")) {
                CSLogger.warn("Browser Console Error: " + msg.text());
            } else if (configManager.getFrameworkConfig().isDebugMode()) {
                CSLogger.debug("Browser Console: [" + msg.type() + "] " + msg.text());
            }
        });
        
        page.onDialog(dialog -> {
            CSLogger.info("Browser Dialog [" + dialog.type() + "]: " + dialog.message());
            reporter.logInfo("Browser Dialog", dialog.type() + ": " + dialog.message());
            dialog.dismiss();
        });
        
        page.onPageError(error -> {
            CSLogger.error("Browser Page Error: " + error);
            reporter.logWarning("Browser Page Error", error);
        });
        
        page.onRequest(request -> {
            if (configManager.getFrameworkConfig().isDebugMode()) {
                CSLogger.debug("Request: " + request.method() + " " + request.url());
            }
        });
        
        page.onResponse(response -> {
            if (configManager.getFrameworkConfig().isDebugMode()) {
                CSLogger.debug("Response: " + response.status() + " " + response.url());
            }
            
            // Log failed requests
            if (response.status() >= 400) {
                CSLogger.warn("Failed Response: " + response.status() + " " + response.url());
            }
        });
    }
    
    /**
     * Waits for the page to load completely
     * 
     * @return this page object instance
     */
    public BasePage waitForPageLoad() {
        page.waitForLoadState(LoadState.DOMCONTENTLOADED);
        page.waitForLoadState(LoadState.LOAD);
        page.waitForLoadState(LoadState.NETWORKIDLE);
        return this;
    }
    
    /**
     * Navigates to a relative URL
     * 
     * @param relativeUrl Relative URL to navigate to
     * @return this page object instance
     */
    public BasePage navigateTo(String relativeUrl) {
        String baseUrl = configManager.getFrameworkConfig().getBaseUrl();
        String url = baseUrl + (relativeUrl.startsWith("/") ? relativeUrl : "/" + relativeUrl);
        
        try {
            page.navigate(url);
            reporter.logInfo("Navigation", "Navigated to URL: " + url);
            waitForPageLoad();
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(page, "navigationFailed");
            reporter.logFailure("Navigation failed", "Failed to navigate to URL " + url + ": " + e.getMessage());
            throw new RuntimeException("Failed to navigate to URL " + url, e);
        }
    }
    
    /**
     * Clicks an element with built-in waiting, reporting, and self-healing
     * 
     * @param selector Element selector
     * @return this page object instance
     */
    public BasePage click(String selector) {
        return click(selector, defaultTimeout);
    }
    
    /**
     * Clicks an element with custom timeout and built-in waiting, reporting, and self-healing
     * 
     * @param selector Element selector
     * @param timeoutSeconds Timeout in seconds
     * @return this page object instance
     */
    public BasePage click(String selector, int timeoutSeconds) {
        try {
            Locator locator = page.locator(selector);
            
            // Wait for element to be clickable
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutSeconds * 1000));
            
            // Get element text for logging
            String elementText = "";
            try {
                elementText = locator.textContent();
                if (elementText.isEmpty()) {
                    elementText = locator.getAttribute("name");
                    if (elementText == null || elementText.isEmpty()) {
                        elementText = selector;
                    }
                }
            } catch (Exception e) {
                elementText = selector;
            }
            
            // Click the element
            locator.click(new Locator.ClickOptions()
                    .setTimeout(timeoutSeconds * 1000));
            
            reporter.logInfo("Click", "Clicked on element: " + elementText);
            return this;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return click(healedSelector, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "clickFailed");
            reporter.logFailure("Click failed", "Failed to click on element with selector " + selector + ": " + e.getMessage());
            throw new RuntimeException("Failed to click on element with selector " + selector, e);
        }
    }
    
    /**
     * Types text into an input field with built-in waiting, reporting, and self-healing
     * 
     * @param selector Element selector
     * @param text Text to type
     * @return this page object instance
     */
    public BasePage fill(String selector, String text) {
        return fill(selector, text, defaultTimeout);
    }
    
    /**
     * Types text into an input field with custom timeout and built-in waiting, reporting, and self-healing
     * 
     * @param selector Element selector
     * @param text Text to type
     * @param timeoutSeconds Timeout in seconds
     * @return this page object instance
     */
    public BasePage fill(String selector, String text, int timeoutSeconds) {
        try {
            Locator locator = page.locator(selector);
            
            // Wait for element to be visible
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutSeconds * 1000));
            
            // Clear and fill the input
            locator.clear();
            locator.fill(text);
            
            reporter.logInfo("Fill", "Filled '" + (text.contains("password") ? "********" : text) + 
                          "' in element: " + selector);
            return this;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return fill(healedSelector, text, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "fillFailed");
            reporter.logFailure("Fill failed", "Failed to fill text in element with selector " + selector + ": " + e.getMessage());
            throw new RuntimeException("Failed to fill text in element with selector " + selector, e);
        }
    }
    
    /**
     * Types text and presses Enter with built-in waiting, reporting, and self-healing
     * 
     * @param selector Element selector
     * @param text Text to type
     * @return this page object instance
     */
    public BasePage typeAndEnter(String selector, String text) {
        return typeAndEnter(selector, text, defaultTimeout);
    }
    
    /**
     * Types text and presses Enter with custom timeout
     * 
     * @param selector Element selector
     * @param text Text to type
     * @param timeoutSeconds Timeout in seconds
     * @return this page object instance
     */
    public BasePage typeAndEnter(String selector, String text, int timeoutSeconds) {
        try {
            fill(selector, text, timeoutSeconds);
            page.locator(selector).press("Enter");
            reporter.logInfo("TypeAndEnter", "Typed text and pressed Enter in element: " + selector);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(page, "typeAndEnterFailed");
            reporter.logFailure("TypeAndEnter failed", "Failed to type text and press Enter in element: " + selector);
            throw new RuntimeException("Failed to type text and press Enter in element: " + selector, e);
        }
    }
    
    /**
     * Gets the text content of an element
     * 
     * @param selector Element selector
     * @return text content of the element
     */
    public String getText(String selector) {
        return getText(selector, defaultTimeout);
    }
    
    /**
     * Gets the text content of an element with custom timeout
     * 
     * @param selector Element selector
     * @param timeoutSeconds Timeout in seconds
     * @return text content of the element
     */
    public String getText(String selector, int timeoutSeconds) {
        try {
            Locator locator = page.locator(selector);
            
            // Wait for element to be visible
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutSeconds * 1000));
            
            String text = locator.textContent();
            reporter.logInfo("GetText", "Retrieved text from element: " + selector);
            return text;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return getText(healedSelector, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "getTextFailed");
            reporter.logFailure("GetText failed", "Failed to get text from element with selector " + selector + ": " + e.getMessage());
            throw new RuntimeException("Failed to get text from element with selector " + selector, e);
        }
    }
    
    /**
     * Gets the value of an attribute of an element
     * 
     * @param selector Element selector
     * @param attributeName Attribute name
     * @return attribute value
     */
    public String getAttribute(String selector, String attributeName) {
        return getAttribute(selector, attributeName, defaultTimeout);
    }
    
    /**
     * Gets the value of an attribute of an element with custom timeout
     * 
     * @param selector Element selector
     * @param attributeName Attribute name
     * @param timeoutSeconds Timeout in seconds
     * @return attribute value
     */
    public String getAttribute(String selector, String attributeName, int timeoutSeconds) {
        try {
            Locator locator = page.locator(selector);
            
            // Wait for element to be present
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.ATTACHED)
                    .setTimeout(timeoutSeconds * 1000));
            
            String value = locator.getAttribute(attributeName);
            reporter.logInfo("GetAttribute", "Retrieved attribute '" + attributeName + "' from element: " + selector);
            return value;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return getAttribute(healedSelector, attributeName, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "getAttributeFailed");
            reporter.logFailure("GetAttribute failed", "Failed to get attribute '" + attributeName + "' from element with selector " + selector + ": " + e.getMessage());
            throw new RuntimeException("Failed to get attribute '" + attributeName + "' from element with selector " + selector, e);
        }
    }
    
    /**
     * Hovers over an element
     * 
     * @param selector Element selector
     * @return this page object instance
     */
    public BasePage hover(String selector) {
        return hover(selector, defaultTimeout);
    }
    
    /**
     * Hovers over an element with custom timeout
     * 
     * @param selector Element selector
     * @param timeoutSeconds Timeout in seconds
     * @return this page object instance
     */
    public BasePage hover(String selector, int timeoutSeconds) {
        try {
            Locator locator = page.locator(selector);
            
            // Wait for element to be visible
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutSeconds * 1000));
            
            locator.hover(new Locator.HoverOptions()
                    .setTimeout(timeoutSeconds * 1000));
            
            reporter.logInfo("Hover", "Hovered over element: " + selector);
            return this;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return hover(healedSelector, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "hoverFailed");
            reporter.logFailure("Hover failed", "Failed to hover over element with selector " + selector + ": " + e.getMessage());
            throw new RuntimeException("Failed to hover over element with selector " + selector, e);
        }
    }
    
    /**
     * Selects an option from a dropdown by visible text
     * 
     * @param selector Dropdown selector
     * @param text Option text to select
     * @return this page object instance
     */
    public BasePage selectByText(String selector, String text) {
        return selectByText(selector, text, defaultTimeout);
    }
    
    /**
     * Selects an option from a dropdown by visible text with custom timeout
     * 
     * @param selector Dropdown selector
     * @param text Option text to select
     * @param timeoutSeconds Timeout in seconds
     * @return this page object instance
     */
    public BasePage selectByText(String selector, String text, int timeoutSeconds) {
        try {
            Locator locator = page.locator(selector);
            
            // Wait for dropdown to be visible
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutSeconds * 1000));
            
            // Select by visible text
            locator.selectOption(new SelectOption().setLabel(text));
            
            reporter.logInfo("Select", "Selected option '" + text + "' from dropdown: " + selector);
            return this;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return selectByText(healedSelector, text, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "selectByTextFailed");
            reporter.logFailure("Select failed", "Failed to select option '" + text + "' from dropdown with selector " + selector + ": " + e.getMessage());
            throw new RuntimeException("Failed to select option '" + text + "' from dropdown with selector " + selector, e);
        }
    }
    
    /**
     * Selects an option from a dropdown by value
     * 
     * @param selector Dropdown selector
     * @param value Option value to select
     * @return this page object instance
     */
    public BasePage selectByValue(String selector, String value) {
        return selectByValue(selector, value, defaultTimeout);
    }
    
    /**
     * Selects an option from a dropdown by value with custom timeout
     * 
     * @param selector Dropdown selector
     * @param value Option value to select
     * @param timeoutSeconds Timeout in seconds
     * @return this page object instance
     */
    public BasePage selectByValue(String selector, String value, int timeoutSeconds) {
        try {
            Locator locator = page.locator(selector);
            
            // Wait for dropdown to be visible
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutSeconds * 1000));
            
            // Select by value
            locator.selectOption(new SelectOption().setValue(value));
            
            reporter.logInfo("Select", "Selected option with value '" + value + "' from dropdown: " + selector);
            return this;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return selectByValue(healedSelector, value, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "selectByValueFailed");
            reporter.logFailure("Select failed", "Failed to select option with value '" + value + "' from dropdown with selector " + selector + ": " + e.getMessage());
            throw new RuntimeException("Failed to select option with value '" + value + "' from dropdown with selector " + selector, e);
        }
    }
    
    /**
     * Checks if an element is visible
     * 
     * @param selector Element selector
     * @return true if element is visible, false otherwise
     */
    public boolean isVisible(String selector) {
        return isVisible(selector, defaultTimeout);
    }
    
    /**
     * Checks if an element is visible with custom timeout
     * 
     * @param selector Element selector
     * @param timeoutSeconds Timeout in seconds
     * @return true if element is visible, false otherwise
     */
    public boolean isVisible(String selector, int timeoutSeconds) {
        try {
            boolean visible = page.locator(selector).isVisible();
            CSLogger.debug("Element visibility check: " + selector + " - " + visible);
            return visible;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        return isVisible(healedSelector, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            CSLogger.debug("Element visibility check failed for selector: " + selector + " - " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Checks if an element exists in the DOM
     * 
     * @param selector Element selector
     * @return true if element exists, false otherwise
     */
    public boolean exists(String selector) {
        return exists(selector, defaultTimeout);
    }
    
    /**
     * Checks if an element exists in the DOM with custom timeout
     * 
     * @param selector Element selector
     * @param timeoutSeconds Timeout in seconds
     * @return true if element exists, false otherwise
     */
    public boolean exists(String selector, int timeoutSeconds) {
        try {
            page.setDefaultTimeout(timeoutSeconds * 1000);
            int count = page.locator(selector).count();
            page.setDefaultTimeout(defaultTimeout * 1000);
            return count > 0;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        return exists(healedSelector, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            return false;
        }
    }
    
    /**
     * Waits for an element to be visible
     * 
     * @param selector Element selector
     * @return this page object instance
     */
    public BasePage waitForElementVisible(String selector) {
        return waitForElementVisible(selector, defaultTimeout);
    }
    
    /**
     * Waits for an element to be visible with custom timeout
     * 
     * @param selector Element selector
     * @param timeoutSeconds Timeout in seconds
     * @return this page object instance
     */
    public BasePage waitForElementVisible(String selector, int timeoutSeconds) {
        try {
            page.locator(selector).waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutSeconds * 1000));
            
            reporter.logInfo("Wait", "Element is visible: " + selector);
            return this;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return waitForElementVisible(healedSelector, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "waitForElementVisibleFailed");
            reporter.logFailure("Wait failed", "Element did not become visible within " + timeoutSeconds + " seconds: " + selector);
            throw new RuntimeException("Element did not become visible within " + timeoutSeconds + " seconds: " + selector, e);
        }
    }
    
    /**
     * Waits for an element to be hidden
     * 
     * @param selector Element selector
     * @return this page object instance
     */
    public BasePage waitForElementHidden(String selector) {
        return waitForElementHidden(selector, defaultTimeout);
    }
    
    /**
     * Waits for an element to be hidden with custom timeout
     * 
     * @param selector Element selector
     * @param timeoutSeconds Timeout in seconds
     * @return this page object instance
     */
    public BasePage waitForElementHidden(String selector, int timeoutSeconds) {
        try {
            page.locator(selector).waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.HIDDEN)
                    .setTimeout(timeoutSeconds * 1000));
            
            reporter.logInfo("Wait", "Element is hidden: " + selector);
            return this;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return waitForElementHidden(healedSelector, timeoutSeconds);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "waitForElementHiddenFailed");
            reporter.logFailure("Wait failed", "Element did not become hidden within " + timeoutSeconds + " seconds: " + selector);
            throw new RuntimeException("Element did not become hidden within " + timeoutSeconds + " seconds: " + selector, e);
        }
    }
    
    /**
     * Takes a screenshot
     * 
     * @param name Screenshot name
     * @return path to the screenshot file
     */
    public String takeScreenshot(String name) {
        try {
            Path screenshotPath = screenshotManager.captureScreenshot(page, name);
            reporter.logInfo("Screenshot", "Screenshot captured: " + name);
            return screenshotPath.toString();
        } catch (Exception e) {
            CSLogger.error("Failed to take screenshot: " + e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Executes JavaScript in the browser
     * 
     * @param script JavaScript code to execute
     * @param args Script arguments
     * @return result of the script execution
     */
    public Object executeScript(String script, Object... args) {
        try {
            Object result = page.evaluate(script, Arrays.asList(args));
            reporter.logInfo("JavaScript", "Executed JavaScript in the browser");
            return result;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(page, "executeScriptFailed");
            reporter.logFailure("JavaScript failed", "Failed to execute JavaScript: " + e.getMessage());
            throw new RuntimeException("Failed to execute JavaScript", e);
        }
    }
    
    /**
     * Waits for a specified amount of time
     * 
     * @param seconds Time to wait in seconds
     * @return this page object instance
     */
    public BasePage wait(double seconds) {
        try {
            page.waitForTimeout(seconds * 1000);
            reporter.logInfo("Wait", "Waited for " + seconds + " seconds");
            return this;
        } catch (Exception e) {
            reporter.logWarning("Wait interrupted", "Wait was interrupted: " + e.getMessage());
            return this;
        }
    }
    
    /**
     * Gets the current URL
     * 
     * @return current URL
     */
    public String getCurrentUrl() {
        return page.url();
    }
    
    /**
     * Gets the page title
     * 
     * @return page title
     */
    public String getTitle() {
        return page.title();
    }
    
    /**
     * Reloads the page
     * 
     * @return this page object instance
     */
    public BasePage refresh() {
        try {
            page.reload();
            waitForPageLoad();
            reporter.logInfo("Navigation", "Page reloaded");
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(page, "refreshFailed");
            reporter.logFailure("Refresh failed", "Failed to reload the page: " + e.getMessage());
            throw new RuntimeException("Failed to reload the page", e);
        }
    }
    
    /**
     * Navigates back in browser history
     * 
     * @return this page object instance
     */
    public BasePage goBack() {
        try {
            page.goBack();
            waitForPageLoad();
            reporter.logInfo("Navigation", "Navigated back in browser history");
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(page, "goBackFailed");
            reporter.logFailure("Navigation failed", "Failed to navigate back: " + e.getMessage());
            throw new RuntimeException("Failed to navigate back", e);
        }
    }
    
    /**
     * Navigates forward in browser history
     * 
     * @return this page object instance
     */
    public BasePage goForward() {
        try {
            page.goForward();
            waitForPageLoad();
            reporter.logInfo("Navigation", "Navigated forward in browser history");
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(page, "goForwardFailed");
            reporter.logFailure("Navigation failed", "Failed to navigate forward: " + e.getMessage());
            throw new RuntimeException("Failed to navigate forward", e);
        }
    }
    
    /**
     * Presses a key on the keyboard
     * 
     * @param key Key to press
     * @return this page object instance
     */
    public BasePage pressKey(String key) {
        try {
            page.keyboard().press(key);
            reporter.logInfo("Keyboard", "Pressed key: " + key);
            return this;
        } catch (Exception e) {
            screenshotManager.captureScreenshot(page, "pressKeyFailed");
            reporter.logFailure("Keyboard action failed", "Failed to press key " + key + ": " + e.getMessage());
            throw new RuntimeException("Failed to press key " + key, e);
        }
    }
    
    /**
     * Uploads a file to an input element
     * 
     * @param selector File input selector
     * @param filePath Path to the file to upload
     * @return this page object instance
     */
    public BasePage uploadFile(String selector, String filePath) {
        try {
            Locator locator = page.locator(selector);
            
            // Wait for element to be present
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(WaitForSelectorState.ATTACHED)
                    .setTimeout(defaultTimeout * 1000));
            
            // Set input files
            locator.setInputFiles(Paths.get(filePath));
            
            reporter.logInfo("Upload", "Uploaded file: " + filePath);
            return this;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return uploadFile(healedSelector, filePath);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            screenshotManager.captureScreenshot(page, "uploadFileFailed");
            reporter.logFailure("Upload failed", "Failed to upload file to element with selector " + selector + ": " + e.getMessage());
            throw new RuntimeException("Failed to upload file to element with selector " + selector, e);
        }
    }
    
    /**
     * Gets the count of elements matching a selector
     * 
     * @param selector Element selector
     * @return number of matching elements
     */
    public int getElementCount(String selector) {
        try {
            int count = page.locator(selector).count();
            reporter.logInfo("Element count", "Found " + count + " elements matching selector: " + selector);
            return count;
        } catch (Exception e) {
            if (autoHeal) {
                try {
                    // Attempt to heal the selector
                    String healedSelector = selfHealingLocatorService.healSelector(page, selector);
                    if (!healedSelector.equals(selector)) {
                        CSLogger.info("Self-healed selector from " + selector + " to " + healedSelector);
                        reporter.logInfo("Self-healed selector", "Original: " + selector + " → Healed: " + healedSelector);
                        return getElementCount(healedSelector);
                    }
                } catch (Exception healException) {
                    CSLogger.error("Failed to heal selector: " + healException.getMessage(), healException);
                }
            }
            
            CSLogger.error("Failed to get element count: " + e.getMessage(), e);
            return 0;
        }
    }
    
    /**
     * Gets the current page object
     * 
     * @return Playwright Page object
     */
    public Page getPage() {
        return page;
    }
    
    /**
     * Generates smart locators for an element
     * 
     * @param selector Base selector
     * @return List of alternative locators
     */
    public List<String> generateSmartLocators(String selector) {
        try {
            return smartLocatorService.generateLocators(page, selector);
        } catch (Exception e) {
            CSLogger.error("Failed to generate smart locators: " + e.getMessage(), e);
            return List.of(selector);
        }
    }
}

templates/projects/playwright/java/testng/README.md.templage
----------------------------------------------------------------


# ${project.name} - Playwright Java TestNG Test Automation Framework

## Overview

This test automation framework provides a robust, maintainable, and scalable solution for web application testing using Microsoft Playwright with Java and TestNG. Built with the CSTestForge framework, it offers enhanced capabilities such as AI-powered element identification, self-healing locators, and comprehensive reporting.

## Table of Contents

- [Features](#features)
- [Project Structure](#project-structure)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Configuration](#configuration)
- [Writing Tests](#writing-tests)
  - [Test Classes](#test-classes)
  - [Page Objects](#page-objects)
  - [Data-Driven Testing](#data-driven-testing)
  - [Test Annotations](#test-annotations)
- [Running Tests](#running-tests)
- [Reporting](#reporting)
- [Advanced Features](#advanced-features)
- [CI/CD Integration](#cicd-integration)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

## Features

- **Playwright Integration**: Utilize Microsoft Playwright's powerful browser automation capabilities
- **Multi-Browser Support**: Test on Chromium, Firefox, and WebKit with the same code
- **TestNG Framework**: Structured test organization with annotations and test lifecycle management
- **Page Object Model**: Enhanced page objects with fluent API and self-healing capabilities
- **Smart Element Location**: AI-powered element identification with alternative locator strategies
- **Self-Healing Capabilities**: Automatic recovery from broken element locators during test execution
- **Trace Recording**: Capture detailed traces with screenshots and DOM snapshots for test debugging
- **Video Recording**: Record test executions for visual debugging and documentation
- **Parallel Execution**: Run tests in parallel across multiple browsers and contexts
- **Comprehensive Reporting**: Detailed HTML reports with screenshots, traces, and videos
- **Data-Driven Testing**: Integration with various data sources (Excel, CSV, JSON, Databases)
- **Environment Management**: Seamless switching between test environments (dev, qa, staging, prod)
- **CI/CD Integration**: Built-in support for continuous integration platforms

## Project Structure

```
${project.name}/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── ${package.path}/
│   │   │       ├── core/
│   │   │       │   ├── config/
│   │   │       │   │   ├── ConfigurationManager.java
│   │   │       │   │   ├── EnvironmentConfig.java
│   │   │       │   │   └── FrameworkConfig.java
│   │   │       │   ├── utils/
│   │   │       │   │   ├── CSDateUtils.java
│   │   │       │   │   ├── CSFileUtils.java
│   │   │       │   │   ├── CSTextUtils.java
│   │   │       │   │   ├── CSScreenshotManager.java
│   │   │       │   │   ├── CSConstants.java
│   │   │       │   │   └── CSLogger.java
│   │   │       │   ├── data/
│   │   │       │   │   ├── CSTestForgeDataProvider.java
│   │   │       │   │   ├── CSDataSourceFactory.java
│   │   │       │   │   └── sources/
│   │   │       │   │       ├── CSDataSource.java
│   │   │       │   │       ├── ExcelDataSource.java
│   │   │       │   │       ├── CsvDataSource.java
│   │   │       │   │       ├── JsonDataSource.java
│   │   │       │   │       └── DatabaseDataSource.java
│   │   │       │   ├── reporting/
│   │   │       │   │   ├── CSReporter.java
│   │   │       │   │   ├── CSHtmlReportGenerator.java
│   │   │       │   │   ├── CSTestResult.java
│   │   │       │   │   ├── CSTestStep.java
│   │   │       │   │   └── listeners/
│   │   │       │   │       └── CSTestListener.java
│   │   │       │   └── ai/
│   │   │       │       ├── ElementRecognitionService.java
│   │   │       │       ├── SmartLocatorService.java
│   │   │       │       └── SelfHealingLocatorService.java
│   │   │       └── playwright/
│   │   │           ├── browser/
│   │   │           │   ├── BrowserManager.java
│   │   │           │   ├── BrowserType.java
│   │   │           │   └── BrowserFactory.java
│   │   │           └── annotations/
│   │   │               └── CSFindBy.java
│   │   └── resources/
│   │       ├── config/
│   │       │   ├── framework-config.properties
│   │       │   └── environment/
│   │       │       ├── dev.properties
│   │       │       ├── qa.properties
│   │       │       ├── stage.properties
│   │       │       └── prod.properties
│   │       └── logback.xml
│   └── test/
│       ├── java/
│       │   └── ${package.path}/
│       │       ├── pages/
│       │       │   ├── BasePage.java
│       │       │   ├── LoginPage.java
│       │       │   ├── DashboardPage.java
│       │       │   └── ... (other page objects)
│       │       ├── tests/
│       │       │   ├── BaseTest.java
│       │       │   ├── LoginTest.java
│       │       │   └── ... (other test classes)
│       │       └── utils/
│       │           ├── TestData.java
│       │           └── TestUtils.java
│       └── resources/
│           ├── testdata/
│           │   ├── testdata.xlsx
│           │   ├── testdata.csv
│           │   └── testdata.json
│           ├── testng.xml
│           └── testng-parallel.xml
├── target/
│   ├── reports/
│   │   ├── html/
│   │   ├── screenshots/
│   │   ├── traces/
│   │   └── videos/
│   ├── playwright-videos/
│   └── playwright-traces/
├── pom.xml
├── README.md
└── .gitignore
```

## Prerequisites

- Java 17 or higher
- Maven 3.8.0 or higher
- Playwright for Java (automatically installed by Maven)
- IDE (IntelliJ IDEA, Eclipse, or VS Code recommended)

## Installation

1. Clone this repository:
   ```bash
   git clone https://your-repository-url/${project.name}.git
   cd ${project.name}
   ```

2. Install dependencies and Playwright browsers:
   ```bash
   mvn clean install -DskipTests
   ```

This will automatically download and install the required Playwright browser binaries (Chromium, Firefox, WebKit).

## Configuration

The framework uses a hierarchical configuration system:

1. **Base Configuration**: `src/main/resources/config/framework-config.properties`
2. **Environment-Specific Configurations**: `src/main/resources/config/environment/*.properties`
3. **Runtime Configuration**: System properties passed via command line

Key configuration properties:

```properties
# Framework Configuration
browser=chromium                      # chromium, firefox, webkit
headless=true                         # true/false
defaultTimeoutInSeconds=30            # Default timeout in seconds
screenshotOnFailure=true              # Capture screenshots on test failure
videoRecording=false                  # Enable video recording
traceEnabled=false                    # Enable trace recording
aiSmartLocators=true                  # Enable AI-powered locators
aiSelfHealing=true                    # Enable self-healing locators

# Application Configuration
baseUrl=https://your-application-url.com
apiBaseUrl=https://api.your-application-url.com
username=testuser
password=TestPassword123
```

To specify the environment:

```bash
mvn test -Denvironment=qa
```

## Writing Tests

### Test Classes

Test classes should extend the `BaseTest` class and use TestNG annotations:

```java
import org.testng.annotations.Test;
import org.testng.Assert;
import ${package}.tests.BaseTest;
import ${package}.pages.LoginPage;
import ${package}.pages.DashboardPage;

public class LoginTest extends BaseTest {
    
    private LoginPage loginPage;
    private DashboardPage dashboardPage;
    
    @BeforeMethod
    public void setUp() {
        loginPage = new LoginPage();
        dashboardPage = new DashboardPage();
    }
    
    @Test(description = "Verify successful login with valid credentials")
    public void testValidLogin() {
        // Navigate to the login page
        loginPage.navigateTo();
        
        // Login with valid credentials
        loginPage.enterUsername("validuser")
                 .enterPassword("validpassword")
                 .clickLoginButton();
        
        // Verify successful login
        Assert.assertTrue(dashboardPage.isPageLoaded(), "Dashboard should be loaded after login");
        Assert.assertEquals(dashboardPage.getWelcomeMessage(), "Welcome, validuser!");
    }
    
    @Test(description = "Verify login fails with invalid credentials")
    public void testInvalidLogin() {
        // Navigate to the login page
        loginPage.navigateTo();
        
        // Login with invalid credentials
        loginPage.enterUsername("invaliduser")
                 .enterPassword("invalidpassword")
                 .clickLoginButton();
        
        // Verify login failure
        Assert.assertTrue(loginPage.isErrorMessageDisplayed(), "Error message should be displayed");
        Assert.assertEquals(loginPage.getErrorMessage(), "Invalid username or password");
    }
}
```

### Page Objects

Page objects should extend the `BasePage` class and use a fluent API:

```java
import ${package}.pages.BasePage;
import com.microsoft.playwright.Locator;
import ${package}.playwright.java.annotations.CSFindBy;

public class LoginPage extends BasePage {
    
    // Element selectors
    private static final String USERNAME_FIELD = "#username";
    private static final String PASSWORD_FIELD = "#password";
    private static final String LOGIN_BUTTON = "button[type='submit']";
    private static final String ERROR_MESSAGE = ".error-message";
    
    // Use CSFindBy annotation for enhanced locators with AI support
    @CSFindBy(css = ".login-form")
    private String loginForm;
    
    public LoginPage() {
        super();
    }
    
    public LoginPage navigateTo() {
        navigateTo("/login");
        return this;
    }
    
    public LoginPage enterUsername(String username) {
        fill(USERNAME_FIELD, username);
        return this;
    }
    
    public LoginPage enterPassword(String password) {
        fill(PASSWORD_FIELD, password);
        return this;
    }
    
    public void clickLoginButton() {
        click(LOGIN_BUTTON);
        waitForPageLoad();
    }
    
    public boolean isErrorMessageDisplayed() {
        return isVisible(ERROR_MESSAGE);
    }
    
    public String getErrorMessage() {
        return getText(ERROR_MESSAGE);
    }
    
    public void login(String username, String password) {
        enterUsername(username);
        enterPassword(password);
        clickLoginButton();
    }
    
    @Override
    public boolean isPageLoaded() {
        return isVisible(loginForm);
    }
}
```

### Data-Driven Testing

Use the `@CSTestForgeDataProvider` annotation for data-driven tests:

```java
import org.testng.annotations.Test;
import org.testng.Assert;
import ${package}.tests.BaseTest;
import ${package}.pages.LoginPage;
import ${package}.pages.DashboardPage;
import ${package}.core.data.CSTestForgeDataProvider;

public class DataDrivenLoginTest extends BaseTest {
    
    private LoginPage loginPage;
    private DashboardPage dashboardPage;
    
    @BeforeMethod
    public void setUp() {
        loginPage = new LoginPage();
        dashboardPage = new DashboardPage();
    }
    
    @Test(dataProvider = "loginData")
    @CSTestForgeDataProvider(source = "testdata/login_data.xlsx", sheet = "Login")
    public void testLogin(String username, String password, boolean expectSuccess, String expectedMessage) {
        // Navigate to the login page
        loginPage.navigateTo();
        
        // Login with provided credentials
        loginPage.enterUsername(username)
                 .enterPassword(password)
                 .clickLoginButton();
        
        if (expectSuccess) {
            // Verify successful login
            Assert.assertTrue(dashboardPage.isPageLoaded(), "Dashboard should be loaded after login");
            Assert.assertEquals(dashboardPage.getWelcomeMessage(), expectedMessage);
        } else {
            // Verify login failure
            Assert.assertTrue(loginPage.isErrorMessageDisplayed(), "Error message should be displayed");
            Assert.assertEquals(loginPage.getErrorMessage(), expectedMessage);
        }
    }
}
```

Excel data format (login_data.xlsx):

| username   | password      | expectSuccess | expectedMessage           |
|------------|---------------|---------------|---------------------------|
| validuser  | validpassword | true          | Welcome, validuser!       |
| invaliduser| invalidpassword| false        | Invalid username or password |
| ""         | validpassword | false         | Username cannot be empty  |
| validuser  | ""            | false         | Password cannot be empty  |

### Test Annotations

The framework leverages TestNG annotations:

- `@Test`: Marks a method as a test method
- `@BeforeMethod`: Runs before each test method in a class
- `@AfterMethod`: Runs after each test method in a class
- `@BeforeClass`: Runs once before any test method in a class
- `@AfterClass`: Runs once after all test methods in a class
- `@BeforeSuite`: Runs once before any test in the suite
- `@AfterSuite`: Runs once after all tests in the suite
- `@Parameters`: Defines parameters for a test method
- `@DataProvider`: Defines a data provider method

## Running Tests

To run all tests:

```bash
mvn clean test
```

To run a specific test class:

```bash
mvn clean test -Dtest=LoginTest
```

To run a specific test method:

```bash
mvn clean test -Dtest=LoginTest#testValidLogin
```

To run with a specific browser:

```bash
```bash
mvn clean test -Dbrowser=firefox
```

To run tests in headed mode:

```bash
mvn clean test -Dheaded=true
```

To run tests in parallel:

```bash
mvn clean test -P parallel
```

To run tests with a specific environment:

```bash
mvn clean test -Denvironment=qa
```

To run tests with specific groups:

```bash
mvn clean test -Dgroups=smoke
```

### Maven Profiles

The project includes several Maven profiles for different execution scenarios:

```bash
# Run chromium tests
mvn clean test -P chromium

# Run firefox tests
mvn clean test -P firefox

# Run webkit tests
mvn clean test -P webkit

# Run in headed mode
mvn clean test -P headed

# Run in headless mode
mvn clean test -P headless

# Run smoke tests
mvn clean test -P smoke

# Run regression tests
mvn clean test -P regression

# Run in parallel
mvn clean test -P parallel

# Run in CI environment
mvn clean test -P ci
```

You can combine profiles:

```bash
# Run smoke tests in firefox in headed mode
mvn clean test -P smoke,firefox,headed
```

## Reporting

The framework generates comprehensive HTML reports with screenshots, traces, and videos. Reports are created in the `target/reports` directory after test execution.

Key reporting features:

1. **HTML Reports**: Detailed HTML reports with test execution summary and details
2. **Screenshots**: Automatic screenshots for failed tests
3. **Traces**: Playwright traces with DOM snapshots and network activity
4. **Videos**: Test execution videos for visual debugging
5. **Logs**: Execution logs with timestamped events

To view the report after test execution, open `target/reports/html/index.html` in your browser.

## Advanced Features

### Trace Recording

Playwright traces provide a detailed timeline of test execution with screenshots, DOM snapshots, and network activity:

```java
// Enable trace recording in your test
context.tracing().start(new Tracing.StartOptions()
        .setScreenshots(true)
        .setSnapshots(true));

// Test execution...

// Save trace at the end of the test
context.tracing().stop(new Tracing.StopOptions()
        .setPath(Paths.get("target/playwright-traces", "trace.zip")));
```

The framework automatically handles trace recording when enabled in the configuration.

### Video Recording

Record videos of test executions for visual debugging:

```java
// Enable video recording in your test
BrowserContext.CreateOptions contextOptions = new BrowserContext.CreateOptions()
        .setRecordVideoDir(Paths.get("target/playwright-videos"));

BrowserContext context = browser.newContext(contextOptions);
```

The framework automatically handles video recording when enabled in the configuration.

### Self-Healing Locators

The framework includes self-healing locators that automatically recover from broken locators during test execution:

```java
// In BasePage class
public BasePage click(String selector) {
    try {
        page.locator(selector).click();
    } catch (Exception e) {
        // Attempt to heal the selector
        String healedSelector = selfHealingLocatorService.healSelector(page, selector);
        if (!healedSelector.equals(selector)) {
            page.locator(healedSelector).click();
        } else {
            throw e;
        }
    }
    return this;
}
```

To enable self-healing locators, set `aiSelfHealing=true` in your configuration.

### AI-Enhanced Element Recognition

The framework uses advanced AI techniques to identify elements more reliably:

```java
// In SmartLocatorService class
public String findBestSelector(Page page, String baseSelector) {
    // Try multiple selector strategies
    List<String> alternativeSelectors = generateAlternativeSelectors(page, baseSelector);
    
    // Evaluate each selector for uniqueness and stability
    return alternativeSelectors.stream()
            .max(Comparator.comparingDouble(selector -> evaluateSelectorQuality(page, selector)))
            .orElse(baseSelector);
}
```

To enable AI-enhanced element recognition, set `aiSmartLocators=true` in your configuration.

### Parallel Execution

TestNG allows running tests in parallel to reduce execution time:

```xml
<!-- In testng-parallel.xml -->
<suite name="Parallel Test Suite" parallel="methods" thread-count="4">
    <test name="Parallel Tests">
        <packages>
            <package name="${package}.tests.*"/>
        </packages>
    </test>
</suite>
```

Run tests in parallel using the parallel profile:

```bash
mvn clean test -P parallel
```

### Cross-Browser Testing

Run tests on multiple browsers:

```bash
# Run on Chromium
mvn clean test -Dbrowser=chromium

# Run on Firefox
mvn clean test -Dbrowser=firefox

# Run on WebKit
mvn clean test -Dbrowser=webkit
```

The framework automatically handles browser initialization based on the specified browser.

## CI/CD Integration

### GitHub Actions

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Run Tests
        run: mvn clean test -P ci
      - name: Upload Reports
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-reports
          path: |
            target/reports/
            target/playwright-videos/
            target/playwright-traces/
```

### Jenkins Pipeline

```groovy
// Jenkinsfile
pipeline {
    agent any
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Test') {
            steps {
                sh 'mvn clean test -P ci'
            }
        }
    }
    
    post {
        always {
            publishHTML(target: [
                allowMissing: false,
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: 'target/reports/html',
                reportFiles: 'index.html',
                reportName: 'Test Report'
            ])
            
            archiveArtifacts artifacts: 'target/reports/**/*,target/playwright-videos/**/*,target/playwright-traces/**/*', fingerprint: true
        }
    }
}
```

### Azure DevOps Pipeline

```yaml
# azure-pipelines.yml
trigger:
  - main

pool:
  vmImage: 'ubuntu-latest'

steps:
  - task: Maven@3
    inputs:
      mavenPomFile: 'pom.xml'
      goals: 'clean test'
      options: '-P ci'
    displayName: 'Run Tests'
  
  - task: PublishTestResults@2
    inputs:
      testResultsFormat: 'JUnit'
      testResultsFiles: '**/surefire-reports/TEST-*.xml'
      mergeTestResults: true
      testRunTitle: 'Playwright Tests'
    displayName: 'Publish Test Results'
  
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: 'target/reports'
      ArtifactName: 'reports'
      publishLocation: 'Container'
    displayName: 'Publish Reports'
  
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: 'target/playwright-videos'
      ArtifactName: 'videos'
      publishLocation: 'Container'
    displayName: 'Publish Videos'
  
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: 'target/playwright-traces'
      ArtifactName: 'traces'
      publishLocation: 'Container'
    displayName: 'Publish Traces'
```

## Best Practices

### Framework Usage

1. **Follow Page Object Model**: Keep UI interactions in page objects, not tests
2. **Single Responsibility**: Each test should verify one feature or behavior
3. **Reuse Code**: Utilize the BasePage and BaseTest classes for common functionality
4. **Manage Test Data**: Use data-driven testing and external data sources
5. **Handle Waits Properly**: Use Playwright's built-in auto-waiting instead of explicit waits
6. **Record Traces**: Enable trace recording for complex tests to simplify debugging
7. **Capture Screenshots**: Use automatic screenshots for failed tests
8. **Utilize Self-Healing**: Enable self-healing locators for more robust tests
9. **Maintain Test Independence**: Tests should not depend on each other
10. **Use Explicit Assertions**: Include descriptive messages in assertions

### Code Quality

1. **Follow Java Code Conventions**: Maintain a consistent coding style
2. **Use Meaningful Names**: Use descriptive names for classes, methods, and variables
3. **Keep Methods Short**: Methods should do one thing and be concise
4. **Add Javadoc Comments**: Document classes and methods with Javadoc
5. **Use Constants**: Define constants for selectors and test data
6. **Handle Exceptions**: Properly handle exceptions with meaningful error messages
7. **Avoid Hardcoding**: Use configuration files for environment-specific values
8. **Use Fluent APIs**: Chain methods for more readable test code
9. **Implement Proper Logging**: Log important events and actions
10. **Write Clean Code**: Follow SOLID principles and clean code practices

## Troubleshooting

### Common Issues

1. **Element Not Found**
   - Verify the selector is correct
   - Check if the element is in an iframe
   - Ensure the element is in the viewport
   - Enable self-healing locators

2. **Test Times Out**
   - Increase the default timeout in configuration
   - Check for network issues or slow loading
   - Add explicit waits for specific conditions

3. **Test Fails Intermittently**
   - Add retry logic for flaky tests
   - Check for timing issues
   - Enable video recording to diagnose the issue
   - Enable trace recording for detailed debugging

4. **Browser Crashes**
   - Check system resources (memory, CPU)
   - Update Playwright version
   - Use headless mode for resource-constrained environments

### Debugging Techniques

1. **Enable Trace Recording**:
   ```java
   context.tracing().start(new Tracing.StartOptions()
           .setScreenshots(true)
           .setSnapshots(true));
   ```

2. **Enable Video Recording**:
   ```java
   BrowserContext.CreateOptions options = new BrowserContext.CreateOptions()
           .setRecordVideoDir(Paths.get("target/videos"));
   ```

3. **Enable Headed Mode**:
   ```bash
   mvn test -Dheaded=true
   ```

4. **Increase Log Level**:
   ```
   # In logback.xml
   <logger name="${package}" level="DEBUG" />
   ```

5. **Use Pause for Debugging**:
   ```java
   // Add a pause for debugging
   page.pause();
   ```

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the terms of the license provided by your organization. See the LICENSE file for details.

---

Generated by CSTestForge Framework v1.0.0



templates/projects/playwright/java/bdd/pom.xml.templage
-------------------------------------------------------------

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>${groupId}</groupId>
    <artifactId>${artifactId}</artifactId>
    <version>${version}</version>
    <packaging>jar</packaging>

    <n>${project.name}</n>
    <description>${project.description}</description>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>17</java.version>
        <maven.compiler.source>${java.version}</maven.compiler.source>
        <maven.compiler.target>${java.version}</maven.compiler.target>
        
        <!-- Dependencies Versions -->
        <playwright.version>1.36.0</playwright.version>
        <cucumber.version>7.14.0</cucumber.version>
        <extentreports.version>5.1.1</extentreports.version>
        <log4j.version>2.20.0</log4j.version>
        <slf4j.version>2.0.9</slf4j.version>
        <logback.version>1.4.11</logback.version>
        <jackson.version>2.15.2</jackson.version>
        <commons-io.version>2.13.0</commons-io.version>
        <commons-lang3.version>3.13.0</commons-lang3.version>
        <commons-text.version>1.10.0</commons-text.version>
        <commons-csv.version>1.10.0</commons-csv.version>
        <commons-collections4.version>4.4</commons-collections4.version>
        <poi.version>5.2.3</poi.version>
        <rest-assured.version>5.3.2</rest-assured.version>
        <gson.version>2.10.1</gson.version>
        <lombok.version>1.18.28</lombok.version>
        <assertj.version>3.24.2</assertj.version>
        <awaitility.version>4.2.0</awaitility.version>
        <monte-screen-recorder.version>0.7.7.0</monte-screen-recorder.version>
        <cucumber-reporting.version>5.7.7</cucumber-reporting.version>
        
        <!-- Plugin Versions -->
        <maven-compiler-plugin.version>3.11.0</maven-compiler-plugin.version>
        <maven-surefire-plugin.version>3.1.2</maven-surefire-plugin.version>
        <maven-resources-plugin.version>3.3.1</maven-resources-plugin.version>
        <maven-clean-plugin.version>3.3.1</maven-clean-plugin.version>
        <maven-jar-plugin.version>3.3.0</maven-jar-plugin.version>
        <maven-source-plugin.version>3.3.0</maven-source-plugin.version>
        <maven-javadoc-plugin.version>3.5.0</maven-javadoc-plugin.version>
        <jacoco-maven-plugin.version>0.8.10</jacoco-maven-plugin.version>
    </properties>

    <dependencies>
        <!-- Playwright -->
        <dependency>
            <groupId>com.microsoft.playwright</groupId>
            <artifactId>playwright</artifactId>
            <version>${playwright.version}</version>
        </dependency>
        
        <!-- Cucumber -->
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-java</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-junit</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-picocontainer</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-core</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        
        <!-- Reporting -->
        <dependency>
            <groupId>com.aventstack</groupId>
            <artifactId>extentreports</artifactId>
            <version>${extentreports.version}</version>
        </dependency>
        <dependency>
            <groupId>net.masterthought</groupId>
            <artifactId>cucumber-reporting</artifactId>
            <version>${cucumber-reporting.version}</version>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>${log4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>${log4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>
        
        <!-- JSON Processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>${gson.version}</version>
        </dependency>
        
        <!-- Apache Commons -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>${commons-io.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>${commons-lang3.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-text</artifactId>
            <version>${commons-text.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>${commons-csv.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-collections4</artifactId>
            <version>${commons-collections4.version}</version>
        </dependency>
        
        <!-- Excel Processing -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>${poi.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>${poi.version}</version>
        </dependency>
        
        <!-- REST API Testing -->
        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <version>${rest-assured.version}</version>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope>
        </dependency>
        
        <!-- Assertions -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>${assertj.version}</version>
        </dependency>
        
        <!-- Waiting Utilities -->
        <dependency>
            <groupId>org.awaitility</groupId>
            <artifactId>awaitility</artifactId>
            <version>${awaitility.version}</version>
        </dependency>
        
        <!-- Video Recording -->
        <dependency>
            <groupId>com.github.stephenc.monte</groupId>
            <artifactId>monte-screen-recorder</artifactId>
            <version>${monte-screen-recorder.version}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Compiler Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven-compiler-plugin.version}</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            
            <!-- Surefire Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>${maven-surefire-plugin.version}</version>
                <configuration>
                    <includes>
                        <include>**/*RunnerTest.java</include>
                    </includes>
                    <testFailureIgnore>true</testFailureIgnore>
                    <systemPropertyVariables>
                        <cucumber.filter.tags>${cucumber.filter.tags}</cucumber.filter.tags>
                        <environment>${environment}</environment>
                        <browser>${browser}</browser>
                        <headless>${headless}</headless>
                    </systemPropertyVariables>
                </configuration>
            </plugin>
            
            <!-- Resources Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <version>${maven-resources-plugin.version}</version>
                <configuration>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>
            
            <!-- Playwright Install -->
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>3.1.0</version>
                <executions>
                    <execution>
                        <id>playwright-install</id>
                        <phase>process-resources</phase>
                        <goals>
                            <goal>java</goal>
                        </goals>
                        <configuration>
                            <mainClass>com.microsoft.playwright.CLI</mainClass>
                            <arguments>
                                <argument>install</argument>
                            </arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            
            <!-- Cucumber Reporting Plugin -->
            <plugin>
                <groupId>net.masterthought</groupId>
                <artifactId>maven-cucumber-reporting</artifactId>
                <version>${cucumber-reporting.version}</version>
                <executions>
                    <execution>
                        <id>execution</id>
                        <phase>verify</phase>
                        <goals>
                            <goal>generate</goal>
                        </goals>
                        <configuration>
                            <projectName>${project.name}</projectName>
                            <outputDirectory>${project.build.directory}/cucumber-reports</outputDirectory>
                            <inputDirectory>${project.build.directory}/cucumber-reports</inputDirectory>
                            <jsonFiles>
                                <param>**/*.json</param>
                            </jsonFiles>
                            <checkBuildResult>false</checkBuildResult>
                            <classificationFiles>
                                <param>classifications.properties</param>
                            </classificationFiles>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            
            <!-- JaCoCo Plugin for Code Coverage -->
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>${jacoco-maven-plugin.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>report</id>
                        <phase>test</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <!-- Source Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>${maven-source-plugin.version}</version>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <!-- JavaDoc Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>${maven-javadoc-plugin.version}</version>
                <executions>
                    <execution>
                        <id>attach-javadocs</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
            <resource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
    
    <profiles>
        <!-- Environment Profiles -->
        <profile>
            <id>dev</id>
            <properties>
                <environment>dev</environment>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>qa</id>
            <properties>
                <environment>qa</environment>
            </properties>
        </profile>
        <profile>
            <id>stage</id>
            <properties>
                <environment>stage</environment>
            </properties>
        </profile>
        <profile>
            <id>prod</id>
            <properties>
                <environment>prod</environment>
            </properties>
        </profile>
        
        <!-- Browser Profiles -->
        <profile>
            <id>chromium</id>
            <properties>
                <browser>chromium</browser>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>firefox</id>
            <properties>
                <browser>firefox</browser>
            </properties>
        </profile>
        <profile>
            <id>webkit</id>
            <properties>
                <browser>webkit</browser>
            </properties>
        </profile>
        
        <!-- Execution Mode Profiles -->
        <profile>
            <id>headless</id>
            <properties>
                <headless>true</headless>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        <profile>
            <id>headed</id>
            <properties>
                <headless>false</headless>
            </properties>
        </profile>
        
        <!-- Test Scope Profiles -->
        <profile>
            <id>smoke</id>
            <properties>
                <cucumber.filter.tags>@smoke</cucumber.filter.tags>
            </properties>
        </profile>
        <profile>
            <id>regression</id>
            <properties>
                <cucumber.filter.tags>@regression</cucumber.filter.tags>
            </properties>
        </profile>
        <profile>
            <id>sanity</id>
            <properties>
                <cucumber.filter.tags>@sanity</cucumber.filter.tags>
            </properties>
        </profile>
        <profile>
            <id>all</id>
            <properties>
                <cucumber.filter.tags>not @ignore</cucumber.filter.tags>
            </properties>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
        
        <!-- Parallel Execution -->
        <profile>
            <id>parallel</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>${maven-surefire-plugin.version}</version>
                        <configuration>
                            <includes>
                                <include>**/*RunnerTest.java</include>
                            </includes>
                            <systemPropertyVariables>
                                <cucumber.execution.parallel.enabled>true</cucumber.execution.parallel.enabled>
                                <cucumber.execution.parallel.config.strategy>fixed</cucumber.execution.parallel.config.strategy>
                                <cucumber.execution.parallel.config.fixed.parallelism>4</cucumber.execution.parallel.config.fixed.parallelism>
                                <cucumber.plugin>pretty,html:${project.build.directory}/cucumber-reports/cucumber-html-report.html,json:${project.build.directory}/cucumber-reports/cucumber.json</cucumber.plugin>
                                <cucumber.filter.tags>${cucumber.filter.tags}</cucumber.filter.tags>
                                <environment>${environment}</environment>
                                <browser>${browser}</browser>
                                <headless>${headless}</headless>
                            </systemPropertyVariables>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        
        <!-- CI/CD Profile -->
        <profile>
            <id>ci</id>
            <properties>
                <headless>true</headless>
                <cucumber.filter.tags>not @ignore</cucumber.filter.tags>
            </properties>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <version>${maven-surefire-plugin.version}</version>
                        <configuration>
                            <includes>
                                <include>**/*RunnerTest.java</include>
                            </includes>
                            <systemPropertyVariables>
                                <cucumber.execution.parallel.enabled>true</cucumber.execution.parallel.enabled>
                                <cucumber.execution.parallel.config.strategy>fixed</cucumber.execution.parallel.config.strategy>
                                <cucumber.execution.parallel.config.fixed.parallelism>2</cucumber.execution.parallel.config.fixed.parallelism>
                                <cucumber.plugin>pretty,html:${project.build.directory}/cucumber-reports/cucumber-html-report.html,json:${project.build.directory}/cucumber-reports/cucumber.json</cucumber.plugin>
                                <cucumber.filter.tags>${cucumber.filter.tags}</cucumber.filter.tags>
                                <environment>${environment}</environment>
                                <browser>chromium</browser>
                                <headless>true</headless>
                                <video.recording>false</video.recording>
                            </systemPropertyVariables>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        
        <!-- Report Generation Only -->
        <profile>
            <id>report-only</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>net.masterthought</groupId>
                        <artifactId>maven-cucumber-reporting</artifactId>
                        <version>${cucumber-reporting.version}</version>
                        <executions>
                            <execution>
                                <id>execution</id>
                                <phase>verify</phase>
                                <goals>
                                    <goal>generate</goal>
                                </goals>
                                <configuration>
                                    <projectName>${project.name}</projectName>
                                    <outputDirectory>${project.build.directory}/cucumber-reports</outputDirectory>
                                    <inputDirectory>${project.build.directory}/cucumber-reports</inputDirectory>
                                    <jsonFiles>
                                        <param>**/*.json</param>
                                    </jsonFiles>
                                    <checkBuildResult>false</checkBuildResult>
                                    <classificationFiles>
                                        <param>classifications.properties</param>
                                    </classificationFiles>
                                </configuration>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
    
    <repositories>
        <repository>
            <id>central</id>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
        <repository>
            <id>github</id>
            <url>https://maven.pkg.github.com/${github.organization}/*</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
    </repositories>
</project>



templates/projects/playwright/java/bdd/src/test/java/stepdefs/BaseStepDef.java.template
--------------------------------------------------------------------------------------------

package ${package}.stepdefs;

import com.microsoft.playwright.*;
import com.microsoft.playwright.options.*;

import io.cucumber.java.After;
import io.cucumber.java.AfterStep;
import io.cucumber.java.Before;
import io.cucumber.java.BeforeStep;
import io.cucumber.java.Scenario;

import ${package}.core.config.ConfigurationManager;
import ${package}.core.reporting.CSReporter;
import ${package}.core.utils.CSConstants;
import ${package}.core.utils.CSLogger;
import ${package}.core.utils.CSScreenshotManager;
import ${package}.playwright.java.browser.BrowserManager;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Base Step Definition class that provides common functionality for all step definition classes.
 * This class handles Playwright initialization, cleanup, and test execution hooks for Cucumber scenarios.
 */
public class BaseStepDef {

    protected Playwright playwright;
    protected Browser browser;
    protected BrowserContext context;
    protected Page page;
    protected CSReporter reporter;
    protected CSScreenshotManager screenshotManager;
    protected Map<String, Object> testContext;
    private static boolean videoRecordingEnabled;
    private static boolean traceEnabled;
    private static boolean screenshotOnStepEnabled;
    private static boolean screenshotOnFailureEnabled;
    private static String currentScenarioName;
    private static int stepCounter;
    private long scenarioStartTime;
    
    /**
     * Constructor for BaseStepDef
     */
    public BaseStepDef() {
        testContext = new HashMap<>();
        screenshotManager = CSScreenshotManager.getInstance();
        reporter = CSReporter.getInstance();
        
        // Load configuration settings
        loadConfigSettings();
    }
    
    /**
     * Load configuration settings from the framework configuration
     */
    private void loadConfigSettings() {
        ConfigurationManager configManager = ConfigurationManager.getInstance();
        videoRecordingEnabled = configManager.getFrameworkConfig().isVideoRecordingEnabled();
        traceEnabled = configManager.getFrameworkConfig().isTraceEnabled();
        screenshotOnStepEnabled = configManager.getFrameworkConfig().isScreenshotOnStepEnabled();
        screenshotOnFailureEnabled = configManager.getFrameworkConfig().isScreenshotOnFailureEnabled();
    }
    
    /**
     * Before hook that runs before each scenario
     * 
     * @param scenario The current Cucumber scenario
     */
    @Before
    public void setUp(Scenario scenario) {
        currentScenarioName = scenario.getName().replaceAll("[^a-zA-Z0-9-_]", "_");
        stepCounter = 0;
        scenarioStartTime = System.currentTimeMillis();
        
        CSLogger.info("Starting scenario: " + scenario.getName());
        
        try {
            // Initialize Playwright
            initializePlaywright();
            
            // Start test in reporter
            reporter.startTest(scenario.getName(), scenario.getSourceTagNames().toString());
            
        } catch (Exception e) {
            CSLogger.error("Failed to initialize Playwright in setUp: " + e.getMessage(), e);
            throw new RuntimeException("Failed to initialize Playwright", e);
        }
    }
    
    /**
     * After hook that runs after each scenario
     * 
     * @param scenario The current Cucumber scenario
     */
    @After
    public void tearDown(Scenario scenario) {
        try {
            // Take screenshot on failure if enabled
            if (scenario.isFailed() && screenshotOnFailureEnabled) {
                takeScreenshot(scenario, "FAILURE");
            }
            
            // Calculate and log execution time
            long executionTime = System.currentTimeMillis() - scenarioStartTime;
            String formattedTime = formatExecutionTime(executionTime);
            CSLogger.info("Scenario: " + scenario.getName() + " completed in " + formattedTime);
            
            // Log scenario result
            if (scenario.isFailed()) {
                reporter.logFailure("Scenario Failed", scenario.getName() + " - " + getFailureMessage(scenario));
            } else {
                reporter.logSuccess("Scenario Passed", scenario.getName() + " - Executed in " + formattedTime);
            }
            
            // Complete test in reporter
            reporter.endTest(scenario.getStatus().toString(), executionTime);
            
        } catch (Exception e) {
            CSLogger.error("Error in tearDown: " + e.getMessage(), e);
        } finally {
            // Always clean up Playwright resources
            closePlaywright();
        }
    }
    
    /**
     * Before step hook that runs before each step
     * 
     * @param scenario The current Cucumber scenario
     */
    @BeforeStep
    public void beforeStep(Scenario scenario) {
        stepCounter++;
        CSLogger.debug("Executing step " + stepCounter + " of scenario: " + scenario.getName());
    }
    
    /**
     * After step hook that runs after each step
     * 
     * @param scenario The current Cucumber scenario
     */
    @AfterStep
    public void afterStep(Scenario scenario) {
        // Take screenshot after each step if enabled
        if (screenshotOnStepEnabled) {
            takeScreenshot(scenario, "STEP_" + stepCounter);
        }
    }
    
    /**
     * Initialize Playwright, browser, context, and page
     */
    protected void initializePlaywright() {
        CSLogger.info("Initializing Playwright...");
        
        // Create Playwright instance
        playwright = Playwright.create();
        
        // Get browser type based on configuration
        String browserType = System.getProperty("browser", ConfigurationManager.getInstance()
                            .getFrameworkConfig().getBrowser());
        boolean headless = Boolean.parseBoolean(System.getProperty("headless", String.valueOf(
                          ConfigurationManager.getInstance().getFrameworkConfig().isHeadless())));
        
        // Launch browser
        browser = launchBrowser(browserType, headless);
        
        // Create browser context with recording options if enabled
        BrowserContext.CreateOptions contextOptions = new BrowserContext.CreateOptions();
        
        if (videoRecordingEnabled) {
            Path videoDir = Paths.get("target/playwright-videos");
            contextOptions.setRecordVideoDir(videoDir);
            CSLogger.info("Video recording enabled to directory: " + videoDir);
        }
        
        if (traceEnabled) {
            contextOptions.setRecordVideoSize(1280, 720);
        }
        
        // Create context
        context = browser.newContext(contextOptions);
        
        // Start tracing if enabled
        if (traceEnabled) {
            context.tracing().start(new Tracing.StartOptions()
                    .setScreenshots(true)
                    .setSnapshots(true));
            CSLogger.info("Tracing enabled for context");
        }
        
        // Create page
        page = context.newPage();
        
        // Set default timeout
        page.setDefaultTimeout(ConfigurationManager.getInstance()
                              .getFrameworkConfig().getDefaultTimeoutInMillis());
        
        // Register page with BrowserManager for access in page objects
        BrowserManager.registerPage(page);
        
        CSLogger.info("Playwright initialized with browser: " + browserType + ", headless: " + headless);
    }
    
    /**
     * Launch the browser based on type and headless mode
     * 
     * @param browserType Type of browser (chromium, firefox, webkit)
     * @param headless Whether to run in headless mode
     * @return Browser instance
     */
    protected Browser launchBrowser(String browserType, boolean headless) {
        CSLogger.debug("Launching browser: " + browserType + ", headless: " + headless);
        
        BrowserType.LaunchOptions launchOptions = new BrowserType.LaunchOptions()
                .setHeadless(headless)
                .setSlowMo(50);
        
        // Set browser arguments based on browser type
        switch (browserType.toLowerCase()) {
            case "chromium":
                launchOptions.setArgs(getBrowserArgs(browserType));
                return playwright.chromium().launch(launchOptions);
            case "firefox":
                return playwright.firefox().launch(launchOptions);
            case "webkit":
                return playwright.webkit().launch(launchOptions);
            default:
                CSLogger.warn("Unknown browser type: " + browserType + ", defaulting to Chromium");
                return playwright.chromium().launch(launchOptions);
        }
    }
    
    /**
     * Get browser arguments based on browser type
     * 
     * @param browserType Type of browser
     * @return Array of browser arguments
     */
    protected String[] getBrowserArgs(String browserType) {
        if ("chromium".equalsIgnoreCase(browserType)) {
            return new String[] {
                "--disable-gpu",
                "--no-sandbox",
                "--disable-dev-shm-usage",
                "--disable-setuid-sandbox",
                "--disable-web-security",
                "--disable-features=IsolateOrigins,site-per-process"
            };
        }
        return new String[] {};
    }
    
    /**
     * Close Playwright resources
     */
    protected void closePlaywright() {
        CSLogger.debug("Closing Playwright resources...");
        
        try {
            if (context != null) {
                // Save trace if enabled
                if (traceEnabled) {
                    Path tracePath = Paths.get("target/playwright-traces", 
                                  currentScenarioName + ".zip");
                    context.tracing().stop(new Tracing.StopOptions()
                            .setPath(tracePath));
                    reporter.logTrace("Trace captured", tracePath.toString());
                    CSLogger.info("Trace saved to: " + tracePath);
                }
                
                // Close context
                context.close();
                context = null;
                page = null;
                CSLogger.debug("Browser context and page closed");
            }
            
            if (browser != null) {
                browser.close();
                browser = null;
                CSLogger.debug("Browser closed");
            }
            
            if (playwright != null) {
                playwright.close();
                playwright = null;
                CSLogger.debug("Playwright closed");
            }
            
            // Clear browser manager
            BrowserManager.clearPage();
            
        } catch (Exception e) {
            CSLogger.error("Error closing Playwright: " + e.getMessage(), e);
        }
    }
    
    /**
     * Take a screenshot and attach it to the scenario
     * 
     * @param scenario The current Cucumber scenario
     * @param label Label for the screenshot
     */
    protected void takeScreenshot(Scenario scenario, String label) {
        if (page != null) {
            try {
                String screenshotName = currentScenarioName + "_" + label;
                Path screenshotPath = Paths.get("target/screenshots", screenshotName + ".png");
                
                // Take screenshot
                byte[] screenshot = page.screenshot(new Page.ScreenshotOptions()
                        .setFullPage(true)
                        .setPath(screenshotPath));
                
                // Attach to Cucumber scenario
                scenario.attach(screenshot, "image/png", screenshotName);
                
                // Log to reporter
                reporter.logScreenshot("Screenshot: " + label, screenshotPath.toString());
                CSLogger.info("Screenshot captured: " + screenshotPath);
                
            } catch (Exception e) {
                CSLogger.error("Failed to capture screenshot: " + e.getMessage(), e);
            }
        }
    }
    
    /**
     * Format execution time in a human-readable format
     * 
     * @param milliseconds Time in milliseconds
     * @return Formatted time string
     */
    protected String formatExecutionTime(long milliseconds) {
        long seconds = TimeUnit.MILLISECONDS.toSeconds(milliseconds) % 60;
        long minutes = TimeUnit.MILLISECONDS.toMinutes(milliseconds) % 60;
        long hours = TimeUnit.MILLISECONDS.toHours(milliseconds);
        
        if (hours > 0) {
            return String.format("%dh %dm %ds", hours, minutes, seconds);
        } else if (minutes > 0) {
            return String.format("%dm %ds", minutes, seconds);
        } else {
            return String.format("%ds", seconds);
        }
    }
    
    /**
     * Get the failure message from the scenario
     * 
     * @param scenario The current Cucumber scenario
     * @return The failure message
     */
    protected String getFailureMessage(Scenario scenario) {
        // Get error message from scenario
        String errorMessage = "Unknown error";
        
        if (scenario.isFailed()) {
            if (scenario.getStatus().toString().equals("FAILED")) {
                // Attempt to get error details
                if (page != null) {
                    try {
                        // Capture page URL and title
                        String pageUrl = page.url();
                        String pageTitle = page.title();
                        errorMessage = "Failed on page: " + pageTitle + " (" + pageUrl + ")";
                        
                        // Capture any console errors
                        String consoleErrors = (String) testContext.get("lastConsoleError");
                        if (consoleErrors != null && !consoleErrors.isEmpty()) {
                            errorMessage += " - Console error: " + consoleErrors;
                        }
                    } catch (Exception e) {
                        // Ignore, we'll use the default message
                    }
                }
            }
        }
        
        return errorMessage;
    }
    
    /**
     * Store a value in the test context
     * 
     * @param key The key
     * @param value The value
     */
    public void storeInContext(String key, Object value) {
        testContext.put(key, value);
    }
    
    /**
     * Retrieve a value from the test context
     * 
     * @param key The key
     * @param <T> The type of the value
     * @return The value
     */
    @SuppressWarnings("unchecked")
    public <T> T getFromContext(String key) {
        return (T) testContext.get(key);
    }
    
    /**
     * Check if a key exists in the test context
     * 
     * @param key The key
     * @return True if the key exists, false otherwise
     */
    public boolean hasInContext(String key) {
        return testContext.containsKey(key);
    }
    
    /**
     * Remove a value from the test context
     * 
     * @param key The key
     */
    public void removeFromContext(String key) {
        testContext.remove(key);
    }
    
    /**
     * Clear the test context
     */
    public void clearContext() {
        testContext.clear();
    }
    
    /**
     * Navigate to a URL
     * 
     * @param url URL to navigate to
     */
    protected void navigateTo(String url) {
        CSLogger.info("Navigating to URL: " + url);
        page.navigate(url);
        reporter.logInfo("Navigation", "Navigated to URL: " + url);
    }
    
    /**
     * Get the current page
     * 
     * @return The current page
     */
    public Page getPage() {
        return page;
    }
    
    /**
     * Get the browser context
     * 
     * @return The browser context
     */
    public BrowserContext getBrowserContext() {
        return context;
    }
    
    /**
     * Get the browser
     * 
     * @return The browser
     */
    public Browser getBrowser() {
        return browser;
    }
    
    /**
     * Get the Playwright instance
     * 
     * @return The Playwright instance
     */
    public Playwright getPlaywright() {
        return playwright;
    }
}





