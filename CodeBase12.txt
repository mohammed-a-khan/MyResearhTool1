
recorder/common/event-capture.js
-----------------------------------------------

/**
 * event-capture.js
 * Part of CSTestForge Browser Integration Module
 * 
 * This script is responsible for capturing user interactions in the browser
 * during the recording process. It tracks various events including clicks,
 * inputs, selections, keyboard events, navigation, and DOM mutations.
 * 
 * The captured events are processed and sent to the main application for
 * further processing and test code generation.
 */

(function() {
    'use strict';

    // Configuration
    const CONFIG = {
        captureClicks: true,
        captureInputs: true,
        captureSelections: true,
        captureKeyboard: true,
        captureNavigation: true,
        captureMutations: true,
        captureHovers: false,
        ignoreClassPatterns: [/^cs-ignore/, /^no-record/],
        ignoreIdPatterns: [/^cs-ignore/, /^no-record/],
        eventThrottleMs: 50,
        attributesToTrack: ['id', 'name', 'class', 'type', 'value', 'href', 'src', 'alt', 'title', 'placeholder', 'role', 'aria-label'],
        maxPathLength: 10,
        postMessageTarget: window.parent,
        postMessageOrigin: '*', // Should be restricted in production
        eventBufferSize: 20,
        dataAttributesToTrack: ['data-testid', 'data-test', 'data-automation', 'data-cy', 'data-qa'],
        sensitiveInputTypes: ['password', 'email', 'tel', 'ssn', 'cc-number'],
        sensitiveInputNamePatterns: [/password/i, /email/i, /ssn/i, /creditcard/i, /secret/i],
        maskSensitiveData: true,
        captureContext: true,
        contextRadius: 2, // Number of siblings to capture for context
        captureNetwork: false,
        networkCaptureDebounceMs: 300
    };

    // Communication channel
    const CSChannel = {
        eventBuffer: [],
        lastFlushTime: 0,
        flushIntervalId: null,
        
        /**
         * Initialize the communication channel
         */
        init: function() {
            this.flushIntervalId = setInterval(() => this.flushEvents(), 500);
            window.addEventListener('unload', () => {
                this.flushEvents(true);
                clearInterval(this.flushIntervalId);
            });
        },
        
        /**
         * Send event to the recorder application
         * @param {Object} event - The event to send
         */
        sendEvent: function(event) {
            event.timestamp = Date.now();
            event.url = window.location.href;
            event.title = document.title;
            
            this.eventBuffer.push(event);
            
            if (this.eventBuffer.length >= CONFIG.eventBufferSize || 
                (Date.now() - this.lastFlushTime > 1000)) {
                this.flushEvents();
            }
        },
        
        /**
         * Flush all events in the buffer
         * @param {boolean} force - Force flush even if throttling conditions aren't met
         */
        flushEvents: function(force = false) {
            if (this.eventBuffer.length === 0) return;
            
            if (force || this.eventBuffer.length >= CONFIG.eventBufferSize || 
                (Date.now() - this.lastFlushTime > 1000)) {
                
                try {
                    const events = [...this.eventBuffer];
                    this.eventBuffer = [];
                    this.lastFlushTime = Date.now();
                    
                    CONFIG.postMessageTarget.postMessage({
                        type: 'CSTestForge_Events',
                        events: events,
                        frameId: CSEventCapture.getFrameId(),
                        frameUrl: window.location.href
                    }, CONFIG.postMessageOrigin);
                } catch (e) {
                    console.error('CSTestForge: Error sending events', e);
                    // Restore events to buffer if sending failed
                    this.eventBuffer = [...this.eventBuffer, ...events];
                }
            }
        }
    };
    
    // Utilities
    const CSUtils = {
        /**
         * Get a unique selector for an element
         * @param {Element} element - The element to generate a selector for
         * @returns {string} A CSS selector that uniquely identifies the element
         */
        getUniqueSelector: function(element) {
            if (!element) return "";
            if (element === document.body) return "body";
            if (element === document.documentElement) return "html";
            
            // Try ID selector if the element has an ID
            if (element.id && !CSUtils.shouldIgnoreElement(element)) {
                return `#${CSS.escape(element.id)}`;
            }
            
            // Try data attribute selectors for testing attributes
            for (const attr of CONFIG.dataAttributesToTrack) {
                if (element.hasAttribute(attr)) {
                    return `[${attr}="${CSS.escape(element.getAttribute(attr))}"]`;
                }
            }
            
            // Try name attribute for form elements
            if (element.name && ['INPUT', 'SELECT', 'TEXTAREA', 'BUTTON', 'FORM'].includes(element.tagName)) {
                const nameSelector = `${element.tagName.toLowerCase()}[name="${CSS.escape(element.name)}"]`;
                if (document.querySelectorAll(nameSelector).length === 1) {
                    return nameSelector;
                }
            }
            
            // Try to build a selector path
            let current = element;
            let path = [];
            let pathLength = 0;
            
            while (current && current !== document.body && current !== document.documentElement && pathLength < CONFIG.maxPathLength) {
                let selector;
                
                // Try to use class names that appear unique enough
                const classes = Array.from(current.classList).filter(cls => {
                    return !CONFIG.ignoreClassPatterns.some(pattern => pattern.test(cls));
                });
                
                if (classes.length > 0) {
                    const classSelector = classes.map(c => `.${CSS.escape(c)}`).join('');
                    const matches = document.querySelectorAll(classSelector);
                    if (matches.length === 1) {
                        selector = classSelector;
                    } else if (matches.length > 1 && matches.length < 10) {
                        // Try to narrow down with tag name
                        const tagClassSelector = `${current.tagName.toLowerCase()}${classSelector}`;
                        if (document.querySelectorAll(tagClassSelector).length === 1) {
                            selector = tagClassSelector;
                        }
                    }
                }
                
                // If no unique class selector was found, use nth-child
                if (!selector) {
                    const parent = current.parentElement;
                    if (parent) {
                        const children = Array.from(parent.children);
                        const index = children.indexOf(current) + 1;
                        const tagName = current.tagName.toLowerCase();
                        selector = `${tagName}:nth-child(${index})`;
                    } else {
                        selector = current.tagName.toLowerCase();
                    }
                }
                
                path.unshift(selector);
                current = current.parentElement;
                pathLength++;
            }
            
            return path.join(' > ');
        },
        
        /**
         * Check if an element should be ignored for recording
         * @param {Element} element - The element to check
         * @returns {boolean} True if the element should be ignored
         */
        shouldIgnoreElement: function(element) {
            if (!element) return true;
            
            // Check for ignore class patterns
            if (element.className && typeof element.className === 'string') {
                if (CONFIG.ignoreClassPatterns.some(pattern => pattern.test(element.className))) {
                    return true;
                }
            }
            
            // Check for ignore id patterns
            if (element.id && CONFIG.ignoreIdPatterns.some(pattern => pattern.test(element.id))) {
                return true;
            }
            
            // Check for elements that are not visible or not interactive
            if (element.disabled || 
                (element.getAttribute('aria-disabled') === 'true') ||
                element.hasAttribute('cs-ignore') ||
                element.hasAttribute('data-cs-ignore')) {
                return true;
            }
            
            // Check element visibility
            const style = window.getComputedStyle(element);
            if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
                return true;
            }
            
            return false;
        },
        
        /**
         * Check if an input contains sensitive information
         * @param {Element} element - The input element to check
         * @returns {boolean} True if the input contains sensitive information
         */
        isSensitiveInput: function(element) {
            if (!element || !element.tagName) return false;
            
            // Check only input elements
            if (element.tagName !== 'INPUT') return false;
            
            // Check input type
            const type = element.type ? element.type.toLowerCase() : '';
            if (CONFIG.sensitiveInputTypes.includes(type)) {
                return true;
            }
            
            // Check input name, id, and placeholder for sensitive patterns
            const attrs = [
                element.name || '',
                element.id || '',
                element.placeholder || ''
            ];
            
            for (const attr of attrs) {
                if (CONFIG.sensitiveInputNamePatterns.some(pattern => pattern.test(attr))) {
                    return true;
                }
            }
            
            return false;
        },
        
        /**
         * Mask sensitive data if needed
         * @param {string} value - The value to potentially mask
         * @param {Element} element - The element containing the value
         * @returns {string} The original value or a masked version
         */
        maskSensitiveData: function(value, element) {
            if (!CONFIG.maskSensitiveData || !value || !element) return value;
            
            if (this.isSensitiveInput(element)) {
                return value.replace(/./g, '•');
            }
            
            return value;
        },
        
        /**
         * Get attributes of an element that we want to track
         * @param {Element} element - The element to get attributes from
         * @returns {Object} Object containing the element's attributes
         */
        getElementAttributes: function(element) {
            if (!element) return {};
            
            const attributes = {};
            
            for (const attr of CONFIG.attributesToTrack) {
                if (element.hasAttribute(attr)) {
                    let value = element.getAttribute(attr);
                    
                    // Mask sensitive data if needed
                    if (attr === 'value') {
                        value = this.maskSensitiveData(value, element);
                    }
                    
                    attributes[attr] = value;
                }
            }
            
            // Capture data attributes specifically
            for (const dataAttr of CONFIG.dataAttributesToTrack) {
                if (element.hasAttribute(dataAttr)) {
                    attributes[dataAttr] = element.getAttribute(dataAttr);
                }
            }
            
            return attributes;
        },
        
        /**
         * Get computed style properties we care about for an element
         * @param {Element} element - The element to get styles for
         * @returns {Object} Object containing relevant style properties
         */
        getElementStyles: function(element) {
            if (!element) return {};
            
            const computedStyle = window.getComputedStyle(element);
            
            return {
                display: computedStyle.display,
                visibility: computedStyle.visibility,
                position: computedStyle.position,
                width: computedStyle.width,
                height: computedStyle.height,
                zIndex: computedStyle.zIndex,
                overflow: computedStyle.overflow
            };
        },
        
        /**
         * Get element context (surrounding elements) for better element identification
         * @param {Element} element - The element to get context for
         * @returns {Object} Context information about surrounding elements
         */
        getElementContext: function(element) {
            if (!element || !CONFIG.captureContext) return null;
            
            const context = {
                parent: null,
                siblings: [],
                children: []
            };
            
            // Get parent info
            if (element.parentElement && element.parentElement !== document.body) {
                context.parent = {
                    tagName: element.parentElement.tagName,
                    attributes: this.getElementAttributes(element.parentElement),
                    text: element.parentElement.textContent.substring(0, 50).trim()
                };
            }
            
            // Get siblings
            if (element.parentElement) {
                const siblings = Array.from(element.parentElement.children);
                const elementIndex = siblings.indexOf(element);
                
                // Get a few siblings before and after for context
                const startIdx = Math.max(0, elementIndex - CONFIG.contextRadius);
                const endIdx = Math.min(siblings.length - 1, elementIndex + CONFIG.contextRadius);
                
                for (let i = startIdx; i <= endIdx; i++) {
                    if (i !== elementIndex) {
                        const sibling = siblings[i];
                        context.siblings.push({
                            tagName: sibling.tagName,
                            attributes: this.getElementAttributes(sibling),
                            text: sibling.textContent.substring(0, 30).trim(),
                            position: i < elementIndex ? 'before' : 'after'
                        });
                    }
                }
            }
            
            // Get direct children
            const children = Array.from(element.children).slice(0, 3); // Limit to first 3 children
            for (const child of children) {
                context.children.push({
                    tagName: child.tagName,
                    attributes: this.getElementAttributes(child),
                    text: child.textContent.substring(0, 30).trim()
                });
            }
            
            return context;
        },
        
        /**
         * Get the text content of an element, properly trimmed
         * @param {Element} element - The element to get text from
         * @returns {string} The element's text content
         */
        getElementText: function(element) {
            if (!element) return '';
            
            // Handle input elements
            if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                return this.maskSensitiveData(element.value, element);
            }
            
            // For other elements, get text content
            let text = element.textContent || '';
            
            // Trim and limit length
            text = text.trim().replace(/\s+/g, ' ').substring(0, 100);
            
            return text;
        },
        
        /**
         * Generate XPath for an element
         * @param {Element} element - The element to generate XPath for
         * @returns {string} XPath expression
         */
        getXPath: function(element) {
            if (!element) return '';
            
            // Special cases
            if (element === document.body) return '/html/body';
            if (element === document.documentElement) return '/html';
            
            // Try to get a simple XPath with id first
            if (element.id) {
                return `//*[@id="${element.id}"]`;
            }
            
            // Generate full path
            let path = '';
            let current = element;
            
            while (current && current.nodeType === Node.ELEMENT_NODE) {
                let currentPath = current.tagName.toLowerCase();
                
                // Add predicates for better identification
                if (current.id) {
                    currentPath += `[@id="${current.id}"]`;
                } else {
                    // Get position among siblings of same type
                    let siblingsOfSameType = 0;
                    let position = 0;
                    
                    for (let i = 0; i < current.parentNode.childNodes.length; i++) {
                        const sibling = current.parentNode.childNodes[i];
                        if (sibling.nodeType === Node.ELEMENT_NODE && 
                            sibling.tagName === current.tagName) {
                            siblingsOfSameType++;
                            if (sibling === current) {
                                position = siblingsOfSameType;
                            }
                        }
                    }
                    
                    if (siblingsOfSameType > 1) {
                        currentPath += `[${position}]`;
                    }
                }
                
                path = currentPath + (path ? '/' + path : '');
                current = current.parentNode;
                
                if (current === document.body) {
                    path = '/html/body/' + path;
                    break;
                }
            }
            
            return '/' + path;
        },
        
        /**
         * Throttle function to limit how often a function can be called
         * @param {Function} func - The function to throttle
         * @param {number} limit - The time limit in milliseconds
         * @returns {Function} Throttled function
         */
        throttle: function(func, limit) {
            let lastFunc;
            let lastRan;
            
            return function() {
                const context = this;
                const args = arguments;
                
                if (!lastRan) {
                    func.apply(context, args);
                    lastRan = Date.now();
                } else {
                    clearTimeout(lastFunc);
                    lastFunc = setTimeout(function() {
                        if ((Date.now() - lastRan) >= limit) {
                            func.apply(context, args);
                            lastRan = Date.now();
                        }
                    }, limit - (Date.now() - lastRan));
                }
            };
        },
        
        /**
         * Debounce function to delay execution until after a quiet period
         * @param {Function} func - The function to debounce
         * @param {number} wait - The wait time in milliseconds
         * @returns {Function} Debounced function
         */
        debounce: function(func, wait) {
            let timeout;
            
            return function() {
                const context = this;
                const args = arguments;
                
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }
    };
    
    // Main Event Capture Logic
    const CSEventCapture = {
        observers: {},
        lastEvent: null,
        lastEventTime: 0,
        frameId: null,
        
        /**
         * Initialize event capture
         */
        init: function() {
            this.frameId = this.generateFrameId();
            this.setupListeners();
            this.setupMutationObserver();
            this.setupResizeObserver();
            
            if (CONFIG.captureNetwork) {
                this.setupNetworkObserver();
            }
            
            // Listen for messages from the parent application
            window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'CSTestForge_Command') {
                    this.handleCommand(event.data.command, event.data.params);
                }
            });
            
            // Inject event capture into iframes when they load
            this.setupIframeListeners();
            
            // Initialize communication channel
            CSChannel.init();
            
            // Report initialization
            CSChannel.sendEvent({
                type: 'initialization',
                frameId: this.frameId,
                url: window.location.href,
                title: document.title,
                userAgent: navigator.userAgent,
                viewportWidth: window.innerWidth,
                viewportHeight: window.innerHeight,
                devicePixelRatio: window.devicePixelRatio
            });
        },
        
        /**
         * Generate a unique ID for this frame
         * @returns {string} A unique ID
         */
        generateFrameId: function() {
            return 'csframe_' + Math.random().toString(36).substring(2, 15);
        },
        
        /**
         * Get the frame ID
         * @returns {string} The frame ID
         */
        getFrameId: function() {
            return this.frameId;
        },
        
        /**
         * Set up all event listeners
         */
        setupListeners: function() {
            if (CONFIG.captureClicks) {
                // Click events
                document.addEventListener('click', this.handleClickEvent.bind(this), true);
                document.addEventListener('dblclick', this.handleClickEvent.bind(this), true);
                document.addEventListener('contextmenu', this.handleClickEvent.bind(this), true);
            }
            
            if (CONFIG.captureInputs) {
                // Input events
                document.addEventListener('input', CSUtils.throttle(this.handleInputEvent.bind(this), CONFIG.eventThrottleMs), true);
                document.addEventListener('change', this.handleChangeEvent.bind(this), true);
                document.addEventListener('focus', this.handleFocusEvent.bind(this), true);
                document.addEventListener('blur', this.handleBlurEvent.bind(this), true);
                document.addEventListener('submit', this.handleFormEvent.bind(this), true);
            }
            
            if (CONFIG.captureKeyboard) {
                // Keyboard events (only keydown for performance reasons)
                document.addEventListener('keydown', CSUtils.throttle(this.handleKeyboardEvent.bind(this), CONFIG.eventThrottleMs), true);
            }
            
            if (CONFIG.captureNavigation) {
                // Navigation events
                window.addEventListener('popstate', this.handleNavigationEvent.bind(this));
                window.addEventListener('hashchange', this.handleNavigationEvent.bind(this));
                
                // Intercept history methods
                this.interceptHistoryMethods();
            }
            
            if (CONFIG.captureHovers) {
                // Mouse movement (throttled heavily)
                document.addEventListener('mouseover', CSUtils.throttle(this.handleHoverEvent.bind(this), 300), true);
            }
            
            // Window events
            window.addEventListener('load', this.handleWindowEvent.bind(this));
            window.addEventListener('beforeunload', this.handleWindowEvent.bind(this));
            window.addEventListener('scroll', CSUtils.throttle(this.handleScrollEvent.bind(this), 300), true);
        },
        
        /**
         * Set up mutation observer to track DOM changes
         */
        setupMutationObserver: function() {
            if (!CONFIG.captureMutations) return;
            
            this.observers.mutation = new MutationObserver(CSUtils.throttle((mutations) => {
                // Group mutations by target for efficiency
                const mutationsByTarget = {};
                
                for (const mutation of mutations) {
                    const target = mutation.target;
                    const targetId = target.id || CSUtils.getUniqueSelector(target);
                    
                    if (!mutationsByTarget[targetId]) {
                        mutationsByTarget[targetId] = {
                            target: target,
                            addedNodes: [],
                            removedNodes: [],
                            attributes: {},
                            characterData: false
                        };
                    }
                    
                    // Track added nodes
                    if (mutation.type === 'childList') {
                        if (mutation.addedNodes.length) {
                            for (let i = 0; i < mutation.addedNodes.length; i++) {
                                const node = mutation.addedNodes[i];
                                if (node.nodeType === Node.ELEMENT_NODE && !CSUtils.shouldIgnoreElement(node)) {
                                    mutationsByTarget[targetId].addedNodes.push({
                                        tagName: node.tagName,
                                        attributes: CSUtils.getElementAttributes(node),
                                        text: CSUtils.getElementText(node)
                                    });
                                }
                            }
                        }
                        
                        if (mutation.removedNodes.length) {
                            for (let i = 0; i < mutation.removedNodes.length; i++) {
                                const node = mutation.removedNodes[i];
                                if (node.nodeType === Node.ELEMENT_NODE) {
                                    mutationsByTarget[targetId].removedNodes.push({
                                        tagName: node.tagName,
                                        text: node.textContent ? node.textContent.substring(0, 50).trim() : ''
                                    });
                                }
                            }
                        }
                    }
                    
                    // Track attribute changes
                    if (mutation.type === 'attributes') {
                        const attrName = mutation.attributeName;
                        const currentValue = target.getAttribute(attrName);
                        
                        mutationsByTarget[targetId].attributes[attrName] = {
                            oldValue: mutation.oldValue,
                            newValue: currentValue
                        };
                    }
                    
                    // Track text changes
                    if (mutation.type === 'characterData') {
                        mutationsByTarget[targetId].characterData = true;
                    }
                }
                
                // Process grouped mutations
                for (const targetId in mutationsByTarget) {
                    const mutation = mutationsByTarget[targetId];
                    
                    // Skip if there's nothing significant to report
                    if (mutation.addedNodes.length === 0 && 
                        mutation.removedNodes.length === 0 && 
                        Object.keys(mutation.attributes).length === 0 && 
                        !mutation.characterData) {
                        continue;
                    }
                    
                    CSChannel.sendEvent({
                        type: 'mutation',
                        targetSelector: CSUtils.getUniqueSelector(mutation.target),
                        targetXPath: CSUtils.getXPath(mutation.target),
                        addedNodes: mutation.addedNodes,
                        removedNodes: mutation.removedNodes,
                        attributes: mutation.attributes,
                        characterData: mutation.characterData,
                        targetText: CSUtils.getElementText(mutation.target)
                    });
                }
            }, 500));
            
            this.observers.mutation.observe(document, {
                childList: true,
                attributes: true,
                characterData: true,
                subtree: true,
                attributeOldValue: true,
                characterDataOldValue: true
            });
        },
        
        /**
         * Set up resize observer to track element size changes
         */
        setupResizeObserver: function() {
            if (typeof ResizeObserver === 'undefined') return;
            
            this.observers.resize = new ResizeObserver(CSUtils.throttle((entries) => {
                for (const entry of entries) {
                    const element = entry.target;
                    
                    if (CSUtils.shouldIgnoreElement(element)) continue;
                    
                    CSChannel.sendEvent({
                        type: 'resize',
                        targetSelector: CSUtils.getUniqueSelector(element),
                        targetXPath: CSUtils.getXPath(element),
                        width: entry.contentRect.width,
                        height: entry.contentRect.height
                    });
                }
            }, 500));
            
            // Observe key elements like forms, tables, and containers
            const elementsToObserve = document.querySelectorAll('form, table, div.container, main, section');
            elementsToObserve.forEach(element => {
                if (!CSUtils.shouldIgnoreElement(element)) {
                    this.observers.resize.observe(element);
                }
            });
        },
        
        /**
         * Set up network observer to track AJAX requests
         */
        setupNetworkObserver: function() {
            // Intercept XMLHttpRequest
            const originalXhrOpen = XMLHttpRequest.prototype.open;
            const originalXhrSend = XMLHttpRequest.prototype.send;
            
            XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
                this._csMethod = method;
                this._csUrl = url;
                this._csStartTime = Date.now();
                return originalXhrOpen.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function(body) {
                const xhr = this;
                
                // Capture request body if it's not too large
                let requestBody = null;
                if (body && typeof body === 'string' && body.length < 5000) {
                    try {
                        requestBody = JSON.parse(body);
                    } catch (e) {
                        requestBody = body.substring(0, 200); // Just take a sample if not JSON
                    }
                }
                
                // Record request
                CSChannel.sendEvent({
                    type: 'network',
                    subtype: 'request',
                    method: xhr._csMethod,
                    url: xhr._csUrl,
                    body: requestBody,
                    time: Date.now()
                });
                
                // Track response
                xhr.addEventListener('load', function() {
                    let responseData = null;
                    
                    // Try to parse response if it's not too large
                    if (xhr.responseText && xhr.responseText.length < 10000) {
                        try {
                            // Try to parse as JSON first
                            responseData = JSON.parse(xhr.responseText);
                        } catch (e) {
                            // If not JSON, just take first part of response
                            responseData = xhr.responseText.substring(0, 200);
                        }
                    }
                    
                    CSChannel.sendEvent({
                        type: 'network',
                        subtype: 'response',
                        method: xhr._csMethod,
                        url: xhr._csUrl,
                        status: xhr.status,
                        response: responseData,
                        time: Date.now(),
                        duration: Date.now() - xhr._csStartTime
                    });
                });
                
                xhr.addEventListener('error', function() {
                    CSChannel.sendEvent({
                        type: 'network',
                        subtype: 'error',
                        method: xhr._csMethod,
                        url: xhr._csUrl,
                        time: Date.now(),
                        duration: Date.now() - xhr._csStartTime
                    });
                });
                
                return originalXhrSend.apply(this, arguments);
            };
            
            // Intercept fetch API
            const originalFetch = window.fetch;
            
            window.fetch = function(input, init) {
                const startTime = Date.now();
                const method = init && init.method ? init.method : 'GET';
                const url = typeof input === 'string' ? input : input.url;
                
                // Capture request body if available
                let requestBody = null;
                if (init && init.body) {
                    if (typeof init.body === 'string' && init.body.length < 5000) {
                        try {
                            requestBody = JSON.parse(init.body);
                        } catch (e) {
                            requestBody = init.body.substring(0, 200);
                        }
                    } else if (init.body instanceof FormData) {
                        requestBody = 'FormData (cannot capture content)';
                    }
                }
                
                // Record request
                CSChannel.sendEvent({
                    type: 'network',
                    subtype: 'request',
                    method: method,
                    url: url,
                    body: requestBody,
                    time: Date.now()
                });
                
                // Call the original fetch and track response
                return originalFetch.apply(this, arguments)
                    .then(response => {
                        // Clone the response so we can read it
                        const responseClone = response.clone();
                        
                        // Process response in the background
                        responseClone.text().then(text => {
                            let responseData = null;
                            
                            if (text && text.length < 10000) {
                                try {
                                    responseData = JSON.parse(text);
                                } catch (e) {
                                    responseData = text.substring(0, 200);
                                }
                            }
                            
                            CSChannel.sendEvent({
                                type: 'network',
                                subtype: 'response',
                                method: method,
                                url: url,
                                status: responseClone.status,
                                response: responseData,
                                time: Date.now(),
                                duration: Date.now() - startTime
                            });
                        }).catch(() => {
                            // If we can't read the response, just record the status
                            CSChannel.sendEvent({
                                type: 'network',
                                subtype: 'response',
                                method: method,
                                url: url,
                                status: responseClone.status,
                                time: Date.now(),
                                duration: Date.now() - startTime
                            });
                        });
                        
                        return response;
                    })
                    .catch(error => {
                        CSChannel.sendEvent({
                            type: 'network',
                            subtype: 'error',
                            method: method,
                            url: url,
                            time: Date.now(),
                            duration: Date.now() - startTime,
                            error: error.toString()
                        });
                        
                        throw error;
                    });
            };
        },
        
        /**
         * Intercept history methods to track navigation
         */
        interceptHistoryMethods: function() {
            const originalPushState = history.pushState;
            const originalReplaceState = history.replaceState;
            
            history.pushState = function() {
                const result = originalPushState.apply(this, arguments);
                
                CSChannel.sendEvent({
                    type: 'navigation',
                    subtype: 'pushState',
                    url: window.location.href,
                    state: arguments[0] ? JSON.stringify(arguments[0]).substring(0, 100) : null,
                    title: arguments[1] || document.title
                });
                
                return result;
            };
            
            history.replaceState = function() {
                const result = originalReplaceState.apply(this, arguments);
                
                CSChannel.sendEvent({
                    type: 'navigation',
                    subtype: 'replaceState',
                    url: window.location.href,
                    state: arguments[0] ? JSON.stringify(arguments[0]).substring(0, 100) : null,
                    title: arguments[1] || document.title
                });
                
                return result;
            };
        },
        
        /**
         * Set up iframe event listeners
         */
        setupIframeListeners: function() {
            // Create a MutationObserver to watch for newly added iframes
            const iframeObserver = new MutationObserver(mutations => {
                for (const mutation of mutations) {
                    if (mutation.type === 'childList') {
                        for (const node of mutation.addedNodes) {
                            if (node.nodeName === 'IFRAME') {
                                this.attachToIframe(node);
                            } else if (node.nodeType === Node.ELEMENT_NODE) {
                                // Check for iframes within added nodes
                                const iframes = node.querySelectorAll('iframe');
                                for (const iframe of iframes) {
                                    this.attachToIframe(iframe);
                                }
                            }
                        }
                    }
                }
            });
            
            // Observe the entire document for iframe additions
            iframeObserver.observe(document, {
                childList: true,
                subtree: true
            });
            
            // Attach to existing iframes
            const existingIframes = document.querySelectorAll('iframe');
            for (const iframe of existingIframes) {
                this.attachToIframe(iframe);
            }
        },
        
        /**
         * Attach event capture to an iframe
         * @param {HTMLIFrameElement} iframe - The iframe to attach to
         */
        attachToIframe: function(iframe) {
            // Skip iframes that should be ignored
            if (CSUtils.shouldIgnoreElement(iframe)) {
                return;
            }
            
            try {
                // Wait for iframe to load
                const handleLoad = () => {
                    try {
                        // Skip if iframe has no contentWindow or is from a different origin
                        if (!iframe.contentWindow || !iframe.contentWindow.document) {
                            return;
                        }
                        
                        // Check if we can access the iframe's content
                        iframe.contentWindow.document.body;
                        
                        // Send a message to the parent app about this iframe
                        CSChannel.sendEvent({
                            type: 'iframe',
                            src: iframe.src,
                            selector: CSUtils.getUniqueSelector(iframe),
                            xpath: CSUtils.getXPath(iframe)
                        });
                        
                        // Inject the recorder script into the iframe
                        CONFIG.postMessageTarget.postMessage({
                            type: 'CSTestForge_InjectIframe',
                            frameSelector: CSUtils.getUniqueSelector(iframe),
                            frameXPath: CSUtils.getXPath(iframe),
                            url: iframe.src || iframe.contentWindow.location.href
                        }, CONFIG.postMessageOrigin);
                    } catch (e) {
                        // Cross-origin iframe - can't access content
                        CSChannel.sendEvent({
                            type: 'iframe',
                            src: iframe.src,
                            selector: CSUtils.getUniqueSelector(iframe),
                            xpath: CSUtils.getXPath(iframe),
                            crossOrigin: true
                        });
                    }
                };
                
                if (iframe.contentDocument && iframe.contentDocument.readyState === 'complete') {
                    handleLoad();
                } else {
                    iframe.addEventListener('load', handleLoad);
                }
            } catch (e) {
                // Error accessing iframe - likely cross-origin
                console.error('CSTestForge: Error attaching to iframe', e);
            }
        },
        
        /**
         * Handle click events
         * @param {Event} event - The click event
         */
        handleClickEvent: function(event) {
            if (!event.target || CSUtils.shouldIgnoreElement(event.target)) {
                return;
            }
            
            // Determine the actual interactive element receiving the click
            // It might be a child of a button or link
            let targetElement = event.target;
            
            // If we clicked on a non-interactive element within an interactive one,
            // use the interactive parent
            let interactiveParent = targetElement.closest('a, button, [role="button"], [type="button"], [type="submit"], [type="reset"], input[type="checkbox"], input[type="radio"]');
            if (interactiveParent) {
                targetElement = interactiveParent;
            }
            
            CSChannel.sendEvent({
                type: 'click',
                subtype: event.type, // 'click', 'dblclick', or 'contextmenu'
                targetSelector: CSUtils.getUniqueSelector(targetElement),
                targetXPath: CSUtils.getXPath(targetElement),
                targetTagName: targetElement.tagName,
                targetText: CSUtils.getElementText(targetElement),
                targetAttributes: CSUtils.getElementAttributes(targetElement),
                targetContext: CSUtils.getElementContext(targetElement),
                clientX: event.clientX,
                clientY: event.clientY,
                altKey: event.altKey,
                ctrlKey: event.ctrlKey,
                shiftKey: event.shiftKey,
                metaKey: event.metaKey,
                button: event.button
            });
        },
        
        /**
         * Handle input events
         * @param {Event} event - The input event
         */
        handleInputEvent: function(event) {
            if (!event.target || CSUtils.shouldIgnoreElement(event.target)) {
                return;
            }
            
            const targetElement = event.target;
            let value = '';
            
            // Handle different types of input elements
            if (targetElement.tagName === 'INPUT') {
                if (targetElement.type === 'checkbox' || targetElement.type === 'radio') {
                    value = targetElement.checked;
                } else {
                    value = CSUtils.maskSensitiveData(targetElement.value, targetElement);
                }
            } else if (targetElement.tagName === 'TEXTAREA') {
                value = CSUtils.maskSensitiveData(targetElement.value, targetElement);
            } else if (targetElement.tagName === 'SELECT') {
                value = targetElement.value;
                
                // Get selected option text for better readability
                const selectedOption = targetElement.options[targetElement.selectedIndex];
                if (selectedOption) {
                    value = {
                        value: value,
                        text: selectedOption.text
                    };
                }
            } else if (targetElement.isContentEditable) {
                value = targetElement.innerHTML;
            }
            
            CSChannel.sendEvent({
                type: 'input',
                subtype: event.type, // 'input'
                targetSelector: CSUtils.getUniqueSelector(targetElement),
                targetXPath: CSUtils.getXPath(targetElement),
                targetTagName: targetElement.tagName,
                targetType: targetElement.type,
                targetName: targetElement.name,
                targetId: targetElement.id,
                targetAttributes: CSUtils.getElementAttributes(targetElement),
                value: value,
                isSensitive: CSUtils.isSensitiveInput(targetElement)
            });
        },
        
        /**
         * Handle change events
         * @param {Event} event - The change event
         */
        handleChangeEvent: function(event) {
            if (!event.target || CSUtils.shouldIgnoreElement(event.target)) {
                return;
            }
            
            const targetElement = event.target;
            let value = '';
            
            // Handle different types of input elements
            if (targetElement.tagName === 'INPUT') {
                if (targetElement.type === 'checkbox' || targetElement.type === 'radio') {
                    value = targetElement.checked;
                } else if (targetElement.type === 'file') {
                    // For file inputs, capture file names but not the actual files
                    value = Array.from(targetElement.files).map(file => file.name).join(', ');
                } else {
                    value = CSUtils.maskSensitiveData(targetElement.value, targetElement);
                }
            } else if (targetElement.tagName === 'TEXTAREA') {
                value = CSUtils.maskSensitiveData(targetElement.value, targetElement);
            } else if (targetElement.tagName === 'SELECT') {
                value = targetElement.value;
                
                // For multiselect, get all selected options
                if (targetElement.multiple) {
                    const selectedOptions = Array.from(targetElement.selectedOptions);
                    value = selectedOptions.map(option => ({
                        value: option.value,
                        text: option.text
                    }));
                } else {
                    // Get selected option text for better readability
                    const selectedOption = targetElement.options[targetElement.selectedIndex];
                    if (selectedOption) {
                        value = {
                            value: value,
                            text: selectedOption.text
                        };
                    }
                }
            }
            
            CSChannel.sendEvent({
                type: 'change',
                targetSelector: CSUtils.getUniqueSelector(targetElement),
                targetXPath: CSUtils.getXPath(targetElement),
                targetTagName: targetElement.tagName,
                targetType: targetElement.type,
                targetName: targetElement.name,
                targetId: targetElement.id,
                targetAttributes: CSUtils.getElementAttributes(targetElement),
                value: value,
                isSensitive: CSUtils.isSensitiveInput(targetElement)
            });
        },
        
        /**
         * Handle focus events
         * @param {Event} event - The focus event
         */
        handleFocusEvent: function(event) {
            if (!event.target || CSUtils.shouldIgnoreElement(event.target)) {
                return;
            }
            
            const targetElement = event.target;
            
            CSChannel.sendEvent({
                type: 'focus',
                targetSelector: CSUtils.getUniqueSelector(targetElement),
                targetXPath: CSUtils.getXPath(targetElement),
                targetTagName: targetElement.tagName,
                targetType: targetElement.type,
                targetName: targetElement.name,
                targetId: targetElement.id,
                targetAttributes: CSUtils.getElementAttributes(targetElement)
            });
        },
        
        /**
         * Handle blur events
         * @param {Event} event - The blur event
         */
        handleBlurEvent: function(event) {
            if (!event.target || CSUtils.shouldIgnoreElement(event.target)) {
                return;
            }
            
            const targetElement = event.target;
            
            CSChannel.sendEvent({
                type: 'blur',
                targetSelector: CSUtils.getUniqueSelector(targetElement),
                targetXPath: CSUtils.getXPath(targetElement),
                targetTagName: targetElement.tagName,
                targetType: targetElement.type,
                targetName: targetElement.name,
                targetId: targetElement.id,
                targetAttributes: CSUtils.getElementAttributes(targetElement)
            });
        },
        
        /**
         * Handle form events
         * @param {Event} event - The form event
         */
        handleFormEvent: function(event) {
            if (!event.target || CSUtils.shouldIgnoreElement(event.target)) {
                return;
            }
            
            const form = event.target;
            
            // Prevent default if recording mode is active
            // This is optional and can be controlled via a command
            // from the recorder
            
            // Collect form data (excluding sensitive fields)
            const formData = {};
            const elements = form.elements;
            
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                
                // Skip if the element doesn't have a name
                if (!element.name) continue;
                
                // Skip if the element is sensitive
                if (CSUtils.isSensitiveInput(element)) {
                    formData[element.name] = '••••••••';
                    continue;
                }
                
                // Handle different input types
                if (element.type === 'checkbox' || element.type === 'radio') {
                    if (element.checked) {
                        formData[element.name] = element.value;
                    }
                } else if (element.type !== 'file' && element.type !== 'submit' && 
                           element.type !== 'button' && element.type !== 'reset') {
                    formData[element.name] = element.value;
                }
            }
            
            CSChannel.sendEvent({
                type: 'form',
                subtype: 'submit',
                targetSelector: CSUtils.getUniqueSelector(form),
                targetXPath: CSUtils.getXPath(form),
                formId: form.id,
                formName: form.name,
                formAction: form.action,
                formMethod: form.method,
                formData: formData
            });
        },
        
        /**
         * Handle keyboard events
         * @param {Event} event - The keyboard event
         */
        handleKeyboardEvent: function(event) {
            if (!event.target || CSUtils.shouldIgnoreElement(event.target)) {
                return;
            }
            
            const targetElement = event.target;
            
            // Skip recording for sensitive inputs
            if (CSUtils.isSensitiveInput(targetElement)) {
                // Just record that a key was pressed on a sensitive field,
                // without recording the actual key
                CSChannel.sendEvent({
                    type: 'keyboard',
                    subtype: 'keydown',
                    targetSelector: CSUtils.getUniqueSelector(targetElement),
                    targetXPath: CSUtils.getXPath(targetElement),
                    targetTagName: targetElement.tagName,
                    isSensitive: true
                });
                return;
            }
            
            // Record special keys and combinations
            if (event.key === 'Enter' || 
                event.key === 'Escape' || 
                event.key === 'Tab' || 
                event.key === 'ArrowUp' || 
                event.key === 'ArrowDown' || 
                event.key === 'ArrowLeft' || 
                event.key === 'ArrowRight' || 
                event.ctrlKey || 
                event.altKey || 
                event.metaKey) {
                
                CSChannel.sendEvent({
                    type: 'keyboard',
                    subtype: 'keydown',
                    targetSelector: CSUtils.getUniqueSelector(targetElement),
                    targetXPath: CSUtils.getXPath(targetElement),
                    targetTagName: targetElement.tagName,
                    key: event.key,
                    keyCode: event.keyCode,
                    ctrlKey: event.ctrlKey,
                    altKey: event.altKey,
                    shiftKey: event.shiftKey,
                    metaKey: event.metaKey
                });
            }
        },
        
        /**
         * Handle navigation events
         * @param {Event} event - The navigation event
         */
        handleNavigationEvent: function(event) {
            CSChannel.sendEvent({
                type: 'navigation',
                subtype: event.type, // 'popstate' or 'hashchange'
                url: window.location.href,
                oldURL: event.oldURL,
                newURL: event.newURL,
                state: event.state ? JSON.stringify(event.state).substring(0, 100) : null
            });
        },
        
        /**
         * Handle hover events
         * @param {Event} event - The hover event
         */
        handleHoverEvent: function(event) {
            if (!event.target || CSUtils.shouldIgnoreElement(event.target)) {
                return;
            }
            
            // Only record hovers on interactive elements
            const targetElement = event.target;
            const isInteractive = targetElement.tagName === 'A' || 
                                  targetElement.tagName === 'BUTTON' || 
                                  targetElement.getAttribute('role') === 'button' || 
                                  targetElement.tagName === 'INPUT' || 
                                  targetElement.tagName === 'SELECT' || 
                                  targetElement.tagName === 'TEXTAREA' || 
                                  targetElement.tagName === 'LABEL' || 
                                  targetElement.hasAttribute('tabindex');
            
            if (!isInteractive) {
                // Check if it's within an interactive element
                const interactiveParent = targetElement.closest('a, button, [role="button"], input, select, textarea, label, [tabindex]');
                if (!interactiveParent) {
                    return;
                }
            }
            
            CSChannel.sendEvent({
                type: 'hover',
                targetSelector: CSUtils.getUniqueSelector(targetElement),
                targetXPath: CSUtils.getXPath(targetElement),
                targetTagName: targetElement.tagName,
                targetText: CSUtils.getElementText(targetElement),
                clientX: event.clientX,
                clientY: event.clientY
            });
        },
        
        /**
         * Handle window events
         * @param {Event} event - The window event
         */
        handleWindowEvent: function(event) {
            CSChannel.sendEvent({
                type: 'window',
                subtype: event.type, // 'load' or 'beforeunload'
                url: window.location.href,
                title: document.title,
                viewportWidth: window.innerWidth,
                viewportHeight: window.innerHeight
            });
        },
        
        /**
         * Handle scroll events
         * @param {Event} event - The scroll event
         */
        handleScrollEvent: function(event) {
            // Only record scrolls on the document or large containers
            let target = event.target;
            
            if (target === document) {
                CSChannel.sendEvent({
                    type: 'scroll',
                    subtype: 'document',
                    scrollX: window.scrollX,
                    scrollY: window.scrollY
                });
            } else if (target.nodeType === Node.ELEMENT_NODE) {
                // Check if it's a large scrollable container
                const rect = target.getBoundingClientRect();
                if (rect.width > 200 && rect.height > 200) {
                    CSChannel.sendEvent({
                        type: 'scroll',
                        subtype: 'element',
                        targetSelector: CSUtils.getUniqueSelector(target),
                        targetXPath: CSUtils.getXPath(target),
                        scrollLeft: target.scrollLeft,
                        scrollTop: target.scrollTop
                    });
                }
            }
        },
        
        /**
         * Handle commands from the recorder application
         * @param {string} command - The command to handle
         * @param {Object} params - Command parameters
         */
        handleCommand: function(command, params) {
            switch (command) {
                case 'pause':
                    this.pauseEventCapture();
                    break;
                    
                case 'resume':
                    this.resumeEventCapture();
                    break;
                    
                case 'highlight':
                    this.highlightElement(params.selector);
                    break;
                    
                case 'getPageInfo':
                    this.sendPageInfo();
                    break;
                    
                case 'testSelector':
                    this.testSelector(params.selector);
                    break;
                    
                case 'executeScript':
                    this.executeScript(params.script, params.scriptId);
                    break;
                    
                case 'updateConfig':
                    this.updateConfig(params.config);
                    break;
                    
                default:
                    console.log('CSTestForge: Unknown command', command);
            }
        },
        
        /**
         * Pause event capture
         */
        pauseEventCapture: function() {
            console.log('CSTestForge: Event capture paused');
            
            // Remove event listeners
            if (CONFIG.captureClicks) {
                document.removeEventListener('click', this.handleClickEvent.bind(this), true);
                document.removeEventListener('dblclick', this.handleClickEvent.bind(this), true);
                document.removeEventListener('contextmenu', this.handleClickEvent.bind(this), true);
            }
            
            if (CONFIG.captureInputs) {
                document.removeEventListener('input', this.handleInputEvent.bind(this), true);
                document.removeEventListener('change', this.handleChangeEvent.bind(this), true);
                document.removeEventListener('focus', this.handleFocusEvent.bind(this), true);
                document.removeEventListener('blur', this.handleBlurEvent.bind(this), true);
                document.removeEventListener('submit', this.handleFormEvent.bind(this), true);
            }
            
            if (CONFIG.captureKeyboard) {
                document.removeEventListener('keydown', this.handleKeyboardEvent.bind(this), true);
            }
            
            if (CONFIG.captureHovers) {
                document.removeEventListener('mouseover', this.handleHoverEvent.bind(this), true);
            }
            
            // Disconnect observers
            for (const observerName in this.observers) {
                if (this.observers[observerName]) {
                    this.observers[observerName].disconnect();
                }
            }
            
            CSChannel.sendEvent({
                type: 'status',
                status: 'paused'
            });
        },
        
        /**
         * Resume event capture
         */
        resumeEventCapture: function() {
            console.log('CSTestForge: Event capture resumed');
            
            // Re-initialize event capture
            this.setupListeners();
            this.setupMutationObserver();
            this.setupResizeObserver();
            
            if (CONFIG.captureNetwork) {
                this.setupNetworkObserver();
            }
            
            CSChannel.sendEvent({
                type: 'status',
                status: 'recording'
            });
        },
        
        /**
         * Highlight an element
         * @param {string} selector - CSS selector for the element to highlight
         */
        highlightElement: function(selector) {
            try {
                const element = document.querySelector(selector);
                
                if (!element) {
                    console.log('CSTestForge: Element not found', selector);
                    return;
                }
                
                // Create highlight overlay
                const overlay = document.createElement('div');
                const rect = element.getBoundingClientRect();
                
                overlay.style.position = 'absolute';
                overlay.style.top = (rect.top + window.scrollY) + 'px';
                overlay.style.left = (rect.left + window.scrollX) + 'px';
                overlay.style.width = rect.width + 'px';
                overlay.style.height = rect.height + 'px';
                overlay.style.backgroundColor = 'rgba(197, 75, 140, 0.3)';
                overlay.style.border = '2px solid #C54B8C';
                overlay.style.zIndex = '2147483647';
                overlay.style.pointerEvents = 'none';
                overlay.style.boxSizing = 'border-box';
                overlay.style.transition = 'opacity 0.3s ease-in-out';
                overlay.style.borderRadius = '3px';
                overlay.id = 'cs-highlight-overlay';
                
                // Remove any existing overlay
                const existingOverlay = document.getElementById('cs-highlight-overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
                
                document.body.appendChild(overlay);
                
                // Add pulse animation
                overlay.animate([
                    { boxShadow: '0 0 0 rgba(197, 75, 140, 0.4)' },
                    { boxShadow: '0 0 0 10px rgba(197, 75, 140, 0)' }
                ], {
                    duration: 1000,
                    iterations: 3
                });
                
                // Remove overlay after animation
                setTimeout(() => {
                    if (overlay.parentNode) {
                        overlay.remove();
                    }
                }, 3000);
            } catch (e) {
                console.error('CSTestForge: Error highlighting element', e);
            }
        },
        
        /**
         * Send page information to the recorder
         */
        sendPageInfo: function() {
            // Collect all interactive elements
            const interactiveElements = document.querySelectorAll('a, button, input, select, textarea, [role="button"], [tabindex]');
            
            const elementsInfo = Array.from(interactiveElements).map(element => {
                if (CSUtils.shouldIgnoreElement(element)) {
                    return null;
                }
                
                return {
                    selector: CSUtils.getUniqueSelector(element),
                    xpath: CSUtils.getXPath(element),
                    tagName: element.tagName,
                    type: element.type,
                    id: element.id,
                    name: element.name,
                    text: CSUtils.getElementText(element),
                    attributes: CSUtils.getElementAttributes(element),
                    rect: element.getBoundingClientRect().toJSON()
                };
            }).filter(Boolean);
            
            // Collect forms
            const forms = document.querySelectorAll('form');
            const formsInfo = Array.from(forms).map(form => {
                if (CSUtils.shouldIgnoreElement(form)) {
                    return null;
                }
                
                const elements = Array.from(form.elements).map(element => {
                    if (CSUtils.shouldIgnoreElement(element)) {
                        return null;
                    }
                    
                    return {
                        selector: CSUtils.getUniqueSelector(element),
                        xpath: CSUtils.getXPath(element),
                        tagName: element.tagName,
                        type: element.type,
                        id: element.id,
                        name: element.name,
                        value: CSUtils.isSensitiveInput(element) ? '••••••••' : element.value
                    };
                }).filter(Boolean);
                
                return {
                    selector: CSUtils.getUniqueSelector(form),
                    xpath: CSUtils.getXPath(form),
                    id: form.id,
                    name: form.name,
                    action: form.action,
                    method: form.method,
                    elements: elements
                };
            }).filter(Boolean);
            
            CSChannel.sendEvent({
                type: 'pageInfo',
                url: window.location.href,
                title: document.title,
                elements: elementsInfo,
                forms: formsInfo,
                viewportWidth: window.innerWidth,
                viewportHeight: window.innerHeight,
                documentHeight: document.documentElement.scrollHeight,
                documentWidth: document.documentElement.scrollWidth
            });
        },
        
        /**
         * Test a selector and return the results
         * @param {string} selector - The selector to test
         */
        testSelector: function(selector) {
            try {
                const elements = document.querySelectorAll(selector);
                
                const result = {
                    count: elements.length,
                    elements: Array.from(elements).slice(0, 10).map(element => {
                        return {
                            tagName: element.tagName,
                            id: element.id,
                            className: element.className,
                            text: CSUtils.getElementText(element),
                            rect: element.getBoundingClientRect().toJSON()
                        };
                    })
                };
                
                CSChannel.sendEvent({
                    type: 'testSelector',
                    selector: selector,
                    result: result,
                    success: true
                });
            } catch (e) {
                CSChannel.sendEvent({
                    type: 'testSelector',
                    selector: selector,
                    error: e.toString(),
                    success: false
                });
            }
        },
        
        /**
         * Execute a script in the page context
         * @param {string} script - The script to execute
         * @param {string} scriptId - ID to identify the script execution
         */
        executeScript: function(script, scriptId) {
            try {
                // Create a function from the script string
                const scriptFunction = new Function(script);
                
                // Execute the script
                const result = scriptFunction();
                
                CSChannel.sendEvent({
                    type: 'scriptResult',
                    scriptId: scriptId,
                    result: result,
                    success: true
                });
            } catch (e) {
                CSChannel.sendEvent({
                    type: 'scriptResult',
                    scriptId: scriptId,
                    error: e.toString(),
                    success: false
                });
            }
        },
        
        /**
         * Update configuration settings
         * @param {Object} newConfig - New configuration settings
         */
        updateConfig: function(newConfig) {
            // Update only the provided settings
            for (const key in newConfig) {
                if (CONFIG.hasOwnProperty(key)) {
                    CONFIG[key] = newConfig[key];
                }
            }
            
            console.log('CSTestForge: Configuration updated', CONFIG);
            
            CSChannel.sendEvent({
                type: 'configUpdated',
                config: CONFIG
            });
            
            // Reinitialize with new config if needed
            if (newConfig.captureClicks !== undefined ||
                newConfig.captureInputs !== undefined ||
                newConfig.captureKeyboard !== undefined ||
                newConfig.captureNavigation !== undefined ||
                newConfig.captureMutations !== undefined ||
                newConfig.captureHovers !== undefined ||
                newConfig.captureNetwork !== undefined) {
                
                this.pauseEventCapture();
                this.resumeEventCapture();
            }
        }
    };
    
    /**
     * Class to handle advanced element recognition
     */
    const CSElementRecognizer = {
        /**
         * Element types for classification
         */
        elementTypes: {
            BUTTON: 'button',
            LINK: 'link',
            TEXTBOX: 'textbox',
            CHECKBOX: 'checkbox',
            RADIO: 'radio',
            SELECT: 'select',
            MULTISELECT: 'multiselect',
            FILE: 'file',
            IMAGE: 'image',
            FORM: 'form',
            TABLE: 'table',
            DROPDOWN: 'dropdown',
            TAB: 'tab',
            MENU: 'menu',
            DATEPICKER: 'datepicker',
            SLIDER: 'slider',
            TOGGLE: 'toggle',
            DIALOG: 'dialog',
            ALERT: 'alert',
            UNKNOWN: 'unknown'
        },
        
        /**
         * Recognize element type based on various attributes and context
         * @param {Element} element - The element to recognize
         * @returns {string} The recognized element type
         */
        recognizeElementType: function(element) {
            if (!element || !element.tagName) {
                return this.elementTypes.UNKNOWN;
            }
            
            const tagName = element.tagName.toLowerCase();
            const type = element.getAttribute('type') ? element.getAttribute('type').toLowerCase() : '';
            const role = element.getAttribute('role') ? element.getAttribute('role').toLowerCase() : '';
            
            // Direct mapping for common elements
            if (tagName === 'button' || role === 'button') {
                return this.elementTypes.BUTTON;
            }
            
            if (tagName === 'a') {
                return this.elementTypes.LINK;
            }
            
            if (tagName === 'input') {
                if (type === 'checkbox') {
                    return this.elementTypes.CHECKBOX;
                }
                
                if (type === 'radio') {
                    return this.elementTypes.RADIO;
                }
                
                if (type === 'file') {
                    return this.elementTypes.FILE;
                }
                
                if (type === 'button' || type === 'submit' || type === 'reset') {
                    return this.elementTypes.BUTTON;
                }
                
                if (type === 'text' || type === 'password' || type === 'email' || 
                    type === 'tel' || type === 'number' || type === 'search' || 
                    type === 'url' || type === '' || type === undefined) {
                    return this.elementTypes.TEXTBOX;
                }
                
                if (type === 'date' || type === 'datetime-local' || type === 'month' || 
                    type === 'time' || type === 'week') {
                    return this.elementTypes.DATEPICKER;
                }
                
                if (type === 'range') {
                    return this.elementTypes.SLIDER;
                }
            }
            
            if (tagName === 'textarea') {
                return this.elementTypes.TEXTBOX;
            }
            
            if (tagName === 'select') {
                if (element.multiple) {
                    return this.elementTypes.MULTISELECT;
                }
                return this.elementTypes.SELECT;
            }
            
            if (tagName === 'img' || role === 'img') {
                return this.elementTypes.IMAGE;
            }
            
            if (tagName === 'form') {
                return this.elementTypes.FORM;
            }
            
            if (tagName === 'table' || role === 'grid' || role === 'treegrid') {
                return this.elementTypes.TABLE;
            }
            
            // Role-based recognition
            if (role === 'tab') {
                return this.elementTypes.TAB;
            }
            
            if (role === 'menu' || role === 'menubar' || role === 'menuitem') {
                return this.elementTypes.MENU;
            }
            
            if (role === 'listbox' || role === 'combobox') {
                return this.elementTypes.DROPDOWN;
            }
            
            if (role === 'dialog' || role === 'alertdialog') {
                return this.elementTypes.DIALOG;
            }
            
            if (role === 'alert') {
                return this.elementTypes.ALERT;
            }
            
            if (role === 'switch') {
                return this.elementTypes.TOGGLE;
            }
            
            if (role === 'slider') {
                return this.elementTypes.SLIDER;
            }
            
            // Context-based recognition for non-semantic elements
            if (tagName === 'div' || tagName === 'span') {
                // Look for class names that indicate functionality
                const className = element.className || '';
                
                const buttonPatterns = [/btn/i, /button/i];
                const linkPatterns = [/link/i];
                const checkboxPatterns = [/checkbox/i, /check-box/i];
                const radioPatterns = [/radio/i];
                const menuPatterns = [/menu/i, /dropdown/i, /submenu/i];
                const tabPatterns = [/tab/i, /\btab-/i, /-tab\b/i];
                const sliderPatterns = [/slider/i, /range/i];
                const togglePatterns = [/toggle/i, /switch/i];
                const dialogPatterns = [/modal/i, /dialog/i, /popup/i];
                
                if (buttonPatterns.some(pattern => pattern.test(className))) {
                    return this.elementTypes.BUTTON;
                }
                
                if (linkPatterns.some(pattern => pattern.test(className))) {
                    return this.elementTypes.LINK;
                }
                
                if (checkboxPatterns.some(pattern => pattern.test(className))) {
                    return this.elementTypes.CHECKBOX;
                }
                
                if (radioPatterns.some(pattern => pattern.test(className))) {
                    return this.elementTypes.RADIO;
                }
                
                if (menuPatterns.some(pattern => pattern.test(className))) {
                    return this.elementTypes.MENU;
                }
                
                if (tabPatterns.some(pattern => pattern.test(className))) {
                    return this.elementTypes.TAB;
                }
                
                if (sliderPatterns.some(pattern => pattern.test(className))) {
                    return this.elementTypes.SLIDER;
                }
                
                if (togglePatterns.some(pattern => pattern.test(className))) {
                    return this.elementTypes.TOGGLE;
                }
                
                if (dialogPatterns.some(pattern => pattern.test(className))) {
                    return this.elementTypes.DIALOG;
                }
                
                // Check for child elements that might indicate functionality
                if (element.querySelector('input[type="checkbox"]')) {
                    return this.elementTypes.CHECKBOX;
                }
                
                if (element.querySelector('input[type="radio"]')) {
                    return this.elementTypes.RADIO;
                }
                
                // Check for clickable divs with specific characteristics
                if (element.onclick || element.addEventListener || element.hasAttribute('onclick') || 
                    window.getComputedStyle(element).cursor === 'pointer' || 
                    element.hasAttribute('tabindex')) {
                    
                    if (element.querySelector('a') && !element.querySelector('a ~ a')) {
                        return this.elementTypes.LINK;
                    }
                    
                    return this.elementTypes.BUTTON;
                }
            }
            
            return this.elementTypes.UNKNOWN;
        },
        
        /**
         * Suggest a better selector for an element based on its type and attributes
         * @param {Element} element - The element to generate a selector for
         * @returns {Object} Object containing suggested selectors
         */
        suggestBetterSelector: function(element) {
            if (!element) {
                return null;
            }
            
            const elementType = this.recognizeElementType(element);
            const suggestions = [];
            
            // Try ID selector if available
            if (element.id) {
                suggestions.push({
                    type: 'id',
                    selector: `#${CSS.escape(element.id)}`,
                    robustness: 'high'
                });
            }
            
            // Try data attribute selectors
            for (const attr of CONFIG.dataAttributesToTrack) {
                if (element.hasAttribute(attr)) {
                    suggestions.push({
                        type: 'data-attribute',
                        selector: `[${attr}="${CSS.escape(element.getAttribute(attr))}"]`,
                        robustness: 'high'
                    });
                }
            }
            
            // Try name attribute for form elements
            if (element.name && ['INPUT', 'SELECT', 'TEXTAREA', 'BUTTON', 'FORM'].includes(element.tagName)) {
                suggestions.push({
                    type: 'name',
                    selector: `${element.tagName.toLowerCase()}[name="${CSS.escape(element.name)}"]`,
                    robustness: 'medium'
                });
            }
            
            // Type-specific selectors
            switch (elementType) {
                case this.elementTypes.BUTTON:
                    if (element.textContent && element.textContent.trim()) {
                        const buttonText = element.textContent.trim();
                        suggestions.push({
                            type: 'button-text',
                            selector: `button:contains("${buttonText}")`,
                            robustness: 'medium',
                            note: 'Requires jQuery or similar for :contains'
                        });
                        
                        // XPath alternative
                        suggestions.push({
                            type: 'button-text-xpath',
                            selector: `//button[contains(text(), '${buttonText}')]`,
                            robustness: 'medium',
                            isXPath: true
                        });
                    }
                    break;
                    
                case this.elementTypes.LINK:
                    if (element.textContent && element.textContent.trim()) {
                        const linkText = element.textContent.trim();
                        suggestions.push({
                            type: 'link-text',
                            selector: `a:contains("${linkText}")`,
                            robustness: 'medium',
                            note: 'Requires jQuery or similar for :contains'
                        });
                        
                        // XPath alternative
                        suggestions.push({
                            type: 'link-text-xpath',
                            selector: `//a[contains(text(), '${linkText}')]`,
                            robustness: 'medium',
                            isXPath: true
                        });
                    }
                    
                    if (element.getAttribute('href')) {
                        suggestions.push({
                            type: 'link-href',
                            selector: `a[href="${CSS.escape(element.getAttribute('href'))}"]`,
                            robustness: 'low'
                        });
                    }
                    break;
                    
                case this.elementTypes.TEXTBOX:
                    if (element.getAttribute('placeholder')) {
                        suggestions.push({
                            type: 'input-placeholder',
                            selector: `input[placeholder="${CSS.escape(element.getAttribute('placeholder'))}"]`,
                            robustness: 'medium'
                        });
                    }
                    
                    // Look for associated label
                    if (element.id) {
                        const label = document.querySelector(`label[for="${CSS.escape(element.id)}"]`);
                        if (label && label.textContent.trim()) {
                            suggestions.push({
                                type: 'input-label',
                                selector: `label:contains("${label.textContent.trim()}") + input, input#${CSS.escape(element.id)}`,
                                robustness: 'medium',
                                note: 'Requires jQuery or similar for :contains'
                            });
                            
                            // XPath alternative
                            suggestions.push({
                                type: 'input-label-xpath',
                                selector: `//label[contains(text(), '${label.textContent.trim()}')]/following-sibling::input`,
                                robustness: 'medium',
                                isXPath: true
                            });
                        }
                    }
                    break;
                    
                case this.elementTypes.CHECKBOX:
                case this.elementTypes.RADIO:
                    // Look for associated label
                    if (element.id) {
                        const label = document.querySelector(`label[for="${CSS.escape(element.id)}"]`);
                        if (label && label.textContent.trim()) {
                            suggestions.push({
                                type: 'input-label',
                                selector: `input#${CSS.escape(element.id)}`,
                                robustness: 'high'
                            });
                            
                            suggestions.push({
                                type: 'label-text',
                                selector: `label:contains("${label.textContent.trim()}") + input, input#${CSS.escape(element.id)}`,
                                robustness: 'medium',
                                note: 'Requires jQuery or similar for :contains'
                            });
                            
                            // XPath alternative
                            suggestions.push({
                                type: 'label-text-xpath',
                                selector: `//label[contains(text(), '${label.textContent.trim()}')]/following-sibling::input`,
                                robustness: 'medium',
                                isXPath: true
                            });
                        }
                    }
                    break;
                    
                case this.elementTypes.SELECT:
                    // Look for associated label
                    if (element.id) {
                        const label = document.querySelector(`label[for="${CSS.escape(element.id)}"]`);
                        if (label && label.textContent.trim()) {
                            suggestions.push({
                                type: 'select-label',
                                selector: `label:contains("${label.textContent.trim()}") + select, select#${CSS.escape(element.id)}`,
                                robustness: 'medium',
                                note: 'Requires jQuery or similar for :contains'
                            });
                            
                            // XPath alternative
                            suggestions.push({
                                type: 'select-label-xpath',
                                selector: `//label[contains(text(), '${label.textContent.trim()}')]/following-sibling::select`,
                                robustness: 'medium',
                                isXPath: true
                            });
                        }
                    }
                    break;
            }
            
            // If no good suggestions, fall back to CSS path
            if (suggestions.length === 0) {
                const cssPath = CSUtils.getUniqueSelector(element);
                suggestions.push({
                    type: 'css-path',
                    selector: cssPath,
                    robustness: 'low'
                });
            }
            
            // Always add the XPath as an option
            suggestions.push({
                type: 'xpath',
                selector: CSUtils.getXPath(element),
                robustness: 'medium',
                isXPath: true
            });
            
            return {
                elementType: elementType,
                suggestions: suggestions
            };
        },
        
        /**
         * Get alternative methods to locate an element based on its context
         * @param {Element} element - The element to analyze
         * @returns {Object} Object containing alternative location methods
         */
        getAlternativeLocators: function(element) {
            if (!element) {
                return null;
            }
            
            const alternatives = [];
            
            // Check if the element has unique text content
            if (element.textContent && element.textContent.trim()) {
                const textContent = element.textContent.trim();
                if (textContent.length > 0 && textContent.length < 100) {
                    // Check how many elements have this text
                    const textMatch = Array.from(document.querySelectorAll('*')).filter(
                        el => el.textContent && el.textContent.trim() === textContent
                    );
                    
                    if (textMatch.length < 3) {
                        alternatives.push({
                            type: 'text-content',
                            description: `Element with text "${textContent}"`,
                            robustness: textMatch.length === 1 ? 'high' : 'medium',
                            xpath: `//*[contains(text(), '${textContent}')]`
                        });
                    }
                }
            }
            
            // Check if the element is near a landmark element
            const landmarks = [
                { tag: 'h1', type: 'heading' },
                { tag: 'h2', type: 'heading' },
                { tag: 'h3', type: 'heading' },
                { tag: 'header', type: 'header' },
                { tag: 'footer', type: 'footer' },
                { tag: 'nav', type: 'navigation' },
                { tag: 'aside', type: 'sidebar' },
                { tag: 'main', type: 'main content' }
            ];
            
            for (const landmark of landmarks) {
                const landmarkElements = document.querySelectorAll(landmark.tag);
                
                for (const landmarkElement of landmarkElements) {
                    // Check if landmark has text and is reasonably close to our element
                    if (!landmarkElement.textContent || !landmarkElement.textContent.trim()) {
                        continue;
                    }
                    
                    const landmarkText = landmarkElement.textContent.trim();
                    
                    // Too far away in the DOM
                    if (!element.parentElement || !landmarkElement.parentElement) {
                        continue;
                    }
                    
                    // Check if element is after landmark in the same container
                    const commonParent = CSUtils.findCommonAncestor(element, landmarkElement);
                    if (commonParent) {
                        const landmarkPosition = CSUtils.getPositionInParent(landmarkElement, commonParent);
                        const elementPosition = CSUtils.getPositionInParent(element, commonParent);
                        
                        if (landmarkPosition !== -1 && elementPosition !== -1) {
                            if (Math.abs(landmarkPosition - elementPosition) < 10) {
                                alternatives.push({
                                    type: 'landmark-proximity',
                                    description: `Element near ${landmark.type} "${landmarkText.substring(0, 20)}${landmarkText.length > 20 ? '...' : ''}"`,
                                    robustness: 'medium',
                                    xpath: `//following-sibling::*[position() < 10]`
                                });
                            }
                        }
                    }
                }
            }
            
            // Check for nearby image with alt text
            const nearbyImages = element.parentElement ? element.parentElement.querySelectorAll('img[alt]') : [];
            for (const img of nearbyImages) {
                const altText = img.getAttribute('alt');
                if (altText && altText.trim()) {
                    alternatives.push({
                        type: 'image-proximity',
                        description: `Element near image with alt text "${altText}"`,
                        robustness: 'medium',
                        xpath: `//*[img[@alt="${altText}"]]/*[position() < 5]`
                    });
                }
            }
            
            return alternatives;
        }
    };
    
    /**
     * Add utility methods specifically for element recognition
     */
    CSUtils.findCommonAncestor = function(element1, element2) {
        if (!element1 || !element2) {
            return null;
        }
        
        const ancestors1 = [];
        let current = element1.parentElement;
        
        while (current) {
            ancestors1.push(current);
            current = current.parentElement;
        }
        
        current = element2.parentElement;
        while (current) {
            if (ancestors1.includes(current)) {
                return current;
            }
            current = current.parentElement;
        }
        
        return null;
    };
    
    CSUtils.getPositionInParent = function(element, parent) {
        if (!element || !parent) {
            return -1;
        }
        
        let current = element;
        let position = 0;
        
        while (current !== parent && current.parentElement) {
            const siblings = current.parentElement.children;
            for (let i = 0; i < siblings.length; i++) {
                if (siblings[i] === current) {
                    position += i;
                    break;
                }
            }
            
            current = current.parentElement;
            
            if (current === parent) {
                return position;
            }
        }
        
        return -1;
    };
    
    /**
     * Smart wait detector to identify wait patterns in applications
     */
    const CSWaitDetector = {
        /**
         * Configuration for the wait detector
         */
        config: {
            // Interval for polling the page (ms)
            pollInterval: 100,
            
            // Timeout after which to stop looking for waits (ms)
            timeout: 30000,
            
            // Stability time required to consider a wait complete (ms)
            stabilityThreshold: 500,
            
            // Types of waits to detect
            detectSpinners: true,
            detectProgressBars: true,
            detectNetworkRequests: true,
            detectAnimations: true,
            detectStateChanges: true,
            
            // Selectors for common loading indicators
            spinnerSelectors: [
                '.spinner', '.loader', '.loading', 
                '[role="progressbar"]', 
                '.fa-spinner', '.fa-circle-o-notch', '.fa-refresh',
                '.spin', '.rotate', '.pulse',
                '[class*="spinner"]', '[class*="loader"]', '[class*="loading"]',
                '[class*="progress"]'
            ],
            
            // Animation properties to detect
            animationProperties: [
                'animation', 'animation-name', 'animation-duration',
                'transition', 'transition-property', 'transition-duration'
            ],
            
            // Keywords in class names or IDs that suggest a loading state
            loadingKeywords: [
                'load', 'loading', 'wait', 'waiting', 
                'progress', 'spinner', 'spin', 'busy', 
                'fetching', 'processing'
            ]
        },
        
        /**
         * State for tracking waits
         */
        state: {
            // Whether a wait detection is in progress
            detecting: false,
            
            // Timestamp when detection started
            startTime: 0,
            
            // Intervals and timeouts
            pollInterval: null,
            timeout: null,
            
            // Wait conditions detected
            detectedWaits: [],
            
            // Network requests in progress
            activeRequests: 0,
            
            // DOM stability tracking
            lastDomState: '',
            lastDomStateTime: 0,
            domStable: false,
            
            // Callback to call when wait is complete
            callback: null
        },
        
        /**
         * Start detecting waits on the page
         * @param {Function} callback - Function to call when wait is complete
         */
        detectWaits: function(callback) {
            if (this.state.detecting) {
                return;
            }
            
            this.state.detecting = true;
            this.state.startTime = Date.now();
            this.state.detectedWaits = [];
            this.state.callback = callback || function() {};
            
            // Start polling for wait conditions
            this.state.pollInterval = setInterval(() => {
                this.checkWaitConditions();
            }, this.config.pollInterval);
            
            // Set timeout to prevent endless waiting
            this.state.timeout = setTimeout(() => {
                this.stopDetection(true);
            }, this.config.timeout);
            
            // Set up network request interception if enabled
            if (this.config.detectNetworkRequests) {
                this.setupNetworkMonitoring();
            }
            
            console.log('CSTestForge: Wait detection started');
        },
        
        /**
         * Check for various wait conditions on the page
         */
        checkWaitConditions: function() {
            let waitingConditions = [];
            
            // Check for visible spinners
            if (this.config.detectSpinners) {
                const spinners = this.findVisibleSpinners();
                if (spinners.length > 0) {
                    waitingConditions.push({
                        type: 'spinner',
                        elements: spinners.map(spinner => ({
                            selector: CSUtils.getUniqueSelector(spinner),
                            xpath: CSUtils.getXPath(spinner)
                        }))
                    });
                }
            }
            
            // Check for progress bars
            if (this.config.detectProgressBars) {
                const progressBars = this.findProgressBars();
                if (progressBars.length > 0) {
                    waitingConditions.push({
                        type: 'progressBar',
                        elements: progressBars.map(bar => ({
                            selector: CSUtils.getUniqueSelector(bar),
                            xpath: CSUtils.getXPath(bar),
                            value: bar.value,
                            max: bar.max
                        }))
                    });
                }
            }
            
            // Check for ongoing network requests
            if (this.config.detectNetworkRequests && this.state.activeRequests > 0) {
                waitingConditions.push({
                    type: 'networkRequest',
                    count: this.state.activeRequests
                });
            }
            
            // Check for animations
            if (this.config.detectAnimations) {
                const animatedElements = this.findAnimatedElements();
                if (animatedElements.length > 0) {
                    waitingConditions.push({
                        type: 'animation',
                        elements: animatedElements.map(el => ({
                            selector: CSUtils.getUniqueSelector(el),
                            xpath: CSUtils.getXPath(el)
                        }))
                    });
                }
            }
            
            // Check for DOM stability
            if (this.config.detectStateChanges) {
                const currentDomState = this.getDomFingerprint();
                const now = Date.now();
                
                if (currentDomState === this.state.lastDomState) {
                    if (now - this.state.lastDomStateTime >= this.config.stabilityThreshold) {
                        this.state.domStable = true;
                    }
                } else {
                    this.state.lastDomState = currentDomState;
                    this.state.lastDomStateTime = now;
                    this.state.domStable = false;
                    
                    waitingConditions.push({
                        type: 'domChange',
                        timestamp: now
                    });
                }
            }
            
            // Update detected waits
            this.state.detectedWaits = waitingConditions;
            
            // If no wait conditions and DOM is stable, stop detection
            if (waitingConditions.length === 0 && this.state.domStable) {
                this.stopDetection(false);
            }
        },
        
        /**
         * Stop wait detection
         * @param {boolean} timedOut - Whether detection stopped due to timeout
         */
        stopDetection: function(timedOut) {
            if (!this.state.detecting) {
                return;
            }
            
            clearInterval(this.state.pollInterval);
            clearTimeout(this.state.timeout);
            
            this.state.detecting = false;
            
            // Clean up network monitoring
            if (this.config.detectNetworkRequests) {
                this.cleanupNetworkMonitoring();
            }
            
            // Calculate wait duration
            const duration = Date.now() - this.state.startTime;
            
            console.log(`CSTestForge: Wait detection stopped after ${duration}ms, timedOut: ${timedOut}`);
            
            // Call callback with results
            this.state.callback({
                duration: duration,
                timedOut: timedOut,
                waits: this.state.detectedWaits
            });
        },
        
        /**
         * Set up monitoring for network requests
         */
        setupNetworkMonitoring: function() {
            const self = this;
            
            // Track XMLHttpRequest
            const originalXhrOpen = XMLHttpRequest.prototype.open;
            const originalXhrSend = XMLHttpRequest.prototype.send;
            
            XMLHttpRequest.prototype.open = function() {
                return originalXhrOpen.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function() {
                self.state.activeRequests++;
                
                this.addEventListener('load', function() {
                    self.state.activeRequests--;
                });
                
                this.addEventListener('error', function() {
                    self.state.activeRequests--;
                });
                
                this.addEventListener('abort', function() {
                    self.state.activeRequests--;
                });
                
                return originalXhrSend.apply(this, arguments);
            };
            
            // Track fetch
            const originalFetch = window.fetch;
            
            window.fetch = function() {
                self.state.activeRequests++;
                
                return originalFetch.apply(this, arguments)
                    .then(response => {
                        self.state.activeRequests--;
                        return response;
                    })
                    .catch(error => {
                        self.state.activeRequests--;
                        throw error;
                    });
            };
            
            // Store the original methods for cleanup
            this._originalXhrOpen = originalXhrOpen;
            this._originalXhrSend = originalXhrSend;
            this._originalFetch = originalFetch;
        },
        
        /**
         * Clean up network request monitoring
         */
        cleanupNetworkMonitoring: function() {
            // Restore original methods
            if (this._originalXhrOpen) {
                XMLHttpRequest.prototype.open = this._originalXhrOpen;
            }
            
            if (this._originalXhrSend) {
                XMLHttpRequest.prototype.send = this._originalXhrSend;
            }
            
            if (this._originalFetch) {
                window.fetch = this._originalFetch;
            }
        },
        
        /**
         * Find all visible spinners in the document
         * @returns {Array} Array of spinner elements
         */
        findVisibleSpinners: function() {
            const spinners = [];
            
            // Check elements matching spinner selectors
            for (const selector of this.config.spinnerSelectors) {
                try {
                    const elements = document.querySelectorAll(selector);
                    
                    for (const element of elements) {
                        if (this.isElementVisible(element)) {
                            spinners.push(element);
                        }
                    }
                } catch (e) {
                    // Invalid selector, skip
                }
            }
            
            // Check for elements with loading-related class names or IDs
            for (const keyword of this.config.loadingKeywords) {
                const classSelector = `[class*="${keyword}"]`;
                const idSelector = `[id*="${keyword}"]`;
                
                try {
                    const classBased = document.querySelectorAll(classSelector);
                    const idBased = document.querySelectorAll(idSelector);
                    
                    for (const element of classBased) {
                        if (this.isElementVisible(element) && !spinners.includes(element)) {
                            spinners.push(element);
                        }
                    }
                    
                    for (const element of idBased) {
                        if (this.isElementVisible(element) && !spinners.includes(element)) {
                            spinners.push(element);
                        }
                    }
                } catch (e) {
                    // Skip invalid selectors
                }
            }
            
            // Look for rotating or pulsing elements
            const allElements = document.querySelectorAll('*');
            
            for (const element of allElements) {
                if (spinners.includes(element)) {
                    continue;
                }
                
                const style = window.getComputedStyle(element);
                
                // Check for rotation or animation
                if (style.animation && style.animation !== 'none' && 
                    (style.animation.includes('spin') || 
                     style.animation.includes('rotate') || 
                     style.animation.includes('pulse'))) {
                    
                    if (this.isElementVisible(element)) {
                        spinners.push(element);
                    }
                }
                
                // Check for rotating transforms
                if (style.transform && style.transform.includes('rotate')) {
                    if (this.isElementVisible(element)) {
                        spinners.push(element);
                    }
                }
            }
            
            return spinners;
        },
        
        /**
         * Find all progress bars in the document
         * @returns {Array} Array of progress bar elements
         */
        findProgressBars: function() {
            const progressBars = [];
            
            // Check for HTML5 progress elements
            const progressElements = document.querySelectorAll('progress');
            for (const element of progressElements) {
                if (this.isElementVisible(element)) {
                    progressBars.push(element);
                }
            }
            
            // Check for elements with aria-valuemin, aria-valuemax, and aria-valuenow attributes
            const ariaProgressBars = document.querySelectorAll('[aria-valuemin][aria-valuemax][aria-valuenow]');
            for (const element of ariaProgressBars) {
                if (this.isElementVisible(element)) {
                    progressBars.push(element);
                }
            }
            
            // Check for elements with progress-related class names
            const progressClasses = [
                '.progress-bar', '.progressbar', '.progress', 
                '[class*="progress"]', '[class*="loader"]'
            ];
            
            for (const selector of progressClasses) {
                try {
                    const elements = document.querySelectorAll(selector);
                    
                    for (const element of elements) {
                        if (this.isElementVisible(element) && !progressBars.includes(element)) {
                            progressBars.push(element);
                        }
                    }
                } catch (e) {
                    // Skip invalid selectors
                }
            }
            
            return progressBars;
        },
        
        /**
         * Find elements with active animations
         * @returns {Array} Array of animated elements
         */
        findAnimatedElements: function() {
            const animatedElements = [];
            
            // Check a reasonable number of elements (not the entire document)
            const elementsToCheck = document.querySelectorAll('div, span, img, button, a');
            
            for (const element of elementsToCheck) {
                if (!this.isElementVisible(element)) {
                    continue;
                }
                
                const style = window.getComputedStyle(element);
                
                // Check animation properties
                for (const prop of this.config.animationProperties) {
                    const value = style[prop];
                    
                    if (value && value !== 'none' && value !== '0s') {
                        animatedElements.push(element);
                        break;
                    }
                }
            }
            
            return animatedElements;
        },
        
        /**
         * Check if an element is visible
         * @param {Element} element - The element to check
         * @returns {boolean} Whether the element is visible
         */
        isElementVisible: function(element) {
            if (!element) {
                return false;
            }
            
            const style = window.getComputedStyle(element);
            
            // Check visibility properties
            if (style.display === 'none' || 
                style.visibility === 'hidden' || 
                style.opacity === '0') {
                return false;
            }
            
            // Check dimensions
            const rect = element.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                return false;
            }
            
            // Check if element is in viewport
            const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            
            if (rect.right < 0 || rect.bottom < 0 || 
                rect.left > viewportWidth || rect.top > viewportHeight) {
                return false;
            }
            
            return true;
        },
        
        /**
         * Get a fingerprint of the current DOM state for change detection
         * @returns {string} A string representing the current DOM state
         */
        getDomFingerprint: function() {
            // Get a subset of the DOM to avoid performance issues
            const keyElements = document.querySelectorAll('h1, h2, h3, .content, main, #main, [role="main"], button, input, select');
            
            let fingerprint = '';
            
            for (const element of keyElements) {
                // Get text content and attribute values
                fingerprint += element.tagName;
                fingerprint += element.id || '';
                fingerprint += element.className || '';
                fingerprint += element.textContent ? element.textContent.trim().substring(0, 50) : '';
                
                // Get position information
                const rect = element.getBoundingClientRect();
                fingerprint += `${Math.round(rect.top)},${Math.round(rect.left)},${Math.round(rect.width)},${Math.round(rect.height)}`;
            }
            
            return fingerprint;
        }
    };
    
    /**
     * Primary initialization
     */
    CSEventCapture.init();
    
    // Make the event capture available for testing or manual access
    window.__CSTestForge = {
        capture: CSEventCapture,
        channel: CSChannel,
        utils: CSUtils,
        elementRecognizer: CSElementRecognizer,
        waitDetector: CSWaitDetector
    };
})();


dom-observer.js
-----------------------------------

/**
 * dom-observer.js
 * Part of CSTestForge Browser Integration Module
 * 
 * This script is responsible for observing DOM changes during recording
 * and identifying meaningful structure changes, content updates, and
 * dynamic element creation/removal events that should be captured
 * for test automation purposes.
 * 
 * It uses the MutationObserver API to track changes efficiently with
 * sophisticated filtering to reduce noise and capture semantically
 * important mutations.
 */

(function() {
    'use strict';
    
    // Configuration options for the DOM observer
    const CONFIG = {
        // Whether the observer is active
        enabled: true,
        
        // Capture addition of elements
        captureAddedNodes: true,
        
        // Capture removal of elements
        captureRemovedNodes: true,
        
        // Capture attribute changes
        captureAttributes: true,
        
        // Capture text content changes
        captureCharacterData: true,
        
        // Throttle how often we process mutations (ms)
        throttleInterval: 100,
        
        // Maximum batch size for mutations
        maxBatchSize: 50,
        
        // Whether to capture inline style changes
        captureStyleChanges: true,
        
        // Whether to capture class changes
        captureClassChanges: true,
        
        // Key attributes to always track when changed
        keyAttributes: [
            'id', 'class', 'name', 'value', 'checked', 'selected', 'disabled',
            'aria-expanded', 'aria-hidden', 'aria-selected', 'aria-checked',
            'data-state', 'data-open', 'data-closed', 'data-visible', 'data-hidden',
            'href', 'src', 'alt', 'title', 'placeholder', 'type'
        ],
        
        // Additional data attributes to track when changed
        dataAttributes: [
            'data-testid', 'data-id', 'data-qa', 'data-test', 'data-cy',
            'data-automation', 'data-target', 'data-toggle'
        ],
        
        // Attribute changes to ignore (partial matches)
        ignoreAttributePatterns: [
            'data-lastpass', 'data-gramm', 'autocomplete', 'spellcheck',
            'aria-owns', 'aria-activedescendant', 'aria-describedby',
            'data-reactid', 'data-react', 'data-v-', 'vue-'
        ],
        
        // Element tags to ignore when tracking added/removed nodes
        ignoreElementTags: [
            'SCRIPT', 'STYLE', 'NOSCRIPT', 'META', 'LINK', 'PATH', 'G', 'SVG', 'DEFS',
            'RECT', 'CIRCLE', 'LINE', 'POLYGON', 'POLYLINE', 'ELLIPSE', 'STOP', 'MASK'
        ],
        
        // Class name patterns to ignore (partial matches)
        ignoreClassPatterns: [
            'highlight', 'active', 'hover', 'focus', 'blur', 'selected', 'visited',
            'animated', 'fade', 'appear', 'transitioning', 'loading'
        ],
        
        // ID patterns to ignore (partial matches)
        ignoreIdPatterns: [
            'gm-', 'yui_', 'selected-', 'hovered-', 'temp-', 'unique-', 'react-'
        ],
        
        // Whether to include the target's siblings in context
        includeSiblingContext: true,
        
        // Whether to include the target's parent context
        includeParentContext: true,
        
        // Function to post messages to the parent application
        postMessage: function(message) {
            try {
                window.parent.postMessage({
                    type: 'CSTestForge_DOMObserve',
                    data: message,
                    frameId: CSDOMObserver.frameId,
                    url: window.location.href
                }, '*');
            } catch (e) {
                console.error('CSTestForge DOM Observer: Error sending message', e);
            }
        },
        
        // Maximum size in bytes of context capture
        maxContextSize: 10000,
        
        // Whether to attach observer to Shadow DOM roots
        observeShadowRoots: true,
        
        // Whether to track dynamic CSS style sheet changes
        trackStyleSheetChanges: true
    };
    
    // Track Shadow DOM observers separately
    const shadowRootObservers = new Map();
    
    // Track which nodes have shadow roots
    const nodesWithShadowRoots = new Set();
    
    // Store state for throttling
    let throttleTimeout = null;
    let pendingMutations = [];
    
    // Unique ID for this frame
    let frameId = 'csframe_' + Math.random().toString(36).substring(2, 15);
    
    /**
     * DOM Observer Implementation
     */
    const CSDOMObserver = {
        // Main observer instance
        observer: null,
        
        // Frame ID for messaging
        frameId: frameId,
        
        // Observer state
        initialized: false,
        paused: false,
        connected: false,
        
        // Storage for statistics
        stats: {
            mutationsProcessed: 0,
            addedNodes: 0,
            removedNodes: 0,
            attributeChanges: 0,
            characterDataChanges: 0,
            eventsFired: 0,
            shadowRootsObserved: 0,
            styleSheetChanges: 0
        },
        
        /**
         * Initialize the DOM observer
         */
        init: function() {
            if (this.initialized) {
                return;
            }
            
            // Create mutation observer
            this.observer = new MutationObserver(this.handleMutations.bind(this));
            
            // Connect the observer
            this.connect();
            
            // Listen for control messages
            window.addEventListener('message', this.handleMessage.bind(this));
            
            // Observe shadow roots for existing elements
            if (CONFIG.observeShadowRoots) {
                this.observeExistingShadowRoots();
            }
            
            // Track style sheet changes if enabled
            if (CONFIG.trackStyleSheetChanges) {
                this.trackStyleSheets();
            }
            
            this.initialized = true;
            console.log('CSTestForge DOM Observer: Initialized');
            
            // Send initialization event
            CONFIG.postMessage({
                type: 'init',
                url: window.location.href,
                title: document.title,
                timestamp: Date.now()
            });
        },
        
        /**
         * Connect the observer to the document
         */
        connect: function() {
            if (this.connected || this.paused) {
                return;
            }
            
            // Observe everything with subtree option for entire document
            this.observer.observe(document, {
                childList: CONFIG.captureAddedNodes || CONFIG.captureRemovedNodes,
                attributes: CONFIG.captureAttributes,
                characterData: CONFIG.captureCharacterData,
                subtree: true,
                attributeOldValue: true,
                characterDataOldValue: true
            });
            
            this.connected = true;
            console.log('CSTestForge DOM Observer: Connected');
        },
        
        /**
         * Disconnect the observer
         */
        disconnect: function() {
            if (!this.connected) {
                return;
            }
            
            this.observer.disconnect();
            this.connected = false;
            
            // Disconnect all shadow root observers
            for (const observer of shadowRootObservers.values()) {
                observer.disconnect();
            }
            
            // Clear any pending throttled operations
            if (throttleTimeout) {
                clearTimeout(throttleTimeout);
                throttleTimeout = null;
            }
            
            console.log('CSTestForge DOM Observer: Disconnected');
        },
        
        /**
         * Pause the observer
         */
        pause: function() {
            if (this.paused) {
                return;
            }
            
            this.disconnect();
            this.paused = true;
            
            console.log('CSTestForge DOM Observer: Paused');
            
            // Send pause event
            CONFIG.postMessage({
                type: 'status',
                status: 'paused',
                timestamp: Date.now()
            });
        },
        
        /**
         * Resume the observer
         */
        resume: function() {
            if (!this.paused) {
                return;
            }
            
            this.paused = false;
            this.connect();
            
            console.log('CSTestForge DOM Observer: Resumed');
            
            // Send resume event
            CONFIG.postMessage({
                type: 'status',
                status: 'resumed',
                timestamp: Date.now()
            });
        },
        
        /**
         * Handle incoming control messages
         * @param {MessageEvent} event - The message event
         */
        handleMessage: function(event) {
            if (!event.data || event.data.type !== 'CSTestForge_DOMObserveCommand') {
                return;
            }
            
            const command = event.data.command;
            
            switch (command) {
                case 'pause':
                    this.pause();
                    break;
                    
                case 'resume':
                    this.resume();
                    break;
                    
                case 'getStats':
                    this.sendStats();
                    break;
                    
                case 'updateConfig':
                    this.updateConfig(event.data.config);
                    break;
                    
                case 'highlightElement':
                    this.highlightElement(event.data.selector);
                    break;
                    
                default:
                    console.warn('CSTestForge DOM Observer: Unknown command', command);
            }
        },
        
        /**
         * Handle mutations batched from the observer
         * @param {MutationRecord[]} mutations - The array of mutations
         */
        handleMutations: function(mutations) {
            if (this.paused || !CONFIG.enabled || mutations.length === 0) {
                return;
            }
            
            // Add to pending mutations
            pendingMutations = pendingMutations.concat(mutations);
            
            // Apply throttling
            if (throttleTimeout) {
                return;
            }
            
            throttleTimeout = setTimeout(() => {
                // Process mutations in reasonable batches
                this.processMutationBatches(pendingMutations);
                pendingMutations = [];
                throttleTimeout = null;
            }, CONFIG.throttleInterval);
        },
        
        /**
         * Process mutations in manageable batches
         * @param {MutationRecord[]} mutations - The array of all mutations
         */
        processMutationBatches: function(mutations) {
            const totalMutations = mutations.length;
            
            // Process in batches to avoid blocking the main thread for too long
            for (let i = 0; i < totalMutations; i += CONFIG.maxBatchSize) {
                const batch = mutations.slice(i, i + CONFIG.maxBatchSize);
                this.processMutationBatch(batch);
            }
        },
        
        /**
         * Process a batch of mutations
         * @param {MutationRecord[]} mutations - The batch of mutations to process
         */
        processMutationBatch: function(mutations) {
            if (mutations.length === 0) {
                return;
            }
            
            // Group mutations by target for more efficient processing
            const mutationsByTarget = this.groupMutationsByTarget(mutations);
            
            // Process grouped mutations
            this.processGroupedMutations(mutationsByTarget);
            
            // Update stats
            this.stats.mutationsProcessed += mutations.length;
        },
        
        /**
         * Group mutations by their target elements
         * @param {MutationRecord[]} mutations - The array of mutations
         * @returns {Object} Mutations grouped by target
         */
        groupMutationsByTarget: function(mutations) {
            const mutationsByTarget = new Map();
            
            for (const mutation of mutations) {
                // Skip mutations we're not interested in based on config
                if (this.shouldIgnoreMutation(mutation)) {
                    continue;
                }
                
                const target = mutation.target;
                const targetKey = this.getTargetKey(target);
                
                if (!mutationsByTarget.has(targetKey)) {
                    mutationsByTarget.set(targetKey, {
                        target: target,
                        childList: [],
                        attributes: [],
                        characterData: []
                    });
                }
                
                const targetMutations = mutationsByTarget.get(targetKey);
                
                switch (mutation.type) {
                    case 'childList':
                        targetMutations.childList.push(mutation);
                        break;
                        
                    case 'attributes':
                        targetMutations.attributes.push(mutation);
                        break;
                        
                    case 'characterData':
                        targetMutations.characterData.push(mutation);
                        break;
                }
            }
            
            return mutationsByTarget;
        },
        
        /**
         * Process mutations that have been grouped by target
         * @param {Map} mutationsByTarget - Mutations grouped by target
         */
        processGroupedMutations: function(mutationsByTarget) {
            // Process each target's mutations
            for (const [targetKey, targetMutations] of mutationsByTarget.entries()) {
                const target = targetMutations.target;
                
                // Skip if target is no longer in the document
                if (!this.isNodeInDocument(target)) {
                    continue;
                }
                
                // Process child list mutations first, as they can affect the DOM structure
                if (targetMutations.childList.length > 0) {
                    this.processChildListMutations(target, targetMutations.childList);
                }
                
                // Process attribute mutations
                if (targetMutations.attributes.length > 0) {
                    this.processAttributeMutations(target, targetMutations.attributes);
                }
                
                // Process character data mutations
                if (targetMutations.characterData.length > 0) {
                    this.processCharacterDataMutations(target, targetMutations.characterData);
                }
                
                // Check for new shadow roots after DOM changes
                if (CONFIG.observeShadowRoots && 
                    (targetMutations.childList.length > 0 || targetMutations.attributes.length > 0)) {
                    this.checkForShadowRoot(target);
                }
            }
        },
        
        /**
         * Process mutations that affect child nodes
         * @param {Node} target - The target node
         * @param {MutationRecord[]} mutations - The childList mutations
         */
        processChildListMutations: function(target, mutations) {
            // Track added and removed nodes across all mutations for this target
            const addedNodes = new Set();
            const removedNodes = new Set();
            
            // Collect all added and removed nodes
            for (const mutation of mutations) {
                if (mutation.addedNodes.length > 0) {
                    for (const node of mutation.addedNodes) {
                        // Skip text nodes and nodes that were subsequently removed
                        if (this.shouldTrackNode(node) && !removedNodes.has(node)) {
                            addedNodes.add(node);
                        }
                        
                        // If it was removed and then re-added, remove it from the removed set
                        if (removedNodes.has(node)) {
                            removedNodes.delete(node);
                        }
                    }
                }
                
                if (mutation.removedNodes.length > 0) {
                    for (const node of mutation.removedNodes) {
                        // Skip text nodes and nodes that were added after being removed
                        if (this.shouldTrackNode(node) && !addedNodes.has(node)) {
                            removedNodes.add(node);
                        }
                        
                        // If it was added and then removed, remove it from the added set
                        if (addedNodes.has(node)) {
                            addedNodes.delete(node);
                        }
                    }
                }
            }
            
            // Process final added nodes
            if (addedNodes.size > 0 && CONFIG.captureAddedNodes) {
                const addedElements = [];
                
                for (const node of addedNodes) {
                    // We only care about element nodes
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const elementInfo = this.getElementInfo(node);
                        
                        if (elementInfo) {
                            addedElements.push(elementInfo);
                            
                            // Check if we should observe a Shadow DOM for this element
                            if (CONFIG.observeShadowRoots) {
                                this.checkForShadowRoot(node);
                            }
                        }
                    }
                }
                
                if (addedElements.length > 0) {
                    this.stats.addedNodes += addedElements.length;
                    
                    // Report added nodes event
                    CONFIG.postMessage({
                        type: 'nodesAdded',
                        target: this.getElementInfo(target),
                        elements: addedElements,
                        timestamp: Date.now()
                    });
                }
            }
            
            // Process final removed nodes
            if (removedNodes.size > 0 && CONFIG.captureRemovedNodes) {
                const removedElements = [];
                
                for (const node of removedNodes) {
                    // We only care about element nodes
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        // We have limited access to removed nodes, just capture basic info
                        removedElements.push({
                            tagName: node.tagName,
                            id: node.id,
                            className: node.className,
                            textContent: node.textContent ? node.textContent.substring(0, 100) : ''
                        });
                        
                        // Unregister any shadow root observers for this node
                        if (nodesWithShadowRoots.has(node)) {
                            this.unregisterShadowRootObserver(node);
                        }
                    }
                }
                
                if (removedElements.length > 0) {
                    this.stats.removedNodes += removedElements.length;
                    
                    // Report removed nodes event
                    CONFIG.postMessage({
                        type: 'nodesRemoved',
                        target: this.getElementInfo(target),
                        elements: removedElements,
                        timestamp: Date.now()
                    });
                }
            }
        },
        
        /**
         * Process mutations that affect attributes
         * @param {Node} target - The target node
         * @param {MutationRecord[]} mutations - The attribute mutations
         */
        processAttributeMutations: function(target, mutations) {
            if (!CONFIG.captureAttributes) {
                return;
            }
            
            // Group changes by attribute name
            const attributeChanges = {};
            
            for (const mutation of mutations) {
                const attributeName = mutation.attributeName;
                const oldValue = mutation.oldValue;
                const newValue = target.getAttribute(attributeName);
                
                // Skip if we should ignore this attribute
                if (this.shouldIgnoreAttribute(attributeName, oldValue, newValue)) {
                    continue;
                }
                
                // Only track the latest change for each attribute
                attributeChanges[attributeName] = {
                    oldValue: oldValue,
                    newValue: newValue
                };
            }
            
            const attributeNames = Object.keys(attributeChanges);
            
            if (attributeNames.length > 0) {
                this.stats.attributeChanges += attributeNames.length;
                
                // Report attribute changes event
                CONFIG.postMessage({
                    type: 'attributesChanged',
                    target: this.getElementInfo(target),
                    changes: attributeChanges,
                    timestamp: Date.now()
                });
                
                // Special handling for certain attribute changes
                this.handleSpecialAttributeChanges(target, attributeChanges);
            }
        },
        
        /**
         * Process mutations that affect text content
         * @param {Node} target - The target node
         * @param {MutationRecord[]} mutations - The characterData mutations
         */
        processCharacterDataMutations: function(target, mutations) {
            if (!CONFIG.captureCharacterData) {
                return;
            }
            
            // We only care about the latest text change
            const lastMutation = mutations[mutations.length - 1];
            const oldValue = lastMutation.oldValue;
            
            // Get the new text value - different approach based on node type
            let newValue = '';
            
            if (target.nodeType === Node.TEXT_NODE) {
                newValue = target.textContent;
            } else if (target.nodeType === Node.ELEMENT_NODE) {
                newValue = target.textContent;
            } else {
                newValue = String(target.nodeValue);
            }
            
            // Skip if the content hasn't actually changed or is not meaningful
            if (oldValue === newValue || 
                (oldValue && newValue && 
                 oldValue.trim() === newValue.trim() && 
                 oldValue.length < 2)) {
                return;
            }
            
            // For text nodes, get the parent element for better context
            const contextNode = target.nodeType === Node.TEXT_NODE ? target.parentElement : target;
            
            if (!contextNode) {
                return;
            }
            
            this.stats.characterDataChanges++;
            
            // Report text content change event
            CONFIG.postMessage({
                type: 'textChanged',
                target: this.getElementInfo(contextNode),
                oldText: oldValue ? oldValue.substring(0, 1000) : '',
                newText: newValue ? newValue.substring(0, 1000) : '',
                timestamp: Date.now()
            });
        },
        
        /**
         * Handle special attribute changes with semantic meaning
         * @param {Element} target - The target element
         * @param {Object} attributeChanges - The attribute changes
         */
        handleSpecialAttributeChanges: function(target, attributeChanges) {
            // Handle class changes - track added and removed classes
            if (attributeChanges.hasOwnProperty('class')) {
                const change = attributeChanges['class'];
                const oldClasses = change.oldValue ? change.oldValue.trim().split(/\s+/) : [];
                const newClasses = change.newValue ? change.newValue.trim().split(/\s+/) : [];
                
                const addedClasses = newClasses.filter(cls => !oldClasses.includes(cls));
                const removedClasses = oldClasses.filter(cls => !newClasses.includes(cls));
                
                // Filter out classes we should ignore
                const filteredAddedClasses = addedClasses.filter(cls => !this.shouldIgnoreClass(cls));
                const filteredRemovedClasses = removedClasses.filter(cls => !this.shouldIgnoreClass(cls));
                
                if (filteredAddedClasses.length > 0 || filteredRemovedClasses.length > 0) {
                    CONFIG.postMessage({
                        type: 'classChanged',
                        target: this.getElementInfo(target),
                        addedClasses: filteredAddedClasses,
                        removedClasses: filteredRemovedClasses,
                        timestamp: Date.now()
                    });
                }
            }
            
            // Handle style attribute changes
            if (attributeChanges.hasOwnProperty('style') && CONFIG.captureStyleChanges) {
                const change = attributeChanges['style'];
                
                // Parse style strings into properties
                const oldStyles = this.parseStyleAttribute(change.oldValue);
                const newStyles = this.parseStyleAttribute(change.newValue);
                
                // Compute changes
                const styleChanges = {};
                
                // Added, modified or removed properties
                // Find added or modified properties
                for (const prop in newStyles) {
                    if (!oldStyles.hasOwnProperty(prop) || oldStyles[prop] !== newStyles[prop]) {
                        styleChanges[prop] = {
                            oldValue: oldStyles[prop] || null,
                            newValue: newStyles[prop]
                        };
                    }
                }
                
                // Find removed properties
                for (const prop in oldStyles) {
                    if (!newStyles.hasOwnProperty(prop)) {
                        styleChanges[prop] = {
                            oldValue: oldStyles[prop],
                            newValue: null
                        };
                    }
                }
                
                // If there are any meaningful style changes, report them
                if (Object.keys(styleChanges).length > 0) {
                    CONFIG.postMessage({
                        type: 'styleChanged',
                        target: this.getElementInfo(target),
                        changes: styleChanges,
                        timestamp: Date.now()
                    });
                }
            }
            
            // Handle states like checkbox/radio checked, select selected, etc.
            if (target.tagName === 'INPUT' && 
                (target.type === 'checkbox' || target.type === 'radio') &&
                attributeChanges.hasOwnProperty('checked')) {
                
                CONFIG.postMessage({
                    type: 'stateChanged',
                    target: this.getElementInfo(target),
                    state: 'checked',
                    oldValue: attributeChanges['checked'].oldValue !== null,
                    newValue: attributeChanges['checked'].newValue !== null,
                    timestamp: Date.now()
                });
            }
            
            // Handle disabled state changes
            if (attributeChanges.hasOwnProperty('disabled')) {
                CONFIG.postMessage({
                    type: 'stateChanged',
                    target: this.getElementInfo(target),
                    state: 'disabled',
                    oldValue: attributeChanges['disabled'].oldValue !== null,
                    newValue: attributeChanges['disabled'].newValue !== null,
                    timestamp: Date.now()
                });
            }
            
            // Handle ARIA state changes
            const ariaStateAttributes = ['aria-expanded', 'aria-hidden', 'aria-selected', 'aria-checked'];
            
            for (const ariaAttr of ariaStateAttributes) {
                if (attributeChanges.hasOwnProperty(ariaAttr)) {
                    const stateName = ariaAttr.replace('aria-', '');
                    
                    CONFIG.postMessage({
                        type: 'ariaStateChanged',
                        target: this.getElementInfo(target),
                        state: stateName,
                        oldValue: attributeChanges[ariaAttr].oldValue,
                        newValue: attributeChanges[ariaAttr].newValue,
                        timestamp: Date.now()
                    });
                }
            }
        },
        
        /**
         * Parse style attribute string into an object
         * @param {string} styleString - The style attribute string
         * @returns {Object} Object with style properties as keys
         */
        parseStyleAttribute: function(styleString) {
            const styles = {};
            
            if (!styleString) {
                return styles;
            }
            
            // Split the style string into property/value pairs
            const pairs = styleString.split(';');
            
            for (let i = 0; i < pairs.length; i++) {
                const pair = pairs[i].trim();
                
                if (!pair) {
                    continue;
                }
                
                const colonIndex = pair.indexOf(':');
                
                if (colonIndex === -1) {
                    continue;
                }
                
                const property = pair.substring(0, colonIndex).trim();
                const value = pair.substring(colonIndex + 1).trim();
                
                if (property && value) {
                    styles[property] = value;
                }
            }
            
            return styles;
        },
        
        /**
         * Generate a unique key for a target node
         * @param {Node} target - The target node
         * @returns {string} A unique key for the node
         */
        getTargetKey: function(target) {
            // For element nodes, use more identifying information
            if (target.nodeType === Node.ELEMENT_NODE) {
                return `${target.tagName}#${target.id || ''}${target.className ? '.' + target.className : ''}`;
            }
            
            // For text nodes, include part of the text and parent info
            if (target.nodeType === Node.TEXT_NODE && target.parentElement) {
                const text = target.textContent ? target.textContent.substring(0, 20) : '';
                return `TEXT:${target.parentElement.tagName}#${target.parentElement.id || ''}:${text}`;
            }
            
            // For other node types, use the node type and a counter
            return `NODE:${target.nodeType}:${Math.random().toString(36).substring(2, 8)}`;
        },
        
        /**
         * Check if a node should be tracked
         * @param {Node} node - The node to check
         * @returns {boolean} Whether the node should be tracked
         */
        shouldTrackNode: function(node) {
            // Skip non-element nodes except text nodes with meaningful content
            if (node.nodeType !== Node.ELEMENT_NODE) {
                if (node.nodeType === Node.TEXT_NODE && node.textContent && node.textContent.trim()) {
                    return true;
                }
                return false;
            }
            
            // Skip elements with tags we should ignore
            if (CONFIG.ignoreElementTags.includes(node.tagName)) {
                return false;
            }
            
            return true;
        },
        
        /**
         * Check if we should ignore an attribute change
         * @param {string} name - Attribute name
         * @param {string} oldValue - Old attribute value
         * @param {string} newValue - New attribute value
         * @returns {boolean} Whether to ignore the attribute change
         */
        shouldIgnoreAttribute: function(name, oldValue, newValue) {
            // Skip if attribute name matches ignore patterns
            for (const pattern of CONFIG.ignoreAttributePatterns) {
                if (name.indexOf(pattern) !== -1) {
                    return true;
                }
            }
            
            // Skip style changes if not capturing style changes
            if (name === 'style' && !CONFIG.captureStyleChanges) {
                return true;
            }
            
            // Skip class changes if not capturing class changes
            if (name === 'class' && !CONFIG.captureClassChanges) {
                return true;
            }
            
            // Skip if not a key attribute or data attribute we care about
            if (!CONFIG.keyAttributes.includes(name) && 
                !CONFIG.dataAttributes.some(attr => name.startsWith(attr))) {
                
                // Is it a normal attribute we should track?
                const isImportantAttribute = 
                    name === 'href' || 
                    name === 'src' || 
                    name === 'value' || 
                    name === 'checked' || 
                    name === 'selected' || 
                    name === 'disabled' || 
                    name.startsWith('aria-') || 
                    name.startsWith('data-');
                
                if (!isImportantAttribute) {
                    return true;
                }
            }
            
            // Values are the same (after normalization for empty/null)
            if ((oldValue === null || oldValue === '') && 
                (newValue === null || newValue === '')) {
                return true;
            }
            
            if (oldValue === newValue) {
                return true;
            }
            
            return false;
        },
        
        /**
         * Check if a class name should be ignored
         * @param {string} className - The class name
         * @returns {boolean} Whether to ignore the class
         */
        shouldIgnoreClass: function(className) {
            // Skip classes matching ignore patterns
            for (const pattern of CONFIG.ignoreClassPatterns) {
                if (className.indexOf(pattern) !== -1) {
                    return true;
                }
            }
            
            return false;
        },
        
        /**
         * Check if we should ignore a mutation entirely
         * @param {MutationRecord} mutation - The mutation record
         * @returns {boolean} Whether to ignore the mutation
         */
        shouldIgnoreMutation: function(mutation) {
            // Skip if the target is null
            if (!mutation.target) {
                return true;
            }
            
            // Skip attribute mutations if not capturing attributes
            if (mutation.type === 'attributes' && !CONFIG.captureAttributes) {
                return true;
            }
            
            // Skip child list mutations if not capturing added/removed nodes
            if (mutation.type === 'childList' && 
                !CONFIG.captureAddedNodes && !CONFIG.captureRemovedNodes) {
                return true;
            }
            
            // Skip character data mutations if not capturing them
            if (mutation.type === 'characterData' && !CONFIG.captureCharacterData) {
                return true;
            }
            
            // Skip attribute mutations for attributes we should ignore
            if (mutation.type === 'attributes') {
                const oldValue = mutation.oldValue;
                const newValue = mutation.target.getAttribute(mutation.attributeName);
                
                if (this.shouldIgnoreAttribute(mutation.attributeName, oldValue, newValue)) {
                    return true;
                }
            }
            
            return false;
        },
        
        /**
         * Check if a node is still in the document
         * @param {Node} node - The node to check
         * @returns {boolean} Whether the node is in the document
         */
        isNodeInDocument: function(node) {
            if (!node) {
                return false;
            }
            
            if (node.nodeType === Node.TEXT_NODE) {
                return node.parentNode && document.contains(node.parentNode);
            }
            
            return document.contains(node);
        },
        
        /**
         * Get information about an element
         * @param {Element} element - The element
         * @returns {Object} Object with element info
         */
        getElementInfo: function(element) {
            if (!element || element.nodeType !== Node.ELEMENT_NODE) {
                return null;
            }
            
            // Basic info all elements should have
            const info = {
                tagName: element.tagName,
                id: element.id || null,
                className: element.className || null
            };
            
            // Add CSS selector for identification
            try {
                info.selector = this.generateSelector(element);
            } catch (e) {
                info.selector = null;
            }
            
            // Add XPath for identification
            try {
                info.xpath = this.generateXPath(element);
            } catch (e) {
                info.xpath = null;
            }
            
            // Add rect information if the element is visible
            try {
                const rect = element.getBoundingClientRect();
                info.rect = {
                    top: rect.top,
                    left: rect.left,
                    width: rect.width,
                    height: rect.height,
                    bottom: rect.bottom,
                    right: rect.right
                };
                
                // Check if element is in viewport
                info.inViewport = (
                    rect.top < window.innerHeight &&
                    rect.left < window.innerWidth &&
                    rect.bottom > 0 &&
                    rect.right > 0
                );
            } catch (e) {
                info.rect = null;
                info.inViewport = false;
            }
            
            // Add element-specific attributes based on tag
            this.addElementSpecificInfo(element, info);
            
            // Add significant attributes
            const attributes = {};
            const attrs = element.attributes;
            
            if (attrs) {
                for (let i = 0; i < attrs.length; i++) {
                    const attr = attrs[i];
                    
                    // Only include attributes we care about
                    if (CONFIG.keyAttributes.includes(attr.name) || 
                        CONFIG.dataAttributes.some(dataAttr => attr.name.startsWith(dataAttr))) {
                        attributes[attr.name] = attr.value;
                    }
                }
            }
            
            info.attributes = attributes;
            
            // Add text content if it's not too long
            const text = element.textContent ? element.textContent.trim() : '';
            if (text && text.length <= 100) {
                info.text = text;
            } else if (text) {
                info.text = text.substring(0, 100) + '...';
            } else {
                info.text = null;
            }
            
            // Add parent context if configured
            if (CONFIG.includeParentContext && element.parentElement && 
                !this.isContextOverLimit(info)) {
                try {
                    const parent = element.parentElement;
                    info.parent = {
                        tagName: parent.tagName,
                        id: parent.id || null,
                        className: parent.className || null,
                        selector: this.generateSelector(parent)
                    };
                } catch (e) {
                    // Skip parent context if there's an error
                }
            }
            
            // Add sibling context if configured
            if (CONFIG.includeSiblingContext && element.parentElement && 
                !this.isContextOverLimit(info)) {
                try {
                    const siblings = Array.from(element.parentElement.children);
                    const elementIndex = siblings.indexOf(element);
                    
                    // Add 1-2 previous and next siblings
                    const previousSiblings = [];
                    const nextSiblings = [];
                    
                    // Previous siblings
                    for (let i = Math.max(0, elementIndex - 2); i < elementIndex; i++) {
                        const sibling = siblings[i];
                        previousSiblings.push({
                            tagName: sibling.tagName,
                            id: sibling.id || null,
                            className: sibling.className || null,
                            text: sibling.textContent ? sibling.textContent.substring(0, 50).trim() : null
                        });
                    }
                    
                    // Next siblings
                    for (let i = elementIndex + 1; i < Math.min(siblings.length, elementIndex + 3); i++) {
                        const sibling = siblings[i];
                        nextSiblings.push({
                            tagName: sibling.tagName,
                            id: sibling.id || null,
                            className: sibling.className || null,
                            text: sibling.textContent ? sibling.textContent.substring(0, 50).trim() : null
                        });
                    }
                    
                    if (previousSiblings.length > 0) {
                        info.previousSiblings = previousSiblings;
                    }
                    
                    if (nextSiblings.length > 0) {
                        info.nextSiblings = nextSiblings;
                    }
                } catch (e) {
                    // Skip sibling context if there's an error
                }
            }
            
            return info;
        },
        
        /**
         * Add element-specific information based on tag name
         * @param {Element} element - The element
         * @param {Object} info - The info object to add to
         */
        addElementSpecificInfo: function(element, info) {
            const tagName = element.tagName;
            
            switch (tagName) {
                case 'INPUT':
                    info.type = element.type || 'text';
                    info.name = element.name || null;
                    info.value = element.type === 'password' ? '********' : element.value;
                    
                    if (element.type === 'checkbox' || element.type === 'radio') {
                        info.checked = element.checked;
                    }
                    
                    if (element.placeholder) {
                        info.placeholder = element.placeholder;
                    }
                    break;
                    
                case 'TEXTAREA':
                    info.name = element.name || null;
                    info.value = element.value;
                    
                    if (element.placeholder) {
                        info.placeholder = element.placeholder;
                    }
                    break;
                    
                case 'SELECT':
                    info.name = element.name || null;
                    info.value = element.value;
                    info.multiple = element.multiple;
                    
                    // Get selected option text
                    if (element.selectedIndex !== -1) {
                        const selectedOption = element.options[element.selectedIndex];
                        if (selectedOption) {
                            info.selectedText = selectedOption.text;
                        }
                    }
                    
                    // Get all options if there aren't too many
                    if (element.options.length <= 10) {
                        info.options = [];
                        
                        for (let i = 0; i < element.options.length; i++) {
                            const option = element.options[i];
                            info.options.push({
                                value: option.value,
                                text: option.text,
                                selected: option.selected
                            });
                        }
                    } else {
                        info.optionCount = element.options.length;
                    }
                    break;
                    
                case 'BUTTON':
                    info.type = element.type || 'button';
                    info.name = element.name || null;
                    
                    // Include button text if available
                    const buttonText = element.textContent ? element.textContent.trim() : '';
                    if (buttonText) {
                        info.buttonText = buttonText;
                    }
                    break;
                    
                case 'A':
                    info.href = element.href || null;
                    info.target = element.target || null;
                    info.rel = element.rel || null;
                    
                    // Include link text if available
                    const linkText = element.textContent ? element.textContent.trim() : '';
                    if (linkText) {
                        info.linkText = linkText;
                    }
                    break;
                    
                case 'IMG':
                    info.src = element.src || null;
                    info.alt = element.alt || null;
                    info.width = element.width || null;
                    info.height = element.height || null;
                    break;
                    
                case 'FORM':
                    info.action = element.action || null;
                    info.method = element.method || null;
                    info.enctype = element.enctype || null;
                    break;
                    
                case 'TABLE':
                    info.rows = element.rows ? element.rows.length : 0;
                    info.cols = element.rows && element.rows.length > 0 ? element.rows[0].cells.length : 0;
                    break;
            }
        },
        
        /**
         * Generate a CSS selector for an element
         * @param {Element} element - The element
         * @returns {string} CSS selector
         */
        generateSelector: function(element) {
            if (!element || element === document) {
                return 'document';
            }
            
            if (element === document.documentElement) {
                return 'html';
            }
            
            if (element === document.body) {
                return 'body';
            }
            
            // Try ID selector if the element has an ID
            if (element.id) {
                return `#${CSS.escape(element.id)}`;
            }
            
            // Try data attribute selectors
            for (const attr of CONFIG.dataAttributes) {
                if (element.hasAttribute(attr)) {
                    return `[${attr}="${CSS.escape(element.getAttribute(attr))}"]`;
                }
            }
            
            // Try with tag name and classes
            if (element.className) {
                const classes = element.className.trim().split(/\s+/);
                
                // Filter out common utility classes that might change
                const significantClasses = classes.filter(cls => !this.shouldIgnoreClass(cls));
                
                if (significantClasses.length > 0) {
                    const classSelector = significantClasses.map(cls => `.${CSS.escape(cls)}`).join('');
                    const tagWithClassSelector = `${element.tagName.toLowerCase()}${classSelector}`;
                    
                    // Check if this selector is unique
                    if (document.querySelectorAll(tagWithClassSelector).length === 1) {
                        return tagWithClassSelector;
                    }
                }
            }
            
            // If we get here, we need to generate a path
            let current = element;
            let path = [];
            
            while (current && current !== document.body && current !== document.documentElement) {
                let selector;
                
                // Try ID
                if (current.id) {
                    path.unshift(`#${CSS.escape(current.id)}`);
                    break;
                }
                
                // Try with tag name and nth-child
                const parent = current.parentElement;
                
                if (parent) {
                    const siblings = Array.from(parent.children);
                    const index = siblings.indexOf(current) + 1;
                    const tagName = current.tagName.toLowerCase();
                    
                    if (siblings.filter(el => el.tagName === current.tagName).length === 1) {
                        // Only one of this tag type among siblings
                        selector = tagName;
                    } else {
                        // Use nth-child
                        selector = `${tagName}:nth-child(${index})`;
                    }
                    
                    path.unshift(selector);
                } else {
                    path.unshift(current.tagName.toLowerCase());
                }
                
                current = parent;
            }
            
            return path.join(' > ');
        },
        
        /**
         * Generate an XPath for an element
         * @param {Element} element - The element
         * @returns {string} XPath expression
         */
        generateXPath: function(element) {
            if (!element) {
                return '';
            }
            
            if (element === document) {
                return '/';
            }
            
            if (element === document.documentElement) {
                return '/html';
            }
            
            if (element === document.body) {
                return '/html/body';
            }
            
            // Try to get a simple XPath with id
            if (element.id) {
                return `//*[@id="${element.id}"]`;
            }
            
            // Generate full path
            let path = '';
            let current = element;
            
            while (current && current.nodeType === Node.ELEMENT_NODE) {
                let currentPath = current.tagName.toLowerCase();
                
                // Add predicates for better identification
                if (current.id) {
                    currentPath += `[@id="${current.id}"]`;
                } else {
                    // Get position among siblings of same type
                    let siblingsOfSameType = 0;
                    let position = 0;
                    
                    for (let i = 0; i < current.parentNode.childNodes.length; i++) {
                        const sibling = current.parentNode.childNodes[i];
                        if (sibling.nodeType === Node.ELEMENT_NODE && 
                            sibling.tagName === current.tagName) {
                            siblingsOfSameType++;
                            if (sibling === current) {
                                position = siblingsOfSameType;
                            }
                        }
                    }
                    
                    if (siblingsOfSameType > 1) {
                        currentPath += `[${position}]`;
                    }
                }
                
                path = currentPath + (path ? '/' + path : '');
                current = current.parentNode;
                
                if (current === document.body) {
                    path = '/html/body/' + path;
                    break;
                }
                
                if (current === document.documentElement) {
                    path = '/html/' + path;
                    break;
                }
            }
            
            return '/' + path;
        },
        
        /**
         * Check if the context size exceeds the limit
         * @param {Object} context - The context object
         * @returns {boolean} Whether the size exceeds the limit
         */
        isContextOverLimit: function(context) {
            // Rough estimation of object size by converting to JSON
            const contextString = JSON.stringify(context);
            return contextString.length > CONFIG.maxContextSize;
        },
        
        /**
         * Observe any shadow DOM roots that already exist in the document
         */
        observeExistingShadowRoots: function() {
            // Check for elements that might have shadow roots
            const potentialShadowHosts = document.querySelectorAll('*');
            
            for (const element of potentialShadowHosts) {
                this.checkForShadowRoot(element);
            }
        },
        
        /**
         * Check if an element has a shadow root and observe it if it does
         * @param {Element} element - The element to check
         */
        checkForShadowRoot: function(element) {
            // Skip if already tracking this element's shadow root
            if (nodesWithShadowRoots.has(element)) {
                return;
            }
            
            // Check if the element has a shadow root
            if (element.shadowRoot) {
                this.observeShadowRoot(element);
            }
        },
        
        /**
         * Observe a shadow root for mutations
         * @param {Element} host - The shadow root host element
         */
        observeShadowRoot: function(host) {
            if (!host || !host.shadowRoot) {
                return;
            }
            
            // Skip if already observing this shadow root
            if (shadowRootObservers.has(host.shadowRoot)) {
                return;
            }
            
            // Create a new observer for the shadow root
            const shadowObserver = new MutationObserver(mutations => {
                this.handleShadowMutations(host, mutations);
            });
            
            // Observe the shadow root
            shadowObserver.observe(host.shadowRoot, {
                childList: CONFIG.captureAddedNodes || CONFIG.captureRemovedNodes,
                attributes: CONFIG.captureAttributes,
                characterData: CONFIG.captureCharacterData,
                subtree: true,
                attributeOldValue: true,
                characterDataOldValue: true
            });
            
            // Register the observer and host
            shadowRootObservers.set(host.shadowRoot, shadowObserver);
            nodesWithShadowRoots.add(host);
            
            this.stats.shadowRootsObserved++;
            
            // Report shadow root observed
            CONFIG.postMessage({
                type: 'shadowRootObserved',
                host: this.getElementInfo(host),
                timestamp: Date.now()
            });
            
            // Check for nested shadow roots
            const shadowElements = host.shadowRoot.querySelectorAll('*');
            for (const element of shadowElements) {
                this.checkForShadowRoot(element);
            }
        },
        
        /**
         * Unregister and disconnect a shadow root observer
         * @param {Element} host - The shadow root host element
         */
        unregisterShadowRootObserver: function(host) {
            if (!host || !nodesWithShadowRoots.has(host)) {
                return;
            }
            
            // Get the shadow root and its observer
            const shadowRoot = host.shadowRoot;
            
            if (shadowRoot && shadowRootObservers.has(shadowRoot)) {
                const observer = shadowRootObservers.get(shadowRoot);
                
                // Disconnect the observer
                observer.disconnect();
                
                // Remove from the maps
                shadowRootObservers.delete(shadowRoot);
            }
            
            nodesWithShadowRoots.delete(host);
        },
        
        /**
         * Handle mutations from a shadow DOM
         * @param {Element} host - The shadow root host element
         * @param {MutationRecord[]} mutations - The mutation records
         */
        handleShadowMutations: function(host, mutations) {
            if (this.paused || !CONFIG.enabled || mutations.length === 0) {
                return;
            }
            
            // Process the mutations like normal, but add shadow root context
            const hostInfo = this.getElementInfo(host);
            
            // Group mutations by target
            const mutationsByTarget = this.groupMutationsByTarget(mutations);
            
            // Process grouped mutations
            for (const [targetKey, targetMutations] of mutationsByTarget.entries()) {
                const target = targetMutations.target;
                
                // Add the shadow root mutations
                const shadowMutations = {
                    host: hostInfo,
                    target: target,
                    shadowRoot: true
                };
                
                // Process child list mutations
                if (targetMutations.childList.length > 0) {
                    this.processShadowChildListMutations(shadowMutations, target, targetMutations.childList);
                }
                
                // Process attribute mutations
                if (targetMutations.attributes.length > 0) {
                    this.processShadowAttributeMutations(shadowMutations, target, targetMutations.attributes);
                }
                
                // Process character data mutations
                if (targetMutations.characterData.length > 0) {
                    this.processShadowCharacterDataMutations(shadowMutations, target, targetMutations.characterData);
                }
                
                // Check for new shadow roots after DOM changes
                if (CONFIG.observeShadowRoots && 
                    (targetMutations.childList.length > 0 || targetMutations.attributes.length > 0) && 
                    target.nodeType === Node.ELEMENT_NODE) {
                    this.checkForShadowRoot(target);
                }
            }
        },
        
        /**
         * Process shadow DOM child list mutations
         * @param {Object} shadowMutations - Shadow mutations context
         * @param {Node} target - The target node
         * @param {MutationRecord[]} mutations - The childList mutations
         */
        processShadowChildListMutations: function(shadowMutations, target, mutations) {
            if (!CONFIG.captureAddedNodes && !CONFIG.captureRemovedNodes) {
                return;
            }
            
            // Track added and removed nodes across all mutations for this target
            const addedNodes = new Set();
            const removedNodes = new Set();
            
            // Collect all added and removed nodes
            for (const mutation of mutations) {
                if (mutation.addedNodes.length > 0) {
                    for (const node of mutation.addedNodes) {
                        if (this.shouldTrackNode(node) && !removedNodes.has(node)) {
                            addedNodes.add(node);
                        }
                        
                        if (removedNodes.has(node)) {
                            removedNodes.delete(node);
                        }
                    }
                }
                
                if (mutation.removedNodes.length > 0) {
                    for (const node of mutation.removedNodes) {
                        if (this.shouldTrackNode(node) && !addedNodes.has(node)) {
                            removedNodes.add(node);
                        }
                        
                        if (addedNodes.has(node)) {
                            addedNodes.delete(node);
                        }
                    }
                }
            }
            
            // Process final added nodes
            if (addedNodes.size > 0 && CONFIG.captureAddedNodes) {
                const addedElements = [];
                
                for (const node of addedNodes) {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const elementInfo = this.getElementInfo(node);
                        
                        if (elementInfo) {
                            addedElements.push(elementInfo);
                            
                            // Check if we should observe a Shadow DOM for this element
                            if (CONFIG.observeShadowRoots) {
                                this.checkForShadowRoot(node);
                            }
                        }
                    }
                }
                
                if (addedElements.length > 0) {
                    this.stats.addedNodes += addedElements.length;
                    
                    // Report shadow elements added
                    CONFIG.postMessage({
                        type: 'shadowNodesAdded',
                        host: shadowMutations.host,
                        target: this.getElementInfo(target),
                        elements: addedElements,
                        timestamp: Date.now()
                    });
                }
            }
            
            // Process final removed nodes
            if (removedNodes.size > 0 && CONFIG.captureRemovedNodes) {
                const removedElements = [];
                
                for (const node of removedNodes) {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        removedElements.push({
                            tagName: node.tagName,
                            id: node.id,
                            className: node.className,
                            textContent: node.textContent ? node.textContent.substring(0, 100) : ''
                        });
                        
                        // Unregister any shadow root observers for this node
                        if (nodesWithShadowRoots.has(node)) {
                            this.unregisterShadowRootObserver(node);
                        }
                    }
                }
                
                if (removedElements.length > 0) {
                    this.stats.removedNodes += removedElements.length;
                    
                    // Report shadow elements removed
                    CONFIG.postMessage({
                        type: 'shadowNodesRemoved',
                        host: shadowMutations.host,
                        target: this.getElementInfo(target),
                        elements: removedElements,
                        timestamp: Date.now()
                    });
                }
            }
        },
        
        /**
         * Process shadow DOM attribute mutations
         * @param {Object} shadowMutations - Shadow mutations context
         * @param {Node} target - The target node
         * @param {MutationRecord[]} mutations - The attribute mutations
         */
        processShadowAttributeMutations: function(shadowMutations, target, mutations) {
            if (!CONFIG.captureAttributes || target.nodeType !== Node.ELEMENT_NODE) {
                return;
            }
            
            // Group changes by attribute name
            const attributeChanges = {};
            
            for (const mutation of mutations) {
                const attributeName = mutation.attributeName;
                const oldValue = mutation.oldValue;
                const newValue = target.getAttribute(attributeName);
                
                // Skip if we should ignore this attribute
                if (this.shouldIgnoreAttribute(attributeName, oldValue, newValue)) {
                    continue;
                }
                
                // Only track the latest change for each attribute
                attributeChanges[attributeName] = {
                    oldValue: oldValue,
                    newValue: newValue
                };
            }
            
            const attributeNames = Object.keys(attributeChanges);
            
            if (attributeNames.length > 0) {
                this.stats.attributeChanges += attributeNames.length;
                
                // Report shadow attribute changes
                CONFIG.postMessage({
                    type: 'shadowAttributesChanged',
                    host: shadowMutations.host,
                    target: this.getElementInfo(target),
                    changes: attributeChanges,
                    timestamp: Date.now()
                });
            }
        },
        
        /**
         * Process shadow DOM character data mutations
         * @param {Object} shadowMutations - Shadow mutations context
         * @param {Node} target - The target node
         * @param {MutationRecord[]} mutations - The characterData mutations
         */
        processShadowCharacterDataMutations: function(shadowMutations, target, mutations) {
            if (!CONFIG.captureCharacterData) {
                return;
            }
            
            // We only care about the latest text change
            const lastMutation = mutations[mutations.length - 1];
            const oldValue = lastMutation.oldValue;
            
            // Get the new text value
            let newValue = '';
            
            if (target.nodeType === Node.TEXT_NODE) {
                newValue = target.textContent;
            } else if (target.nodeType === Node.ELEMENT_NODE) {
                newValue = target.textContent;
            } else {
                newValue = String(target.nodeValue);
            }
            
            // Skip if the content hasn't actually changed or is not meaningful
            if (oldValue === newValue || 
                (oldValue && newValue && 
                 oldValue.trim() === newValue.trim() && 
                 oldValue.length < 2)) {
                return;
            }
            
            // For text nodes, get the parent element for better context
            const contextNode = target.nodeType === Node.TEXT_NODE ? target.parentElement : target;
            
            if (!contextNode) {
                return;
            }
            
            this.stats.characterDataChanges++;
            
            // Report shadow text change
            CONFIG.postMessage({
                type: 'shadowTextChanged',
                host: shadowMutations.host,
                target: this.getElementInfo(contextNode),
                oldText: oldValue ? oldValue.substring(0, 1000) : '',
                newText: newValue ? newValue.substring(0, 1000) : '',
                timestamp: Date.now()
            });
        },
        
        /**
         * Track style sheet changes in the document
         */
        trackStyleSheets: function() {
            if (!CONFIG.trackStyleSheetChanges) {
                return;
            }
            
            // Store initial style sheets
            this.recordStyleSheets();
            
            // Set up a periodic check for new style sheets
            setInterval(() => {
                this.checkStyleSheetChanges();
            }, 1000);
        },
        
        /**
         * Record the current state of style sheets
         */
        recordStyleSheets: function() {
            this.styleSheets = Array.from(document.styleSheets).map(sheet => {
                const sheetInfo = {
                    href: sheet.href,
                    title: sheet.title,
                    disabled: sheet.disabled,
                    media: sheet.media.mediaText,
                    ownerNode: sheet.ownerNode ? this.getElementInfo(sheet.ownerNode) : null
                };
                
                // Try to get rules if same-origin
                try {
                    sheetInfo.ruleCount = sheet.cssRules ? sheet.cssRules.length : 0;
                } catch (e) {
                    // Cross-origin style sheet
                    sheetInfo.crossOrigin = true;
                }
                
                return sheetInfo;
            });
        },
        
        /**
         * Check for style sheet changes
         */
        checkStyleSheetChanges: function() {
            if (!this.styleSheets) {
                this.recordStyleSheets();
                return;
            }
            
            const currentStyleSheets = Array.from(document.styleSheets);
            const changes = [];
            
            // Check for new style sheets
            for (const sheet of currentStyleSheets) {
                const existingSheet = this.styleSheets.find(s => {
                    return (s.href === sheet.href && s.title === sheet.title) || 
                           (s.ownerNode && sheet.ownerNode && s.ownerNode.selector === this.generateSelector(sheet.ownerNode));
                });
                
                if (!existingSheet) {
                    changes.push({
                        type: 'added',
                        sheet: {
                            href: sheet.href,
                            title: sheet.title,
                            disabled: sheet.disabled,
                            media: sheet.media.mediaText,
                            ownerNode: sheet.ownerNode ? this.getElementInfo(sheet.ownerNode) : null
                        }
                    });
                }
            }
            
            // Check for removed style sheets
            for (const oldSheet of this.styleSheets) {
                const stillExists = currentStyleSheets.some(sheet => {
                    return (oldSheet.href === sheet.href && oldSheet.title === sheet.title) || 
                           (oldSheet.ownerNode && sheet.ownerNode && oldSheet.ownerNode.selector === this.generateSelector(sheet.ownerNode));
                });
                
                if (!stillExists) {
                    changes.push({
                        type: 'removed',
                        sheet: oldSheet
                    });
                }
            }
            
            // Report changes if any
            if (changes.length > 0) {
                this.stats.styleSheetChanges += changes.length;
                
                CONFIG.postMessage({
                    type: 'styleSheetChanges',
                    changes: changes,
                    timestamp: Date.now()
                });
                
                // Update the stored style sheets
                this.recordStyleSheets();
            }
        },
        
        /**
         * Send current statistics
         */
        sendStats: function() {
            CONFIG.postMessage({
                type: 'stats',
                stats: this.stats,
                timestamp: Date.now()
            });
        },
        
        /**
         * Update configuration settings
         * @param {Object} newConfig - New configuration settings
         */
        updateConfig: function(newConfig) {
            let needReconnect = false;
            
            // Check if important observation settings have changed
            if (newConfig.captureAddedNodes !== undefined && newConfig.captureAddedNodes !== CONFIG.captureAddedNodes) {
                needReconnect = true;
            }
            
            if (newConfig.captureRemovedNodes !== undefined && newConfig.captureRemovedNodes !== CONFIG.captureRemovedNodes) {
                needReconnect = true;
            }
            
            if (newConfig.captureAttributes !== undefined && newConfig.captureAttributes !== CONFIG.captureAttributes) {
                needReconnect = true;
            }
            
            if (newConfig.captureCharacterData !== undefined && newConfig.captureCharacterData !== CONFIG.captureCharacterData) {
                needReconnect = true;
            }
            
            // Update all provided settings
            for (const key in newConfig) {
                if (CONFIG.hasOwnProperty(key)) {
                    CONFIG[key] = newConfig[key];
                }
            }
            
            // Reconnect if needed
            if (needReconnect && this.connected && !this.paused) {
                this.disconnect();
                this.connect();
            }
            
            console.log('CSTestForge DOM Observer: Configuration updated', CONFIG);
            
            // Send confirmation
            CONFIG.postMessage({
                type: 'configUpdated',
                timestamp: Date.now()
            });
        },
        
        /**
         * Highlight an element in the DOM
         * @param {string} selector - CSS selector for the element to highlight
         */
        highlightElement: function(selector) {
            try {
                // Try to find the element
                let element;
                
                if (selector.startsWith('/')) {
                    // XPath selector
                    const result = document.evaluate(
                        selector, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null
                    );
                    element = result.singleNodeValue;
                } else {
                    // CSS selector
                    element = document.querySelector(selector);
                }
                
                if (!element) {
                    console.warn('CSTestForge DOM Observer: Element not found', selector);
                    return;
                }
                
                // Create highlight overlay
                const overlay = document.createElement('div');
                const rect = element.getBoundingClientRect();
                
                overlay.style.position = 'absolute';
                overlay.style.top = (rect.top + window.scrollY) + 'px';
                overlay.style.left = (rect.left + window.scrollX) + 'px';
                overlay.style.width = rect.width + 'px';
                overlay.style.height = rect.height + 'px';
                overlay.style.backgroundColor = 'rgba(197, 75, 140, 0.3)';
                overlay.style.border = '2px solid #C54B8C';
                overlay.style.zIndex = '2147483647';
                overlay.style.pointerEvents = 'none';
                overlay.style.boxSizing = 'border-box';
                overlay.style.transition = 'opacity 0.3s ease-in-out';
                overlay.style.borderRadius = '3px';
                overlay.id = 'cs-highlight-overlay';
                
                // Remove any existing overlay
                const existingOverlay = document.getElementById('cs-highlight-overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
                
                document.body.appendChild(overlay);
                
                // Add pulse animation
                overlay.animate([
                    { boxShadow: '0 0 0 rgba(197, 75, 140, 0.4)' },
                    { boxShadow: '0 0 0 10px rgba(197, 75, 140, 0)' }
                ], {
                    duration: 1000,
                    iterations: 3
                });
                
                // Remove overlay after animation
                setTimeout(() => {
                    if (overlay.parentNode) {
                        overlay.remove();
                    }
                }, 3000);
                
                // Scroll element into view if needed
                if (rect.top < 0 || rect.bottom > window.innerHeight) {
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }
                
                // Report highlight success
                CONFIG.postMessage({
                    type: 'elementHighlighted',
                    selector: selector,
                    success: true,
                    elementInfo: this.getElementInfo(element),
                    timestamp: Date.now()
                });
            } catch (e) {
                console.error('CSTestForge DOM Observer: Error highlighting element', e);
                
                // Report highlight failure
                CONFIG.postMessage({
                    type: 'elementHighlighted',
                    selector: selector,
                    success: false,
                    error: e.toString(),
                    timestamp: Date.now()
                });
            }
        }
    };
    
    // Initialize the DOM observer
    CSDOMObserver.init();
    
    // Make the observer available for testing or manual use
    window.__CSTestForgeDOMObserver = CSDOMObserver;
})();


network-monitor.js
------------------------------------

/**
 * network-monitor.js
 * Part of CSTestForge Browser Integration Module
 * 
 * This script is responsible for monitoring network activity during recording,
 * tracking XHR requests, fetch API calls, and websocket communications.
 * It captures request and response details for test verification and
 * dependency analysis.
 */

(function() {
    'use strict';

    // Configuration
    const CONFIG = {
        // Whether to monitor network activity
        enabled: true,
        
        // Types of requests to monitor
        monitorXHR: true,
        monitorFetch: true,
        monitorBeacons: true,
        monitorWebSockets: true,
        
        // Detail level for capturing request/response bodies
        captureRequestBody: true,
        captureResponseBody: true,
        
        // Maximum size in bytes to capture for request/response bodies
        maxRequestBodySize: 10000,
        maxResponseBodySize: 50000,
        
        // Don't capture bodies for these content types
        skipBodyContentTypes: [
            'image/', 'video/', 'audio/', 'font/', 
            'application/octet-stream', 'application/pdf'
        ],
        
        // Paths to ignore (regexps)
        ignorePaths: [
            /\.(png|jpg|jpeg|gif|svg|webp|ico|woff|woff2|ttf|eot|mp4|webm|mp3|ogg)(\?|$)/,
            /\/analytics\//, /\/tracking\//, /\/log\//,
            /google-analytics/, /doubleclick/, /pixel\//
        ],
        
        // Maximum number of requests to keep in memory
        maxRequestHistory: 100,
        
        // Whether to throttle event firing
        throttleEvents: true,
        
        // How often to send batched events (ms)
        batchInterval: 500,
        
        // Function to post messages to the parent application
        postMessage: function(message) {
            try {
                window.parent.postMessage({
                    type: 'CSTestForge_NetworkMonitor',
                    data: message,
                    frameId: window.__CSNetworkMonitor.frameId,
                    url: window.location.href
                }, '*');
            } catch (e) {
                console.error('CSTestForge Network Monitor: Error sending message', e);
            }
        },
        
        // Process response bodies - automatically parse JSON, etc.
        processResponseBodies: true,
        
        // Monitor resource timing API
        monitorResourceTiming: true,
        
        // Track network errors
        trackNetworkErrors: true,
        
        // Monitor performance entries
        monitorPerformanceEntries: true,
        
        // Mask sensitive data in requests
        maskSensitiveData: true,
        
        // Sensitive fields to mask
        sensitiveFields: [
            'password', 'token', 'auth', 'key', 'secret', 'credential',
            'ssn', 'social', 'credit', 'card', 'cvv', 'cvc', 'pin'
        ],
        
        // Headers to not capture
        sensitiveHeaders: [
            'authorization', 'cookie', 'set-cookie', 'x-auth-token'
        ],
        
        // Whether to group similar requests
        groupSimilarRequests: true
    };
    
    // Storage for intercepted originals
    const originals = {
        XMLHttpRequest: {
            open: null,
            send: null,
            setRequestHeader: null,
            addEventListener: null,
            removeEventListener: null
        },
        fetch: null,
        WebSocket: {
            constructor: null,
            send: null,
            addEventListener: null,
            removeEventListener: null
        },
        sendBeacon: null
    };
    
    // Storage for active requests
    const pendingRequests = new Map();
    const completedRequests = [];
    const requestCounters = {
        xhr: 0,
        fetch: 0,
        websocket: 0,
        beacon: 0
    };
    
    // Event batching
    let eventBuffer = [];
    let batchTimeout = null;
    
    // Unique ID for this frame
    const frameId = 'csframe_' + Math.random().toString(36).substring(2, 15);
    
    /**
     * Network Monitor Implementation
     */
    const CSNetworkMonitor = {
        // Identifier for this frame
        frameId: frameId,
        
        /**
         * Initialize the network monitor
         */
        init: function() {
            if (!CONFIG.enabled) {
                return;
            }
            
            // Store original methods
            this.saveOriginals();
            
            // Set up interceptors
            if (CONFIG.monitorXHR) {
                this.interceptXHR();
            }
            
            if (CONFIG.monitorFetch) {
                this.interceptFetch();
            }
            
            if (CONFIG.monitorBeacons) {
                this.interceptBeacon();
            }
            
            if (CONFIG.monitorWebSockets) {
                this.interceptWebSocket();
            }
            
            // Set up resource timing monitoring
            if (CONFIG.monitorResourceTiming) {
                this.monitorResourceTiming();
            }
            
            // Monitor performance entries
            if (CONFIG.monitorPerformanceEntries) {
                this.monitorPerformanceEntries();
            }
            
            // Listen for control messages
            window.addEventListener('message', this.handleMessage.bind(this));
            
            // Send initialization event
            this.sendEvent({
                type: 'init',
                url: window.location.href,
                timestamp: Date.now()
            });
            
            console.log('CSTestForge Network Monitor: Initialized');
        },
        
        /**
         * Save original methods for restoration
         */
        saveOriginals: function() {
            // XMLHttpRequest methods
            originals.XMLHttpRequest.open = XMLHttpRequest.prototype.open;
            originals.XMLHttpRequest.send = XMLHttpRequest.prototype.send;
            originals.XMLHttpRequest.setRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
            originals.XMLHttpRequest.addEventListener = XMLHttpRequest.prototype.addEventListener;
            originals.XMLHttpRequest.removeEventListener = XMLHttpRequest.prototype.removeEventListener;
            
            // Fetch API
            originals.fetch = window.fetch;
            
            // WebSocket
            originals.WebSocket.constructor = window.WebSocket;
            originals.WebSocket.send = WebSocket.prototype.send;
            originals.WebSocket.addEventListener = WebSocket.prototype.addEventListener;
            originals.WebSocket.removeEventListener = WebSocket.prototype.removeEventListener;
            
            // Beacon API
            originals.sendBeacon = navigator.sendBeacon;
        },
        
        /**
         * Restore original methods
         */
        restoreOriginals: function() {
            // Only restore if we have the originals and current methods are our overrides
            if (originals.XMLHttpRequest.open) {
                XMLHttpRequest.prototype.open = originals.XMLHttpRequest.open;
            }
            
            if (originals.XMLHttpRequest.send) {
                XMLHttpRequest.prototype.send = originals.XMLHttpRequest.send;
            }
            
            if (originals.XMLHttpRequest.setRequestHeader) {
                XMLHttpRequest.prototype.setRequestHeader = originals.XMLHttpRequest.setRequestHeader;
            }
            
            if (originals.XMLHttpRequest.addEventListener) {
                XMLHttpRequest.prototype.addEventListener = originals.XMLHttpRequest.addEventListener;
            }
            
            if (originals.XMLHttpRequest.removeEventListener) {
                XMLHttpRequest.prototype.removeEventListener = originals.XMLHttpRequest.removeEventListener;
            }
            
            if (originals.fetch) {
                window.fetch = originals.fetch;
            }
            
            if (originals.WebSocket.constructor) {
                window.WebSocket = originals.WebSocket.constructor;
            }
            
            if (originals.WebSocket.send) {
                WebSocket.prototype.send = originals.WebSocket.send;
            }
            
            if (originals.WebSocket.addEventListener) {
                WebSocket.prototype.addEventListener = originals.WebSocket.addEventListener;
            }
            
            if (originals.WebSocket.removeEventListener) {
                WebSocket.prototype.removeEventListener = originals.WebSocket.removeEventListener;
            }
            
            if (originals.sendBeacon) {
                navigator.sendBeacon = originals.sendBeacon;
            }
        },
        
        /**
         * Intercept XMLHttpRequest
         */
        interceptXHR: function() {
            const self = this;
            
            // Intercept open method
            XMLHttpRequest.prototype.open = function() {
                const method = arguments[0];
                const url = arguments[1];
                const async = arguments[2] !== false; // Default is true
                
                // Store request data
                this._csNetworkMonitor = {
                    id: 'xhr_' + (++requestCounters.xhr),
                    method: method,
                    url: url,
                    async: async,
                    startTime: performance.now(),
                    requestHeaders: {},
                    responseHeaders: {},
                    status: 0,
                    statusText: '',
                    type: 'xhr',
                    state: 'opened'
                };
                
                // Should we monitor this request?
                this._csNetworkMonitor.monitored = !self.shouldIgnoreRequest(url);
                
                // Call original
                return originals.XMLHttpRequest.open.apply(this, arguments);
            };
            
            // Intercept setRequestHeader
            XMLHttpRequest.prototype.setRequestHeader = function(header, value) {
                // Store header if monitored and we're tracking this request
                if (this._csNetworkMonitor && this._csNetworkMonitor.monitored) {
                    // Mask sensitive headers if needed
                    const lcHeader = header.toLowerCase();
                    if (CONFIG.maskSensitiveData && CONFIG.sensitiveHeaders.includes(lcHeader)) {
                        this._csNetworkMonitor.requestHeaders[header] = '********';
                    } else {
                        this._csNetworkMonitor.requestHeaders[header] = value;
                    }
                }
                
                // Call original
                return originals.XMLHttpRequest.setRequestHeader.apply(this, arguments);
            };
            
            // Intercept send
            XMLHttpRequest.prototype.send = function(body) {
                if (this._csNetworkMonitor && this._csNetworkMonitor.monitored) {
                    // Process and store the request body
                    if (CONFIG.captureRequestBody && body !== null && body !== undefined) {
                        this._csNetworkMonitor.requestBody = self.processRequestBody(body);
                    }
                    
                    // Update state
                    this._csNetworkMonitor.state = 'sent';
                    
                    // Add to pending requests
                    pendingRequests.set(this._csNetworkMonitor.id, this._csNetworkMonitor);
                    
                    // Send request started event
                    self.sendEvent({
                        type: 'requestStarted',
                        request: self.sanitizeRequest(this._csNetworkMonitor),
                        timestamp: Date.now()
                    });
                    
                    // Set up response handlers
                    self.setupXHRResponseHandlers(this);
                }
                
                // Call original
                return originals.XMLHttpRequest.send.apply(this, arguments);
            };
            
            // Enhanced addEventListener to monitor load/error events
            XMLHttpRequest.prototype.addEventListener = function(type, listener, options) {
                // Call original first
                const result = originals.XMLHttpRequest.addEventListener.apply(this, arguments);
                
                if (this._csNetworkMonitor && this._csNetworkMonitor.monitored) {
                    if (type === 'load' || type === 'loadend' || type === 'error' || type === 'abort' || type === 'timeout') {
                        // Add our own listener after the user's
                        const origListener = listener;
                        const wrappedListener = function(event) {
                            // Call original listener
                            if (typeof origListener === 'function') {
                                origListener.call(this, event);
                            }
                            
                            // Process the response
                            self.handleXHRResponse(this, type);
                        };
                        
                        // Replace the original listener with our wrapped version
                        arguments[1] = wrappedListener;
                        
                        // Store original mapping to prevent duplicate wrapping
                        if (!this._csNetworkMonitor.wrappedListeners) {
                            this._csNetworkMonitor.wrappedListeners = new Map();
                        }
                        this._csNetworkMonitor.wrappedListeners.set(listener, wrappedListener);
                    }
                }
                
                return result;
            };
            
            // Enhanced removeEventListener to handle wrapped listeners
            XMLHttpRequest.prototype.removeEventListener = function(type, listener, options) {
                // If this is a monitored request and we've wrapped this listener, use the wrapped version
                if (this._csNetworkMonitor && this._csNetworkMonitor.monitored && 
                    this._csNetworkMonitor.wrappedListeners && 
                    this._csNetworkMonitor.wrappedListeners.has(listener)) {
                    
                    arguments[1] = this._csNetworkMonitor.wrappedListeners.get(listener);
                    this._csNetworkMonitor.wrappedListeners.delete(listener);
                }
                
                // Call original
                return originals.XMLHttpRequest.removeEventListener.apply(this, arguments);
            };
        },
        
        /**
         * Set up response handlers for an XMLHttpRequest
         * @param {XMLHttpRequest} xhr - The XHR object
         */
        setupXHRResponseHandlers: function(xhr) {
            // We need to make sure we capture the response regardless of event listeners
            // Add our own listeners for readystatechange
            xhr.addEventListener('readystatechange', () => {
                if (xhr.readyState === 4) {
                    this.handleXHRResponse(xhr, 'readystatechange');
                }
            });
            
            // Add our own listeners for load, error, timeout, and abort
            xhr.addEventListener('load', () => this.handleXHRResponse(xhr, 'load'));
            xhr.addEventListener('error', () => this.handleXHRResponse(xhr, 'error'));
            xhr.addEventListener('timeout', () => this.handleXHRResponse(xhr, 'timeout'));
            xhr.addEventListener('abort', () => this.handleXHRResponse(xhr, 'abort'));
        },
        
        /**
         * Handle XHR response completion
         * @param {XMLHttpRequest} xhr - The XHR object
         * @param {string} eventType - The event type that triggered this
         */
        handleXHRResponse: function(xhr, eventType) {
            // Skip if not a monitored request
            if (!xhr._csNetworkMonitor || !xhr._csNetworkMonitor.monitored) {
                return;
            }
            
            const requestInfo = xhr._csNetworkMonitor;
            
            // Skip if we've already processed this response
            if (requestInfo.state === 'completed') {
                return;
            }
            
            // Update request info with response data
            requestInfo.endTime = performance.now();
            requestInfo.duration = requestInfo.endTime - requestInfo.startTime;
            requestInfo.status = xhr.status;
            requestInfo.statusText = xhr.statusText;
            requestInfo.state = 'completed';
            requestInfo.eventType = eventType;
            
            // Get response headers
            const allHeaders = xhr.getAllResponseHeaders();
            const headerLines = allHeaders.split(/\r?\n/);
            
            for (const line of headerLines) {
                const parts = line.split(': ');
                if (parts.length === 2) {
                    const header = parts[0];
                    const value = parts[1];
                    
                    // Mask sensitive headers if needed
                    const lcHeader = header.toLowerCase();
                    if (CONFIG.maskSensitiveData && CONFIG.sensitiveHeaders.includes(lcHeader)) {
                        requestInfo.responseHeaders[header] = '********';
                    } else {
                        requestInfo.responseHeaders[header] = value;
                    }
                }
            }
            
            // Get response body for non-binary content
            if (CONFIG.captureResponseBody && xhr.responseType === '' || xhr.responseType === 'text') {
                // Check content type to see if we should skip body capture
                const contentType = xhr.getResponseHeader('content-type');
                
                // Skip body capture for certain content types
                if (!this.shouldSkipBodyCapture(contentType)) {
                    try {
                        const responseText = xhr.responseText;
                        
                        // Limit size
                        if (responseText && responseText.length > CONFIG.maxResponseBodySize) {
                            requestInfo.responseBody = responseText.substring(0, CONFIG.maxResponseBodySize) + '... [truncated]';
                        } else {
                            requestInfo.responseBody = responseText;
                        }
                        
                        // Process response body based on content type
                        if (CONFIG.processResponseBodies) {
                            requestInfo.processedResponse = this.processResponseBody(
                                requestInfo.responseBody, contentType
                            );
                        }
                    } catch (e) {
                        requestInfo.responseBodyError = e.toString();
                    }
                }
            } else if (CONFIG.captureResponseBody && xhr.responseType === 'json') {
                try {
                    requestInfo.processedResponse = xhr.response;
                } catch (e) {
                    requestInfo.responseBodyError = e.toString();
                }
            }
            
            // Remove from pending, add to completed
            pendingRequests.delete(requestInfo.id);
            this.addCompletedRequest(requestInfo);
            
            // Send request completed event
            this.sendEvent({
                type: 'requestCompleted',
                request: this.sanitizeRequest(requestInfo),
                timestamp: Date.now()
            });
            
            // Track network errors
            if (CONFIG.trackNetworkErrors && (eventType === 'error' || (xhr.status >= 400 && xhr.status < 600))) {
                this.sendEvent({
                    type: 'networkError',
                    request: this.sanitizeRequest(requestInfo),
                    error: eventType === 'error' ? 'Network error' : `HTTP ${xhr.status} ${xhr.statusText}`,
                    timestamp: Date.now()
                });
            }
        },
        
        /**
         * Intercept fetch API
         */
        interceptFetch: function() {
            const self = this;
            
            window.fetch = function() {
                // Get request info
                const request = arguments[0];
                const options = arguments[1] || {};
                
                // Create a unique ID for this request
                const requestId = 'fetch_' + (++requestCounters.fetch);
                
                // Parse request
                let url, method, requestHeaders, requestBody;
                
                if (typeof request === 'string') {
                    url = request;
                    method = options.method || 'GET';
                    requestHeaders = options.headers ? self.parseHeaders(options.headers) : {};
                    requestBody = options.body;
                } else {
                    // Request is a Request object
                    url = request.url;
                    method = request.method || 'GET';
                    
                    // Clone headers to avoid modifying the original
                    requestHeaders = {};
                    if (request.headers) {
                        request.headers.forEach((value, name) => {
                            // Mask sensitive headers if needed
                            const lcHeader = name.toLowerCase();
                            if (CONFIG.maskSensitiveData && CONFIG.sensitiveHeaders.includes(lcHeader)) {
                                requestHeaders[name] = '********';
                            } else {
                                requestHeaders[name] = value;
                            }
                        });
                    }
                    
                    // The request body can't be accessed directly, will need to be provided in options
                    requestBody = options.body;
                }
                
                // Should we monitor this request?
                const monitored = !self.shouldIgnoreRequest(url);
                
                if (!monitored) {
                    // Just call original
                    return originals.fetch.apply(this, arguments);
                }
                
                // Create request info
                const requestInfo = {
                    id: requestId,
                    method: method,
                    url: url,
                    requestHeaders: requestHeaders,
                    startTime: performance.now(),
                    type: 'fetch',
                    state: 'started',
                    monitored: true
                };
                
                // Process and store the request body
                if (CONFIG.captureRequestBody && requestBody) {
                    requestInfo.requestBody = self.processRequestBody(requestBody);
                }
                
                // Add to pending requests
                pendingRequests.set(requestId, requestInfo);
                
                // Send request started event
                self.sendEvent({
                    type: 'requestStarted',
                    request: self.sanitizeRequest(requestInfo),
                    timestamp: Date.now()
                });
                
                // Call original and intercept the response
                const fetchPromise = originals.fetch.apply(this, arguments);
                
                return fetchPromise.then(response => {
                    // Clone the response to avoid consuming it
                    const responseClone = response.clone();
                    
                    // Update request info
                    requestInfo.endTime = performance.now();
                    requestInfo.duration = requestInfo.endTime - requestInfo.startTime;
                    requestInfo.status = response.status;
                    requestInfo.statusText = response.statusText;
                    requestInfo.responseHeaders = {};
                    requestInfo.state = 'completed';
                    
                    // Get response headers
                    response.headers.forEach((value, name) => {
                        // Mask sensitive headers if needed
                        const lcHeader = name.toLowerCase();
                        if (CONFIG.maskSensitiveData && CONFIG.sensitiveHeaders.includes(lcHeader)) {
                            requestInfo.responseHeaders[name] = '********';
                        } else {
                            requestInfo.responseHeaders[name] = value;
                        }
                    });
                    
                    // Check content type
                    const contentType = response.headers.get('content-type');
                    
                    // Get response body if appropriate
                    if (CONFIG.captureResponseBody && !self.shouldSkipBodyCapture(contentType)) {
                        // Use the appropriate method based on expected content type
                        let bodyPromise;
                        
                        if (contentType && contentType.includes('application/json')) {
                            bodyPromise = responseClone.json().then(
                                json => JSON.stringify(json, null, 2),
                                error => `Error parsing JSON: ${error}`
                            );
                        } else {
                            bodyPromise = responseClone.text().catch(
                                error => `Error getting text: ${error}`
                            );
                        }
                        
                        bodyPromise.then(body => {
                            // Limit size
                            if (body && body.length > CONFIG.maxResponseBodySize) {
                                requestInfo.responseBody = body.substring(0, CONFIG.maxResponseBodySize) + '... [truncated]';
                            } else {
                                requestInfo.responseBody = body;
                            }
                            
                            // Process response body based on content type
                            if (CONFIG.processResponseBodies) {
                                requestInfo.processedResponse = self.processResponseBody(
                                    requestInfo.responseBody, contentType
                                );
                            }
                            
                            // Remove from pending, add to completed
                            pendingRequests.delete(requestId);
                            self.addCompletedRequest(requestInfo);
                            
                            // Send request completed event
                            self.sendEvent({
                                type: 'requestCompleted',
                                request: self.sanitizeRequest(requestInfo),
                                timestamp: Date.now()
                            });
                        });
                    } else {
                        // Skip body capture
                        pendingRequests.delete(requestId);
                        self.addCompletedRequest(requestInfo);
                        
                        // Send request completed event
                        self.sendEvent({
                            type: 'requestCompleted',
                            request: self.sanitizeRequest(requestInfo),
                            timestamp: Date.now()
                        });
                    }
                    
                    // Track network errors
                    if (CONFIG.trackNetworkErrors && (response.status >= 400 && response.status < 600)) {
                        self.sendEvent({
                            type: 'networkError',
                            request: self.sanitizeRequest(requestInfo),
                            error: `HTTP ${response.status} ${response.statusText}`,
                            timestamp: Date.now()
                        });
                    }
                    
                    return response;
                }).catch(error => {
                    // Update request info for error
                    requestInfo.endTime = performance.now();
                    requestInfo.duration = requestInfo.endTime - requestInfo.startTime;
                    requestInfo.state = 'error';
                    requestInfo.error = error.toString();
                    
                    // Remove from pending, add to completed
                    pendingRequests.delete(requestId);
                    self.addCompletedRequest(requestInfo);
                    
                    // Send request error event
                    self.sendEvent({
                        type: 'requestError',
                        request: self.sanitizeRequest(requestInfo),
                        error: error.toString(),
                        timestamp: Date.now()
                    });
                    
                    // Track network errors
                    if (CONFIG.trackNetworkErrors) {
                        self.sendEvent({
                            type: 'networkError',
                            request: self.sanitizeRequest(requestInfo),
                            error: error.toString(),
                            timestamp: Date.now()
                        });
                    }
                    
                    // Re-throw the error
                    throw error;
                });
            };
        },
        
        /**
         * Intercept WebSocket constructor and methods
         */
        interceptWebSocket: function() {
            const self = this;
            
            // Replace the WebSocket constructor
            window.WebSocket = function(url, protocols) {
                // Create a unique ID for this connection
                const wsId = 'ws_' + (++requestCounters.websocket);
                
                // Create WebSocket connection info
                const wsInfo = {
                    id: wsId,
                    url: url,
                    protocols: protocols,
                    startTime: performance.now(),
                    state: 'connecting',
                    type: 'websocket',
                    monitored: !self.shouldIgnoreRequest(url),
                    messagesSent: 0,
                    messagesReceived: 0,
                    lastSentMessage: null,
                    lastReceivedMessage: null
                };
                
                // Call the original constructor
                const ws = protocols 
                    ? new originals.WebSocket.constructor(url, protocols) 
                    : new originals.WebSocket.constructor(url);
                
                if (wsInfo.monitored) {
                    // Store connection info
                    ws._csNetworkMonitor = wsInfo;
                    
                    // Send connection started event
                    self.sendEvent({
                        type: 'websocketConnecting',
                        connection: self.sanitizeWebSocketInfo(wsInfo),
                        timestamp: Date.now()
                    });
                    
                    // Set up event handlers
                    ws.addEventListener('open', function(event) {
                        wsInfo.state = 'open';
                        wsInfo.openTime = performance.now();
                        
                        self.sendEvent({
                            type: 'websocketOpen',
                            connection: self.sanitizeWebSocketInfo(wsInfo),
                            timestamp: Date.now()
                        });
                    });
                    
                    ws.addEventListener('close', function(event) {
                        wsInfo.state = 'closed';
                        wsInfo.closeTime = performance.now();
                        wsInfo.closeCode = event.code;
                        wsInfo.closeReason = event.reason;
                        wsInfo.wasClean = event.wasClean;
                        
                        self.sendEvent({
                            type: 'websocketClose',
                            connection: self.sanitizeWebSocketInfo(wsInfo),
                            timestamp: Date.now()
                        });
                    });
                    
                    ws.addEventListener('error', function(event) {
                        wsInfo.state = 'error';
                        wsInfo.errorTime = performance.now();
                        
                        self.sendEvent({
                            type: 'websocketError',
                            connection: self.sanitizeWebSocketInfo(wsInfo),
                            timestamp: Date.now()
                        });
                        
                        // Track network errors
                        if (CONFIG.trackNetworkErrors) {
                            self.sendEvent({
                                type: 'networkError',
                                connection: self.sanitizeWebSocketInfo(wsInfo),
                                error: 'WebSocket error',
                                timestamp: Date.now()
                            });
                        }
                    });
                    
                    ws.addEventListener('message', function(event) {
                        wsInfo.messagesReceived++;
                        
                        // Capture message data
                        if (CONFIG.captureResponseBody) {
                            let messageData = event.data;
                            
                            // Try to process message data
                            if (typeof messageData === 'string') {
                                // Check for very large messages
                                if (messageData.length > CONFIG.maxResponseBodySize) {
                                    messageData = messageData.substring(0, CONFIG.maxResponseBodySize) + '... [truncated]';
                                }
                                
                                // Try to parse as JSON
                                let processedData = messageData;
                                if (CONFIG.processResponseBodies) {
                                    try {
                                        const jsonData = JSON.parse(messageData);
                                        processedData = jsonData;
                                    } catch (e) {
                                        // Not JSON, use as is
                                    }
                                }
                                
                                wsInfo.lastReceivedMessage = {
                                    time: performance.now(),
                                    data: messageData,
                                    processed: processedData
                                };
                            } else if (messageData instanceof Blob) {
                                wsInfo.lastReceivedMessage = {
                                    time: performance.now(),
                                    type: 'blob',
                                    size: messageData.size
                                };
                            } else if (messageData instanceof ArrayBuffer) {
                                wsInfo.lastReceivedMessage = {
                                    time: performance.now(),
                                    type: 'arraybuffer',
                                    size: messageData.byteLength
                                };
                            } else {
                                wsInfo.lastReceivedMessage = {
                                    time: performance.now(),
                                    type: typeof messageData,
                                    summary: String(messageData).substring(0, 100)
                                };
                            }
                        }
                        
                        self.sendEvent({
                            type: 'websocketMessage',
                            direction: 'received',
                            connection: self.sanitizeWebSocketInfo(wsInfo),
                            message: wsInfo.lastReceivedMessage,
                            timestamp: Date.now()
                        });
                    });
                }
                
                return ws;
            };
            
            // Preserve prototype chain
            window.WebSocket.prototype = originals.WebSocket.constructor.prototype;
            
            // Intercept the send method
            WebSocket.prototype.send = function(data) {
                if (this._csNetworkMonitor && this._csNetworkMonitor.monitored) {
                    const wsInfo = this._csNetworkMonitor;
                    wsInfo.messagesSent++;
                    
                    // Capture message data
                    if (CONFIG.captureRequestBody) {
                        let messageData = data;
                        
                        // Try to process message data
                        if (typeof messageData === 'string') {
                            // Check for very large messages
                            if (messageData.length > CONFIG.maxRequestBodySize) {
                                messageData = messageData.substring(0, CONFIG.maxRequestBodySize) + '... [truncated]';
                            }
                            
                            // Try to parse as JSON
                            let processedData = messageData;
                            if (CONFIG.processResponseBodies) {
                                try {
                                    const jsonData = JSON.parse(messageData);
                                    processedData = jsonData;
                                } catch (e) {
                                    // Not JSON, use as is
                                }
                            }
                            
                            wsInfo.lastSentMessage = {
                                time: performance.now(),
                                data: messageData,
                                processed: processedData
                            };
                        } else if (data instanceof Blob) {
                            wsInfo.lastSentMessage = {
                                time: performance.now(),
                                type: 'blob',
                                size: data.size
                            };
                        } else if (data instanceof ArrayBuffer) {
                            wsInfo.lastSentMessage = {
                                time: performance.now(),
                                type: 'arraybuffer',
                                size: data.byteLength
                            };
                        } else {
                            wsInfo.lastSentMessage = {
                                time: performance.now(),
                                type: typeof data,
                                summary: String(data).substring(0, 100)
                            };
                        }
                    }
                    
                    self.sendEvent({
                        type: 'websocketMessage',
                        direction: 'sent',
                        connection: self.sanitizeWebSocketInfo(wsInfo),
                        message: wsInfo.lastSentMessage,
                        timestamp: Date.now()
                    });
                }
                
                // Call original
                return originals.WebSocket.send.apply(this, arguments);
            };
        },
        
        /**
         * Intercept navigator.sendBeacon
         */
        interceptBeacon: function() {
            const self = this;
            
            navigator.sendBeacon = function(url, data) {
                // Create a unique ID for this beacon
                const beaconId = 'beacon_' + (++requestCounters.beacon);
                
                // Should we monitor this request?
                const monitored = !self.shouldIgnoreRequest(url);
                
                if (!monitored) {
                    // Just call original
                    return originals.sendBeacon.apply(this, arguments);
                }
                
                // Create beacon info
                const beaconInfo = {
                    id: beaconId,
                    url: url,
                    method: 'POST', // Beacons are always POST
                    startTime: performance.now(),
                    type: 'beacon',
                    state: 'sent',
                    monitored: true
                };
                
                // Process and store the data
                if (CONFIG.captureRequestBody && data) {
                    beaconInfo.requestBody = self.processRequestBody(data);
                }
                
                // Send beacon event
                self.sendEvent({
                    type: 'beaconSent',
                    beacon: self.sanitizeRequest(beaconInfo),
                    timestamp: Date.now()
                });
                
                // Add to completed requests
                self.addCompletedRequest(beaconInfo);
                
                // Call original
                return originals.sendBeacon.apply(this, arguments);
            };
        },
        
        /**
         * Monitor resource timing API
         */
        monitorResourceTiming: function() {
            if (!window.performance || !window.performance.getEntriesByType) {
                return;
            }
            
            const self = this;
            let lastObservedIndex = 0;
            
            // Check for new entries periodically
            setInterval(() => {
                const entries = window.performance.getEntriesByType('resource');
                
                if (entries.length > lastObservedIndex) {
                    // Process new entries
                    for (let i = lastObservedIndex; i < entries.length; i++) {
                        self.processResourceTimingEntry(entries[i]);
                    }
                    
                    lastObservedIndex = entries.length;
                }
            }, 1000);
            
            // Also observe PerformanceObserver if available
            if (window.PerformanceObserver) {
                try {
                    const observer = new PerformanceObserver((list) => {
                        list.getEntries().forEach(entry => {
                            if (entry.entryType === 'resource') {
                                self.processResourceTimingEntry(entry);
                            }
                        });
                    });
                    
                    observer.observe({ entryTypes: ['resource'] });
                } catch (e) {
                    console.error('CSTestForge Network Monitor: Error setting up PerformanceObserver', e);
                }
            }
        },
        
        /**
         * Process a resource timing entry
         * @param {PerformanceResourceTiming} entry - The resource timing entry
         */
        processResourceTimingEntry: function(entry) {
            // Skip if we should ignore this request
            if (this.shouldIgnoreRequest(entry.name)) {
                return;
            }
            
            // Skip entries we've already tracked via our interceptors
            const entryUrl = entry.name;
            const matchingRequest = completedRequests.find(req => req.url === entryUrl);
            
            if (matchingRequest) {
                // We already tracked this request
                return;
            }
            
            // Create resource info
            const resourceInfo = {
                id: 'resource_' + Math.random().toString(36).substring(2, 8),
                url: entry.name,
                initiatorType: entry.initiatorType,
                startTime: entry.startTime,
                responseEnd: entry.responseEnd,
                duration: entry.duration,
                type: 'resource',
                transferSize: entry.transferSize,
                encodedBodySize: entry.encodedBodySize,
                decodedBodySize: entry.decodedBodySize,
                state: 'completed'
            };
            
            // Add timing information
            resourceInfo.timing = {
                connectStart: entry.connectStart,
                connectEnd: entry.connectEnd,
                domainLookupStart: entry.domainLookupStart,
                domainLookupEnd: entry.domainLookupEnd,
                fetchStart: entry.fetchStart,
                redirectStart: entry.redirectStart,
                redirectEnd: entry.redirectEnd,
                requestStart: entry.requestStart,
                responseStart: entry.responseStart,
                responseEnd: entry.responseEnd,
                secureConnectionStart: entry.secureConnectionStart
            };
            
            // Send resource timing event
            this.sendEvent({
                type: 'resourceTiming',
                resource: resourceInfo,
                timestamp: Date.now()
            });
            
            // Add to completed requests
            this.addCompletedRequest(resourceInfo);
        },
        
        /**
         * Monitor performance entries
         */
        monitorPerformanceEntries: function() {
            if (!window.performance || !window.performance.getEntriesByType) {
                return;
            }
            
            const self = this;
            
            // Monitor navigation timing
            const navigationEntries = window.performance.getEntriesByType('navigation');
            if (navigationEntries.length > 0) {
                self.sendEvent({
                    type: 'navigationTiming',
                    navigation: navigationEntries[0],
                    timestamp: Date.now()
                });
            }
            
            // Monitor paint timing
            const paintEntries = window.performance.getEntriesByType('paint');
            if (paintEntries.length > 0) {
                self.sendEvent({
                    type: 'paintTiming',
                    paints: paintEntries,
                    timestamp: Date.now()
                });
            }
            
            // Use PerformanceObserver for ongoing monitoring
            if (window.PerformanceObserver) {
                try {
                    // Observe navigation timing
                    const navObserver = new PerformanceObserver((list) => {
                        list.getEntries().forEach(entry => {
                            self.sendEvent({
                                type: 'navigationTiming',
                                navigation: entry,
                                timestamp: Date.now()
                            });
                        });
                    });
                    
                    navObserver.observe({ entryTypes: ['navigation'] });
                    
                    // Observe paint timing
                    const paintObserver = new PerformanceObserver((list) => {
                        list.getEntries().forEach(entry => {
                            self.sendEvent({
                                type: 'paintTiming',
                                paint: entry,
                                timestamp: Date.now()
                            });
                        });
                    });
                    
                    paintObserver.observe({ entryTypes: ['paint'] });
                    
                    // Observe long tasks
                    const longTaskObserver = new PerformanceObserver((list) => {
                        list.getEntries().forEach(entry => {
                            self.sendEvent({
                                type: 'longTask',
                                task: entry,
                                timestamp: Date.now()
                            });
                        });
                    });
                    
                    longTaskObserver.observe({ entryTypes: ['longtask'] });
                } catch (e) {
                    console.error('CSTestForge Network Monitor: Error setting up PerformanceObserver', e);
                }
            }
        },
        
        /**
         * Process request body based on content type
         * @param {*} body - The request body
         * @returns {*} Processed body
         */
        processRequestBody: function(body) {
            if (!body) {
                return null;
            }
            
            // Handle different body types
            if (typeof body === 'string') {
                // Check if it's too large
                if (body.length > CONFIG.maxRequestBodySize) {
                    const truncated = body.substring(0, CONFIG.maxRequestBodySize) + '... [truncated]';
                    
                    // Try to parse as JSON
                    try {
                        const json = JSON.parse(body);
                        return {
                            type: 'json',
                            original: truncated,
                            parsed: json
                        };
                    } catch (e) {
                        // Not JSON
                        return {
                            type: 'text',
                            content: this.maskSensitiveData(truncated)
                        };
                    }
                }
                
                // Try to parse as JSON
                try {
                    const json = JSON.parse(body);
                    return {
                        type: 'json',
                        parsed: this.maskSensitiveData(json)
                    };
                } catch (e) {
                    // Not JSON
                    return {
                        type: 'text',
                        content: this.maskSensitiveData(body)
                    };
                }
            } else if (body instanceof FormData) {
                // Try to extract form data entries
                const formDataEntries = {};
                
                try {
                    // Modern browsers support FormData.entries()
                    for (const [key, value] of body.entries()) {
                        if (value instanceof File) {
                            formDataEntries[key] = {
                                type: 'file',
                                name: value.name,
                                size: value.size,
                                type: value.type
                            };
                        } else {
                            // Mask sensitive data if needed
                            if (CONFIG.maskSensitiveData && this.isSensitiveField(key)) {
                                formDataEntries[key] = '********';
                            } else {
                                formDataEntries[key] = value;
                            }
                        }
                    }
                    
                    return {
                        type: 'formdata',
                        entries: formDataEntries
                    };
                } catch (e) {
                    return {
                        type: 'formdata',
                        error: 'Could not extract FormData entries'
                    };
                }
            } else if (body instanceof URLSearchParams) {
                // Convert to object
                const params = {};
                
                for (const [key, value] of body.entries()) {
                    // Mask sensitive data if needed
                    if (CONFIG.maskSensitiveData && this.isSensitiveField(key)) {
                        params[key] = '********';
                    } else {
                        params[key] = value;
                    }
                }
                
                return {
                    type: 'urlencoded',
                    params: params
                };
            } else if (body instanceof Blob) {
                return {
                    type: 'blob',
                    size: body.size,
                    mimeType: body.type
                };
            } else if (body instanceof ArrayBuffer) {
                return {
                    type: 'arraybuffer',
                    size: body.byteLength
                };
            } else if (typeof body === 'object') {
                return {
                    type: 'object',
                    value: this.maskSensitiveData(body)
                };
            } else {
                return {
                    type: typeof body,
                    preview: String(body).substring(0, 100)
                };
            }
        },
        
        /**
         * Process response body based on content type
         * @param {string} body - The response body
         * @param {string} contentType - The content type
         * @returns {*} Processed body
         */
        processResponseBody: function(body, contentType) {
            if (!body) {
                return null;
            }
            
            // Check if it's JSON
            if (contentType && contentType.includes('application/json')) {
                try {
                    return JSON.parse(body);
                } catch (e) {
                    return {
                        type: 'text',
                        content: body,
                        parseError: e.toString()
                    };
                }
            }
            
            // Check if it's XML
            if (contentType && (contentType.includes('application/xml') || contentType.includes('text/xml'))) {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(body, 'text/xml');
                    
                    // Check for parsing errors
                    const parserError = xmlDoc.querySelector('parsererror');
                    if (parserError) {
                        return {
                            type: 'text',
                            content: body,
                            parseError: 'XML parsing error'
                        };
                    }
                    
                    // Return a simplified representation
                    return {
                        type: 'xml',
                        rootElement: xmlDoc.documentElement.tagName,
                        content: body
                    };
                } catch (e) {
                    return {
                        type: 'text',
                        content: body,
                        parseError: e.toString()
                    };
                }
            }
            
            // Check if it's HTML
            if (contentType && contentType.includes('text/html')) {
                return {
                    type: 'html',
                    content: body.substring(0, 1000) + (body.length > 1000 ? '... [truncated]' : '')
                };
            }
            
            // Default to text
            return {
                type: 'text',
                content: body
            };
        },
        
        /**
         * Parse headers object/string into a key-value object
         * @param {Object|string} headers - The headers
         * @returns {Object} Headers as key-value pairs
         */
        parseHeaders: function(headers) {
            if (!headers) {
                return {};
            }
            
            // If headers is already an object
            if (typeof headers === 'object' && !headers.forEach) {
                return headers;
            }
            
            const result = {};
            
            // If headers is a Headers object
            if (headers.forEach) {
                headers.forEach((value, name) => {
                    // Mask sensitive headers if needed
                    const lcHeader = name.toLowerCase();
                    if (CONFIG.maskSensitiveData && CONFIG.sensitiveHeaders.includes(lcHeader)) {
                        result[name] = '********';
                    } else {
                        result[name] = value;
                    }
                });
                return result;
            }
            
            // If headers is a string
            if (typeof headers === 'string') {
                const pairs = headers.split('\r\n');
                for (const pair of pairs) {
                    const index = pair.indexOf(': ');
                    if (index > 0) {
                        const name = pair.substring(0, index);
                        const value = pair.substring(index + 2);
                        
                        // Mask sensitive headers if needed
                        const lcHeader = name.toLowerCase();
                        if (CONFIG.maskSensitiveData && CONFIG.sensitiveHeaders.includes(lcHeader)) {
                            result[name] = '********';
                        } else {
                            result[name] = value;
                        }
                    }
                }
                return result;
            }
            
            return {};
        },
        
        /**
         * Check if a field is sensitive
         * @param {string} fieldName - The field name
         * @returns {boolean} Whether the field is sensitive
         */
        isSensitiveField: function(fieldName) {
            if (!fieldName || typeof fieldName !== 'string') {
                return false;
            }
            
            const lowercaseName = fieldName.toLowerCase();
            
            return CONFIG.sensitiveFields.some(pattern => lowercaseName.includes(pattern));
        },
        
        /**
         * Mask sensitive data in objects
         * @param {*} data - The data to mask
         * @returns {*} Masked data
         */
        maskSensitiveData: function(data) {
            if (!CONFIG.maskSensitiveData) {
                return data;
            }
            
            if (!data) {
                return data;
            }
            
            // Handle different data types
            if (typeof data === 'string') {
                // For strings, we don't have field names to check,
                // so we just return as is
                return data;
            }
            
            if (typeof data === 'object' && data !== null) {
                // Clone the object to avoid modifying the original
                const masked = Array.isArray(data) ? [...data] : {...data};
                
                for (const key in masked) {
                    if (Object.prototype.hasOwnProperty.call(masked, key)) {
                        if (this.isSensitiveField(key)) {
                            masked[key] = '********';
                        } else if (typeof masked[key] === 'object' && masked[key] !== null) {
                            masked[key] = this.maskSensitiveData(masked[key]);
                        }
                    }
                }
                
                return masked;
            }
            
            return data;
        },
        
        /**
         * Check if a request should be ignored
         * @param {string} url - The request URL
         * @returns {boolean} Whether to ignore the request
         */
        shouldIgnoreRequest: function(url) {
            if (!url) {
                return true;
            }
            
            // Check against ignore patterns
            for (const pattern of CONFIG.ignorePaths) {
                if (pattern.test(url)) {
                    return true;
                }
            }
            
            return false;
        },
        
        /**
         * Check if body capture should be skipped based on content type
         * @param {string} contentType - The content type
         * @returns {boolean} Whether to skip body capture
         */
        shouldSkipBodyCapture: function(contentType) {
            if (!contentType) {
                return false;
            }
            
            for (const skipType of CONFIG.skipBodyContentTypes) {
                if (contentType.includes(skipType)) {
                    return true;
                }
            }
            
            return false;
        },
        
        /**
         * Add a request to the completed requests list
         * @param {Object} request - The request info
         */
        addCompletedRequest: function(request) {
            // Add to completed requests
            completedRequests.push(request);
            
            // Trim if needed
            if (completedRequests.length > CONFIG.maxRequestHistory) {
                completedRequests.shift();
            }
            
            // Check for similar requests if grouping is enabled
            if (CONFIG.groupSimilarRequests) {
                this.checkForSimilarRequests(request);
            }
        },
        
        /**
         * Check for similar requests and group them
         * @param {Object} request - The request info
         */
        checkForSimilarRequests: function(request) {
            // Only check completed requests
            if (request.state !== 'completed' && request.state !== 'error') {
                return;
            }
            
            // Extract the base URL without query params
            const url = request.url;
            const baseUrl = url.split('?')[0];
            
            // Find similar requests
            const similarRequests = completedRequests.filter(req => {
                const reqBaseUrl = req.url.split('?')[0];
                return req !== request && 
                       reqBaseUrl === baseUrl && 
                       req.method === request.method &&
                       (req.state === 'completed' || req.state === 'error');
            });
            
            if (similarRequests.length >= 2) {
                // Found similar requests
                this.sendEvent({
                    type: 'similarRequests',
                    baseUrl: baseUrl,
                    method: request.method,
                    count: similarRequests.length + 1,
                    requests: [request, ...similarRequests].map(req => this.sanitizeRequest(req)),
                    timestamp: Date.now()
                });
            }
        },
        
        /**
         * Sanitize request info for sending
         * @param {Object} request - The request info
         * @returns {Object} Sanitized request info
         */
        sanitizeRequest: function(request) {
            // Create a clean copy with only the fields we want to send
            const sanitized = {
                id: request.id,
                url: request.url,
                method: request.method,
                type: request.type,
                state: request.state,
                startTime: request.startTime,
                endTime: request.endTime,
                duration: request.duration,
                status: request.status,
                statusText: request.statusText
            };
            
            // Add request headers if available
            if (request.requestHeaders) {
                sanitized.requestHeaders = request.requestHeaders;
            }
            
            // Add response headers if available
            if (request.responseHeaders) {
                sanitized.responseHeaders = request.responseHeaders;
            }
            
            // Add request body if available and not too large
            if (request.requestBody) {
                sanitized.requestBody = request.requestBody;
            }
            
            // Add response body if available and not too large
            if (request.responseBody) {
                sanitized.responseBody = request.responseBody;
            }
            
            // Add processed response if available
            if (request.processedResponse) {
                sanitized.processedResponse = request.processedResponse;
            }
            
            // Add error info if available
            if (request.error) {
                sanitized.error = request.error;
            }
            
            // Add timing info if available
            if (request.timing) {
                sanitized.timing = request.timing;
            }
            
            return sanitized;
        },
        
        /**
         * Sanitize WebSocket info for sending
         * @param {Object} wsInfo - The WebSocket info
         * @returns {Object} Sanitized WebSocket info
         */
        sanitizeWebSocketInfo: function(wsInfo) {
            // Create a clean copy with only the fields we want to send
            const sanitized = {
                id: wsInfo.id,
                url: wsInfo.url,
                protocols: wsInfo.protocols,
                state: wsInfo.state,
                startTime: wsInfo.startTime,
                openTime: wsInfo.openTime,
                closeTime: wsInfo.closeTime,
                messagesSent: wsInfo.messagesSent,
                messagesReceived: wsInfo.messagesReceived,
                type: wsInfo.type
            };
            
            // Add close info if available
            if (wsInfo.closeCode) {
                sanitized.closeCode = wsInfo.closeCode;
                sanitized.closeReason = wsInfo.closeReason;
                sanitized.wasClean = wsInfo.wasClean;
            }
            
            // Add last sent message if available
            if (wsInfo.lastSentMessage) {
                sanitized.lastSentMessage = wsInfo.lastSentMessage;
            }
            
            // Add last received message if available
            if (wsInfo.lastReceivedMessage) {
                sanitized.lastReceivedMessage = wsInfo.lastReceivedMessage;
            }
            
            // Add error info if available
            if (wsInfo.error) {
                sanitized.error = wsInfo.error;
            }
            
            return sanitized;
        },
        
        /**
         * Send an event to the parent application
         * @param {Object} event - The event to send
         */
        sendEvent: function(event) {
            if (CONFIG.throttleEvents) {
                // Add to buffer
                eventBuffer.push(event);
                
                // Set up flush timeout if not already set
                if (!batchTimeout) {
                    batchTimeout = setTimeout(() => {
                        this.flushEvents();
                    }, CONFIG.batchInterval);
                }
            } else {
                // Send immediately
                CONFIG.postMessage(event);
            }
        },
        
        /**
         * Flush all events in the buffer
         */
        flushEvents: function() {
            if (eventBuffer.length === 0) {
                return;
            }
            
            // Send events in batch
            CONFIG.postMessage({
                type: 'eventBatch',
                events: eventBuffer,
                timestamp: Date.now()
            });
            
            // Clear buffer and timeout
            eventBuffer = [];
            batchTimeout = null;
        },
        
        /**
         * Handle incoming messages
         * @param {MessageEvent} event - The message event
         */
        handleMessage: function(event) {
            if (!event.data || event.data.type !== 'CSTestForge_NetworkMonitorCommand') {
                return;
            }
            
            const command = event.data.command;
            
            switch (command) {
                case 'getRequests':
                    this.sendRequests();
                    break;
                    
                case 'clearRequests':
                    this.clearRequests();
                    break;
                    
                case 'disable':
                    this.disable();
                    break;
                    
                case 'enable':
                    this.enable();
                    break;
                    
                case 'updateConfig':
                    this.updateConfig(event.data.config);
                    break;
                    
                default:
                    console.warn('CSTestForge Network Monitor: Unknown command', command);
            }
        },
        
        /**
         * Send all requests to the parent application
         */
        sendRequests: function() {
            // Sanitize all requests
            const sanitizedRequests = completedRequests.map(req => this.sanitizeRequest(req));
            
            // Send requests
            CONFIG.postMessage({
                type: 'allRequests',
                requests: sanitizedRequests,
                timestamp: Date.now()
            });
        },
        
        /**
         * Clear all requests
         */
        clearRequests: function() {
            // Clear all requests
            completedRequests.length = 0;
            
            // Send confirmation
            CONFIG.postMessage({
                type: 'requestsCleared',
                timestamp: Date.now()
            });
        },
        
        /**
         * Disable the network monitor
         */
        disable: function() {
            if (!CONFIG.enabled) {
                return;
            }
            
            // Disable
            CONFIG.enabled = false;
            
            // Restore original methods
            this.restoreOriginals();
            
            // Send confirmation
            CONFIG.postMessage({
                type: 'disabled',
                timestamp: Date.now()
            });
        },
        
        /**
         * Enable the network monitor
         */
        enable: function() {
            if (CONFIG.enabled) {
                return;
            }
            
            // Enable
            CONFIG.enabled = true;
            
            // Re-initialize
            this.saveOriginals();
            
            if (CONFIG.monitorXHR) {
                this.interceptXHR();
            }
            
            if (CONFIG.monitorFetch) {
                this.interceptFetch();
            }
            
            if (CONFIG.monitorBeacons) {
                this.interceptBeacon();
            }
            
            if (CONFIG.monitorWebSockets) {
                this.interceptWebSocket();
            }
            
            // Send confirmation
            CONFIG.postMessage({
                type: 'enabled',
                timestamp: Date.now()
            });
        },
        
        /**
         * Update configuration settings
         * @param {Object} newConfig - New configuration settings
         */
        updateConfig: function(newConfig) {
            let needReinit = false;
            
            // Check if important settings have changed
            if ((newConfig.monitorXHR !== undefined && newConfig.monitorXHR !== CONFIG.monitorXHR) ||
                (newConfig.monitorFetch !== undefined && newConfig.monitorFetch !== CONFIG.monitorFetch) ||
                (newConfig.monitorBeacons !== undefined && newConfig.monitorBeacons !== CONFIG.monitorBeacons) ||
                (newConfig.monitorWebSockets !== undefined && newConfig.monitorWebSockets !== CONFIG.monitorWebSockets)) {
                needReinit = true;
            }
            
            // Update settings
            for (const key in newConfig) {
                if (CONFIG.hasOwnProperty(key)) {
                    CONFIG[key] = newConfig[key];
                }
            }
            
            // Reinitialize if needed
            if (needReinit && CONFIG.enabled) {
                this.restoreOriginals();
                this.saveOriginals();
                
                if (CONFIG.monitorXHR) {
                    this.interceptXHR();
                }
                
                if (CONFIG.monitorFetch) {
                    this.interceptFetch();
                }
                
                if (CONFIG.monitorBeacons) {
                    this.interceptBeacon();
                }
                
                if (CONFIG.monitorWebSockets) {
                    this.interceptWebSocket();
                }
            }
            
            // Send confirmation
            CONFIG.postMessage({
                type: 'configUpdated',
                config: CONFIG,
                timestamp: Date.now()
            });
        }
    };
    
    // Initialize the network monitor
    CSNetworkMonitor.init();
    
    // Make the monitor available for testing or manual use
    window.__CSNetworkMonitor = CSNetworkMonitor;
})();


element-identifier.js
--------------------------------------------

/**
 * element-identifier.js
 * Part of CSTestForge Browser Integration Module
 * 
 * This script is responsible for identifying elements in the DOM, generating
 * robust locator strategies, and providing contextual information for element
 * recognition during recording and playback. It implements advanced algorithms
 * for element fingerprinting and smart locator generation.
 */

(function() {
    'use strict';
    
    // Configuration
    const CONFIG = {
        // Types of locators to generate
        generateIdLocators: true,
        generateCssLocators: true,
        generateXpathLocators: true,
        generateLinkTextLocators: true,
        generateButtonTextLocators: true,
        generateLabelLocators: true,
        generateImageLocators: true,
        generateDataAttributeLocators: true,
        
        // Locator generation options
        preferIds: true,
        preferDataAttributes: true,
        includeIndexesInCss: false,
        includeClassesInCss: true,
        generateRelativeLocators: true,
        
        // Primary brand color for highlighting
        brandColor: '#C54B8C',
        
        // Maximum elements to process in a single batch
        maxBatchSize: 50,
        
        // Maximum depth for CSS selectors
        maxCssSelectorDepth: 5,
        
        // Maximum number of locators to generate per element
        maxLocatorsPerElement: 10,
        
        // Data attributes to use for locator generation
        dataAttributes: [
            'data-testid', 'data-test', 'data-automation', 'data-qa',
            'data-cy', 'data-e2e', 'data-auto', 'data-anchor', 'data-target'
        ],
        
        // Class name patterns to ignore in locators
        ignoreClassPatterns: [
            /^ng-/, /^ui-/, /^mat-/, /^v-/, /^fa-/, /^icon-/, /^ng\d+/,
            /^[a-z]+-[0-9]+$/, /^[a-zA-Z]{1,2}\d+$/, /^[0-9a-f]{6,}$/
        ],
        
        // ID patterns to ignore in locators
        ignoreIdPatterns: [
            /^ember\d+$/, /^ngid\d+/, /^ngfid\d+/, /^[a-z]+-[0-9]+$/,
            /^[a-zA-Z]{1,2}\d+$/, /^[0-9a-f]{6,}$/
        ],
        
        // Element types to identify and their characteristics
        elementTypes: {
            button: {
                tags: ['BUTTON'],
                attributes: {
                    'type': ['button', 'submit', 'reset']
                },
                roles: ['button'],
                classPatterns: [/btn/i, /button/i]
            },
            link: {
                tags: ['A'],
                roles: ['link'],
                attributes: {
                    'href': [/.*/]
                }
            },
            input: {
                tags: ['INPUT'],
                excludeTypes: ['checkbox', 'radio', 'button', 'submit', 'reset']
            },
            checkbox: {
                tags: ['INPUT'],
                attributes: {
                    'type': ['checkbox']
                },
                roles: ['checkbox']
            },
            radio: {
                tags: ['INPUT'],
                attributes: {
                    'type': ['radio']
                },
                roles: ['radio']
            },
            select: {
                tags: ['SELECT'],
                roles: ['listbox', 'combobox']
            },
            textarea: {
                tags: ['TEXTAREA']
            },
            image: {
                tags: ['IMG'],
                roles: ['img']
            },
            label: {
                tags: ['LABEL']
            },
            table: {
                tags: ['TABLE'],
                roles: ['table', 'grid']
            },
            dropdown: {
                roles: ['listbox', 'menu', 'combobox'],
                classPatterns: [/dropdown/i, /select/i, /combo/i]
            },
            menu: {
                roles: ['menu', 'menubar', 'menuitem'],
                classPatterns: [/menu/i, /nav/i]
            },
            dialog: {
                roles: ['dialog', 'alertdialog'],
                classPatterns: [/modal/i, /dialog/i, /popup/i]
            },
            tab: {
                roles: ['tab', 'tablist', 'tabpanel'],
                classPatterns: [/tab/i]
            },
            slider: {
                roles: ['slider'],
                classPatterns: [/slider/i, /range/i]
            },
            toggle: {
                roles: ['switch'],
                classPatterns: [/toggle/i, /switch/i]
            }
        },
        
        // Function to post messages to the parent application
        postMessage: function(message) {
            try {
                window.parent.postMessage({
                    type: 'CSTestForge_ElementIdentifier',
                    data: message,
                    frameId: CSElementIdentifier.frameId,
                    url: window.location.href
                }, '*');
            } catch (e) {
                console.error('CSTestForge Element Identifier: Error sending message', e);
            }
        },
        
        // Relative locator options
        relativeDirections: ['above', 'below', 'toLeftOf', 'toRightOf', 'near'],
        maxRelativeDistance: 100, // pixels
        
        // Accessibility attributes to check
        accessibilityAttributes: [
            'aria-label', 'aria-labelledby', 'aria-describedby',
            'aria-required', 'aria-expanded', 'aria-checked'
        ],
        
        // Maximum length for text-based locators
        maxTextLength: 100,
        
        // Whether to generate unique fingerprints for elements
        generateFingerprints: true,
        
        // Whether to analyze shadow DOM
        analyzeShadowDOM: true,
        
        // Enable machine learning enhancements if available
        useSmartLocators: true,
        
        // Max ancestors to include in selector path
        maxAncestors: 5,
        
        // Highlight duration in milliseconds
        highlightDuration: 2000
    };
    
    // For storing element fingerprints
    const elementFingerprints = new WeakMap();
    
    // For tracking highlighted elements
    const highlightedElements = new Set();
    
    // Unique ID for this frame
    const frameId = 'csframe_' + Math.random().toString(36).substring(2, 15);
    
    /**
     * Element Identifier Implementation
     */
    const CSElementIdentifier = {
        // Frame identifier
        frameId: frameId,
        
        /**
         * Initialize the element identifier
         */
        init: function() {
            // Listen for control messages
            window.addEventListener('message', this.handleMessage.bind(this));
            
            // Pre-process visible elements on the page
            this.processVisibleElements();
            
            // Set up mutation observer to detect new elements
            this.setupMutationObserver();
            
            // Send initialization event
            CONFIG.postMessage({
                type: 'init',
                url: window.location.href,
                title: document.title,
                timestamp: Date.now()
            });
            
            console.log('CSTestForge Element Identifier: Initialized');
        },
        
        /**
         * Process visible elements on the page
         */
        processVisibleElements: function() {
            // Get all elements that might be interactable
            const elements = document.querySelectorAll(
                'a, button, input, select, textarea, [role="button"], [role="link"], ' +
                '[role="checkbox"], [role="radio"], [role="listbox"], [role="combobox"], ' +
                '[role="tab"], [role="menu"], [role="menuitem"], [role="dialog"], ' +
                '[tabindex], [onclick], [href], img[alt]'
            );
            
            // Process elements in batches to avoid blocking the main thread
            this.processElementBatches(Array.from(elements));
        },
        
        /**
         * Process elements in batches
         * @param {Element[]} elements - The elements to process
         */
        processElementBatches: function(elements) {
            const totalElements = elements.length;
            
            // Process in batches
            for (let i = 0; i < totalElements; i += CONFIG.maxBatchSize) {
                const batch = elements.slice(i, i + CONFIG.maxBatchSize);
                
                // Use requestIdleCallback or setTimeout to avoid blocking the main thread
                if (window.requestIdleCallback) {
                    window.requestIdleCallback(() => {
                        this.processElementBatch(batch);
                    });
                } else {
                    setTimeout(() => {
                        this.processElementBatch(batch);
                    }, 0);
                }
            }
        },
        
        /**
         * Process a batch of elements
         * @param {Element[]} elements - The batch of elements to process
         */
        processElementBatch: function(elements) {
            const processedElements = [];
            
            for (const element of elements) {
                // Skip if not visible or interactable
                if (!this.isElementVisible(element) || !this.isElementInteractable(element)) {
                    continue;
                }
                
                // Process the element
                const elementInfo = this.processElement(element);
                
                if (elementInfo) {
                    processedElements.push(elementInfo);
                    
                    // Generate fingerprint if enabled
                    if (CONFIG.generateFingerprints) {
                        const fingerprint = this.generateElementFingerprint(element);
                        elementFingerprints.set(element, fingerprint);
                    }
                }
            }
            
            // Send batch of processed elements
            if (processedElements.length > 0) {
                CONFIG.postMessage({
                    type: 'elements',
                    elements: processedElements,
                    timestamp: Date.now()
                });
            }
        },
        
        /**
         * Process a single element
         * @param {Element} element - The element to process
         * @returns {Object|null} Element information or null if should be skipped
         */
        processElement: function(element) {
            if (!element || !element.tagName) {
                return null;
            }
            
            // Basic element info
            const rect = element.getBoundingClientRect();
            const elementType = this.identifyElementType(element);
            
            const elementInfo = {
                tagName: element.tagName,
                type: elementType,
                id: element.id || null,
                name: element.name || null,
                value: element.value || null,
                className: element.className || null,
                rect: {
                    top: rect.top + window.scrollY,
                    left: rect.left + window.scrollX,
                    width: rect.width,
                    height: rect.height,
                    bottom: rect.bottom + window.scrollY,
                    right: rect.right + window.scrollX
                },
                visible: this.isElementVisible(element),
                enabled: !element.disabled,
                attributes: this.getElementAttributes(element),
                text: this.getElementText(element)
            };
            
            // Generate locators
            elementInfo.locators = this.generateLocators(element, elementType);
            
            // Add parent info
            if (element.parentElement) {
                elementInfo.parent = {
                    tagName: element.parentElement.tagName,
                    id: element.parentElement.id || null,
                    className: element.parentElement.className || null
                };
            }
            
            return elementInfo;
        },
        
        /**
         * Set up mutation observer to detect new elements
         */
        setupMutationObserver: function() {
            const self = this;
            
            // Create mutation observer
            const observer = new MutationObserver((mutations) => {
                // Collect added elements
                const addedElements = [];
                
                for (const mutation of mutations) {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        for (const node of mutation.addedNodes) {
                            // Check if the node is an element
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                addedElements.push(node);
                                
                                // Also collect all interactable descendant elements
                                const descendants = node.querySelectorAll(
                                    'a, button, input, select, textarea, [role="button"], [role="link"], ' +
                                    '[role="checkbox"], [role="radio"], [role="listbox"], [role="combobox"], ' +
                                    '[role="tab"], [role="menu"], [role="menuitem"], [role="dialog"], ' +
                                    '[tabindex], [onclick], [href], img[alt]'
                                );
                                
                                addedElements.push(...Array.from(descendants));
                            }
                        }
                    }
                }
                
                // Process newly added elements
                if (addedElements.length > 0) {
                    // Remove duplicates
                    const uniqueElements = [...new Set(addedElements)];
                    self.processElementBatches(uniqueElements);
                }
                
                // Check for shadow roots in added elements
                if (CONFIG.analyzeShadowDOM) {
                    for (const element of addedElements) {
                        if (element.shadowRoot) {
                            self.processShadowRoot(element);
                        }
                    }
                }
            });
            
            // Observe the entire document
            observer.observe(document.documentElement, {
                childList: true,
                subtree: true
            });
            
            // Check for existing shadow roots
            if (CONFIG.analyzeShadowDOM) {
                this.processExistingShadowRoots();
            }
        },
        
        /**
         * Process existing shadow roots in the document
         */
        processExistingShadowRoots: function() {
            // Find all elements that might have shadow roots
            const elements = document.querySelectorAll('*');
            
            for (const element of elements) {
                if (element.shadowRoot) {
                    this.processShadowRoot(element);
                }
            }
        },
        
        /**
         * Process a shadow root and its contents
         * @param {Element} host - The shadow root host element
         */
        processShadowRoot: function(host) {
            if (!host || !host.shadowRoot) {
                return;
            }
            
            // Get all interactable elements in the shadow DOM
            const shadowElements = host.shadowRoot.querySelectorAll(
                'a, button, input, select, textarea, [role="button"], [role="link"], ' +
                '[role="checkbox"], [role="radio"], [role="listbox"], [role="combobox"], ' +
                '[role="tab"], [role="menu"], [role="menuitem"], [role="dialog"], ' +
                '[tabindex], [onclick], [href], img[alt]'
            );
            
            // Report shadow root
            CONFIG.postMessage({
                type: 'shadowRoot',
                host: {
                    tagName: host.tagName,
                    id: host.id || null,
                    className: host.className || null,
                    locators: this.generateLocators(host, this.identifyElementType(host))
                },
                timestamp: Date.now()
            });
            
            // Process shadow elements
            this.processElementBatches(Array.from(shadowElements));
            
            // Check for nested shadow roots
            for (const element of shadowElements) {
                if (element.shadowRoot) {
                    this.processShadowRoot(element);
                }
            }
        },
        
        /**
         * Handle incoming messages
         * @param {MessageEvent} event - The message event
         */
        handleMessage: function(event) {
            if (!event.data || event.data.type !== 'CSTestForge_ElementIdentifierCommand') {
                return;
            }
            
            const command = event.data.command;
            
            switch (command) {
                case 'highlight':
                    this.highlightElement(event.data.selector, event.data.selectorType);
                    break;
                    
                case 'getElements':
                    this.getAllElements();
                    break;
                    
                case 'findElement':
                    this.findElement(event.data.selector, event.data.selectorType);
                    break;
                
                case 'testLocator':
                    this.testLocator(event.data.locator, event.data.locatorType);
                    break;
                
                case 'analyzeElement':
                    this.analyzeElement(event.data.selector, event.data.selectorType);
                    break;
                
                case 'updateConfig':
                    this.updateConfig(event.data.config);
                    break;
                
                default:
                    console.warn('CSTestForge Element Identifier: Unknown command', command);
            }
        },
        
        /**
         * Highlight an element in the DOM
         * @param {string} selector - The selector string
         * @param {string} selectorType - The type of selector (css/xpath)
         */
        highlightElement: function(selector, selectorType) {
            try {
                // Find the element
                const element = this.findElementBySelector(selector, selectorType);
                
                if (!element) {
                    CONFIG.postMessage({
                        type: 'highlightResult',
                        success: false,
                        error: 'Element not found',
                        selector: selector,
                        selectorType: selectorType,
                        timestamp: Date.now()
                    });
                    return;
                }
                
                // Remove any existing highlights
                this.removeAllHighlights();
                
                // Scroll element into view if needed
                if (!this.isElementInViewport(element)) {
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }
                
                // Create highlight overlay
                const highlight = this.createHighlightOverlay(element);
                
                // Add to highlighted elements
                highlightedElements.add(highlight);
                
                // Set up auto-removal
                setTimeout(() => {
                    if (highlight.parentNode) {
                        highlight.parentNode.removeChild(highlight);
                    }
                    highlightedElements.delete(highlight);
                }, CONFIG.highlightDuration);
                
                // Process element and send result
                const elementInfo = this.processElement(element);
                
                CONFIG.postMessage({
                    type: 'highlightResult',
                    success: true,
                    element: elementInfo,
                    selector: selector,
                    selectorType: selectorType,
                    timestamp: Date.now()
                });
            } catch (e) {
                CONFIG.postMessage({
                    type: 'highlightResult',
                    success: false,
                    error: e.toString(),
                    selector: selector,
                    selectorType: selectorType,
                    timestamp: Date.now()
                });
            }
        },
        
        /**
         * Create a highlight overlay for an element
         * @param {Element} element - The element to highlight
         * @returns {Element} The created highlight overlay
         */
        createHighlightOverlay: function(element) {
            const rect = element.getBoundingClientRect();
            
            // Create highlight element
            const highlight = document.createElement('div');
            
            // Set styles
            highlight.style.position = 'absolute';
            highlight.style.top = (rect.top + window.scrollY) + 'px';
            highlight.style.left = (rect.left + window.scrollX) + 'px';
            highlight.style.width = rect.width + 'px';
            highlight.style.height = rect.height + 'px';
            highlight.style.backgroundColor = `${CONFIG.brandColor}33`;  // 20% opacity
            highlight.style.border = `2px solid ${CONFIG.brandColor}`;
            highlight.style.borderRadius = '3px';
            highlight.style.zIndex = '2147483647';  // Highest possible z-index
            highlight.style.pointerEvents = 'none';  // Don't block interactions
            highlight.style.boxSizing = 'border-box';
            highlight.style.transition = 'all 0.3s ease-in-out';
            highlight.className = 'cs-testforge-highlight';
            
            // Add animation
            highlight.animate([
                { boxShadow: `0 0 0 2px ${CONFIG.brandColor}66` },
                { boxShadow: `0 0 0 6px ${CONFIG.brandColor}00` }
            ], {
                duration: 1000,
                iterations: 2
            });
            
            // Append to document
            document.body.appendChild(highlight);
            
            return highlight;
        },
        
        /**
         * Remove all highlight overlays
         */
        removeAllHighlights: function() {
            // Remove existing highlights
            const existingHighlights = document.querySelectorAll('.cs-testforge-highlight');
            
            for (const highlight of existingHighlights) {
                if (highlight.parentNode) {
                    highlight.parentNode.removeChild(highlight);
                }
            }
            
            // Clear the set
            highlightedElements.clear();
        },
        
        /**
         * Find an element by selector
         * @param {string} selector - The selector string
         * @param {string} selectorType - The type of selector (css/xpath)
         * @returns {Element|null} The found element or null
         */
        findElementBySelector: function(selector, selectorType) {
            if (!selector) {
                return null;
            }
            
            try {
                if (selectorType === 'xpath') {
                    // XPath selector
                    const result = document.evaluate(
                        selector,
                        document,
                        null,
                        XPathResult.FIRST_ORDERED_NODE_TYPE,
                        null
                    );
                    
                    return result.singleNodeValue;
                } else {
                    // CSS selector
                    return document.querySelector(selector);
                }
            } catch (e) {
                console.error('CSTestForge Element Identifier: Error finding element', e);
                return null;
            }
        },
        
        /**
         * Find all elements by selector
         * @param {string} selector - The selector string
         * @param {string} selectorType - The type of selector (css/xpath)
         * @returns {Element[]} Array of found elements
         */
        findAllElementsBySelector: function(selector, selectorType) {
            if (!selector) {
                return [];
            }
            
            try {
                if (selectorType === 'xpath') {
                    // XPath selector
                    const result = document.evaluate(
                        selector,
                        document,
                        null,
                        XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
                        null
                    );
                    
                    const elements = [];
                    for (let i = 0; i < result.snapshotLength; i++) {
                        elements.push(result.snapshotItem(i));
                    }
                    
                    return elements;
                } else {
                    // CSS selector
                    return Array.from(document.querySelectorAll(selector));
                }
            } catch (e) {
                console.error('CSTestForge Element Identifier: Error finding elements', e);
                return [];
            }
        },
        
        /**
         * Get all interactable elements
         */
        getAllElements: function() {
            // Get all interactable elements
            const elements = document.querySelectorAll(
                'a, button, input, select, textarea, [role="button"], [role="link"], ' +
                '[role="checkbox"], [role="radio"], [role="listbox"], [role="combobox"], ' +
                '[role="tab"], [role="menu"], [role="menuitem"], [role="dialog"], ' +
                '[tabindex], [onclick], [href], img[alt]'
            );
            
            // Process elements
            const processedElements = [];
            
            for (const element of elements) {
                // Skip if not visible or interactable
                if (!this.isElementVisible(element) || !this.isElementInteractable(element)) {
                    continue;
                }
                
                // Process the element
                const elementInfo = this.processElement(element);
                
                if (elementInfo) {
                    processedElements.push(elementInfo);
                }
            }
            
            // Send all processed elements
            CONFIG.postMessage({
                type: 'allElements',
                elements: processedElements,
                timestamp: Date.now()
            });
        },
        
        /**
         * Find an element and return details
         * @param {string} selector - The selector string
         * @param {string} selectorType - The type of selector (css/xpath)
         */
        findElement: function(selector, selectorType) {
            try {
                // Find the element
                const element = this.findElementBySelector(selector, selectorType);
                
                if (!element) {
                    CONFIG.postMessage({
                        type: 'findElementResult',
                        success: false,
                        error: 'Element not found',
                        selector: selector,
                        selectorType: selectorType,
                        timestamp: Date.now()
                    });
                    return;
                }
                
                // Process element and send result
                const elementInfo = this.processElement(element);
                
                CONFIG.postMessage({
                    type: 'findElementResult',
                    success: true,
                    element: elementInfo,
                    selector: selector,
                    selectorType: selectorType,
                    timestamp: Date.now()
                });
            } catch (e) {
                CONFIG.postMessage({
                    type: 'findElementResult',
                    success: false,
                    error: e.toString(),
                    selector: selector,
                    selectorType: selectorType,
                    timestamp: Date.now()
                });
            }
        },
        
        /**
         * Test a locator and return all matching elements
         * @param {string} locator - The locator string
         * @param {string} locatorType - The type of locator (css/xpath)
         */
        testLocator: function(locator, locatorType) {
            try {
                // Find all matching elements
                const elements = this.findAllElementsBySelector(locator, locatorType);
                
                // Process elements
                const processedElements = [];
                
                for (const element of elements) {
                    const elementInfo = this.processElement(element);
                    
                    if (elementInfo) {
                        processedElements.push(elementInfo);
                    }
                }
                
                // Send test results
                CONFIG.postMessage({
                    type: 'testLocatorResult',
                    success: true,
                    count: elements.length,
                    elements: processedElements,
                    locator: locator,
                    locatorType: locatorType,
                    timestamp: Date.now()
                });
                
                // Highlight first element if found
                if (elements.length > 0) {
                    this.removeAllHighlights();
                    const highlight = this.createHighlightOverlay(elements[0]);
                    highlightedElements.add(highlight);
                    
                    setTimeout(() => {
                        if (highlight.parentNode) {
                            highlight.parentNode.removeChild(highlight);
                        }
                        highlightedElements.delete(highlight);
                    }, CONFIG.highlightDuration);
                }
            } catch (e) {
                CONFIG.postMessage({
                    type: 'testLocatorResult',
                    success: false,
                    error: e.toString(),
                    locator: locator,
                    locatorType: locatorType,
                    timestamp: Date.now()
                });
            }
        },
        
        /**
         * Perform detailed analysis of an element
         * @param {string} selector - The selector string
         * @param {string} selectorType - The type of selector (css/xpath)
         */
        analyzeElement: function(selector, selectorType) {
            try {
                // Find the element
                const element = this.findElementBySelector(selector, selectorType);
                
                if (!element) {
                    CONFIG.postMessage({
                        type: 'analyzeElementResult',
                        success: false,
                        error: 'Element not found',
                        selector: selector,
                        selectorType: selectorType,
                        timestamp: Date.now()
                    });
                    return;
                }
                
                // Basic element info
                const elementInfo = this.processElement(element);
                
                // Additional analysis
                const analysis = {
                    // Get computed style
                    computedStyle: this.getComputedStyleProperties(element),
                    
                    // Get accessibility info
                    accessibility: this.getAccessibilityInfo(element),
                    
                    // Get positional info
                    position: this.getPositionalInfo(element),
                    
                    // Get event listeners if possible
                    events: this.getElementEvents(element),
                    
                    // Get element context
                    context: this.getElementContext(element),
                    
                    // Get ancestor chain
                    ancestors: this.getAncestorChain(element),
                    
                    // Get similar elements
                    similarElements: this.findSimilarElements(element),
                    
                    // Get uniqueness score
                    uniquenessScore: this.calculateUniquenessScore(element),
                    
                    // Get element fingerprint if available
                    fingerprint: elementFingerprints.get(element) || this.generateElementFingerprint(element)
                };
                
                // Send analysis results
                CONFIG.postMessage({
                    type: 'analyzeElementResult',
                    success: true,
                    element: elementInfo,
                    analysis: analysis,
                    selector: selector,
                    selectorType: selectorType,
                    timestamp: Date.now()
                });
                
                // Highlight the element
                this.removeAllHighlights();
                const highlight = this.createHighlightOverlay(element);
                highlightedElements.add(highlight);
                
                setTimeout(() => {
                    if (highlight.parentNode) {
                        highlight.parentNode.removeChild(highlight);
                    }
                    highlightedElements.delete(highlight);
                }, CONFIG.highlightDuration);
            } catch (e) {
                CONFIG.postMessage({
                    type: 'analyzeElementResult',
                    success: false,
                    error: e.toString(),
                    selector: selector,
                    selectorType: selectorType,
                    timestamp: Date.now()
                });
            }
        },
        
        /**
         * Update configuration settings
         * @param {Object} newConfig - New configuration settings
         */
        updateConfig: function(newConfig) {
            // Update settings
            for (const key in newConfig) {
                if (CONFIG.hasOwnProperty(key)) {
                    CONFIG[key] = newConfig[key];
                }
            }
            
            // Send confirmation
            CONFIG.postMessage({
                type: 'configUpdated',
                timestamp: Date.now()
            });
        },
        
        /**
         * Get computed style properties for an element
         * @param {Element} element - The element
         * @returns {Object} Object with style properties
         */
        getComputedStyleProperties: function(element) {
            const computed = window.getComputedStyle(element);
            
            return {
                display: computed.display,
                position: computed.position,
                visibility: computed.visibility,
                width: computed.width,
                height: computed.height,
                color: computed.color,
                backgroundColor: computed.backgroundColor,
                fontSize: computed.fontSize,
                fontWeight: computed.fontWeight,
                zIndex: computed.zIndex,
                opacity: computed.opacity,
                cursor: computed.cursor
            };
        },
        
        /**
         * Get accessibility information for an element
         * @param {Element} element - The element
         * @returns {Object} Object with accessibility info
         */
        getAccessibilityInfo: function(element) {
            const info = {
                role: element.getAttribute('role') || this.getImplicitRole(element),
                tabIndex: element.hasAttribute('tabindex') ? element.getAttribute('tabindex') : null,
                focusable: this.isElementFocusable(element),
                hasFocus: document.activeElement === element
            };
            
            // Add ARIA attributes
            for (const attr of CONFIG.accessibilityAttributes) {
                if (element.hasAttribute(attr)) {
                    info[attr] = element.getAttribute(attr);
                }
            }
            
            // Check if element has label
            const labelledBy = element.getAttribute('aria-labelledby');
            if (labelledBy) {
                const labelElement = document.getElementById(labelledBy);
                if (labelElement) {
                    info.labelledByText = labelElement.textContent;
                }
            }
            
            // Check for associated label element
            if (element.id) {
                const label = document.querySelector(`label[for="${element.id}"]`);
                if (label) {
                    info.labelText = label.textContent;
                }
            }
            
            return info;
        },
        
        /**
         * Get implicit ARIA role based on element type
         * @param {Element} element - The element
         * @returns {string|null} The implicit role or null
         */
        getImplicitRole: function(element) {
            const tagName = element.tagName.toLowerCase();
            
            // Map of elements to their implicit roles
            const roleMap = {
                'a': element.hasAttribute('href') ? 'link' : null,
                'button': 'button',
                'h1': 'heading',
                'h2': 'heading',
                'h3': 'heading',
                'h4': 'heading',
                'h5': 'heading',
                'h6': 'heading',
                'img': 'img',
                'input': (() => {
                    const type = element.type ? element.type.toLowerCase() : 'text';
                    
                    switch (type) {
                        case 'button':
                        case 'image':
                        case 'reset':
                        case 'submit':
                            return 'button';
                        case 'checkbox':
                            return 'checkbox';
                        case 'radio':
                            return 'radio';
                        case 'range':
                            return 'slider';
                        case 'email':
                        case 'password':
                        case 'search':
                        case 'tel':
                        case 'text':
                        case 'url':
                            return 'textbox';
                        default:
                            return null;
                    }
                })(),
                'select': element.multiple ? 'listbox' : 'combobox',
                'textarea': 'textbox',
                'ul': 'list',
                'ol': 'list',
                'li': 'listitem',
                'table': 'table',
                'tr': 'row',
                'td': 'cell',
                'th': 'columnheader',
                'nav': 'navigation',
                'main': 'main',
                'form': 'form',
                'article': 'article',
                'section': 'region',
                'aside': 'complementary',
                'footer': 'contentinfo',
                'header': 'banner'
            };
            
            return roleMap[tagName] || null;
        },
        
        /**
         * Get positional information for an element
         * @param {Element} element - The element
         * @returns {Object} Object with positional info
         */
        getPositionalInfo: function(element) {
            const rect = element.getBoundingClientRect();
            
            return {
                inViewport: this.isElementInViewport(element),
                viewportPercentage: this.getViewportPercentage(rect),
                distanceFromTop: rect.top + window.scrollY,
                distanceFromLeft: rect.left + window.scrollX,
                centerX: rect.left + rect.width / 2,
                centerY: rect.top + rect.height / 2,
                nearbyElements: this.getNearbyElements(element)
            };
        },
        
        /**
         * Get nearby elements for relative locators
         * @param {Element} element - The element
         * @returns {Object} Object with nearby elements
         */
        getNearbyElements: function(element) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const nearby = {
                above: [],
                below: [],
                toLeftOf: [],
                toRightOf: []
            };
            
            // Get all visible elements
            const allElements = Array.from(document.querySelectorAll('*')).filter(
                el => this.isElementVisible(el) && el !== element
            );
            
            // Find nearby elements in each direction
            for (const el of allElements) {
                const elRect = el.getBoundingClientRect();
                const elCenterX = elRect.left + elRect.width / 2;
                const elCenterY = elRect.top + elRect.height / 2;
                
                // Calculate distance
                const distance = Math.sqrt(
                    Math.pow(centerX - elCenterX, 2) + 
                    Math.pow(centerY - elCenterY, 2)
                );
                
                // Only include elements within the max distance
                if (distance > CONFIG.maxRelativeDistance) {
                    continue;
                }
                
                // Determine direction
                if (elCenterY < centerY - rect.height / 2) {
                    nearby.above.push({
                        element: {
                            tagName: el.tagName,
                            id: el.id || null,
                            className: el.className || null,
                            text: this.getElementText(el)
                        },
                        distance: distance
                    });
                } else if (elCenterY > centerY + rect.height / 2) {
                    nearby.below.push({
                        element: {
                            tagName: el.tagName,
                            id: el.id || null,
                            className: el.className || null,
                            text: this.getElementText(el)
                        },
                        distance: distance
                    });
                }
                
                if (elCenterX < centerX - rect.width / 2) {
                    nearby.toLeftOf.push({
                        element: {
                            tagName: el.tagName,
                            id: el.id || null,
                            className: el.className || null,
                            text: this.getElementText(el)
                        },
                        distance: distance
                    });
                } else if (elCenterX > centerX + rect.width / 2) {
                    nearby.toRightOf.push({
                        element: {
                            tagName: el.tagName,
                            id: el.id || null,
                            className: el.className || null,
                            text: this.getElementText(el)
                        },
                        distance: distance
                    });
                }
            }
            
            // Sort elements by distance and take top 3
            for (const direction in nearby) {
                nearby[direction].sort((a, b) => a.distance - b.distance);
                nearby[direction] = nearby[direction].slice(0, 3);
            }
            
            return nearby;
        },
        
        /**
         * Get viewport percentage occupied by element
         * @param {DOMRect} rect - The element's bounding rect
         * @returns {number} Percentage of viewport occupied
         */
        getViewportPercentage: function(rect) {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Calculate visible area
            const left = Math.max(0, rect.left);
            const top = Math.max(0, rect.top);
            const right = Math.min(viewportWidth, rect.right);
            const bottom = Math.min(viewportHeight, rect.bottom);
            
            // Calculate visible width and height
            const visibleWidth = Math.max(0, right - left);
            const visibleHeight = Math.max(0, bottom - top);
            
            // Calculate visible area
            const visibleArea = visibleWidth * visibleHeight;
            
            // Calculate viewport area
            const viewportArea = viewportWidth * viewportHeight;
            
            // Calculate percentage
            return (visibleArea / viewportArea) * 100;
        },
        
        /**
         * Get element event listeners if possible
         * @param {Element} element - The element
         * @returns {Object|null} Object with event info or null
         */
        getElementEvents: function(element) {
            // This is tricky as there's no standard API to get event listeners
            // We'll check for common inline events
            const inlineEvents = ['onclick', 'onchange', 'onfocus', 'onblur', 'onkeydown', 
                                 'onkeyup', 'onkeypress', 'onmousedown', 'onmouseup', 
                                 'onmouseover', 'onmouseout', 'onload', 'onsubmit'];
            
            const events = {};
            let hasEvents = false;
            
            for (const eventName of inlineEvents) {
                if (element.hasAttribute(eventName)) {
                    events[eventName] = element.getAttribute(eventName);
                    hasEvents = true;
                }
            }
            
            // Check if element has class names that suggest JS interactions
            const interactiveClassPatterns = [
                /active/i, /btn/i, /button/i, /click/i, /control/i, 
                /draggable/i, /dropdown/i, /editable/i, /expandable/i,
                /menu/i, /selectable/i, /slider/i, /sortable/i, /toggle/i
            ];
            
            const className = element.className || '';
            
            for (const pattern of interactiveClassPatterns) {
                if (pattern.test(className)) {
                    events.suggestiveClasses = events.suggestiveClasses || [];
                    events.suggestiveClasses.push(className.match(pattern)[0]);
                    hasEvents = true;
                }
            }
            
            // Check for event handler properties (only works in some browsers)
            try {
                const handlers = ['onclick', 'onchange', 'onfocus', 'onblur'];
                
                for (const handler of handlers) {
                    if (element[handler]) {
                        events[handler] = 'Function defined';
                        hasEvents = true;
                    }
                }
            } catch (e) {
                // Ignore errors
            }
            
            return hasEvents ? events : null;
        },
        
        /**
         * Get element context information
         * @param {Element} element - The element
         * @returns {Object} Object with context info
         */
        getElementContext: function(element) {
            // Get parent info
            const parentInfo = element.parentElement ? {
                tagName: element.parentElement.tagName,
                id: element.parentElement.id || null,
                className: element.parentElement.className || null,
                text: this.getElementText(element.parentElement)
            } : null;
            
            // Get siblings with text
            const siblings = [];
            
            if (element.parentElement) {
                const children = Array.from(element.parentElement.children);
                
                for (const child of children) {
                    if (child !== element) {
                        const text = this.getElementText(child);
                        
                        if (text) {
                            siblings.push({
                                tagName: child.tagName,
                                id: child.id || null,
                                className: child.className || null,
                                text: text
                            });
                        }
                    }
                }
            }
            
            // Get closest heading if available
            const closestHeading = this.findClosestHeading(element);
            
            // Get form info if element is in a form
            const formInfo = this.getFormInfo(element);
            
            return {
                parent: parentInfo,
                siblings: siblings.slice(0, 5),  // Limit to 5 siblings
                closestHeading: closestHeading,
                form: formInfo
            };
        },
        
        /**
         * Find the closest heading element
         * @param {Element} element - The starting element
         * @returns {Object|null} Heading info or null
         */
        findClosestHeading: function(element) {
            // Look for h1-h6 elements that appear before this element
            const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'));
            
            // Convert element's position to a number for comparison
            const elementPosition = this.getElementPosition(element);
            
            let closestHeading = null;
            let closestDistance = Infinity;
            
            for (const heading of headings) {
                const headingPosition = this.getElementPosition(heading);
                
                // Only consider headings that appear before the element
                if (headingPosition < elementPosition) {
                    const distance = elementPosition - headingPosition;
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestHeading = heading;
                    }
                }
            }
            
            if (closestHeading) {
                return {
                    tagName: closestHeading.tagName,
                    id: closestHeading.id || null,
                    className: closestHeading.className || null,
                    text: this.getElementText(closestHeading),
                    level: parseInt(closestHeading.tagName.substring(1), 10)
                };
            }
            
            return null;
        },
        
        /**
         * Get an element's position in the document
         * @param {Element} element - The element
         * @returns {number} Position value for comparison
         */
        getElementPosition: function(element) {
            // Use getBoundingClientRect for an accurate position
            const rect = element.getBoundingClientRect();
            return rect.top + window.scrollY;
        },
        
        /**
         * Get form information if element is in a form
         * @param {Element} element - The element
         * @returns {Object|null} Form info or null
         */
        getFormInfo: function(element) {
            // Check if element is in a form
            const form = element.closest('form');
            
            if (!form) {
                return null;
            }
            
            // Get form elements
            const formElements = [];
            const inputs = form.querySelectorAll('input, select, textarea, button');
            
            for (const input of inputs) {
                if (input !== element) {
                    formElements.push({
                        tagName: input.tagName,
                        type: input.type || null,
                        id: input.id || null,
                        name: input.name || null,
                        value: input.value || null
                    });
                }
            }
            
            return {
                id: form.id || null,
                name: form.name || null,
                action: form.action || null,
                method: form.method || null,
                elements: formElements.slice(0, 10)  // Limit to 10 elements
            };
        },
        
        /**
         * Get ancestor chain for an element
         * @param {Element} element - The element
         * @returns {Object[]} Array of ancestor elements
         */
        getAncestorChain: function(element) {
            const ancestors = [];
            let current = element.parentElement;
            let depth = 0;
            
            while (current && depth < CONFIG.maxAncestors) {
                ancestors.push({
                    tagName: current.tagName,
                    id: current.id || null,
                    className: current.className || null,
                    attributes: this.getElementAttributes(current),
                    locators: this.generateLocators(current, this.identifyElementType(current))
                });
                
                current = current.parentElement;
                depth++;
            }
            
            return ancestors;
        },
        
        /**
         * Find similar elements to the given element
         * @param {Element} element - The element
         * @returns {Object[]} Array of similar elements
         */
        findSimilarElements: function(element) {
            const elementType = this.identifyElementType(element);
            const tagName = element.tagName.toLowerCase();
            let similarSelector;
            
            // Build a selector for similar elements
            if (elementType !== 'unknown') {
                // Use role if available
                const role = element.getAttribute('role');
                if (role) {
                    similarSelector = `[role="${role}"]`;
                } else {
                    // Use tag and class name patterns
                    const classNames = Array.from(element.classList);
                    const classSelectors = [];
                    
                    for (const className of classNames) {
                        // Skip classes that match ignore patterns
                        let shouldIgnore = false;
                        for (const pattern of CONFIG.ignoreClassPatterns) {
                            if (pattern.test(className)) {
                                shouldIgnore = true;
                                break;
                            }
                        }
                        
                        if (!shouldIgnore) {
                            classSelectors.push(`.${className}`);
                        }
                    }
                    
                    if (classSelectors.length > 0) {
                        similarSelector = `${tagName}${classSelectors.join('')}`;
                    } else {
                        similarSelector = tagName;
                    }
                }
            } else {
                // Just use the tag name
                similarSelector = tagName;
            }
            
            // Find similar elements
            const similarElements = [];
            
            try {
                const elements = document.querySelectorAll(similarSelector);
                
                for (const el of elements) {
                    if (el !== element && this.isElementVisible(el)) {
                        similarElements.push({
                            tagName: el.tagName,
                            id: el.id || null,
                            className: el.className || null,
                            text: this.getElementText(el),
                            locators: this.generateLocators(el, this.identifyElementType(el))
                        });
                        
                        // Limit to 5 similar elements
                        if (similarElements.length >= 5) {
                            break;
                        }
                    }
                }
            } catch (e) {
                // Invalid selector, return empty array
            }
            
            return similarElements;
        },
        
        /**
         * Calculate uniqueness score for an element
         * @param {Element} element - The element
         * @returns {Object} Uniqueness scores
         */
        calculateUniquenessScore: function(element) {
            const scores = {
                overall: 0,
                idScore: 0,
                classScore: 0,
                attributeScore: 0,
                textScore: 0,
                positionScore: 0
            };
            
            // ID score (highest priority)
            if (element.id) {
                const idElements = document.querySelectorAll(`#${CSS.escape(element.id)}`);
                scores.idScore = idElements.length === 1 ? 100 : 100 / idElements.length;
            }
            
            // Class score
            if (element.className) {
                const classes = Array.from(element.classList);
                let bestClassScore = 0;
                
                for (const className of classes) {
                    // Skip classes that match ignore patterns
                    let shouldIgnore = false;
                    for (const pattern of CONFIG.ignoreClassPatterns) {
                        if (pattern.test(className)) {
                            shouldIgnore = true;
                            break;
                        }
                    }
                    
                    if (shouldIgnore) {
                        continue;
                    }
                    
                    const classElements = document.querySelectorAll(`.${CSS.escape(className)}`);
                    const classScore = 50 / classElements.length;
                    
                    if (classScore > bestClassScore) {
                        bestClassScore = classScore;
                    }
                }
                
                scores.classScore = bestClassScore;
            }
            
            // Attribute score
            const dataAttributes = Object.entries(this.getElementAttributes(element))
                .filter(([key]) => CONFIG.dataAttributes.some(attr => key.startsWith(attr)));
            
            if (dataAttributes.length > 0) {
                let bestAttributeScore = 0;
                
                for (const [key, value] of dataAttributes) {
                    const attrElements = document.querySelectorAll(`[${key}="${CSS.escape(value)}"]`);
                    const attrScore = 80 / attrElements.length;
                    
                    if (attrScore > bestAttributeScore) {
                        bestAttributeScore = attrScore;
                    }
                }
                
                scores.attributeScore = bestAttributeScore;
            }
            
            // Text score
            const text = this.getElementText(element);
            if (text) {
                // Use XPath to find elements with this text
                try {
                    const result = document.evaluate(
                        `//*[contains(text(), '${text.replace(/'/g, "\\'")}')]`,
                        document,
                        null,
                        XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
                        null
                    );
                    
                    scores.textScore = result.snapshotLength === 1 ? 70 : 70 / result.snapshotLength;
                } catch (e) {
                    // XPath error, set to 0
                    scores.textScore = 0;
                }
            }
            
            // Position score (lowest priority)
            // This depends on how specific the XPath is
            try {
                const xpath = this.generateXPath(element);
                const result = document.evaluate(
                    xpath,
                    document,
                    null,
                    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
                    null
                );
                
                scores.positionScore = result.snapshotLength === 1 ? 40 : 40 / result.snapshotLength;
            } catch (e) {
                // XPath error, set to 0
                scores.positionScore = 0;
            }
            
            // Overall score (weighted average)
            scores.overall = Math.max(
                scores.idScore,
                (scores.attributeScore * 0.8 + scores.textScore * 0.7 + scores.classScore * 0.5 + scores.positionScore * 0.4) / 2.4
            );
            
            return scores;
        },
        
        /**
         * Generate a unique fingerprint for an element
         * @param {Element} element - The element
         * @returns {string} Element fingerprint
         */
        generateElementFingerprint: function(element) {
            if (!element) {
                return '';
            }
            
            // Combine various properties for a unique fingerprint
            const properties = [
                element.tagName,
                element.id || '',
                element.className || '',
                element.name || '',
                this.getElementText(element) || '',
                element.getAttribute('role') || ''
            ];
            
            // Add rectangle info
            const rect = element.getBoundingClientRect();
            properties.push(`${Math.round(rect.width)}x${Math.round(rect.height)}`);
            
            // Add key attributes
            for (const attr of CONFIG.dataAttributes) {
                properties.push(element.getAttribute(attr) || '');
            }
            
            // Add parent info
            if (element.parentElement) {
                properties.push(element.parentElement.tagName);
                properties.push(element.parentElement.id || '');
                properties.push(element.parentElement.className || '');
            }
            
            // Join and hash
            const fingerprint = properties.join('|');
            
            // Create a simple hash
            let hash = 0;
            for (let i = 0; i < fingerprint.length; i++) {
                const char = fingerprint.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            
            return `fp_${Math.abs(hash).toString(36)}`;
        },
        
        /**
         * Identify element type based on attributes and context
         * @param {Element} element - The element
         * @returns {string} Element type
         */
        identifyElementType: function(element) {
            if (!element || !element.tagName) {
                return 'unknown';
            }
            
            const tagName = element.tagName.toUpperCase();
            const role = element.getAttribute('role');
            
            // Check each element type
            for (const [type, definition] of Object.entries(CONFIG.elementTypes)) {
                // Check tags
                if (definition.tags && definition.tags.includes(tagName)) {
                    // Check if we need to exclude based on type (for INPUT elements)
                    if (definition.excludeTypes && tagName === 'INPUT') {
                        const inputType = (element.getAttribute('type') || '').toLowerCase();
                        if (definition.excludeTypes.includes(inputType)) {
                            continue;
                        }
                    }
                    
                    // Check attributes
                    let hasRequiredAttributes = true;
                    
                    if (definition.attributes) {
                        for (const [attr, values] of Object.entries(definition.attributes)) {
                            const attrValue = (element.getAttribute(attr) || '').toLowerCase();
                            
                            if (!values.some(value => {
                                if (value instanceof RegExp) {
                                    return value.test(attrValue);
                                } else {
                                    return value === attrValue;
                                }
                            })) {
                                hasRequiredAttributes = false;
                                break;
                            }
                        }
                    }
                    
                    if (hasRequiredAttributes) {
                        return type;
                    }
                }
                
                // Check roles
                if (definition.roles && role && definition.roles.includes(role.toLowerCase())) {
                    return type;
                }
                
                // Check class patterns
                if (definition.classPatterns && element.className) {
                    for (const pattern of definition.classPatterns) {
                        if (pattern.test(element.className)) {
                            return type;
                        }
                    }
                }
            }
            
            // Fallback to tag-based identification
            switch (tagName) {
                case 'BUTTON':
                case 'A':
                case 'INPUT':
                case 'SELECT':
                case 'TEXTAREA':
                case 'IMG':
                case 'LABEL':
                case 'TABLE':
                    return tagName.toLowerCase();
                default:
                    // Check if it's a "clickable" div/span
                    if ((tagName === 'DIV' || tagName === 'SPAN') && 
                        (element.onclick || element.getAttribute('onclick') || 
                         window.getComputedStyle(element).cursor === 'pointer')) {
                        return 'button';
                    }
                    return 'unknown';
            }
        },
        
        /**
         * Generate locators for an element
         * @param {Element} element - The element
         * @param {string} elementType - The element type
         * @returns {Object} Object with locator strategies
         */
        generateLocators: function(element, elementType) {
            const locators = {};
            
            // ID locator - highest priority
            if (CONFIG.generateIdLocators && element.id) {
                // Check if ID should be ignored
                let shouldIgnore = false;
                for (const pattern of CONFIG.ignoreIdPatterns) {
                    if (pattern.test(element.id)) {
                        shouldIgnore = true;
                        break;
                    }
                }
                
                if (!shouldIgnore) {
                    locators.id = {
                        strategy: 'id',
                        value: element.id,
                        robust: true,
                        css: `#${CSS.escape(element.id)}`,
                        xpath: `//*[@id="${element.id}"]`
                    };
                }
            }
            
            // Data attribute locators - very high priority
            if (CONFIG.generateDataAttributeLocators) {
                for (const attr of CONFIG.dataAttributes) {
                    if (element.hasAttribute(attr)) {
                        const value = element.getAttribute(attr);
                        
                        locators[attr] = {
                            strategy: 'attribute',
                            attribute: attr,
                            value: value,
                            robust: true,
                            css: `[${attr}="${CSS.escape(value)}"]`,
                            xpath: `//*[@${attr}="${value}"]`
                        };
                        
                        // Break after finding first data attribute if preferring them
                        if (CONFIG.preferDataAttributes) {
                            break;
                        }
                    }
                }
            }
            
            // Type-specific locators
            switch (elementType) {
                case 'link':
                    // Link text locator
                    if (CONFIG.generateLinkTextLocators) {
                        const text = this.getElementText(element);
                        
                        if (text) {
                            locators.linkText = {
                                strategy: 'linkText',
                                value: text,
                                robust: true,
                                css: null, // No direct CSS equivalent
                                xpath: `//a[contains(text(),"${text}")]`
                            };
                        }
                    }
                    break;
                    
                case 'button':
                    // Button text locator
                    if (CONFIG.generateButtonTextLocators) {
                        const text = this.getElementText(element);
                        
                        if (text) {
                            locators.buttonText = {
                                strategy: 'text',
                                value: text,
                                robust: true,
                                css: null, // No direct CSS equivalent
                                xpath: `//*[self::button or @role="button"][contains(text(),"${text}")]`
                            };
                        }
                    }
                    break;
                    
                case 'input':
                case 'select':
                case 'textarea':
                    // Label locator
                    if (CONFIG.generateLabelLocators && element.id) {
                        const label = document.querySelector(`label[for="${element.id}"]`);
                        
                        if (label) {
                            const labelText = this.getElementText(label);
                            
                            if (labelText) {
                                locators.label = {
                                    strategy: 'labelText',
                                    value: labelText,
                                    robust: true,
                                    css: null, // No direct CSS equivalent
                                    xpath: `//label[contains(text(),"${labelText}")]`
                                };
                            }
                        }
                    }
                    
                    // Name attribute
                    if (element.name) {
                        locators.name = {
                            strategy: 'attribute',
                            attribute: 'name',
                            value: element.name,
                            robust: true,
                            css: `${element.tagName.toLowerCase()}[name="${CSS.escape(element.name)}"]`,
                            xpath: `//${element.tagName.toLowerCase()}[@name="${element.name}"]`
                        };
                    }
                    break;
                    
                case 'image':
                    // Image locator
                    if (CONFIG.generateImageLocators && element.alt) {
                        locators.alt = {
                            strategy: 'attribute',
                            attribute: 'alt',
                            value: element.alt,
                            robust: true,
                            css: `img[alt="${CSS.escape(element.alt)}"]`,
                            xpath: `//img[@alt="${element.alt}"]`
                        };
                    }
                    break;
            }
            
            // CSS locator
            if (CONFIG.generateCssLocators) {
                const cssSelector = this.generateCssSelector(element);
                
                locators.css = {
                    strategy: 'css',
                    value: cssSelector,
                    robust: this.isSelectorRobust(cssSelector, 'css'),
                    css: cssSelector,
                    xpath: null
                };
            }
            
            // XPath locator
            if (CONFIG.generateXpathLocators) {
                const xpathSelector = this.generateXPath(element);
                
                locators.xpath = {
                    strategy: 'xpath',
                    value: xpathSelector,
                    robust: this.isSelectorRobust(xpathSelector, 'xpath'),
                    css: null,
                    xpath: xpathSelector
                };
            }
            
            // Relative locators
            if (CONFIG.generateRelativeLocators) {
                const relativeLocators = this.generateRelativeLocators(element);
                
                if (Object.keys(relativeLocators).length > 0) {
                    locators.relative = relativeLocators;
                }
            }
            
            return locators;
        },
        
        /**
         * Generate a CSS selector for an element
         * @param {Element} element - The element
         * @returns {string} CSS selector
         */
        generateCssSelector: function(element) {
            if (!element) {
                return '';
            }
            
            // If element has ID, use it
            if (element.id) {
                // Check if ID should be ignored
                let shouldIgnore = false;
                for (const pattern of CONFIG.ignoreIdPatterns) {
                    if (pattern.test(element.id)) {
                        shouldIgnore = true;
                        break;
                    }
                }
                
                if (!shouldIgnore) {
                    return `#${CSS.escape(element.id)}`;
                }
            }
            
            // If element has data attributes, use first one
            if (CONFIG.preferDataAttributes) {
                for (const attr of CONFIG.dataAttributes) {
                    if (element.hasAttribute(attr)) {
                        return `[${attr}="${CSS.escape(element.getAttribute(attr))}"]`;
                    }
                }
            }
            
            // Build a path of ancestors
            let current = element;
            const path = [];
            
            while (current && path.length < CONFIG.maxCssSelectorDepth) {
                // Skip if we're at the root
                if (current === document.documentElement || current === document.body) {
                    path.unshift(current.tagName.toLowerCase());
                    break;
                }
                
                // Start with tag name
                let selector = current.tagName.toLowerCase();
                
                // Add ID if available and not ignored
                if (current.id) {
                    let shouldIgnore = false;
                    for (const pattern of CONFIG.ignoreIdPatterns) {
                        if (pattern.test(current.id)) {
                            shouldIgnore = true;
                            break;
                        }
                    }
                    
                    if (!shouldIgnore) {
                        selector = `${selector}#${CSS.escape(current.id)}`;
                        path.unshift(selector);
                        break;  // ID is unique, stop here
                    }
                }
                
                // Add classes if enabled and available
                if (CONFIG.includeClassesInCss && current.classList.length > 0) {
                    const classes = Array.from(current.classList)
                        .filter(cls => {
                            // Filter out classes that match ignore patterns
                            for (const pattern of CONFIG.ignoreClassPatterns) {
                                if (pattern.test(cls)) {
                                    return false;
                                }
                            }
                            return true;
                        })
                        .map(cls => `.${CSS.escape(cls)}`)
                        .join('');
                    
                    if (classes) {
                        selector += classes;
                    }
                }
                
                // Add index if enabled or if selector alone is not unique
                if (CONFIG.includeIndexesInCss || !this.isSelectorUnique(selector)) {
                    // Get all siblings with same tag
                    const parent = current.parentElement;
                    
                    if (parent) {
                        const siblings = Array.from(parent.children).filter(
                            child => child.tagName === current.tagName
                        );
                        
                        if (siblings.length > 1) {
                            // Get 1-based index
                            const index = siblings.indexOf(current) + 1;
                            selector += `:nth-child(${index})`;
                        }
                    }
                }
                
                path.unshift(selector);
                
                // Stop here if this selector is unique
                if (this.isSelectorUnique(path.join(' > '))) {
                    break;
                }
                
                // Move up to parent
                current = current.parentElement;
            }
            
            return path.join(' > ');
        },
        
        /**
         * Generate an XPath for an element
         * @param {Element} element - The element
         * @returns {string} XPath selector
         */
        generateXPath: function(element) {
            if (!element) {
                return '';
            }
            
            // If element has ID, use it
            if (element.id) {
                // Check if ID should be ignored
                let shouldIgnore = false;
                for (const pattern of CONFIG.ignoreIdPatterns) {
                    if (pattern.test(element.id)) {
                        shouldIgnore = true;
                        break;
                    }
                }
                
                if (!shouldIgnore) {
                    return `//*[@id="${element.id}"]`;
                }
            }
            
            // If element has data attributes, use first one
            if (CONFIG.preferDataAttributes) {
                for (const attr of CONFIG.dataAttributes) {
                    if (element.hasAttribute(attr)) {
                        return `//*[@${attr}="${element.getAttribute(attr)}"]`;
                    }
                }
            }
            
            // Check for special cases by element type
            const elementType = this.identifyElementType(element);
            
            switch (elementType) {
                case 'link':
                    // Check for link text
                    const linkText = this.getElementText(element);
                    if (linkText) {
                        return `//a[contains(text(),"${linkText}")]`;
                    }
                    break;
                    
                case 'button':
                    // Check for button text
                    const buttonText = this.getElementText(element);
                    if (buttonText) {
                        return `//*[self::button or @role="button"][contains(text(),"${buttonText}")]`;
                    }
                    break;
                    
                case 'input':
                case 'select':
                case 'textarea':
                    // Check for name attribute
                    if (element.name) {
                        return `//${element.tagName.toLowerCase()}[@name="${element.name}"]`;
                    }
                    
                    // Check for label
                    if (element.id) {
                        const label = document.querySelector(`label[for="${element.id}"]`);
                        if (label) {
                            const labelText = this.getElementText(label);
                            if (labelText) {
                                return `//label[contains(text(),"${labelText}")]/following::${element.tagName.toLowerCase()}`;
                            }
                        }
                    }
                    break;
                    
                case 'image':
                    // Check for alt attribute
                    if (element.alt) {
                        return `//img[@alt="${element.alt}"]`;
                    }
                    break;
            }
            
            // Generate a full path
            let current = element;
            let path = '';
            
            while (current && current.nodeType === Node.ELEMENT_NODE) {
                let position = 1;
                let sibling = current.previousSibling;
                
                // Count previous siblings of same type
                while (sibling) {
                    if (sibling.nodeType === Node.ELEMENT_NODE && 
                        sibling.tagName === current.tagName) {
                        position++;
                    }
                    sibling = sibling.previousSibling;
                }
                
                // Add to path
                const tagName = current.tagName.toLowerCase();
                
                if (position === 1) {
                    path = `/${tagName}${path}`;
                } else {
                    path = `/${tagName}[${position}]${path}`;
                }
                
                current = current.parentNode;
                
                // Stop at document
                if (current === document) {
                    break;
                }
            }
            
            return path;
        },
        
        /**
         * Generate relative locators for an element
         * @param {Element} element - The element
         * @returns {Object} Object with relative locators
         */
        generateRelativeLocators: function(element) {
            if (!element) {
                return {};
            }
            
            const rect = element.getBoundingClientRect();
            const locators = {};
            
            // Find elements for each relative direction
            for (const direction of CONFIG.relativeDirections) {
                const candidates = this.findCandidatesInDirection(element, direction, rect);
                
                if (candidates.length > 0) {
                    // Use the closest one
                    const closest = candidates[0];
                    
                    // Only use if it has a robust locator
                    const candidateLocators = this.generateLocators(closest.element, this.identifyElementType(closest.element));
                    let robustLocator = null;
                    
                    // Find best robust locator
                    if (candidateLocators.id && candidateLocators.id.robust) {
                        robustLocator = candidateLocators.id;
                    } else {
                        // Check data attributes
                        for (const attr of CONFIG.dataAttributes) {
                            if (candidateLocators[attr] && candidateLocators[attr].robust) {
                                robustLocator = candidateLocators[attr];
                                break;
                            }
                        }
                        
                        // Check other locators
                        if (!robustLocator) {
                            for (const key of ['name', 'linkText', 'buttonText', 'label', 'alt']) {
                                if (candidateLocators[key] && candidateLocators[key].robust) {
                                    robustLocator = candidateLocators[key];
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (robustLocator) {
                        locators[direction] = {
                            strategy: 'relative',
                            direction: direction,
                            targetLocator: robustLocator,
                            distance: closest.distance
                        };
                    }
                }
            }
            
            return locators;
        },
        
        /**
         * Find candidate elements in a specific direction
         * @param {Element} element - The element
         * @param {string} direction - The direction to search
         * @param {DOMRect} rect - The element's bounding rectangle
         * @returns {Object[]} Array of candidate elements with distances
         */
        findCandidatesInDirection: function(element, direction, rect) {
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const candidates = [];
            
            // Get all visible elements
            const allElements = Array.from(document.querySelectorAll('*')).filter(
                el => this.isElementVisible(el) && el !== element
            );
            
            for (const el of allElements) {
                const elRect = el.getBoundingClientRect();
                const elCenterX = elRect.left + elRect.width / 2;
                const elCenterY = elRect.top + elRect.height / 2;
                
                let isInDirection = false;
                let distance = 0;
                
                switch (direction) {
                    case 'above':
                        isInDirection = elRect.bottom < rect.top;
                        if (isInDirection) {
                            distance = rect.top - elRect.bottom;
                        }
                        break;
                        
                    case 'below':
                        isInDirection = elRect.top > rect.bottom;
                        if (isInDirection) {
                            distance = elRect.top - rect.bottom;
                        }
                        break;
                        
                    case 'toLeftOf':
                        isInDirection = elRect.right < rect.left;
                        if (isInDirection) {
                            distance = rect.left - elRect.right;
                        }
                        break;
                        
                    case 'toRightOf':
                        isInDirection = elRect.left > rect.right;
                        if (isInDirection) {
                            distance = elRect.left - rect.right;
                        }
                        break;
                        
                    case 'near':
                        // Calculate Euclidean distance between centers
                        distance = Math.sqrt(
                            Math.pow(centerX - elCenterX, 2) + 
                            Math.pow(centerY - elCenterY, 2)
                        );
                        isInDirection = distance <= CONFIG.maxRelativeDistance;
                        break;
                }
                
                if (isInDirection) {
                    candidates.push({
                        element: el,
                        distance: distance
                    });
                }
            }
            
            // Sort by distance
            candidates.sort((a, b) => a.distance - b.distance);
            
            // Return top 3 candidates
            return candidates.slice(0, 3);
        },
        
        /**
         * Check if a selector uniquely identifies an element
         * @param {string} selector - The selector to check
         * @returns {boolean} Whether the selector is unique
         */
        isSelectorUnique: function(selector) {
            try {
                const elements = document.querySelectorAll(selector);
                return elements.length === 1;
            } catch (e) {
                return false;
            }
        },
        
        /**
         * Check if a selector is robust (unlikely to change)
         * @param {string} selector - The selector to check
         * @param {string} type - The selector type (css/xpath)
         * @returns {boolean} Whether the selector is robust
         */
        isSelectorRobust: function(selector, type) {
            // ID-based selectors are robust
            if (type === 'css' && selector.includes('#')) {
                return true;
            }
            
            if (type === 'xpath' && selector.includes('@id')) {
                return true;
            }
            
            // Data attribute selectors are robust
            for (const attr of CONFIG.dataAttributes) {
                if (type === 'css' && selector.includes(`[${attr}=`)) {
                    return true;
                }
                
                if (type === 'xpath' && selector.includes(`@${attr}`)) {
                    return true;
                }
            }
            
            // Avoid selectors with too many steps
            const steps = type === 'css' ? selector.split('>').length : selector.split('/').length;
            if (steps > 3) {
                return false;
            }
            
            // Selectors with classes are less robust
            if (type === 'css' && selector.includes('.')) {
                return false;
            }
            
            // XPath selectors with indexes are less robust
            if (type === 'xpath' && selector.includes('[') && !selector.includes('@')) {
                return false;
            }
            
            return true;
        },
        
        /**
         * Get element attributes
         * @param {Element} element - The element
         * @returns {Object} Object with attributes
         */
        getElementAttributes: function(element) {
            const attributes = {};
            
            if (!element || !element.attributes) {
                return attributes;
            }
            
            for (const attr of element.attributes) {
                attributes[attr.name] = attr.value;
            }
            
            return attributes;
        },
        
        /**
         * Get element text content
         * @param {Element} element - The element
         * @returns {string} Element text content
         */
        getElementText: function(element) {
            if (!element) {
                return '';
            }
            
            // Handle input elements
            if (element.tagName === 'INPUT') {
                if (element.type === 'button' || element.type === 'submit') {
                    return element.value || '';
                }
                return '';
            }
            
            // Get direct text content
            let text = '';
            
            for (const node of element.childNodes) {
                if (node.nodeType === Node.TEXT_NODE) {
                    text += node.textContent;
                }
            }
            
            // Trim and limit length
            text = text.trim();
            if (text.length > CONFIG.maxTextLength) {
                text = text.substring(0, CONFIG.maxTextLength) + '...';
            }
            
            return text;
        },
        
        /**
         * Check if an element is visible
         * @param {Element} element - The element
         * @returns {boolean} Whether the element is visible
         */
        isElementVisible: function(element) {
            if (!element) {
                return false;
            }
            
            const style = window.getComputedStyle(element);
            
            // Check style properties
            if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
                return false;
            }
            
            // Check if element has zero dimensions
            const rect = element.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                return false;
            }
            
            // Check if element is visible in the viewport
            return true;
        },
        
        /**
         * Check if an element is interactable
         * @param {Element} element - The element
         * @returns {boolean} Whether the element is interactable
         */
        isElementInteractable: function(element) {
            if (!element) {
                return false;
            }
            
            // Check if element is disabled
            if (element.disabled) {
                return false;
            }
            
            // Check if element has interactable tag
            const interactableTags = ['A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'LABEL'];
            if (interactableTags.includes(element.tagName)) {
                return true;
            }
            
            // Check for role attribute
            const interactableRoles = ['button', 'link', 'checkbox', 'radio', 'switch', 'tab', 'menuitem'];
            const role = element.getAttribute('role');
            if (role && interactableRoles.includes(role)) {
                return true;
            }
            
            // Check for tabindex attribute
            if (element.hasAttribute('tabindex') && element.getAttribute('tabindex') >= 0) {
                return true;
            }
            
            // Check for onclick attribute or property
            if (element.hasAttribute('onclick') || element.onclick) {
                return true;
            }
            
            // Check if cursor is pointer
            const style = window.getComputedStyle(element);
            if (style.cursor === 'pointer') {
                return true;
            }
            
            return false;
        },
        
        /**
         * Check if an element is in the viewport
         * @param {Element} element - The element
         * @returns {boolean} Whether the element is in the viewport
         */
        isElementInViewport: function(element) {
            if (!element) {
                return false;
            }
            
            const rect = element.getBoundingClientRect();
            
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        },
        
        /**
         * Check if an element is focusable
         * @param {Element} element - The element
         * @returns {boolean} Whether the element is focusable
         */
        isElementFocusable: function(element) {
            if (!element) {
                return false;
            }
            
            // Inherently focusable elements
            const focusableTags = ['A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'];
            
            if (focusableTags.includes(element.tagName)) {
                // Links need href to be focusable
                if (element.tagName === 'A' && !element.hasAttribute('href')) {
                    return false;
                }
                
                // Disabled elements are not focusable
                if (element.disabled) {
                    return false;
                }
                
                return true;
            }
            
            // Check tabindex
            if (element.hasAttribute('tabindex') && element.getAttribute('tabindex') >= 0) {
                return true;
            }
            
            return false;
        }
    };
    
    // Initialize element identifier
    CSElementIdentifier.init();
    
    // Make the identifier available for manual access
    window.__CSElementIdentifier = CSElementIdentifier;
})();



timing-collector.js
----------------------------------------------


/**
 * timing-collector.js
 * Part of CSTestForge Browser Integration Module
 * 
 * This script is responsible for collecting timing information during recording,
 * including page load times, action execution times, and network performance.
 * It provides performance metrics for test verification and optimization.
 */

(function() {
    'use strict';
    
    // Configuration
    const CONFIG = {
        // Whether to collect timing information
        enabled: true,
        
        // Types of timing to collect
        collectPageTiming: true,
        collectResourceTiming: true,
        collectUserActionTiming: true,
        collectElementTimings: true,
        collectMarks: true,
        collectNetworkTiming: true,
        
        // Whether to aggregate resource timings by type
        aggregateResourceTimings: true,
        
        // How often to collect metrics (ms)
        pollingInterval: 5000,
        
        // Maximum number of resource timing entries to keep
        maxResourceTimingEntries: 100,
        
        // Function to post messages to the parent application
        postMessage: function(message) {
            try {
                window.parent.postMessage({
                    type: 'CSTestForge_TimingCollector',
                    data: message,
                    frameId: CSTimingCollector.frameId,
                    url: window.location.href
                }, '*');
            } catch (e) {
                console.error('CSTestForge Timing Collector: Error sending message', e);
            }
        },
        
        // Whether to clear timings after collecting
        clearTimingsAfterCollection: true,
        
        // Whether to collect custom timings with console.time
        interceptConsoleTime: true,
        
        // Whether to collect long tasks
        collectLongTasks: true,
        
        // Whether to track frame rate (FPS)
        trackFrameRate: true,
        
        // How often to report frame rate (ms)
        frameRateInterval: 1000,
        
        // Whether to collect Web Vitals
        collectWebVitals: true,
        
        // Custom metrics to collect
        customMetrics: [
            { name: 'domInteractive', source: 'performance', entry: 'navigation', field: 'domInteractive' },
            { name: 'domContentLoaded', source: 'performance', entry: 'navigation', field: 'domContentLoadedEventEnd' },
            { name: 'loadComplete', source: 'performance', entry: 'navigation', field: 'loadEventEnd' },
            { name: 'firstPaint', source: 'performance', entry: 'paint', field: 'startTime', filter: entry => entry.name === 'first-paint' },
            { name: 'firstContentfulPaint', source: 'performance', entry: 'paint', field: 'startTime', filter: entry => entry.name === 'first-contentful-paint' }
        ]
    };
    
    // Storage for timing data
    const timingData = {
        pageLoadTiming: null,
        resourceTimings: [],
        userActions: [],
        customMarks: [],
        customMeasures: [],
        longTasks: [],
        elementTimings: {},
        lastCollectionTime: 0,
        frameRates: [],
        webVitals: {},
        networkTimings: []
    };
    
    // Storage for frame rate tracking
    let frameRateTrackingEnabled = false;
    let frameRateData = {
        frameCount: 0,
        lastTimestamp: 0,
        currentFPS: 0,
        reportingInterval: null
    };
    
    // Storage for console.time tracking
    const consoleTimers = {};
    
    // Storage for user action timing
    let lastActionTime = 0;
    let lastActionName = '';
    
    // Unique ID for this frame
    const frameId = 'csframe_' + Math.random().toString(36).substring(2, 15);
    
    /**
     * Timing Collector Implementation
     */
    const CSTimingCollector = {
        // Frame identifier
        frameId: frameId,
        
        /**
         * Initialize the timing collector
         */
        init: function() {
            if (!CONFIG.enabled) {
                return;
            }
            
            // Collect initial page timing
            if (CONFIG.collectPageTiming) {
                this.collectPageTiming();
            }
            
            // Set up resource timing collection
            if (CONFIG.collectResourceTiming) {
                this.setupResourceTimingCollection();
            }
            
            // Set up user action timing
            if (CONFIG.collectUserActionTiming) {
                this.setupUserActionTiming();
            }
            
            // Set up element timing collection
            if (CONFIG.collectElementTimings) {
                this.setupElementTimingCollection();
            }
            
            // Set up console.time interception
            if (CONFIG.interceptConsoleTime) {
                this.interceptConsoleTime();
            }
            
            // Set up long task collection
            if (CONFIG.collectLongTasks) {
                this.setupLongTaskCollection();
            }
            
            // Set up frame rate tracking
            if (CONFIG.trackFrameRate) {
                this.setupFrameRateTracking();
            }
            
            // Set up Web Vitals collection
            if (CONFIG.collectWebVitals) {
                this.setupWebVitalsCollection();
            }
            
            // Set up network timing collection
            if (CONFIG.collectNetworkTiming) {
                this.setupNetworkTimingCollection();
            }
            
            // Set up periodic collection
            setInterval(() => {
                this.collectAllMetrics();
            }, CONFIG.pollingInterval);
            
            // Listen for control messages
            window.addEventListener('message', this.handleMessage.bind(this));
            
            // Listen for page events
            window.addEventListener('load', this.handlePageLoad.bind(this));
            window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
            
            // Send initialization event
            CONFIG.postMessage({
                type: 'init',
                url: window.location.href,
                title: document.title,
                timestamp: Date.now()
            });
            
            console.log('CSTestForge Timing Collector: Initialized');
        },
        
        /**
         * Collect page timing information
         * @param {string} eventType - The event that triggered collection
         */
        collectPageTiming: function(eventType) {
            if (!window.performance || !window.performance.timing) {
                return;
            }
            
            // Get navigation timing data
            const navigationTiming = this.getNavigationTiming();
            
            // Only update if we have timing data
            if (navigationTiming) {
                timingData.pageLoadTiming = navigationTiming;
                
                // Send page timing event
                CONFIG.postMessage({
                    type: 'pageTiming',
                    trigger: eventType || 'manual',
                    timing: navigationTiming,
                    timestamp: Date.now()
                });
            }
        },
        
        /**
         * Get navigation timing data
         * @returns {Object|null} Navigation timing data or null
         */
        getNavigationTiming: function() {
            // Try using the newer Navigation Timing API first
            if (window.performance && window.performance.getEntriesByType) {
                const navEntries = window.performance.getEntriesByType('navigation');
                
                if (navEntries && navEntries.length > 0) {
                    const entry = navEntries[0];
                    
                    return {
                        navigationStart: 0,
                        unloadEventStart: entry.unloadEventStart,
                        unloadEventEnd: entry.unloadEventEnd,
                        redirectStart: entry.redirectStart,
                        redirectEnd: entry.redirectEnd,
                        fetchStart: entry.fetchStart,
                        domainLookupStart: entry.domainLookupStart,
                        domainLookupEnd: entry.domainLookupEnd,
                        connectStart: entry.connectStart,
                        connectEnd: entry.connectEnd,
                        secureConnectionStart: entry.secureConnectionStart,
                        requestStart: entry.requestStart,
                        responseStart: entry.responseStart,
                        responseEnd: entry.responseEnd,
                        domLoading: entry.domContentLoadedEventStart,
                        domInteractive: entry.domInteractive,
                        domContentLoadedEventStart: entry.domContentLoadedEventStart,
                        domContentLoadedEventEnd: entry.domContentLoadedEventEnd,
                        domComplete: entry.domComplete,
                        loadEventStart: entry.loadEventStart,
                        loadEventEnd: entry.loadEventEnd,
                        type: entry.type,
                        redirectCount: entry.redirectCount,
                        // Calculate derived metrics
                        dnsTime: entry.domainLookupEnd - entry.domainLookupStart,
                        tcpConnectTime: entry.connectEnd - entry.connectStart,
                        requestTime: entry.responseStart - entry.requestStart,
                        responseTime: entry.responseEnd - entry.responseStart,
                        domProcessingTime: entry.domComplete - entry.responseEnd,
                        domInteractiveTime: entry.domInteractive - entry.navigationStart,
                        loadTime: entry.loadEventEnd - entry.navigationStart
                    };
                }
            }
            
            // Fall back to older Navigation Timing API
            if (window.performance && window.performance.timing) {
                const timing = window.performance.timing;
                const navigationStart = timing.navigationStart;
                
                // Make sure the load event has fired
                if (timing.loadEventEnd === 0) {
                    return null;
                }
                
                return {
                    navigationStart: 0,
                    unloadEventStart: timing.unloadEventStart - navigationStart,
                    unloadEventEnd: timing.unloadEventEnd - navigationStart,
                    redirectStart: timing.redirectStart - navigationStart,
                    redirectEnd: timing.redirectEnd - navigationStart,
                    fetchStart: timing.fetchStart - navigationStart,
                    domainLookupStart: timing.domainLookupStart - navigationStart,
                    domainLookupEnd: timing.domainLookupEnd - navigationStart,
                    connectStart: timing.connectStart - navigationStart,
                    connectEnd: timing.connectEnd - navigationStart,
                    secureConnectionStart: timing.secureConnectionStart ? timing.secureConnectionStart - navigationStart : 0,
                    requestStart: timing.requestStart - navigationStart,
                    responseStart: timing.responseStart - navigationStart,
                    responseEnd: timing.responseEnd - navigationStart,
                    domLoading: timing.domLoading - navigationStart,
                    domInteractive: timing.domInteractive - navigationStart,
                    domContentLoadedEventStart: timing.domContentLoadedEventStart - navigationStart,
                    domContentLoadedEventEnd: timing.domContentLoadedEventEnd - navigationStart,
                    domComplete: timing.domComplete - navigationStart,
                    loadEventStart: timing.loadEventStart - navigationStart,
                    loadEventEnd: timing.loadEventEnd - navigationStart,
                    // Calculate derived metrics
                    dnsTime: timing.domainLookupEnd - timing.domainLookupStart,
                    tcpConnectTime: timing.connectEnd - timing.connectStart,
                    requestTime: timing.responseStart - timing.requestStart,
                    responseTime: timing.responseEnd - timing.responseStart,
                    domProcessingTime: timing.domComplete - timing.responseEnd,
                    domInteractiveTime: timing.domInteractive - timing.navigationStart,
                    loadTime: timing.loadEventEnd - timing.navigationStart
                };
            }
            
            return null;
        },
        
        /**
         * Set up resource timing collection
         */
        setupResourceTimingCollection: function() {
            if (!window.performance || !window.performance.getEntriesByType) {
                return;
            }
            
            // Collect initial resource timings
            this.collectResourceTiming();
            
            // Set up observer for future resource timings
            if (window.PerformanceObserver) {
                try {
                    const observer = new PerformanceObserver((list) => {
                        const entries = list.getEntries();
                        this.processResourceTimingEntries(entries);
                    });
                    
                    observer.observe({ entryTypes: ['resource'] });
                } catch (e) {
                    console.error('CSTestForge Timing Collector: Error setting up PerformanceObserver for resources', e);
                    
                    // Fall back to polling
                    setInterval(() => {
                        this.collectResourceTiming();
                    }, CONFIG.pollingInterval);
                }
            } else {
                // Fall back to polling
                setInterval(() => {
                    this.collectResourceTiming();
                }, CONFIG.pollingInterval);
            }
        },
        
        /**
         * Collect resource timing information
         */
        collectResourceTiming: function() {
            if (!window.performance || !window.performance.getEntriesByType) {
                return;
            }
            
            // Get resource timing entries
            const entries = window.performance.getEntriesByType('resource');
            
            // Process entries
            this.processResourceTimingEntries(entries);
            
            // Clear resource timings if configured
            if (CONFIG.clearTimingsAfterCollection) {
                window.performance.clearResourceTimings();
            }
        },
        
        /**
         * Process resource timing entries
         * @param {PerformanceResourceTiming[]} entries - The resource timing entries
         */
        processResourceTimingEntries: function(entries) {
            if (!entries || entries.length === 0) {
                return;
            }
            
            // Get latest timestamp from collected entries
            let latestTimestamp = timingData.lastCollectionTime;
            
            // Process each entry
            for (const entry of entries) {
                // Skip entries we've already processed
                if (entry.startTime <= timingData.lastCollectionTime) {
                    continue;
                }
                
                // Update latest timestamp
                latestTimestamp = Math.max(latestTimestamp, entry.startTime);
                
                // Process the entry
                const processedEntry = this.processResourceTimingEntry(entry);
                
                // Add to resource timings
                timingData.resourceTimings.push(processedEntry);
                
                // Limit the number of entries
                if (timingData.resourceTimings.length > CONFIG.maxResourceTimingEntries) {
                    timingData.resourceTimings.shift();
                }
            }
            
            // Update last collection time
            timingData.lastCollectionTime = latestTimestamp;
            
            // If aggregation is enabled, create summary
            let aggregatedEntries = null;
            
            if (CONFIG.aggregateResourceTimings) {
                aggregatedEntries = this.aggregateResourceTimings(entries);
            }
            
            // Send resource timing event
            CONFIG.postMessage({
                type: 'resourceTiming',
                entries: timingData.resourceTimings.slice(-50), // Send last 50 entries
                aggregated: aggregatedEntries,
                timestamp: Date.now()
            });
        },
        
        /**
         * Process a single resource timing entry
         * @param {PerformanceResourceTiming} entry - The resource timing entry
         * @returns {Object} Processed entry
         */
        processResourceTimingEntry: function(entry) {
            // Extract the resource type from the initiatorType
            let resourceType = entry.initiatorType;
            
            // If initiatorType is 'link', check for resource type based on file extension
            if (resourceType === 'link' || resourceType === 'other' || resourceType === '') {
                resourceType = this.getResourceTypeFromUrl(entry.name);
            }
            
            return {
                name: entry.name,
                startTime: entry.startTime,
                duration: entry.duration,
                initiatorType: entry.initiatorType,
                resourceType: resourceType,
                fetchStart: entry.fetchStart,
                domainLookupStart: entry.domainLookupStart,
                domainLookupEnd: entry.domainLookupEnd,
                connectStart: entry.connectStart,
                connectEnd: entry.connectEnd,
                secureConnectionStart: entry.secureConnectionStart,
                requestStart: entry.requestStart,
                responseStart: entry.responseStart,
                responseEnd: entry.responseEnd,
                transferSize: entry.transferSize,
                encodedBodySize: entry.encodedBodySize,
                decodedBodySize: entry.decodedBodySize,
                // Calculate derived metrics
                dnsTime: entry.domainLookupEnd - entry.domainLookupStart,
                tcpConnectTime: entry.connectEnd - entry.connectStart,
                ttfb: entry.responseStart - entry.requestStart,
                downloadTime: entry.responseEnd - entry.responseStart,
                totalNetworkTime: entry.responseEnd - entry.fetchStart
            };
        },
        
        /**
         * Determine resource type from URL
         * @param {string} url - The resource URL
         * @returns {string} Resource type
         */
        getResourceTypeFromUrl: function(url) {
            // Extract file extension
            const extension = url.split('?')[0].split('#')[0].split('.').pop().toLowerCase();
            
            // Define mappings from extensions to resource types
            const extensionMap = {
                // Images
                'jpg': 'image',
                'jpeg': 'image',
                'png': 'image',
                'gif': 'image',
                'svg': 'image',
                'webp': 'image',
                'ico': 'image',
                // Scripts
                'js': 'script',
                'mjs': 'script',
                // Styles
                'css': 'style',
                // Fonts
                'woff': 'font',
                'woff2': 'font',
                'ttf': 'font',
                'otf': 'font',
                'eot': 'font',
                // Audio
                'mp3': 'audio',
                'wav': 'audio',
                'ogg': 'audio',
                // Video
                'mp4': 'video',
                'webm': 'video',
                'ogv': 'video',
                // Documents
                'pdf': 'document',
                'doc': 'document',
                'docx': 'document',
                'xls': 'document',
                'xlsx': 'document',
                'ppt': 'document',
                'pptx': 'document',
                // Data
                'json': 'xhr',
                'xml': 'xhr'
            };
            
            // Return the mapped type or 'other' if not found
            return extensionMap[extension] || 'other';
        },
        
        /**
         * Aggregate resource timings by type
         * @param {PerformanceResourceTiming[]} entries - The resource timing entries
         * @returns {Object} Aggregated timings by type
         */
        aggregateResourceTimings: function(entries) {
            const aggregated = {};
            
            // Group entries by resource type
            for (const entry of entries) {
                // Skip entries we've already processed
                if (entry.startTime <= timingData.lastCollectionTime) {
                    continue;
                }
                
                // Get resource type
                let resourceType = entry.initiatorType;
                
                // If initiatorType is 'link', check for resource type based on file extension
                if (resourceType === 'link' || resourceType === 'other' || resourceType === '') {
                    resourceType = this.getResourceTypeFromUrl(entry.name);
                }
                
                // Initialize group if not exists
                if (!aggregated[resourceType]) {
                    aggregated[resourceType] = {
                        count: 0,
                        totalSize: 0,
                        totalDuration: 0,
                        maxDuration: 0,
                        minDuration: Infinity,
                        avgDuration: 0,
                        totalNetworkTime: 0,
                        avgNetworkTime: 0
                    };
                }
                
                // Add entry to group
                const group = aggregated[resourceType];
                group.count++;
                group.totalSize += entry.transferSize || 0;
                group.totalDuration += entry.duration;
                group.maxDuration = Math.max(group.maxDuration, entry.duration);
                group.minDuration = Math.min(group.minDuration, entry.duration);
                group.totalNetworkTime += (entry.responseEnd - entry.fetchStart);
            }
            
            // Calculate averages
            for (const type in aggregated) {
                const group = aggregated[type];
                group.avgDuration = group.totalDuration / group.count;
                group.avgNetworkTime = group.totalNetworkTime / group.count;
                group.avgSize = group.totalSize / group.count;
            }
            
            return aggregated;
        },
        
        /**
         * Set up user action timing
         */
        setupUserActionTiming: function() {
            // Events to track
            const events = [
                'click', 'dblclick', 'contextmenu',
                'mousedown', 'mouseup',
                'keydown', 'keyup',
                'input', 'change',
                'focus', 'blur',
                'submit'
            ];
            
            // Track events
            for (const event of events) {
                document.addEventListener(event, (e) => {
                    this.trackUserAction(event, e);
                }, true);
            }
        },
        
        /**
         * Track a user action
         * @param {string} actionType - The action type
         * @param {Event} event - The DOM event
         */
        trackUserAction: function(actionType, event) {
            // Get the target element
            const target = event.target;
            
            // Skip if not an element
            if (!target || !target.tagName) {
                return;
            }
            
            // Build action details
            const action = {
                type: actionType,
                time: performance.now(),
                target: {
                    tagName: target.tagName,
                    id: target.id || null,
                    className: target.className || null,
                    type: target.type || null,
                    name: target.name || null,
                    value: target.type === 'password' ? '********' : (target.value || null)
                },
                timeSinceLastAction: 0
            };
            
            // Calculate time since last action
            if (lastActionTime > 0) {
                action.timeSinceLastAction = action.time - lastActionTime;
                action.lastActionType = lastActionName;
            }
            
            // Update last action time and name
            lastActionTime = action.time;
            lastActionName = actionType;
            
            // Add to user actions
            timingData.userActions.push(action);
            
            // Keep only latest actions (last 100)
            if (timingData.userActions.length > 100) {
                timingData.userActions.shift();
            }
            
            // Create a performance mark
            if (window.performance && window.performance.mark) {
                const markName = `user_action_${actionType}_${Date.now()}`;
                window.performance.mark(markName);
            }
            
            // Send user action event
            CONFIG.postMessage({
                type: 'userAction',
                action: action,
                timestamp: Date.now()
            });
        },
        
        /**
         * Set up element timing collection
         */
        setupElementTimingCollection: function() {
            // Check if Element Timing API is supported
            if (!window.PerformanceObserver || !('PerformanceElementTiming' in window)) {
                return;
            }
            
            try {
                // Create observer for element timings
                const observer = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    
                    for (const entry of entries) {
                        this.processElementTimingEntry(entry);
                    }
                });
                
                observer.observe({ entryTypes: ['element'] });
            } catch (e) {
                console.error('CSTestForge Timing Collector: Error setting up Element Timing Observer', e);
            }
        },
        
        /**
         * Process an element timing entry
         * @param {PerformanceElementTiming} entry - The element timing entry
         */
        processElementTimingEntry: function(entry) {
            // Get element identifier
            const elementId = entry.identifier || 'unknown';
            
            // Process entry
            const processedEntry = {
                name: entry.name,
                entryType: entry.entryType,
                startTime: entry.startTime,
                duration: entry.duration,
                renderTime: entry.renderTime,
                loadTime: entry.loadTime,
                identifier: elementId,
                naturalWidth: entry.naturalWidth,
                naturalHeight: entry.naturalHeight,
                intersectionRect: entry.intersectionRect,
                element: entry.element ? {
                    tagName: entry.element.tagName,
                    id: entry.element.id || null,
                    className: entry.element.className || null
                } : null
            };
            
            // Add to element timings
            if (!timingData.elementTimings[elementId]) {
                timingData.elementTimings[elementId] = [];
            }
            
            timingData.elementTimings[elementId].push(processedEntry);
            
            // Send element timing event
            CONFIG.postMessage({
                type: 'elementTiming',
                entry: processedEntry,
                timestamp: Date.now()
            });
        },
        
        /**
         * Set up console.time interception
         */
        interceptConsoleTime: function() {
            // Save original methods
            const originalTime = console.time;
            const originalTimeEnd = console.timeEnd;
            const originalTimeLog = console.timeLog;
            
            // Intercept console.time
            console.time = function(label) {
                const startTime = performance.now();
                consoleTimers[label] = startTime;
                
                // Track as custom mark
                if (window.performance && window.performance.mark) {
                    window.performance.mark(`console_time_start_${label}`);
                }
                
                // Call original
                return originalTime.apply(this, arguments);
            };
            
            // Intercept console.timeEnd
            console.timeEnd = function(label) {
                if (consoleTimers[label]) {
                    const startTime = consoleTimers[label];
                    const endTime = performance.now();
                    const duration = endTime - startTime;
                    
                    // Track as custom measure
                    if (window.performance && window.performance.measure) {
                        try {
                            window.performance.measure(
                                `console_time_${label}`,
                                `console_time_start_${label}`
                            );
                        } catch (e) {
                            // If the start mark doesn't exist, create measure from navigation start
                            window.performance.measure(
                                `console_time_${label}`
                            );
                        }
                    }
                    
                    // Add to custom measures
                    timingData.customMeasures.push({
                        name: `console_time_${label}`,
                        startTime: startTime,
                        endTime: endTime,
                        duration: duration,
                        source: 'console.time'
                    });
                    
                    // Send custom timing event
                    CONFIG.postMessage({
                        type: 'customTiming',
                        name: label,
                        duration: duration,
                        source: 'console.time',
                        timestamp: Date.now()
                    });
                    
                    // Remove from timers
                    delete consoleTimers[label];
                }
                
                // Call original
                return originalTimeEnd.apply(this, arguments);
            };
            
            // Intercept console.timeLog
            console.timeLog = function(label) {
                if (consoleTimers[label]) {
                    const startTime = consoleTimers[label];
                    const currentTime = performance.now();
                    const duration = currentTime - startTime;
                    
                    // Send custom timing event
                    CONFIG.postMessage({
                        type: 'customTimingLog',
                        name: label,
                        duration: duration,
                        source: 'console.timeLog',
                        timestamp: Date.now()
                    });
                }
                
                // Call original
                return originalTimeLog.apply(this, arguments);
            };
        },
        
        /**
         * Set up long task collection
         */
        setupLongTaskCollection: function() {
            // Check if Long Tasks API is supported
            if (!window.PerformanceObserver || !('PerformanceLongTaskTiming' in window)) {
                return;
            }
            
            try {
                // Create observer for long tasks
                const observer = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    
                    for (const entry of entries) {
                        this.processLongTaskEntry(entry);
                    }
                });
                
                observer.observe({ entryTypes: ['longtask'] });
            } catch (e) {
                console.error('CSTestForge Timing Collector: Error setting up Long Task Observer', e);
            }
        },
        
        /**
         * Process a long task entry
         * @param {PerformanceLongTaskTiming} entry - The long task entry
         */
        processLongTaskEntry: function(entry) {
            // Process entry
            const processedEntry = {
                name: entry.name,
                entryType: entry.entryType,
                startTime: entry.startTime,
                duration: entry.duration,
                attribution: entry.attribution ? entry.attribution.map(attr => ({
                    name: attr.name,
                    containerType: attr.containerType,
                    containerName: attr.containerName,
                    containerId: attr.containerId,
                    containerSrc: attr.containerSrc
                })) : []
            };
            
            // Add to long tasks
            timingData.longTasks.push(processedEntry);
            
            // Keep only latest tasks (last 50)
            if (timingData.longTasks.length > 50) {
                timingData.longTasks.shift();
            }
            
            // Send long task event
            CONFIG.postMessage({
                type: 'longTask',
                entry: processedEntry,
                timestamp: Date.now()
            });
        },
        
        /**
         * Set up frame rate tracking
         */
        setupFrameRateTracking: function() {
            if (frameRateTrackingEnabled) {
                return;
            }
            
            frameRateTrackingEnabled = true;
            frameRateData.lastTimestamp = performance.now();
            
            // Request animation frame loop
            const frameCallback = () => {
                // Count frame
                frameRateData.frameCount++;
                
                // Schedule next frame
                if (frameRateTrackingEnabled) {
                    requestAnimationFrame(frameCallback);
                }
            };
            
            // Start frame counting
            requestAnimationFrame(frameCallback);
            
            // Set up reporting interval
            frameRateData.reportingInterval = setInterval(() => {
                this.reportFrameRate();
            }, CONFIG.frameRateInterval);
        },
        
        /**
         * Stop frame rate tracking
         */
        stopFrameRateTracking: function() {
            frameRateTrackingEnabled = false;
            
            if (frameRateData.reportingInterval) {
                clearInterval(frameRateData.reportingInterval);
                frameRateData.reportingInterval = null;
            }
        },
        
        /**
         * Report current frame rate
         */
        reportFrameRate: function() {
            const currentTime = performance.now();
            const elapsedTime = currentTime - frameRateData.lastTimestamp;
            
            // Calculate FPS
            const fps = Math.round((frameRateData.frameCount * 1000) / elapsedTime);
            
            // Reset counters
            frameRateData.frameCount = 0;
            frameRateData.lastTimestamp = currentTime;
            frameRateData.currentFPS = fps;
            
            // Add to frame rates
            timingData.frameRates.push({
                time: currentTime,
                fps: fps
            });
            
            // Keep only latest rates (last 60)
            if (timingData.frameRates.length > 60) {
                timingData.frameRates.shift();
            }
            
            // Send frame rate event
            CONFIG.postMessage({
                type: 'frameRate',
                fps: fps,
                timestamp: Date.now()
            });
        },
        
        /**
         * Set up Web Vitals collection
         */
        setupWebVitalsCollection: function() {
            // Check if needed APIs are supported
            if (!window.PerformanceObserver) {
                return;
            }
            
            // Collect LCP (Largest Contentful Paint)
            try {
                const lcpObserver = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    
                    // We only care about the latest LCP entry
                    if (entries.length > 0) {
                        const lcpEntry = entries[entries.length - 1];
                        
                        timingData.webVitals.lcp = {
                            value: lcpEntry.startTime,
                            element: lcpEntry.element ? {
                                tagName: lcpEntry.element.tagName,
                                id: lcpEntry.element.id || null,
                                className: lcpEntry.element.className || null
                            } : null
                        };
                        
                        // Send LCP event
                        CONFIG.postMessage({
                            type: 'webVital',
                            name: 'LCP',
                            value: lcpEntry.startTime,
                            element: timingData.webVitals.lcp.element,
                            timestamp: Date.now()
                        });
                    }
                });
                
                lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
            } catch (e) {
                console.error('CSTestForge Timing Collector: Error setting up LCP Observer', e);
            }
            
            // Collect FID (First Input Delay)
            try {
                const fidObserver = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    
                    for (const entry of entries) {
                        // Calculate FID
                        const fid = entry.processingStart - entry.startTime;
                        
                        timingData.webVitals.fid = {
                            value: fid,
                            type: entry.name,
                            startTime: entry.startTime
                        };
                        
                        // Send FID event
                        CONFIG.postMessage({
                            type: 'webVital',
                            name: 'FID',
                            value: fid,
                            inputType: entry.name,
                            timestamp: Date.now()
                        });
                        
                        // We only need the first input
                        fidObserver.disconnect();
                    }
                });
                
                fidObserver.observe({ entryTypes: ['first-input'] });
            } catch (e) {
                console.error('CSTestForge Timing Collector: Error setting up FID Observer', e);
            }
            
            // Collect CLS (Cumulative Layout Shift)
            try {
                let clsValue = 0;
                let clsEntries = [];
                
                const clsObserver = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    
                    for (const entry of entries) {
                        // Only count layout shifts without recent user input
                        if (!entry.hadRecentInput) {
                            clsValue += entry.value;
                            clsEntries.push(entry);
                        }
                    }
                    
                    timingData.webVitals.cls = {
                        value: clsValue,
                        entries: clsEntries.length
                    };
                    
                    // Send CLS event
                    CONFIG.postMessage({
                        type: 'webVital',
                        name: 'CLS',
                        value: clsValue,
                        entries: clsEntries.length,
                        timestamp: Date.now()
                    });
                });
                
                clsObserver.observe({ entryTypes: ['layout-shift'] });
            } catch (e) {
                console.error('CSTestForge Timing Collector: Error setting up CLS Observer', e);
            }
            
            // Collect FCP (First Contentful Paint)
            try {
                const fcpObserver = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    
                    for (const entry of entries) {
                        if (entry.name === 'first-contentful-paint') {
                            timingData.webVitals.fcp = {
                                value: entry.startTime
                            };
                            
                            // Send FCP event
                            CONFIG.postMessage({
                                type: 'webVital',
                                name: 'FCP',
                                value: entry.startTime,
                                timestamp: Date.now()
                            });
                            
                            // We only need the FCP
                            fcpObserver.disconnect();
                        }
                    }
                });
                
                fcpObserver.observe({ entryTypes: ['paint'] });
            } catch (e) {
                console.error('CSTestForge Timing Collector: Error setting up FCP Observer', e);
            }
            
            // Collect TTFB (Time to First Byte)
            this.collectTTFB();
        },
        
        /**
         * Collect TTFB (Time to First Byte)
         */
        collectTTFB: function() {
            // Get navigation entries
            if (window.performance && window.performance.getEntriesByType) {
                const navEntries = window.performance.getEntriesByType('navigation');
                
                if (navEntries && navEntries.length > 0) {
                    const navEntry = navEntries[0];
                    const ttfb = navEntry.responseStart;
                    
                    timingData.webVitals.ttfb = {
                        value: ttfb
                    };
                    
                    // Send TTFB event
                    CONFIG.postMessage({
                        type: 'webVital',
                        name: 'TTFB',
                        value: ttfb,
                        timestamp: Date.now()
                    });
                }
            }
        },
        
        /**
         * Set up network timing collection
         */
        setupNetworkTimingCollection: function() {
            // Intercept XMLHttpRequest
            this.interceptXHR();
            
            // Intercept Fetch
            this.interceptFetch();
        },
        
        /**
         * Intercept XMLHttpRequest
         */
        interceptXHR: function() {
            const originalOpen = XMLHttpRequest.prototype.open;
            const originalSend = XMLHttpRequest.prototype.send;
            const self = this;
            
            XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
                this._csTimingInfo = {
                    method: method,
                    url: url,
                    async: async !== false, // Default is true
                    startTime: 0,
                    endTime: 0,
                    status: 0,
                    statusText: '',
                    duration: 0
                };
                
                return originalOpen.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function(body) {
                if (!this._csTimingInfo) {
                    return originalSend.apply(this, arguments);
                }
                
                // Record start time
                this._csTimingInfo.startTime = performance.now();
                
                // Set up event listeners
                this.addEventListener('load', function() {
                    self.finalizeXHRTiming(this);
                });
                
                this.addEventListener('error', function() {
                    self.finalizeXHRTiming(this, 'error');
                });
                
                this.addEventListener('abort', function() {
                    self.finalizeXHRTiming(this, 'abort');
                });
                
                this.addEventListener('timeout', function() {
                    self.finalizeXHRTiming(this, 'timeout');
                });
                
                return originalSend.apply(this, arguments);
            };
        },
        
        /**
         * Finalize XHR timing
         * @param {XMLHttpRequest} xhr - The XHR object
         * @param {string} [errorType] - The error type, if any
         */
        finalizeXHRTiming: function(xhr, errorType) {
            if (!xhr._csTimingInfo) {
                return;
            }
            
            // Record end time
            xhr._csTimingInfo.endTime = performance.now();
            xhr._csTimingInfo.duration = xhr._csTimingInfo.endTime - xhr._csTimingInfo.startTime;
            
            // Record status
            if (!errorType) {
                xhr._csTimingInfo.status = xhr.status;
                xhr._csTimingInfo.statusText = xhr.statusText;
            } else {
                xhr._csTimingInfo.error = errorType;
            }
            
            // Add to network timings
            timingData.networkTimings.push(xhr._csTimingInfo);
            
            // Keep only latest timings (last 100)
            if (timingData.networkTimings.length > 100) {
                timingData.networkTimings.shift();
            }
            
            // Send network timing event
            CONFIG.postMessage({
                type: 'networkTiming',
                requestType: 'xhr',
                timing: xhr._csTimingInfo,
                timestamp: Date.now()
            });
        },
        
        /**
         * Intercept Fetch
         */
        interceptFetch: function() {
            const originalFetch = window.fetch;
            const self = this;
            
            window.fetch = function(input, init) {
                const timingInfo = {
                    method: init && init.method ? init.method : 'GET',
                    url: typeof input === 'string' ? input : input.url,
                    startTime: performance.now(),
                    endTime: 0,
                    status: 0,
                    statusText: '',
                    duration: 0
                };
                
                return originalFetch.apply(this, arguments)
                    .then(function(response) {
                        // Record end time
                        timingInfo.endTime = performance.now();
                        timingInfo.duration = timingInfo.endTime - timingInfo.startTime;
                        
                        // Record status
                        timingInfo.status = response.status;
                        timingInfo.statusText = response.statusText;
                        
                        // Add to network timings
                        timingData.networkTimings.push(timingInfo);
                        
                        // Keep only latest timings (last 100)
                        if (timingData.networkTimings.length > 100) {
                            timingData.networkTimings.shift();
                        }
                        
                        // Send network timing event
                        CONFIG.postMessage({
                            type: 'networkTiming',
                            requestType: 'fetch',
                            timing: timingInfo,
                            timestamp: Date.now()
                        });
                        
                        return response;
                    })
                    .catch(function(error) {
                        // Record end time
                        timingInfo.endTime = performance.now();
                        timingInfo.duration = timingInfo.endTime - timingInfo.startTime;
                        
                        // Record error
                        timingInfo.error = error.toString();
                        
                        // Add to network timings
                        timingData.networkTimings.push(timingInfo);
                        
                        // Keep only latest timings (last 100)
                        if (timingData.networkTimings.length > 100) {
                            timingData.networkTimings.shift();
                        }
                        
                        // Send network timing event
                        CONFIG.postMessage({
                            type: 'networkTiming',
                            requestType: 'fetch',
                            timing: timingInfo,
                            timestamp: Date.now()
                        });
                        
                        throw error;
                    });
            };
        },
        
        /**
         * Collect custom performance marks and measures
         */
        collectMarks: function() {
            if (!CONFIG.collectMarks || !window.performance || !window.performance.getEntriesByType) {
                return;
            }
            
            // Collect marks
            const marks = window.performance.getEntriesByType('mark');
            
            // Process marks
            for (const mark of marks) {
                // Skip if already processed
                if (timingData.customMarks.some(m => m.name === mark.name && m.startTime === mark.startTime)) {
                    continue;
                }
                
                // Add to custom marks
                timingData.customMarks.push({
                    name: mark.name,
                    startTime: mark.startTime,
                    entryType: mark.entryType
                });
            }
            
            // Collect measures
            const measures = window.performance.getEntriesByType('measure');
            
            // Process measures
            for (const measure of measures) {
                // Skip if already processed
                if (timingData.customMeasures.some(m => m.name === measure.name && m.startTime === measure.startTime)) {
                    continue;
                }
                
                // Add to custom measures
                timingData.customMeasures.push({
                    name: measure.name,
                    startTime: measure.startTime,
                    duration: measure.duration,
                    entryType: measure.entryType
                });
                
                // Send custom timing event
                CONFIG.postMessage({
                    type: 'customTiming',
                    name: measure.name,
                    duration: measure.duration,
                    source: 'performance.measure',
                    timestamp: Date.now()
                });
            }
            
            // Clear marks and measures if configured
            if (CONFIG.clearTimingsAfterCollection) {
                try {
                    window.performance.clearMarks();
                    window.performance.clearMeasures();
                } catch (e) {
                    // Ignore errors
                }
            }
        },
        
        /**
         * Collect all custom metrics
         */
        collectCustomMetrics: function() {
            const metrics = {};
            
            // Process each custom metric definition
            for (const metricDef of CONFIG.customMetrics) {
                try {
                    let value = null;
                    
                    // Get metric value based on source
                    if (metricDef.source === 'performance') {
                        if (metricDef.entry === 'navigation') {
                            // Get from navigation timing
                            const navEntries = window.performance.getEntriesByType('navigation');
                            
                            if (navEntries && navEntries.length > 0) {
                                value = navEntries[0][metricDef.field];
                            }
                        } else if (metricDef.entry === 'paint') {
                            // Get from paint timing
                            const paintEntries = window.performance.getEntriesByType('paint');
                            
                            // Apply filter if specified
                            const filteredEntries = metricDef.filter ?
                                paintEntries.filter(metricDef.filter) :
                                paintEntries;
                            
                            if (filteredEntries && filteredEntries.length > 0) {
                                value = filteredEntries[0][metricDef.field];
                            }
                        }
                    }
                    
                    // Add to metrics if we got a value
                    if (value !== null) {
                        metrics[metricDef.name] = value;
                    }
                } catch (e) {
                    console.error(`CSTestForge Timing Collector: Error collecting custom metric ${metricDef.name}`, e);
                }
            }
            
            // Send custom metrics event if we have any
            if (Object.keys(metrics).length > 0) {
                CONFIG.postMessage({
                    type: 'customMetrics',
                    metrics: metrics,
                    timestamp: Date.now()
                });
            }
            
            return metrics;
        },
        
        /**
         * Collect all metrics
         */
        collectAllMetrics: function() {
            // Collect page timing
            if (CONFIG.collectPageTiming) {
                this.collectPageTiming('periodic');
            }
            
            // Collect resource timing
            if (CONFIG.collectResourceTiming) {
                this.collectResourceTiming();
            }
            
            // Collect marks and measures
            if (CONFIG.collectMarks) {
                this.collectMarks();
            }
            
            // Collect TTFB
            if (CONFIG.collectWebVitals) {
                this.collectTTFB();
            }
            
            // Collect custom metrics
            const customMetrics = this.collectCustomMetrics();
            
            // Send all metrics event
            CONFIG.postMessage({
                type: 'allMetrics',
                timing: timingData.pageLoadTiming,
                resources: {
                    count: timingData.resourceTimings.length,
                    aggregated: CONFIG.aggregateResourceTimings ? this.aggregateResourceTimings(timingData.resourceTimings) : null
                },
                userActions: {
                    count: timingData.userActions.length,
                    lastAction: timingData.userActions.length > 0 ? timingData.userActions[timingData.userActions.length - 1] : null
                },
                customMarks: timingData.customMarks.length,
                customMeasures: timingData.customMeasures.length,
                longTasks: {
                    count: timingData.longTasks.length,
                    totalDuration: timingData.longTasks.reduce((sum, task) => sum + task.duration, 0)
                },
                webVitals: timingData.webVitals,
                frameRate: frameRateData.currentFPS,
                customMetrics: customMetrics,
                timestamp: Date.now()
            });
        },
        
        /**
         * Handle incoming messages
         * @param {MessageEvent} event - The message event
         */
        handleMessage: function(event) {
            if (!event.data || event.data.type !== 'CSTestForge_TimingCollectorCommand') {
                return;
            }
            
            const command = event.data.command;
            
            switch (command) {
                case 'collectMetrics':
                    this.collectAllMetrics();
                    break;
                    
                case 'clearTimings':
                    this.clearTimings();
                    break;
                    
                case 'createMark':
                    this.createMark(event.data.name);
                    break;
                    
                case 'createMeasure':
                    this.createMeasure(event.data.name, event.data.startMark, event.data.endMark);
                    break;
                    
                case 'startFrameRateTracking':
                    this.setupFrameRateTracking();
                    break;
                    
                case 'stopFrameRateTracking':
                    this.stopFrameRateTracking();
                    break;
                    
                case 'updateConfig':
                    this.updateConfig(event.data.config);
                    break;
                    
                default:
                    console.warn('CSTestForge Timing Collector: Unknown command', command);
            }
        },
        
        /**
         * Handle page load event
         */
        handlePageLoad: function() {
            // Collect page timing after load
            if (CONFIG.collectPageTiming) {
                this.collectPageTiming('load');
            }
            
            // Collect all metrics
            this.collectAllMetrics();
        },
        
        /**
         * Handle before unload event
         */
        handleBeforeUnload: function() {
            // Collect final metrics
            this.collectAllMetrics();
        },
        
        /**
         * Clear all timing data
         */
        clearTimings: function() {
            // Clear performance timings
            if (window.performance) {
                try {
                    if (window.performance.clearResourceTimings) {
                        window.performance.clearResourceTimings();
                    }
                    
                    if (window.performance.clearMarks) {
                        window.performance.clearMarks();
                    }
                    
                    if (window.performance.clearMeasures) {
                        window.performance.clearMeasures();
                    }
                } catch (e) {
                    console.error('CSTestForge Timing Collector: Error clearing performance timings', e);
                }
            }
            
            // Clear internal timing data
            timingData.resourceTimings = [];
            timingData.userActions = [];
            timingData.customMarks = [];
            timingData.customMeasures = [];
            timingData.longTasks = [];
            timingData.elementTimings = {};
            timingData.frameRates = [];
            timingData.networkTimings = [];
            
            // Send confirmation
            CONFIG.postMessage({
                type: 'timingsCleared',
                timestamp: Date.now()
            });
        },
        
        /**
         * Create a performance mark
         * @param {string} name - The mark name
         */
        createMark: function(name) {
            if (!window.performance || !window.performance.mark) {
                return;
            }
            
            try {
                // Create mark
                window.performance.mark(name);
                
                // Add to custom marks
                timingData.customMarks.push({
                    name: name,
                    startTime: performance.now(),
                    entryType: 'mark',
                    source: 'api'
                });
                
                // Send confirmation
                CONFIG.postMessage({
                    type: 'markCreated',
                    name: name,
                    timestamp: Date.now()
                });
            } catch (e) {
                console.error(`CSTestForge Timing Collector: Error creating mark ${name}`, e);
            }
        },
        
        /**
         * Create a performance measure
         * @param {string} name - The measure name
         * @param {string} startMark - The start mark name
         * @param {string} endMark - The end mark name
         */
        createMeasure: function(name, startMark, endMark) {
            if (!window.performance || !window.performance.measure) {
                return;
            }
            
            try {
                // Create measure
                if (startMark && endMark) {
                    window.performance.measure(name, startMark, endMark);
                } else if (startMark) {
                    window.performance.measure(name, startMark);
                } else {
                    window.performance.measure(name);
                }
                
                // Get the measure
                const measures = window.performance.getEntriesByName(name, 'measure');
                
                if (measures && measures.length > 0) {
                    const measure = measures[measures.length - 1];
                    
                    // Add to custom measures
                    timingData.customMeasures.push({
                        name: name,
                        startTime: measure.startTime,
                        duration: measure.duration,
                        entryType: 'measure',
                        source: 'api'
                    });
                    
                    // Send confirmation
                    CONFIG.postMessage({
                        type: 'measureCreated',
                        name: name,
                        duration: measure.duration,
                        timestamp: Date.now()
                    });
                }
            } catch (e) {
                console.error(`CSTestForge Timing Collector: Error creating measure ${name}`, e);
            }
        },
        
        /**
         * Update configuration settings
         * @param {Object} newConfig - New configuration settings
         */
        updateConfig: function(newConfig) {
            // Update settings
            for (const key in newConfig) {
                if (CONFIG.hasOwnProperty(key)) {
                    CONFIG[key] = newConfig[key];
                }
            }
            
            // Apply configuration changes
            if (newConfig.hasOwnProperty('trackFrameRate')) {
                if (CONFIG.trackFrameRate) {
                    this.setupFrameRateTracking();
                } else {
                    this.stopFrameRateTracking();
                }
            }
            
            // Send confirmation
            CONFIG.postMessage({
                type: 'configUpdated',
                timestamp: Date.now()
            });
        }
    };
    
    // Initialize timing collector
    CSTimingCollector.init();
    
    // Make the collector available for manual access
    window.__CSTimingCollector = CSTimingCollector;
})();


feature-dector.js
------------------------------------------------------------

/**
 * feature-detector.js
 * Part of CSTestForge Browser Integration Module
 * 
 * This script is responsible for detecting browser features, capabilities,
 * and compatibility issues to ensure optimal test execution and recording.
 * It provides detailed environment information and adjusts behavior based
 * on available browser capabilities.
 */

(function() {
    'use strict';
    
    // Configuration
    const CONFIG = {
        // Whether to detect features
        enabled: true,
        
        // Features to detect
        detectAPIs: true,
        detectFeatures: true,
        detectPerformance: true,
        detectStorage: true,
        detectNetwork: true,
        detectMedia: true,
        detectWebGL: true,
        detectAccessibility: true,
        detectDeviceCapabilities: true,
        
        // Whether to send detailed information
        sendDetailedInfo: true,
        
        // Minimum interval between status updates (ms)
        statusUpdateInterval: 60000,
        
        // Function to post messages to the parent application
        postMessage: function(message) {
            try {
                window.parent.postMessage({
                    type: 'CSTestForge_FeatureDetector',
                    data: message,
                    frameId: CSFeatureDetector.frameId,
                    url: window.location.href
                }, '*');
            } catch (e) {
                console.error('CSTestForge Feature Detector: Error sending message', e);
            }
        }
    };
    
    // Feature detection cache
    const featureCache = {
        apis: null,
        features: null,
        performance: null,
        storage: null,
        network: null,
        media: null,
        webgl: null,
        accessibility: null,
        deviceCapabilities: null,
        lastUpdateTime: 0
    };
    
    // Browser identification
    const browserInfo = {
        name: '',
        version: '',
        engine: '',
        os: '',
        osVersion: '',
        device: '',
        viewport: {
            width: 0,
            height: 0
        },
        pixelRatio: 1,
        touch: false,
        mobile: false,
        bot: false
    };
    
    // Unique ID for this frame
    const frameId = 'csframe_' + Math.random().toString(36).substring(2, 15);
    
    /**
     * Feature Detector Implementation
     */
    const CSFeatureDetector = {
        // Frame identifier
        frameId: frameId,
        
        /**
         * Initialize the feature detector
         */
        init: function() {
            if (!CONFIG.enabled) {
                return;
            }
            
            // Identify browser
            this.identifyBrowser();
            
            // Detect features on init
            this.detectAllFeatures();
            
            // Listen for control messages
            window.addEventListener('message', this.handleMessage.bind(this));
            
            // Listen for viewport changes
            window.addEventListener('resize', this.handleResize.bind(this));
            
            // Send initialization event
            CONFIG.postMessage({
                type: 'init',
                browser: browserInfo,
                timestamp: Date.now()
            });
            
            console.log('CSTestForge Feature Detector: Initialized');
        },
        
        /**
         * Identify the browser and environment
         */
        identifyBrowser: function() {
            const ua = navigator.userAgent;
            
            // Detect browser name and version
            if (ua.indexOf('Firefox/') > -1) {
                browserInfo.name = 'Firefox';
                browserInfo.version = this.getVersion(ua, 'Firefox/');
                browserInfo.engine = 'Gecko';
            } else if (ua.indexOf('Edg/') > -1) {
                browserInfo.name = 'Edge';
                browserInfo.version = this.getVersion(ua, 'Edg/');
                browserInfo.engine = 'Blink';
            } else if (ua.indexOf('Chrome/') > -1) {
                browserInfo.name = 'Chrome';
                browserInfo.version = this.getVersion(ua, 'Chrome/');
                browserInfo.engine = 'Blink';
            } else if (ua.indexOf('Safari/') > -1 && ua.indexOf('Chrome/') === -1) {
                browserInfo.name = 'Safari';
                browserInfo.version = this.getVersion(ua, 'Version/');
                browserInfo.engine = 'WebKit';
            } else if (ua.indexOf('Trident/') > -1 || ua.indexOf('MSIE ') > -1) {
                browserInfo.name = 'Internet Explorer';
                
                if (ua.indexOf('MSIE ') > -1) {
                    browserInfo.version = this.getVersion(ua, 'MSIE ');
                } else {
                    // Trident versions map to IE versions
                    const tridentVersion = this.getVersion(ua, 'Trident/');
                    browserInfo.version = (parseFloat(tridentVersion) + 4).toString();
                }
                
                browserInfo.engine = 'Trident';
            } else if (ua.indexOf('Opera/') > -1 || ua.indexOf('OPR/') > -1) {
                browserInfo.name = 'Opera';
                
                if (ua.indexOf('OPR/') > -1) {
                    browserInfo.version = this.getVersion(ua, 'OPR/');
                } else {
                    browserInfo.version = this.getVersion(ua, 'Opera/');
                }
                
                browserInfo.engine = 'Blink';
            } else {
                browserInfo.name = 'Unknown';
                browserInfo.version = '';
                browserInfo.engine = 'Unknown';
            }
            
            // Detect OS
            if (ua.indexOf('Windows') > -1) {
                browserInfo.os = 'Windows';
                
                if (ua.indexOf('Windows NT 10.0') > -1) {
                    browserInfo.osVersion = '10';
                } else if (ua.indexOf('Windows NT 6.3') > -1) {
                    browserInfo.osVersion = '8.1';
                } else if (ua.indexOf('Windows NT 6.2') > -1) {
                    browserInfo.osVersion = '8';
                } else if (ua.indexOf('Windows NT 6.1') > -1) {
                    browserInfo.osVersion = '7';
                } else if (ua.indexOf('Windows NT 6.0') > -1) {
                    browserInfo.osVersion = 'Vista';
                } else if (ua.indexOf('Windows NT 5.1') > -1) {
                    browserInfo.osVersion = 'XP';
                } else {
                    browserInfo.osVersion = 'Unknown';
                }
            } else if (ua.indexOf('Macintosh') > -1 || ua.indexOf('Mac OS X') > -1) {
                browserInfo.os = 'macOS';
                
                const macOSVersionMatch = ua.match(/Mac OS X ([0-9_]+)/);
                if (macOSVersionMatch) {
                    browserInfo.osVersion = macOSVersionMatch[1].replace(/_/g, '.');
                } else {
                    browserInfo.osVersion = 'Unknown';
                }
            } else if (ua.indexOf('Linux') > -1) {
                browserInfo.os = 'Linux';
                browserInfo.osVersion = '';
                
                if (ua.indexOf('Ubuntu') > -1) {
                    browserInfo.osVersion = 'Ubuntu';
                } else if (ua.indexOf('Fedora') > -1) {
                    browserInfo.osVersion = 'Fedora';
                } else if (ua.indexOf('Debian') > -1) {
                    browserInfo.osVersion = 'Debian';
                }
            } else if (ua.indexOf('Android') > -1) {
                browserInfo.os = 'Android';
                browserInfo.osVersion = this.getVersion(ua, 'Android ');
                browserInfo.mobile = true;
            } else if (ua.indexOf('iOS') > -1 || ua.indexOf('iPhone') > -1 || ua.indexOf('iPad') > -1) {
                browserInfo.os = 'iOS';
                
                const iOSVersionMatch = ua.match(/OS ([0-9_]+)/);
                if (iOSVersionMatch) {
                    browserInfo.osVersion = iOSVersionMatch[1].replace(/_/g, '.');
                } else {
                    browserInfo.osVersion = 'Unknown';
                }
                
                browserInfo.mobile = true;
            } else {
                browserInfo.os = 'Unknown';
                browserInfo.osVersion = 'Unknown';
            }
            
            // Detect device type
            if (ua.indexOf('iPhone') > -1) {
                browserInfo.device = 'iPhone';
            } else if (ua.indexOf('iPad') > -1) {
                browserInfo.device = 'iPad';
            } else if (ua.indexOf('Android') > -1 && ua.indexOf('Mobile') > -1) {
                browserInfo.device = 'Android Phone';
            } else if (ua.indexOf('Android') > -1) {
                browserInfo.device = 'Android Tablet';
            } else if (browserInfo.os === 'Windows' && (ua.indexOf('Touch') > -1 || ua.indexOf('Tablet') > -1)) {
                browserInfo.device = 'Windows Tablet';
            } else if (browserInfo.mobile) {
                browserInfo.device = 'Mobile Device';
            } else {
                browserInfo.device = 'Desktop';
            }
            
            // Detect viewport size
            browserInfo.viewport = {
                width: window.innerWidth || document.documentElement.clientWidth,
                height: window.innerHeight || document.documentElement.clientHeight
            };
            
            // Detect pixel ratio
            browserInfo.pixelRatio = window.devicePixelRatio || 1;
            
            // Detect touch support
            browserInfo.touch = ('ontouchstart' in window) || 
                               (navigator.maxTouchPoints > 0) || 
                               (navigator.msMaxTouchPoints > 0);
            
            // Detect mobile
            if (!browserInfo.mobile) {
                browserInfo.mobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
            }
            
            // Detect bot
            browserInfo.bot = /bot|crawler|spider|crawling/i.test(ua);
        },
        
        /**
         * Get version from user agent string
         * @param {string} ua - User agent string
         * @param {string} pattern - Pattern to match
         * @returns {string} Version string
         */
        getVersion: function(ua, pattern) {
            const index = ua.indexOf(pattern);
            
            if (index === -1) {
                return '';
            }
            
            const versionString = ua.substring(index + pattern.length);
            const end = versionString.indexOf(' ');
            
            if (end === -1) {
                return versionString;
            }
            
            return versionString.substring(0, end);
        },
        
        /**
         * Detect all features
         */
        detectAllFeatures: function() {
            const now = Date.now();
            
            // Only update if the interval has passed
            if (now - featureCache.lastUpdateTime < CONFIG.statusUpdateInterval) {
                return;
            }
            
            // Update cache time
            featureCache.lastUpdateTime = now;
            
            // Detect features
            let featuresChanged = false;
            
            if (CONFIG.detectAPIs) {
                const apis = this.detectAPIs();
                
                if (!this.areObjectsEqual(apis, featureCache.apis)) {
                    featureCache.apis = apis;
                    featuresChanged = true;
                }
            }
            
            if (CONFIG.detectFeatures) {
                const features = this.detectFeatures();
                
                if (!this.areObjectsEqual(features, featureCache.features)) {
                    featureCache.features = features;
                    featuresChanged = true;
                }
            }
            
            if (CONFIG.detectPerformance) {
                const performance = this.detectPerformance();
                
                if (!this.areObjectsEqual(performance, featureCache.performance)) {
                    featureCache.performance = performance;
                    featuresChanged = true;
                }
            }
            
            if (CONFIG.detectStorage) {
                const storage = this.detectStorage();
                
                if (!this.areObjectsEqual(storage, featureCache.storage)) {
                    featureCache.storage = storage;
                    featuresChanged = true;
                }
            }
            
            if (CONFIG.detectNetwork) {
                const network = this.detectNetwork();
                
                if (!this.areObjectsEqual(network, featureCache.network)) {
                    featureCache.network = network;
                    featuresChanged = true;
                }
            }
            
            if (CONFIG.detectMedia) {
                const media = this.detectMedia();
                
                if (!this.areObjectsEqual(media, featureCache.media)) {
                    featureCache.media = media;
                    featuresChanged = true;
                }
            }
            
            if (CONFIG.detectWebGL) {
                const webgl = this.detectWebGL();
                
                if (!this.areObjectsEqual(webgl, featureCache.webgl)) {
                    featureCache.webgl = webgl;
                    featuresChanged = true;
                }
            }
            
            if (CONFIG.detectAccessibility) {
                const accessibility = this.detectAccessibility();
                
                if (!this.areObjectsEqual(accessibility, featureCache.accessibility)) {
                    featureCache.accessibility = accessibility;
                    featuresChanged = true;
                }
            }
            
            if (CONFIG.detectDeviceCapabilities) {
                const deviceCapabilities = this.detectDeviceCapabilities();
                
                if (!this.areObjectsEqual(deviceCapabilities, featureCache.deviceCapabilities)) {
                    featureCache.deviceCapabilities = deviceCapabilities;
                    featuresChanged = true;
                }
            }
            
            // Send features event if changed
            if (featuresChanged) {
                this.sendFeatures();
            }
        },
        
        /**
         * Check if two objects are equal
         * @param {Object} obj1 - First object
         * @param {Object} obj2 - Second object
         * @returns {boolean} Whether the objects are equal
         */
        areObjectsEqual: function(obj1, obj2) {
            // Handle null or undefined
            if (obj1 === obj2) {
                return true;
            }
            
            if (obj1 === null || obj2 === null || obj1 === undefined || obj2 === undefined) {
                return false;
            }
            
            // Check if both are objects
            if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {
                return false;
            }
            
            // Check if both have the same properties
            const keys1 = Object.keys(obj1);
            const keys2 = Object.keys(obj2);
            
            if (keys1.length !== keys2.length) {
                return false;
            }
            
            // Check if all properties are equal
            for (const key of keys1) {
                if (!obj2.hasOwnProperty(key)) {
                    return false;
                }
                
                const val1 = obj1[key];
                const val2 = obj2[key];
                
                if (typeof val1 === 'object' && typeof val2 === 'object') {
                    if (!this.areObjectsEqual(val1, val2)) {
                        return false;
                    }
                } else if (val1 !== val2) {
                    return false;
                }
            }
            
            return true;
        },
        
        /**
         * Send features event
         */
        sendFeatures: function() {
            const features = {
                browser: browserInfo,
                apis: featureCache.apis,
                features: featureCache.features,
                performance: featureCache.performance,
                storage: featureCache.storage,
                network: featureCache.network,
                media: featureCache.media,
                webgl: featureCache.webgl,
                accessibility: featureCache.accessibility,
                deviceCapabilities: featureCache.deviceCapabilities
            };
            
            CONFIG.postMessage({
                type: 'features',
                features: features,
                timestamp: Date.now()
            });
        },
        
        /**
         * Detect API support
         * @returns {Object} Object with API support information
         */
        detectAPIs: function() {
            const apis = {
                // Core
                promise: typeof Promise !== 'undefined',
                fetch: typeof fetch !== 'undefined',
                xhr: typeof XMLHttpRequest !== 'undefined',
                json: typeof JSON !== 'undefined',
                setTimeout: typeof setTimeout !== 'undefined',
                setInterval: typeof setInterval !== 'undefined',
                requestAnimationFrame: typeof requestAnimationFrame !== 'undefined',
                
                // DOM
                querySelector: typeof document.querySelector !== 'undefined',
                querySelectorAll: typeof document.querySelectorAll !== 'undefined',
                addEventListener: typeof window.addEventListener !== 'undefined',
                createDocumentFragment: typeof document.createDocumentFragment !== 'undefined',
                createElement: typeof document.createElement !== 'undefined',
                getComputedStyle: typeof window.getComputedStyle !== 'undefined',
                
                // Storage
                localStorage: (() => {
                    try {
                        return typeof localStorage !== 'undefined';
                    } catch (e) {
                        return false;
                    }
                })(),
                sessionStorage: (() => {
                    try {
                        return typeof sessionStorage !== 'undefined';
                    } catch (e) {
                        return false;
                    }
                })(),
                indexedDB: typeof indexedDB !== 'undefined',
                
                // Network
                websocket: typeof WebSocket !== 'undefined',
                eventSource: typeof EventSource !== 'undefined',
                
                // Graphics
                canvas: typeof document.createElement('canvas').getContext === 'function',
                webgl: (() => {
                    try {
                        const canvas = document.createElement('canvas');
                        return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                    } catch (e) {
                        return false;
                    }
                })(),
                webgl2: (() => {
                    try {
                        const canvas = document.createElement('canvas');
                        return !!canvas.getContext('webgl2');
                    } catch (e) {
                        return false;
                    }
                })(),
                svg: typeof SVGElement !== 'undefined',
                
                // Media
                audio: typeof Audio !== 'undefined',
                video: typeof document.createElement('video').canPlayType === 'function',
                mediaDevices: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                
                // Input
                touch: ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0),
                pointer: typeof PointerEvent !== 'undefined',
                gamepad: typeof navigator.getGamepads !== 'undefined',
                
                // Location
                geolocation: !!navigator.geolocation,
                
                // Workers
                worker: typeof Worker !== 'undefined',
                sharedWorker: typeof SharedWorker !== 'undefined',
                serviceWorker: !!(navigator.serviceWorker),
                
                // Advanced
                history: !!(window.history && window.history.pushState),
                notifications: typeof Notification !== 'undefined',
                webRTC: !!(window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection),
                speech: !!(window.SpeechRecognition || window.webkitSpeechRecognition),
                speechSynthesis: typeof speechSynthesis !== 'undefined',
                webVR: typeof navigator.getVRDisplays !== 'undefined',
                webXR: typeof navigator.xr !== 'undefined',
                
                // Performance
                performance: typeof performance !== 'undefined',
                performanceObserver: typeof PerformanceObserver !== 'undefined',
                
                // Animation
                animation: typeof document.createElement('div').animate === 'function',
                webAnimations: typeof Animation !== 'undefined',
                
                // Misc
                intl: typeof Intl !== 'undefined',
                crypto: !!(window.crypto && window.crypto.subtle),
                intersectionObserver: typeof IntersectionObserver !== 'undefined',
                mutationObserver: typeof MutationObserver !== 'undefined',
                resizeObserver: typeof ResizeObserver !== 'undefined',
                clipboard: navigator.clipboard !== undefined
            };
            
            return apis;
        },
        
        /**
         * Detect HTML5 and CSS features
         * @returns {Object} Object with feature support information
         */
        detectFeatures: function() {
            // Test element for feature detection
            const testElement = document.createElement('div');
            
            const features = {
                // HTML5 elements
                elements: {
                    article: this.isElementSupported('article'),
                    aside: this.isElementSupported('aside'),
                    audio: this.isElementSupported('audio'),
                    canvas: this.isElementSupported('canvas'),
                    datalist: this.isElementSupported('datalist'),
                    details: this.isElementSupported('details'),
                    figure: this.isElementSupported('figure'),
                    footer: this.isElementSupported('footer'),
                    header: this.isElementSupported('header'),
                    main: this.isElementSupported('main'),
                    mark: this.isElementSupported('mark'),
                    meter: this.isElementSupported('meter'),
                    nav: this.isElementSupported('nav'),
                    output: this.isElementSupported('output'),
                    picture: this.isElementSupported('picture'),
                    progress: this.isElementSupported('progress'),
                    section: this.isElementSupported('section'),
                    template: this.isElementSupported('template'),
                    time: this.isElementSupported('time'),
                    video: this.isElementSupported('video')
                },
                
                // Input types
                inputTypes: {
                    color: this.isInputTypeSupported('color'),
                    date: this.isInputTypeSupported('date'),
                    datetime: this.isInputTypeSupported('datetime'),
                    'datetime-local': this.isInputTypeSupported('datetime-local'),
                    email: this.isInputTypeSupported('email'),
                    month: this.isInputTypeSupported('month'),
                    number: this.isInputTypeSupported('number'),
                    range: this.isInputTypeSupported('range'),
                    search: this.isInputTypeSupported('search'),
                    tel: this.isInputTypeSupported('tel'),
                    time: this.isInputTypeSupported('time'),
                    url: this.isInputTypeSupported('url'),
                    week: this.isInputTypeSupported('week')
                },
                
                // Input attributes
                inputAttributes: {
                    autocomplete: 'autocomplete' in testElement,
                    autofocus: 'autofocus' in testElement,
                    maxlength: 'maxLength' in testElement,
                    pattern: 'pattern' in testElement,
                    placeholder: 'placeholder' in testElement,
                    required: 'required' in testElement,
                    step: 'step' in testElement
                },
                
                // CSS features
                css: {
                    animations: this.isCssPropertySupported('animation'),
                    boxShadow: this.isCssPropertySupported('boxShadow'),
                    borderRadius: this.isCssPropertySupported('borderRadius'),
                    flexbox: this.isCssPropertySupported('flexDirection'),
                    grid: this.isCssPropertySupported('gridTemplateColumns'),
                    transition: this.isCssPropertySupported('transition'),
                    transform: this.isCssPropertySupported('transform'),
                    transformOrigin: this.isCssPropertySupported('transformOrigin'),
                    translate: this.isCssPropertySupported('translate'),
                    filter: this.isCssPropertySupported('filter'),
                    variables: this.isCssPropertySupported('--test', '0'),
                    sticky: this.isCssValueSupported('position', 'sticky'),
                    columns: this.isCssPropertySupported('columnCount'),
                    gradients: this.isCssValueSupported('backgroundImage', 'linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.1))'),
                    calc: this.isCssValueSupported('width', 'calc(1px + 1px)'),
                    maskImage: this.isCssPropertySupported('maskImage'),
                    clipPath: this.isCssPropertySupported('clipPath'),
                    supports: typeof CSS !== 'undefined' && typeof CSS.supports === 'function'
                },
                
                // Advanced features
                advanced: {
                    datasetAPI: !!testElement.dataset,
                    classList: !!testElement.classList,
                    shadowDOM: typeof testElement.attachShadow === 'function',
                    templates: typeof document.createElement('template').content !== 'undefined',
                    customElements: typeof window.customElements !== 'undefined',
                    imports: 'import' in document.createElement('link'),
                    adoptedStyleSheets: 'adoptedStyleSheets' in document,
                    elementTiming: 'elementTiming' in testElement,
                    contentVisibility: this.isCssPropertySupported('contentVisibility'),
                    constructableStyleSheets: typeof CSSStyleSheet === 'function' && 
                                            'replace' in CSSStyleSheet.prototype
                }
            };
            
            return features;
        },
        
        /**
         * Check if an element is supported
         * @param {string} tagName - The element tag name
         * @returns {boolean} Whether the element is supported
         */
        isElementSupported: function(tagName) {
            try {
                const element = document.createElement(tagName);
                return element.toString() !== '[object HTMLUnknownElement]';
            } catch (e) {
                return false;
            }
        },
        
        /**
         * Check if an input type is supported
         * @param {string} type - The input type
         * @returns {boolean} Whether the input type is supported
         */
        isInputTypeSupported: function(type) {
            const input = document.createElement('input');
            input.setAttribute('type', type);
            
            // If the browser doesn't support the type, it will be reset to 'text'
            return input.type !== 'text';
        },
        
        /**
         * Check if a CSS property is supported
         * @param {string} property - The CSS property
         * @param {string} [value] - Optional property value
         * @returns {boolean} Whether the CSS property is supported
         */
        isCssPropertySupported: function(property, value) {
            // Convert camelCase to kebab-case
            const kebabProperty = property.replace(/([A-Z])/g, function(letter) {
                return '-' + letter.toLowerCase();
            });
            
            // If CSS.supports is available, use it
            if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {
                if (value) {
                    return CSS.supports(kebabProperty, value);
                } else {
                    return CSS.supports(kebabProperty, 'initial');
                }
            }
            
            // Fallback to checking if the property exists in style
            const testElement = document.createElement('div');
            
            return property in testElement.style;
        },
        
        /**
         * Check if a CSS value is supported
         * @param {string} property - The CSS property
         * @param {string} value - The CSS value
         * @returns {boolean} Whether the CSS value is supported
         */
        isCssValueSupported: function(property, value) {
            if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {
                return CSS.supports(property, value);
            }
            
            // Fallback using DOM
            const testElement = document.createElement('div');
            testElement.style[property] = value;
            
            // If the browser supports the value, the style will be set
            return testElement.style[property] !== '';
        },
        
        /**
         * Detect performance features
         * @returns {Object} Object with performance support information
         */
        detectPerformance: function() {
            const performance = {
                supported: typeof window.performance !== 'undefined',
                now: typeof window.performance !== 'undefined' && typeof window.performance.now === 'function',
                timing: typeof window.performance !== 'undefined' && typeof window.performance.timing !== 'undefined',
                navigation: typeof window.performance !== 'undefined' && typeof window.performance.navigation !== 'undefined',
                memory: typeof window.performance !== 'undefined' && typeof window.performance.memory !== 'undefined',
                timeOrigin: typeof window.performance !== 'undefined' && typeof window.performance.timeOrigin !== 'undefined',
                observer: typeof PerformanceObserver !== 'undefined',
                resourceTiming: typeof window.performance !== 'undefined' && 
                               typeof window.performance.getEntriesByType === 'function' && 
                               (window.performance.getEntriesByType('resource') || []).length >= 0,
                userTiming: typeof window.performance !== 'undefined' && 
                           typeof window.performance.mark === 'function' && 
                           typeof window.performance.measure === 'function',
                longTasks: typeof window.PerformanceObserver !== 'undefined' && 
                           (() => {
                               try {
                                   const observer = new PerformanceObserver(function() {});
                                   observer.observe({ entryTypes: ['longtask'] });
                                   observer.disconnect();
                                   return true;
                               } catch (e) {
                                   return false;
                               }
                           })(),
                elementTiming: typeof window.PerformanceObserver !== 'undefined' && 
                              (() => {
                                  try {
                                      const observer = new PerformanceObserver(function() {});
                                      observer.observe({ entryTypes: ['element'] });
                                      observer.disconnect();
                                      return true;
                                  } catch (e) {
                                      return false;
                                  }
                              })(),
                paintTiming: typeof window.PerformanceObserver !== 'undefined' && 
                            (() => {
                                try {
                                    const observer = new PerformanceObserver(function() {});
                                    observer.observe({ entryTypes: ['paint'] });
                                    observer.disconnect();
                                    return true;
                                } catch (e) {
                                    return false;
                                }
                            })(),
                largestContentfulPaint: typeof window.PerformanceObserver !== 'undefined' && 
                                      (() => {
                                          try {
                                              const observer = new PerformanceObserver(function() {});
                                              observer.observe({ entryTypes: ['largest-contentful-paint'] });
                                              observer.disconnect();
                                              return true;
                                          } catch (e) {
                                              return false;
                                          }
                                      })(),
                layoutShift: typeof window.PerformanceObserver !== 'undefined' && 
                           (() => {
                               try {
                                   const observer = new PerformanceObserver(function() {});
                                   observer.observe({ entryTypes: ['layout-shift'] });
                                   observer.disconnect();
                                   return true;
                               } catch (e) {
                                   return false;
                               }
                           })(),
                firstInput: typeof window.PerformanceObserver !== 'undefined' && 
                          (() => {
                              try {
                                  const observer = new PerformanceObserver(function() {});
                                  observer.observe({ entryTypes: ['first-input'] });
                                  observer.disconnect();
                                  return true;
                              } catch (e) {
                                  return false;
                              }
                          })()
            };
            
            return performance;
        },
        
        /**
         * Detect storage features
         * @returns {Object} Object with storage support information
         */
        detectStorage: function() {
            const storage = {
                localStorage: (() => {
                    try {
                        const test = 'test';
                        localStorage.setItem(test, test);
                        localStorage.removeItem(test);
                        return true;
                    } catch (e) {
                        return false;
                    }
                })(),
                sessionStorage: (() => {
                    try {
                        const test = 'test';
                        sessionStorage.setItem(test, test);
                        sessionStorage.removeItem(test);
                        return true;
                    } catch (e) {
                        return false;
                    }
                })(),
                cookies: (() => {
                    try {
                        document.cookie = 'test=test; max-age=1';
                        const result = document.cookie.indexOf('test=test') !== -1;
                        document.cookie = 'test=; expires=Thu, 01 Jan 1970 00:00:00 GMT';
                        return result;
                    } catch (e) {
                        return false;
                    }
                })(),
                indexedDB: (() => {
                    try {
                        return typeof indexedDB !== 'undefined';
                    } catch (e) {
                        return false;
                    }
                })(),
                webSQL: (() => {
                    try {
                        return typeof openDatabase !== 'undefined';
                    } catch (e) {
                        return false;
                    }
                })(),
                cacheAPI: typeof caches !== 'undefined',
                webStorage: (() => {
                    try {
                        return typeof navigator.storage !== 'undefined' && typeof navigator.storage.estimate === 'function';
                    } catch (e) {
                        return false;
                    }
                })(),
                fileSystem: (() => {
                    try {
                        return typeof window.requestFileSystem !== 'undefined' || 
                               typeof window.webkitRequestFileSystem !== 'undefined';
                    } catch (e) {
                        return false;
                    }
                })()
            };
            
            // Get localStorage/sessionStorage size limits
            if (storage.localStorage) {
                try {
                    let testKey = 'storageTest';
                    let testValue = 'a';
                    let estimatedLimit = 0;
                    
                    localStorage.removeItem(testKey);
                    
                    // Try to determine the limit
                    try {
                        // Start with 1 KB
                        let testSize = 1024;
                        localStorage.setItem(testKey, testValue.repeat(testSize));
                        
                        // Increase by 1 MB chunks
                        let maxIterations = 50; // Prevent endless loop
                        let iteration = 0;
                        
                        while (iteration < maxIterations) {
                            testSize += 1024 * 1024; // Add 1 MB
                            const largeValue = testValue.repeat(testSize);
                            
                            try {
                                localStorage.setItem(testKey, largeValue);
                                estimatedLimit = testSize;
                                iteration++;
                            } catch (e) {
                                // We've hit the limit
                                break;
                            }
                        }
                        
                        storage.localStorageLimit = estimatedLimit;
                    } catch (e) {
                        // Ignore errors
                    } finally {
                        localStorage.removeItem(testKey);
                    }
                } catch (e) {
                    // Ignore errors
                }
            }
            
            // Check for storage quotas
            if (typeof navigator.storage !== 'undefined' && typeof navigator.storage.estimate === 'function') {
                try {
                    navigator.storage.estimate().then(estimate => {
                        storage.persistentStorageQuota = estimate.quota;
                        storage.persistentStorageUsage = estimate.usage;
                    }).catch(() => {
                        // Ignore errors
                    });
                } catch (e) {
                    // Ignore errors
                }
            }
            
            return storage;
        },
        
        /**
         * Detect network features
         * @returns {Object} Object with network support information
         */
        detectNetwork: function() {
            const network = {
                online: typeof navigator.onLine === 'boolean' ? navigator.onLine : true,
                connection: typeof navigator.connection !== 'undefined',
                downlink: (() => {
                    try {
                        return navigator.connection && typeof navigator.connection.downlink === 'number' ?
                               navigator.connection.downlink : null;
                    } catch (e) {
                        return null;
                    }
                })(),
                effectiveType: (() => {
                    try {
                        return navigator.connection && typeof navigator.connection.effectiveType === 'string' ?
                               navigator.connection.effectiveType : null;
                    } catch (e) {
                        return null;
                    }
                })(),
                rtt: (() => {
                    try {
                        return navigator.connection && typeof navigator.connection.rtt === 'number' ?
                               navigator.connection.rtt : null;
                    } catch (e) {
                        return null;
                    }
                })(),
                saveData: (() => {
                    try {
                        return navigator.connection && typeof navigator.connection.saveData === 'boolean' ?
                               navigator.connection.saveData : null;
                    } catch (e) {
                        return null;
                    }
                })(),
                navigatorSendBeacon: typeof navigator.sendBeacon === 'function',
                fetch: typeof fetch === 'function',
                fetchCredentials: typeof Request !== 'undefined' && 'credentials' in Request.prototype,
                xmlHttpRequest: typeof XMLHttpRequest !== 'undefined',
                webSocket: typeof WebSocket !== 'undefined',
                eventSource: typeof EventSource !== 'undefined',
                serverSentEvents: typeof EventSource !== 'undefined',
                webRTC: (() => {
                    try {
                        return !!(window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection);
                    } catch (e) {
                        return false;
                    }
                })()
            };
            
            return network;
        },
        
        /**
         * Detect media features
         * @returns {Object} Object with media support information
         */
        detectMedia: function() {
            const media = {
                audio: (() => {
                    try {
                        return typeof Audio !== 'undefined';
                    } catch (e) {
                        return false;
                    }
                })(),
                video: (() => {
                    try {
                        const video = document.createElement('video');
                        return typeof video.canPlayType === 'function';
                    } catch (e) {
                        return false;
                    }
                })(),
                canvas: (() => {
                    try {
                        const canvas = document.createElement('canvas');
                        return !!(canvas.getContext && canvas.getContext('2d'));
                    } catch (e) {
                        return false;
                    }
                })(),
                capture: (() => {
                    try {
                        const input = document.createElement('input');
                        input.type = 'file';
                        return 'capture' in input;
                    } catch (e) {
                        return false;
                    }
                })(),
                mediaDevices: (() => {
                    try {
                        return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
                    } catch (e) {
                        return false;
                    }
                })(),
                getUserMedia: (() => {
                    try {
                        return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || 
                                navigator.mozGetUserMedia || navigator.msGetUserMedia ||
                                (navigator.mediaDevices && navigator.mediaDevices.getUserMedia));
                    } catch (e) {
                        return false;
                    }
                })(),
                pictureInPicture: (() => {
                    try {
                        const video = document.createElement('video');
                        return 'requestPictureInPicture' in video;
                    } catch (e) {
                        return false;
                    }
                })(),
                mediaSession: typeof navigator.mediaSession !== 'undefined',
                mediaRecorder: typeof MediaRecorder !== 'undefined',
                audioContext: (() => {
                    try {
                        return !!(window.AudioContext || window.webkitAudioContext);
                    } catch (e) {
                        return false;
                    }
                })(),
                webAudio: (() => {
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        const context = new AudioContext();
                        context.close();
                        return true;
                    } catch (e) {
                        return false;
                    }
                })(),
                speechSynthesis: 'speechSynthesis' in window,
                speechRecognition: (() => {
                    try {
                        return !!(window.SpeechRecognition || window.webkitSpeechRecognition);
                    } catch (e) {
                        return false;
                    }
                })(),
                webMIDI: 'requestMIDIAccess' in navigator,
                imageCapture: typeof ImageCapture !== 'undefined',
                
                // Video formats
                videoFormats: (() => {
                    try {
                        const video = document.createElement('video');
                        if (!video.canPlayType) {
                            return {};
                        }
                        
                        return {
                            mp4: video.canPlayType('video/mp4'),
                            webm: video.canPlayType('video/webm'),
                            ogg: video.canPlayType('video/ogg'),
                            hevc: video.canPlayType('video/mp4; codecs="hvc1"'),
                            vp9: video.canPlayType('video/webm; codecs="vp9"'),
                            av1: video.canPlayType('video/mp4; codecs="av01"')
                        };
                    } catch (e) {
                        return {};
                    }
                })(),
                
                // Audio formats
                audioFormats: (() => {
                    try {
                        const audio = document.createElement('audio');
                        if (!audio.canPlayType) {
                            return {};
                        }
                        
                        return {
                            mp3: audio.canPlayType('audio/mpeg'),
                            ogg: audio.canPlayType('audio/ogg; codecs="vorbis"'),
                            opus: audio.canPlayType('audio/ogg; codecs="opus"'),
                            wav: audio.canPlayType('audio/wav'),
                            aac: audio.canPlayType('audio/aac'),
                            m4a: audio.canPlayType('audio/x-m4a'),
                            flac: audio.canPlayType('audio/flac')
                        };
                    } catch (e) {
                        return {};
                    }
                })(),
                
                // Media streaming
                mediaSource: typeof MediaSource !== 'undefined',
                wasm: typeof WebAssembly !== 'undefined',
                webCodecs: typeof VideoEncoder !== 'undefined' && typeof VideoDecoder !== 'undefined',
                webHID: 'hid' in navigator,
                webUSB: 'usb' in navigator,
                webSerial: 'serial' in navigator,
                mediaDrm: 'requestMediaKeySystemAccess' in navigator,
                encryptedMedia: typeof HTMLMediaElement !== 'undefined' && 'setMediaKeys' in HTMLMediaElement.prototype
            };
            
            return media;
        },
        
        /**
         * Detect WebGL capabilities
         * @returns {Object} Object with WebGL support information
         */
        detectWebGL: function() {
            const webgl = {
                supported: false,
                webgl2: false,
                vendor: '',
                renderer: '',
                maxTextureSize: 0,
                maxTextureUnits: 0,
                maxCubeMapTextureSize: 0,
                maxRenderBufferSize: 0,
                maxViewportDims: [],
                maxVertexAttribs: 0,
                maxVertexUniformVectors: 0,
                maxFragmentUniformVectors: 0,
                maxVaryingVectors: 0,
                extensions: [],
                shadingLanguageVersion: '',
                antialias: false,
                unmaskedVendor: '',
                unmaskedRenderer: '',
                float32TextureLinear: false,
                highFloatPrecision: 0,
                mediumFloatPrecision: 0,
                lowFloatPrecision: 0
            };
            
            try {
                // Get WebGL context
                const canvas = document.createElement('canvas');
                let gl = canvas.getContext('webgl2');
                let isWebGL2 = !!gl;
                
                if (!gl) {
                    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                }
                
                if (!gl) {
                    return webgl;
                }
                
                webgl.supported = true;
                webgl.webgl2 = isWebGL2;
                
                // Get basic info
                webgl.vendor = gl.getParameter(gl.VENDOR);
                webgl.renderer = gl.getParameter(gl.RENDERER);
                webgl.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                webgl.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                webgl.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                webgl.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                webgl.maxViewportDims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
                webgl.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                webgl.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
                webgl.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                webgl.maxVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS);
                webgl.shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
                
                // Check for antialias
                webgl.antialias = gl.getContextAttributes().antialias;
                
                // Get unmasked info (for graphics card recognition)
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    webgl.unmaskedVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    webgl.unmaskedRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                }
                
                // Get supported extensions
                webgl.extensions = gl.getSupportedExtensions();
                
                // Check for float32 textures with linear filtering
                const ext = gl.getExtension('OES_texture_float_linear');
                webgl.float32TextureLinear = !!ext;
                
                // Check for float precision
                const shaderPrecision = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
                webgl.highFloatPrecision = shaderPrecision.precision;
                
                const mediumPrecision = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
                webgl.mediumFloatPrecision = mediumPrecision.precision;
                
                const lowPrecision = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT);
                webgl.lowFloatPrecision = lowPrecision.precision;
            } catch (e) {
                console.error('CSTestForge Feature Detector: Error detecting WebGL', e);
            }
            
            return webgl;
        },
        
        /**
         * Detect accessibility features
         * @returns {Object} Object with accessibility support information
         */
        detectAccessibility: function() {
            const accessibility = {
                aria: 'role' in document.createElement('div'),
                caption: 'track' in document.createElement('video'),
                landmark: this.isElementSupported('main') && this.isElementSupported('header') && this.isElementSupported('footer'),
                focusVisible: (() => {
                    try {
                        return this.isCssPropertySupported(':focus-visible', '{}');
                    } catch (e) {
                        return false;
                    }
                })(),
                reducedMotion: (() => {
                    try {
                        return typeof window.matchMedia === 'function' && 
                              window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                    } catch (e) {
                        return false;
                    }
                })(),
                forcedColors: (() => {
                    try {
                        return typeof window.matchMedia === 'function' && 
                              window.matchMedia('(forced-colors: active)').matches;
                    } catch (e) {
                        return false;
                    }
                })(),
                prefersColorScheme: (() => {
                    try {
                        if (typeof window.matchMedia !== 'function') {
                            return null;
                        }
                        
                        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                            return 'dark';
                        } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
                            return 'light';
                        } else {
                            return 'no-preference';
                        }
                    } catch (e) {
                        return null;
                    }
                })(),
                prefersContrast: (() => {
                    try {
                        if (typeof window.matchMedia !== 'function') {
                            return null;
                        }
                        
                        if (window.matchMedia('(prefers-contrast: more)').matches) {
                            return 'more';
                        } else if (window.matchMedia('(prefers-contrast: less)').matches) {
                            return 'less';
                        } else {
                            return 'no-preference';
                        }
                    } catch (e) {
                        return null;
                    }
                })(),
                keyboardNavigation: (() => {
                    try {
                        return 'tabIndex' in document.createElement('div');
                    } catch (e) {
                        return false;
                    }
                })(),
                focusModes: (() => {
                    try {
                        return 'focus' in document.activeElement;
                    } catch (e) {
                        return false;
                    }
                })()
            };
            
            return accessibility;
        },
        
        /**
         * Detect device capabilities
         * @returns {Object} Object with device capabilities information
         */
        detectDeviceCapabilities: function() {
            const deviceCapabilities = {
                vibrate: typeof navigator.vibrate === 'function',
                deviceMotion: typeof DeviceMotionEvent !== 'undefined',
                deviceOrientation: typeof DeviceOrientationEvent !== 'undefined',
                geolocation: !!navigator.geolocation,
                ambientLight: typeof window.AmbientLightSensor !== 'undefined',
                batteryStatus: !!navigator.getBattery,
                batteryLevel: (() => {
                    try {
                        if (navigator.battery) {
                            return navigator.battery.level;
                        } else if (navigator.getBattery) {
                            // We can't get it immediately, so return null
                            return null;
                        } else {
                            return null;
                        }
                    } catch (e) {
                        return null;
                    }
                })(),
                maxTouchPoints: navigator.maxTouchPoints || 0,
                hardwareConcurrency: navigator.hardwareConcurrency || 0,
                deviceMemory: navigator.deviceMemory || 0,
                screenWidth: window.screen.width,
                screenHeight: window.screen.height,
                screenColorDepth: window.screen.colorDepth,
                screenOrientation: (() => {
                    try {
                        if (window.screen.orientation) {
                            return window.screen.orientation.type;
                        } else if (window.orientation !== undefined) {
                            // Convert orientation angle to type
                            const angle = window.orientation;
                            if (angle === 0 || angle === 180) {
                                return 'portrait-primary';
                            } else {
                                return 'landscape-primary';
                            }
                        } else {
                            return null;
                        }
                    } catch (e) {
                        return null;
                    }
                })(),
                bluetooth: typeof navigator.bluetooth !== 'undefined',
                usb: typeof navigator.usb !== 'undefined',
                serial: typeof navigator.serial !== 'undefined',
                gamepad: typeof navigator.getGamepads === 'function',
                vr: typeof navigator.getVRDisplays === 'function' || typeof navigator.xr !== 'undefined',
                hid: typeof navigator.hid !== 'undefined',
                nfc: typeof navigator.nfc !== 'undefined',
                sensors: (() => {
                    try {
                        return {
                            accelerometer: typeof Accelerometer !== 'undefined',
                            gyroscope: typeof Gyroscope !== 'undefined',
                            magnetometer: typeof Magnetometer !== 'undefined',
                            ambientLight: typeof AmbientLightSensor !== 'undefined',
                            proximity: typeof ProximitySensor !== 'undefined',
                            absPressure: typeof AbsolutePressureSensor !== 'undefined',
                            relPressure: typeof RelativePressureSensor !== 'undefined',
                            linearAcceleration: typeof LinearAccelerationSensor !== 'undefined',
                            gravityAcceleration: typeof GravitySensor !== 'undefined'
                        };
                    } catch (e) {
                        return {};
                    }
                })(),
                permissions: typeof navigator.permissions !== 'undefined',
                mediaCapabilities: typeof navigator.mediaCapabilities !== 'undefined',
                compat: {
                    pointerEvents: typeof PointerEvent !== 'undefined',
                    touch: 'ontouchstart' in window,
                    msPointer: typeof MSPointerEvent !== 'undefined',
                    msTouchEvents: 'ontouchstart' in window && navigator.msMaxTouchPoints !== undefined,
                    passive: (() => {
                        try {
                            let support = false;
                            const options = Object.defineProperty({}, 'passive', {
                                get: function() { support = true; return true; }
                            });
                            window.addEventListener('test', null, options);
                            window.removeEventListener('test', null, options);
                            return support;
                        } catch (e) {
                            return false;
                        }
                    })()
                }
            };
            
            return deviceCapabilities;
        },
        
        /**
         * Handle incoming messages
         * @param {MessageEvent} event - The message event
         */
        handleMessage: function(event) {
            if (!event.data || event.data.type !== 'CSTestForge_FeatureDetectorCommand') {
                return;
            }
            
            const command = event.data.command;
            
            switch (command) {
                case 'detectFeatures':
                    this.detectAllFeatures();
                    break;
                    
                case 'getBrowserInfo':
                    this.sendBrowserInfo();
                    break;
                    
                case 'testFeature':
                    this.testFeature(event.data.feature);
                    break;
                    
                case 'getBatteryStatus':
                    this.getBatteryStatus();
                    break;
                    
                case 'updateConfig':
                    this.updateConfig(event.data.config);
                    break;
                    
                default:
                    console.warn('CSTestForge Feature Detector: Unknown command', command);
            }
        },
        
        /**
         * Handle resize event
         */
        handleResize: function() {
            // Update viewport size
            browserInfo.viewport = {
                width: window.innerWidth || document.documentElement.clientWidth,
                height: window.innerHeight || document.documentElement.clientHeight
            };
            
            // Send viewport update event
            CONFIG.postMessage({
                type: 'viewportUpdate',
                viewport: browserInfo.viewport,
                timestamp: Date.now()
            });
        },
        
        /**
         * Send browser information
         */
        sendBrowserInfo: function() {
            CONFIG.postMessage({
                type: 'browserInfo',
                browser: browserInfo,
                timestamp: Date.now()
            });
        },
        
        /**
         * Test a specific feature
         * @param {string} feature - The feature to test
         */
        testFeature: function(feature) {
            let result = false;
            let details = null;
            
            switch (feature) {
                case 'webgl':
                    details = this.detectWebGL();
                    result = details.supported;
                    break;
                    
                case 'webp':
                    result = this.testWebP();
                    break;
                    
                case 'avif':
                    result = this.testAVIF();
                    break;
                    
                case 'webm':
                    details = this.detectMedia().videoFormats.webm;
                    result = !!details;
                    break;
                    
                case 'websocket':
                    result = typeof WebSocket !== 'undefined';
                    break;
                    
                case 'webrtc':
                    result = !!(window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection);
                    break;
                    
                case 'webassembly':
                    result = typeof WebAssembly !== 'undefined';
                    break;
                    
                case 'flexbox':
                    result = this.isCssPropertySupported('flexDirection');
                    break;
                    
                case 'gridlayout':
                    result = this.isCssPropertySupported('gridTemplateColumns');
                    break;
                    
                case 'es6':
                    result = this.testES6Support();
                    break;
                    
                case 'touch':
                    result = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
                    break;
                    
                case 'canvas':
                    try {
                        const canvas = document.createElement('canvas');
                        result = !!(canvas.getContext && canvas.getContext('2d'));
                    } catch (e) {
                        result = false;
                    }
                    break;
                    
                case 'cors':
                    result = 'withCredentials' in new XMLHttpRequest();
                    break;
                    
                case 'serviceworker':
                    result = 'serviceWorker' in navigator;
                    break;
                    
                default:
                    console.warn('CSTestForge Feature Detector: Unknown feature', feature);
            }
            
            // Send feature test result
            CONFIG.postMessage({
                type: 'featureTest',
                feature: feature,
                supported: result,
                details: details,
                timestamp: Date.now()
            });
        },
        
        /**
         * Test WebP support
         * @returns {boolean} Whether WebP is supported
         */
        testWebP: function() {
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            
            try {
                const ctx = canvas.getContext('2d');
                const dataUrl = canvas.toDataURL('image/webp');
                return dataUrl.indexOf('data:image/webp') === 0;
            } catch (e) {
                return false;
            }
        },
        
        /**
         * Test AVIF support
         * @returns {boolean} Whether AVIF is supported
         */
        testAVIF: function() {
            // We can't directly test AVIF with canvas,
            // so we check if the browser family is known to support it
            const avifSupportingBrowsers = {
                'Chrome': 85,
                'Firefox': 86,
                'Edge': 90,
                'Opera': 71
            };
            
            if (browserInfo.name in avifSupportingBrowsers) {
                const minVersion = avifSupportingBrowsers[browserInfo.name];
                const currentVersion = parseInt(browserInfo.version, 10);
                
                return !isNaN(currentVersion) && currentVersion >= minVersion;
            }
            
            return false;
        },
        
        /**
         * Test ES6 support
         * @returns {boolean} Whether ES6 is supported
         */
        testES6Support: function() {
            try {
                // Test arrow functions
                eval('var arrow = (x) => x;');
                
                // Test let/const
                eval('let x = 1; const y = 2;');
                
                // Test template literals
                eval('var tmpl = `test`;');
                
                // Test destructuring
                eval('var {a, b} = {a: 1, b: 2};');
                
                // Test classes
                eval('class TestClass { constructor() {} }');
                
                // Test promises
                if (typeof Promise !== 'function') {
                    return false;
                }
                
                return true;
            } catch (e) {
                return false;
            }
        },
        
        /**
         * Get battery status
         */
        getBatteryStatus: function() {
            if (!navigator.getBattery) {
                CONFIG.postMessage({
                    type: 'batteryStatus',
                    supported: false,
                    timestamp: Date.now()
                });
                return;
            }
            
            navigator.getBattery().then(battery => {
                const status = {
                    charging: battery.charging,
                    level: battery.level,
                    chargingTime: battery.chargingTime,
                    dischargingTime: battery.dischargingTime
                };
                
                CONFIG.postMessage({
                    type: 'batteryStatus',
                    supported: true,
                    status: status,
                    timestamp: Date.now()
                });
            }).catch(() => {
                CONFIG.postMessage({
                    type: 'batteryStatus',
                    supported: false,
                    timestamp: Date.now()
                });
            });
        },
        
        /**
         * Update configuration settings
         * @param {Object} newConfig - New configuration settings
         */
        updateConfig: function(newConfig) {
            // Update settings
            for (const key in newConfig) {
                if (CONFIG.hasOwnProperty(key)) {
                    CONFIG[key] = newConfig[key];
                }
            }
            
            // Send configuration updated event
            CONFIG.postMessage({
                type: 'configUpdated',
                timestamp: Date.now()
            });
        }
    };
    
    // Initialize feature detector
    CSFeatureDetector.init();
    
    // Make the detector available for manual access
    window.__CSFeatureDetector = CSFeatureDetector;
})();


version-dector.js
---------------------------------------------------

/**
 * version-detector.js
 * Part of CSTestForge Browser Integration Module
 * 
 * This script is responsible for detecting browser versions and framework
 * versions used by the application under test. It provides detailed compatibility
 * information and can identify potential issues that may affect test execution.
 */

(function() {
    'use strict';
    
    // Configuration
    const CONFIG = {
        // Whether to detect versions
        enabled: true,
        
        // Types of versions to detect
        detectBrowserVersion: true,
        detectJSFrameworks: true,
        detectCSSFrameworks: true,
        detectTestingFrameworks: true,
        detectAPIs: true,
        
        // Whether to report warnings for compatibility issues
        reportCompatibilityWarnings: true,
        
        // Minimum supported versions
        minimumVersions: {
            chrome: 88,
            firefox: 78,
            safari: 14,
            edge: 88,
            opera: 74,
            ie: 11
        },
        
        // Function to post messages to the parent application
        postMessage: function(message) {
            try {
                window.parent.postMessage({
                    type: 'CSTestForge_VersionDetector',
                    data: message,
                    frameId: CSVersionDetector.frameId,
                    url: window.location.href
                }, '*');
            } catch (e) {
                console.error('CSTestForge Version Detector: Error sending message', e);
            }
        }
    };
    
    // Framework signatures to detect
    const frameworkSignatures = {
        // JavaScript frameworks
        jsFrameworks: [
            {
                name: 'React',
                detector: function() {
                    return !!(window.React || window.__REACT_DEVTOOLS_GLOBAL_HOOK__ || 
                             document.querySelector('[data-reactroot], [data-reactid]'));
                },
                versionDetector: function() {
                    if (window.React && window.React.version) {
                        return window.React.version;
                    }
                    return null;
                }
            },
            {
                name: 'Angular',
                detector: function() {
                    return !!(window.angular || document.querySelector('[ng-app], [ng-controller], [ng-model], [data-ng-app], [data-ng-controller], [data-ng-model], [x-ng-app], [x-ng-controller], [x-ng-model]') || 
                             document.querySelector('.ng-binding, .ng-scope') ||
                             window.getAllAngularRootElements);
                },
                versionDetector: function() {
                    if (window.angular && window.angular.version) {
                        return window.angular.version.full;
                    }
                    if (window.ng && window.ng.probe && document.querySelector('[ng-version]')) {
                        return document.querySelector('[ng-version]').getAttribute('ng-version');
                    }
                    return null;
                }
            },
            {
                name: 'AngularJS',
                detector: function() {
                    return !!(window.angular && !window.getAllAngularRootElements);
                },
                versionDetector: function() {
                    if (window.angular && window.angular.version) {
                        return window.angular.version.full;
                    }
                    return null;
                }
            },
            {
                name: 'Vue',
                detector: function() {
                    return !!(window.Vue || 
                             document.querySelector('[data-v-app], [data-v-], [v-cloak], [v-if], [v-for], [v-show], [v-hide], [v-on], [v-bind]') ||
                             window.__VUE__);
                },
                versionDetector: function() {
                    if (window.Vue && window.Vue.version) {
                        return window.Vue.version;
                    }
                    // Try finding Vue devtools global
                    if (window.__VUE__ && window.__VUE_DEVTOOLS_GLOBAL_HOOK__ && window.__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue) {
                        return window.__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue.version;
                    }
                    return null;
                }
            },
            {
                name: 'Ember',
                detector: function() {
                    return !!(window.Ember || document.querySelector('[data-ember-action]') || window.EmberENV);
                },
                versionDetector: function() {
                    if (window.Ember && window.Ember.VERSION) {
                        return window.Ember.VERSION;
                    }
                    return null;
                }
            },
            {
                name: 'Backbone',
                detector: function() {
                    return !!window.Backbone;
                },
                versionDetector: function() {
                    if (window.Backbone && window.Backbone.VERSION) {
                        return window.Backbone.VERSION;
                    }
                    return null;
                }
            },
            {
                name: 'jQuery',
                detector: function() {
                    return !!(window.jQuery || window.$);
                },
                versionDetector: function() {
                    if (window.jQuery && window.jQuery.fn && window.jQuery.fn.jquery) {
                        return window.jQuery.fn.jquery;
                    } else if (window.$ && window.$.fn && window.$.fn.jquery) {
                        return window.$.fn.jquery;
                    }
                    return null;
                }
            },
            {
                name: 'Lodash',
                detector: function() {
                    return !!(window._ && window._.VERSION);
                },
                versionDetector: function() {
                    if (window._ && window._.VERSION) {
                        return window._.VERSION;
                    }
                    return null;
                }
            },
            {
                name: 'Underscore',
                detector: function() {
                    return !!(window._ && window._.VERSION && !window._.mixin);
                },
                versionDetector: function() {
                    if (window._ && window._.VERSION) {
                        return window._.VERSION;
                    }
                    return null;
                }
            },
            {
                name: 'Redux',
                detector: function() {
                    return !!(window.Redux || window.__REDUX_DEVTOOLS_EXTENSION__);
                },
                versionDetector: function() {
                    if (window.Redux && window.Redux.version) {
                        return window.Redux.version;
                    }
                    return null;
                }
            },
            {
                name: 'Svelte',
                detector: function() {
                    return !!(document.querySelector('style[data-svelte]') ||
                             document.querySelectorAll('*[class*=svelte-]').length > 0 ||
                             window.__SVELTE__ || 
                             document.querySelector('*[__svelte-data]'));
                },
                versionDetector: function() {
                    // Svelte doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Alpine.js',
                detector: function() {
                    return !!(window.Alpine || document.querySelector('[x-data], [x-init], [x-show], [x-bind], [x-text], [x-html], [x-if], [x-for]'));
                },
                versionDetector: function() {
                    if (window.Alpine && window.Alpine.version) {
                        return window.Alpine.version;
                    }
                    return null;
                }
            },
            {
                name: 'Polymer',
                detector: function() {
                    return !!(window.Polymer || document.querySelector('[is=dom-module]'));
                },
                versionDetector: function() {
                    if (window.Polymer && window.Polymer.version) {
                        return window.Polymer.version;
                    }
                    return null;
                }
            },
            {
                name: 'LitElement',
                detector: function() {
                    return !!(window.litElementVersions || window.LitElement);
                },
                versionDetector: function() {
                    if (window.litElementVersions && window.litElementVersions.length) {
                        return window.litElementVersions[0];
                    }
                    return null;
                }
            },
            {
                name: 'Preact',
                detector: function() {
                    return !!(window.preact || (window.__PREACT_DEVTOOLS__ && !window.React));
                },
                versionDetector: function() {
                    // Preact doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Next.js',
                detector: function() {
                    return !!document.querySelector('#__next') || window.__NEXT_DATA__;
                },
                versionDetector: function() {
                    // Next.js doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Nuxt.js',
                detector: function() {
                    return !!document.querySelector('#__nuxt, #__layout') || window.__NUXT__;
                },
                versionDetector: function() {
                    // Nuxt doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Gatsby',
                detector: function() {
                    return !!window.___gatsby || document.querySelector('#___gatsby');
                },
                versionDetector: function() {
                    // Gatsby doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Meteor',
                detector: function() {
                    return !!window.Meteor;
                },
                versionDetector: function() {
                    if (window.Meteor && window.Meteor.release) {
                        return window.Meteor.release;
                    }
                    return null;
                }
            },
            {
                name: 'D3.js',
                detector: function() {
                    return !!window.d3;
                },
                versionDetector: function() {
                    if (window.d3 && window.d3.version) {
                        return window.d3.version;
                    }
                    return null;
                }
            },
            {
                name: 'Knockout',
                detector: function() {
                    return !!window.ko;
                },
                versionDetector: function() {
                    if (window.ko && window.ko.version) {
                        return window.ko.version;
                    }
                    return null;
                }
            },
            {
                name: 'Mootools',
                detector: function() {
                    return !!(window.MooTools || window.mootools || window.$);
                },
                versionDetector: function() {
                    if (window.MooTools && window.MooTools.version) {
                        return window.MooTools.version;
                    }
                    return null;
                }
            },
            {
                name: 'Prototype.js',
                detector: function() {
                    return !!(window.Prototype);
                },
                versionDetector: function() {
                    if (window.Prototype && window.Prototype.Version) {
                        return window.Prototype.Version;
                    }
                    return null;
                }
            },
            {
                name: 'Three.js',
                detector: function() {
                    return !!(window.THREE);
                },
                versionDetector: function() {
                    if (window.THREE && window.THREE.REVISION) {
                        return window.THREE.REVISION;
                    }
                    return null;
                }
            },
            {
                name: 'Babylon.js',
                detector: function() {
                    return !!(window.BABYLON);
                },
                versionDetector: function() {
                    if (window.BABYLON && window.BABYLON.Engine && window.BABYLON.Engine.Version) {
                        return window.BABYLON.Engine.Version;
                    }
                    return null;
                }
            },
            {
                name: 'PixiJS',
                detector: function() {
                    return !!(window.PIXI);
                },
                versionDetector: function() {
                    if (window.PIXI && window.PIXI.VERSION) {
                        return window.PIXI.VERSION;
                    }
                    return null;
                }
            },
            {
                name: 'GSAP',
                detector: function() {
                    return !!(window.gsap || window.TweenMax || window.TweenLite);
                },
                versionDetector: function() {
                    if (window.gsap && window.gsap.version) {
                        return window.gsap.version;
                    } else if (window.TweenMax && window.TweenMax.version) {
                        return window.TweenMax.version;
                    } else if (window.TweenLite && window.TweenLite.version) {
                        return window.TweenLite.version;
                    }
                    return null;
                }
            },
            {
                name: 'Anime.js',
                detector: function() {
                    return !!(window.anime);
                },
                versionDetector: function() {
                    if (window.anime && window.anime.version) {
                        return window.anime.version;
                    }
                    return null;
                }
            },
            {
                name: 'Axios',
                detector: function() {
                    return !!(window.axios);
                },
                versionDetector: function() {
                    if (window.axios && window.axios.VERSION) {
                        return window.axios.VERSION;
                    }
                    return null;
                }
            },
            {
                name: 'Moment.js',
                detector: function() {
                    return !!(window.moment);
                },
                versionDetector: function() {
                    if (window.moment && window.moment.version) {
                        return window.moment.version;
                    }
                    return null;
                }
            },
            {
                name: 'Day.js',
                detector: function() {
                    return !!(window.dayjs);
                },
                versionDetector: function() {
                    if (window.dayjs && window.dayjs.version) {
                        return window.dayjs.version;
                    }
                    return null;
                }
            },
            {
                name: 'Luxon',
                detector: function() {
                    return !!(window.luxon);
                },
                versionDetector: function() {
                    if (window.luxon && window.luxon.VERSION) {
                        return window.luxon.VERSION;
                    }
                    return null;
                }
            },
            {
                name: 'date-fns',
                detector: function() {
                    return !!(window.dateFns);
                },
                versionDetector: function() {
                    // date-fns doesn't expose its version easily
                    return null;
                }
            }
        ],
        
        // CSS frameworks
        cssFrameworks: [
            {
                name: 'Bootstrap',
                detector: function() {
                    return !!(document.querySelector('[class*="col-"], .row, .container, .container-fluid, .navbar, .btn, .modal, .carousel') ||
                            document.querySelector('link[href*="bootstrap"]'));
                },
                versionDetector: function() {
                    // Try to find version in CSS or JS
                    const bootstrapJS = document.querySelector('script[src*="bootstrap"]');
                    if (bootstrapJS && bootstrapJS.src.match(/bootstrap@(\d+\.\d+\.\d+)/)) {
                        return bootstrapJS.src.match(/bootstrap@(\d+\.\d+\.\d+)/)[1];
                    }
                    
                    const bootstrapCSS = document.querySelector('link[href*="bootstrap"]');
                    if (bootstrapCSS && bootstrapCSS.href.match(/bootstrap@(\d+\.\d+\.\d+)/)) {
                        return bootstrapCSS.href.match(/bootstrap@(\d+\.\d+\.\d+)/)[1];
                    }
                    
                    // Bootstrap versions have distinct features
                    if (document.querySelector('.container-xxl, .col-xxl, .row-cols-xxl')) {
                        return '5.x';
                    } else if (document.querySelector('.toast, .stretched-link, .spinner-border')) {
                        return '4.x';
                    } else if (document.querySelector('.img-fluid, .card')) {
                        return '4.x';
                    } else if (document.querySelector('.img-responsive, .panel')) {
                        return '3.x';
                    } else if (document.querySelector('.row, .container')) {
                        return '2.x';
                    }
                    
                    return null;
                }
            },
            {
                name: 'Tailwind CSS',
                detector: function() {
                    // Check for Tailwind's distinctive class patterns
                    const hasTailwindClasses = document.querySelectorAll('[class*="text-"], [class*="bg-"], [class*="border-"], [class*="shadow-"], [class*="p-"], [class*="m-"], [class*="grid-"], [class*="flex-"]').length > 10;
                    
                    // Check if we have a lot of classes with tailwind patterns
                    if (hasTailwindClasses) {
                        return true;
                    }
                    
                    return !!document.querySelector('link[href*="tailwind"]');
                },
                versionDetector: function() {
                    // Tailwind doesn't expose its version easily
                    // But we can try to infer based on available classes
                    if (document.querySelector('[class*="aspect-"], [class*="container-"], [class*="text-opacity-"]')) {
                        return '2.x';
                    } else if (document.querySelector('[class*="space-x-"], [class*="space-y-"], [class*="transform-"]')) {
                        return '1.x';
                    }
                    return null;
                }
            },
            {
                name: 'Bulma',
                detector: function() {
                    return !!(document.querySelector('.columns, .column, .is-primary, .is-info, .is-success, .is-warning, .is-danger, .is-link, .navbar, .hero, .section, .footer') ||
                            document.querySelector('link[href*="bulma"]'));
                },
                versionDetector: function() {
                    const bulmaCSS = document.querySelector('link[href*="bulma"]');
                    if (bulmaCSS && bulmaCSS.href.match(/bulma@(\d+\.\d+\.\d+)/)) {
                        return bulmaCSS.href.match(/bulma@(\d+\.\d+\.\d+)/)[1];
                    }
                    return null;
                }
            },
            {
                name: 'Foundation',
                detector: function() {
                    return !!(document.querySelector('.row, .columns, .small-up, .medium-up, .large-up, .button, .top-bar, .orbit') ||
                            document.querySelector('link[href*="foundation"]'));
                },
                versionDetector: function() {
                    const foundationJS = document.querySelector('script[src*="foundation"]');
                    if (foundationJS && foundationJS.src.match(/foundation@(\d+\.\d+\.\d+)/)) {
                        return foundationJS.src.match(/foundation@(\d+\.\d+\.\d+)/)[1];
                    }
                    
                    const foundationCSS = document.querySelector('link[href*="foundation"]');
                    if (foundationCSS && foundationCSS.href.match(/foundation@(\d+\.\d+\.\d+)/)) {
                        return foundationCSS.href.match(/foundation@(\d+\.\d+\.\d+)/)[1];
                    }
                    
                    if (document.querySelector('.grid-x, .cell')) {
                        return '6.x';
                    } else if (document.querySelector('.row, .columns')) {
                        return '5.x or earlier';
                    }
                    
                    return null;
                }
            },
            {
                name: 'Materialize CSS',
                detector: function() {
                    return !!(document.querySelector('.materialize, .card, .card-panel, .waves-effect, .btn, .btn-flat, .fixed-action-btn, .sidenav, .navbar') ||
                            document.querySelector('link[href*="materialize"]'));
                },
                versionDetector: function() {
                    const materializeCSS = document.querySelector('link[href*="materialize"]');
                    if (materializeCSS && materializeCSS.href.match(/materialize@(\d+\.\d+\.\d+)/)) {
                        return materializeCSS.href.match(/materialize@(\d+\.\d+\.\d+)/)[1];
                    }
                    return null;
                }
            },
            {
                name: 'Material-UI',
                detector: function() {
                    return !!(document.querySelector('.MuiButton-root, .MuiPaper-root, .MuiTypography-root, .MuiContainer-root, .MuiAppBar-root, .MuiToolbar-root, .MuiGrid-root'));
                },
                versionDetector: function() {
                    // Material-UI doesn't expose its version easily
                    if (document.querySelector('.MuiV5-root')) {
                        return '5.x';
                    } else if (document.querySelector('.MuiBox-root')) {
                        return '4.x';
                    } else if (document.querySelector('.MuiButton-root')) {
                        return '3.x or 4.x';
                    }
                    return null;
                }
            },
            {
                name: 'Chakra UI',
                detector: function() {
                    return !!(document.querySelector('[class^="chakra-"], [data-chakra-component]'));
                },
                versionDetector: function() {
                    // Chakra UI doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Semantic UI',
                detector: function() {
                    return !!(document.querySelector('.ui.segment, .ui.button, .ui.grid, .ui.menu, .ui.form, .ui.header, .ui.list, .ui.card') ||
                            document.querySelector('link[href*="semantic"]'));
                },
                versionDetector: function() {
                    const semanticJS = document.querySelector('script[src*="semantic"]');
                    if (semanticJS && semanticJS.src.match(/semantic@(\d+\.\d+\.\d+)/)) {
                        return semanticJS.src.match(/semantic@(\d+\.\d+\.\d+)/)[1];
                    }
                    
                    const semanticCSS = document.querySelector('link[href*="semantic"]');
                    if (semanticCSS && semanticCSS.href.match(/semantic@(\d+\.\d+\.\d+)/)) {
                        return semanticCSS.href.match(/semantic@(\d+\.\d+\.\d+)/)[1];
                    }
                    return null;
                }
            },
            {
                name: 'Ant Design',
                detector: function() {
                    return !!(document.querySelector('.ant-btn, .ant-input, .ant-form, .ant-layout, .ant-menu, .ant-table, .ant-pagination, .ant-modal'));
                },
                versionDetector: function() {
                    // Ant Design doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'UIKit',
                detector: function() {
                    return !!(document.querySelector('[uk-grid], [uk-modal], [uk-tooltip], [uk-toggle], [uk-scrollspy], .uk-button, .uk-card, .uk-container, .uk-navbar') ||
                            document.querySelector('link[href*="uikit"]'));
                },
                versionDetector: function() {
                    if (window.UIkit && window.UIkit.version) {
                        return window.UIkit.version;
                    }
                    
                    const uikitJS = document.querySelector('script[src*="uikit"]');
                    if (uikitJS && uikitJS.src.match(/uikit@(\d+\.\d+\.\d+)/)) {
                        return uikitJS.src.match(/uikit@(\d+\.\d+\.\d+)/)[1];
                    }
                    
                    return null;
                }
            },
            {
                name: 'Skeleton',
                detector: function() {
                    return !!(document.querySelector('.container, .column, .columns, .row') && 
                            document.querySelector('link[href*="skeleton"]'));
                },
                versionDetector: function() {
                    // Skeleton doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Primer',
                detector: function() {
                    return !!(document.querySelector('.d-flex, .color-bg-primary, .color-text-primary, .btn, .Box, .Layout, .Subhead, .flash') ||
                            document.querySelector('link[href*="primer"]'));
                },
                versionDetector: function() {
                    // Primer doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Pure CSS',
                detector: function() {
                    return !!(document.querySelector('.pure-g, .pure-u, .pure-menu, .pure-button, .pure-form, .pure-table') ||
                            document.querySelector('link[href*="pure"]'));
                },
                versionDetector: function() {
                    const pureCSS = document.querySelector('link[href*="pure"]');
                    if (pureCSS && pureCSS.href.match(/pure@(\d+\.\d+\.\d+)/)) {
                        return pureCSS.href.match(/pure@(\d+\.\d+\.\d+)/)[1];
                    }
                    return null;
                }
            },
            {
                name: 'Spectre.css',
                detector: function() {
                    return !!(document.querySelector('.container, .columns, .column, .btn, .form-input, .card, .menu, .navbar') &&
                            document.querySelector('link[href*="spectre"]'));
                },
                versionDetector: function() {
                    const spectreCSS = document.querySelector('link[href*="spectre"]');
                    if (spectreCSS && spectreCSS.href.match(/spectre@(\d+\.\d+\.\d+)/)) {
                        return spectreCSS.href.match(/spectre@(\d+\.\d+\.\d+)/)[1];
                    }
                    return null;
                }
            },
            {
                name: 'Milligram',
                detector: function() {
                    return !!(document.querySelector('.container, .row, .column, .button') &&
                            document.querySelector('link[href*="milligram"]'));
                },
                versionDetector: function() {
                    const milligramCSS = document.querySelector('link[href*="milligram"]');
                    if (milligramCSS && milligramCSS.href.match(/milligram@(\d+\.\d+\.\d+)/)) {
                        return milligramCSS.href.match(/milligram@(\d+\.\d+\.\d+)/)[1];
                    }
                    return null;
                }
            }
        ],
        
        // Testing frameworks
        testingFrameworks: [
            {
                name: 'Jest',
                detector: function() {
                    return !!(window.jest || window.afterAll || window.beforeAll || window.test || window.it || window.describe);
                },
                versionDetector: function() {
                    // Jest doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Mocha',
                detector: function() {
                    return !!(window.mocha || window.Mocha);
                },
                versionDetector: function() {
                    if (window.mocha && window.mocha.version) {
                        return window.mocha.version;
                    }
                    return null;
                }
            },
            {
                name: 'Jasmine',
                detector: function() {
                    return !!(window.jasmine);
                },
                versionDetector: function() {
                    if (window.jasmine && window.jasmine.version) {
                        return window.jasmine.version;
                    }
                    return null;
                }
            },
            {
                name: 'QUnit',
                detector: function() {
                    return !!(window.QUnit);
                },
                versionDetector: function() {
                    if (window.QUnit && window.QUnit.version) {
                        return window.QUnit.version;
                    }
                    return null;
                }
            },
            {
                name: 'Sinon',
                detector: function() {
                    return !!(window.sinon);
                },
                versionDetector: function() {
                    if (window.sinon && window.sinon.version) {
                        return window.sinon.version;
                    }
                    return null;
                }
            },
            {
                name: 'Chai',
                detector: function() {
                    return !!(window.chai);
                },
                versionDetector: function() {
                    if (window.chai && window.chai.version) {
                        return window.chai.version;
                    }
                    return null;
                }
            },
            {
                name: 'Cypress',
                detector: function() {
                    return !!(window.Cypress || window.cy);
                },
                versionDetector: function() {
                    if (window.Cypress && window.Cypress.version) {
                        return window.Cypress.version;
                    }
                    return null;
                }
            },
            {
                name: 'Selenium',
                detector: function() {
                    return !!(window.selenium || document.querySelector('.selenium-agent'));
                },
                versionDetector: function() {
                    // Selenium doesn't expose its version easily in the browser
                    return null;
                }
            },
            {
                name: 'Testing Library',
                detector: function() {
                    return !!(window.TestingLibraryDom || 
                             document.querySelector('[data-testid]'));
                },
                versionDetector: function() {
                    // Testing Library doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Playwright',
                detector: function() {
                    return !!(window.__playwright || window.playwright);
                },
                versionDetector: function() {
                    // Playwright doesn't expose its version easily
                    return null;
                }
            },
            {
                name: 'Puppeteer',
                detector: function() {
                    return !!(window.__puppeteer || 
                             navigator.userAgent.includes('HeadlessChrome'));
                },
                versionDetector: function() {
                    // Puppeteer doesn't expose its version easily
                    return null;
                }
            }
        ]
    };
    
    // Keep track of detected versions
    const detectedVersions = {
        browser: null,
        jsFrameworks: [],
        cssFrameworks: [],
        testingFrameworks: [],
        apis: []
    };
    
    // Compatibility warnings
    const compatibilityWarnings = [];
    
    // Unique ID for this frame
    const frameId = 'csframe_' + Math.random().toString(36).substring(2, 15);
    
    /**
     * Version Detector Implementation
     */
    const CSVersionDetector = {
        // Frame identifier
        frameId: frameId,
        
        /**
         * Initialize the version detector
         */
        init: function() {
            if (!CONFIG.enabled) {
                return;
            }
            
            // Detect browser version
            if (CONFIG.detectBrowserVersion) {
                this.detectBrowserVersion();
            }
            
            // Detect JS frameworks
            if (CONFIG.detectJSFrameworks) {
                this.detectJSFrameworks();
            }
            
            // Detect CSS frameworks
            if (CONFIG.detectCSSFrameworks) {
                this.detectCSSFrameworks();
            }
            
            // Detect testing frameworks
            if (CONFIG.detectTestingFrameworks) {
                this.detectTestingFrameworks();
            }
            
            // Detect APIs
            if (CONFIG.detectAPIs) {
                this.detectAPIs();
            }
            
            // Check for compatibility issues
            if (CONFIG.reportCompatibilityWarnings) {
                this.checkCompatibility();
            }
            
            // Listen for control messages
            window.addEventListener('message', this.handleMessage.bind(this));
            
            // Send initialization event
            CONFIG.postMessage({
                type: 'init',
                versions: detectedVersions,
                warnings: compatibilityWarnings,
                timestamp: Date.now()
            });
            
            console.log('CSTestForge Version Detector: Initialized');
        },
        
        /**
         * Detect browser version
         */
        detectBrowserVersion: function() {
            const ua = navigator.userAgent;
            let browser = null;
            
            // Chrome
            let match = ua.match(/(Chrome|Chromium)\/(\d+\.\d+\.\d+\.\d+)/);
            if (match) {
                browser = {
                    name: match[1],
                    version: match[2],
                    majorVersion: parseInt(match[2])
                };
                
                // Check if it's actually Edge
                const edgeMatch = ua.match(/Edg\/(\d+\.\d+\.\d+\.\d+)/);
                if (edgeMatch) {
                    browser = {
                        name: 'Edge',
                        version: edgeMatch[1],
                        majorVersion: parseInt(edgeMatch[1])
                    };
                }
                
                // Check if it's actually Opera
                const operaMatch = ua.match(/OPR\/(\d+\.\d+\.\d+)/);
                if (operaMatch) {
                    browser = {
                        name: 'Opera',
                        version: operaMatch[1],
                        majorVersion: parseInt(operaMatch[1])
                    };
                }
            } else {
                // Firefox
                match = ua.match(/Firefox\/(\d+\.\d+)/);
                if (match) {
                    browser = {
                        name: 'Firefox',
                        version: match[1],
                        majorVersion: parseInt(match[1])
                    };
                } else {
                    // Safari
                    match = ua.match(/Version\/(\d+\.\d+).*Safari/);
                    if (match) {
                        browser = {
                            name: 'Safari',
                            version: match[1],
                            majorVersion: parseInt(match[1])
                        };
                    } else {
                        // Internet Explorer
                        match = ua.match(/MSIE (\d+\.\d+)/);
                        if (match) {
                            browser = {
                                name: 'Internet Explorer',
                                version: match[1],
                                majorVersion: parseInt(match[1])
                            };
                        } else {
                            // IE 11
                            if (ua.indexOf('Trident/7.0') > -1) {
                                browser = {
                                    name: 'Internet Explorer',
                                    version: '11.0',
                                    majorVersion: 11
                                };
                            }
                        }
                    }
                }
            }
            
            detectedVersions.browser = browser;
        },
        
        /**
         * Detect JavaScript frameworks
         */
        detectJSFrameworks: function() {
            for (const framework of frameworkSignatures.jsFrameworks) {
                try {
                    if (framework.detector()) {
                        const version = framework.versionDetector ? framework.versionDetector() : null;
                        
                        detectedVersions.jsFrameworks.push({
                            name: framework.name,
                            version: version,
                            majorVersion: version ? parseInt(version) : null
                        });
                    }
                } catch (e) {
                    console.error(`CSTestForge Version Detector: Error detecting ${framework.name}`, e);
                }
            }
        },
        
        /**
         * Detect CSS frameworks
         */
        detectCSSFrameworks: function() {
            for (const framework of frameworkSignatures.cssFrameworks) {
                try {
                    if (framework.detector()) {
                        const version = framework.versionDetector ? framework.versionDetector() : null;
                        
                        detectedVersions.cssFrameworks.push({
                            name: framework.name,
                            version: version,
                            majorVersion: version && !isNaN(parseInt(version)) ? parseInt(version) : null
                        });
                    }
                } catch (e) {
                    console.error(`CSTestForge Version Detector: Error detecting ${framework.name}`, e);
                }
            }
        },
        
        /**
         * Detect testing frameworks
         */
        detectTestingFrameworks: function() {
            for (const framework of frameworkSignatures.testingFrameworks) {
                try {
                    if (framework.detector()) {
                        const version = framework.versionDetector ? framework.versionDetector() : null;
                        
                        detectedVersions.testingFrameworks.push({
                            name: framework.name,
                            version: version,
                            majorVersion: version && !isNaN(parseInt(version)) ? parseInt(version) : null
                        });
                    }
                } catch (e) {
                    console.error(`CSTestForge Version Detector: Error detecting ${framework.name}`, e);
                }
            }
        },
        
        /**
         * Detect APIs used by the application
         */
        detectAPIs: function() {
            const apis = [];
            
            // Common APIs to check
            const apiChecks = [
                { name: 'Fetch API', check: typeof fetch !== 'undefined' },
                { name: 'Intersection Observer', check: typeof IntersectionObserver !== 'undefined' },
                { name: 'Mutation Observer', check: typeof MutationObserver !== 'undefined' },
                { name: 'Resize Observer', check: typeof ResizeObserver !== 'undefined' },
                { name: 'Performance Observer', check: typeof PerformanceObserver !== 'undefined' },
                { name: 'Web Animations', check: typeof Element.prototype.animate !== 'undefined' },
                { name: 'Custom Elements', check: typeof customElements !== 'undefined' },
                { name: 'Shadow DOM', check: typeof Element.prototype.attachShadow !== 'undefined' },
                { name: 'Web Components', check: typeof customElements !== 'undefined' && typeof Element.prototype.attachShadow !== 'undefined' },
                { name: 'Service Worker', check: typeof navigator.serviceWorker !== 'undefined' },
                { name: 'WebSockets', check: typeof WebSocket !== 'undefined' },
                { name: 'WebRTC', check: typeof RTCPeerConnection !== 'undefined' },
                { name: 'WebGL', check: (() => {
                    try {
                        const canvas = document.createElement('canvas');
                        return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                    } catch (e) {
                        return false;
                    }
                })() },
                { name: 'WebGL 2', check: (() => {
                    try {
                        const canvas = document.createElement('canvas');
                        return !!canvas.getContext('webgl2');
                    } catch (e) {
                        return false;
                    }
                })() },
                { name: 'Canvas', check: typeof CanvasRenderingContext2D !== 'undefined' },
                { name: 'Web Audio', check: typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined' },
                { name: 'Geolocation', check: typeof navigator.geolocation !== 'undefined' },
                { name: 'Web Workers', check: typeof Worker !== 'undefined' },
                { name: 'IndexedDB', check: typeof indexedDB !== 'undefined' },
                { name: 'WebVR', check: typeof navigator.getVRDisplays !== 'undefined' },
                { name: 'WebXR', check: typeof navigator.xr !== 'undefined' },
                { name: 'Gamepad API', check: typeof navigator.getGamepads !== 'undefined' },
                { name: 'Web Bluetooth', check: typeof navigator.bluetooth !== 'undefined' },
                { name: 'Web USB', check: typeof navigator.usb !== 'undefined' },
                { name: 'Web Serial', check: typeof navigator.serial !== 'undefined' },
                { name: 'Payment Request API', check: typeof PaymentRequest !== 'undefined' },
                { name: 'Credential Management API', check: typeof navigator.credentials !== 'undefined' },
                { name: 'Web Share API', check: typeof navigator.share !== 'undefined' },
                { name: 'Web Speech API', check: typeof SpeechRecognition !== 'undefined' || typeof webkitSpeechRecognition !== 'undefined' },
                { name: 'Web Notifications', check: typeof Notification !== 'undefined' },
                { name: 'Vibration API', check: typeof navigator.vibrate !== 'undefined' },
                { name: 'Battery API', check: typeof navigator.getBattery !== 'undefined' },
                { name: 'Page Visibility API', check: typeof document.hidden !== 'undefined' },
                { name: 'Navigation Timing API', check: typeof performance !== 'undefined' && typeof performance.timing !== 'undefined' },
                { name: 'Web Crypto API', check: typeof window.crypto !== 'undefined' && typeof window.crypto.subtle !== 'undefined' },
                { name: 'Drag and Drop API', check: typeof DataTransfer !== 'undefined' },
                { name: 'Media Capture', check: typeof MediaRecorder !== 'undefined' },
                { name: 'Media Source Extensions', check: typeof MediaSource !== 'undefined' },
                { name: 'WebAssembly', check: typeof WebAssembly !== 'undefined' }
            ];
            
            // Check each API
            for (const api of apiChecks) {
                try {
                    if (api.check) {
                        apis.push({
                            name: api.name,
                            supported: true
                        });
                    }
                } catch (e) {
                    // Ignore errors
                }
            }
            
            detectedVersions.apis = apis;
        },
        
        /**
         * Check for compatibility issues
         */
        checkCompatibility: function() {
            // Check browser compatibility
            if (detectedVersions.browser) {
                const browserName = detectedVersions.browser.name.toLowerCase();
                const minimumVersion = CONFIG.minimumVersions[browserName];
                
                if (minimumVersion && detectedVersions.browser.majorVersion < minimumVersion) {
                    compatibilityWarnings.push({
                        type: 'browser',
                        level: 'error',
                        message: `Browser version ${detectedVersions.browser.name} ${detectedVersions.browser.version} is below the minimum supported version ${minimumVersion}`
                    });
                }
            }
            
            // Check for Internet Explorer
            if (detectedVersions.browser && detectedVersions.browser.name === 'Internet Explorer') {
                compatibilityWarnings.push({
                    type: 'browser',
                    level: 'error',
                    message: 'Internet Explorer is not fully supported. Some features may not work correctly.'
                });
            }
            
            // Check for popular framework combinations that might have compatibility issues
            const hasReact = detectedVersions.jsFrameworks.some(f => f.name === 'React');
            const hasAngular = detectedVersions.jsFrameworks.some(f => f.name === 'Angular');
            const hasVue = detectedVersions.jsFrameworks.some(f => f.name === 'Vue');
            const hasjQuery = detectedVersions.jsFrameworks.some(f => f.name === 'jQuery');
            
            // Check for multiple major frameworks
            if ((hasReact && hasAngular) || (hasReact && hasVue) || (hasAngular && hasVue)) {
                compatibilityWarnings.push({
                    type: 'framework',
                    level: 'warning',
                    message: 'Multiple major frameworks detected. This may cause conflicts or performance issues.'
                });
            }
            
            // Check for jQuery with modern frameworks
            if (hasjQuery && (hasReact || hasAngular || hasVue)) {
                compatibilityWarnings.push({
                    type: 'framework',
                    level: 'info',
                    message: 'jQuery is used alongside a modern framework. Consider using native DOM APIs for better performance.'
                });
            }
            
            // Check for specific version compatibility issues
            for (const framework of detectedVersions.jsFrameworks) {
                if (framework.name === 'React' && framework.version && parseInt(framework.version) < 16) {
                    compatibilityWarnings.push({
                        type: 'framework',
                        level: 'warning',
                        message: `React version ${framework.version} is outdated. Consider upgrading to v16 or newer.`
                    });
                }
                
                if (framework.name === 'Angular' && framework.version && parseInt(framework.version) < 9) {
                    compatibilityWarnings.push({
                        type: 'framework',
                        level: 'warning',
                        message: `Angular version ${framework.version} is outdated. Consider upgrading to v9 or newer.`
                    });
                }
                
                if (framework.name === 'Vue' && framework.version && parseInt(framework.version) < 2) {
                    compatibilityWarnings.push({
                        type: 'framework',
                        level: 'warning',
                        message: `Vue version ${framework.version} is outdated. Consider upgrading to v2 or newer.`
                    });
                }
                
                if (framework.name === 'jQuery' && framework.version && parseInt(framework.version) < 3) {
                    compatibilityWarnings.push({
                        type: 'framework',
                        level: 'info',
                        message: `jQuery version ${framework.version} is outdated. Consider upgrading to v3 or newer.`
                    });
                }
            }
            
            // Check for specific browser APIs that might be needed
            if (hasReact || hasAngular || hasVue) {
                const hasMutationObserver = detectedVersions.apis.some(api => api.name === 'Mutation Observer');
                const hasIntersectionObserver = detectedVersions.apis.some(api => api.name === 'Intersection Observer');
                
                if (!hasMutationObserver) {
                    compatibilityWarnings.push({
                        type: 'api',
                        level: 'warning',
                        message: 'Mutation Observer API is not supported by this browser but might be required by the frameworks in use.'
                    });
                }
                
                if (!hasIntersectionObserver) {
                    compatibilityWarnings.push({
                        type: 'api',
                        level: 'info',
                        message: 'Intersection Observer API is not supported by this browser but might be useful for performance optimization.'
                    });
                }
            }
        },
        
        /**
         * Handle incoming messages
         * @param {MessageEvent} event - The message event
         */
        handleMessage: function(event) {
            if (!event.data || event.data.type !== 'CSTestForge_VersionDetectorCommand') {
                return;
            }
            
            const command = event.data.command;
            
            switch (command) {
                case 'detectVersions':
                    this.detectAll();
                    break;
                    
                case 'checkCompatibility':
                    this.checkCompatibility();
                    this.sendCompatibilityWarnings();
                    break;
                    
                case 'getDetectedVersions':
                    this.sendDetectedVersions();
                    break;
                    
                case 'checkFeature':
                    this.checkFeature(event.data.feature);
                    break;
                    
                case 'updateConfig':
                    this.updateConfig(event.data.config);
                    break;
                    
                default:
                    console.warn('CSTestForge Version Detector: Unknown command', command);
            }
        },
        
        /**
         * Detect all versions
         */
        detectAll: function() {
            // Clear existing data
            detectedVersions.jsFrameworks = [];
            detectedVersions.cssFrameworks = [];
            detectedVersions.testingFrameworks = [];
            detectedVersions.apis = [];
            
            // Detect browser version
            if (CONFIG.detectBrowserVersion) {
                this.detectBrowserVersion();
            }
            
            // Detect JS frameworks
            if (CONFIG.detectJSFrameworks) {
                this.detectJSFrameworks();
            }
            
            // Detect CSS frameworks
            if (CONFIG.detectCSSFrameworks) {
                this.detectCSSFrameworks();
            }
            
            // Detect testing frameworks
            if (CONFIG.detectTestingFrameworks) {
                this.detectTestingFrameworks();
            }
            
            // Detect APIs
            if (CONFIG.detectAPIs) {
                this.detectAPIs();
            }
            
            // Check for compatibility issues
            if (CONFIG.reportCompatibilityWarnings) {
                this.checkCompatibility();
            }
            
            // Send detected versions
            this.sendDetectedVersions();
        },
        
        /**
         * Send detected versions
         */
        sendDetectedVersions: function() {
            CONFIG.postMessage({
                type: 'detectedVersions',
                versions: detectedVersions,
                timestamp: Date.now()
            });
        },
        
        /**
         * Send compatibility warnings
         */
        sendCompatibilityWarnings: function() {
            CONFIG.postMessage({
                type: 'compatibilityWarnings',
                warnings: compatibilityWarnings,
                timestamp: Date.now()
            });
        },
        
        /**
         * Check if a specific feature is supported
         * @param {string} feature - The feature to check
         */
        checkFeature: function(feature) {
            let isSupported = false;
            let version = null;
            
            // Check JS frameworks
            const jsFramework = frameworkSignatures.jsFrameworks.find(f => f.name.toLowerCase() === feature.toLowerCase());
            if (jsFramework) {
                try {
                    isSupported = jsFramework.detector();
                    if (isSupported && jsFramework.versionDetector) {
                        version = jsFramework.versionDetector();
                    }
                } catch (e) {
                    console.error(`CSTestForge Version Detector: Error checking feature ${feature}`, e);
                }
            }
            
            // Check CSS frameworks
            const cssFramework = frameworkSignatures.cssFrameworks.find(f => f.name.toLowerCase() === feature.toLowerCase());
            if (cssFramework) {
                try {
                    isSupported = cssFramework.detector();
                    if (isSupported && cssFramework.versionDetector) {
                        version = cssFramework.versionDetector();
                    }
                } catch (e) {
                    console.error(`CSTestForge Version Detector: Error checking feature ${feature}`, e);
                }
            }
            
            // Check testing frameworks
            const testingFramework = frameworkSignatures.testingFrameworks.find(f => f.name.toLowerCase() === feature.toLowerCase());
            if (testingFramework) {
                try {
                    isSupported = testingFramework.detector();
                    if (isSupported && testingFramework.versionDetector) {
                        version = testingFramework.versionDetector();
                    }
                } catch (e) {
                    console.error(`CSTestForge Version Detector: Error checking feature ${feature}`, e);
                }
            }
            
            // Send feature check result
            CONFIG.postMessage({
                type: 'featureCheck',
                feature: feature,
                supported: isSupported,
                version: version,
                timestamp: Date.now()
            });
        },
        
        /**
         * Update configuration settings
         * @param {Object} newConfig - New configuration settings
         */
        updateConfig: function(newConfig) {
            // Update settings
            for (const key in newConfig) {
                if (CONFIG.hasOwnProperty(key)) {
                    CONFIG[key] = newConfig[key];
                }
            }
            
            // Re-detect with new config if enabled
            if (CONFIG.enabled) {
                this.detectAll();
            }
            
            // Send configuration updated event
            CONFIG.postMessage({
                type: 'configUpdated',
                timestamp: Date.now()
            });
        }
    };
    
    // Initialize version detector
    CSVersionDetector.init();
    
    // Make the detector available for manual access
    window.__CSVersionDetector = CSVersionDetector;
})();


