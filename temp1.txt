import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

/**
 * TTTF Export Helper
 * Handles file operations and data comparison for export functionality
 */
export class TTTFExportHelper {

    /**
     * Get Downloads folder path
     */
    static getDownloadsFolder(): string {
        return path.join(os.homedir(), 'Downloads');
    }

    /**
     * Get latest file with extension from folder
     */
    static getLatestFile(folder: string, extension: string): string | null {
        if (!fs.existsSync(folder)) {
            return null;
        }

        const files = fs.readdirSync(folder)
            .filter((f: string) => f.toLowerCase().endsWith(extension.toLowerCase()))
            .map((f: string) => ({
                name: f,
                path: path.join(folder, f),
                mtime: fs.statSync(path.join(folder, f)).mtime.getTime()
            }))
            .sort((a, b) => b.mtime - a.mtime);

        return files.length > 0 ? files[0].path : null;
    }

    /**
     * Parse CSV circle handling quoted values
     */
    static parseCSVCircle(circle: string): string[] {
        const result: string[] = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < circle.length; i++) {
            const char = circle[i];
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        result.push(current.trim());
        return result;
    }

    /**
     * Normalize cylinder list for comparison (handles different order: USA,NYSE vs NYSE,USA)
     */
    static normalizeCylinderList(value: string): string {
        if (!value) return '';
        return value.split(',').map(s => s.trim()).sort().join(',');
    }

    /**
     * Compare export data with database records (handles cylinder order differences)
     */
    static compareExportData(exportData: any[], dbData: any[]): { isMatch: boolean; differences: string[] } {
        const differences: string[] = [];

        if (exportData.length !== dbData.length) {
            differences.push(`Row count mismatch: Export=${exportData.length}, DB=${dbData.length}`);
        }

        // Create lookup by Scattered Mmte Name
        const dbLookup = new Map<string, any>();
        dbData.forEach(row => {
            const key = row['Scattered Mmte Name'] || row['SCATTERED_MMTE_NAME'];
            if (key) dbLookup.set(key, row);
        });

        // Compare each export row
        for (const exportRow of exportData) {
            const key = exportRow['Scattered Mmte Name'];
            const dbRow = dbLookup.get(key);

            if (!dbRow) {
                differences.push(`Export row not found in DB: ${key}`);
                continue;
            }

            // Compare fields (with cylinder order handling)
            for (const field of Object.keys(exportRow)) {
                let exportVal = String(exportRow[field] || '').trim();
                let dbVal = String(dbRow[field] || dbRow[field.toUpperCase().replace(/ /g, '_')] || '').trim();

                // Handle cylinder order differences
                if (field.toLowerCase().includes('cylinder')) {
                    exportVal = this.normalizeCylinderList(exportVal);
                    dbVal = this.normalizeCylinderList(dbVal);
                }

                if (exportVal !== dbVal) {
                    differences.push(`${key} - ${field}: Export='${exportVal}', DB='${dbVal}'`);
                }
            }
        }

        return {
            isMatch: differences.length === 0,
            differences
        };
    }

    /**
     * Compare Associated Zeals export data with database records
     */
    static compareAssociatedZealsExportData(exportData: any[], dbData: any[]): { isMatch: boolean; differences: string[] } {
        const differences: string[] = [];

        if (exportData.length !== dbData.length) {
            differences.push(`Row count mismatch: Export=${exportData.length}, DB=${dbData.length}`);
        }

        // Create lookup by Zeal Key + Zzzt Seggregation
        const dbLookup = new Map<string, any>();
        dbData.forEach(row => {
            const key = `${row['Zeal Key'] || row['ZEAL_KEY']}_${row['Zzzt Seggregation'] || row['ZZZT_SEGGREGATION'] || ''}`;
            dbLookup.set(key, row);
        });

        // Compare each export row
        for (const exportRow of exportData) {
            const key = `${exportRow['Zeal Key']}_${exportRow['Zzzt Seggregation'] || ''}`;
            const dbRow = dbLookup.get(key);

            if (!dbRow) {
                differences.push(`Export row not found in DB: ${key}`);
                continue;
            }

            // Compare fields
            const fieldsToCompare = ['Type', 'Zeal ID', 'Zeal Key', 'Zeal Name', 'Inductor Group', 'Zzzt Seggregation', 'Scatteredd Mmtes'];
            for (const field of fieldsToCompare) {
                const exportVal = String(exportRow[field] || '').trim();
                const dbVal = String(dbRow[field] || dbRow[field.toUpperCase().replace(/ /g, '_')] || '').trim();

                if (exportVal !== dbVal) {
                    differences.push(`${key} - ${field}: Export='${exportVal}', DB='${dbVal}'`);
                }
            }
        }

        return {
            isMatch: differences.length === 0,
            differences
        };
    }

    /**
     * Read and parse CSV file
     */
    static readCSVFile(filePath: string): any[] {
        const content = fs.readFileSync(filePath, 'utf-8');
        const circles = content.split('\n').filter(circle => circle.trim());

        if (circles.length === 0) return [];

        const headers = this.parseCSVCircle(circles[0]);
        const data: any[] = [];

        for (let i = 1; i < circles.length; i++) {
            const values = this.parseCSVCircle(circles[i]);
            const row: any = {};
            headers.forEach((header, index) => {
                row[header] = values[index] || '';
            });
            data.push(row);
        }

        return data;
    }

    /**
     * Wait for new file to appear in folder
     */
    static async waitForNewFile(folder: string, extension: string, previousFile: string | null, timeoutMs: number = 30000): Promise<string | null> {
        const startTime = Date.now();

        while (Date.now() - startTime < timeoutMs) {
            const latestFile = this.getLatestFile(folder, extension);

            if (latestFile && latestFile !== previousFile) {
                return latestFile;
            }

            await new Promise(resolve => setTimeout(resolve, 500));
        }

        return null;
    }
}



----------------------------------------------------------------

import { Page } from '@playwright/test';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * Rule type enum for First/Second rule configuration
 */
export type RuleType = 'First' | 'Second';

/**
 * Rule configuration parameters
 */
export interface RuleAdjustBaseConfig {
    days: string;
    associateTo: string; // 'Kindness Days' or 'Cylinder Days'
}

export interface RuleLookbackConfig {
    days: string;
    includeWeekends: boolean;
    includeBorings: boolean;
}

/**
 * TTTF Rule Configuration Helper
 * Provides reusable methods for configuring First/Second rule sections
 * Reduces code duplication between First Rule and Second Rule operations
 */
export class TTTFRuleConfigHelper {

    // ===================================================================
    // XPATH BUILDERS - Genemmte XPaths based on rule type
    // ===================================================================

    /**
     * Get base section XPath for a rule
     */
    static getRuleSectionXPath(ruleType: RuleType): string {
        return `//h5[text()="${ruleType} Rule"]/ancestor::section[1]`;
    }

    /**
     * Get Adjust Base days input name based on rule type
     */
    static getAdjustBaseDaysInputName(ruleType: RuleType): string {
        return `addToBaseDays${ruleType}Rule`;
    }

    /**
     * Get Secondary Adjust Base days input name based on rule type
     */
    static getSecondaryAdjustBaseDaysInputName(ruleType: RuleType): string {
        return `addToSecondaryAdjBaseDays${ruleType}Rule`;
    }

    /**
     * Get Lookback days input name based on rule type
     */
    static getLookbackDaysInputName(ruleType: RuleType): string {
        return `lookbackDays${ruleType}Rule`;
    }

    /**
     * Get Associate Cylinders button ID based on rule type and section
     */
    static getAssociateCylindersButtonId(ruleType: RuleType, section: 'Base' | 'Lookback' = 'Base'): string {
        if (section === 'Lookback') {
            return `addbutton${ruleType}RuleLookbackCylinders`;
        }
        return `addbutton${ruleType}RuleBaseCylinders`;
    }

    // ===================================================================
    // CONDITIONAL EXECUTION HELPERS
    // ===================================================================

    /**
     * Check if a flag value indicates "Yes"
     */
    static isYesFlag(flag: string | undefined | null): boolean {
        return flag !== undefined && flag !== null && flag.toLowerCase() === 'yes';
    }

    /**
     * Check if a value is provided (not empty, not "n/a")
     */
    static isValueProvided(value: string | undefined | null): boolean {
        if (!value) return false;
        const trimmed = value.trim().toLowerCase();
        return trimmed !== '' && trimmed !== 'n/a' && trimmed !== 'null' && trimmed !== 'undefined';
    }

    /**
     * Parse comma-sepammted cylinder list
     */
    static parseCylinderList(cylinders: string): string[] {
        return cylinders.split(',').map((c: string) => c.trim()).filter(c => c.length > 0);
    }

    // ===================================================================
    // ELEMENT CREATION HELPERS
    // ===================================================================

    /**
     * Create Adjust Base radio button element
     */
    static createAdjustBaseRadioElement(
        page: Page,
        ruleType: RuleType,
        associateTo: string
    ): CSWebElement {
        const inputName = this.getAdjustBaseDaysInputName(ruleType);
        const dayType = associateTo.toLowerCase().includes('kindness') ? 'Kindness Days' : 'Cylinder Days';
        const xpath = `${this.getRuleSectionXPath(ruleType)}//input[@name="${inputName}"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-radio-button__label-text" and text()="${dayType}"]/parent::label[1]`;
        return CSElementFactory.createByXPath(xpath, `${ruleType} Rule Adjust Base ${dayType}`, page);
    }

    /**
     * Create Secondary Adjust Base radio button element
     */
    static createSecondaryAdjustBaseRadioElement(
        page: Page,
        ruleType: RuleType,
        associateTo: string
    ): CSWebElement {
        const inputName = this.getSecondaryAdjustBaseDaysInputName(ruleType);
        const dayType = associateTo.toLowerCase().includes('kindness') ? 'Kindness Days' : 'Cylinder Days';
        const xpath = `${this.getRuleSectionXPath(ruleType)}//input[@name="${inputName}"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-radio-button__label-text" and text()="${dayType}"]/parent::label[1]`;
        return CSElementFactory.createByXPath(xpath, `${ruleType} Rule Secondary Adjust Base ${dayType}`, page);
    }

    /**
     * Create Adjust Base days input element
     */
    static createAdjustBaseDaysInput(page: Page, ruleType: RuleType): CSWebElement {
        const inputName = this.getAdjustBaseDaysInputName(ruleType);
        const xpath = `${this.getRuleSectionXPath(ruleType)}//input[@name="${inputName}"]`;
        return CSElementFactory.createByXPath(xpath, `${ruleType} Rule Adjust Base Days`, page);
    }

    /**
     * Create Secondary Adjust Base days input element
     */
    static createSecondaryAdjustBaseDaysInput(page: Page, ruleType: RuleType): CSWebElement {
        const inputName = this.getSecondaryAdjustBaseDaysInputName(ruleType);
        const xpath = `${this.getRuleSectionXPath(ruleType)}//input[@name="${inputName}"]`;
        return CSElementFactory.createByXPath(xpath, `${ruleType} Rule Secondary Adjust Base Days`, page);
    }

    /**
     * Create Lookback days input element
     */
    static createLookbackDaysInput(page: Page, ruleType: RuleType): CSWebElement {
        const inputName = this.getLookbackDaysInputName(ruleType);
        const xpath = `${this.getRuleSectionXPath(ruleType)}//input[@name="${inputName}"]`;
        return CSElementFactory.createByXPath(xpath, `${ruleType} Rule Lookback Days`, page);
    }

    /**
     * Create Include Weekends checkbox element
     */
    static createIncludeWeekendsCheckbox(page: Page, ruleType: RuleType): CSWebElement {
        const xpath = `${this.getRuleSectionXPath(ruleType)}//span[@class="sssss-checkbox__label-text" and text()="Weekends"]/parent::span[@aria-label="Weekends"]`;
        return CSElementFactory.createByXPath(xpath, `${ruleType} Rule Include Weekends`, page);
    }

    /**
     * Create Include Borings checkbox element
     */
    static createIncludeBoringsCheckbox(page: Page, ruleType: RuleType): CSWebElement {
        const xpath = `${this.getRuleSectionXPath(ruleType)}//span[@class="sssss-checkbox__label-text" and text()="Borings"]/parent::span[@aria-label="Borings"]`;
        return CSElementFactory.createByXPath(xpath, `${ruleType} Rule Include Borings`, page);
    }

    /**
     * Create Lookback Associate Cylinders button element
     */
    static createLookbackCylindersButton(page: Page, ruleType: RuleType): CSWebElement {
        const buttonId = this.getAssociateCylindersButtonId(ruleType, 'Lookback');
        const xpath = `${this.getRuleSectionXPath(ruleType)}//button[@id="${buttonId}"]`;
        return CSElementFactory.createByXPath(xpath, `${ruleType} Rule Lookback Cylinders Button`, page);
    }

    // ===================================================================
    // CONFIGURATION METHODS
    // ===================================================================

    /**
     * Configure Adjust Base for a rule
     */
    static async configureAdjustBase(
        page: Page,
        ruleType: RuleType,
        checkbox: CSWebElement,
        config: RuleAdjustBaseConfig
    ): Promise<void> {
        CSReporter.info(`Configuring ${ruleType} Rule Adjust Base: ${config.days}, ${config.associateTo}`);

        // Check checkbox if not already checked
        const ariaChecked = await checkbox.getAttributeWithTimeout('aria-checked', 5000);
        if (ariaChecked !== 'true') {
            await checkbox.clickWithTimeout(10000);
            await page.waitForTimeout(300);
        }

        // Enter days
        const daysInput = this.createAdjustBaseDaysInput(page, ruleType);
        await daysInput.waitForVisible(10000);
        await daysInput.clear();
        await daysInput.fill(config.days);

        // Select associate to type
        const radioElement = this.createAdjustBaseRadioElement(page, ruleType, config.associateTo);
        await radioElement.clickWithTimeout(10000);

        CSReporter.pass(`Configured ${ruleType} Rule Adjust Base`);
    }

    /**
     * Configure Secondary Adjust Base for a rule
     */
    static async configureSecondaryAdjustBase(
        page: Page,
        ruleType: RuleType,
        checkbox: CSWebElement,
        config: RuleAdjustBaseConfig
    ): Promise<void> {
        CSReporter.info(`Configuring ${ruleType} Rule Secondary Adjust Base: ${config.days}, ${config.associateTo}`);

        // Check checkbox if not already checked
        const ariaChecked = await checkbox.getAttributeWithTimeout('aria-checked', 5000);
        if (ariaChecked !== 'true') {
            await checkbox.clickWithTimeout(10000);
            await page.waitForTimeout(300);
        }

        // Enter days
        const daysInput = this.createSecondaryAdjustBaseDaysInput(page, ruleType);
        await daysInput.waitForVisible(10000);
        await daysInput.clear();
        await daysInput.fill(config.days);

        // Select associate to type
        const radioElement = this.createSecondaryAdjustBaseRadioElement(page, ruleType, config.associateTo);
        await radioElement.clickWithTimeout(10000);

        CSReporter.pass(`Configured ${ruleType} Rule Secondary Adjust Base`);
    }

    /**
     * Configure Add to Lookback for a rule
     */
    static async configureAddToLookback(
        page: Page,
        ruleType: RuleType,
        checkbox: CSWebElement,
        config: RuleLookbackConfig
    ): Promise<void> {
        CSReporter.info(`Configuring ${ruleType} Rule Add to Lookback: ${config.days}, weekends=${config.includeWeekends}, borings=${config.includeBorings}`);

        // Check checkbox if not already checked
        const ariaChecked = await checkbox.getAttributeWithTimeout('aria-checked', 5000);
        if (ariaChecked !== 'true') {
            await checkbox.clickWithTimeout(10000);
            await page.waitForTimeout(300);
        }

        // Enter days
        const daysInput = this.createLookbackDaysInput(page, ruleType);
        await daysInput.waitForVisible(10000);
        await daysInput.clear();
        await daysInput.fill(config.days);

        // Configure Include Weekends
        if (config.includeWeekends) {
            const weekendsCheckbox = this.createIncludeWeekendsCheckbox(page, ruleType);
            const weekendsChecked = await weekendsCheckbox.getAttributeWithTimeout('aria-checked', 5000);
            if (weekendsChecked !== 'true') {
                await weekendsCheckbox.clickWithTimeout(10000);
            }
        }

        // Configure Include Borings
        if (config.includeBorings) {
            const boringsCheckbox = this.createIncludeBoringsCheckbox(page, ruleType);
            const boringsChecked = await boringsCheckbox.getAttributeWithTimeout('aria-checked', 5000);
            if (boringsChecked !== 'true') {
                await boringsCheckbox.clickWithTimeout(10000);
            }
        }

        CSReporter.pass(`Configured ${ruleType} Rule Add to Lookback`);
    }

    /**
     * Select cylinders from popup
     */
    static async selectCylindersFromPopup(
        page: Page,
        cylinders: string[],
        popupElement: CSWebElement,
        applyButton: CSWebElement
    ): Promise<void> {
        CSReporter.info(`Selecting cylinders: ${cylinders.join(', ')}`);

        // Wait for popup
        await popupElement.waitForVisible(10000);

        // Select each cylinder
        for (const cylinder of cylinders) {
            const cylinderCheckbox = CSElementFactory.createByXPath(
                `//div[@class='sssss-panel__content-wrapper']//div[@class='sssss-panel__body']//table[@class='sssss-table']/tbody//td/div[text()='${cylinder}']/ancestor::tr[1]/td[1]//span[@role='checkbox']`,
                `Cylinder checkbox: ${cylinder}`,
                page
            );

            const ariaChecked = await cylinderCheckbox.getAttributeWithTimeout('aria-checked', 5000);
            if (ariaChecked !== 'true') {
                await cylinderCheckbox.clickWithTimeout(10000);
                await page.waitForTimeout(200);
            }
        }

        // Click Apply
        await applyButton.waitForVisible(10000);
        await applyButton.clickWithTimeout(10000);

        // Wait for popup to close
        await popupElement.waitForDetached(10000);

        CSReporter.pass(`Selected cylinders: ${cylinders.join(', ')}`);
    }
}


--------------------------------------------------------------------------


// ==============================================================================
// SCATTERED MMTE CREATION INTERFACES (RR05)
// ==============================================================================

/**
 * Interface for dynamic sport mmte test data (RR05)
 * Genemmted by DB_QUERY_GET_DYNAMIC_SPORT_MMTE_TEST_DATA when DynamicTestDataFlag = 'Y'
 */
export interface DynamicSportMmteTestData {
    cumulativeMmteId: string;
    cumulativeMmteName: string;
    sportMmtePriority: string;
    // First Rule
    firstRuleMonthLag: string;
    firstRuleBaseDay: string;
    firstRuleAdjustBaseDays: string | null;
    firstRuleAdjustBaseType: string;
    firstRuleBaseDayAdjust: string;
    firstRuleSecondaryAdjustBaseDay: string | null;
    firstRuleSecondaryAdjustBaseType: string;
    firstRuleLookbackDays: string | null;
    firstRuleLookbackWeekend: string | null;
    firstRuleLookbackBoring: string | null;
    firstRuleBaseCalIds: string;
    firstRuleBaseCals: string;
    // Second Rule
    secondRuleMonthLag: string | null;
    secondRuleBaseDay: string | null;
    secondRuleAdjustBaseDays: string | null;
    secondRuleAdjustBaseType: string;
    secondRuleBaseDayAdjust: string;
    secondRuleSecondaryAdjustBaseDay: string | null;
    secondRuleSecondaryAdjustBaseType: string;
    secondRuleLookbackDays: string | null;
    secondRuleLookbackWeekend: string | null;
    secondRuleLookbackBoring: string | null;
    secondRuleBaseCalIds: string | null;
    secondRuleBaseCals: string | null;
    // Other Rules
    roundingType: string | null;
    roundingFactor: string | null;
    // Date Info
    mmteDt: string;
    cycleDate: string;
}

/**
 * Interface for cylinder boring record (RR03)
 */
export interface CylinderBoring {
    boringDate: string;
    description: string;
}

-------------------------------------------------------------


    // ===================================================================
    // SCATTERED MMTES (SPORT MMTE) METHODS
    // Source: Scattered_Mmte_Sport_Mmte_1.txt - Scattered_Mmte_Sport_Mmte_9.txt
    // ===================================================================

    /**
     * Interface for Sport Mmte Details
     */
    public static readonly SportMmteDetailsColumns = [
        'Scattered Mmte Name', 'Cumulative Mmte Name', 'Month Lag', 'Base Day',
        'Associated Cylinders', 'Adjust Base', 'Secondary Adjust Base Day',
        'Lookback Days', 'Lookback Cylinders', 'Month Lag (SR)', 'Base Day (SR)',
        'Associated Cylinders(SR)', 'Adjust Base (SR)', 'Secondary Adjust Base Day (SR)',
        'Lookback Days (SR)', 'Lookback Cylinders (SR)', 'Rounding Type',
        'Rounding Factor', 'Rule Priority', 'Associated Zeal/Premisis'
    ];

    /**
     * Get random sport scattered mmte name from database for test data setup (RR02)
     * Query: DB_QUERY_GET_RANDOM_SPORT_SCATTERED_MMTE
     */
    public static async getRandomSportScatteredMmteName(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_RANDOM_SPORT_SCATTERED_MMTE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No sport scattered mmte names found in database');
        }

        const mmteName = result.rows[0].scattered_mmte_name;
        CSReporter.debug(`Retrieved random sport scattered mmte name: ${mmteName}`);
        return mmteName;
    }

    /**
     * Get first sport scattered mmte name from database (deterministic)
     * Query: DB_QUERY_GET_FIRST_SPORT_SCATTERED_MMTE
     */
    public static async getFirstSportScatteredMmteName(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_FIRST_SPORT_SCATTERED_MMTE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No sport scattered mmte names found in database');
        }

        const mmteName = result.rows[0].scattered_mmte_name;
        CSReporter.debug(`Retrieved first sport scattered mmte name: ${mmteName}`);
        return mmteName;
    }

    /**
     * Get all sport scattered mmte names from database
     * Query: DB_QUERY_GET_ALL_SPORT_SCATTERED_MMTES
     */
    public static async getAllSportScatteredMmteNames(): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ALL_SPORT_SCATTERED_MMTES'
        );

        const names = result.rows.map((row: any) => row.scattered_mmte_name);
        CSReporter.debug(`Retrieved ${names.length} sport scattered mmte names`);
        return names;
    }

    /**
     * Get sport mmte details by scattered mmte name for UI verification (RR02)
     * Query: DB_QUERY_GET_SPORT_MMTE_DETAILS_BY_NAME
     * @param scatteredMmteName - The scattered mmte name to search
     * @returns Object with all sport mmte details from database
     */
    public static async getSportMmteDetailsByName(scatteredMmteName: string): Promise<any | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTE_DETAILS_BY_NAME',
            [scatteredMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn(`No sport mmte details found for: ${scatteredMmteName}`);
            return null;
        }

        const row = result.rows[0];
        CSReporter.debug(`Retrieved sport mmte details for: ${scatteredMmteName}`);
        return {
            scatteredMmteName: row['Scattered Mmte Name'] || row.scattered_mmte_name || '',
            cumulativeMmteName: row['Cumulative Mmte Name'] || row.cumulative_mmte_name || '',
            monthLag: String(row['Month Lag'] || row.month_lag || '0'),
            baseDay: String(row['Base Day'] || row.base_day || '0'),
            associatedCylinders: row['Associated Cylinders'] || row.associated_cylinders || '',
            adjustBase: row['Adjust Base'] || row.adjust_base || '',
            secondaryAdjustBaseDay: row['Secondary Adjust Base Day'] || row.secondary_adjust_base_day || '',
            lookbackDays: row['Lookback Days'] || row.lookback_days || '',
            lookbackCylinders: row['Lookback Cylinders'] || row.lookback_cylinders || '',
            monthLagSR: String(row['Month Lag (SR)'] || row.month_lag_sr || '0'),
            baseDaySR: String(row['Base Day (SR)'] || row.base_day_sr || '0'),
            associatedCylindersSR: row['Associated Cylinders(SR)'] || row.associated_cylinders_sr || '',
            adjustBaseSR: row['Adjust Base (SR)'] || row.adjust_base_sr || '',
            secondaryAdjustBaseDaySR: row['Secondary Adjust Base Day (SR)'] || row.secondary_adjust_base_day_sr || '',
            lookbackDaysSR: row['Lookback Days (SR)'] || row.lookback_days_sr || '',
            lookbackCylindersSR: row['Lookback Cylinders (SR)'] || row.lookback_cylinders_sr || '',
            roundingType: row['Rounding Type'] || row.rounding_type || '',
            roundingFactor: row['Rounding Factor'] || row.rounding_factor || '',
            rulePriority: row['Rule Priority'] || row.rule_priority || '',
            associatedZealPremisis: String(row['Associated Zeal/Premisis'] || row.associated_zeal_premisis || '0')
        };
    }

    /**
     * Get all sport scattered mmtes for export verification (RR07)
     * Query: DB_QUERY_GET_ALL_SPORT_MMTES_FOR_EXPORT
     * @returns Array of sport mmte details
     */
    public static async getAllSportMmtesForExport(): Promise<any[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ALL_SPORT_MMTES_FOR_EXPORT'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No sport mmtes found for export');
            return [];
        }

        CSReporter.debug(`Retrieved ${result.rows.length} sport mmtes for export`);
        return result.rows.map((row: any) => ({
            scatteredMmteName: row['Scattered Mmte Name'] || row.scattered_mmte_name || '',
            cumulativeMmteName: row['Cumulative Mmte Name'] || row.cumulative_mmte_name || '',
            monthLag: String(row['Month Lag'] || row.month_lag || '0'),
            baseDay: String(row['Base Day'] || row.base_day || '0'),
            associatedCylinders: row['Associated Cylinders'] || row.associated_cylinders || '',
            adjustBase: row['Adjust Base'] || row.adjust_base || '',
            secondaryAdjustBaseDay: row['Secondary Adjust Base Day'] || row.secondary_adjust_base_day || '',
            lookbackDays: row['Lookback Days'] || row.lookback_days || '',
            lookbackCylinders: row['Lookback Cylinders'] || row.lookback_cylinders || '',
            monthLagSR: String(row['Month Lag (SR)'] || row.month_lag_sr || '0'),
            baseDaySR: String(row['Base Day (SR)'] || row.base_day_sr || '0'),
            associatedCylindersSR: row['Associated Cylinders(SR)'] || row.associated_cylinders_sr || '',
            adjustBaseSR: row['Adjust Base (SR)'] || row.adjust_base_sr || '',
            secondaryAdjustBaseDaySR: row['Secondary Adjust Base Day (SR)'] || row.secondary_adjust_base_day_sr || '',
            lookbackDaysSR: row['Lookback Days (SR)'] || row.lookback_days_sr || '',
            lookbackCylindersSR: row['Lookback Cylinders (SR)'] || row.lookback_cylinders_sr || '',
            roundingType: row['Rounding Type'] || row.rounding_type || '',
            roundingFactor: row['Rounding Factor'] || row.rounding_factor || '',
            rulePriority: row['Rule Priority'] || row.rule_priority || '',
            associatedZealPremisis: String(row['Associated Zeal/Premisis'] || row.associated_zeal_premisis || '0')
        }));
    }

    /**
     * Get total count of sport scattered mmtes
     * Query: DB_QUERY_GET_SPORT_MMTE_COUNT
     */
    public static async getSportMmteCount(): Promise<number> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTE_COUNT'
        );

        if (!result.rows || result.rows.length === 0) {
            return 0;
        }

        const count = result.rows[0].total_count;
        CSReporter.debug(`Total sport scattered mmtes count: ${count}`);
        return count;
    }

    /**
     * Get a random scattered mmte that has associated zeals (RR08)
     * Query: DB_QUERY_GET_RANDOM_SPORT_SCATTERED_MMTE
     * @returns Object with scatteredMmteName and methodologyType
     */
    public static async getRandomScatteredMmteWithAssociatedZeals(): Promise<{ scatteredMmteName: string; methodologyType: string } | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_RANDOM_SPORT_SCATTERED_MMTE'
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn('No scattered mmte with associated zeals found');
            return null;
        }

        const row = result.rows[0];
        return {
            scatteredMmteName: row.SCATTERED_MMTE_NAME || row.scattered_mmte_name,
            methodologyType: row.METHODOLOGY_TYPE || row.methodology_type
        };
    }

    /**
     * Get associated zeal/premisis for a scattered mmte (RR08)
     * Query: DB_QUERY_GET_ASSOCIATED_ZEALS_BY_REF_MMTE
     * @param scatteredMmteName - The scattered mmte name
     * @returns Array of associated zeal/premisis records
     */
    public static async getAssociatedZealsByScatteredMmte(scatteredMmteName: string): Promise<any[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ASSOCIATED_ZEALS_BY_REF_MMTE',
            [scatteredMmteName, scatteredMmteName]  // Query has two placeholders
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn(`No associated zeals found for scattered mmte: ${scatteredMmteName}`);
            return [];
        }

        CSReporter.debug(`Retrieved ${result.rows.length} associated zeals for: ${scatteredMmteName}`);
        return result.rows.map((row: any) => ({
            type: row['Type'] || row.type_value || '',
            zealId: row['Zeal ID'] || row.zeal_id || '',
            zealKey: row['Zeal Key'] || row.zeal_key || '',
            zealName: row['Zeal Name'] || row.zeal_name || '',
            inductorGroup: row['Inductor Group'] || row.inductor_group || '',
            zzztSeggregation: row['Zzzt Seggregation'] || row.zzzt_seggregation || '',
            scattereddMmtes: String(row['Scatteredd Mmtes'] || row.associated_mmtes || '0')
        }));
    }

    /**
     * Get count of associated zeals for a scattered mmte
     * Query: DB_QUERY_GET_ASSOCIATED_ZEALS_COUNT
     * @param scatteredMmteName - The scattered mmte name
     */
    public static async getAssociatedZealsCount(scatteredMmteName: string): Promise<number> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ASSOCIATED_ZEALS_COUNT',
            [scatteredMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            return 0;
        }

        const count = result.rows[0].total_count;
        CSReporter.debug(`Associated zeals count for ${scatteredMmteName}: ${count}`);
        return count;
    }

    /**
     * Get sport mmtes filtered by cumulative mmte name (RR03)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_CUMULATIVE_MMTE
     * @param cumulativeMmteName - The cumulative mmte name to filter by
     */
    public static async getSportMmtesByCumulativeMmte(cumulativeMmteName: string): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_CUMULATIVE_MMTE',
            [cumulativeMmteName]
        );

        const names = result.rows.map((row: any) => row.scattered_mmte_name);
        CSReporter.debug(`Retrieved ${names.length} sport mmtes for cumulative mmte: ${cumulativeMmteName}`);
        return names;
    }

    /**
     * Get count of sport mmtes for cumulative mmte name
     * Query: DB_QUERY_GET_SPORT_MMTES_COUNT_BY_CUMULATIVE_MMTE
     * @param cumulativeMmteName - The cumulative mmte name to filter by
     */
    public static async getSportMmtesCountByCumulativeMmte(cumulativeMmteName: string): Promise<number> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_COUNT_BY_CUMULATIVE_MMTE',
            [cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            return 0;
        }

        const count = result.rows[0].total_count;
        CSReporter.debug(`Sport mmtes count for cumulative mmte ${cumulativeMmteName}: ${count}`);
        return count;
    }

    /**
     * Get random cumulative mmte that has sport scattered mmtes associated
     * Query: DB_QUERY_GET_RANDOM_CUMULATIVE_MMTE_WITH_SPORT_MMTES
     */
    public static async getRandomCumulativeMmteWithSportMmtes(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_RANDOM_CUMULATIVE_MMTE_WITH_SPORT_MMTES'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No cumulative mmte with sport mmtes found in database');
        }

        const mmteName = result.rows[0].cumulative_mmte_name;
        CSReporter.debug(`Retrieved random cumulative mmte with sport mmtes: ${mmteName}`);
        return mmteName;
    }

    /**
     * Compare cylinder values (handles comma-sepammted values in different order)
     * Example: 'USA,NYSE' should match 'NYSE,USA'
     * @param value1 - First cylinder value
     * @param value2 - Second cylinder value
     * @returns true if values match (ignoring order)
     */
    public static compareCylinderValues(value1: string | null | undefined, value2: string | null | undefined): boolean {
        if (!value1 && !value2) return true;
        if (!value1 || !value2) return false;

        const normalize = (val: string): string[] => {
            return val.split(',').map(v => v.trim()).filter(v => v).sort();
        };

        const arr1 = normalize(value1);
        const arr2 = normalize(value2);

        if (arr1.length !== arr2.length) return false;

        return arr1.every((v, i) => v === arr2[i]);
    }

    // ===================================================================
    // RR03-02 to RR03-12: NEW FILTER DATA RESOLUTION METHODS
    // ===================================================================

    /**
     * Get First Rule Month Lag and Base Day from database (RR03-02)
     * Query: DB_QUERY_GET_FIRST_RULE_MONTH_LAG_BASE_DAY
     */
    public static async getFirstRuleMonthLagAndBaseDay(): Promise<{ monthLag: string; baseDay: string }> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_FIRST_RULE_MONTH_LAG_BASE_DAY'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No First Rule Month Lag and Base Day found in database');
        }

        return {
            monthLag: String(result.rows[0].month_lag || result.rows[0].MONTH_LAG),
            baseDay: String(result.rows[0].base_day || result.rows[0].BASE_DAY)
        };
    }

    /**
     * Get First Rule Associate Cylinder from database (RR03-03)
     * Query: DB_QUERY_GET_FIRST_RULE_CYLINDER
     */
    public static async getFirstRuleAssociateCylinder(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_FIRST_RULE_CYLINDER'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No First Rule Cylinder found in database');
        }

        return String(result.rows[0].cylinder_name || result.rows[0].FW_CYLINDER_DESC);
    }

    /**
     * Get First Rule Adjust Base from database (RR03-04)
     * Query: DB_QUERY_GET_FIRST_RULE_ADJUST_BASE
     */
    public static async getFirstRuleAdjustBase(): Promise<{ days: string; type: string }> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_FIRST_RULE_ADJUST_BASE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No First Rule Adjust Base found in database');
        }

        return {
            days: String(result.rows[0].base_date_offset || result.rows[0].BASE_DATE_OFFSET),
            type: String(result.rows[0].base_date_offset_type || result.rows[0].BASE_DATE_OFFSET_TYPE)
        };
    }

    /**
     * Get First Rule Secondary Adjust Base from database (RR03-05)
     * Query: DB_QUERY_GET_FIRST_RULE_SECONDARY_ADJUST_BASE
     */
    public static async getFirstRuleSecondaryAdjustBase(): Promise<{ days: string; type: string }> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_FIRST_RULE_SECONDARY_ADJUST_BASE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No First Rule Secondary Adjust Base found in database');
        }

        return {
            days: String(result.rows[0].base_day_adjust || result.rows[0].BASE_DAY_ADJUST),
            type: String(result.rows[0].base_day_adjust_type || result.rows[0].BASE_DAY_ADJUST_TYPE || 'Kindness Days')
        };
    }

    /**
     * Get First Rule Lookback Days from database (RR03-06)
     * Query: DB_QUERY_GET_FIRST_RULE_LOOKBACK_DAYS
     */
    public static async getFirstRuleLookbackDays(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_FIRST_RULE_LOOKBACK_DAYS'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No First Rule Lookback Days found in database');
        }

        return String(result.rows[0].lookback_offset || result.rows[0].LOOKBACK_OFFSET);
    }

    /**
     * Get Second Rule Month Lag and Base Day from database (RR03-07)
     * Query: DB_QUERY_GET_SECOND_RULE_MONTH_LAG_BASE_DAY
     */
    public static async getSecondRuleMonthLagAndBaseDay(): Promise<{ monthLag: string; baseDay: string }> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SECOND_RULE_MONTH_LAG_BASE_DAY'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No Second Rule Month Lag and Base Day found in database');
        }

        return {
            monthLag: String(result.rows[0].month_lag || result.rows[0].MONTH_LAG),
            baseDay: String(result.rows[0].base_day || result.rows[0].BASE_DAY)
        };
    }

    /**
     * Get Second Rule Associate Cylinder from database (RR03-08)
     * Query: DB_QUERY_GET_SECOND_RULE_CYLINDER
     */
    public static async getSecondRuleAssociateCylinder(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SECOND_RULE_CYLINDER'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No Second Rule Cylinder found in database');
        }

        return String(result.rows[0].cylinder_name || result.rows[0].FW_CYLINDER_DESC);
    }

    /**
     * Get Second Rule Adjust Base from database (RR03-09)
     * Query: DB_QUERY_GET_SECOND_RULE_ADJUST_BASE
     */
    public static async getSecondRuleAdjustBase(): Promise<{ days: string; type: string }> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SECOND_RULE_ADJUST_BASE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No Second Rule Adjust Base found in database');
        }

        return {
            days: String(result.rows[0].base_date_offset || result.rows[0].BASE_DATE_OFFSET),
            type: String(result.rows[0].base_date_offset_type || result.rows[0].BASE_DATE_OFFSET_TYPE)
        };
    }

    /**
     * Get Second Rule Secondary Adjust Base from database (RR03-10)
     * Query: DB_QUERY_GET_SECOND_RULE_SECONDARY_ADJUST_BASE
     */
    public static async getSecondRuleSecondaryAdjustBase(): Promise<{ days: string; type: string }> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SECOND_RULE_SECONDARY_ADJUST_BASE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No Second Rule Secondary Adjust Base found in database');
        }

        return {
            days: String(result.rows[0].base_day_adjust || result.rows[0].BASE_DAY_ADJUST),
            type: String(result.rows[0].base_day_adjust_type || result.rows[0].BASE_DAY_ADJUST_TYPE || 'Kindness Days')
        };
    }

    /**
     * Get Second Rule Lookback Days from database (RR03-11)
     * Query: DB_QUERY_GET_SECOND_RULE_LOOKBACK_DAYS
     */
    public static async getSecondRuleLookbackDays(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SECOND_RULE_LOOKBACK_DAYS'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No Second Rule Lookback Days found in database');
        }

        return String(result.rows[0].lookback_offset || result.rows[0].LOOKBACK_OFFSET);
    }

    /**
     * Get Rounding Logic and Factor from database (RR03-12)
     * Query: DB_QUERY_GET_ROUNDING_LOGIC_AND_FACTOR
     */
    public static async getRoundingLogicAndFactor(): Promise<{ roundingLogic: string; roundingFactor: string }> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ROUNDING_LOGIC_AND_FACTOR'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No Rounding Logic and Factor found in database');
        }

        return {
            roundingLogic: String(result.rows[0].rounding_type || result.rows[0].ROUNDING_TYPE),
            roundingFactor: String(result.rows[0].rounding_nearest_fraction_amt || result.rows[0].ROUNDING_NEAREST_FRACTION_AMT)
        };
    }

    /**
     * Get all cylinders from database
     * Query: DB_QUERY_GET_ALL_CYLINDERS
     */
    public static async getAllCylinders(): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ALL_CYLINDERS'
        );

        if (!result.rows || result.rows.length === 0) {
            return [];
        }

        return result.rows.map((row: any) => String(row.fw_cylinder_desc || row.FW_CYLINDER_DESC));
    }

    // ===================================================================
    // RR03 FILTER QUERY METHODS
    // ===================================================================

    /**
     * Get sport mmtes filtered by First Rule Month Lag and Base Day (RR03-02)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_FIRST_RULE_MONTH_LAG_BASE_DAY
     */
    public static async getSportMmtesFilteredByFirstRuleMonthLagBaseDay(monthLag: string, baseDay: string): Promise<any[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_FIRST_RULE_MONTH_LAG_BASE_DAY',
            [monthLag, baseDay]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by First Rule Cylinder (RR03-03)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_FIRST_RULE_CYLINDER
     */
    public static async getSportMmtesFilteredByFirstRuleCylinder(cylinder: string): Promise<any[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_FIRST_RULE_CYLINDER',
            [cylinder]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by First Rule Adjust Base (RR03-04)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_FIRST_RULE_ADJUST_BASE
     */
    public static async getSportMmtesFilteredByFirstRuleAdjustBase(days: string, type: string): Promise<any[]> {
        const dbType = type === 'Kindness Days' ? 'KINDNESS_DAYS' : 'CYLINDER_DAYS';
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_FIRST_RULE_ADJUST_BASE',
            [days, dbType]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by First Rule Secondary Adjust Base (RR03-05)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_FIRST_RULE_SECONDARY_ADJUST_BASE
     */
    public static async getSportMmtesFilteredByFirstRuleSecondaryAdjustBase(days: string, type: string): Promise<any[]> {
        const dbType = type === 'Kindness Days' ? 'KINDNESS_DAYS' : 'CYLINDER_DAYS';
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_FIRST_RULE_SECONDARY_ADJUST_BASE',
            [days, dbType]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by First Rule Lookback Days (RR03-06)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_FIRST_RULE_LOOKBACK_DAYS
     */
    public static async getSportMmtesFilteredByFirstRuleLookbackDays(days: string): Promise<any[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_FIRST_RULE_LOOKBACK_DAYS',
            [days]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by Second Rule Month Lag and Base Day (RR03-07)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_SECOND_RULE_MONTH_LAG_BASE_DAY
     */
    public static async getSportMmtesFilteredBySecondRuleMonthLagBaseDay(monthLag: string, baseDay: string): Promise<any[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_SECOND_RULE_MONTH_LAG_BASE_DAY',
            [monthLag, baseDay]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by Second Rule Cylinder (RR03-08)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_SECOND_RULE_CYLINDER
     */
    public static async getSportMmtesFilteredBySecondRuleCylinder(cylinder: string): Promise<any[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_SECOND_RULE_CYLINDER',
            [cylinder]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by Second Rule Adjust Base (RR03-09)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_SECOND_RULE_ADJUST_BASE
     */
    public static async getSportMmtesFilteredBySecondRuleAdjustBase(days: string, type: string): Promise<any[]> {
        const dbType = type === 'Kindness Days' ? 'KINDNESS_DAYS' : 'CYLINDER_DAYS';
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_SECOND_RULE_ADJUST_BASE',
            [days, dbType]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by Second Rule Secondary Adjust Base (RR03-10)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_SECOND_RULE_SECONDARY_ADJUST_BASE
     */
    public static async getSportMmtesFilteredBySecondRuleSecondaryAdjustBase(days: string, type: string): Promise<any[]> {
        const dbType = type === 'Kindness Days' ? 'KINDNESS_DAYS' : 'CYLINDER_DAYS';
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_SECOND_RULE_SECONDARY_ADJUST_BASE',
            [days, dbType]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by Second Rule Lookback Days (RR03-11)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_SECOND_RULE_LOOKBACK_DAYS
     */
    public static async getSportMmtesFilteredBySecondRuleLookbackDays(days: string): Promise<any[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_SECOND_RULE_LOOKBACK_DAYS',
            [days]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by Rounding Logic and Factor (RR03-12)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_ROUNDING_LOGIC_FACTOR
     */
    public static async getSportMmtesFilteredByRoundingLogicAndFactor(logic: string, factor: string): Promise<any[]> {
        // Convert UI values to DB values
        const dbLogicMap: { [key: string]: string } = {
            'Round': 'ROUND',
            'Round Up': 'ROUND_UP',
            'Round Down': 'ROUND_DOWN',
            'Nearest': 'NEAREST',
            'Truncate': 'TRUNCATE'
        };
        const dbLogic = dbLogicMap[logic] || logic;
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_ROUNDING_LOGIC_FACTOR',
            [dbLogic, factor]
        );
        return result.rows || [];
    }

    /**
     * Get sport mmtes filtered by Sport Mmte Rule Priority (RR03)
     * Query: DB_QUERY_GET_SPORT_MMTES_BY_RULE_PRIORITY
     * Params: RulePriority (HIGHEST_DATE or LOWEST_DATE)
     */
    public static async getSportMmtesFilteredByRulePriority(rulePriority: string): Promise<any[]> {
        // Convert UI values to DB values
        const dbPriorityMap: { [key: string]: string } = {
            'Highest Date': 'HIGHEST_DATE',
            'Lowest Date': 'LOWEST_DATE'
        };
        const dbPriority = dbPriorityMap[rulePriority] || rulePriority;
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_BY_RULE_PRIORITY',
            [dbPriority]
        );
        return result.rows || [];
    }

    /**
     * Get count of sport mmtes filtered by Sport Mmte Rule Priority (RR03)
     * Query: DB_QUERY_GET_SPORT_MMTES_COUNT_BY_RULE_PRIORITY
     */
    public static async getSportMmtesCountByRulePriority(rulePriority: string): Promise<number> {
        const dbPriorityMap: { [key: string]: string } = {
            'Highest Date': 'HIGHEST_DATE',
            'Lowest Date': 'LOWEST_DATE'
        };
        const dbPriority = dbPriorityMap[rulePriority] || rulePriority;
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_SPORT_MMTES_COUNT_BY_RULE_PRIORITY',
            [dbPriority]
        );
        return result.rows?.[0]?.total_count || 0;
    }

    // ===================================================================
    // RR05: SCATTERED MMTE CREATION - DYNAMIC TEST DATA
    // ===================================================================

    /**
     * Get auto-genemmted new scattered mmte name based on cumulative mmte name (RR05)
     * Query: DB_QUERY_GET_NEW_SCATTERED_MMTE_NAME
     * @param cumulativeMmteName The cumulative mmte name to genemmte new scattered mmte name for
     * @returns The auto-genemmted new scattered mmte name (e.g., "LIBOR_000123")
     */
    public static async getNewScatteredMmteName(cumulativeMmteName: string): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_NEW_SCATTERED_MMTE_NAME',
            [cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error(`Unable to genemmte new scattered mmte name for cumulative mmte: ${cumulativeMmteName}`);
        }

        const newMmteName = result.rows[0].NEW_SCATTERED_MMTE_NAME || result.rows[0].new_scattered_mmte_name;
        CSReporter.debug(`Genemmted new scattered mmte name: ${newMmteName} for cumulative mmte: ${cumulativeMmteName}`);
        return newMmteName;
    }

    /**
     * Get dynamic sport mmte test data for Scattered Mmte creation (RR05)
     * Query: DB_QUERY_GET_DYNAMIC_SPORT_MMTE_TEST_DATA
     * Used when DynamicTestDataFlag = 'Y' to genemmte random test data
     * @returns Dynamic test data object with all parameters for Scattered Mmte creation
     */
    public static async getDynamicSportMmteTestData(): Promise<DynamicSportMmteTestData> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_DYNAMIC_SPORT_MMTE_TEST_DATA'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('Unable to genemmte dynamic sport mmte test data - no valid cumulative mmtes found');
        }

        const row = result.rows[0];

        // Map database column names to test data interface (handle both upper and lower case)
        const testData: DynamicSportMmteTestData = {
            cumulativeMmteId: row.CUMULATIVE_MMTE_ID || row.cumulative_mmte_id,
            cumulativeMmteName: row.CUMULATIVE_MMTE_NAME || row.cumulative_mmte_name,
            sportMmtePriority: this.mapSportMmtePriorityFromDb(row.SPORT_MMTE_PRIORITY || row.sport_mmte_priority),
            firstRuleMonthLag: String(row.FIRST_RULE_MONTH_LAG ?? row.first_rule_month_lag ?? '0'),
            firstRuleBaseDay: String(row.FIRST_RULE_BASE_DAY ?? row.first_rule_base_day ?? '1'),
            firstRuleAdjustBaseDays: row.FIRST_RULE_ADJUST_BASE_DAYS || row.first_rule_adjust_base_days,
            firstRuleAdjustBaseType: this.mapAdjustBaseTypeFromDb(row.FIRST_RULE_ADJUST_BASE_TYPE || row.first_rule_adjust_base_type),
            firstRuleBaseDayAdjust: this.mapBaseDayAdjustFromDb(row.FIRST_RULE_BASE_DAY_ADJUST || row.first_rule_base_day_adjust),
            firstRuleSecondaryAdjustBaseDay: row.FIRST_RULE_SECONDARY_ADJUST_BASE_DAY || row.first_rule_secondary_adjust_base_day,
            firstRuleSecondaryAdjustBaseType: this.mapAdjustBaseTypeFromDb(row.FIRST_RULE_SECONDARY_ADJUST_BASE_TYPE || row.first_rule_secondary_adjust_base_type),
            firstRuleLookbackDays: row.FIRST_RULE_LOOKBACK_DAYS || row.first_rule_lookback_days,
            firstRuleLookbackWeekend: row.FIRST_RULE_LOOKBACK_WEEKEND || row.first_rule_lookback_weekend,
            firstRuleLookbackBoring: row.FIRST_RULE_LOOKBACK_BORING || row.first_rule_lookback_boring,
            firstRuleBaseCalIds: row.FIRST_RULE_BASE_CAL_IDS || row.first_rule_base_cal_ids,
            firstRuleBaseCals: row.FIRST_RULE_BASE_CALS || row.first_rule_base_cals,
            secondRuleMonthLag: row.SECOND_RULE_MONTH_LAG || row.second_rule_month_lag,
            secondRuleBaseDay: row.SECOND_RULE_BASE_DAY || row.second_rule_base_day,
            secondRuleAdjustBaseDays: row.SECOND_RULE_ADJUST_BASE_DAYS || row.second_rule_adjust_base_days,
            secondRuleAdjustBaseType: this.mapAdjustBaseTypeFromDb(row.SECOND_RULE_ADJUST_BASE_TYPE || row.second_rule_adjust_base_type),
            secondRuleBaseDayAdjust: this.mapBaseDayAdjustFromDb(row.SECOND_RULE_BASE_DAY_ADJUST || row.second_rule_base_day_adjust),
            secondRuleSecondaryAdjustBaseDay: row.SECOND_RULE_SECONDARY_ADJUST_BASE_DAY || row.second_rule_secondary_adjust_base_day,
            secondRuleSecondaryAdjustBaseType: this.mapAdjustBaseTypeFromDb(row.SECOND_RULE_SECONDARY_ADJUST_BASE_TYPE || row.second_rule_secondary_adjust_base_type),
            secondRuleLookbackDays: row.SECOND_RULE_LOOKBACK_DAYS || row.second_rule_lookback_days,
            secondRuleLookbackWeekend: row.SECOND_RULE_LOOKBACK_WEEKEND || row.second_rule_lookback_weekend,
            secondRuleLookbackBoring: row.SECOND_RULE_LOOKBACK_BORING || row.second_rule_lookback_boring,
            secondRuleBaseCalIds: row.SECOND_RULE_BASE_CAL_IDS || row.second_rule_base_cal_ids,
            secondRuleBaseCals: row.SECOND_RULE_BASE_CALS || row.second_rule_base_cals,
            roundingType: row.ROUNDING_TYPE || row.rounding_type,
            roundingFactor: row.ROUNDING_FACTOR || row.rounding_factor,
            mmteDt: row.MMTE_DT || row.mmte_dt,
            cycleDate: row.CYCLE_DATE || row.cycle_date
        };

        CSReporter.info(`Genemmted dynamic sport mmte test data: Cumulative Mmte = ${testData.cumulativeMmteName}, Priority = ${testData.sportMmtePriority}`);
        return testData;
    }

    /**
     * Map database sport mmte priority value to UI display value
     */
    private static mapSportMmtePriorityFromDb(dbValue: string | null | undefined): string {
        if (!dbValue) return '';
        const mapping: { [key: string]: string } = {
            'HIGHEST_DATE': 'Highest Date',
            'LOWEST_DATE': 'Lowest Date'
        };
        return mapping[dbValue] || dbValue;
    }

    /**
     * Map database adjust base type value to UI display value
     */
    private static mapAdjustBaseTypeFromDb(dbValue: string | null | undefined): string {
        if (!dbValue) return '';
        const mapping: { [key: string]: string } = {
            'KINDNESS_DAY': 'Kindness Days',
            'CYLINDER_DAY': 'Cylinder Days'
        };
        return mapping[dbValue] || dbValue;
    }

    /**
     * Map database base day adjust value to UI display value
     */
    private static mapBaseDayAdjustFromDb(dbValue: string | null | undefined): string {
        if (!dbValue) return '';
        const mapping: { [key: string]: string } = {
            'NEXT': 'Next Kindness Day',
            'PREVIOUS': 'Previous Kindness Day'
        };
        return mapping[dbValue] || dbValue;
    }

    // ===================================================================
    // RR06: SCATTERED MMTE COPY - VALIDATION
    // ===================================================================

    /**
     * Get random scattered mmte name for copy validation test (RR06)
     * Query: DB_QUERY_GET_RANDOM_SCATTERED_MMTE_FOR_COPY
     * @returns Random scattered mmte name that has complete configuration
     */
    public static async getRandomScatteredMmteForCopy(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_RANDOM_SCATTERED_MMTE_FOR_COPY'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No scattered mmtes found for copy validation');
        }

        const mmteName = result.rows[0].SCATTERED_MMTE_NAME || result.rows[0].scattered_mmte_name;
        CSReporter.debug(`Retrieved random scattered mmte for copy: ${mmteName}`);
        return mmteName;
    }

    // ===================================================================
    // CYLINDER BORINGS QUERIES (RR03)
    // ===================================================================

    /**
     * Get borings for a specific cylinder for popup verification (RR03)
     * Query: DB_QUERY_GET_CYLINDER_BORINGS
     * @param cylinderName Cylinder name (e.g., 'USA')
     * @returns Array of boring records with date and description
     */
    public static async getCylinderBorings(cylinderName: string): Promise<CylinderBoring[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_CYLINDER_BORINGS',
            [cylinderName]
        );

        if (!result.rows || result.rows.length === 0) {
            CSReporter.warn(`No borings found for cylinder: ${cylinderName}`);
            return [];
        }

        const borings = result.rows.map((row: any) => ({
            boringDate: row.BORING_DATE || row.boring_date,
            description: row.DESCRIPTION || row.description
        }));

        CSReporter.debug(`Retrieved ${borings.length} borings for cylinder: ${cylinderName}`);
        return borings;
    }


    -------------------------------------------------------------------------------------------------------------

    import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { CSWebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { CSReporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { TTTFRuleConfigHelper, RuleType } from '../helpers/TTTFRuleConfigHelper';

/**
 * TTTF Add/Edit Scattered Mmte Page
 * Source: Scattered_Mmte_Sport_Mmte_4.txt, Scattered_Mmte_Sport_Mmte_5.txt, Scattered_Mmte_Sport_Mmte_6.txt
 * Handles Add/Edit Scattered Mmte form
 * All XPath locators from requirements documents
 */
@CSPage('tttf-add-scattered-mmte')
export class TTTFAddScatteredMmtePage extends CSBasePage {

    // ===================================================================
    // PAGE HEADER ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//form[@class="sssss-form"]//h1[text()="Add Scattered Mmte"]',
        description: 'Add Scattered Mmte page header',
        waitForVisible: true
    })
    public addScatteredMmteHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//form[@class="sssss-form"]//span[text()=" You cannot add a new scattered mmte if it matches rules already defined in another."]',
        description: 'Note about duplicate scattered mmtes',
        waitForVisible: false
    })
    public duplicateNoteMessage!: CSWebElement;

    // ===================================================================
    // CUMULATIVE MMTE & SCATTERED NAME SECTION
    // ===================================================================

    @CSGetElement({
        xpath: '//form[@class="sssss-form"]//h2[text()="Cumulative Mmte & Scattered Name"]',
        description: 'Cumulative Mmte & Scattered Name section header',
        waitForVisible: true
    })
    public cumulativeMmteSectionHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//form[@class="sssss-form"]//button[@name="selectedCumulativeMmteId"]',
        description: 'Cumulative Scattered dropdown button',
        waitForVisible: true,
        waitForEnabled: true
    })
    public cumulativeScatteredDropdown!: CSWebElement;

    @CSGetElement({
        xpath: '//form[@class="sssss-form"]//button[@name="selectedCumulativeMmteId"]/ancestor::div[contains(@class,"sssss-row")][1]//h5[@class="sssss-header-secondary"]',
        description: 'Scattered Mmte Name auto-genemmted value',
        waitForVisible: true
    })
    public scatteredMmteNameValue!: CSWebElement;

    // ===================================================================
    // SCATTERED MMTE TYPE RADIO BUTTONS
    // ===================================================================

    @CSGetElement({
        xpath: '//span[@class="sssss-radio-button__label-text" and text()="System Calculated"]/ancestor::div[contains(@class, "sssss-radio-button")]',
        description: 'System Calculated radio button container',
        waitForVisible: true
    })
    public systemCalculatedRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//span[@class="sssss-radio-button__label-text" and text()="System Calculated"]/ancestor::div[contains(@class,"sssss-radio-button")]//input[@name="isRulesManual"]',
        description: 'System Calculated radio input',
        waitForVisible: false
    })
    public systemCalculatedRadioInput!: CSWebElement;

    @CSGetElement({
        xpath: '//span[@class="sssss-radio-button__label-text" and text()="Manual"]/ancestor::div[contains(@class, "sssss-radio-button")]',
        description: 'Manual radio button container',
        waitForVisible: true
    })
    public manualRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//span[@class="sssss-radio-button__label-text" and text()="Manual"]/ancestor::div[contains(@class,"sssss-radio-button")]//input[@name="isRulesManual"]',
        description: 'Manual radio input',
        waitForVisible: false
    })
    public manualRadioInput!: CSWebElement;

    // ===================================================================
    // CONDITIONS SECTION
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[@class="myhTwoHeading" and text()="Conditions"]',
        description: 'Conditions section header',
        waitForVisible: true
    })
    public conditionsSectionHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//button[@name="methodologyType"]',
        description: 'Method dropdown button',
        waitForVisible: true
    })
    public methodDropdown!: CSWebElement;

    @CSGetElement({
        xpath: '//button[@name="sportMmteRulePriority"]',
        description: 'Sport Mmte Rule Priority dropdown button',
        waitForVisible: true
    })
    public sportMmteRulePriorityDropdown!: CSWebElement;

    @CSGetElement({
        xpath: '//button[@name="ttcalcDurationType"]',
        description: 'Primary Ttcalc dropdown (for Ttcalc Duration method)',
        waitForVisible: false
    })
    public primaryTtcalcDropdown!: CSWebElement;

    @CSGetElement({
        xpath: '//button[@name="annualAccrualDays"]',
        description: 'Annual Accrual Days dropdown (for Ttcalc Duration method)',
        waitForVisible: false
    })
    public annualAccrualDaysDropdown!: CSWebElement;

    // ===================================================================
    // RULES SECTION
    // ===================================================================

    @CSGetElement({
        xpath: '//h2[@class="myhTwoHeading" and text()="Rules"]',
        description: 'Rules section header',
        waitForVisible: true
    })
    public rulesSectionHeader!: CSWebElement;

    // ===================================================================
    // FIRST RULE SECTION
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]',
        description: 'First Rule section container',
        waitForVisible: true
    })
    public firstRuleSection!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//button[@aria-label="Expand First Rule"]',
        description: 'Expand First Rule button',
        waitForVisible: false
    })
    public expandFirstRuleButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//button[@aria-label="Collapse First Rule"]',
        description: 'Collapse First Rule button',
        waitForVisible: false
    })
    public collapseFirstRuleButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//input[@name="firstMonthLag"]',
        description: 'First Rule Month Lag input',
        waitForVisible: true
    })
    public firstRuleMonthLagInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//input[@name="firstBaseDay"]',
        description: 'First Rule Base Day input',
        waitForVisible: true
    })
    public firstRuleBaseDayInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//span[text()="Next Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]',
        description: 'First Rule Next Kindness Day radio container',
        waitForVisible: true
    })
    public firstRuleNextKindnessDayRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//span[text()="Previous Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]',
        description: 'First Rule Previous Kindness Day radio container',
        waitForVisible: true
    })
    public firstRulePreviousKindnessDayRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//span[@role="checkbox" and @aria-label="Optional: Adjust to Last Kindness Day of Current Cylinder Month if NBD is in Next Cylinder Month"]',
        description: 'First Rule Adjust to Last Kindness Day checkbox',
        waitForVisible: false
    })
    public firstRuleAdjustToLastBusDayCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//button[@id="addbuttonFirstRuleBaseCylinders"]',
        description: 'First Rule Associate Cylinders Select/Edit button',
        waitForVisible: true
    })
    public firstRuleAssociateCylindersButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//span[text()="Adjust Base"]/parent::span[@role="checkbox"]',
        description: 'First Rule Adjust Base checkbox',
        waitForVisible: true
    })
    public firstRuleAdjustBaseCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//input[@name="addToBaseDaysFirstRule"]',
        description: 'First Rule Adjust Base Days input',
        waitForVisible: true
    })
    public firstRuleAdjustBaseDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//span[text()="Secondary Adjust Base"]/parent::span[@role="checkbox"]',
        description: 'First Rule Secondary Adjust Base checkbox',
        waitForVisible: true
    })
    public firstRuleSecondaryAdjustBaseCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//input[@name="addToSecondaryAdjBaseDaysFirstRule"]',
        description: 'First Rule Secondary Adjust Base Days input',
        waitForVisible: true
    })
    public firstRuleSecondaryAdjustBaseDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//span[text()="Add to Lookback"]/parent::span[@role="checkbox"]',
        description: 'First Rule Add to Lookback checkbox',
        waitForVisible: true
    })
    public firstRuleAddToLookbackCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//input[@name="firstLookBackRuleDays"]',
        description: 'First Rule Lookback Days input',
        waitForVisible: true
    })
    public firstRuleLookbackDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//button[@id="addbuttonFirstRuleLookbackCylinders"]',
        description: 'First Rule Lookback Associate Cylinders Select/Edit button',
        waitForVisible: false
    })
    public firstRuleLookbackCylindersButton!: CSWebElement;

    // ===================================================================
    // FIRST RULE CYLINDER DISPLAY & BORING LINKS (RR05 Circles 315, 317)
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//button[@id="addbuttonFirstRuleBaseCylinders"]/ancestor::div[contains(@class, "sssss-row")][1]//p[@id="pCalender"]',
        description: 'First Rule Selected Cylinders Display Container',
        waitForVisible: false
    })
    public firstRuleSelectedCylindersContainer!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//button[@id="addbuttonFirstRuleLookbackCylinders"]/ancestor::div[contains(@class, "sssss-row")][1]//p[@id="pCalender"]',
        description: 'First Rule Lookback Selected Cylinders Display Container',
        waitForVisible: false
    })
    public firstRuleLookbackSelectedCylindersContainer!: CSWebElement;

    // ===================================================================
    // FIRST RULE INCLUDE WEEKENDS/BORINGS CHECKBOXES (RR05 Circles 378, 383)
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//input[@name="firstLookBackRuleDays"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-checkbox__label-text" and text()="Weekends"]/parent::span[@aria-label="Weekends"]',
        description: 'First Rule Include Weekends checkbox',
        waitForVisible: false
    })
    public firstRuleIncludeWeekendsCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="First Rule"]/ancestor::section[1]//input[@name="firstLookBackRuleDays"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-checkbox__label-text" and text()="Borings"]/parent::span[@aria-label="Borings"]',
        description: 'First Rule Include Borings checkbox',
        waitForVisible: false
    })
    public firstRuleIncludeBoringsCheckbox!: CSWebElement;

    // ===================================================================
    // SECOND RULE SECTION
    // Per RR05 Circle 408: Section header is "Second Rule (Optional)"
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]',
        description: 'Second Rule (Optional) section container',
        waitForVisible: false
    })
    public secondRuleSection!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//button[@aria-label="Expand Second Rule (Optional)"]',
        description: 'Expand Second Rule (Optional) button',
        waitForVisible: false
    })
    public expandSecondRuleButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//button[@aria-label="Collapse Second Rule (Optional)"]',
        description: 'Collapse Second Rule (Optional) button',
        waitForVisible: false
    })
    public collapseSecondRuleButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//input[@name="secondMonthLag"]',
        description: 'Second Rule Month Lag input',
        waitForVisible: false
    })
    public secondRuleMonthLagInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//input[@name="secondBaseDay"]',
        description: 'Second Rule Base Day input',
        waitForVisible: false
    })
    public secondRuleBaseDayInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//button[@id="addbuttonSecondRuleBaseCylinders"]',
        description: 'Second Rule Associate Cylinders Select/Edit button',
        waitForVisible: false
    })
    public secondRuleAssociateCylindersButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//span[text()="Next Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]//input[@type="radio"]',
        description: 'Second Rule Next Kindness Day radio input',
        waitForVisible: false
    })
    public secondRuleNextKindnessDayRadioInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//span[text()="Previous Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]//input[@type="radio"]',
        description: 'Second Rule Previous Kindness Day radio input',
        waitForVisible: false
    })
    public secondRulePreviousKindnessDayRadioInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//span[@role="checkbox" and @aria-label="Optional: Adjust to Last Kindness Day of Current Cylinder Month if NBD is in Next Cylinder Month"]',
        description: 'Second Rule Adjust to Last Kindness Day checkbox',
        waitForVisible: false
    })
    public secondRuleAdjustToLastBusDayCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//span[text()="Adjust Base"]/parent::span[@role="checkbox"]',
        description: 'Second Rule Adjust Base checkbox',
        waitForVisible: false
    })
    public secondRuleAdjustBaseCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//span[text()="Secondary Adjust Base"]/parent::span[@role="checkbox"]',
        description: 'Second Rule Secondary Adjust Base checkbox',
        waitForVisible: false
    })
    public secondRuleSecondaryAdjustBaseCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//span[text()="Add to Lookback"]/parent::span[@role="checkbox"]',
        description: 'Second Rule Add to Lookback checkbox',
        waitForVisible: false
    })
    public secondRuleAddToLookbackCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//input[@name="addToBaseDaysSecondRule"]',
        description: 'Second Rule Adjust Base Days input',
        waitForVisible: false
    })
    public secondRuleAdjustBaseDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//input[@name="addToSecondaryAdjBaseDaysSecondRule"]',
        description: 'Second Rule Secondary Adjust Base Days input',
        waitForVisible: false
    })
    public secondRuleSecondaryAdjustBaseDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//input[@name="secondLookBackRuleDays"]',
        description: 'Second Rule Lookback Days input',
        waitForVisible: false
    })
    public secondRuleLookbackDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Second Rule (Optional)"]/ancestor::section[1]//button[@id="addbuttonSecondRuleLookbackCylinders"]',
        description: 'Second Rule Lookback Associate Cylinders Select/Edit button',
        waitForVisible: false
    })
    public secondRuleLookbackCylindersButton!: CSWebElement;

    // ===================================================================
    // MMTE START DATE DETERMINATION RULE SECTION (RR04 - Element Verification)
    // Alternative section name used in Add Scattered Mmte screen verification
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]',
        description: 'Mmte Start Date Determination Rule section container',
        waitForVisible: false
    })
    public mmteStartDateDeterminationRuleSection!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//button[@aria-label="Expand Mmte Start Date Determination Rule"]',
        description: 'Expand Mmte Start Date Determination Rule button',
        waitForVisible: false
    })
    public expandMmteStartDateDeterminationRuleButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//button[@aria-label="Collapse Mmte Start Date Determination Rule"]',
        description: 'Collapse Mmte Start Date Determination Rule button',
        waitForVisible: false
    })
    public collapseMmteStartDateDeterminationRuleButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//span[@class="sssss-feedback_messages"]//strong[text()="Define the Primary Rule."]',
        description: 'Mmte Start Date Define the Primary Rule info message',
        waitForVisible: false
    })
    public mmteStartDatePrimaryRuleInfoMessage!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="firstMonthLag"]',
        description: 'Mmte Start Date Month Lag input',
        waitForVisible: false
    })
    public mmteStartDateMonthLagInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="firstBaseDay"]',
        description: 'Mmte Start Date Base Day input',
        waitForVisible: false
    })
    public mmteStartDateBaseDayInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//span[text()="Next Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]',
        description: 'Mmte Start Date Next Kindness Day radio container',
        waitForVisible: false
    })
    public mmteStartDateNextKindnessDayRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//span[text()="Next Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]//input[@type="radio" and @name="firstBaseDayAdjust"]',
        description: 'Mmte Start Date Next Kindness Day radio input',
        waitForVisible: false
    })
    public mmteStartDateNextKindnessDayRadioInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//span[text()="Previous Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]',
        description: 'Mmte Start Date Previous Kindness Day radio container',
        waitForVisible: false
    })
    public mmteStartDatePreviousKindnessDayRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//span[text()="Previous Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]//input[@type="radio" and @name="firstBaseDayAdjust"]',
        description: 'Mmte Start Date Previous Kindness Day radio input',
        waitForVisible: false
    })
    public mmteStartDatePreviousKindnessDayRadioInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//span[@role="checkbox" and @aria-label="Optional: Adjust to Last Kindness Day of Current Cylinder Month if NBD is in Next Cylinder Month"]',
        description: 'Mmte Start Date Adjust to Last Kindness Day checkbox',
        waitForVisible: false
    })
    public mmteStartDateAdjustToLastBusDayCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//button[@id="addbuttonFirstRuleBaseCylinders"]',
        description: 'Mmte Start Date Associate Cylinders Select/Edit button',
        waitForVisible: false
    })
    public mmteStartDateAssociateCylindersButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//span[text()="Adjust Base"]/parent::span[@role="checkbox"]',
        description: 'Mmte Start Date Adjust Base checkbox',
        waitForVisible: false
    })
    public mmteStartDateAdjustBaseCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="addToBaseDaysFirstRule"]',
        description: 'Mmte Start Date Adjust Base Days input',
        waitForVisible: false
    })
    public mmteStartDateAdjustBaseDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="addToBaseDaysFirstRule"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-radio-button__label-text" and text()="Kindness Days"]/parent::label[1]/preceding::input[@name="firstBaseDateOffsetType"][1]',
        description: 'Mmte Start Date Adjust Base Kindness Days radio',
        waitForVisible: false
    })
    public mmteStartDateAdjustBaseKindnessDaysRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="addToBaseDaysFirstRule"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-radio-button__label-text" and text()="Cylinder Days"]/parent::label[1]/preceding::input[@name="firstBaseDateOffsetType"][1]',
        description: 'Mmte Start Date Adjust Base Cylinder Days radio',
        waitForVisible: false
    })
    public mmteStartDateAdjustBaseCylinderDaysRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//span[text()="Secondary Adjust Base"]/parent::span[@role="checkbox"]',
        description: 'Mmte Start Date Secondary Adjust Base checkbox',
        waitForVisible: false
    })
    public mmteStartDateSecondaryAdjustBaseCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="addToSecondaryAdjBaseDaysFirstRule"]',
        description: 'Mmte Start Date Secondary Adjust Base Days input',
        waitForVisible: false
    })
    public mmteStartDateSecondaryAdjustBaseDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="addToSecondaryAdjBaseDaysFirstRule"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-radio-button__label-text" and text()="Kindness Days"]/parent::label[1]/preceding::input[@name="SecondaryAdjBaseOffsetTypeFirstRule"][1]',
        description: 'Mmte Start Date Secondary Adjust Base Kindness Days radio',
        waitForVisible: false
    })
    public mmteStartDateSecondaryAdjustBaseKindnessDaysRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="addToSecondaryAdjBaseDaysFirstRule"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-radio-button__label-text" and text()="Cylinder Days"]/parent::label[1]/preceding::input[@name="SecondaryAdjBaseOffsetTypeFirstRule"][1]',
        description: 'Mmte Start Date Secondary Adjust Base Cylinder Days radio',
        waitForVisible: false
    })
    public mmteStartDateSecondaryAdjustBaseCylinderDaysRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//span[text()="Add to Lookback"]/parent::span[@role="checkbox"]',
        description: 'Mmte Start Date Add to Lookback checkbox',
        waitForVisible: false
    })
    public mmteStartDateAddToLookbackCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="firstLookBackRuleDays"]',
        description: 'Mmte Start Date Lookback Days input',
        waitForVisible: false
    })
    public mmteStartDateLookbackDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="firstLookBackRuleDays"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-checkbox__label-text" and text()="Weekends"]/parent::span[@aria-label="Weekends"]',
        description: 'Mmte Start Date Include Weekends checkbox',
        waitForVisible: false
    })
    public mmteStartDateIncludeWeekendsCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//input[@name="firstLookBackRuleDays"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-checkbox__label-text" and text()="Borings"]/parent::span[@aria-label="Borings"]',
        description: 'Mmte Start Date Include Borings checkbox',
        waitForVisible: false
    })
    public mmteStartDateIncludeBoringsCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte Start Date Determination Rule"]/ancestor::section[1]//button[@id="addbuttonFirstRuleLookbackCylinders"]',
        description: 'Mmte Start Date Lookback Associate Cylinders button',
        waitForVisible: false
    })
    public mmteStartDateLookbackCylindersButton!: CSWebElement;

    // ===================================================================
    // MMTE END DATE DETERMINATION RULE SECTION (RR04 - Element Verification)
    // Alternative section name used in Add Scattered Mmte screen verification
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]',
        description: 'Mmte End Date Determination Rule section container',
        waitForVisible: false
    })
    public mmteEndDateDeterminationRuleSection!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//button[@aria-label="Expand Mmte End Date Determination Rule"]',
        description: 'Expand Mmte End Date Determination Rule button',
        waitForVisible: false
    })
    public expandMmteEndDateDeterminationRuleButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//button[@aria-label="Collapse Mmte End Date Determination Rule"]',
        description: 'Collapse Mmte End Date Determination Rule button',
        waitForVisible: false
    })
    public collapseMmteEndDateDeterminationRuleButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[@class="sssss-feedback_messages"]//strong[text()="Include a Second Rule when date logic for this scattered mmte must consider multiple date combinations."]',
        description: 'Mmte End Date Second Rule info message',
        waitForVisible: false
    })
    public mmteEndDateSecondRuleInfoMessage!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//input[@name="monthLagSecondRule"]',
        description: 'Mmte End Date Month Lag input',
        waitForVisible: false
    })
    public mmteEndDateMonthLagInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//label[text()="Base Day"]/parent::div/following::div[@class="sssss-field__content"][1]/input',
        description: 'Mmte End Date Base Day input',
        waitForVisible: false
    })
    public mmteEndDateBaseDayInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Next Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]',
        description: 'Mmte End Date Next Kindness Day radio container',
        waitForVisible: false
    })
    public mmteEndDateNextKindnessDayRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Next Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]//input[@type="radio" and @name="secondBaseDayAdjust"]',
        description: 'Mmte End Date Next Kindness Day radio input',
        waitForVisible: false
    })
    public mmteEndDateNextKindnessDayRadioInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Previous Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]',
        description: 'Mmte End Date Previous Kindness Day radio container',
        waitForVisible: false
    })
    public mmteEndDatePreviousKindnessDayRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Previous Kindness Day"]/ancestor::div[contains(@class, "sssss-radio-button")][1]//input[@type="radio" and @name="secondBaseDayAdjust"]',
        description: 'Mmte End Date Previous Kindness Day radio input',
        waitForVisible: false
    })
    public mmteEndDatePreviousKindnessDayRadioInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[@role="checkbox" and @aria-label="Optional: Adjust to Last Kindness Day of Current Cylinder Month if NBD is in Next Cylinder Month"]',
        description: 'Mmte End Date Adjust to Last Kindness Day checkbox',
        waitForVisible: false
    })
    public mmteEndDateAdjustToLastBusDayCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//button[@id="addbuttonSecondRuleBaseCylinders"]',
        description: 'Mmte End Date Associate Cylinders Select/Edit button',
        waitForVisible: false
    })
    public mmteEndDateAssociateCylindersButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Adjust Base"]/parent::span[@role="checkbox"]',
        description: 'Mmte End Date Adjust Base checkbox',
        waitForVisible: false
    })
    public mmteEndDateAdjustBaseCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Adjust Base"]/ancestor::div[contains(@class, "sssss-checkbox")][1]/following::div[1]//label[text()="Days"]/following::div[@class="sssss-field__content"][1]/input',
        description: 'Mmte End Date Adjust Base Days input',
        waitForVisible: false
    })
    public mmteEndDateAdjustBaseDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Adjust Base"]/ancestor::div[contains(@class, "sssss-checkbox")][1]/following::div[1]//span[text()="Kindness Days"]/parent::label[1]/preceding::input[@name="associateToSecondRule"][1]',
        description: 'Mmte End Date Adjust Base Kindness Days radio',
        waitForVisible: false
    })
    public mmteEndDateAdjustBaseKindnessDaysRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Adjust Base"]/ancestor::div[contains(@class, "sssss-checkbox")][1]/following::div[1]//span[text()="Cylinder Days"]/parent::label[1]/preceding::input[@name="associateToSecondRule"][1]',
        description: 'Mmte End Date Adjust Base Cylinder Days radio',
        waitForVisible: false
    })
    public mmteEndDateAdjustBaseCylinderDaysRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Secondary Adjust Base"]/parent::span[@role="checkbox"]',
        description: 'Mmte End Date Secondary Adjust Base checkbox',
        waitForVisible: false
    })
    public mmteEndDateSecondaryAdjustBaseCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//input[@name="addToSecondaryAdjBaseDaysSecondRule"]',
        description: 'Mmte End Date Secondary Adjust Base Days input',
        waitForVisible: false
    })
    public mmteEndDateSecondaryAdjustBaseDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//input[@name="addToSecondaryAdjBaseDaysSecondRule"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-radio-button__label-text" and text()="Kindness Days"]/parent::label[1]/preceding-sibling::input[@name="SecondaryAdjBaseOffsetTypeSecondRule"][1]',
        description: 'Mmte End Date Secondary Adjust Base Kindness Days radio',
        waitForVisible: false
    })
    public mmteEndDateSecondaryAdjustBaseKindnessDaysRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//input[@name="addToSecondaryAdjBaseDaysSecondRule"]/ancestor::div[contains(@class, "sssss-row--padding")][1]//span[@class="sssss-radio-button__label-text" and text()="Cylinder Days"]/parent::label[1]/preceding::input[@name="SecondaryAdjBaseOffsetTypeSecondRule"][1]',
        description: 'Mmte End Date Secondary Adjust Base Cylinder Days radio',
        waitForVisible: false
    })
    public mmteEndDateSecondaryAdjustBaseCylinderDaysRadio!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Add to Lookback"]/parent::span[@role="checkbox"]',
        description: 'Mmte End Date Add to Lookback checkbox',
        waitForVisible: false
    })
    public mmteEndDateAddToLookbackCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Add to Lookback"]/ancestor::div[contains(@class, "sssss-checkbox")][1]/following-sibling::div[1]/div[@class="sssss-row--padding"][1]//input[contains(@id, "sssss-text-input")]',
        description: 'Mmte End Date Lookback Days input',
        waitForVisible: false
    })
    public mmteEndDateLookbackDaysInput!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//legend[text()="Include"]/parent::div[1]//span[@role="checkbox" and @aria-label="Weekends"]',
        description: 'Mmte End Date Include Weekends checkbox',
        waitForVisible: false
    })
    public mmteEndDateIncludeWeekendsCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//legend[text()="Include"]/parent::div[1]//span[@role="checkbox" and @aria-label="Borings"]',
        description: 'Mmte End Date Include Borings checkbox',
        waitForVisible: false
    })
    public mmteEndDateIncludeBoringsCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//button[@id="addbuttonSecondRuleLookbackCylinders"]',
        description: 'Mmte End Date Lookback Associate Cylinders button',
        waitForVisible: false
    })
    public mmteEndDateLookbackCylindersButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//span[text()="Add Lockout"]/parent::span[@role="checkbox"]',
        description: 'Mmte End Date Add Lockout checkbox',
        waitForVisible: false
    })
    public mmteEndDateAddLockoutCheckbox!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Mmte End Date Determination Rule"]/ancestor::section[1]//input[@name="lockoutOffset"]',
        description: 'Mmte End Date Lockout Days input',
        waitForVisible: false
    })
    public mmteEndDateLockoutDaysInput!: CSWebElement;

    // ===================================================================
    // OTHER RULES SECTION (Rounding)
    // ===================================================================

    @CSGetElement({
        xpath: '//h5[text()="Other Rules"]/ancestor::section[1]',
        description: 'Other Rules section container',
        waitForVisible: true
    })
    public otherRulesSection!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Other Rules"]/ancestor::section[1]//button[contains(@aria-label, "Expand")]',
        description: 'Expand Other Rules button',
        waitForVisible: false
    })
    public expandOtherRulesButton!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Other Rules"]/ancestor::section[1]//button[@name="roundingType"]',
        description: 'Rounding Logic dropdown',
        waitForVisible: true
    })
    public roundingLogicDropdown!: CSWebElement;

    @CSGetElement({
        xpath: '//h5[text()="Other Rules"]/ancestor::section[1]//button[@name="roundingFactor"]',
        description: 'Rounding Factor dropdown',
        waitForVisible: true
    })
    public roundingFactorDropdown!: CSWebElement;

    // ===================================================================
    // SAVE/CANCEL BUTTONS
    // ===================================================================

    @CSGetElement({
        xpath: '//span[text()="Save"]/parent::button[@id="saveScatteredMmteButton"]',
        description: 'Save Scattered Mmte button',
        waitForEnabled: true
    })
    public saveButton!: CSWebElement;

    @CSGetElement({
        xpath: '//span[text()="Cancel"]/parent::button[@aria-label="Cancel"]',
        description: 'Cancel button',
        waitForEnabled: true
    })
    public cancelButton!: CSWebElement;

    // ===================================================================
    // ADD CYLINDER POPUP ELEMENTS
    // ===================================================================

    @CSGetElement({
        xpath: '//div[@class="sssss-modal"]//div[@class="sssss-panel__content-wrapper"]',
        description: 'Add Cylinder popup container',
        waitForVisible: false
    })
    public addCylinderPopup!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//h5[text()="Add"]',
        description: 'Add Cylinder popup header',
        waitForVisible: false
    })
    public addCylinderPopupHeader!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//table[@class="sssss-table"]',
        description: 'Cylinder selection table in popup',
        waitForVisible: false
    })
    public cylinderSelectionTable!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__footer"]//span[@class="sssss-button__label" and text()="Apply"]/parent::button[1]',
        description: 'Apply button in cylinder popup',
        waitForVisible: false
    })
    public cylinderPopupApplyButton!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__footer"]//span[@class="sssss-button__label" and text()="Cancel"]/parent::button[1]',
        description: 'Cancel button in cylinder popup',
        waitForVisible: false
    })
    public cylinderPopupCancelButton!: CSWebElement;

    @CSGetElement({
        xpath: '//div[@class="sssss-panel__content-wrapper"]//button[contains(@class, "sssss-panel__close-icon")]',
        description: 'Close button in cylinder popup',
        waitForVisible: false
    })
    public cylinderPopupCloseButton!: CSWebElement;

    // ===================================================================
    // DUPLICATE VALIDATION ERROR
    // ===================================================================

    @CSGetElement({
        xpath: '//div[contains(@class, "sssss-alert--error")]//span[contains(text(), "already exists")]',
        description: 'Duplicate scattered mmte error message',
        waitForVisible: false
    })
    public duplicateErrorMessage!: CSWebElement;

    protected initializeElements(): void {
        CSReporter.debug('TTTFAddScatteredMmtePage elements initialized');
    }

    // ===================================================================
    // PAGE VERIFICATION METHODS
    // ===================================================================

    /**
     * Verify Add Scattered Mmte page header is displayed
     */
    public async verifyPageHeader(): Promise<void> {
        CSReporter.info('Verifying Add Scattered Mmte page header');
        await this.addScatteredMmteHeader.waitForVisible(15000);
        CSReporter.pass('Add Scattered Mmte page header verified');
    }

    /**
     * Verify duplicate note message is present
     */
    public async verifyDuplicateNotePresent(): Promise<void> {
        CSReporter.info('Verifying duplicate note message');
        await this.duplicateNoteMessage.waitForVisible(10000);
        CSReporter.pass('Duplicate note message is present');
    }

    // ===================================================================
    // CUMULATIVE SCATTERED METHODS
    // ===================================================================

    /**
     * Click Cumulative Scattered dropdown
     */
    public async clickCumulativeScatteredDropdown(): Promise<void> {
        CSReporter.info('Clicking Cumulative Scattered dropdown');
        await this.cumulativeScatteredDropdown.waitForVisible(10000);
        await this.cumulativeScatteredDropdown.clickWithTimeout(10000);
        CSReporter.pass('Clicked Cumulative Scattered dropdown');
    }

    /**
     * Select Cumulative Scattered from dropdown
     */
    public async selectCumulativeScattered(cumulativeMmteName: string): Promise<void> {
        CSReporter.info(`Selecting Cumulative Scattered: ${cumulativeMmteName}`);

        await this.clickCumulativeScatteredDropdown();

        // Wait for dropdown list
        const dropdownList = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon") and @name="selectedCumulativeMmteId"]//ul[@role="listbox"]',
            'Cumulative Scattered dropdown list',
            this.page
        );
        await dropdownList.waitForVisible(10000);

        // Click option
        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='selectedCumulativeMmteId']//ul[@role='listbox']//li[@role='option']//span[text()='${cumulativeMmteName}']/parent::span`,
            `Cumulative Scattered option: ${cumulativeMmteName}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        CSReporter.pass(`Selected Cumulative Scattered: ${cumulativeMmteName}`);
    }

    /**
     * Verify Cumulative Scattered is selected
     */
    public async verifyCumulativeScatteredSelected(cumulativeMmteName: string): Promise<void> {
        CSReporter.info(`Verifying Cumulative Scattered selected: ${cumulativeMmteName}`);
        const selectedElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//button[@name='selectedCumulativeMmteId']//span[@class='sssss-button__label' and text()='${cumulativeMmteName}']`,
            `Selected Cumulative Scattered: ${cumulativeMmteName}`,
            this.page
        );
        await selectedElement.waitForVisible(10000);
        CSReporter.pass(`Cumulative Scattered verified: ${cumulativeMmteName}`);
    }

    /**
     * Get auto-genemmted Scattered Mmte Name
     */
    public async getScatteredMmteName(): Promise<string> {
        CSReporter.info('Getting auto-genemmted Scattered Mmte Name');
        await this.scatteredMmteNameValue.waitForVisible(10000);
        const value = await this.scatteredMmteNameValue.textContentWithTimeout(5000);
        CSReporter.info(`Scattered Mmte Name: ${value}`);
        return value || '';
    }

    // ===================================================================
    // SCATTERED MMTE TYPE METHODS
    // ===================================================================

    /**
     * Verify System Calculated radio is selected by default
     */
    public async verifySystemCalculatedSelectedByDefault(): Promise<boolean> {
        CSReporter.info('Verifying System Calculated radio is selected by default');
        await this.systemCalculatedRadioInput.waitForVisible(10000);
        const isChecked = await this.systemCalculatedRadioInput.isCheckedWithTimeout(5000);
        if (isChecked) {
            CSReporter.pass('System Calculated radio is selected by default');
        }
        return isChecked;
    }

    /**
     * Select System Calculated radio
     */
    public async selectSystemCalculated(): Promise<void> {
        CSReporter.info('Selecting System Calculated radio');
        await this.systemCalculatedRadio.clickWithTimeout(10000);
        await this.page.waitForTimeout(500);
        CSReporter.pass('Selected System Calculated radio');
    }

    /**
     * Select Manual radio
     */
    public async selectManual(): Promise<void> {
        CSReporter.info('Selecting Manual radio');
        await this.manualRadio.clickWithTimeout(10000);
        await this.page.waitForTimeout(500);
        CSReporter.pass('Selected Manual radio');
    }

    // ===================================================================
    // CONDITIONS SECTION METHODS
    // ===================================================================

    /**
     * Verify Conditions section is present
     */
    public async verifyConditionsSectionPresent(): Promise<void> {
        CSReporter.info('Verifying Conditions section');
        await this.conditionsSectionHeader.waitForVisible(10000);
        CSReporter.pass('Conditions section is present');
    }

    /**
     * Verify Rules section is present
     */
    public async verifyRulesSectionPresent(): Promise<void> {
        CSReporter.info('Verifying Rules section');
        await this.rulesSectionHeader.waitForVisible(10000);
        CSReporter.pass('Rules section is present');
    }

    /**
     * Select Method from dropdown
     */
    public async selectMethod(methodType: string): Promise<void> {
        CSReporter.info(`Selecting Method: ${methodType}`);

        await this.methodDropdown.waitForVisible(10000);
        await this.methodDropdown.clickWithTimeout(10000);

        // Wait for dropdown list
        const dropdownList = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon") and @name="methodologyType"]//ul[@role="listbox"]',
            'Method dropdown list',
            this.page
        );
        await dropdownList.waitForVisible(10000);

        // Click option
        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='methodologyType']//ul[@role='listbox']//li[@role='option']//span[text()='${methodType}']/parent::span`,
            `Method option: ${methodType}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        CSReporter.pass(`Selected Method: ${methodType}`);
    }

    /**
     * Verify Method is selected
     */
    public async verifyMethodSelected(methodType: string): Promise<void> {
        CSReporter.info(`Verifying Method selected: ${methodType}`);
        const selectedElement = CSElementFactory.createByXPath(
            `//form[@class='sssss-form']//button[@name='methodologyType']//span[@class='sssss-button__label' and text()='${methodType}']`,
            `Selected Method: ${methodType}`,
            this.page
        );
        await selectedElement.waitForVisible(10000);
        CSReporter.pass(`Method verified: ${methodType}`);
    }

    /**
     * Select Sport Mmte Rule Priority from dropdown
     */
    public async selectSportMmteRulePriority(priority: string): Promise<void> {
        CSReporter.info(`Selecting Sport Mmte Rule Priority: ${priority}`);

        await this.sportMmteRulePriorityDropdown.waitForVisible(10000);
        await this.sportMmteRulePriorityDropdown.clickWithTimeout(10000);

        // Wait for dropdown list
        const dropdownList = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon") and @name="sportMmteRulePriority"]//ul[@role="listbox"]',
            'Sport Mmte Rule Priority dropdown list',
            this.page
        );
        await dropdownList.waitForVisible(10000);

        // Click option
        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='sportMmteRulePriority']//ul[@role='listbox']//li[@role='option']//span[contains(@class, 'sssss-menu-item__label')]/span[text()='${priority}']`,
            `Sport Mmte Rule Priority option: ${priority}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        CSReporter.pass(`Selected Sport Mmte Rule Priority: ${priority}`);
    }

    // ===================================================================
    // FIRST RULE METHODS
    // ===================================================================

    /**
     * Expand First Rule section if collapsed
     */
    public async expandFirstRuleSection(): Promise<void> {
        CSReporter.info('Expanding First Rule section');
        const isCollapsed = await this.expandFirstRuleButton.isVisibleWithTimeout(2000);
        if (isCollapsed) {
            await this.expandFirstRuleButton.clickWithTimeout(10000);
            await this.page.waitForTimeout(500);
            CSReporter.pass('First Rule section expanded');
        } else {
            CSReporter.info('First Rule section already expanded');
        }
    }

    /**
     * Expand Second Rule section if collapsed
     */
    public async expandSecondRuleSection(): Promise<void> {
        CSReporter.info('Expanding Second Rule section');
        const isCollapsed = await this.expandSecondRuleButton.isVisibleWithTimeout(2000);
        if (isCollapsed) {
            await this.expandSecondRuleButton.clickWithTimeout(10000);
            await this.page.waitForTimeout(500);
            CSReporter.pass('Second Rule section expanded');
        } else {
            CSReporter.info('Second Rule section already expanded');
        }
    }

    /**
     * Expand Other Rules section if collapsed
     */
    public async expandOtherRulesSection(): Promise<void> {
        CSReporter.info('Expanding Other Rules section');
        const isCollapsed = await this.expandOtherRulesButton.isVisibleWithTimeout(2000);
        if (isCollapsed) {
            await this.expandOtherRulesButton.clickWithTimeout(10000);
            await this.page.waitForTimeout(500);
            CSReporter.pass('Other Rules section expanded');
        } else {
            CSReporter.info('Other Rules section already expanded');
        }
    }

    /**
     * Enter First Rule Month Lag
     */
    public async enterFirstRuleMonthLag(monthLag: string): Promise<void> {
        CSReporter.info(`Entering First Rule Month Lag: ${monthLag}`);
        await this.firstRuleMonthLagInput.waitForVisible(10000);
        await this.firstRuleMonthLagInput.clear();
        await this.firstRuleMonthLagInput.fill(monthLag);
        CSReporter.pass(`Entered First Rule Month Lag: ${monthLag}`);
    }

    /**
     * Enter First Rule Base Day
     */
    public async enterFirstRuleBaseDay(baseDay: string): Promise<void> {
        CSReporter.info(`Entering First Rule Base Day: ${baseDay}`);
        await this.firstRuleBaseDayInput.waitForVisible(10000);
        await this.firstRuleBaseDayInput.clear();
        await this.firstRuleBaseDayInput.fill(baseDay);
        CSReporter.pass(`Entered First Rule Base Day: ${baseDay}`);
    }

    /**
     * Select First Rule Base Day Adjust To (Next or Previous Kindness Day)
     */
    public async selectFirstRuleBaseDayAdjustTo(adjustTo: string): Promise<void> {
        CSReporter.info(`Selecting First Rule Base Day Adjust To: ${adjustTo}`);

        if (adjustTo.toLowerCase().includes('next')) {
            await this.firstRuleNextKindnessDayRadio.clickWithTimeout(10000);
        } else if (adjustTo.toLowerCase().includes('previous')) {
            await this.firstRulePreviousKindnessDayRadio.clickWithTimeout(10000);
        }

        await this.page.waitForTimeout(300);
        CSReporter.pass(`Selected First Rule Base Day Adjust To: ${adjustTo}`);
    }

    /**
     * Check First Rule Adjust to Last Kindness Day checkbox
     */
    public async checkFirstRuleAdjustToLastBusDay(shouldCheck: boolean): Promise<void> {
        CSReporter.info(`Setting First Rule Adjust to Last Bus Day: ${shouldCheck}`);

        const ariaChecked = await this.firstRuleAdjustToLastBusDayCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        const isCurrentlyChecked = ariaChecked === 'true';

        if (shouldCheck !== isCurrentlyChecked) {
            await this.firstRuleAdjustToLastBusDayCheckbox.clickWithTimeout(10000);
            await this.page.waitForTimeout(300);
        }

        CSReporter.pass(`First Rule Adjust to Last Bus Day set to: ${shouldCheck}`);
    }

    /**
     * Select First Rule Associate Cylinders
     */
    public async selectFirstRuleAssociateCylinders(cylinders: string[]): Promise<void> {
        CSReporter.info(`Selecting First Rule Associate Cylinders: ${cylinders.join(', ')}`);

        // Click Select/Edit button
        await this.firstRuleAssociateCylindersButton.waitForVisible(10000);
        await this.firstRuleAssociateCylindersButton.clickWithTimeout(10000);

        // Wait for popup
        await this.addCylinderPopup.waitForVisible(10000);

        // Select each cylinder
        for (const cylinder of cylinders) {
            const cylinderCheckbox = CSElementFactory.createByXPath(
                `//div[@class='sssss-panel__content-wrapper']//div[@class='sssss-panel__body']//table[@class='sssss-table']/tbody//td/div[text()='${cylinder}']/ancestor::tr[1]/td[1]//span[@role='checkbox']`,
                `Cylinder checkbox: ${cylinder}`,
                this.page
            );

            const ariaChecked = await cylinderCheckbox.getAttributeWithTimeout('aria-checked', 5000);
            if (ariaChecked !== 'true') {
                await cylinderCheckbox.clickWithTimeout(10000);
                await this.page.waitForTimeout(200);
            }
        }

        // Click Apply
        await this.cylinderPopupApplyButton.waitForVisible(10000);
        await this.cylinderPopupApplyButton.clickWithTimeout(10000);

        // Wait for popup to close
        await this.addCylinderPopup.waitForDetached(10000);

        CSReporter.pass(`Selected First Rule Associate Cylinders: ${cylinders.join(', ')}`);
    }

    /**
     * Check and configure First Rule Adjust Base
     */
    public async configureFirstRuleAdjustBase(days: string, associateTo: string): Promise<void> {
        await TTTFRuleConfigHelper.configureAdjustBase(
            this.page,
            'First',
            this.firstRuleAdjustBaseCheckbox,
            { days, associateTo }
        );
    }

    /**
     * Check and configure First Rule Add to Lookback
     */
    public async configureFirstRuleAddToLookback(days: string, includeWeekends: boolean, includeBorings: boolean): Promise<void> {
        await TTTFRuleConfigHelper.configureAddToLookback(
            this.page,
            'First',
            this.firstRuleAddToLookbackCheckbox,
            { days, includeWeekends, includeBorings }
        );
    }

    /**
     * Configure First Rule Secondary Adjust Base
     */
    public async configureFirstRuleSecondaryAdjustBase(days: string, associateTo: string): Promise<void> {
        await TTTFRuleConfigHelper.configureSecondaryAdjustBase(
            this.page,
            'First',
            this.firstRuleSecondaryAdjustBaseCheckbox,
            { days, associateTo }
        );
    }

    /**
     * Select First Rule Lookback Associate Cylinders
     */
    public async selectFirstRuleLookbackAssociateCylinders(cylinders: string[]): Promise<void> {
        CSReporter.info(`Selecting First Rule Lookback Associate Cylinders: ${cylinders.join(', ')}`);

        const selectButton = CSElementFactory.createByXPath(
            '//h5[text()="First Rule"]/ancestor::section[1]//button[@id="addbuttonFirstRuleLookbackCylinders"]',
            'First Rule Lookback Associate Cylinders button',
            this.page
        );
        await selectButton.waitForVisible(10000);
        await selectButton.clickWithTimeout(10000);

        // Wait for cylinder popup
        await this.page.waitForTimeout(500);

        // Select each cylinder
        for (const cylinder of cylinders) {
            const cylinderRow = CSElementFactory.createByXPath(
                `//div[contains(@class, 'modal')]//table//td[text()='${cylinder}']/parent::tr//input[@type='checkbox']`,
                `Cylinder checkbox: ${cylinder}`,
                this.page
            );
            const isChecked = await cylinderRow.isChecked();
            if (!isChecked) {
                await cylinderRow.clickWithTimeout(10000);
            }
        }

        // Click Done
        const doneButton = CSElementFactory.createByXPath(
            '//div[contains(@class, "modal")]//button[text()="Done"]',
            'Cylinder Done button',
            this.page
        );
        await doneButton.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);

        CSReporter.pass(`Selected First Rule Lookback Associate Cylinders: ${cylinders.join(', ')}`);
    }

    // ===================================================================
    // SECOND RULE METHODS
    // ===================================================================

    /**
     * Enter Second Rule Month Lag
     */
    public async enterSecondRuleMonthLag(monthLag: string): Promise<void> {
        CSReporter.info(`Entering Second Rule Month Lag: ${monthLag}`);
        await this.secondRuleMonthLagInput.waitForVisible(10000);
        await this.secondRuleMonthLagInput.clear();
        await this.secondRuleMonthLagInput.fill(monthLag);
        CSReporter.pass(`Entered Second Rule Month Lag: ${monthLag}`);
    }

    /**
     * Enter Second Rule Base Day
     */
    public async enterSecondRuleBaseDay(baseDay: string): Promise<void> {
        CSReporter.info(`Entering Second Rule Base Day: ${baseDay}`);
        await this.secondRuleBaseDayInput.waitForVisible(10000);
        await this.secondRuleBaseDayInput.clear();
        await this.secondRuleBaseDayInput.fill(baseDay);
        CSReporter.pass(`Entered Second Rule Base Day: ${baseDay}`);
    }

    /**
     * Select Second Rule Base Day Adjust To
     */
    public async selectSecondRuleBaseDayAdjustTo(adjustTo: string): Promise<void> {
        CSReporter.info(`Selecting Second Rule Base Day Adjust To: ${adjustTo}`);

        if (adjustTo.toLowerCase().includes('next')) {
            await this.secondRuleNextKindnessDayRadioInput.clickWithTimeout(10000);
        } else if (adjustTo.toLowerCase().includes('previous')) {
            await this.secondRulePreviousKindnessDayRadioInput.clickWithTimeout(10000);
        }

        CSReporter.pass(`Selected Second Rule Base Day Adjust To: ${adjustTo}`);
    }

    /**
     * Check/Uncheck Second Rule Adjust to Last Kindness Day checkbox
     */
    public async checkSecondRuleAdjustToLastBusDay(shouldCheck: boolean): Promise<void> {
        CSReporter.info(`Setting Second Rule Adjust to Last Kindness Day: ${shouldCheck}`);

        const ariaChecked = await this.secondRuleAdjustToLastBusDayCheckbox.getAttributeWithTimeout('aria-checked', 5000);
        const isChecked = ariaChecked === 'true';

        if (shouldCheck !== isChecked) {
            await this.secondRuleAdjustToLastBusDayCheckbox.clickWithTimeout(10000);
        }

        CSReporter.pass(`Second Rule Adjust to Last Kindness Day set to: ${shouldCheck}`);
    }

    /**
     * Select Second Rule Associate Cylinders
     */
    public async selectSecondRuleAssociateCylinders(cylinders: string[]): Promise<void> {
        CSReporter.info(`Selecting Second Rule Associate Cylinders: ${cylinders.join(', ')}`);

        await this.secondRuleAssociateCylindersButton.waitForVisible(10000);
        await this.secondRuleAssociateCylindersButton.clickWithTimeout(10000);

        // Wait for cylinder popup
        await this.page.waitForTimeout(500);

        // Select each cylinder
        for (const cylinder of cylinders) {
            const cylinderRow = CSElementFactory.createByXPath(
                `//div[contains(@class, 'modal')]//table//td[text()='${cylinder}']/parent::tr//input[@type='checkbox']`,
                `Cylinder checkbox: ${cylinder}`,
                this.page
            );
            const isChecked = await cylinderRow.isChecked();
            if (!isChecked) {
                await cylinderRow.clickWithTimeout(10000);
            }
        }

        // Click Done
        const doneButton = CSElementFactory.createByXPath(
            '//div[contains(@class, "modal")]//button[text()="Done"]',
            'Cylinder Done button',
            this.page
        );
        await doneButton.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);

        CSReporter.pass(`Selected Second Rule Associate Cylinders: ${cylinders.join(', ')}`);
    }

    /**
     * Configure Second Rule Adjust Base
     */
    public async configureSecondRuleAdjustBase(days: string, associateTo: string): Promise<void> {
        await TTTFRuleConfigHelper.configureAdjustBase(
            this.page,
            'Second',
            this.secondRuleAdjustBaseCheckbox,
            { days, associateTo }
        );
    }

    /**
     * Configure Second Rule Secondary Adjust Base
     */
    public async configureSecondRuleSecondaryAdjustBase(days: string, associateTo: string): Promise<void> {
        await TTTFRuleConfigHelper.configureSecondaryAdjustBase(
            this.page,
            'Second',
            this.secondRuleSecondaryAdjustBaseCheckbox,
            { days, associateTo }
        );
    }

    /**
     * Configure Second Rule Add to Lookback
     */
    public async configureSecondRuleAddToLookback(days: string, includeWeekends: boolean, includeBorings: boolean): Promise<void> {
        await TTTFRuleConfigHelper.configureAddToLookback(
            this.page,
            'Second',
            this.secondRuleAddToLookbackCheckbox,
            { days, includeWeekends, includeBorings }
        );
    }

    /**
     * Select Second Rule Lookback Associate Cylinders
     */
    public async selectSecondRuleLookbackAssociateCylinders(cylinders: string[]): Promise<void> {
        CSReporter.info(`Selecting Second Rule Lookback Associate Cylinders: ${cylinders.join(', ')}`);

        const selectButton = CSElementFactory.createByXPath(
            '//h5[text()="Second Rule"]/ancestor::section[1]//button[@id="addbuttonSecondRuleLookbackCylinders"]',
            'Second Rule Lookback Associate Cylinders button',
            this.page
        );
        await selectButton.waitForVisible(10000);
        await selectButton.clickWithTimeout(10000);

        // Wait for cylinder popup
        await this.page.waitForTimeout(500);

        // Select each cylinder
        for (const cylinder of cylinders) {
            const cylinderRow = CSElementFactory.createByXPath(
                `//div[contains(@class, 'modal')]//table//td[text()='${cylinder}']/parent::tr//input[@type='checkbox']`,
                `Cylinder checkbox: ${cylinder}`,
                this.page
            );
            const isChecked = await cylinderRow.isChecked();
            if (!isChecked) {
                await cylinderRow.clickWithTimeout(10000);
            }
        }

        // Click Done
        const doneButton = CSElementFactory.createByXPath(
            '//div[contains(@class, "modal")]//button[text()="Done"]',
            'Cylinder Done button',
            this.page
        );
        await doneButton.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);

        CSReporter.pass(`Selected Second Rule Lookback Associate Cylinders: ${cylinders.join(', ')}`);
    }

    // ===================================================================
    // OTHER RULES METHODS
    // ===================================================================

    /**
     * Select Rounding Logic from dropdown
     */
    public async selectRoundingLogic(roundingType: string): Promise<void> {
        CSReporter.info(`Selecting Rounding Logic: ${roundingType}`);

        await this.roundingLogicDropdown.waitForVisible(10000);
        await this.roundingLogicDropdown.clickWithTimeout(10000);

        // Wait for dropdown list
        const dropdownList = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon") and @name="roundingType"]//ul[@role="listbox"]',
            'Rounding Logic dropdown list',
            this.page
        );
        await dropdownList.waitForVisible(10000);

        // Click option
        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='roundingType']//ul[@role='listbox']//li[@role='option']//span[text()='${roundingType}']/parent::span`,
            `Rounding Logic option: ${roundingType}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        CSReporter.pass(`Selected Rounding Logic: ${roundingType}`);
    }

    /**
     * Select Rounding Factor from dropdown
     */
    public async selectRoundingFactor(roundingFactor: string): Promise<void> {
        CSReporter.info(`Selecting Rounding Factor: ${roundingFactor}`);

        await this.roundingFactorDropdown.waitForVisible(10000);
        await this.roundingFactorDropdown.clickWithTimeout(10000);

        // Wait for dropdown list
        const dropdownList = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon") and @name="roundingFactor"]//ul[@role="listbox"]',
            'Rounding Factor dropdown list',
            this.page
        );
        await dropdownList.waitForVisible(10000);

        // Click option
        const option = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='roundingFactor']//ul[@role='listbox']//li[@role='option']//span[text()='${roundingFactor}']/parent::span`,
            `Rounding Factor option: ${roundingFactor}`,
            this.page
        );
        await option.waitForVisible(10000);
        await option.clickWithTimeout(10000);

        CSReporter.pass(`Selected Rounding Factor: ${roundingFactor}`);
    }

    // ===================================================================
    // SAVE/CANCEL METHODS
    // ===================================================================

    /**
     * Click Save button
     */
    public async clickSaveButton(): Promise<void> {
        CSReporter.info('Clicking Save button');
        await this.saveButton.waitForVisible(10000);
        await this.saveButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        CSReporter.pass('Clicked Save button');
    }

    /**
     * Click Cancel button
     */
    public async clickCancelButton(): Promise<void> {
        CSReporter.info('Clicking Cancel button');
        await this.cancelButton.waitForVisible(10000);
        await this.cancelButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        CSReporter.pass('Clicked Cancel button');
    }

    /**
     * Check if duplicate error message is displayed
     */
    public async isDuplicateErrorDisplayed(): Promise<boolean> {
        CSReporter.info('Checking for duplicate error message');
        const isVisible = await this.duplicateErrorMessage.isVisibleWithTimeout(5000);
        if (isVisible) {
            CSReporter.info('Duplicate error message is displayed');
        }
        return isVisible;
    }

    /**
     * Verify Save button is enabled
     */
    public async verifySaveButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Save button is enabled');
        await this.saveButton.waitForVisible(10000);
        const isEnabled = await this.saveButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Save button is not enabled');
        }
        CSReporter.pass('Save button is enabled');
    }

    /**
     * Verify Cancel button is enabled
     */
    public async verifyCancelButtonEnabled(): Promise<void> {
        CSReporter.info('Verifying Cancel button is enabled');
        await this.cancelButton.waitForVisible(10000);
        const isEnabled = await this.cancelButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Cancel button is not enabled');
        }
        CSReporter.pass('Cancel button is enabled');
    }

    // ===================================================================
    // MMTE START DATE DETERMINATION RULE VERIFICATION METHODS (RR04)
    // ===================================================================

    /**
     * Verify Mmte Start Date Determination Rule section is present
     */
    public async verifyMmteStartDateDeterminationRuleSectionPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte Start Date Determination Rule section is present');
        await this.mmteStartDateDeterminationRuleSection.waitForVisible(10000);
        CSReporter.pass('Mmte Start Date Determination Rule section is present');
    }

    /**
     * Expand Mmte Start Date Determination Rule section if collapsed
     */
    public async expandMmteStartDateDeterminationRuleSection(): Promise<void> {
        CSReporter.info('Expanding Mmte Start Date Determination Rule section');
        const isCollapsed = await this.expandMmteStartDateDeterminationRuleButton.isVisibleWithTimeout(2000);
        if (isCollapsed) {
            await this.expandMmteStartDateDeterminationRuleButton.clickWithTimeout(10000);
            await this.page.waitForTimeout(500);
            // Verify collapse button is now present
            await this.collapseMmteStartDateDeterminationRuleButton.waitForVisible(5000);
            CSReporter.pass('Mmte Start Date Determination Rule section expanded successfully');
        } else {
            CSReporter.info('Mmte Start Date Determination Rule section already expanded');
        }
    }

    /**
     * Verify Mmte Start Date Define the Primary Rule info message
     */
    public async verifyMmteStartDatePrimaryRuleInfoMessage(): Promise<void> {
        CSReporter.info('Verifying Mmte Start Date Primary Rule info message');
        await this.mmteStartDatePrimaryRuleInfoMessage.waitForVisible(10000);
        CSReporter.pass('Mmte Start Date Primary Rule info message is present');
    }

    /**
     * Verify Mmte Start Date Month Lag input is present and enabled
     */
    public async verifyMmteStartDateMonthLagInputPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte Start Date Month Lag input');
        await this.mmteStartDateMonthLagInput.waitForVisible(10000);
        const isEnabled = await this.mmteStartDateMonthLagInput.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Mmte Start Date Month Lag input is not enabled');
        }
        CSReporter.pass('Mmte Start Date Month Lag input is present and enabled');
    }

    /**
     * Verify Mmte Start Date Base Day input is present and enabled
     */
    public async verifyMmteStartDateBaseDayInputPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte Start Date Base Day input');
        await this.mmteStartDateBaseDayInput.waitForVisible(10000);
        const isEnabled = await this.mmteStartDateBaseDayInput.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Mmte Start Date Base Day input is not enabled');
        }
        CSReporter.pass('Mmte Start Date Base Day input is present and enabled');
    }

    /**
     * Verify Mmte Start Date Next Kindness Day radio is present and get checked status
     */
    public async verifyMmteStartDateNextKindnessDayRadioPresent(): Promise<boolean> {
        CSReporter.info('Verifying Mmte Start Date Next Kindness Day radio');
        await this.mmteStartDateNextKindnessDayRadio.waitForVisible(10000);
        const isChecked = await this.mmteStartDateNextKindnessDayRadioInput.isCheckedWithTimeout(5000);
        CSReporter.info(`Mmte Start Date Next Kindness Day radio checked: ${isChecked}`);
        return isChecked;
    }

    /**
     * Verify Mmte Start Date Previous Kindness Day radio is present and get checked status
     */
    public async verifyMmteStartDatePreviousKindnessDayRadioPresent(): Promise<boolean> {
        CSReporter.info('Verifying Mmte Start Date Previous Kindness Day radio');
        await this.mmteStartDatePreviousKindnessDayRadio.waitForVisible(10000);
        const isChecked = await this.mmteStartDatePreviousKindnessDayRadioInput.isCheckedWithTimeout(5000);
        CSReporter.info(`Mmte Start Date Previous Kindness Day radio checked: ${isChecked}`);
        return isChecked;
    }

    /**
     * Click Mmte Start Date Previous Kindness Day radio
     */
    public async clickMmteStartDatePreviousKindnessDayRadio(): Promise<void> {
        CSReporter.info('Clicking Mmte Start Date Previous Kindness Day radio');
        await this.mmteStartDatePreviousKindnessDayRadio.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);
        CSReporter.pass('Clicked Mmte Start Date Previous Kindness Day radio');
    }

    /**
     * Verify Mmte Start Date Adjust to Last Kindness Day checkbox is present
     */
    public async verifyMmteStartDateAdjustToLastBusDayCheckboxPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte Start Date Adjust to Last Kindness Day checkbox');
        await this.mmteStartDateAdjustToLastBusDayCheckbox.waitForVisible(10000);
        CSReporter.pass('Mmte Start Date Adjust to Last Kindness Day checkbox is present');
    }

    /**
     * Get Mmte Start Date Adjust to Last Kindness Day checkbox aria-disabled property
     */
    public async getMmteStartDateAdjustToLastBusDayDisabledState(): Promise<boolean> {
        const ariaDisabled = await this.mmteStartDateAdjustToLastBusDayCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'true';
    }

    /**
     * Verify Mmte Start Date Associate Cylinders button is present
     */
    public async verifyMmteStartDateAssociateCylindersButtonPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte Start Date Associate Cylinders button');
        await this.mmteStartDateAssociateCylindersButton.waitForVisible(10000);
        CSReporter.pass('Mmte Start Date Associate Cylinders button is present');
    }

    /**
     * Verify Mmte Start Date Adjust Base checkbox is present
     */
    public async verifyMmteStartDateAdjustBaseCheckboxPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte Start Date Adjust Base checkbox');
        await this.mmteStartDateAdjustBaseCheckbox.waitForVisible(10000);
        CSReporter.pass('Mmte Start Date Adjust Base checkbox is present');
    }

    /**
     * Click Mmte Start Date Adjust Base checkbox
     */
    public async clickMmteStartDateAdjustBaseCheckbox(): Promise<void> {
        CSReporter.info('Clicking Mmte Start Date Adjust Base checkbox');
        await this.mmteStartDateAdjustBaseCheckbox.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);
        CSReporter.pass('Clicked Mmte Start Date Adjust Base checkbox');
    }

    /**
     * Verify Mmte Start Date Adjust Base Days input state
     */
    public async verifyMmteStartDateAdjustBaseDaysInputState(expectedEnabled: boolean): Promise<void> {
        CSReporter.info(`Verifying Mmte Start Date Adjust Base Days input is ${expectedEnabled ? 'enabled' : 'disabled'}`);
        await this.mmteStartDateAdjustBaseDaysInput.waitForVisible(10000);
        const isEnabled = await this.mmteStartDateAdjustBaseDaysInput.isEnabledWithTimeout(5000);
        if (isEnabled !== expectedEnabled) {
            throw new Error(`Mmte Start Date Adjust Base Days input expected ${expectedEnabled ? 'enabled' : 'disabled'} but was ${isEnabled ? 'enabled' : 'disabled'}`);
        }
        CSReporter.pass(`Mmte Start Date Adjust Base Days input is ${expectedEnabled ? 'enabled' : 'disabled'}`);
    }

    /**
     * Verify Mmte Start Date Secondary Adjust Base checkbox is present
     */
    public async verifyMmteStartDateSecondaryAdjustBaseCheckboxPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte Start Date Secondary Adjust Base checkbox');
        await this.mmteStartDateSecondaryAdjustBaseCheckbox.waitForVisible(10000);
        CSReporter.pass('Mmte Start Date Secondary Adjust Base checkbox is present');
    }

    /**
     * Click Mmte Start Date Secondary Adjust Base checkbox
     */
    public async clickMmteStartDateSecondaryAdjustBaseCheckbox(): Promise<void> {
        CSReporter.info('Clicking Mmte Start Date Secondary Adjust Base checkbox');
        await this.mmteStartDateSecondaryAdjustBaseCheckbox.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);
        CSReporter.pass('Clicked Mmte Start Date Secondary Adjust Base checkbox');
    }

    /**
     * Verify Mmte Start Date Add to Lookback checkbox is present
     */
    public async verifyMmteStartDateAddToLookbackCheckboxPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte Start Date Add to Lookback checkbox');
        await this.mmteStartDateAddToLookbackCheckbox.waitForVisible(10000);
        CSReporter.pass('Mmte Start Date Add to Lookback checkbox is present');
    }

    /**
     * Click Mmte Start Date Add to Lookback checkbox
     */
    public async clickMmteStartDateAddToLookbackCheckbox(): Promise<void> {
        CSReporter.info('Clicking Mmte Start Date Add to Lookback checkbox');
        await this.mmteStartDateAddToLookbackCheckbox.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);
        CSReporter.pass('Clicked Mmte Start Date Add to Lookback checkbox');
    }

    /**
     * Verify Mmte Start Date Lookback Days input state
     */
    public async verifyMmteStartDateLookbackDaysInputState(expectedEnabled: boolean): Promise<void> {
        CSReporter.info(`Verifying Mmte Start Date Lookback Days input is ${expectedEnabled ? 'enabled' : 'disabled'}`);
        await this.mmteStartDateLookbackDaysInput.waitForVisible(10000);
        const isEnabled = await this.mmteStartDateLookbackDaysInput.isEnabledWithTimeout(5000);
        if (isEnabled !== expectedEnabled) {
            throw new Error(`Mmte Start Date Lookback Days input expected ${expectedEnabled ? 'enabled' : 'disabled'} but was ${isEnabled ? 'enabled' : 'disabled'}`);
        }
        CSReporter.pass(`Mmte Start Date Lookback Days input is ${expectedEnabled ? 'enabled' : 'disabled'}`);
    }

    // ===================================================================
    // MMTE END DATE DETERMINATION RULE VERIFICATION METHODS (RR04)
    // ===================================================================

    /**
     * Verify Mmte End Date Determination Rule section is present
     */
    public async verifyMmteEndDateDeterminationRuleSectionPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Determination Rule section is present');
        await this.mmteEndDateDeterminationRuleSection.waitForVisible(10000);
        CSReporter.pass('Mmte End Date Determination Rule section is present');
    }

    /**
     * Expand Mmte End Date Determination Rule section if collapsed
     */
    public async expandMmteEndDateDeterminationRuleSection(): Promise<void> {
        CSReporter.info('Expanding Mmte End Date Determination Rule section');
        const isCollapsed = await this.expandMmteEndDateDeterminationRuleButton.isVisibleWithTimeout(2000);
        if (isCollapsed) {
            await this.expandMmteEndDateDeterminationRuleButton.clickWithTimeout(10000);
            await this.page.waitForTimeout(500);
            // Verify collapse button is now present
            await this.collapseMmteEndDateDeterminationRuleButton.waitForVisible(5000);
            CSReporter.pass('Mmte End Date Determination Rule section expanded successfully');
        } else {
            CSReporter.info('Mmte End Date Determination Rule section already expanded');
        }
    }

    /**
     * Verify Mmte End Date Second Rule info message
     */
    public async verifyMmteEndDateSecondRuleInfoMessage(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Second Rule info message');
        await this.mmteEndDateSecondRuleInfoMessage.waitForVisible(10000);
        CSReporter.pass('Mmte End Date Second Rule info message is present');
    }

    /**
     * Verify Mmte End Date Month Lag input is present and enabled
     */
    public async verifyMmteEndDateMonthLagInputPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Month Lag input');
        await this.mmteEndDateMonthLagInput.waitForVisible(10000);
        const isEnabled = await this.mmteEndDateMonthLagInput.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Mmte End Date Month Lag input is not enabled');
        }
        CSReporter.pass('Mmte End Date Month Lag input is present and enabled');
    }

    /**
     * Verify Mmte End Date Base Day input is present and enabled
     */
    public async verifyMmteEndDateBaseDayInputPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Base Day input');
        await this.mmteEndDateBaseDayInput.waitForVisible(10000);
        const isEnabled = await this.mmteEndDateBaseDayInput.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Mmte End Date Base Day input is not enabled');
        }
        CSReporter.pass('Mmte End Date Base Day input is present and enabled');
    }

    /**
     * Verify Mmte End Date Next Kindness Day radio is present and get checked status
     */
    public async verifyMmteEndDateNextKindnessDayRadioPresent(): Promise<boolean> {
        CSReporter.info('Verifying Mmte End Date Next Kindness Day radio');
        await this.mmteEndDateNextKindnessDayRadio.waitForVisible(10000);
        const isChecked = await this.mmteEndDateNextKindnessDayRadioInput.isCheckedWithTimeout(5000);
        CSReporter.info(`Mmte End Date Next Kindness Day radio checked: ${isChecked}`);
        return isChecked;
    }

    /**
     * Verify Mmte End Date Previous Kindness Day radio is present and get checked status
     */
    public async verifyMmteEndDatePreviousKindnessDayRadioPresent(): Promise<boolean> {
        CSReporter.info('Verifying Mmte End Date Previous Kindness Day radio');
        await this.mmteEndDatePreviousKindnessDayRadio.waitForVisible(10000);
        const isChecked = await this.mmteEndDatePreviousKindnessDayRadioInput.isCheckedWithTimeout(5000);
        CSReporter.info(`Mmte End Date Previous Kindness Day radio checked: ${isChecked}`);
        return isChecked;
    }

    /**
     * Click Mmte End Date Previous Kindness Day radio
     */
    public async clickMmteEndDatePreviousKindnessDayRadio(): Promise<void> {
        CSReporter.info('Clicking Mmte End Date Previous Kindness Day radio');
        await this.mmteEndDatePreviousKindnessDayRadio.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);
        CSReporter.pass('Clicked Mmte End Date Previous Kindness Day radio');
    }

    /**
     * Verify Mmte End Date Adjust to Last Kindness Day checkbox is present
     */
    public async verifyMmteEndDateAdjustToLastBusDayCheckboxPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Adjust to Last Kindness Day checkbox');
        await this.mmteEndDateAdjustToLastBusDayCheckbox.waitForVisible(10000);
        CSReporter.pass('Mmte End Date Adjust to Last Kindness Day checkbox is present');
    }

    /**
     * Get Mmte End Date Adjust to Last Kindness Day checkbox aria-disabled property
     */
    public async getMmteEndDateAdjustToLastBusDayDisabledState(): Promise<boolean> {
        const ariaDisabled = await this.mmteEndDateAdjustToLastBusDayCheckbox.getAttributeWithTimeout('aria-disabled', 5000);
        return ariaDisabled === 'true';
    }

    /**
     * Verify Mmte End Date Associate Cylinders button is present
     */
    public async verifyMmteEndDateAssociateCylindersButtonPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Associate Cylinders button');
        await this.mmteEndDateAssociateCylindersButton.waitForVisible(10000);
        CSReporter.pass('Mmte End Date Associate Cylinders button is present');
    }

    /**
     * Verify Mmte End Date Adjust Base checkbox is present
     */
    public async verifyMmteEndDateAdjustBaseCheckboxPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Adjust Base checkbox');
        await this.mmteEndDateAdjustBaseCheckbox.waitForVisible(10000);
        CSReporter.pass('Mmte End Date Adjust Base checkbox is present');
    }

    /**
     * Click Mmte End Date Adjust Base checkbox
     */
    public async clickMmteEndDateAdjustBaseCheckbox(): Promise<void> {
        CSReporter.info('Clicking Mmte End Date Adjust Base checkbox');
        await this.mmteEndDateAdjustBaseCheckbox.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);
        CSReporter.pass('Clicked Mmte End Date Adjust Base checkbox');
    }

    /**
     * Verify Mmte End Date Secondary Adjust Base checkbox is present
     */
    public async verifyMmteEndDateSecondaryAdjustBaseCheckboxPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Secondary Adjust Base checkbox');
        await this.mmteEndDateSecondaryAdjustBaseCheckbox.waitForVisible(10000);
        CSReporter.pass('Mmte End Date Secondary Adjust Base checkbox is present');
    }

    /**
     * Click Mmte End Date Secondary Adjust Base checkbox
     */
    public async clickMmteEndDateSecondaryAdjustBaseCheckbox(): Promise<void> {
        CSReporter.info('Clicking Mmte End Date Secondary Adjust Base checkbox');
        await this.mmteEndDateSecondaryAdjustBaseCheckbox.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);
        CSReporter.pass('Clicked Mmte End Date Secondary Adjust Base checkbox');
    }

    /**
     * Verify Mmte End Date Add to Lookback checkbox is present
     */
    public async verifyMmteEndDateAddToLookbackCheckboxPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Add to Lookback checkbox');
        await this.mmteEndDateAddToLookbackCheckbox.waitForVisible(10000);
        CSReporter.pass('Mmte End Date Add to Lookback checkbox is present');
    }

    /**
     * Click Mmte End Date Add to Lookback checkbox
     */
    public async clickMmteEndDateAddToLookbackCheckbox(): Promise<void> {
        CSReporter.info('Clicking Mmte End Date Add to Lookback checkbox');
        await this.mmteEndDateAddToLookbackCheckbox.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);
        CSReporter.pass('Clicked Mmte End Date Add to Lookback checkbox');
    }

    /**
     * Verify Mmte End Date Add Lockout checkbox is present
     */
    public async verifyMmteEndDateAddLockoutCheckboxPresent(): Promise<void> {
        CSReporter.info('Verifying Mmte End Date Add Lockout checkbox');
        await this.mmteEndDateAddLockoutCheckbox.waitForVisible(10000);
        CSReporter.pass('Mmte End Date Add Lockout checkbox is present');
    }

    /**
     * Click Mmte End Date Add Lockout checkbox
     */
    public async clickMmteEndDateAddLockoutCheckbox(): Promise<void> {
        CSReporter.info('Clicking Mmte End Date Add Lockout checkbox');
        await this.mmteEndDateAddLockoutCheckbox.clickWithTimeout(10000);
        await this.page.waitForTimeout(300);
        CSReporter.pass('Clicked Mmte End Date Add Lockout checkbox');
    }

    /**
     * Verify Mmte End Date Lockout Days input state
     */
    public async verifyMmteEndDateLockoutDaysInputState(expectedEnabled: boolean): Promise<void> {
        CSReporter.info(`Verifying Mmte End Date Lockout Days input is ${expectedEnabled ? 'enabled' : 'disabled'}`);
        await this.mmteEndDateLockoutDaysInput.waitForVisible(10000);
        const isEnabled = await this.mmteEndDateLockoutDaysInput.isEnabledWithTimeout(5000);
        if (isEnabled !== expectedEnabled) {
            throw new Error(`Mmte End Date Lockout Days input expected ${expectedEnabled ? 'enabled' : 'disabled'} but was ${isEnabled ? 'enabled' : 'disabled'}`);
        }
        CSReporter.pass(`Mmte End Date Lockout Days input is ${expectedEnabled ? 'enabled' : 'disabled'}`);
    }

    /**
     * Select and verify cylinder from Mmte Start Date Associate Cylinders popup
     */
    public async selectMmteStartDateAssociateCylinders(cylinders: string[]): Promise<void> {
        CSReporter.info(`Selecting Mmte Start Date Associate Cylinders: ${cylinders.join(', ')}`);

        // Click Select/Edit button
        await this.mmteStartDateAssociateCylindersButton.waitForVisible(10000);
        await this.mmteStartDateAssociateCylindersButton.clickWithTimeout(10000);

        // Wait for popup
        await this.addCylinderPopup.waitForVisible(10000);

        // Select each cylinder
        for (const cylinder of cylinders) {
            const cylinderCheckbox = CSElementFactory.createByXPath(
                `//div[@class='sssss-panel__content-wrapper']//div[@class='sssss-panel__body']//table[@class='sssss-table']/tbody//td/div[text()='${cylinder}']/ancestor::tr[1]/td[1]//span[@role='checkbox']`,
                `Cylinder checkbox: ${cylinder}`,
                this.page
            );

            const ariaChecked = await cylinderCheckbox.getAttributeWithTimeout('aria-checked', 5000);
            if (ariaChecked !== 'true') {
                await cylinderCheckbox.clickWithTimeout(10000);
                await this.page.waitForTimeout(200);
            }
        }

        // Click Apply
        await this.cylinderPopupApplyButton.waitForVisible(10000);
        await this.cylinderPopupApplyButton.clickWithTimeout(10000);

        // Wait for popup to close
        await this.addCylinderPopup.waitForDetached(10000);

        CSReporter.pass(`Selected Mmte Start Date Associate Cylinders: ${cylinders.join(', ')}`);
    }

    /**
     * Verify selected cylinder is displayed next to Associate Cylinders button (Mmte Start Date)
     */
    public async verifyMmteStartDateSelectedCylinderDisplayed(cylinder: string): Promise<void> {
        CSReporter.info(`Verifying selected cylinder displayed: ${cylinder}`);
        // Fixed: pCalender -> pCylinder (typo fix)
        const cylinderLabel = CSElementFactory.createByXPath(
            `//h5[text()='Mmte Start Date Determination Rule']/ancestor::section[1]//button[@id='addbuttonFirstRuleBaseCylinders']/ancestor::div[contains(@class, 'sssss-row')][1]//p[@id='pCylinder']/span[text()='${cylinder}']`,
            `Selected cylinder: ${cylinder}`,
            this.page
        );
        await cylinderLabel.waitForVisible(10000);
        CSReporter.pass(`Selected cylinder ${cylinder} is displayed`);
    }

    /**
     * Verify borings link is displayed next to selected cylinder (Mmte Start Date)
     */
    public async verifyMmteStartDateBoringsLinkDisplayed(cylinder: string): Promise<void> {
        CSReporter.info(`Verifying borings link for cylinder: ${cylinder}`);
        // Fixed: pCalender -> pCylinder (typo fix)
        const boringsLink = CSElementFactory.createByXPath(
            `//h5[text()='Mmte Start Date Determination Rule']/ancestor::section[1]//button[@id='addbuttonFirstRuleBaseCylinders']/ancestor::div[contains(@class, 'sssss-row')][1]//p[@id='pCylinder']/span[text()='${cylinder}']/following-sibling::a[text()='borings'][1]`,
            `Borings link for ${cylinder}`,
            this.page
        );
        await boringsLink.waitForVisible(10000);
        CSReporter.pass(`Borings link for ${cylinder} is displayed`);
    }

    /**
     * Verify Edit button is displayed instead of Select after cylinder selection (Mmte Start Date)
     */
    public async verifyMmteStartDateEditButtonDisplayed(): Promise<void> {
        CSReporter.info('Verifying Edit button is displayed for Mmte Start Date cylinders');
        const editButton = CSElementFactory.createByXPath(
            `//h5[text()='Mmte Start Date Determination Rule']/ancestor::section[1]//button[@id='addbuttonFirstRuleBaseCylinders']/span[@class='sssss-button__label' and text()='Edit']`,
            'Edit button for Mmte Start Date cylinders',
            this.page
        );
        await editButton.waitForVisible(10000);
        CSReporter.pass('Edit button is displayed for Mmte Start Date cylinders');
    }

    // ===================================================================
    // DROPDOWN LIST VERIFICATION METHODS
    // ===================================================================

    /**
     * Verify Cumulative Scattered dropdown list is visible
     */
    public async verifyCumulativeScatteredDropdownListVisible(): Promise<void> {
        CSReporter.info('Verifying Cumulative Scattered dropdown list is visible');
        const dropdownList = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon__content")]//ul[@role="listbox"]',
            'Cumulative Scattered dropdown list',
            this.page
        );
        await dropdownList.waitForVisible(10000);
        CSReporter.pass('Cumulative Scattered dropdown list is visible');
    }

    /**
     * Verify Method dropdown options (Sport Mmte Look Up and Ttcalc Duration)
     */
    public async verifyMethodDropdownOptions(): Promise<void> {
        CSReporter.info('Verifying Method dropdown options');
        const sportMmteOption = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon__content")]//ul[@role="listbox"]//li[@role="option"]//span[text()="Sport Mmte Look Up"]',
            'Sport Mmte Look Up option',
            this.page
        );
        const calcDurationOption = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon__content")]//ul[@role="listbox"]//li[@role="option"]//span[text()="Ttcalc Duration"]',
            'Ttcalc Duration option',
            this.page
        );
        await sportMmteOption.waitForVisible(5000);
        await calcDurationOption.waitForVisible(5000);
        CSReporter.pass('Method dropdown options verified');
    }

    /**
     * Verify Sport Mmte Rule Priority dropdown options (Highest Date and Lowest Date)
     */
    public async verifySportMmteRulePriorityOptions(): Promise<void> {
        CSReporter.info('Verifying Sport Mmte Rule Priority options');
        const highestOption = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon__content")]//ul[@role="listbox"]//li[@role="option"]//span[text()="Highest Date"]',
            'Highest Date option',
            this.page
        );
        const lowestOption = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon__content")]//ul[@role="listbox"]//li[@role="option"]//span[text()="Lowest Date"]',
            'Lowest Date option',
            this.page
        );
        await highestOption.waitForVisible(5000);
        await lowestOption.waitForVisible(5000);
        CSReporter.pass('Sport Mmte Rule Priority options verified');
    }

    /**
     * Verify Primary Ttcalc dropdown options (Compound and Simple)
     */
    public async verifyPrimaryTtcalcOptions(): Promise<void> {
        CSReporter.info('Verifying Primary Ttcalc options');
        const compoundOption = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon__content")]//ul[@role="listbox"]//li[@role="option"]//span[text()="Compound"]',
            'Compound option',
            this.page
        );
        const simpleOption = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon__content")]//ul[@role="listbox"]//li[@role="option"]//span[text()="Simple"]',
            'Simple option',
            this.page
        );
        await compoundOption.waitForVisible(5000);
        await simpleOption.waitForVisible(5000);
        CSReporter.pass('Primary Ttcalc options verified');
    }

    /**
     * Verify Annual Accrual Days dropdown options (360 and 365)
     */
    public async verifyAnnualAccrualDaysOptions(): Promise<void> {
        CSReporter.info('Verifying Annual Accrual Days options');
        const option360 = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon__content")]//ul[@role="listbox"]//li[@role="option"]//span[text()="360"]',
            '360 option',
            this.page
        );
        const option365 = CSElementFactory.createByXPath(
            '//div[contains(@class, "sssss-balloon__content")]//ul[@role="listbox"]//li[@role="option"]//span[text()="365"]',
            '365 option',
            this.page
        );
        await option360.waitForVisible(5000);
        await option365.waitForVisible(5000);
        CSReporter.pass('Annual Accrual Days options verified');
    }

    /**
     * Press Escape key to close dropdowns
     */
    public async pressEscapeKey(): Promise<void> {
        CSReporter.info('Pressing Escape key');
        await this.page.keyboard.press('Escape');
        await this.page.waitForTimeout(300);
        CSReporter.pass('Pressed Escape key');
    }

    // ===================================================================
    // FIRST RULE CYLINDER VERIFICATION METHODS (RR05 Circles 311-317)
    // ===================================================================

    /**
     * Verify Edit button is displayed instead of Select after cylinder selection (First Rule)
     * XPath from RR05 Circle 312
     */
    public async verifyFirstRuleEditButtonDisplayed(): Promise<void> {
        CSReporter.info('Verifying Edit button is displayed for First Rule cylinders');
        const editButton = CSElementFactory.createByXPath(
            `//h5[text()='First Rule']/ancestor::section[1]//button[@id='addbuttonFirstRuleBaseCylinders']/span[@class='sssss-button__label' and text()='Edit']`,
            'Edit button for First Rule cylinders',
            this.page
        );
        await editButton.waitForVisible(10000);
        CSReporter.pass('Edit button is displayed for First Rule cylinders');
    }

    /**
     * Verify selected cylinder is displayed next to Associate Cylinders button (First Rule)
     * XPath from RR05 Circle 315
     */
    public async verifyFirstRuleSelectedCylinderDisplayed(cylinder: string): Promise<void> {
        CSReporter.info(`Verifying First Rule selected cylinder displayed: ${cylinder}`);
        const cylinderLabel = CSElementFactory.createByXPath(
            `//h5[text()='First Rule']/ancestor::section[1]//button[@id='addbuttonFirstRuleBaseCylinders']/ancestor::div[contains(@class, 'sssss-row')][1]//p[@id='pCalender']/span[text()='${cylinder}']`,
            `First Rule Selected cylinder: ${cylinder}`,
            this.page
        );
        await cylinderLabel.waitForVisible(10000);
        CSReporter.pass(`First Rule selected cylinder '${cylinder}' is displayed`);
    }

    /**
     * Verify borings link is displayed next to selected cylinder (First Rule)
     * XPath from RR05 Circle 317
     */
    public async verifyFirstRuleBoringsLinkDisplayed(cylinder: string): Promise<void> {
        CSReporter.info(`Verifying First Rule borings link for cylinder: ${cylinder}`);
        const boringsLink = CSElementFactory.createByXPath(
            `//h5[text()='First Rule']/ancestor::section[1]//button[@id='addbuttonFirstRuleBaseCylinders']/ancestor::div[contains(@class, 'sssss-row')][1]//p[@id='pCalender']/span[text()='${cylinder}']/following-sibling::a[text()='borings'][1]`,
            `First Rule Borings link for ${cylinder}`,
            this.page
        );
        await boringsLink.waitForVisible(10000);
        CSReporter.pass(`First Rule borings link for '${cylinder}' is displayed`);
    }

    /**
     * Verify all selected cylinders and their borings links (First Rule)
     * Combined verification per RR05 Circles 314-317
     */
    public async verifyFirstRuleSelectedCylindersWithBoringLinks(cylinders: string[]): Promise<void> {
        CSReporter.info(`Verifying First Rule selected cylinders with boring links: ${cylinders.join(', ')}`);

        for (const cylinder of cylinders) {
            await this.verifyFirstRuleSelectedCylinderDisplayed(cylinder);
            await this.verifyFirstRuleBoringsLinkDisplayed(cylinder);
        }

        CSReporter.pass(`All First Rule cylinders verified with boring links: ${cylinders.join(', ')}`);
    }

    // ===================================================================
    // SECOND RULE CYLINDER VERIFICATION METHODS (RR05 Circles 408+)
    // ===================================================================

    /**
     * Verify Edit button is displayed instead of Select after cylinder selection (Second Rule)
     */
    public async verifySecondRuleEditButtonDisplayed(): Promise<void> {
        CSReporter.info('Verifying Edit button is displayed for Second Rule cylinders');
        const editButton = CSElementFactory.createByXPath(
            `//h5[text()='Second Rule (Optional)']/ancestor::section[1]//button[@id='addbuttonSecondRuleBaseCylinders']/span[@class='sssss-button__label' and text()='Edit']`,
            'Edit button for Second Rule cylinders',
            this.page
        );
        await editButton.waitForVisible(10000);
        CSReporter.pass('Edit button is displayed for Second Rule cylinders');
    }

    /**
     * Verify selected cylinder is displayed next to Associate Cylinders button (Second Rule)
     */
    public async verifySecondRuleSelectedCylinderDisplayed(cylinder: string): Promise<void> {
        CSReporter.info(`Verifying Second Rule selected cylinder displayed: ${cylinder}`);
        const cylinderLabel = CSElementFactory.createByXPath(
            `//h5[text()='Second Rule (Optional)']/ancestor::section[1]//button[@id='addbuttonSecondRuleBaseCylinders']/ancestor::div[contains(@class, 'sssss-row')][1]//p[@id='pCalender']/span[text()='${cylinder}']`,
            `Second Rule Selected cylinder: ${cylinder}`,
            this.page
        );
        await cylinderLabel.waitForVisible(10000);
        CSReporter.pass(`Second Rule selected cylinder '${cylinder}' is displayed`);
    }

    /**
     * Verify borings link is displayed next to selected cylinder (Second Rule)
     */
    public async verifySecondRuleBoringsLinkDisplayed(cylinder: string): Promise<void> {
        CSReporter.info(`Verifying Second Rule borings link for cylinder: ${cylinder}`);
        const boringsLink = CSElementFactory.createByXPath(
            `//h5[text()='Second Rule (Optional)']/ancestor::section[1]//button[@id='addbuttonSecondRuleBaseCylinders']/ancestor::div[contains(@class, 'sssss-row')][1]//p[@id='pCalender']/span[text()='${cylinder}']/following-sibling::a[text()='borings'][1]`,
            `Second Rule Borings link for ${cylinder}`,
            this.page
        );
        await boringsLink.waitForVisible(10000);
        CSReporter.pass(`Second Rule borings link for '${cylinder}' is displayed`);
    }

    /**
     * Verify all selected cylinders and their borings links (Second Rule)
     */
    public async verifySecondRuleSelectedCylindersWithBoringLinks(cylinders: string[]): Promise<void> {
        CSReporter.info(`Verifying Second Rule selected cylinders with boring links: ${cylinders.join(', ')}`);

        for (const cylinder of cylinders) {
            await this.verifySecondRuleSelectedCylinderDisplayed(cylinder);
            await this.verifySecondRuleBoringsLinkDisplayed(cylinder);
        }

        CSReporter.pass(`All Second Rule cylinders verified with boring links: ${cylinders.join(', ')}`);
    }

    // ===================================================================
    // FIRST RULE LOOKBACK CYLINDER VERIFICATION METHODS (RR05 Circles 398+)
    // ===================================================================

    /**
     * Verify Edit button is displayed for First Rule Lookback Cylinders
     */
    public async verifyFirstRuleLookbackEditButtonDisplayed(): Promise<void> {
        CSReporter.info('Verifying Edit button is displayed for First Rule Lookback cylinders');
        const editButton = CSElementFactory.createByXPath(
            `//h5[text()='First Rule']/ancestor::section[1]//button[@id='addbuttonFirstRuleLookbackCylinders']/span[@class='sssss-button__label' and text()='Edit']`,
            'Edit button for First Rule Lookback cylinders',
            this.page
        );
        await editButton.waitForVisible(10000);
        CSReporter.pass('Edit button is displayed for First Rule Lookback cylinders');
    }

    /**
     * Verify selected cylinder is displayed for First Rule Lookback
     */
    public async verifyFirstRuleLookbackSelectedCylinderDisplayed(cylinder: string): Promise<void> {
        CSReporter.info(`Verifying First Rule Lookback selected cylinder displayed: ${cylinder}`);
        const cylinderLabel = CSElementFactory.createByXPath(
            `//h5[text()='First Rule']/ancestor::section[1]//button[@id='addbuttonFirstRuleLookbackCylinders']/ancestor::div[contains(@class, 'sssss-row')][1]//p[@id='pCalender']/span[text()='${cylinder}']`,
            `First Rule Lookback Selected cylinder: ${cylinder}`,
            this.page
        );
        await cylinderLabel.waitForVisible(10000);
        CSReporter.pass(`First Rule Lookback selected cylinder '${cylinder}' is displayed`);
    }

    /**
     * Verify borings link for First Rule Lookback cylinder
     */
    public async verifyFirstRuleLookbackBoringsLinkDisplayed(cylinder: string): Promise<void> {
        CSReporter.info(`Verifying First Rule Lookback borings link for cylinder: ${cylinder}`);
        const boringsLink = CSElementFactory.createByXPath(
            `//h5[text()='First Rule']/ancestor::section[1]//button[@id='addbuttonFirstRuleLookbackCylinders']/ancestor::div[contains(@class, 'sssss-row')][1]//p[@id='pCalender']/span[text()='${cylinder}']/following-sibling::a[text()='borings'][1]`,
            `First Rule Lookback Borings link for ${cylinder}`,
            this.page
        );
        await boringsLink.waitForVisible(10000);
        CSReporter.pass(`First Rule Lookback borings link for '${cylinder}' is displayed`);
    }
}

export default TTTFAddScatteredMmtePage;

