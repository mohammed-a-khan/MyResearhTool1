package com.cstestforge.service.action;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSTextUtils;
import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.model.action.ActionConfig;
import com.cstestforge.model.action.ActionType;
import com.cstestforge.model.action.AssertionActionConfig;
import com.cstestforge.model.action.ConditionalActionConfig;
import com.cstestforge.model.action.CustomActionConfig;
import com.cstestforge.model.action.DataProviderActionConfig;
import com.cstestforge.model.action.LoopActionConfig;
import com.cstestforge.model.action.WaitActionConfig;
import com.cstestforge.model.project.FrameworkType;
import com.cstestforge.model.project.LanguageType;
import com.cstestforge.model.project.TestType;
import com.cstestforge.service.storage.FileSystemStorageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Implementation of the ActionService interface.
 * This class provides functionality for action operations.
 */
@Service
public class ActionServiceImpl implements ActionService {

    private static final CSLogger LOGGER = CSLogger.getLogger(ActionServiceImpl.class);
    
    private final FileSystemStorageService storageService;
    private final Map<String, ActionConfig> templateCache = new HashMap<>();
    private final ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
    
    // Directory for storing action templates
    private final String templatesDirectory;
    
    @Autowired
    public ActionServiceImpl(FileSystemStorageService storageService) {
        this.storageService = storageService;
        
        // Get templates directory from configuration or use default
        ConfigurationManager configManager = ConfigurationManager.getInstance();
        this.templatesDirectory = configManager.getStringConfig("framework.templates.directory", 
                System.getProperty("user.dir") + File.separator + "templates" + File.separator + "actions");
        
        // Ensure templates directory exists
        createTemplatesDirectory();
        
        // Load templates into cache
        loadTemplates();
    }
    
    /**
     * Create templates directory if it doesn't exist.
     */
    private void createTemplatesDirectory() {
        try {
            Path templatesPath = Paths.get(templatesDirectory);
            if (!Files.exists(templatesPath)) {
                Files.createDirectories(templatesPath);
                LOGGER.info("Created templates directory: {}", templatesDirectory);
            }
        } catch (IOException e) {
            LOGGER.error("Failed to create templates directory: {}", templatesDirectory, e);
        }
    }
    
    /**
     * Load templates into cache.
     */
    private void loadTemplates() {
        try {
            Path templatesPath = Paths.get(templatesDirectory);
            if (!Files.exists(templatesPath)) {
                return;
            }
            
            Files.walk(templatesPath)
                    .filter(path -> path.toString().endsWith(".json"))
                    .forEach(path -> {
                        try {
                            ActionConfig template = storageService.loadObject(path.toString(), ActionConfig.class, null);
                            if (template != null) {
                                templateCache.put(template.getId(), template);
                                LOGGER.debug("Loaded template: {}", template.getTemplateName());
                            }
                        } catch (Exception e) {
                            LOGGER.error("Failed to load template from {}: {}", path, e.getMessage());
                        }
                    });
            
            LOGGER.info("Loaded {} templates", templateCache.size());
        } catch (IOException e) {
            LOGGER.error("Failed to load templates", e);
        }
    }
    
    @Override
    public List<ActionType> getSupportedActionTypes(
            FrameworkType frameworkType, LanguageType languageType, TestType testType) {
        
        LOGGER.debug("Getting supported action types for framework: {}, language: {}, test type: {}", 
                frameworkType, languageType, testType);
        
        // All action types are supported by default
        List<ActionType> actionTypes = new ArrayList<>(Arrays.asList(ActionType.values()));
        
        // Filter action types based on framework, language, and test type
        if (frameworkType != null) {
            if (frameworkType == FrameworkType.SELENIUM) {
                // Remove Playwright-specific action types
                // Currently, all action types are supported by both frameworks
            } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                // Remove Selenium-specific action types
                // Currently, all action types are supported by both frameworks
            }
        }
        
        if (languageType != null) {
            if (languageType == LanguageType.JAVA) {
                // Remove TypeScript-specific action types
                // Currently, all action types are supported by both languages
            } else if (languageType == LanguageType.TYPESCRIPT) {
                // Remove Java-specific action types
                // Currently, all action types are supported by both languages
            }
        }
        
        if (testType != null) {
            if (testType == TestType.TESTNG) {
                // Remove BDD-specific action types
                // Currently, all action types are supported by both test types
            } else if (testType == TestType.BDD) {
                // Remove TestNG-specific action types
                // Currently, all action types are supported by both test types
            }
        }
        
        return actionTypes;
    }
    
    @Override
    public Map<String, Object> getActionConfigSchema(ActionType actionType) {
        LOGGER.debug("Getting action schema for action type: {}", actionType);
        
        Map<String, Object> schema = new LinkedHashMap<>();
        
        // Common properties for all action types
        schema.put("id", Map.of("type", "string", "description", "Unique identifier for the action"));
        schema.put("actionType", Map.of("type", "enum", "enum", Arrays.stream(ActionType.values()).map(Enum::name).toArray(), "description", "Type of action"));
        schema.put("name", Map.of("type", "string", "description", "Display name for the action"));
        schema.put("description", Map.of("type", "string", "description", "Description of the action"));
        schema.put("enabled", Map.of("type", "boolean", "default", true, "description", "Whether the action is enabled"));
        
        // Action type specific properties
        switch (actionType) {
            case CLICK:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before clicking"));
                break;
                
            case TYPE:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("text", Map.of("type", "string", "description", "Text to type"));
                schema.put("clearBefore", Map.of("type", "boolean", "default", true, "description", "Whether to clear the field before typing"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before typing"));
                break;
                
            case SELECT:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("option", Map.of("type", "string", "description", "Option to select"));
                schema.put("selectBy", Map.of("type", "enum", "enum", new String[]{"TEXT", "VALUE", "INDEX"}, "description", "How to select the option"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before selecting"));
                break;
                
            case ASSERT:
                schema.put("assertionType", Map.of("type", "string", "description", "Type of assertion"));
                schema.put("locator", Map.of("type", "string", "description", "Element locator (if applicable)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (if applicable)"));
                schema.put("expectedValue", Map.of("type", "string", "description", "Expected value for the assertion"));
                schema.put("actualValue", Map.of("type", "string", "description", "Actual value for the assertion (variable or expression)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("failOnAssertionError", Map.of("type", "boolean", "default", true, "description", "Whether to fail the test on assertion error"));
                break;
                
            case WAIT:
                schema.put("waitType", Map.of("type", "string", "description", "Type of wait"));
                schema.put("locator", Map.of("type", "string", "description", "Element locator (if applicable)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (if applicable)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("condition", Map.of("type", "string", "description", "Condition to wait for (if applicable)"));
                schema.put("pollingInterval", Map.of("type", "integer", "default", 500, "description", "Polling interval in milliseconds"));
                break;
                
            case NAVIGATE:
                schema.put("url", Map.of("type", "string", "description", "URL to navigate to"));
                schema.put("waitForLoad", Map.of("type", "boolean", "default", true, "description", "Whether to wait for page load"));
                schema.put("timeout", Map.of("type", "integer", "default", 60, "description", "Timeout in seconds"));
                break;
                
            case CONDITIONAL:
                schema.put("condition", Map.of("type", "string", "description", "Condition expression"));
                schema.put("operator", Map.of("type", "string", "description", "Conditional operator"));
                schema.put("leftOperand", Map.of("type", "string", "description", "Left operand (variable, expression, or literal)"));
                schema.put("rightOperand", Map.of("type", "string", "description", "Right operand (variable, expression, or literal)"));
                schema.put("nestedActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute if condition is true"));
                schema.put("elseActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute if condition is false"));
                break;
                
            case LOOP:
                schema.put("loopType", Map.of("type", "string", "description", "Type of loop"));
                schema.put("times", Map.of("type", "integer", "description", "Number of times to loop (for 'times' loop type)"));
                schema.put("collection", Map.of("type", "string", "description", "Collection to iterate over (for 'foreach' loop type)"));
                schema.put("variableName", Map.of("type", "string", "description", "Variable name for loop item (for 'foreach' loop type)"));
                schema.put("initExpression", Map.of("type", "string", "description", "Initialization expression (for 'for' loop type)"));
                schema.put("conditionExpression", Map.of("type", "string", "description", "Condition expression (for 'for' and 'while' loop types)"));
                schema.put("incrementExpression", Map.of("type", "string", "description", "Increment expression (for 'for' loop type)"));
                schema.put("nestedActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute in the loop"));
                break;
                
            case DATA_PROVIDER:
                schema.put("dataSourceType", Map.of("type", "string", "description", "Type of data source"));
                schema.put("dataSourcePath", Map.of("type", "string", "description", "Path to the data source"));
                schema.put("sheetName", Map.of("type", "string", "description", "Sheet name (for Excel data source)"));
                schema.put("delimiter", Map.of("type", "string", "default", ",", "description", "Delimiter (for CSV data source)"));
                schema.put("headers", Map.of("type", "boolean", "default", true, "description", "Whether the data has headers"));
                schema.put("parameters", Map.of("type", "array", "items", Map.of("type", "string", "description", "Parameter name"), "description", "Parameter names for the data provider"));
                schema.put("iterationActions", Map.of("type", "array", "items", Map.of("type", "object", "description", "Action configuration"), "description", "Actions to execute for each data iteration"));
                break;
                
            case CUSTOM:
                schema.put("scriptType", Map.of("type", "string", "description", "Type of script"));
                schema.put("script", Map.of("type", "string", "description", "Script content"));
                schema.put("parameters", Map.of("type", "array", "items", Map.of("type", "object", "properties", Map.of(
                        "name", Map.of("type", "string", "description", "Parameter name"),
                        "value", Map.of("type", "string", "description", "Parameter value")
                )), "description", "Script parameters"));
                break;
                
            case VARIABLE:
                schema.put("variableName", Map.of("type", "string", "description", "Name of the variable"));
                schema.put("variableType", Map.of("type", "string", "description", "Type of the variable"));
                schema.put("value", Map.of("type", "string", "description", "Value of the variable"));
                schema.put("scope", Map.of("type", "string", "description", "Scope of the variable"));
                break;
                
            case SCREENSHOT:
                schema.put("fileName", Map.of("type", "string", "description", "Name of the screenshot file"));
                schema.put("element", Map.of("type", "string", "description", "Element locator (for element screenshot, optional)"));
                schema.put("fullPage", Map.of("type", "boolean", "default", false, "description", "Whether to capture full page"));
                schema.put("directory", Map.of("type", "string", "description", "Directory to save the screenshot (optional)"));
                break;
                
            case HOVER:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before hovering"));
                break;
                
            case DRAG_DROP:
                schema.put("sourceLocator", Map.of("type", "string", "description", "Source element locator"));
                schema.put("sourceLocatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of source locator"));
                schema.put("targetLocator", Map.of("type", "string", "description", "Target element locator"));
                schema.put("targetLocatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of target locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElements", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the elements before drag and drop"));
                break;
                
            case SWITCH_FRAME:
                schema.put("frameLocator", Map.of("type", "string", "description", "Frame locator"));
                schema.put("frameLocatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT", "INDEX"}, "description", "Type of frame locator"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("switchToDefault", Map.of("type", "boolean", "default", false, "description", "Whether to switch to default content instead of a specific frame"));
                schema.put("switchToParent", Map.of("type", "boolean", "default", false, "description", "Whether to switch to parent frame instead of a specific frame"));
                break;
                
            case SWITCH_WINDOW:
                schema.put("windowHandle", Map.of("type", "string", "description", "Window handle (optional)"));
                schema.put("windowIndex", Map.of("type", "integer", "description", "Window index (optional)"));
                schema.put("windowTitle", Map.of("type", "string", "description", "Window title (optional)"));
                schema.put("windowUrl", Map.of("type", "string", "description", "Window URL (optional)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                break;
                
            case EXECUTE_SCRIPT:
                schema.put("script", Map.of("type", "string", "description", "JavaScript code to execute"));
                schema.put("arguments", Map.of("type", "array", "items", Map.of("type", "string", "description", "Argument value"), "description", "Script arguments"));
                schema.put("resultVariable", Map.of("type", "string", "description", "Variable to store the result (optional)"));
                break;
                
            case FILE_UPLOAD:
                schema.put("locator", Map.of("type", "string", "description", "Element locator"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator"));
                schema.put("filePath", Map.of("type", "string", "description", "Path to the file to upload"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                schema.put("waitForElement", Map.of("type", "boolean", "default", true, "description", "Whether to wait for the element before uploading"));
                break;
                
            case KEY_PRESS:
                schema.put("locator", Map.of("type", "string", "description", "Element locator (optional)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (optional)"));
                schema.put("key", Map.of("type", "string", "description", "Key to press"));
                schema.put("modifiers", Map.of("type", "array", "items", Map.of("type", "string", "description", "Modifier key"), "description", "Modifier keys (optional)"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                break;
                
            case SCROLL:
                schema.put("locator", Map.of("type", "string", "description", "Element locator (optional)"));
                schema.put("locatorType", Map.of("type", "enum", "enum", new String[]{"CSS", "XPATH", "ID", "NAME", "CLASS_NAME", "TAG_NAME", "LINK_TEXT", "PARTIAL_LINK_TEXT"}, "description", "Type of locator (optional)"));
                schema.put("x", Map.of("type", "integer", "description", "X coordinate (optional)"));
                schema.put("y", Map.of("type", "integer", "description", "Y coordinate (optional)"));
                schema.put("scrollType", Map.of("type", "enum", "enum", new String[]{"PIXEL", "ELEMENT", "TOP", "BOTTOM", "CENTER"}, "description", "Type of scroll"));
                schema.put("timeout", Map.of("type", "integer", "default", 30, "description", "Timeout in seconds"));
                break;
                
            default:
                // Default schema with no additional properties
                break;
        }
        
        return schema;
    }
    
    @Override
    public List<String> validateActionConfig(ActionConfig actionConfig) {
        if (actionConfig == null) {
            return List.of("Action configuration is null");
        }
        
        List<String> errors = new ArrayList<>();
        
        // Validate common properties
        if (actionConfig.getActionType() == null) {
            errors.add("Action type is required");
        }
        
        // Validate action type specific properties
        switch (actionConfig.getActionType()) {
            case CLICK:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for click action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for click action");
                }
                break;
                
            case TYPE:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for type action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for type action");
                }
                if (actionConfig.getProperty("text") == null) {
                    errors.add("Text is required for type action");
                }
                break;
                
            case SELECT:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for select action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for select action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("option"))) {
                    errors.add("Option is required for select action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("selectBy"))) {
                    errors.add("Select by is required for select action");
                }
                break;
                
            case ASSERT:
                AssertionActionConfig assertionConfig = (AssertionActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(assertionConfig.getAssertionType())) {
                    errors.add("Assertion type is required for assert action");
                }
                
                // Validate based on assertion type
                String assertionType = assertionConfig.getAssertionType();
                if (assertionType != null) {
                    if (assertionType.contains("ELEMENT")) {
                        if (CSTextUtils.isNullOrEmpty(assertionConfig.getLocator())) {
                            errors.add("Locator is required for element assertion");
                        }
                        if (CSTextUtils.isNullOrEmpty(assertionConfig.getLocatorType())) {
                            errors.add("Locator type is required for element assertion");
                        }
                    }
                    
                    if (assertionType.contains("EQUALS") || assertionType.contains("CONTAINS") || 
                            assertionType.contains("MATCHES")) {
                        if (assertionConfig.getExpectedValue() == null) {
                            errors.add("Expected value is required for comparison assertion");
                        }
                    }
                }
                break;
                
            case WAIT:
                WaitActionConfig waitConfig = (WaitActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(waitConfig.getWaitType())) {
                    errors.add("Wait type is required for wait action");
                }
                
                // Validate based on wait type
                String waitType = waitConfig.getWaitType();
                if (waitType != null) {
                    if (waitType.contains("ELEMENT")) {
                        if (CSTextUtils.isNullOrEmpty(waitConfig.getLocator())) {
                            errors.add("Locator is required for element wait");
                        }
                        if (CSTextUtils.isNullOrEmpty(waitConfig.getLocatorType())) {
                            errors.add("Locator type is required for element wait");
                        }
                    }
                }
                break;
                
            case NAVIGATE:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("url"))) {
                    errors.add("URL is required for navigate action");
                }
                break;
                
            case CONDITIONAL:
                ConditionalActionConfig conditionalConfig = (ConditionalActionConfig) actionConfig;
                
                if (CSTextUtils.isNullOrEmpty(conditionalConfig.getCondition()) && 
                        (CSTextUtils.isNullOrEmpty(conditionalConfig.getOperator()) || 
                         conditionalConfig.getLeftOperand() == null || 
                         conditionalConfig.getRightOperand() == null)) {
                    errors.add("Either condition or operator with operands is required for conditional action");
                }
                
                if (conditionalConfig.getNestedActions() == null || conditionalConfig.getNestedActions().isEmpty()) {
                    errors.add("Nested actions are required for conditional action");
                }
                break;
                
            case LOOP:
                LoopActionConfig loopConfig = (LoopActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(loopConfig.getLoopType())) {
                    errors.add("Loop type is required for loop action");
                }
                
                // Validate based on loop type
                String loopType = loopConfig.getLoopType();
                if (loopType != null) {
                    if (loopType.equals("TIMES")) {
                        if (loopConfig.getTimes() <= 0) {
                            errors.add("Times must be greater than 0 for times loop");
                        }
                    } else if (loopType.equals("FOREACH")) {
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getCollection())) {
                            errors.add("Collection is required for foreach loop");
                        }
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getVariableName())) {
                            errors.add("Variable name is required for foreach loop");
                        }
                    } else if (loopType.equals("FOR")) {
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getInitExpression())) {
                            errors.add("Init expression is required for for loop");
                        }
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getConditionExpression())) {
                            errors.add("Condition expression is required for for loop");
                        }
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getIncrementExpression())) {
                            errors.add("Increment expression is required for for loop");
                        }
                    } else if (loopType.equals("WHILE")) {
                        if (CSTextUtils.isNullOrEmpty(loopConfig.getConditionExpression())) {
                            errors.add("Condition expression is required for while loop");
                        }
                    }
                }
                
                if (loopConfig.getNestedActions() == null || loopConfig.getNestedActions().isEmpty()) {
                    errors.add("Nested actions are required for loop action");
                }
                break;
                
            case DATA_PROVIDER:
                DataProviderActionConfig dataProviderConfig = (DataProviderActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(dataProviderConfig.getDataSourceType())) {
                    errors.add("Data source type is required for data provider action");
                }
                if (CSTextUtils.isNullOrEmpty(dataProviderConfig.getDataSourcePath())) {
                    errors.add("Data source path is required for data provider action");
                }
                
                // Validate based on data source type
                String dataSourceType = dataProviderConfig.getDataSourceType();
                if (dataSourceType != null) {
                    if (dataSourceType.equals("EXCEL")) {
                        if (CSTextUtils.isNullOrEmpty(dataProviderConfig.getSheetName())) {
                            errors.add("Sheet name is required for Excel data source");
                        }
                    }
                }
                
                if (dataProviderConfig.getParameters() == null || dataProviderConfig.getParameters().isEmpty()) {
                    errors.add("Parameters are required for data provider action");
                }
                
                if (dataProviderConfig.getIterationActions() == null || dataProviderConfig.getIterationActions().isEmpty()) {
                    errors.add("Iteration actions are required for data provider action");
                }
                break;
                
            case CUSTOM:
                CustomActionConfig customConfig = (CustomActionConfig) actionConfig;
                if (CSTextUtils.isNullOrEmpty(customConfig.getScriptType())) {
                    errors.add("Script type is required for custom action");
                }
                if (CSTextUtils.isNullOrEmpty(customConfig.getScript())) {
                    errors.add("Script is required for custom action");
                }
                break;
                
            case VARIABLE:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("variableName"))) {
                    errors.add("Variable name is required for variable action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("variableType"))) {
                    errors.add("Variable type is required for variable action");
                }
                break;
                
            case HOVER:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for hover action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for hover action");
                }
                break;
                
            case DRAG_DROP:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("sourceLocator"))) {
                    errors.add("Source locator is required for drag and drop action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("sourceLocatorType"))) {
                    errors.add("Source locator type is required for drag and drop action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("targetLocator"))) {
                    errors.add("Target locator is required for drag and drop action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("targetLocatorType"))) {
                    errors.add("Target locator type is required for drag and drop action");
                }
                break;
                
            case SWITCH_FRAME:
                if (!Boolean.TRUE.equals(actionConfig.getProperty("switchToDefault")) && 
                        !Boolean.TRUE.equals(actionConfig.getProperty("switchToParent"))) {
                    if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("frameLocator"))) {
                        errors.add("Frame locator is required for switch frame action");
                    }
                    if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("frameLocatorType"))) {
                        errors.add("Frame locator type is required for switch frame action");
                    }
                }
                break;
                
            case SWITCH_WINDOW:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("windowHandle")) && 
                        actionConfig.getProperty("windowIndex") == null && 
                        CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("windowTitle")) && 
                        CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("windowUrl"))) {
                    errors.add("Window handle, index, title, or URL is required for switch window action");
                }
                break;
                
            case EXECUTE_SCRIPT:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("script"))) {
                    errors.add("Script is required for execute script action");
                }
                break;
                
            case FILE_UPLOAD:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locator"))) {
                    errors.add("Locator is required for file upload action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locatorType"))) {
                    errors.add("Locator type is required for file upload action");
                }
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("filePath"))) {
                    errors.add("File path is required for file upload action");
                }
                break;
                
            case KEY_PRESS:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("key"))) {
                    errors.add("Key is required for key press action");
                }
                break;
                
            case SCROLL:
                if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("scrollType"))) {
                    errors.add("Scroll type is required for scroll action");
                }
                
                // Validate based on scroll type
                String scrollType = (String) actionConfig.getProperty("scrollType");
                if (scrollType != null) {
                    if (scrollType.equals("PIXEL")) {
                        if (actionConfig.getProperty("x") == null || actionConfig.getProperty("y") == null) {
                            errors.add("X and Y coordinates are required for pixel scroll");
                        }
                    } else if (scrollType.equals("ELEMENT")) {
                        if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locator"))) {
                            errors.add("Locator is required for element scroll");
                        }
                        if (CSTextUtils.isNullOrEmpty((String)actionConfig.getProperty("locatorType"))) {
                            errors.add("Locator type is required for element scroll");
                        }
                    }
                }
                break;
                
            default:
                // No additional validation
                break;
        }
        
        return errors;
    }
    
    @Override
    public String generateActionCode(ActionConfig actionConfig, FrameworkType frameworkType, 
            LanguageType languageType, TestType testType) {
        
        if (actionConfig == null) {
            return "// Action configuration is null";
        }
        
        StringBuilder code = new StringBuilder();
        
        // Generate code based on framework, language, and test type
        if (languageType == LanguageType.JAVA) {
            generateJavaCode(code, actionConfig, frameworkType, testType);
        } else if (languageType == LanguageType.TYPESCRIPT) {
            generateTypeScriptCode(code, actionConfig, frameworkType, testType);
        } else {
            code.append("// Unsupported language type: ").append(languageType);
        }
        
        return code.toString();
    }
    
    /**
     * Generate Java code for an action configuration.
     *
     * @param code StringBuilder to append code to
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void generateJavaCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        ActionType actionType = actionConfig.getActionType();
        
        switch (actionType) {
            case CLICK:
                generateJavaClickCode(code, actionConfig, frameworkType, testType);
                break;
                
            case TYPE:
                generateJavaTypeCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SELECT:
                generateJavaSelectCode(code, actionConfig, frameworkType, testType);
                break;
                
            case ASSERT:
                generateJavaAssertCode(code, (AssertionActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case WAIT:
                generateJavaWaitCode(code, (WaitActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case NAVIGATE:
                generateJavaNavigateCode(code, actionConfig, frameworkType, testType);
                break;
                
            case CONDITIONAL:
                generateJavaConditionalCode(code, (ConditionalActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case LOOP:
                generateJavaLoopCode(code, (LoopActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case DATA_PROVIDER:
                generateJavaDataProviderCode(code, (DataProviderActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case CUSTOM:
                generateJavaCustomCode(code, (CustomActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case VARIABLE:
                generateJavaVariableCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCREENSHOT:
                generateJavaScreenshotCode(code, actionConfig, frameworkType, testType);
                break;
                
            case HOVER:
                generateJavaHoverCode(code, actionConfig, frameworkType, testType);
                break;
                
            case DRAG_DROP:
                generateJavaDragDropCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_FRAME:
                generateJavaSwitchFrameCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_WINDOW:
                generateJavaSwitchWindowCode(code, actionConfig, frameworkType, testType);
                break;
                
            case EXECUTE_SCRIPT:
                generateJavaExecuteScriptCode(code, actionConfig, frameworkType, testType);
                break;
                
            case FILE_UPLOAD:
                generateJavaFileUploadCode(code, actionConfig, frameworkType, testType);
                break;
                
            case KEY_PRESS:
                generateJavaKeyPressCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCROLL:
                generateJavaScrollCode(code, actionConfig, frameworkType, testType);
                break;
                
            default:
                code.append("// Unsupported action type: ").append(actionType);
                break;
        }
    }
    
    /**
     * Generate TypeScript code for an action configuration.
     *
     * @param code StringBuilder to append code to
     * @param actionConfig Action configuration
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void generateTypeScriptCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        ActionType actionType = actionConfig.getActionType();
        
        switch (actionType) {
            case CLICK:
                generateTypeScriptClickCode(code, actionConfig, frameworkType, testType);
                break;
                
            case TYPE:
                generateTypeScriptTypeCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SELECT:
                generateTypeScriptSelectCode(code, actionConfig, frameworkType, testType);
                break;
                
            case ASSERT:
                generateTypeScriptAssertCode(code, (AssertionActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case WAIT:
                generateTypeScriptWaitCode(code, (WaitActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case NAVIGATE:
                generateTypeScriptNavigateCode(code, actionConfig, frameworkType, testType);
                break;
                
            case CONDITIONAL:
                generateTypeScriptConditionalCode(code, (ConditionalActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case LOOP:
                generateTypeScriptLoopCode(code, (LoopActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case DATA_PROVIDER:
                generateTypeScriptDataProviderCode(code, (DataProviderActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case CUSTOM:
                generateTypeScriptCustomCode(code, (CustomActionConfig) actionConfig, frameworkType, testType);
                break;
                
            case VARIABLE:
                generateTypeScriptVariableCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCREENSHOT:
                generateTypeScriptScreenshotCode(code, actionConfig, frameworkType, testType);
                break;
                
            case HOVER:
                generateTypeScriptHoverCode(code, actionConfig, frameworkType, testType);
                break;
                
            case DRAG_DROP:
                generateTypeScriptDragDropCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_FRAME:
                generateTypeScriptSwitchFrameCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SWITCH_WINDOW:
                generateTypeScriptSwitchWindowCode(code, actionConfig, frameworkType, testType);
                break;
                
            case EXECUTE_SCRIPT:
                generateTypeScriptExecuteScriptCode(code, actionConfig, frameworkType, testType);
                break;
                
            case FILE_UPLOAD:
                generateTypeScriptFileUploadCode(code, actionConfig, frameworkType, testType);
                break;
                
            case KEY_PRESS:
                generateTypeScriptKeyPressCode(code, actionConfig, frameworkType, testType);
                break;
                
            case SCROLL:
                generateTypeScriptScrollCode(code, actionConfig, frameworkType, testType);
                break;
                
            default:
                code.append("// Unsupported action type: ").append(actionType);
                break;
        }
    }
    
    /**
     * Generate Java code for a click action.
     */
    private void generateJavaClickCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Click on element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.CLICKABLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.click();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.click();");
        }
    }
    
    /**
     * Generate TypeScript code for a click action.
     */
    private void generateTypeScriptClickCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Click on element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.CLICKABLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.click();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.click();");
        }
    }
    
    /**
     * Generate Java code for a type action.
     */
    private void generateJavaTypeCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String text = (String) actionConfig.getProperty("text");
        Boolean clearBefore = (Boolean) actionConfig.getProperty("clearBefore", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Type text into element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("element.clear();\n");
            }
            
            code.append("element.sendKeys(\"").append(escapeJavaString(text)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("element.clear();\n");
            }
            
            code.append("element.fill(\"").append(escapeJavaString(text)).append("\");");
        }
    }
    
    /**
     * Generate TypeScript code for a type action.
     */
    private void generateTypeScriptTypeCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String text = (String) actionConfig.getProperty("text");
        Boolean clearBefore = (Boolean) actionConfig.getProperty("clearBefore", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Type text into element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("await element.clear();\n");
            }
            
            code.append("await element.sendKeys(\"").append(escapeTypeScriptString(text)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            if (clearBefore) {
                code.append("await element.clear();\n");
            }
            
            code.append("await element.fill(\"").append(escapeTypeScriptString(text)).append("\");");
        }
    }
    
    /**
     * Generate Java code for a select action.
     */
    private void generateJavaSelectCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String option = (String) actionConfig.getProperty("option");
        String selectBy = (String) actionConfig.getProperty("selectBy");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Select option from dropdown\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("CSSelect select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("select.selectByVisibleText(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("select.selectByValue(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("select.selectByIndex(").append(option).append(");");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            
            code.append("CSSelect select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("select.selectByVisibleText(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("select.selectByValue(\"").append(escapeJavaString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("select.selectByIndex(").append(option).append(");");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a select action.
     */
    private void generateTypeScriptSelectCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String option = (String) actionConfig.getProperty("option");
        String selectBy = (String) actionConfig.getProperty("selectBy");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Select option from dropdown\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("const select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("await select.selectByVisibleText(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("await select.selectByValue(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("await select.selectByIndex(").append(option).append(");");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            
            code.append("const select = new CSSelect(element);\n");
            
            if (selectBy.equals("TEXT")) {
                code.append("await select.selectByVisibleText(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("VALUE")) {
                code.append("await select.selectByValue(\"").append(escapeTypeScriptString(option)).append("\");");
            } else if (selectBy.equals("INDEX")) {
                code.append("await select.selectByIndex(").append(option).append(");");
            }
        }
    }
    
    /**
     * Generate Java code for an assert action.
     */
    private void generateJavaAssertCode(StringBuilder code, AssertionActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String assertionType = actionConfig.getAssertionType();
        String locator = actionConfig.getLocator();
        String locatorType = actionConfig.getLocatorType();
        String expectedValue = actionConfig.getExpectedValue();
        String actualValue = actionConfig.getActualValue();
        Integer timeout = actionConfig.getTimeout() != null ? actionConfig.getTimeout() : 30;
        Boolean failOnAssertionError = actionConfig.isFailOnAssertionError() != null ? actionConfig.isFailOnAssertionError() : true;
        
        code.append("// Assert condition\n");
        
        // Element-based assertions
        if (assertionType.contains("ELEMENT")) {
            if (frameworkType == FrameworkType.SELENIUM) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n\n");
            } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n\n");
            }
            
            if (assertionType.equals("ELEMENT_PRESENT")) {
                code.append("boolean isPresent = element.isPresent();\n");
                code.append("Assert.assertTrue(\"Element should be present\", isPresent);");
            } else if (assertionType.equals("ELEMENT_VISIBLE")) {
                code.append("boolean isVisible = element.isVisible();\n");
                code.append("Assert.assertTrue(\"Element should be visible\", isVisible);");
            } else if (assertionType.equals("ELEMENT_ENABLED")) {
                code.append("boolean isEnabled = element.isEnabled();\n");
                code.append("Assert.assertTrue(\"Element should be enabled\", isEnabled);");
            } else if (assertionType.equals("ELEMENT_SELECTED")) {
                code.append("boolean isSelected = element.isSelected();\n");
                code.append("Assert.assertTrue(\"Element should be selected\", isSelected);");
            } else if (assertionType.equals("ELEMENT_TEXT_EQUALS")) {
                code.append("String actualText = element.getText();\n");
                code.append("Assert.assertEquals(\"Element text should match\", \"").append(escapeJavaString(expectedValue)).append("\", actualText);");
            } else if (assertionType.equals("ELEMENT_TEXT_CONTAINS")) {
                code.append("String actualText = element.getText();\n");
                code.append("Assert.assertTrue(\"Element text should contain expected value\", actualText.contains(\"").append(escapeJavaString(expectedValue)).append("\"));");
            } else if (assertionType.equals("ELEMENT_VALUE_EQUALS")) {
                code.append("String actualValue = element.getAttribute(\"value\");\n");
                code.append("Assert.assertEquals(\"Element value should match\", \"").append(escapeJavaString(expectedValue)).append("\", actualValue);");
            } else if (assertionType.equals("ELEMENT_ATTRIBUTE_EQUALS")) {
                String attributeName = actionConfig.getProperty("attributeName") != null ? 
                        (String) actionConfig.getProperty("attributeName") : "value";
                code.append("String actualAttrValue = element.getAttribute(\"").append(escapeJavaString(attributeName)).append("\");\n");
                code.append("Assert.assertEquals(\"Element attribute should match\", \"").append(escapeJavaString(expectedValue)).append("\", actualAttrValue);");
            } else if (assertionType.equals("ELEMENT_COUNT_EQUALS")) {
                // For elements list count assertion
                code.append("CSElementList elements = getCSElementList(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("int count = elements.size();\n");
                code.append("Assert.assertEquals(\"Element count should match\", ").append(expectedValue).append(", count);");
            }
        }
        // Value-based assertions
        else if (assertionType.contains("VALUE")) {
            if (assertionType.equals("VALUE_EQUALS")) {
                code.append("Assert.assertEquals(\"Value should match\", ").append(expectedValue).append(", ").append(actualValue).append(");");
            } else if (assertionType.equals("VALUE_NOT_EQUALS")) {
                code.append("Assert.assertNotEquals(\"Value should not match\", ").append(expectedValue).append(", ").append(actualValue).append(");");
            } else if (assertionType.equals("VALUE_GREATER_THAN")) {
                code.append("Assert.assertTrue(\"Value should be greater than expected\", (").append(actualValue).append(") > (").append(expectedValue).append("));");
            } else if (assertionType.equals("VALUE_LESS_THAN")) {
                code.append("Assert.assertTrue(\"Value should be less than expected\", (").append(actualValue).append(") < (").append(expectedValue).append("));");
            } else if (assertionType.equals("VALUE_CONTAINS")) {
                code.append("Assert.assertTrue(\"Value should contain expected value\", ((String) ").append(actualValue).append(").contains((String) ").append(expectedValue).append("));");
            } else if (assertionType.equals("VALUE_MATCHES")) {
                code.append("Assert.assertTrue(\"Value should match regex pattern\", ((String) ").append(actualValue).append(").matches((String) ").append(expectedValue).append("));");
            } else if (assertionType.equals("VALUE_EMPTY")) {
                code.append("Assert.assertTrue(\"Value should be empty\", ((String) ").append(actualValue).append(").isEmpty());");
            } else if (assertionType.equals("VALUE_NOT_EMPTY")) {
                code.append("Assert.assertFalse(\"Value should not be empty\", ((String) ").append(actualValue).append(").isEmpty());");
            } else if (assertionType.equals("VALUE_NULL")) {
                code.append("Assert.assertNull(\"Value should be null\", ").append(actualValue).append(");");
            } else if (assertionType.equals("VALUE_NOT_NULL")) {
                code.append("Assert.assertNotNull(\"Value should not be null\", ").append(actualValue).append(");");
            }
        }
        // Boolean assertions
        else if (assertionType.contains("BOOLEAN")) {
            if (assertionType.equals("BOOLEAN_TRUE")) {
                code.append("Assert.assertTrue(\"Condition should be true\", ").append(actualValue).append(");");
            } else if (assertionType.equals("BOOLEAN_FALSE")) {
                code.append("Assert.assertFalse(\"Condition should be false\", ").append(actualValue).append(");");
            }
        }
        // Page assertions
        else if (assertionType.contains("PAGE")) {
            if (assertionType.equals("PAGE_TITLE_EQUALS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("String title = getDriver().getTitle();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("String title = getPage().title();\n");
                }
                code.append("Assert.assertEquals(\"Page title should match\", \"").append(escapeJavaString(expectedValue)).append("\", title);");
            } else if (assertionType.equals("PAGE_TITLE_CONTAINS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("String title = getDriver().getTitle();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("String title = getPage().title();\n");
                }
                code.append("Assert.assertTrue(\"Page title should contain expected value\", title.contains(\"").append(escapeJavaString(expectedValue)).append("\"));");
            } else if (assertionType.equals("PAGE_URL_EQUALS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("String url = getDriver().getCurrentUrl();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("String url = getPage().url();\n");
                }
                code.append("Assert.assertEquals(\"Page URL should match\", \"").append(escapeJavaString(expectedValue)).append("\", url);");
            } else if (assertionType.equals("PAGE_URL_CONTAINS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("String url = getDriver().getCurrentUrl();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("String url = getPage().url();\n");
                }
                code.append("Assert.assertTrue(\"Page URL should contain expected value\", url.contains(\"").append(escapeJavaString(expectedValue)).append("\"));");
            }
        }
        // Custom assertions
        else if (assertionType.equals("CUSTOM")) {
            String customAssertion = (String) actionConfig.getProperty("customAssertion");
            if (customAssertion != null && !customAssertion.isEmpty()) {
                code.append(customAssertion);
            } else {
                code.append("// Custom assertion - implementation required");
            }
        }
    }
    
    /**
     * Generate TypeScript code for an assert action.
     */
    private void generateTypeScriptAssertCode(StringBuilder code, AssertionActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String assertionType = actionConfig.getAssertionType();
        String locator = actionConfig.getLocator();
        String locatorType = actionConfig.getLocatorType();
        String expectedValue = actionConfig.getExpectedValue();
        String actualValue = actionConfig.getActualValue();
        Integer timeout = actionConfig.getTimeout() != null ? actionConfig.getTimeout() : 30;
        Boolean failOnAssertionError = actionConfig.isFailOnAssertionError() != null ? actionConfig.isFailOnAssertionError() : true;
        
        code.append("// Assert condition\n");
        
        // Element-based assertions
        if (assertionType.contains("ELEMENT")) {
            if (frameworkType == FrameworkType.SELENIUM) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n\n");
            } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n\n");
            }
            
            if (assertionType.equals("ELEMENT_PRESENT")) {
                code.append("const isPresent = await element.isPresent();\n");
                code.append("expect(isPresent).to.be.true;");
            } else if (assertionType.equals("ELEMENT_VISIBLE")) {
                code.append("const isVisible = await element.isVisible();\n");
                code.append("expect(isVisible).to.be.true;");
            } else if (assertionType.equals("ELEMENT_ENABLED")) {
                code.append("const isEnabled = await element.isEnabled();\n");
                code.append("expect(isEnabled).to.be.true;");
            } else if (assertionType.equals("ELEMENT_SELECTED")) {
                code.append("const isSelected = await element.isSelected();\n");
                code.append("expect(isSelected).to.be.true;");
            } else if (assertionType.equals("ELEMENT_TEXT_EQUALS")) {
                code.append("const actualText = await element.getText();\n");
                code.append("expect(actualText).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("ELEMENT_TEXT_CONTAINS")) {
                code.append("const actualText = await element.getText();\n");
                code.append("expect(actualText).to.contain(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("ELEMENT_VALUE_EQUALS")) {
                code.append("const actualValue = await element.getAttribute(\"value\");\n");
                code.append("expect(actualValue).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("ELEMENT_ATTRIBUTE_EQUALS")) {
                String attributeName = actionConfig.getProperty("attributeName") != null ? 
                        (String) actionConfig.getProperty("attributeName") : "value";
                code.append("const actualAttrValue = await element.getAttribute(\"").append(escapeTypeScriptString(attributeName)).append("\");\n");
                code.append("expect(actualAttrValue).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("ELEMENT_COUNT_EQUALS")) {
                // For elements list count assertion
                code.append("const elements = getCSElementList(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("const count = await elements.size();\n");
                code.append("expect(count).to.equal(").append(expectedValue).append(");");
            }
        }
        // Value-based assertions
        else if (assertionType.contains("VALUE")) {
            if (assertionType.equals("VALUE_EQUALS")) {
                code.append("expect(").append(actualValue).append(").to.equal(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_NOT_EQUALS")) {
                code.append("expect(").append(actualValue).append(").to.not.equal(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_GREATER_THAN")) {
                code.append("expect(").append(actualValue).append(").to.be.greaterThan(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_LESS_THAN")) {
                code.append("expect(").append(actualValue).append(").to.be.lessThan(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_CONTAINS")) {
                code.append("expect(").append(actualValue).append(").to.contain(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_MATCHES")) {
                code.append("expect(").append(actualValue).append(").to.match(").append(expectedValue).append(");");
            } else if (assertionType.equals("VALUE_EMPTY")) {
                code.append("expect(").append(actualValue).append(").to.be.empty;");
            } else if (assertionType.equals("VALUE_NOT_EMPTY")) {
                code.append("expect(").append(actualValue).append(").to.not.be.empty;");
            } else if (assertionType.equals("VALUE_NULL")) {
                code.append("expect(").append(actualValue).append(").to.be.null;");
            } else if (assertionType.equals("VALUE_NOT_NULL")) {
                code.append("expect(").append(actualValue).append(").to.not.be.null;");
            }
        }
        // Boolean assertions
        else if (assertionType.contains("BOOLEAN")) {
            if (assertionType.equals("BOOLEAN_TRUE")) {
                code.append("expect(").append(actualValue).append(").to.be.true;");
            } else if (assertionType.equals("BOOLEAN_FALSE")) {
                code.append("expect(").append(actualValue).append(").to.be.false;");
            }
        }
        // Page assertions
        else if (assertionType.contains("PAGE")) {
            if (assertionType.equals("PAGE_TITLE_EQUALS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("const title = await getDriver().getTitle();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("const title = await getPage().title();\n");
                }
                code.append("expect(title).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("PAGE_TITLE_CONTAINS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("const title = await getDriver().getTitle();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("const title = await getPage().title();\n");
                }
                code.append("expect(title).to.contain(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("PAGE_URL_EQUALS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("const url = await getDriver().getCurrentUrl();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("const url = await getPage().url();\n");
                }
                code.append("expect(url).to.equal(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            } else if (assertionType.equals("PAGE_URL_CONTAINS")) {
                if (frameworkType == FrameworkType.SELENIUM) {
                    code.append("const url = await getDriver().getCurrentUrl();\n");
                } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                    code.append("const url = await getPage().url();\n");
                }
                code.append("expect(url).to.contain(\"").append(escapeTypeScriptString(expectedValue)).append("\");");
            }
        }
        // Custom assertions
        else if (assertionType.equals("CUSTOM")) {
            String customAssertion = (String) actionConfig.getProperty("customAssertion");
            if (customAssertion != null && !customAssertion.isEmpty()) {
                code.append(customAssertion);
            } else {
                code.append("// Custom assertion - implementation required");
            }
        }
    }
    
    /**
     * Generate Java code for a wait action.
     */
    private void generateJavaWaitCode(StringBuilder code, WaitActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String waitType = actionConfig.getWaitType();
        String locator = actionConfig.getLocator();
        String locatorType = actionConfig.getLocatorType();
        Integer timeout = actionConfig.getTimeout() != null ? actionConfig.getTimeout() : 30;
        Integer pollingInterval = actionConfig.getProperty("pollingInterval") != null ? 
                (Integer) actionConfig.getProperty("pollingInterval") : 500;
        String condition = actionConfig.getProperty("condition") != null ? 
                (String) actionConfig.getProperty("condition") : null;
        
        code.append("// Wait for condition\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitType.contains("ELEMENT")) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(");
                
                if (waitType.equals("ELEMENT_VISIBLE")) {
                    code.append("CSWaitStrategyType.VISIBLE");
                } else if (waitType.equals("ELEMENT_CLICKABLE")) {
                    code.append("CSWaitStrategyType.CLICKABLE");
                } else if (waitType.equals("ELEMENT_PRESENT")) {
                    code.append("CSWaitStrategyType.PRESENT");
                } else if (waitType.equals("ELEMENT_INVISIBLE")) {
                    code.append("CSWaitStrategyType.INVISIBLE");
                } else if (waitType.equals("ELEMENT_SELECTED")) {
                    code.append("CSWaitStrategyType.SELECTED");
                } else if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    code.append("CSWaitStrategyType.ATTRIBUTE");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    code.append("CSWaitStrategyType.TEXT");
                }
                
                code.append(");\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("waitStrategy.setPollingInterval(").append(pollingInterval).append(");\n");
                
                if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    String attributeName = actionConfig.getProperty("attributeName") != null ? 
                            (String) actionConfig.getProperty("attributeName") : "value";
                    String attributeValue = actionConfig.getProperty("attributeValue") != null ? 
                            (String) actionConfig.getProperty("attributeValue") : "";
                    
                    code.append("((CSAttributeWait) waitStrategy).setAttribute(\"")
                            .append(escapeJavaString(attributeName)).append("\", \"")
                            .append(escapeJavaString(attributeValue)).append("\");\n");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    String text = actionConfig.getProperty("text") != null ? 
                            (String) actionConfig.getProperty("text") : "";
                    
                    code.append("((CSTextWait) waitStrategy).setText(\"")
                            .append(escapeJavaString(text)).append("\");\n");
                }
                
                code.append("getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);");
            } else if (waitType.equals("FIXED_TIME")) {
                code.append("CSWaitFactory.sleepInMilliseconds(").append(timeout * 1000).append(");");
            } else if (waitType.equals("PAGE_LOAD")) {
                code.append("getDriver().manage().timeouts().pageLoadTimeout(").append(timeout).append(", TimeUnit.SECONDS);");
            } else if (waitType.equals("SCRIPT")) {
                code.append("getDriver().manage().timeouts().setScriptTimeout(").append(timeout).append(", TimeUnit.SECONDS);");
            } else if (waitType.equals("CUSTOM")) {
                if (condition != null && !condition.isEmpty()) {
                    code.append("CSWaitFactory.waitUntil(driver -> {\n    return ").append(condition).append(";\n}, ")
                            .append(timeout).append(", ").append(pollingInterval).append(");");
                } else {
                    code.append("// Custom wait condition not specified");
                }
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitType.contains("ELEMENT")) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                
                if (waitType.equals("ELEMENT_VISIBLE")) {
                    code.append("element.waitForElementToBeVisible(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_CLICKABLE")) {
                    code.append("element.waitForElementToBeEnabled(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_PRESENT")) {
                    code.append("element.waitForElementToBePresent(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_INVISIBLE")) {
                    code.append("element.waitForElementToBeHidden(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    String attributeName = actionConfig.getProperty("attributeName") != null ? 
                            (String) actionConfig.getProperty("attributeName") : "value";
                    String attributeValue = actionConfig.getProperty("attributeValue") != null ? 
                            (String) actionConfig.getProperty("attributeValue") : "";
                    
                    code.append("element.waitForElementToHaveAttribute(\"").append(escapeJavaString(attributeName))
                            .append("\", \"").append(escapeJavaString(attributeValue)).append("\", ")
                            .append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    String text = actionConfig.getProperty("text") != null ? 
                            (String) actionConfig.getProperty("text") : "";
                    
                    code.append("element.waitForElementToHaveText(\"").append(escapeJavaString(text))
                            .append("\", ").append(timeout * 1000).append(");");
                }
            } else if (waitType.equals("FIXED_TIME")) {
                code.append("getPage().waitForTimeout(").append(timeout * 1000).append(");");
            } else if (waitType.equals("PAGE_LOAD")) {
                code.append("getPage().waitForLoadState(LoadState.LOAD, new PageWaitForLoadStateOptions().setTimeout(")
                        .append(timeout * 1000).append("));");
            } else if (waitType.equals("CUSTOM")) {
                if (condition != null && !condition.isEmpty()) {
                    code.append("getPage().waitForFunction(\"").append(escapeJavaString(condition))
                            .append("\", new PageWaitForFunctionOptions().setTimeout(")
                            .append(timeout * 1000).append(").setPredicate(true));");
                } else {
                    code.append("// Custom wait condition not specified");
                }
            }
        }
    }
    
    /**
     * Generate TypeScript code for a wait action.
     */
    private void generateTypeScriptWaitCode(StringBuilder code, WaitActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String waitType = actionConfig.getWaitType();
        String locator = actionConfig.getLocator();
        String locatorType = actionConfig.getLocatorType();
        Integer timeout = actionConfig.getTimeout() != null ? actionConfig.getTimeout() : 30;
        Integer pollingInterval = actionConfig.getProperty("pollingInterval") != null ? 
                (Integer) actionConfig.getProperty("pollingInterval") : 500;
        String condition = actionConfig.getProperty("condition") != null ? 
                (String) actionConfig.getProperty("condition") : null;
        
        code.append("// Wait for condition\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitType.contains("ELEMENT")) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(");
                
                if (waitType.equals("ELEMENT_VISIBLE")) {
                    code.append("CSWaitStrategyType.VISIBLE");
                } else if (waitType.equals("ELEMENT_CLICKABLE")) {
                    code.append("CSWaitStrategyType.CLICKABLE");
                } else if (waitType.equals("ELEMENT_PRESENT")) {
                    code.append("CSWaitStrategyType.PRESENT");
                } else if (waitType.equals("ELEMENT_INVISIBLE")) {
                    code.append("CSWaitStrategyType.INVISIBLE");
                } else if (waitType.equals("ELEMENT_SELECTED")) {
                    code.append("CSWaitStrategyType.SELECTED");
                } else if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    code.append("CSWaitStrategyType.ATTRIBUTE");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    code.append("CSWaitStrategyType.TEXT");
                }
                
                code.append(");\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("waitStrategy.setPollingInterval(").append(pollingInterval).append(");\n");
                
                if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    String attributeName = actionConfig.getProperty("attributeName") != null ? 
                            (String) actionConfig.getProperty("attributeName") : "value";
                    String attributeValue = actionConfig.getProperty("attributeValue") != null ? 
                            (String) actionConfig.getProperty("attributeValue") : "";
                    
                    code.append("(waitStrategy as CSAttributeWait).setAttribute(\"")
                            .append(escapeTypeScriptString(attributeName)).append("\", \"")
                            .append(escapeTypeScriptString(attributeValue)).append("\");\n");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    String text = actionConfig.getProperty("text") != null ? 
                            (String) actionConfig.getProperty("text") : "";
                    
                    code.append("(waitStrategy as CSTextWait).setText(\"")
                            .append(escapeTypeScriptString(text)).append("\");\n");
                }
                
                code.append("await getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);");
            } else if (waitType.equals("FIXED_TIME")) {
                code.append("await CSWaitFactory.sleep(").append(timeout * 1000).append(");");
            } else if (waitType.equals("PAGE_LOAD")) {
                code.append("await getDriver().manage().timeouts().pageLoadTimeout(").append(timeout).append(", TimeUnit.SECONDS);");
            } else if (waitType.equals("SCRIPT")) {
                code.append("await getDriver().manage().timeouts().setScriptTimeout(").append(timeout).append(", TimeUnit.SECONDS);");
            } else if (waitType.equals("CUSTOM")) {
                if (condition != null && !condition.isEmpty()) {
                    code.append("await CSWaitFactory.waitUntil(async (driver) => {\n    return ").append(condition).append(";\n}, ")
                            .append(timeout).append(", ").append(pollingInterval).append(");");
                } else {
                    code.append("// Custom wait condition not specified");
                }
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitType.contains("ELEMENT")) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                
                if (waitType.equals("ELEMENT_VISIBLE")) {
                    code.append("await element.waitForElementToBeVisible(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_CLICKABLE")) {
                    code.append("await element.waitForElementToBeEnabled(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_PRESENT")) {
                    code.append("await element.waitForElementToBePresent(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_INVISIBLE")) {
                    code.append("await element.waitForElementToBeHidden(").append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_ATTRIBUTE")) {
                    String attributeName = actionConfig.getProperty("attributeName") != null ? 
                            (String) actionConfig.getProperty("attributeName") : "value";
                    String attributeValue = actionConfig.getProperty("attributeValue") != null ? 
                            (String) actionConfig.getProperty("attributeValue") : "";
                    
                    code.append("await element.waitForElementToHaveAttribute(\"").append(escapeTypeScriptString(attributeName))
                            .append("\", \"").append(escapeTypeScriptString(attributeValue)).append("\", ")
                            .append(timeout * 1000).append(");");
                } else if (waitType.equals("ELEMENT_TEXT")) {
                    String text = actionConfig.getProperty("text") != null ? 
                            (String) actionConfig.getProperty("text") : "";
                    
                    code.append("await element.waitForElementToHaveText(\"").append(escapeTypeScriptString(text))
                            .append("\", ").append(timeout * 1000).append(");");
                }
            } else if (waitType.equals("FIXED_TIME")) {
                code.append("await getPage().waitForTimeout(").append(timeout * 1000).append(");");
            } else if (waitType.equals("PAGE_LOAD")) {
                code.append("await getPage().waitForLoadState('load', { timeout: ")
                        .append(timeout * 1000).append(" });");
            } else if (waitType.equals("CUSTOM")) {
                if (condition != null && !condition.isEmpty()) {
                    code.append("await getPage().waitForFunction(`").append(escapeTypeScriptString(condition))
                            .append("`, { timeout: ").append(timeout * 1000).append(" });");
                } else {
                    code.append("// Custom wait condition not specified");
                }
            }
        }
    }
    
    /**
     * Generate Java code for a navigate action.
     */
    private void generateJavaNavigateCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String url = (String) actionConfig.getProperty("url");
        Boolean waitForLoad = (Boolean) actionConfig.getProperty("waitForLoad", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 60);
        
        code.append("// Navigate to URL\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForLoad) {
                code.append("getDriver().manage().timeouts().pageLoadTimeout(").append(timeout).append(", TimeUnit.SECONDS);\n");
            }
            code.append("getDriver().get(\"").append(escapeJavaString(url)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForLoad) {
                code.append("getPage().navigate(\"").append(escapeJavaString(url)).append("\", ")
                        .append("new NavigateOptions().setWaitUntil(LoadState.LOAD).setTimeout(")
                        .append(timeout * 1000).append("));");
            } else {
                code.append("getPage().navigate(\"").append(escapeJavaString(url)).append("\", ")
                        .append("new NavigateOptions().setWaitUntil(LoadState.DOMCONTENTLOADED).setTimeout(")
                        .append(timeout * 1000).append("));");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a navigate action.
     */
    private void generateTypeScriptNavigateCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String url = (String) actionConfig.getProperty("url");
        Boolean waitForLoad = (Boolean) actionConfig.getProperty("waitForLoad", true);
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 60);
        
        code.append("// Navigate to URL\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForLoad) {
                code.append("await getDriver().manage().timeouts().pageLoadTimeout(").append(timeout).append(", TimeUnit.SECONDS);\n");
            }
            code.append("await getDriver().get(\"").append(escapeTypeScriptString(url)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForLoad) {
                code.append("await getPage().goto(\"").append(escapeTypeScriptString(url)).append("\", { ")
                        .append("waitUntil: 'load', timeout: ").append(timeout * 1000).append(" });");
            } else {
                code.append("await getPage().goto(\"").append(escapeTypeScriptString(url)).append("\", { ")
                        .append("waitUntil: 'domcontentloaded', timeout: ").append(timeout * 1000).append(" });");
            }
        }
    }
    
    /**
     * Generate Java code for a conditional action.
     */
    private void generateJavaConditionalCode(StringBuilder code, ConditionalActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String condition = actionConfig.getCondition();
        String operator = actionConfig.getOperator();
        String leftOperand = actionConfig.getLeftOperand();
        String rightOperand = actionConfig.getRightOperand();
        List<ActionConfig> nestedActions = actionConfig.getNestedActions();
        List<ActionConfig> elseActions = actionConfig.getElseActions();
        
        code.append("// Conditional execution\n");
        
        // Build condition
        StringBuilder conditionCode = new StringBuilder();
        if (condition != null && !condition.isEmpty()) {
            conditionCode.append(condition);
        } else if (operator != null && !operator.isEmpty() && leftOperand != null && rightOperand != null) {
            conditionCode.append(leftOperand);
            
            switch (operator) {
                case "EQUALS":
                    conditionCode.append(" == ");
                    break;
                case "NOT_EQUALS":
                    conditionCode.append(" != ");
                    break;
                case "GREATER_THAN":
                    conditionCode.append(" > ");
                    break;
                case "LESS_THAN":
                    conditionCode.append(" < ");
                    break;
                case "GREATER_THAN_OR_EQUALS":
                    conditionCode.append(" >= ");
                    break;
                case "LESS_THAN_OR_EQUALS":
                    conditionCode.append(" <= ");
                    break;
                case "CONTAINS":
                    conditionCode.append(".contains(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "STARTS_WITH":
                    conditionCode.append(".startsWith(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "ENDS_WITH":
                    conditionCode.append(".endsWith(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "MATCHES":
                    conditionCode.append(".matches(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                default:
                    conditionCode.append(" ").append(operator).append(" ");
                    break;
            }
            
            if (rightOperand != null) {
                conditionCode.append(rightOperand);
            }
        } else {
            conditionCode.append("true");
        }
        
        // Generate code
        code.append("if (").append(conditionCode).append(") {\n");
        
        if (nestedActions != null && !nestedActions.isEmpty()) {
            for (ActionConfig nestedAction : nestedActions) {
                StringBuilder nestedCode = new StringBuilder();
                generateJavaCode(nestedCode, nestedAction, frameworkType, testType);
                
                String[] lines = nestedCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        if (elseActions != null && !elseActions.isEmpty()) {
            code.append("} else {\n");
            
            for (ActionConfig elseAction : elseActions) {
                StringBuilder elseCode = new StringBuilder();
                generateJavaCode(elseCode, elseAction, frameworkType, testType);
                
                String[] lines = elseCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate TypeScript code for a conditional action.
     */
    private void generateTypeScriptConditionalCode(StringBuilder code, ConditionalActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String condition = actionConfig.getCondition();
        String operator = actionConfig.getOperator();
        String leftOperand = actionConfig.getLeftOperand();
        String rightOperand = actionConfig.getRightOperand();
        List<ActionConfig> nestedActions = actionConfig.getNestedActions();
        List<ActionConfig> elseActions = actionConfig.getElseActions();
        
        code.append("// Conditional execution\n");
        
        // Build condition
        StringBuilder conditionCode = new StringBuilder();
        if (condition != null && !condition.isEmpty()) {
            conditionCode.append(condition);
        } else if (operator != null && !operator.isEmpty() && leftOperand != null && rightOperand != null) {
            conditionCode.append(leftOperand);
            
            switch (operator) {
                case "EQUALS":
                    conditionCode.append(" === ");
                    break;
                case "NOT_EQUALS":
                    conditionCode.append(" !== ");
                    break;
                case "GREATER_THAN":
                    conditionCode.append(" > ");
                    break;
                case "LESS_THAN":
                    conditionCode.append(" < ");
                    break;
                case "GREATER_THAN_OR_EQUALS":
                    conditionCode.append(" >= ");
                    break;
                case "LESS_THAN_OR_EQUALS":
                    conditionCode.append(" <= ");
                    break;
                case "CONTAINS":
                    conditionCode.append(".includes(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "STARTS_WITH":
                    conditionCode.append(".startsWith(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "ENDS_WITH":
                    conditionCode.append(".endsWith(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(")");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                case "MATCHES":
                    conditionCode.append(".match(");
                    conditionCode.append(rightOperand);
                    conditionCode.append(") !== null");
                    // Skip appending rightOperand again
                    rightOperand = null;
                    break;
                default:
                    conditionCode.append(" ").append(operator).append(" ");
                    break;
            }
            
            if (rightOperand != null) {
                conditionCode.append(rightOperand);
            }
        } else {
            conditionCode.append("true");
        }
        
        // Generate code
        code.append("if (").append(conditionCode).append(") {\n");
        
        if (nestedActions != null && !nestedActions.isEmpty()) {
            for (ActionConfig nestedAction : nestedActions) {
                StringBuilder nestedCode = new StringBuilder();
                generateTypeScriptCode(nestedCode, nestedAction, frameworkType, testType);
                
                String[] lines = nestedCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        if (elseActions != null && !elseActions.isEmpty()) {
            code.append("} else {\n");
            
            for (ActionConfig elseAction : elseActions) {
                StringBuilder elseCode = new StringBuilder();
                generateTypeScriptCode(elseCode, elseAction, frameworkType, testType);
                
                String[] lines = elseCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }

/**
     * Generate Java code for a loop action.
     */
    private void generateJavaLoopCode(StringBuilder code, LoopActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String loopType = actionConfig.getLoopType();
        Integer times = actionConfig.getTimes();
        String collection = actionConfig.getCollection();
        String variableName = actionConfig.getVariableName();
        String initExpression = actionConfig.getInitExpression();
        String conditionExpression = actionConfig.getConditionExpression();
        String incrementExpression = actionConfig.getIncrementExpression();
        List<ActionConfig> nestedActions = actionConfig.getNestedActions();
        
        code.append("// Loop execution\n");
        
        if (loopType.equals("TIMES")) {
            code.append("for (int i = 0; i < ").append(times).append("; i++) {\n");
        } else if (loopType.equals("FOREACH")) {
            code.append("for (Object ").append(variableName).append(" : ").append(collection).append(") {\n");
        } else if (loopType.equals("FOR")) {
            code.append("for (").append(initExpression).append("; ")
                    .append(conditionExpression).append("; ")
                    .append(incrementExpression).append(") {\n");
        } else if (loopType.equals("WHILE")) {
            code.append("while (").append(conditionExpression).append(") {\n");
        } else {
            code.append("// Unsupported loop type: ").append(loopType).append("\n");
        }
        
        if (nestedActions != null && !nestedActions.isEmpty()) {
            for (ActionConfig nestedAction : nestedActions) {
                StringBuilder nestedCode = new StringBuilder();
                generateJavaCode(nestedCode, nestedAction, frameworkType, testType);
                
                String[] lines = nestedCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate TypeScript code for a loop action.
     */
    private void generateTypeScriptLoopCode(StringBuilder code, LoopActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String loopType = actionConfig.getLoopType();
        Integer times = actionConfig.getTimes();
        String collection = actionConfig.getCollection();
        String variableName = actionConfig.getVariableName();
        String initExpression = actionConfig.getInitExpression();
        String conditionExpression = actionConfig.getConditionExpression();
        String incrementExpression = actionConfig.getIncrementExpression();
        List<ActionConfig> nestedActions = actionConfig.getNestedActions();
        
        code.append("// Loop execution\n");
        
        if (loopType.equals("TIMES")) {
            code.append("for (let i = 0; i < ").append(times).append("; i++) {\n");
        } else if (loopType.equals("FOREACH")) {
            code.append("for (const ").append(variableName).append(" of ").append(collection).append(") {\n");
        } else if (loopType.equals("FOR")) {
            code.append("for (").append(initExpression).append("; ")
                    .append(conditionExpression).append("; ")
                    .append(incrementExpression).append(") {\n");
        } else if (loopType.equals("WHILE")) {
            code.append("while (").append(conditionExpression).append(") {\n");
        } else {
            code.append("// Unsupported loop type: ").append(loopType).append("\n");
        }
        
        if (nestedActions != null && !nestedActions.isEmpty()) {
            for (ActionConfig nestedAction : nestedActions) {
                StringBuilder nestedCode = new StringBuilder();
                generateTypeScriptCode(nestedCode, nestedAction, frameworkType, testType);
                
                String[] lines = nestedCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate Java code for a data provider action.
     */
    private void generateJavaDataProviderCode(StringBuilder code, DataProviderActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String dataSourceType = actionConfig.getDataSourceType();
        String dataSourcePath = actionConfig.getDataSourcePath();
        String sheetName = actionConfig.getSheetName();
        String delimiter = actionConfig.getDelimiter();
        Boolean headers = actionConfig.getHeaders();
        List<String> parameters = actionConfig.getParameters();
        List<ActionConfig> iterationActions = actionConfig.getIterationActions();
        
        code.append("// Data-driven execution\n");
        
        // Generate data source
        if (dataSourceType.equals("EXCEL")) {
            code.append("CSDataSource dataSource = CSDataSourceFactory.createExcelDataSource(\"")
                    .append(escapeJavaString(dataSourcePath)).append("\", \"")
                    .append(escapeJavaString(sheetName)).append("\", ")
                    .append(headers).append(");\n");
        } else if (dataSourceType.equals("CSV")) {
            code.append("CSDataSource dataSource = CSDataSourceFactory.createCsvDataSource(\"")
                    .append(escapeJavaString(dataSourcePath)).append("\", \"")
                    .append(escapeJavaString(delimiter)).append("\", ")
                    .append(headers).append(");\n");
        } else if (dataSourceType.equals("JSON")) {
            code.append("CSDataSource dataSource = CSDataSourceFactory.createJsonDataSource(\"")
                    .append(escapeJavaString(dataSourcePath)).append("\");\n");
        } else if (dataSourceType.equals("DATABASE")) {
            String query = actionConfig.getProperty("query") != null ? 
                    (String) actionConfig.getProperty("query") : "";
            String connectionString = actionConfig.getProperty("connectionString") != null ? 
                    (String) actionConfig.getProperty("connectionString") : "";
            
            code.append("CSDataSource dataSource = CSDataSourceFactory.createDatabaseDataSource(\"")
                    .append(escapeJavaString(connectionString)).append("\", \"")
                    .append(escapeJavaString(query)).append("\");\n");
        } else {
            code.append("// Unsupported data source type: ").append(dataSourceType).append("\n");
            return;
        }
        
        // Generate parameters
        if (parameters != null && !parameters.isEmpty()) {
            code.append("String[] parameterNames = new String[] {");
            for (int i = 0; i < parameters.size(); i++) {
                if (i > 0) {
                    code.append(", ");
                }
                code.append("\"").append(escapeJavaString(parameters.get(i))).append("\"");
            }
            code.append("};\n");
        }
        
        // Generate iterations
        code.append("for (Map<String, Object> data : dataSource.getData()) {\n");
        
        if (iterationActions != null && !iterationActions.isEmpty()) {
            code.append("    // Add data to test context\n");
            code.append("    TestContext.getInstance().addData(data);\n");
            code.append("\n");
            
            for (ActionConfig iterationAction : iterationActions) {
                StringBuilder iterationCode = new StringBuilder();
                generateJavaCode(iterationCode, iterationAction, frameworkType, testType);
                
                String[] lines = iterationCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate TypeScript code for a data provider action.
     */
    private void generateTypeScriptDataProviderCode(StringBuilder code, DataProviderActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String dataSourceType = actionConfig.getDataSourceType();
        String dataSourcePath = actionConfig.getDataSourcePath();
        String sheetName = actionConfig.getSheetName();
        String delimiter = actionConfig.getDelimiter();
        Boolean headers = actionConfig.getHeaders();
        List<String> parameters = actionConfig.getParameters();
        List<ActionConfig> iterationActions = actionConfig.getIterationActions();
        
        code.append("// Data-driven execution\n");
        
        // Generate data source
        if (dataSourceType.equals("EXCEL")) {
            code.append("const dataSource = CSDataSourceFactory.createExcelDataSource(\"")
                    .append(escapeTypeScriptString(dataSourcePath)).append("\", \"")
                    .append(escapeTypeScriptString(sheetName)).append("\", ")
                    .append(headers).append(");\n");
        } else if (dataSourceType.equals("CSV")) {
            code.append("const dataSource = CSDataSourceFactory.createCsvDataSource(\"")
                    .append(escapeTypeScriptString(dataSourcePath)).append("\", \"")
                    .append(escapeTypeScriptString(delimiter)).append("\", ")
                    .append(headers).append(");\n");
        } else if (dataSourceType.equals("JSON")) {
            code.append("const dataSource = CSDataSourceFactory.createJsonDataSource(\"")
                    .append(escapeTypeScriptString(dataSourcePath)).append("\");\n");
        } else if (dataSourceType.equals("DATABASE")) {
            String query = actionConfig.getProperty("query") != null ? 
                    (String) actionConfig.getProperty("query") : "";
            String connectionString = actionConfig.getProperty("connectionString") != null ? 
                    (String) actionConfig.getProperty("connectionString") : "";
            
            code.append("const dataSource = CSDataSourceFactory.createDatabaseDataSource(\"")
                    .append(escapeTypeScriptString(connectionString)).append("\", \"")
                    .append(escapeTypeScriptString(query)).append("\");\n");
        } else {
            code.append("// Unsupported data source type: ").append(dataSourceType).append("\n");
            return;
        }
        
        // Generate parameters
        if (parameters != null && !parameters.isEmpty()) {
            code.append("const parameterNames = [");
            for (int i = 0; i < parameters.size(); i++) {
                if (i > 0) {
                    code.append(", ");
                }
                code.append("\"").append(escapeTypeScriptString(parameters.get(i))).append("\"");
            }
            code.append("];\n");
        }
        
        // Generate iterations
        code.append("for (const data of await dataSource.getData()) {\n");
        
        if (iterationActions != null && !iterationActions.isEmpty()) {
            code.append("    // Add data to test context\n");
            code.append("    TestContext.getInstance().addData(data);\n");
            code.append("\n");
            
            for (ActionConfig iterationAction : iterationActions) {
                StringBuilder iterationCode = new StringBuilder();
                generateTypeScriptCode(iterationCode, iterationAction, frameworkType, testType);
                
                String[] lines = iterationCode.toString().split("\n");
                for (String line : lines) {
                    code.append("    ").append(line).append("\n");
                }
            }
        }
        
        code.append("}");
    }
    
    /**
     * Generate Java code for a custom action.
     */
    private void generateJavaCustomCode(StringBuilder code, CustomActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String scriptType = actionConfig.getScriptType();
        String script = actionConfig.getScript();
        List<Map<String, String>> parameters = actionConfig.getParameters();
        
        code.append("// Custom action execution\n");
        
        if (scriptType.equals("JAVASCRIPT")) {
            code.append("// JavaScript execution\n");
            
            // Generate parameters
            if (parameters != null && !parameters.isEmpty()) {
                code.append("Map<String, Object> scriptParams = new HashMap<>();\n");
                for (Map<String, String> parameter : parameters) {
                    String name = parameter.get("name");
                    String value = parameter.get("value");
                    if (name != null && value != null) {
                        code.append("scriptParams.put(\"").append(escapeJavaString(name)).append("\", \"")
                                .append(escapeJavaString(value)).append("\");\n");
                    }
                }
                code.append("\n");
            }
            
            // Generate script execution
            code.append("JavaScriptExecutor jsExecutor = (JavaScriptExecutor) getDriver();\n");
            
            if (parameters != null && !parameters.isEmpty()) {
                code.append("Object result = jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\", scriptParams);\n");
            } else {
                code.append("Object result = jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\");\n");
            }
            
            // Store result if required
            String resultVariable = actionConfig.getProperty("resultVariable") != null ? 
                    (String) actionConfig.getProperty("resultVariable") : null;
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("// Store result in variable\n");
                code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(resultVariable)).append("\", result);");
            }
        } else if (scriptType.equals("JAVA")) {
            code.append("// Java code execution\n");
            code.append(script);
        } else {
            code.append("// Unsupported script type: ").append(scriptType);
        }
    }
    
    /**
     * Generate TypeScript code for a custom action.
     */
    private void generateTypeScriptCustomCode(StringBuilder code, CustomActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String scriptType = actionConfig.getScriptType();
        String script = actionConfig.getScript();
        List<Map<String, String>> parameters = actionConfig.getParameters();
        
        code.append("// Custom action execution\n");
        
        if (scriptType.equals("JAVASCRIPT")) {
            code.append("// JavaScript execution\n");
            
            // Generate parameters
            if (parameters != null && !parameters.isEmpty()) {
                code.append("const scriptParams: Record<string, any> = {};\n");
                for (Map<String, String> parameter : parameters) {
                    String name = parameter.get("name");
                    String value = parameter.get("value");
                    if (name != null && value != null) {
                        code.append("scriptParams[\"").append(escapeTypeScriptString(name)).append("\"] = \"")
                                .append(escapeTypeScriptString(value)).append("\";\n");
                    }
                }
                code.append("\n");
            }
            
            // Generate script execution
            if (frameworkType == FrameworkType.SELENIUM) {
                code.append("const jsExecutor = getDriver() as unknown as IJavaScriptExecutor;\n");
                
                if (parameters != null && !parameters.isEmpty()) {
                    code.append("const result = await jsExecutor.executeScript(`").append(escapeTypeScriptString(script)).append("`, scriptParams);\n");
                } else {
                    code.append("const result = await jsExecutor.executeScript(`").append(escapeTypeScriptString(script)).append("`);\n");
                }
            } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
                code.append("const result = await getPage().evaluate(`").append(escapeTypeScriptString(script)).append("`);\n");
            }
            
            // Store result if required
            String resultVariable = actionConfig.getProperty("resultVariable") != null ? 
                    (String) actionConfig.getProperty("resultVariable") : null;
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("// Store result in variable\n");
                code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(resultVariable)).append("\", result);");
            }
        } else if (scriptType.equals("TYPESCRIPT")) {
            code.append("// TypeScript execution\n");
            
            // Generate parameters
            if (parameters != null && !parameters.isEmpty()) {
                for (Map<String, String> parameter : parameters) {
                    String name = parameter.get("name");
                    String value = parameter.get("value");
                    String type = parameter.get("type");
                    
                    if (name != null && value != null) {
                        if (type != null && !type.isEmpty()) {
                            code.append("const ").append(name).append(": ").append(type).append(" = ");
                        } else {
                            code.append("const ").append(name).append(" = ");
                        }
                        
                        // Handle different types
                        if (type != null) {
                            if (type.equals("string")) {
                                code.append("\"").append(escapeTypeScriptString(value)).append("\";\n");
                            } else if (type.equals("number")) {
                                code.append(value).append(";\n");
                            } else if (type.equals("boolean")) {
                                code.append(value).append(";\n");
                            } else if (type.startsWith("Array") || type.startsWith("array")) {
                                code.append(value).append(";\n");
                            } else if (type.startsWith("Record") || type.startsWith("object")) {
                                code.append(value).append(";\n");
                            } else {
                                code.append(value).append(";\n");
                            }
                        } else {
                            // Try to infer type
                            if (value.startsWith("\"") || value.startsWith("'") || value.startsWith("`")) {
                                code.append(value).append(";\n");
                            } else if (value.equals("true") || value.equals("false")) {
                                code.append(value).append(";\n");
                            } else if (value.matches("\\d+(\\.\\d+)?")) {
                                code.append(value).append(";\n");
                            } else if (value.startsWith("[") && value.endsWith("]")) {
                                code.append(value).append(";\n");
                            } else if (value.startsWith("{") && value.endsWith("}")) {
                                code.append(value).append(";\n");
                            } else {
                                code.append("\"").append(escapeTypeScriptString(value)).append("\";\n");
                            }
                        }
                    }
                }
                code.append("\n");
            }
            
            // Generate main script execution
            code.append("// Execute custom TypeScript code\n");
            code.append("(async () => {\n");
            
            // Split script into lines and add proper indentation
            String[] scriptLines = script.split("\n");
            for (String line : scriptLines) {
                code.append("    ").append(line).append("\n");
            }
            
            code.append("})();\n");
            
            // Store result if needed - for TypeScript custom actions, the script needs to handle storing
            // the result in TestContext directly using TestContext.getInstance().setVariable()
        } else if (scriptType.equals("NODE")) {
            code.append("// Node.js execution\n");
            
            // Generate parameters
            if (parameters != null && !parameters.isEmpty()) {
                for (Map<String, String> parameter : parameters) {
                    String name = parameter.get("name");
                    String value = parameter.get("value");
                    
                    if (name != null && value != null) {
                        code.append("const ").append(name).append(" = ");
                        
                        // Try to infer type
                        if (value.startsWith("\"") || value.startsWith("'") || value.startsWith("`")) {
                            code.append(value).append(";\n");
                        } else if (value.equals("true") || value.equals("false")) {
                            code.append(value).append(";\n");
                        } else if (value.matches("\\d+(\\.\\d+)?")) {
                            code.append(value).append(";\n");
                        } else if (value.startsWith("[") && value.endsWith("]")) {
                            code.append(value).append(";\n");
                        } else if (value.startsWith("{") && value.endsWith("}")) {
                            code.append(value).append(";\n");
                        } else {
                            code.append("\"").append(escapeTypeScriptString(value)).append("\";\n");
                        }
                    }
                }
                code.append("\n");
            }
            
            // Generate require statements for common modules
            code.append("const fs = require('fs');\n");
            code.append("const path = require('path');\n");
            code.append("const os = require('os');\n");
            code.append("const child_process = require('child_process');\n");
            code.append("const util = require('util');\n");
            code.append("\n");
            
            // Generate main script execution
            code.append("// Execute Node.js script\n");
            code.append("(async () => {\n");
            
            // Split script into lines and add proper indentation
            String[] scriptLines = script.split("\n");
            for (String line : scriptLines) {
                code.append("    ").append(line).append("\n");
            }
            
            code.append("})();\n");
        } else if (scriptType.equals("HTTP")) {
            code.append("// HTTP request execution\n");
            
            // Generate HTTP client
            code.append("const fetchData = async (url: string, options: any = {}) => {\n");
            code.append("    try {\n");
            code.append("        const response = await fetch(url, options);\n");
            code.append("        if (!response.ok) {\n");
            code.append("            throw new Error(`HTTP error ${response.status}: ${response.statusText}`);\n");
            code.append("        }\n");
            code.append("        return await response.json();\n");
            code.append("    } catch (error) {\n");
            code.append("        console.error('Fetch error:', error);\n");
            code.append("        throw error;\n");
            code.append("    }\n");
            code.append("};\n\n");
            
            // Handle parameters for HTTP request
            String url = null;
            String method = "GET";
            String body = null;
            Map<String, String> headers = new HashMap<>();
            
            if (parameters != null && !parameters.isEmpty()) {
                for (Map<String, String> parameter : parameters) {
                    String name = parameter.get("name");
                    String value = parameter.get("value");
                    
                    if (name != null && value != null) {
                        if (name.equalsIgnoreCase("url")) {
                            url = value;
                        } else if (name.equalsIgnoreCase("method")) {
                            method = value;
                        } else if (name.equalsIgnoreCase("body")) {
                            body = value;
                        } else if (name.startsWith("header_")) {
                            String headerName = name.substring(7); // Remove "header_" prefix
                            headers.put(headerName, value);
                        }
                    }
                }
            }
            
            // Create request options
            code.append("const requestOptions: RequestInit = {\n");
            code.append("    method: \"").append(escapeTypeScriptString(method)).append("\",\n");
            
            if (!headers.isEmpty()) {
                code.append("    headers: {\n");
                for (Map.Entry<String, String> entry : headers.entrySet()) {
                    code.append("        \"").append(escapeTypeScriptString(entry.getKey())).append("\": \"")
                            .append(escapeTypeScriptString(entry.getValue())).append("\",\n");
                }
                code.append("    },\n");
            }
            
            if (body != null && !body.isEmpty() && !method.equalsIgnoreCase("GET") && !method.equalsIgnoreCase("HEAD")) {
                // Try to determine if it's JSON or form data
                if (body.trim().startsWith("{") && body.trim().endsWith("}")) {
                    code.append("    body: JSON.stringify(").append(body).append("),\n");
                    
                    // Add content-type header if not present
                    if (!headers.containsKey("Content-Type") && !headers.containsKey("content-type")) {
                        code.append("    headers: { ...requestOptions.headers, \"Content-Type\": \"application/json\" },\n");
                    }
                } else {
                    code.append("    body: \"").append(escapeTypeScriptString(body)).append("\",\n");
                }
            }
            
            code.append("};\n\n");
            
            // Execute request
            if (url != null && !url.isEmpty()) {
                code.append("// Execute HTTP request\n");
                code.append("const result = await fetchData(\"").append(escapeTypeScriptString(url)).append("\", requestOptions);\n");
                
                // Store result if required
                String resultVariable = actionConfig.getProperty("resultVariable") != null ? 
                        (String) actionConfig.getProperty("resultVariable") : null;
                if (resultVariable != null && !resultVariable.isEmpty()) {
                    code.append("// Store result in variable\n");
                    code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(resultVariable)).append("\", result);");
                }
            } else {
                code.append("// Error: URL is missing\n");
                code.append("throw new Error(\"URL is required for HTTP request\");");
            }
        } else {
            code.append("// Unsupported script type: ").append(scriptType).append("\n");
            code.append("throw new Error(\"Unsupported script type: ").append(escapeTypeScriptString(scriptType)).append("\");");
        }
    }

/**
     * Generate Java code for a variable action.
     */
    private void generateJavaVariableCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String variableName = (String) actionConfig.getProperty("variableName");
        String variableType = (String) actionConfig.getProperty("variableType");
        String value = (String) actionConfig.getProperty("value");
        String scope = (String) actionConfig.getProperty("scope");
        
        code.append("// Variable declaration\n");
        
        if (scope == null || scope.isEmpty() || scope.equals("LOCAL")) {
            // Local variable declaration
            if (variableType.equals("String")) {
                code.append("String ").append(variableName).append(" = \"").append(escapeJavaString(value)).append("\";");
            } else if (variableType.equals("int") || variableType.equals("Integer")) {
                code.append("int ").append(variableName).append(" = ").append(value).append(";");
            } else if (variableType.equals("double") || variableType.equals("Double")) {
                code.append("double ").append(variableName).append(" = ").append(value).append(";");
            } else if (variableType.equals("boolean") || variableType.equals("Boolean")) {
                code.append("boolean ").append(variableName).append(" = ").append(value).append(";");
            } else if (variableType.equals("long") || variableType.equals("Long")) {
                code.append("long ").append(variableName).append(" = ").append(value).append("L;");
            } else if (variableType.equals("float") || variableType.equals("Float")) {
                code.append("float ").append(variableName).append(" = ").append(value).append("f;");
            } else {
                code.append("Object ").append(variableName).append(" = ").append(value).append(";");
            }
        } else if (scope.equals("TEST_CONTEXT")) {
            // Test context variable declaration
            code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(variableName)).append("\", ");
            
            if (variableType.equals("String")) {
                code.append("\"").append(escapeJavaString(value)).append("\"");
            } else if (variableType.equals("int") || variableType.equals("Integer")) {
                code.append("Integer.valueOf(").append(value).append(")");
            } else if (variableType.equals("double") || variableType.equals("Double")) {
                code.append("Double.valueOf(").append(value).append(")");
            } else if (variableType.equals("boolean") || variableType.equals("Boolean")) {
                code.append("Boolean.valueOf(").append(value).append(")");
            } else if (variableType.equals("long") || variableType.equals("Long")) {
                code.append("Long.valueOf(").append(value).append(")");
            } else if (variableType.equals("float") || variableType.equals("Float")) {
                code.append("Float.valueOf(").append(value).append(")");
            } else {
                code.append(value);
            }
            
            code.append(");");
        } else if (scope.equals("GLOBAL")) {
            // Global variable declaration
            code.append("GlobalVariableManager.getInstance().setVariable(\"").append(escapeJavaString(variableName)).append("\", ");
            
            if (variableType.equals("String")) {
                code.append("\"").append(escapeJavaString(value)).append("\"");
            } else if (variableType.equals("int") || variableType.equals("Integer")) {
                code.append("Integer.valueOf(").append(value).append(")");
            } else if (variableType.equals("double") || variableType.equals("Double")) {
                code.append("Double.valueOf(").append(value).append(")");
            } else if (variableType.equals("boolean") || variableType.equals("Boolean")) {
                code.append("Boolean.valueOf(").append(value).append(")");
            } else if (variableType.equals("long") || variableType.equals("Long")) {
                code.append("Long.valueOf(").append(value).append(")");
            } else if (variableType.equals("float") || variableType.equals("Float")) {
                code.append("Float.valueOf(").append(value).append(")");
            } else {
                code.append(value);
            }
            
            code.append(");");
        }
    }
    
    /**
     * Generate TypeScript code for a variable action.
     */
    private void generateTypeScriptVariableCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String variableName = (String) actionConfig.getProperty("variableName");
        String variableType = (String) actionConfig.getProperty("variableType");
        String value = (String) actionConfig.getProperty("value");
        String scope = (String) actionConfig.getProperty("scope");
        
        code.append("// Variable declaration\n");
        
        if (scope == null || scope.isEmpty() || scope.equals("LOCAL")) {
            // Local variable declaration
            if (variableType.equals("string")) {
                code.append("const ").append(variableName).append(": string = \"").append(escapeTypeScriptString(value)).append("\";");
            } else if (variableType.equals("number")) {
                code.append("const ").append(variableName).append(": number = ").append(value).append(";");
            } else if (variableType.equals("boolean")) {
                code.append("const ").append(variableName).append(": boolean = ").append(value).append(";");
            } else if (variableType.equals("any")) {
                code.append("const ").append(variableName).append(": any = ").append(value).append(";");
            } else {
                code.append("const ").append(variableName).append(": ").append(variableType).append(" = ").append(value).append(";");
            }
        } else if (scope.equals("TEST_CONTEXT")) {
            // Test context variable declaration
            code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(variableName)).append("\", ");
            
            if (variableType.equals("string")) {
                code.append("\"").append(escapeTypeScriptString(value)).append("\"");
            } else {
                code.append(value);
            }
            
            code.append(");");
        } else if (scope.equals("GLOBAL")) {
            // Global variable declaration
            code.append("GlobalVariableManager.getInstance().setVariable(\"").append(escapeTypeScriptString(variableName)).append("\", ");
            
            if (variableType.equals("string")) {
                code.append("\"").append(escapeTypeScriptString(value)).append("\"");
            } else {
                code.append(value);
            }
            
            code.append(");");
        }
    }
    
    /**
     * Generate Java code for a screenshot action.
     */
    private void generateJavaScreenshotCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String fileName = (String) actionConfig.getProperty("fileName");
        String element = (String) actionConfig.getProperty("element");
        String elementLocatorType = (String) actionConfig.getProperty("elementLocatorType");
        Boolean fullPage = (Boolean) actionConfig.getProperty("fullPage", false);
        String directory = (String) actionConfig.getProperty("directory");
        
        code.append("// Capture screenshot\n");
        
        if (fullPage) {
            code.append("CSScreenshotManager.captureFullPageScreenshot(");
        } else if (element != null && !element.isEmpty() && elementLocatorType != null && !elementLocatorType.isEmpty()) {
            code.append("CSElement elementToCapture = getCSElement(").append(getLocatorCode(elementLocatorType, element, LanguageType.JAVA)).append(");\n");
            code.append("CSScreenshotManager.captureElementScreenshot(elementToCapture, ");
        } else {
            code.append("CSScreenshotManager.captureScreenshot(");
        }
        
        if (fileName != null && !fileName.isEmpty()) {
            code.append("\"").append(escapeJavaString(fileName)).append("\"");
        } else {
            code.append("\"screenshot_\" + CSDateUtils.getCurrentTimeStamp()");
        }
        
        if (directory != null && !directory.isEmpty()) {
            code.append(", \"").append(escapeJavaString(directory)).append("\"");
        }
        
        code.append(");");
    }
    
    /**
     * Generate TypeScript code for a screenshot action.
     */
    private void generateTypeScriptScreenshotCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String fileName = (String) actionConfig.getProperty("fileName");
        String element = (String) actionConfig.getProperty("element");
        String elementLocatorType = (String) actionConfig.getProperty("elementLocatorType");
        Boolean fullPage = (Boolean) actionConfig.getProperty("fullPage", false);
        String directory = (String) actionConfig.getProperty("directory");
        
        code.append("// Capture screenshot\n");
        
        if (fullPage) {
            code.append("await CSScreenshotManager.captureFullPageScreenshot(");
        } else if (element != null && !element.isEmpty() && elementLocatorType != null && !elementLocatorType.isEmpty()) {
            code.append("const elementToCapture = getCSElement(").append(getLocatorCode(elementLocatorType, element, LanguageType.TYPESCRIPT)).append(");\n");
            code.append("await CSScreenshotManager.captureElementScreenshot(elementToCapture, ");
        } else {
            code.append("await CSScreenshotManager.captureScreenshot(");
        }
        
        if (fileName != null && !fileName.isEmpty()) {
            code.append("\"").append(escapeTypeScriptString(fileName)).append("\"");
        } else {
            code.append("`screenshot_${CSDateUtils.getCurrentTimeStamp()}`");
        }
        
        if (directory != null && !directory.isEmpty()) {
            code.append(", \"").append(escapeTypeScriptString(directory)).append("\"");
        }
        
        code.append(");");
    }
    
    /**
     * Generate Java code for a hover action.
     */
    private void generateJavaHoverCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Hover over element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.hover();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.hover();");
        }
    }
    
    /**
     * Generate TypeScript code for a hover action.
     */
    private void generateTypeScriptHoverCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// Hover over element\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.hover();");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.hover();");
        }
    }
    
    /**
     * Generate Java code for a drag and drop action.
     */
    private void generateJavaDragDropCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String sourceLocator = (String) actionConfig.getProperty("sourceLocator");
        String sourceLocatorType = (String) actionConfig.getProperty("sourceLocatorType");
        String targetLocator = (String) actionConfig.getProperty("targetLocator");
        String targetLocatorType = (String) actionConfig.getProperty("targetLocatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElements = (Boolean) actionConfig.getProperty("waitForElements", true);
        
        code.append("// Drag and drop\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElements) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.JAVA)).append(", waitStrategy);\n");
                code.append("CSElement targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.JAVA)).append(");\n");
                code.append("CSElement targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.JAVA)).append(");\n");
            }
            code.append("sourceElement.dragAndDropTo(targetElement);");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElements) {
                code.append("CSElement sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.JAVA)).append(");\n");
                code.append("sourceElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("CSElement targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.JAVA)).append(");\n");
                code.append("targetElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.JAVA)).append(");\n");
                code.append("CSElement targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.JAVA)).append(");\n");
            }
            code.append("sourceElement.dragAndDropTo(targetElement);");
        }
    }
    
    /**
     * Generate TypeScript code for a drag and drop action.
     */
    private void generateTypeScriptDragDropCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String sourceLocator = (String) actionConfig.getProperty("sourceLocator");
        String sourceLocatorType = (String) actionConfig.getProperty("sourceLocatorType");
        String targetLocator = (String) actionConfig.getProperty("targetLocator");
        String targetLocatorType = (String) actionConfig.getProperty("targetLocatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElements = (Boolean) actionConfig.getProperty("waitForElements", true);
        
        code.append("// Drag and drop\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElements) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                code.append("const targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("const targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await sourceElement.dragAndDropTo(targetElement);");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElements) {
                code.append("const sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await sourceElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("const targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await targetElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const sourceElement = getCSElement(").append(getLocatorCode(sourceLocatorType, sourceLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("const targetElement = getCSElement(").append(getLocatorCode(targetLocatorType, targetLocator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await sourceElement.dragAndDropTo(targetElement);");
        }
    }
    
    /**
     * Generate Java code for a switch frame action.
     */
    private void generateJavaSwitchFrameCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String frameLocator = (String) actionConfig.getProperty("frameLocator");
        String frameLocatorType = (String) actionConfig.getProperty("frameLocatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean switchToDefault = (Boolean) actionConfig.getProperty("switchToDefault", false);
        Boolean switchToParent = (Boolean) actionConfig.getProperty("switchToParent", false);
        
        code.append("// Switch frame\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (switchToDefault) {
                code.append("getDriver().switchTo().defaultContent();");
            } else if (switchToParent) {
                code.append("getDriver().switchTo().parentFrame();");
            } else if (frameLocatorType != null && frameLocatorType.equals("INDEX")) {
                code.append("getDriver().switchTo().frame(").append(frameLocator).append(");");
            } else {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement frameElement = getCSElement(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.JAVA)).append(", waitStrategy);\n");
                code.append("getDriver().switchTo().frame(frameElement.getWebElement());");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (switchToDefault) {
                code.append("getPage().setFrameByUrl(\"\");");
            } else if (switchToParent) {
                code.append("getPage().setFrameByUrl(\"\");");
            } else if (frameLocatorType != null && frameLocatorType.equals("INDEX")) {
                code.append("getPage().frame(").append(frameLocator).append(");");
            } else {
                code.append("CSElement frameElement = getCSElement(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.JAVA)).append(");\n");
                code.append("frameElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("getPage().frameLocator(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.JAVA)).append(").first();");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a switch frame action.
     */
    private void generateTypeScriptSwitchFrameCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String frameLocator = (String) actionConfig.getProperty("frameLocator");
        String frameLocatorType = (String) actionConfig.getProperty("frameLocatorType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean switchToDefault = (Boolean) actionConfig.getProperty("switchToDefault", false);
        Boolean switchToParent = (Boolean) actionConfig.getProperty("switchToParent", false);
        
        code.append("// Switch frame\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (switchToDefault) {
                code.append("await getDriver().switchTo().defaultContent();");
            } else if (switchToParent) {
                code.append("await getDriver().switchTo().parentFrame();");
            } else if (frameLocatorType != null && frameLocatorType.equals("INDEX")) {
                code.append("await getDriver().switchTo().frame(").append(frameLocator).append(");");
            } else {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const frameElement = getCSElement(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                code.append("await getDriver().switchTo().frame(await frameElement.getWebElement());");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (switchToDefault) {
                code.append("await getPage().setFrameByUrl(\"\");");
            } else if (switchToParent) {
                code.append("await getPage().setFrameByUrl(\"\");");
            } else if (frameLocatorType != null && frameLocatorType.equals("INDEX")) {
                code.append("await getPage().frame(").append(frameLocator).append(");");
            } else {
                code.append("const frameElement = getCSElement(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await frameElement.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("await getPage().frameLocator(").append(getLocatorCode(frameLocatorType, frameLocator, LanguageType.TYPESCRIPT)).append(").first();");
            }
        }
    }
    
    /**
     * Generate Java code for a switch window action.
     */
    private void generateJavaSwitchWindowCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String windowHandle = (String) actionConfig.getProperty("windowHandle");
        Integer windowIndex = (Integer) actionConfig.getProperty("windowIndex");
        String windowTitle = (String) actionConfig.getProperty("windowTitle");
        String windowUrl = (String) actionConfig.getProperty("windowUrl");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Switch window\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (windowHandle != null && !windowHandle.isEmpty()) {
                code.append("getDriver().switchTo().window(\"").append(escapeJavaString(windowHandle)).append("\");");
            } else if (windowIndex != null) {
                code.append("List<String> windowHandles = new ArrayList<>(getDriver().getWindowHandles());\n");
                code.append("if (windowHandles.size() > ").append(windowIndex).append(") {\n");
                code.append("    getDriver().switchTo().window(windowHandles.get(").append(windowIndex).append("));\n");
                code.append("}");
            } else if (windowTitle != null && !windowTitle.isEmpty()) {
                code.append("String originalHandle = getDriver().getWindowHandle();\n");
                code.append("for (String handle : getDriver().getWindowHandles()) {\n");
                code.append("    getDriver().switchTo().window(handle);\n");
                code.append("    if (getDriver().getTitle().equals(\"").append(escapeJavaString(windowTitle)).append("\")) {\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
            } else if (windowUrl != null && !windowUrl.isEmpty()) {
                code.append("String originalHandle = getDriver().getWindowHandle();\n");
                code.append("for (String handle : getDriver().getWindowHandles()) {\n");
                code.append("    getDriver().switchTo().window(handle);\n");
                code.append("    if (getDriver().getCurrentUrl().contains(\"").append(escapeJavaString(windowUrl)).append("\")) {\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (windowIndex != null) {
                code.append("List<Page> pages = getContext().pages();\n");
                code.append("if (pages.size() > ").append(windowIndex).append(") {\n");
                code.append("    setPage(pages.get(").append(windowIndex).append("));\n");
                code.append("}");
            } else if (windowTitle != null && !windowTitle.isEmpty()) {
                code.append("for (Page page : getContext().pages()) {\n");
                code.append("    if (page.title().equals(\"").append(escapeJavaString(windowTitle)).append("\")) {\n");
                code.append("        setPage(page);\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
            } else if (windowUrl != null && !windowUrl.isEmpty()) {
                code.append("for (Page page : getContext().pages()) {\n");
                code.append("    if (page.url().contains(\"").append(escapeJavaString(windowUrl)).append("\")) {\n");
                code.append("        setPage(page);\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a switch window action.
     */
    private void generateTypeScriptSwitchWindowCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String windowHandle = (String) actionConfig.getProperty("windowHandle");
        Integer windowIndex = (Integer) actionConfig.getProperty("windowIndex");
        String windowTitle = (String) actionConfig.getProperty("windowTitle");
        String windowUrl = (String) actionConfig.getProperty("windowUrl");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Switch window\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (windowHandle != null && !windowHandle.isEmpty()) {
                code.append("await getDriver().switchTo().window(\"").append(escapeTypeScriptString(windowHandle)).append("\");");
            } else if (windowIndex != null) {
                code.append("const windowHandles = await getDriver().getAllWindowHandles();\n");
                code.append("if (windowHandles.length > ").append(windowIndex).append(") {\n");
                code.append("    await getDriver().switchTo().window(windowHandles[").append(windowIndex).append("]);\n");
                code.append("}");
            } else if (windowTitle != null && !windowTitle.isEmpty()) {
                code.append("const originalHandle = await getDriver().getWindowHandle();\n");
                code.append("const windowHandles = await getDriver().getAllWindowHandles();\n");
                code.append("for (const handle of windowHandles) {\n");
                code.append("    await getDriver().switchTo().window(handle);\n");
                code.append("    const title = await getDriver().getTitle();\n");
                code.append("    if (title === \"").append(escapeTypeScriptString(windowTitle)).append("\") {\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
            } else if (windowUrl != null && !windowUrl.isEmpty()) {
                code.append("const originalHandle = await getDriver().getWindowHandle();\n");
                code.append("const windowHandles = await getDriver().getAllWindowHandles();\n");
                code.append("for (const handle of windowHandles) {\n");
                code.append("    await getDriver().switchTo().window(handle);\n");
                code.append("    const url = await getDriver().getCurrentUrl();\n");
                code.append("    if (url.includes(\"").append(escapeTypeScriptString(windowUrl)).append("\")) {\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (windowIndex != null) {
                code.append("const pages = getContext().pages();\n");
                code.append("if (pages.length > ").append(windowIndex).append(") {\n");
                code.append("    setPage(pages[").append(windowIndex).append("]);\n");
                code.append("}");
            } else if (windowTitle != null && !windowTitle.isEmpty()) {
                code.append("for (const page of getContext().pages()) {\n");
                code.append("    const title = await page.title();\n");
                code.append("    if (title === \"").append(escapeTypeScriptString(windowTitle)).append("\") {\n");
                code.append("        setPage(page);\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
            } else if (windowUrl != null && !windowUrl.isEmpty()) {
                code.append("for (const page of getContext().pages()) {\n");
                code.append("    const url = page.url();\n");
                code.append("    if (url.includes(\"").append(escapeTypeScriptString(windowUrl)).append("\")) {\n");
                code.append("        setPage(page);\n");
                code.append("        break;\n");
                code.append("    }\n");
                code.append("}\n");
            }
        }
    }
    
    /**
     * Generate Java code for an execute script action.
     */
    private void generateJavaExecuteScriptCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String script = (String) actionConfig.getProperty("script");
        List<String> arguments = (List<String>) actionConfig.getProperty("arguments");
        String resultVariable = (String) actionConfig.getProperty("resultVariable");
        
        code.append("// Execute script\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            code.append("JavascriptExecutor jsExecutor = (JavascriptExecutor) getDriver();\n");
            
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("Object ").append(resultVariable).append(" = jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\"");
            } else {
                code.append("jsExecutor.executeScript(\"").append(escapeJavaString(script)).append("\"");
            }
            
            if (arguments != null && !arguments.isEmpty()) {
                for (String argument : arguments) {
                    code.append(", ").append(argument);
                }
            }
            
            code.append(");");
            
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("\n");
                code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(resultVariable)).append("\", ").append(resultVariable).append(");");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("Object ").append(resultVariable).append(" = getPage().evaluate(\"").append(escapeJavaString(script)).append("\"");
            } else {
                code.append("getPage().evaluate(\"").append(escapeJavaString(script)).append("\"");
            }
            
            if (arguments != null && !arguments.isEmpty()) {
                for (String argument : arguments) {
                    code.append(", ").append(argument);
                }
            }
            
            code.append(");");
            
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("\n");
                code.append("TestContext.getInstance().setVariable(\"").append(escapeJavaString(resultVariable)).append("\", ").append(resultVariable).append(");");
            }
        }
    }
    
    /**
     * Generate TypeScript code for an execute script action.
     */
    private void generateTypeScriptExecuteScriptCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String script = (String) actionConfig.getProperty("script");
        List<String> arguments = (List<String>) actionConfig.getProperty("arguments");
        String resultVariable = (String) actionConfig.getProperty("resultVariable");
        
        code.append("// Execute script\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("const ").append(resultVariable).append(" = await getDriver().executeScript(`").append(escapeTypeScriptString(script)).append("`");
            } else {
                code.append("await getDriver().executeScript(`").append(escapeTypeScriptString(script)).append("`");
            }
            
            if (arguments != null && !arguments.isEmpty()) {
                for (String argument : arguments) {
                    code.append(", ").append(argument);
                }
            }
            
            code.append(");");
            
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("\n");
                code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(resultVariable)).append("\", ").append(resultVariable).append(");");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("const ").append(resultVariable).append(" = await getPage().evaluate(`").append(escapeTypeScriptString(script)).append("`");
            } else {
                code.append("await getPage().evaluate(`").append(escapeTypeScriptString(script)).append("`");
            }
            
            if (arguments != null && !arguments.isEmpty()) {
                for (String argument : arguments) {
                    code.append(", ").append(argument);
                }
            }
            
            code.append(");");
            
            if (resultVariable != null && !resultVariable.isEmpty()) {
                code.append("\n");
                code.append("TestContext.getInstance().setVariable(\"").append(escapeTypeScriptString(resultVariable)).append("\", ").append(resultVariable).append(");");
            }
        }
    }
    
    /**
     * Generate Java code for a file upload action.
     */
    private void generateJavaFileUploadCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String filePath = (String) actionConfig.getProperty("filePath");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// File upload\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.sendKeys(\"").append(escapeJavaString(filePath)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
            }
            code.append("element.setInputFiles(\"").append(escapeJavaString(filePath)).append("\");");
        }
    }
    
    /**
     * Generate TypeScript code for a file upload action.
     */
    private void generateTypeScriptFileUploadCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String filePath = (String) actionConfig.getProperty("filePath");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        Boolean waitForElement = (Boolean) actionConfig.getProperty("waitForElement", true);
        
        code.append("// File upload\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (waitForElement) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.sendKeys(\"").append(escapeTypeScriptString(filePath)).append("\");");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (waitForElement) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
            } else {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
            }
            code.append("await element.setInputFiles(\"").append(escapeTypeScriptString(filePath)).append("\");");
        }
    }
    
    /**
     * Generate Java code for a key press action.
     */
    private void generateJavaKeyPressCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String key = (String) actionConfig.getProperty("key");
        List<String> modifiers = (List<String>) actionConfig.getProperty("modifiers");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Key press\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
                
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("Actions actions = new Actions(getDriver());\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("actions.keyDown(Keys.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("actions.keyDown(Keys.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("actions.keyDown(Keys.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("actions.keyDown(Keys.COMMAND);\n");
                        }
                    }
                    
                    code.append("actions.sendKeys(element.getWebElement(), Keys.").append(key).append(");\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("actions.keyUp(Keys.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("actions.keyUp(Keys.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("actions.keyUp(Keys.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("actions.keyUp(Keys.COMMAND);\n");
                        }
                    }
                    
                    code.append("actions.perform();");
                } else {
                    code.append("element.sendKeys(Keys.").append(key).append(");");
                }
            } else {
                code.append("Actions actions = new Actions(getDriver());\n");
                
                if (modifiers != null && !modifiers.isEmpty()) {
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("actions.keyDown(Keys.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("actions.keyDown(Keys.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("actions.keyDown(Keys.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("actions.keyDown(Keys.COMMAND);\n");
                        }
                    }
                    
                    code.append("actions.sendKeys(Keys.").append(key).append(");\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("actions.keyUp(Keys.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("actions.keyUp(Keys.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("actions.keyUp(Keys.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("actions.keyUp(Keys.COMMAND);\n");
                        }
                    }
                } else {
                    code.append("actions.sendKeys(Keys.").append(key).append(");\n");
                }
                
                code.append("actions.perform();");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("List<KeyboardModifier> keyModifiers = new ArrayList<>();\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("keyModifiers.add(KeyboardModifier.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("keyModifiers.add(KeyboardModifier.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("keyModifiers.add(KeyboardModifier.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("keyModifiers.add(KeyboardModifier.META);\n");
                        }
                    }
                    
                    code.append("element.press(\"").append(key.toLowerCase()).append("\", new PressOptions().setModifiers(keyModifiers));");
                } else {
                    code.append("element.press(\"").append(key.toLowerCase()).append("\");");
                }
            } else {
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("List<KeyboardModifier> keyModifiers = new ArrayList<>();\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("keyModifiers.add(KeyboardModifier.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("keyModifiers.add(KeyboardModifier.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("keyModifiers.add(KeyboardModifier.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("keyModifiers.add(KeyboardModifier.META);\n");
                        }
                    }
                    
                    code.append("getPage().keyboard().press(\"").append(key.toLowerCase()).append("\", new KeyboardPressOptions().setModifiers(keyModifiers));");
                } else {
                    code.append("getPage().keyboard().press(\"").append(key.toLowerCase()).append("\");");
                }
            }
        }
    }
    
    /**
     * Generate TypeScript code for a key press action.
     */
    private void generateTypeScriptKeyPressCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        String key = (String) actionConfig.getProperty("key");
        List<String> modifiers = (List<String>) actionConfig.getProperty("modifiers");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Key press\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("const actions = getDriver().actions();\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("await actions.keyDown(Key.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("await actions.keyDown(Key.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("await actions.keyDown(Key.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("await actions.keyDown(Key.COMMAND);\n");
                        }
                    }
                    
                    code.append("await actions.sendKeys(await element.getWebElement(), Key.").append(key).append(");\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("await actions.keyUp(Key.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("await actions.keyUp(Key.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("await actions.keyUp(Key.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("await actions.keyUp(Key.COMMAND);\n");
                        }
                    }
                    
                    code.append("await actions.perform();");
                } else {
                    code.append("await element.sendKeys(Key.").append(key).append(");");
                }
            } else {
                code.append("const actions = getDriver().actions();\n");
                
                if (modifiers != null && !modifiers.isEmpty()) {
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("await actions.keyDown(Key.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("await actions.keyDown(Key.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("await actions.keyDown(Key.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("await actions.keyDown(Key.COMMAND);\n");
                        }
                    }
                    
                    code.append("await actions.sendKeys(Key.").append(key).append(");\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("await actions.keyUp(Key.CONTROL);\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("await actions.keyUp(Key.ALT);\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("await actions.keyUp(Key.SHIFT);\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("await actions.keyUp(Key.COMMAND);\n");
                        }
                    }
                } else {
                    code.append("await actions.sendKeys(Key.").append(key).append(");\n");
                }
                
                code.append("await actions.perform();");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (locator != null && !locator.isEmpty() && locatorType != null && !locatorType.isEmpty()) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("const keyModifiers: KeyboardModifier[] = [];\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("keyModifiers.push('Control');\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("keyModifiers.push('Alt');\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("keyModifiers.push('Shift');\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("keyModifiers.push('Meta');\n");
                        }
                    }
                    
                    code.append("await element.press(\"").append(key.toLowerCase()).append("\", { modifiers: keyModifiers });");
                } else {
                    code.append("await element.press(\"").append(key.toLowerCase()).append("\");");
                }
            } else {
                if (modifiers != null && !modifiers.isEmpty()) {
                    code.append("const keyModifiers: KeyboardModifier[] = [];\n");
                    
                    for (String modifier : modifiers) {
                        if (modifier.equals("CONTROL") || modifier.equals("CTRL")) {
                            code.append("keyModifiers.push('Control');\n");
                        } else if (modifier.equals("ALT")) {
                            code.append("keyModifiers.push('Alt');\n");
                        } else if (modifier.equals("SHIFT")) {
                            code.append("keyModifiers.push('Shift');\n");
                        } else if (modifier.equals("COMMAND") || modifier.equals("META")) {
                            code.append("keyModifiers.push('Meta');\n");
                        }
                    }
                    
                    code.append("await getPage().keyboard.press(\"").append(key.toLowerCase()).append("\", { modifiers: keyModifiers });");
                } else {
                    code.append("await getPage().keyboard.press(\"").append(key.toLowerCase()).append("\");");
                }
            }
        }
    }
    
    /**
     * Generate Java code for a scroll action.
     */
    private void generateJavaScrollCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer x = (Integer) actionConfig.getProperty("x");
        Integer y = (Integer) actionConfig.getProperty("y");
        String scrollType = (String) actionConfig.getProperty("scrollType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Scroll\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            code.append("JavascriptExecutor jsExecutor = (JavascriptExecutor) getDriver();\n");
            
            if (scrollType.equals("PIXEL")) {
                code.append("jsExecutor.executeScript(\"window.scrollBy(").append(x).append(", ").append(y).append(")\");");
            } else if (scrollType.equals("ELEMENT")) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
                code.append("jsExecutor.executeScript(\"arguments[0].scrollIntoView(true);\", element.getWebElement());");
            } else if (scrollType.equals("TOP")) {
                code.append("jsExecutor.executeScript(\"window.scrollTo(0, 0)\");");
            } else if (scrollType.equals("BOTTOM")) {
                code.append("jsExecutor.executeScript(\"window.scrollTo(0, document.body.scrollHeight)\");");
            } else if (scrollType.equals("CENTER")) {
                code.append("CSWaitStrategy waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(", waitStrategy);\n");
                code.append("jsExecutor.executeScript(\"arguments[0].scrollIntoView({block: 'center', inline: 'center'});\", element.getWebElement());");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (scrollType.equals("PIXEL")) {
                code.append("getPage().evaluate(\"window.scrollBy(").append(x).append(", ").append(y).append(")\");");
            } else if (scrollType.equals("ELEMENT")) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("element.scrollIntoView();");
            } else if (scrollType.equals("TOP")) {
                code.append("getPage().evaluate(\"window.scrollTo(0, 0)\");");
            } else if (scrollType.equals("BOTTOM")) {
                code.append("getPage().evaluate(\"window.scrollTo(0, document.body.scrollHeight)\");");
            } else if (scrollType.equals("CENTER")) {
                code.append("CSElement element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.JAVA)).append(");\n");
                code.append("element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });");
            }
        }
    }
    
    /**
     * Generate TypeScript code for a scroll action.
     */
    private void generateTypeScriptScrollCode(StringBuilder code, ActionConfig actionConfig, 
            FrameworkType frameworkType, TestType testType) {
        
        String locator = (String) actionConfig.getProperty("locator");
        String locatorType = (String) actionConfig.getProperty("locatorType");
        Integer x = (Integer) actionConfig.getProperty("x");
        Integer y = (Integer) actionConfig.getProperty("y");
        String scrollType = (String) actionConfig.getProperty("scrollType");
        Integer timeout = (Integer) actionConfig.getProperty("timeout", 30);
        
        code.append("// Scroll\n");
        
        if (frameworkType == FrameworkType.SELENIUM) {
            if (scrollType.equals("PIXEL")) {
                code.append("await getDriver().executeScript(`window.scrollBy(").append(x).append(", ").append(y).append(")`);\n");
            } else if (scrollType.equals("ELEMENT")) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                code.append("await getDriver().executeScript(`arguments[0].scrollIntoView(true);`, await element.getWebElement());\n");
            } else if (scrollType.equals("TOP")) {
                code.append("await getDriver().executeScript(`window.scrollTo(0, 0)`);\n");
            } else if (scrollType.equals("BOTTOM")) {
                code.append("await getDriver().executeScript(`window.scrollTo(0, document.body.scrollHeight)`);\n");
            } else if (scrollType.equals("CENTER")) {
                code.append("const waitStrategy = CSWaitFactory.getWaitStrategy(CSWaitStrategyType.VISIBLE);\n");
                code.append("waitStrategy.setTimeout(").append(timeout).append(");\n");
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(", waitStrategy);\n");
                code.append("await getDriver().executeScript(`arguments[0].scrollIntoView({block: 'center', inline: 'center'});`, await element.getWebElement());\n");
            }
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            if (scrollType.equals("PIXEL")) {
                code.append("await getPage().evaluate(`window.scrollBy(").append(x).append(", ").append(y).append(")`);\n");
            } else if (scrollType.equals("ELEMENT")) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("await element.scrollIntoViewIfNeeded();\n");
            } else if (scrollType.equals("TOP")) {
                code.append("await getPage().evaluate(`window.scrollTo(0, 0)`);\n");
            } else if (scrollType.equals("BOTTOM")) {
                code.append("await getPage().evaluate(`window.scrollTo(0, document.body.scrollHeight)`);\n");
            } else if (scrollType.equals("CENTER")) {
                code.append("const element = getCSElement(").append(getLocatorCode(locatorType, locator, LanguageType.TYPESCRIPT)).append(");\n");
                code.append("await element.waitForElementToBeVisible(").append(timeout).append(" * 1000);\n");
                code.append("await element.scrollIntoViewIfNeeded({ behavior: 'smooth', block: 'center', inline: 'center' });\n");
            }
        }
    }
    
    /**
     * Get locator code based on locator type and value.
     * 
     * @param locatorType Locator type
     * @param locator Locator value
     * @param languageType Language type
     * @return Locator code
     */
    private String getLocatorCode(String locatorType, String locator, LanguageType languageType) {
        StringBuilder code = new StringBuilder();
        
        if (languageType == LanguageType.JAVA) {
            if (locatorType.equals("CSS")) {
                code.append("By.cssSelector(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("XPATH")) {
                code.append("By.xpath(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("ID")) {
                code.append("By.id(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("NAME")) {
                code.append("By.name(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("CLASS_NAME")) {
                code.append("By.className(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("TAG_NAME")) {
                code.append("By.tagName(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("LINK_TEXT")) {
                code.append("By.linkText(\"").append(escapeJavaString(locator)).append("\")");
            } else if (locatorType.equals("PARTIAL_LINK_TEXT")) {
                code.append("By.partialLinkText(\"").append(escapeJavaString(locator)).append("\")");
            } else {
                code.append("By.cssSelector(\"").append(escapeJavaString(locator)).append("\")");
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            if (locatorType.equals("CSS")) {
                code.append("By.css(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("XPATH")) {
                code.append("By.xpath(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("ID")) {
                code.append("By.id(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("NAME")) {
                code.append("By.name(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("CLASS_NAME")) {
                code.append("By.className(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("TAG_NAME")) {
                code.append("By.tagName(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("LINK_TEXT")) {
                code.append("By.linkText(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else if (locatorType.equals("PARTIAL_LINK_TEXT")) {
                code.append("By.partialLinkText(\"").append(escapeTypeScriptString(locator)).append("\")");
            } else {
                code.append("By.css(\"").append(escapeTypeScriptString(locator)).append("\")");
            }
        }
        
        return code.toString();
    }
    
    /**
     * Escape special characters in Java strings.
     * 
     * @param input Input string
     * @return Escaped string
     */
    private String escapeJavaString(String input) {
        if (input == null) {
            return "";
        }
        
        StringBuilder escaped = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            switch (c) {
                case '\"':
                    escaped.append("\\\"");
                    break;
                case '\\':
                    escaped.append("\\\\");
                    break;
                case '\b':
                    escaped.append("\\b");
                    break;
                case '\n':
                    escaped.append("\\n");
                    break;
                case '\t':
                    escaped.append("\\t");
                    break;
                case '\f':
                    escaped.append("\\f");
                    break;
                case '\r':
                    escaped.append("\\r");
                    break;
                default:
                    if (c < 32 || c > 126) {
                        escaped.append(String.format("\\u%04x", (int) c));
                    } else {
                        escaped.append(c);
                    }
            }
        }
        
        return escaped.toString();
    }
    
    /**
     * Escape special characters in TypeScript strings.
     * 
     * @param input Input string
     * @return Escaped string
     */
    private String escapeTypeScriptString(String input) {
        if (input == null) {
            return "";
        }
        
        StringBuilder escaped = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            switch (c) {
                case '\"':
                    escaped.append("\\\"");
                    break;
                case '\'':
                    escaped.append("\\\'");
                    break;
                case '\\':
                    escaped.append("\\\\");
                    break;
                case '\b':
                    escaped.append("\\b");
                    break;
                case '\n':
                    escaped.append("\\n");
                    break;
                case '\t':
                    escaped.append("\\t");
                    break;
                case '\f':
                    escaped.append("\\f");
                    break;
                case '\r':
                    escaped.append("\\r");
                    break;
                case '`':
                    escaped.append("\\`");
                    break;
                case '$':
                    escaped.append("\\$");
                    break;
                default:
                    if (c < 32 || c > 126) {
                        escaped.append(String.format("\\u%04x", (int) c));
                    } else {
                        escaped.append(c);
                    }
            }
        }
        
        return escaped.toString();
    }
    
    @Override
    public ActionConfig createActionTemplate(ActionConfig actionConfig) {
        if (actionConfig == null) {
            return null;
        }
        
        String templateName = (String) actionConfig.getProperty("templateName");
        if (CSTextUtils.isNullOrEmpty(templateName)) {
            templateName = "Template_" + UUID.randomUUID().toString().substring(0, 8);
            actionConfig.setProperty("templateName", templateName);
        }
        
        String templateDescription = (String) actionConfig.getProperty("templateDescription");
        if (CSTextUtils.isNullOrEmpty(templateDescription)) {
            templateDescription = "Template for " + actionConfig.getActionType().name() + " action";
            actionConfig.setProperty("templateDescription", templateDescription);
        }
        
        String templateId = actionConfig.getId();
        if (CSTextUtils.isNullOrEmpty(templateId)) {
            templateId = UUID.randomUUID().toString();
            actionConfig.setId(templateId);
        }
        
        actionConfig.setProperty("createdAt", LocalDateTime.now().toString());
        
        try {
            String templatePath = templatesDirectory + File.separator + templateId + ".json";
            storageService.saveObject(templatePath, actionConfig, null);
            
            templateCache.put(templateId, actionConfig);
            
            LOGGER.info("Created action template: {}", templateName);
            
            return actionConfig;
        } catch (Exception e) {
            LOGGER.error("Failed to create action template: {}", e.getMessage(), e);
            return null;
        }
    }
    
    @Override
    public ActionConfig updateActionTemplate(String templateId, ActionConfig updatedConfig) {
        if (templateId == null || updatedConfig == null) {
            return null;
        }
        
        ActionConfig existingTemplate = getActionTemplate(templateId);
        if (existingTemplate == null) {
            LOGGER.error("Template with ID {} not found", templateId);
            return null;
        }
        
        // Update properties
        String templateName = (String) updatedConfig.getProperty("templateName");
        if (!CSTextUtils.isNullOrEmpty(templateName)) {
            existingTemplate.setProperty("templateName", templateName);
        }
        
        String templateDescription = (String) updatedConfig.getProperty("templateDescription");
        if (!CSTextUtils.isNullOrEmpty(templateDescription)) {
            existingTemplate.setProperty("templateDescription", templateDescription);
        }
        
        // Update action-specific properties based on action type
        ActionType actionType = existingTemplate.getActionType();
        if (actionType != null) {
            switch (actionType) {
                case CLICK:
                case TYPE:
                case SELECT:
                case HOVER:
                    copyProperty(updatedConfig, existingTemplate, "locator");
                    copyProperty(updatedConfig, existingTemplate, "locatorType");
                    copyProperty(updatedConfig, existingTemplate, "timeout");
                    copyProperty(updatedConfig, existingTemplate, "waitForElement");
                    
                    if (actionType == ActionType.TYPE) {
                        copyProperty(updatedConfig, existingTemplate, "text");
                        copyProperty(updatedConfig, existingTemplate, "clearBefore");
                    } else if (actionType == ActionType.SELECT) {
                        copyProperty(updatedConfig, existingTemplate, "option");
                        copyProperty(updatedConfig, existingTemplate, "selectBy");
                    }
                    break;
                    
                case ASSERT:
                    if (existingTemplate instanceof AssertionActionConfig && updatedConfig instanceof AssertionActionConfig) {
                        AssertionActionConfig existingAssertConfig = (AssertionActionConfig) existingTemplate;
                        AssertionActionConfig updatedAssertConfig = (AssertionActionConfig) updatedConfig;
                        
                        if (updatedAssertConfig.getAssertionType() != null) {
                            existingAssertConfig.setAssertionType(updatedAssertConfig.getAssertionType());
                        }
                        
                        if (updatedAssertConfig.getLocator() != null) {
                            existingAssertConfig.setLocator(updatedAssertConfig.getLocator());
                        }
                        
                        if (updatedAssertConfig.getLocatorType() != null) {
                            existingAssertConfig.setLocatorType(updatedAssertConfig.getLocatorType());
                        }
                        
                        if (updatedAssertConfig.getExpectedValue() != null) {
                            existingAssertConfig.setExpectedValue(updatedAssertConfig.getExpectedValue());
                        }
                        
                        if (updatedAssertConfig.getActualValue() != null) {
                            existingAssertConfig.setActualValue(updatedAssertConfig.getActualValue());
                        }
                        
                        if (updatedAssertConfig.getTimeout() != null) {
                            existingAssertConfig.setTimeout(updatedAssertConfig.getTimeout());
                        }
                        
                        if (updatedAssertConfig.isFailOnAssertionError() != null) {
                            existingAssertConfig.setFailOnAssertionError(updatedAssertConfig.isFailOnAssertionError());
                        }
                    }
                    break;
                    
                case WAIT:
                    if (existingTemplate instanceof WaitActionConfig && updatedConfig instanceof WaitActionConfig) {
                        WaitActionConfig existingWaitConfig = (WaitActionConfig) existingTemplate;
                        WaitActionConfig updatedWaitConfig = (WaitActionConfig) updatedConfig;
                        
                        if (updatedWaitConfig.getWaitType() != null) {
                            existingWaitConfig.setWaitType(updatedWaitConfig.getWaitType());
                        }
                        
                        if (updatedWaitConfig.getLocator() != null) {
                            existingWaitConfig.setLocator(updatedWaitConfig.getLocator());
                        }
                        
                        if (updatedWaitConfig.getLocatorType() != null) {
                            existingWaitConfig.setLocatorType(updatedWaitConfig.getLocatorType());
                        }
                        
                        if (updatedWaitConfig.getTimeout() != null) {
                            existingWaitConfig.setTimeout(updatedWaitConfig.getTimeout());
                        }
                        
                        copyProperty(updatedConfig, existingTemplate, "pollingInterval");
                        copyProperty(updatedConfig, existingTemplate, "condition");
                    }
                    break;
                    
                case NAVIGATE:
                    copyProperty(updatedConfig, existingTemplate, "url");
                    copyProperty(updatedConfig, existingTemplate, "waitForLoad");
                    copyProperty(updatedConfig, existingTemplate, "timeout");
                    break;
                    
                case CONDITIONAL:
                    if (existingTemplate instanceof ConditionalActionConfig && updatedConfig instanceof ConditionalActionConfig) {
                        ConditionalActionConfig existingCondConfig = (ConditionalActionConfig) existingTemplate;
                        ConditionalActionConfig updatedCondConfig = (ConditionalActionConfig) updatedConfig;
                        
                        if (updatedCondConfig.getCondition() != null) {
                            existingCondConfig.setCondition(updatedCondConfig.getCondition());
                        }
                        
                        if (updatedCondConfig.getOperator() != null) {
                            existingCondConfig.setOperator(updatedCondConfig.getOperator());
                        }
                        
                        if (updatedCondConfig.getLeftOperand() != null) {
                            existingCondConfig.setLeftOperand(updatedCondConfig.getLeftOperand());
                        }
                        
                        if (updatedCondConfig.getRightOperand() != null) {
                            existingCondConfig.setRightOperand(updatedCondConfig.getRightOperand());
                        }
                        
                        if (updatedCondConfig.getNestedActions() != null && !updatedCondConfig.getNestedActions().isEmpty()) {
                            existingCondConfig.setNestedActions(updatedCondConfig.getNestedActions());
                        }
                        
                        if (updatedCondConfig.getElseActions() != null && !updatedCondConfig.getElseActions().isEmpty()) {
                            existingCondConfig.setElseActions(updatedCondConfig.getElseActions());
                        }
                    }
                    break;
                    
                case LOOP:
                    if (existingTemplate instanceof LoopActionConfig && updatedConfig instanceof LoopActionConfig) {
                        LoopActionConfig existingLoopConfig = (LoopActionConfig) existingTemplate;
                        LoopActionConfig updatedLoopConfig = (LoopActionConfig) updatedConfig;
                        
                        if (updatedLoopConfig.getLoopType() != null) {
                            existingLoopConfig.setLoopType(updatedLoopConfig.getLoopType());
                        }
                        
                        if (updatedLoopConfig.getTimes() != null) {
                            existingLoopConfig.setTimes(updatedLoopConfig.getTimes());
                        }
                        
                        if (updatedLoopConfig.getCollection() != null) {
                            existingLoopConfig.setCollection(updatedLoopConfig.getCollection());
                        }
                        
                        if (updatedLoopConfig.getVariableName() != null) {
                            existingLoopConfig.setVariableName(updatedLoopConfig.getVariableName());
                        }
                        
                        if (updatedLoopConfig.getInitExpression() != null) {
                            existingLoopConfig.setInitExpression(updatedLoopConfig.getInitExpression());
                        }
                        
                        if (updatedLoopConfig.getConditionExpression() != null) {
                            existingLoopConfig.setConditionExpression(updatedLoopConfig.getConditionExpression());
                        }
                        
                        if (updatedLoopConfig.getIncrementExpression() != null) {
                            existingLoopConfig.setIncrementExpression(updatedLoopConfig.getIncrementExpression());
                        }
                        
                        if (updatedLoopConfig.getNestedActions() != null && !updatedLoopConfig.getNestedActions().isEmpty()) {
                            existingLoopConfig.setNestedActions(updatedLoopConfig.getNestedActions());
                        }
                    }
                    break;
                    
                case DATA_PROVIDER:
                    if (existingTemplate instanceof DataProviderActionConfig && updatedConfig instanceof DataProviderActionConfig) {
                        DataProviderActionConfig existingDPConfig = (DataProviderActionConfig) existingTemplate;
                        DataProviderActionConfig updatedDPConfig = (DataProviderActionConfig) updatedConfig;
                        
                        if (updatedDPConfig.getDataSourceType() != null) {
                            existingDPConfig.setDataSourceType(updatedDPConfig.getDataSourceType());
                        }
                        
                        if (updatedDPConfig.getDataSourcePath() != null) {
                            existingDPConfig.setDataSourcePath(updatedDPConfig.getDataSourcePath());
                        }
                        
                        if (updatedDPConfig.getSheetName() != null) {
                            existingDPConfig.setSheetName(updatedDPConfig.getSheetName());
                        }
                        
                        if (updatedDPConfig.getDelimiter() != null) {
                            existingDPConfig.setDelimiter(updatedDPConfig.getDelimiter());
                        }
                        
                        if (updatedDPConfig.getHeaders() != null) {
                            existingDPConfig.setHeaders(updatedDPConfig.getHeaders());
                        }
                        
                        if (updatedDPConfig.getParameters() != null && !updatedDPConfig.getParameters().isEmpty()) {
                            existingDPConfig.setParameters(updatedDPConfig.getParameters());
                        }
                        
                        if (updatedDPConfig.getIterationActions() != null && !updatedDPConfig.getIterationActions().isEmpty()) {
                            existingDPConfig.setIterationActions(updatedDPConfig.getIterationActions());
                        }
                    }
                    break;
                    
                case CUSTOM:
                    if (existingTemplate instanceof CustomActionConfig && updatedConfig instanceof CustomActionConfig) {
                        CustomActionConfig existingCustomConfig = (CustomActionConfig) existingTemplate;
                        CustomActionConfig updatedCustomConfig = (CustomActionConfig) updatedConfig;
                        
                        if (updatedCustomConfig.getScriptType() != null) {
                            existingCustomConfig.setScriptType(updatedCustomConfig.getScriptType());
                        }
                        
                        if (updatedCustomConfig.getScript() != null) {
                            existingCustomConfig.setScript(updatedCustomConfig.getScript());
                        }
                        
                        if (updatedCustomConfig.getParameters() != null && !updatedCustomConfig.getParameters().isEmpty()) {
                            existingCustomConfig.setParameters(updatedCustomConfig.getParameters());
                        }
                    }
                    break;
                    
                case VARIABLE:
                    copyProperty(updatedConfig, existingTemplate, "variableName");
                    copyProperty(updatedConfig, existingTemplate, "variableType");
                    copyProperty(updatedConfig, existingTemplate, "value");
                    copyProperty(updatedConfig, existingTemplate, "scope");
                    break;
                    
                case SCREENSHOT:
                    copyProperty(updatedConfig, existingTemplate, "fileName");
                    copyProperty(updatedConfig, existingTemplate, "element");
                    copyProperty(updatedConfig, existingTemplate, "elementLocatorType");
                    copyProperty(updatedConfig, existingTemplate, "fullPage");
                    copyProperty(updatedConfig, existingTemplate, "directory");
                    break;
                    
                case DRAG_DROP:
                    copyProperty(updatedConfig, existingTemplate, "sourceLocator");
                    copyProperty(updatedConfig, existingTemplate, "sourceLocatorType");
                    copyProperty(updatedConfig, existingTemplate, "targetLocator");
                    copyProperty(updatedConfig, existingTemplate, "targetLocatorType");
                    copyProperty(updatedConfig, existingTemplate, "timeout");
                    copyProperty(updatedConfig, existingTemplate, "waitForElements");
                    break;
                    
                case SWITCH_FRAME:
                    copyProperty(updatedConfig, existingTemplate, "frameLocator");
                    copyProperty(updatedConfig, existingTemplate, "frameLocatorType");
                    copyProperty(updatedConfig, existingTemplate, "timeout");
                    copyProperty(updatedConfig, existingTemplate, "switchToDefault");
                    copyProperty(updatedConfig, existingTemplate, "switchToParent");
                    break;
                    
                case SWITCH_WINDOW:
                    copyProperty(updatedConfig, existingTemplate, "windowHandle");
                    copyProperty(updatedConfig, existingTemplate, "windowIndex");
                    copyProperty(updatedConfig, existingTemplate, "windowTitle");
                    copyProperty(updatedConfig, existingTemplate, "windowUrl");
                    copyProperty(updatedConfig, existingTemplate, "timeout");
                    break;
                    
                case EXECUTE_SCRIPT:
                    copyProperty(updatedConfig, existingTemplate, "script");
                    copyProperty(updatedConfig, existingTemplate, "arguments");
                    copyProperty(updatedConfig, existingTemplate, "resultVariable");
                    break;
                    
                case FILE_UPLOAD:
                    copyProperty(updatedConfig, existingTemplate, "locator");
                    copyProperty(updatedConfig, existingTemplate, "locatorType");
                    copyProperty(updatedConfig, existingTemplate, "filePath");
                    copyProperty(updatedConfig, existingTemplate, "timeout");
                    copyProperty(updatedConfig, existingTemplate, "waitForElement");
                    break;
                    
                case KEY_PRESS:
                    copyProperty(updatedConfig, existingTemplate, "locator");
                    copyProperty(updatedConfig, existingTemplate, "locatorType");
                    copyProperty(updatedConfig, existingTemplate, "key");
                    copyProperty(updatedConfig, existingTemplate, "modifiers");
                    copyProperty(updatedConfig, existingTemplate, "timeout");
                    break;
                    
                case SCROLL:
                    copyProperty(updatedConfig, existingTemplate, "locator");
                    copyProperty(updatedConfig, existingTemplate, "locatorType");
                    copyProperty(updatedConfig, existingTemplate, "x");
                    copyProperty(updatedConfig, existingTemplate, "y");
                    copyProperty(updatedConfig, existingTemplate, "scrollType");
                    copyProperty(updatedConfig, existingTemplate, "timeout");
                    break;
                    
                default:
                    // No specific properties to update
                    break;
            }
        }
        
        existingTemplate.setProperty("updatedAt", LocalDateTime.now().toString());
        
        try {
            String templatePath = templatesDirectory + File.separator + templateId + ".json";
            storageService.saveObject(templatePath, existingTemplate, null);
            
            templateCache.put(templateId, existingTemplate);
            
            LOGGER.info("Updated action template: {}", existingTemplate.getProperty("templateName"));
            
            return existingTemplate;
        } catch (Exception e) {
            LOGGER.error("Failed to update action template: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Copy property from source to target if it exists in source.
     * 
     * @param source Source configuration
     * @param target Target configuration
     * @param propertyName Property name
     */
    private void copyProperty(ActionConfig source, ActionConfig target, String propertyName) {
        Object value = source.getProperty(propertyName);
        if (value != null) {
            target.setProperty(propertyName, value);
        }
    }
    
    @Override
    public boolean deleteActionTemplate(String templateId) {
        if (templateId == null) {
            return false;
        }
        
        try {
            String templatePath = templatesDirectory + File.separator + templateId + ".json";
            File templateFile = new File(templatePath);
            
            if (templateFile.exists()) {
                boolean deleted = templateFile.delete();
                
                if (deleted) {
                    templateCache.remove(templateId);
                    LOGGER.info("Deleted action template: {}", templateId);
                    return true;
                } else {
                    LOGGER.error("Failed to delete action template file: {}", templatePath);
                    return false;
                }
            } else {
                LOGGER.error("Template file not found: {}", templatePath);
                return false;
            }
        } catch (Exception e) {
            LOGGER.error("Failed to delete action template: {}", e.getMessage(), e);
            return false;
        }
    }
    
    @Override
    public ActionConfig getActionTemplate(String templateId) {
        if (templateId == null) {
            return null;
        }
        
        // Check cache first
        ActionConfig cachedTemplate = templateCache.get(templateId);
        if (cachedTemplate != null) {
            return cachedTemplate;
        }
        
        // Load from file if not in cache
        try {
            String templatePath = templatesDirectory + File.separator + templateId + ".json";
            ActionConfig template = storageService.loadObject(templatePath, ActionConfig.class, null);
            
            if (template != null) {
                templateCache.put(templateId, template);
                return template;
            } else {
                LOGGER.error("Failed to load action template: {}", templateId);
                return null;
            }
        } catch (Exception e) {
            LOGGER.error("Failed to get action template: {}", e.getMessage(), e);
            return null;
        }
    }
    
    @Override
    public List<ActionConfig> getAllActionTemplates() {
        try {
            // Refresh cache to ensure we have all templates
            loadTemplates();
            
            return new ArrayList<>(templateCache.values());
        } catch (Exception e) {
            LOGGER.error("Failed to get all action templates: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    @Override
    public List<ActionConfig> searchActionTemplates(String query, ActionType actionType) {
        try {
            List<ActionConfig> allTemplates = getAllActionTemplates();
            
            if (CSTextUtils.isNullOrEmpty(query) && actionType == null) {
                return allTemplates;
            }
            
            List<ActionConfig> filteredTemplates = new ArrayList<>();
            
            for (ActionConfig template : allTemplates) {
                boolean matchesQuery = CSTextUtils.isNullOrEmpty(query) ||
                        (template.getProperty("templateName") != null && 
                         ((String) template.getProperty("templateName")).toLowerCase().contains(query.toLowerCase())) ||
                        (template.getProperty("templateDescription") != null && 
                         ((String) template.getProperty("templateDescription")).toLowerCase().contains(query.toLowerCase()));
                
                boolean matchesActionType = actionType == null || 
                        (template.getActionType() != null && template.getActionType().equals(actionType));
                
                if (matchesQuery && matchesActionType) {
                    filteredTemplates.add(template);
                }
            }
            
            return filteredTemplates;
        } catch (Exception e) {
            LOGGER.error("Failed to search action templates: {}", e.getMessage(), e);
            return Collections.emptyList();
        }
    }
    
    @Override
    public ActionConfig createFromTemplate(String templateId) {
        if (templateId == null) {
            return null;
        }
        
        ActionConfig template = getActionTemplate(templateId);
        if (template == null) {
            LOGGER.error("Template with ID {} not found", templateId);
            return null;
        }
        
        try {
            // Create a deep copy of the template
            String json = storageService.serializeObject(template, null);
            ActionConfig copy = storageService.deserializeObject(json, ActionConfig.class, null);
            
            // Generate a new ID
            copy.setId(UUID.randomUUID().toString());
            
            // Remove template-specific properties
            copy.removeProperty("templateName");
            copy.removeProperty("templateDescription");
            copy.removeProperty("createdAt");
            copy.removeProperty("updatedAt");
            
            return copy;
        } catch (Exception e) {
            LOGGER.error("Failed to create action from template: {}", e.getMessage(), e);
            return null;
        }
    }
    
    @Override
    public boolean exportActionTemplates(String filePath) {
        if (CSTextUtils.isNullOrEmpty(filePath)) {
            return false;
        }
        
        try {
            List<ActionConfig> allTemplates = getAllActionTemplates();
            
            Map<String, Object> exportData = new HashMap<>();
            exportData.put("templates", allTemplates);
            exportData.put("exportDate", LocalDateTime.now().toString());
            exportData.put("version", "1.0");
            
            String json = storageService.serializeObject(exportData, null);
            
            File exportFile = new File(filePath);
            CSFileUtils.writeStringToFile(exportFile, json);
            
            LOGGER.info("Exported {} action templates to {}", allTemplates.size(), filePath);
            
            return true;
        } catch (Exception e) {
            LOGGER.error("Failed to export action templates: {}", e.getMessage(), e);
            return false;
        }
    }
    
    @Override
    public int importActionTemplates(String filePath, boolean overwrite) {
        if (CSTextUtils.isNullOrEmpty(filePath)) {
            return 0;
        }
        
        try {
            File importFile = new File(filePath);
            if (!importFile.exists() || !importFile.isFile()) {
                LOGGER.error("Import file not found: {}", filePath);
                return 0;
            }
            
            String json = CSFileUtils.readFileToString(importFile);
            Map<String, Object> importData = storageService.deserializeObject(json, Map.class, null);
            
            if (importData == null || !importData.containsKey("templates")) {
                LOGGER.error("Invalid import file format: {}", filePath);
                return 0;
            }
            
            List<Map<String, Object>> templateMaps = (List<Map<String, Object>>) importData.get("templates");
            int importCount = 0;
            
            for (Map<String, Object> templateMap : templateMaps) {
                try {
                    String templateJson = storageService.serializeObject(templateMap, null);
                    ActionConfig template = storageService.deserializeObject(templateJson, ActionConfig.class, null);
                    
                    String templateId = template.getId();
                    if (CSTextUtils.isNullOrEmpty(templateId)) {
                        templateId = UUID.randomUUID().toString();
                        template.setId(templateId);
                    }
                    
                    ActionConfig existingTemplate = getActionTemplate(templateId);
                    
                    if (existingTemplate == null || overwrite) {
                        String templatePath = templatesDirectory + File.separator + templateId + ".json";
                        storageService.saveObject(templatePath, template, null);
                        
                        templateCache.put(templateId, template);
                        importCount++;
                    }
                } catch (Exception e) {
                    LOGGER.error("Failed to import action template: {}", e.getMessage(), e);
                }
            }
            
            LOGGER.info("Imported {} action templates from {}", importCount, filePath);
            
            return importCount;
        } catch (Exception e) {
            LOGGER.error("Failed to import action templates: {}", e.getMessage(), e);
            return 0;
        }
    }
    
    @Override
    public String evaluateExpression(String expression, Map<String, Object> variables) {
        if (CSTextUtils.isNullOrEmpty(expression)) {
            return "";
        }
        
        try {
            // Check if the expression is a simple variable reference
            if (expression.startsWith("${") && expression.endsWith("}")) {
                String variableName = expression.substring(2, expression.length() - 1);
                if (variables != null && variables.containsKey(variableName)) {
                    Object value = variables.get(variableName);
                    return value != null ? value.toString() : "";
                }
                return "";
            }
            
            // Replace variable references in the expression
            String processedExpression = expression;
            if (variables != null && !variables.isEmpty()) {
                for (Map.Entry<String, Object> entry : variables.entrySet()) {
                    String variableName = entry.getKey();
                    Object value = entry.getValue();
                    String valueStr = value != null ? value.toString() : "";
                    
                    // Replace ${variable} syntax
                    processedExpression = processedExpression.replace("${" + variableName + "}", valueStr);
                    
                    // Add variable to the script context
                    if (value instanceof Number) {
                        processedExpression = "var " + variableName + " = " + value + ";\n" + processedExpression;
                    } else if (value instanceof Boolean) {
                        processedExpression = "var " + variableName + " = " + value + ";\n" + processedExpression;
                    } else {
                        processedExpression = "var " + variableName + " = \"" + escapeJavaString(valueStr) + "\";\n" + processedExpression;
                    }
                }
            }
            
            // Evaluate the expression using JavaScript engine
            ScriptEngine engine = scriptEngineManager.getEngineByName("JavaScript");
            Object result = engine.eval(processedExpression);
            
            return result != null ? result.toString() : "";
        } catch (ScriptException e) {
            LOGGER.error("Failed to evaluate expression: {}", expression, e);
            return "";
        }
    }
    
    @Override
    public Map<String, Object> analyzeCode(String code, FrameworkType frameworkType, 
            LanguageType languageType, TestType testType) {
        if (CSTextUtils.isNullOrEmpty(code)) {
            return Map.of("status", "error", "message", "Code is empty");
        }
        
        Map<String, Object> result = new HashMap<>();
        result.put("status", "success");
        
        try {
            List<ActionConfig> actions = new ArrayList<>();
            Set<String> imports = new HashSet<>();
            Set<String> variables = new HashSet<>();
            Set<String> methods = new HashSet<>();
            Set<String> classes = new HashSet<>();
            
            // Analyze code based on language
            if (languageType == LanguageType.JAVA) {
                analyzeJavaCode(code, actions, imports, variables, methods, classes);
            } else if (languageType == LanguageType.TYPESCRIPT) {
                analyzeTypeScriptCode(code, actions, imports, variables, methods, classes);
            }
            
            result.put("actions", actions);
            result.put("imports", imports);
            result.put("variables", variables);
            result.put("methods", methods);
            result.put("classes", classes);
            
        } catch (Exception e) {
            LOGGER.error("Failed to analyze code: {}", e.getMessage(), e);
            result.put("status", "error");
            result.put("message", "Failed to analyze code: " + e.getMessage());
        }
        
        return result;
    }
    
    /**
     * Analyze Java code and extract information.
     * 
     * @param code Java code
     * @param actions List to store detected actions
     * @param imports Set to store imports
     * @param variables Set to store variables
     * @param methods Set to store methods
     * @param classes Set to store classes
     */
    private void analyzeJavaCode(String code, List<ActionConfig> actions, Set<String> imports, 
            Set<String> variables, Set<String> methods, Set<String> classes) {
        
        // Extract imports
        Pattern importPattern = Pattern.compile("import\\s+([^;]+);");
        java.util.regex.Matcher importMatcher = importPattern.matcher(code);
        while (importMatcher.find()) {
            imports.add(importMatcher.group(1).trim());
        }
        
        // Extract class definitions
        Pattern classPattern = Pattern.compile("class\\s+([A-Za-z][A-Za-z0-9_]*)");
        java.util.regex.Matcher classMatcher = classPattern.matcher(code);
        while (classMatcher.find()) {
            classes.add(classMatcher.group(1).trim());
        }
        
        // Extract method definitions
        Pattern methodPattern = Pattern.compile("(public|private|protected|)\\s+(static\\s+)?(\\w+)\\s+(\\w+)\\s*\\([^)]*\\)");
        java.util.regex.Matcher methodMatcher = methodPattern.matcher(code);
        while (methodMatcher.find()) {
            methods.add(methodMatcher.group(4).trim());
        }
        
        // Extract variable declarations
        Pattern variablePattern = Pattern.compile("(\\w+)\\s+(\\w+)\\s*=");
        java.util.regex.Matcher variableMatcher = variablePattern.matcher(code);
        while (variableMatcher.find()) {
            variables.add(variableMatcher.group(2).trim());
        }
        
        // Detect click actions
        Pattern clickPattern = Pattern.compile("(\\w+)\\.click\\(\\);");
        java.util.regex.Matcher clickMatcher = clickPattern.matcher(code);
        while (clickMatcher.find()) {
            String elementVar = clickMatcher.group(1).trim();
            
            // Find the element's locator
            Pattern elementPattern = Pattern.compile(elementVar + "\\s*=\\s*getCSElement\\((.+?)\\)");
            java.util.regex.Matcher elementMatcher = elementPattern.matcher(code);
            
            if (elementMatcher.find()) {
                String locator = elementMatcher.group(1).trim();
                
                ActionConfig clickAction = new ActionConfig();
                clickAction.setId(UUID.randomUUID().toString());
                clickAction.setActionType(ActionType.CLICK);
                clickAction.setName("Click action");
                clickAction.setProperty("element", elementVar);
                clickAction.setProperty("locatorExpression", locator);
                
                actions.add(clickAction);
            }
        }
        
        // Detect sendKeys actions
        Pattern sendKeysPattern = Pattern.compile("(\\w+)\\.sendKeys\\((.+?)\\);");
        java.util.regex.Matcher sendKeysMatcher = sendKeysPattern.matcher(code);
        while (sendKeysMatcher.find()) {
            String elementVar = sendKeysMatcher.group(1).trim();
            String text = sendKeysMatcher.group(2).trim();
            
            ActionConfig typeAction = new ActionConfig();
            typeAction.setId(UUID.randomUUID().toString());
            typeAction.setActionType(ActionType.TYPE);
            typeAction.setName("Type action");
            typeAction.setProperty("element", elementVar);
            typeAction.setProperty("text", text);
            
            actions.add(typeAction);
        }
        
        // Detect navigate actions
        Pattern navigatePattern = Pattern.compile("(getDriver\\(\\)|driver)\\.get\\((.+?)\\);");
        java.util.regex.Matcher navigateMatcher = navigatePattern.matcher(code);
        while (navigateMatcher.find()) {
            String url = navigateMatcher.group(2).trim();
            
            ActionConfig navigateAction = new ActionConfig();
            navigateAction.setId(UUID.randomUUID().toString());
            navigateAction.setActionType(ActionType.NAVIGATE);
            navigateAction.setName("Navigate action");
            navigateAction.setProperty("url", url);
            
            actions.add(navigateAction);
        }
        
        // Detect assertions
        Pattern assertPattern = Pattern.compile("assert(\\w+)\\((.+?)\\);");
        java.util.regex.Matcher assertMatcher = assertPattern.matcher(code);
        while (assertMatcher.find()) {
            String assertType = assertMatcher.group(1).trim();
            String assertArgs = assertMatcher.group(2).trim();
            
            AssertionActionConfig assertAction = new AssertionActionConfig();
            assertAction.setId(UUID.randomUUID().toString());
            assertAction.setActionType(ActionType.ASSERT);
            assertAction.setName("Assert " + assertType);
            
            if (assertType.equals("True")) {
                assertAction.setAssertionType("BOOLEAN_TRUE");
                assertAction.setActualValue(assertArgs);
            } else if (assertType.equals("False")) {
                assertAction.setAssertionType("BOOLEAN_FALSE");
                assertAction.setActualValue(assertArgs);
            } else if (assertType.equals("Equals")) {
                assertAction.setAssertionType("VALUE_EQUALS");
                
                String[] parts = assertArgs.split(",\\s*", 2);
                if (parts.length == 2) {
                    assertAction.setExpectedValue(parts[0].trim());
                    assertAction.setActualValue(parts[1].trim());
                }
            }
            
            actions.add(assertAction);
        }
    }
    
    /**
     * Analyze TypeScript code and extract information.
     * 
     * @param code TypeScript code
     * @param actions List to store detected actions
     * @param imports Set to store imports
     * @param variables Set to store variables
     * @param methods Set to store methods
     * @param classes Set to store classes
     */
    private void analyzeTypeScriptCode(String code, List<ActionConfig> actions, Set<String> imports, 
            Set<String> variables, Set<String> methods, Set<String> classes) {
        
        // Extract imports
        Pattern importPattern = Pattern.compile("import\\s+\\{?([^{}]+)\\}?\\s+from\\s+['\"]([^'\"]+)['\"];");
        java.util.regex.Matcher importMatcher = importPattern.matcher(code);
        while (importMatcher.find()) {
            String importItems = importMatcher.group(1).trim();
            String importSource = importMatcher.group(2).trim();
            
            for (String item : importItems.split(",")) {
                imports.add(item.trim() + " from " + importSource);
            }
        }
        
        // Extract class definitions
        Pattern classPattern = Pattern.compile("class\\s+([A-Za-z][A-Za-z0-9_]*)");
        java.util.regex.Matcher classMatcher = classPattern.matcher(code);
        while (classMatcher.find()) {
            classes.add(classMatcher.group(1).trim());
        }
        
        // Extract method definitions
        Pattern methodPattern = Pattern.compile("(async\\s+)?(function\\s+)?([A-Za-z][A-Za-z0-9_]*)\\s*\\([^)]*\\)");
        java.util.regex.Matcher methodMatcher = methodPattern.matcher(code);
        while (methodMatcher.find()) {
            if (methodMatcher.group(3) != null) {
                methods.add(methodMatcher.group(3).trim());
            }
        }
        
        // Extract variable declarations
        Pattern variablePattern = Pattern.compile("(const|let|var)\\s+(\\w+)\\s*=");
        java.util.regex.Matcher variableMatcher = variablePattern.matcher(code);
        while (variableMatcher.find()) {
            variables.add(variableMatcher.group(2).trim());
        }
        
        // Detect click actions
        Pattern clickPattern = Pattern.compile("await\\s+(\\w+)\\.click\\(\\);");
        java.util.regex.Matcher clickMatcher = clickPattern.matcher(code);
        while (clickMatcher.find()) {
            String elementVar = clickMatcher.group(1).trim();
            
            // Find the element's locator
            Pattern elementPattern = Pattern.compile(elementVar + "\\s*=\\s*getCSElement\\((.+?)\\)");
            java.util.regex.Matcher elementMatcher = elementPattern.matcher(code);
            
            if (elementMatcher.find()) {
                String locator = elementMatcher.group(1).trim();
                
                ActionConfig clickAction = new ActionConfig();
                clickAction.setId(UUID.randomUUID().toString());
                clickAction.setActionType(ActionType.CLICK);
                clickAction.setName("Click action");
                clickAction.setProperty("element", elementVar);
                clickAction.setProperty("locatorExpression", locator);
                
                actions.add(clickAction);
            }
        }
        
        // Detect sendKeys actions
        Pattern sendKeysPattern = Pattern.compile("await\\s+(\\w+)\\.sendKeys\\((.+?)\\);");
        java.util.regex.Matcher sendKeysMatcher = sendKeysPattern.matcher(code);
        while (sendKeysMatcher.find()) {
            String elementVar = sendKeysMatcher.group(1).trim();
            String text = sendKeysMatcher.group(2).trim();
            
            ActionConfig typeAction = new ActionConfig();
            typeAction.setId(UUID.randomUUID().toString());
            typeAction.setActionType(ActionType.TYPE);
            typeAction.setName("Type action");
            typeAction.setProperty("element", elementVar);
            typeAction.setProperty("text", text);
            
            actions.add(typeAction);
        }
        
        // Detect navigate actions
        Pattern navigatePattern = Pattern.compile("await\\s+(getDriver\\(\\)|driver|page|getPage\\(\\))\\.goto\\((.+?)\\);");
        java.util.regex.Matcher navigateMatcher = navigatePattern.matcher(code);
        while (navigateMatcher.find()) {
            String url = navigateMatcher.group(2).trim();
            
            ActionConfig navigateAction = new ActionConfig();
            navigateAction.setId(UUID.randomUUID().toString());
            navigateAction.setActionType(ActionType.NAVIGATE);
            navigateAction.setName("Navigate action");
            navigateAction.setProperty("url", url);
            
            actions.add(navigateAction);
        }
        
        // Detect assertions
        Pattern assertPattern = Pattern.compile("expect\\((.+?)\\)\\.to\\.(\\w+)\\((.+?)\\);");
        java.util.regex.Matcher assertMatcher = assertPattern.matcher(code);
        while (assertMatcher.find()) {
            String actual = assertMatcher.group(1).trim();
            String assertType = assertMatcher.group(2).trim();
            String expected = assertMatcher.group(3).trim();
            
            AssertionActionConfig assertAction = new AssertionActionConfig();
            assertAction.setId(UUID.randomUUID().toString());
            assertAction.setActionType(ActionType.ASSERT);
            assertAction.setName("Assert " + assertType);
            assertAction.setActualValue(actual);
            
            if (assertType.equals("equal")) {
                assertAction.setAssertionType("VALUE_EQUALS");
                assertAction.setExpectedValue(expected);
            } else if (assertType.equals("contain")) {
                assertAction.setAssertionType("VALUE_CONTAINS");
                assertAction.setExpectedValue(expected);
            } else if (assertType.equals("be")) {
                if (expected.equals("true")) {
                    assertAction.setAssertionType("BOOLEAN_TRUE");
                } else if (expected.equals("false")) {
                    assertAction.setAssertionType("BOOLEAN_FALSE");
                }
            }
            
            actions.add(assertAction);
        }
    }
    
    @Override
    public String generateDynamicLocatorExpression(String locator, LanguageType languageType) {
        if (CSTextUtils.isNullOrEmpty(locator)) {
            return "";
        }
        
        try {
            // Try to parse the locator as is first
            return parseLocator(locator, languageType);
        } catch (Exception e) {
            LOGGER.debug("Failed to parse locator as is, trying to detect format: {}", locator);
            
            // Try to detect the locator format
            if (locator.startsWith("//")) {
                // XPath locator
                return getLocatorCode("XPATH", locator, languageType);
            } else if (locator.startsWith("#")) {
                // ID selector
                return getLocatorCode("CSS", locator, languageType);
            } else if (locator.startsWith(".")) {
                // Class selector
                return getLocatorCode("CSS", locator, languageType);
            } else if (locator.contains("=")) {
                // Name or attribute selector
                String[] parts = locator.split("=", 2);
                String type = parts[0].trim();
                String value = parts[1].trim();
                
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    value = value.substring(1, value.length() - 1);
                } else if (value.startsWith("'") && value.endsWith("'")) {
                    value = value.substring(1, value.length() - 1);
                }
                
                if (type.equalsIgnoreCase("id")) {
                    return getLocatorCode("ID", value, languageType);
                } else if (type.equalsIgnoreCase("name")) {
                    return getLocatorCode("NAME", value, languageType);
                } else if (type.equalsIgnoreCase("class") || type.equalsIgnoreCase("className")) {
                    return getLocatorCode("CLASS_NAME", value, languageType);
                } else if (type.equalsIgnoreCase("tag") || type.equalsIgnoreCase("tagName")) {
                    return getLocatorCode("TAG_NAME", value, languageType);
                } else if (type.equalsIgnoreCase("linkText")) {
                    return getLocatorCode("LINK_TEXT", value, languageType);
                } else if (type.equalsIgnoreCase("partialLinkText")) {
                    return getLocatorCode("PARTIAL_LINK_TEXT", value, languageType);
                } else {
                    // Assume CSS selector with attribute
                    return getLocatorCode("CSS", "[" + type + "=\"" + value + "\"]", languageType);
                }
            } else {
                // Assume tag selector (CSS)
                return getLocatorCode("CSS", locator, languageType);
            }
        }
    }
    
    /**
     * Parse a locator string into the appropriate locator code.
     * 
     * @param locator Locator string
     * @param languageType Language type
     * @return Locator code
     */
    private String parseLocator(String locator, LanguageType languageType) {
        if (locator.startsWith("By.")) {
            // Already a By locator expression
            return locator;
        }
        
        // Parse the locator format: type=value
        String[] parts = locator.split("=", 2);
        if (parts.length != 2) {
            throw new IllegalArgumentException("Invalid locator format: " + locator);
        }
        
        String type = parts[0].trim();
        String value = parts[1].trim();
        
        if (value.startsWith("\"") && value.endsWith("\"")) {
            value = value.substring(1, value.length() - 1);
        } else if (value.startsWith("'") && value.endsWith("'")) {
            value = value.substring(1, value.length() - 1);
        }
        
        return getLocatorCode(type.toUpperCase(), value, languageType);
    }
    
    @Override
    public void refreshTemplateCache() {
        templateCache.clear();
        loadTemplates();
    }
}

@Override
    public String generateCodeFromActions(List<ActionConfig> actions, FrameworkType frameworkType, 
            LanguageType languageType, TestType testType) {
        
        if (actions == null || actions.isEmpty()) {
            return "// No actions to generate code from";
        }
        
        StringBuilder code = new StringBuilder();
        
        // Generate imports and setup based on language, framework, and test type
        if (languageType == LanguageType.JAVA) {
            generateJavaSetup(code, frameworkType, testType);
        } else if (languageType == LanguageType.TYPESCRIPT) {
            generateTypeScriptSetup(code, frameworkType, testType);
        }
        
        code.append("\n");
        
        // Generate test method
        if (languageType == LanguageType.JAVA) {
            if (testType == TestType.TESTNG) {
                code.append("@Test\n");
                code.append("public void testCase() {\n");
            } else if (testType == TestType.BDD) {
                code.append("@When(\"test step\")\n");
                code.append("public void testStep() {\n");
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            if (testType == TestType.TESTNG) {
                code.append("it('test case', async () => {\n");
            } else if (testType == TestType.BDD) {
                code.append("When('test step', async () => {\n");
            }
        }
        
        // Generate code for each action
        for (ActionConfig action : actions) {
            StringBuilder actionCode = new StringBuilder();
            
            // Generate code for the action
            if (languageType == LanguageType.JAVA) {
                generateJavaCode(actionCode, action, frameworkType, testType);
            } else if (languageType == LanguageType.TYPESCRIPT) {
                generateTypeScriptCode(actionCode, action, frameworkType, testType);
            }
            
            // Indent the action code
            String[] lines = actionCode.toString().split("\n");
            for (String line : lines) {
                code.append("    ").append(line).append("\n");
            }
            
            code.append("\n");
        }
        
        // Close the test method
        if (languageType == LanguageType.JAVA) {
            code.append("}\n");
        } else if (languageType == LanguageType.TYPESCRIPT) {
            code.append("});\n");
        }
        
        return code.toString();
    }
    
    /**
     * Generate Java setup code.
     * 
     * @param code StringBuilder to append code to
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void generateJavaSetup(StringBuilder code, FrameworkType frameworkType, TestType testType) {
        // Generate imports
        if (frameworkType == FrameworkType.SELENIUM) {
            code.append("import org.openqa.selenium.*;\n");
            code.append("import org.openqa.selenium.support.ui.*;\n");
            code.append("import com.cstestforge.framework.selenium.browser.*;\n");
            code.append("import com.cstestforge.framework.selenium.page.*;\n");
            code.append("import com.cstestforge.framework.selenium.element.*;\n");
            code.append("import com.cstestforge.framework.selenium.wait.*;\n");
            code.append("import com.cstestforge.framework.core.utils.*;\n");
            code.append("import java.util.concurrent.TimeUnit;\n");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            code.append("import com.microsoft.playwright.*;\n");
            code.append("import com.microsoft.playwright.options.*;\n");
            code.append("import com.cstestforge.framework.playwright.browser.*;\n");
            code.append("import com.cstestforge.framework.playwright.page.*;\n");
            code.append("import com.cstestforge.framework.playwright.element.*;\n");
            code.append("import com.cstestforge.framework.core.utils.*;\n");
        }
        
        if (testType == TestType.TESTNG) {
            code.append("import org.testng.annotations.*;\n");
            code.append("import org.testng.Assert;\n");
        } else if (testType == TestType.BDD) {
            code.append("import io.cucumber.java.en.*;\n");
            code.append("import org.junit.Assert;\n");
        }
        
        code.append("import java.util.*;\n");
        code.append("\n");
        
        // Generate class definition
        code.append("public class TestCase extends CSBaseTest {\n");
    }
    
    /**
     * Generate TypeScript setup code.
     * 
     * @param code StringBuilder to append code to
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void generateTypeScriptSetup(StringBuilder code, FrameworkType frameworkType, TestType testType) {
        // Generate imports
        if (frameworkType == FrameworkType.SELENIUM) {
            code.append("import { By, Key, until } from 'selenium-webdriver';\n");
            code.append("import { CSElement, CSElementList, CSSelect } from '@cstestforge/selenium/element';\n");
            code.append("import { CSWaitFactory, CSWaitStrategyType } from '@cstestforge/selenium/wait';\n");
            code.append("import { CSElement, CSElementList, CSSelect } from '@cstestforge/selenium/element';\n");
            code.append("import { CSWaitFactory, CSWaitStrategyType } from '@cstestforge/selenium/wait';\n");
            code.append("import { CSBaseTest } from '@cstestforge/selenium/test';\n");
            code.append("import { CSUtils } from '@cstestforge/core/utils';\n");
        } else if (frameworkType == FrameworkType.PLAYWRIGHT) {
            code.append("import { Page, BrowserContext, Locator, expect } from '@playwright/test';\n");
            code.append("import { CSElement, CSElementList } from '@cstestforge/playwright/element';\n");
            code.append("import { CSBaseTest } from '@cstestforge/playwright/test';\n");
            code.append("import { CSUtils } from '@cstestforge/core/utils';\n");
        }
        
        if (testType == TestType.TESTNG) {
            code.append("import { test, describe, beforeEach, afterEach } from 'mocha';\n");
            code.append("import { expect } from 'chai';\n");
        } else if (testType == TestType.BDD) {
            code.append("import { Given, When, Then } from '@cucumber/cucumber';\n");
        }
        
        code.append("\n");
        
        // Generate class or describe block
        if (testType == TestType.TESTNG) {
            code.append("describe('Test Suite', () => {\n");
            code.append("    let testInstance: TestCase;\n\n");
            code.append("    beforeEach(async () => {\n");
            code.append("        testInstance = new TestCase();\n");
            code.append("        await testInstance.setup();\n");
            code.append("    });\n\n");
            code.append("    afterEach(async () => {\n");
            code.append("        await testInstance.teardown();\n");
            code.append("    });\n\n");
            code.append("    class TestCase extends CSBaseTest {\n");
            code.append("        async setup() {\n");
            code.append("            await super.setup();\n");
            code.append("        }\n\n");
            code.append("        async teardown() {\n");
            code.append("            await super.teardown();\n");
            code.append("        }\n\n");
        }
    }
    
    @Override
    public List<ActionConfig> convertCodeToActions(String code, FrameworkType frameworkType, 
            LanguageType languageType, TestType testType) {
        if (CSTextUtils.isNullOrEmpty(code)) {
            return Collections.emptyList();
        }
        
        List<ActionConfig> actions = new ArrayList<>();
        
        try {
            // Parse code based on language
            if (languageType == LanguageType.JAVA) {
                parseJavaCode(code, actions, frameworkType, testType);
            } else if (languageType == LanguageType.TYPESCRIPT) {
                parseTypeScriptCode(code, actions, frameworkType, testType);
            }
        } catch (Exception e) {
            LOGGER.error("Failed to convert code to actions: {}", e.getMessage(), e);
        }
        
        return actions;
    }
    
    /**
     * Parse Java code and extract actions.
     * 
     * @param code Java code
     * @param actions List to store extracted actions
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void parseJavaCode(String code, List<ActionConfig> actions, FrameworkType frameworkType, TestType testType) {
        // Remove comments and normalize whitespace
        String cleanCode = removeComments(code);
        cleanCode = cleanCode.replaceAll("\\s+", " ");
        
        // Extract methods
        List<String> methods = extractMethods(cleanCode);
        
        for (String method : methods) {
            // Extract statements from method
            List<String> statements = extractStatements(method);
            
            for (String statement : statements) {
                ActionConfig action = convertStatementToAction(statement, frameworkType, languageType, testType);
                if (action != null) {
                    actions.add(action);
                }
            }
        }
    }
    
    /**
     * Parse TypeScript code and extract actions.
     * 
     * @param code TypeScript code
     * @param actions List to store extracted actions
     * @param frameworkType Framework type
     * @param testType Test type
     */
    private void parseTypeScriptCode(String code, List<ActionConfig> actions, FrameworkType frameworkType, TestType testType) {
        // Remove comments and normalize whitespace
        String cleanCode = removeComments(code);
        cleanCode = cleanCode.replaceAll("\\s+", " ");
        
        // Extract methods and lambdas
        List<String> methods = extractTypeScriptMethods(cleanCode);
        
        for (String method : methods) {
            // Extract statements from method
            List<String> statements = extractTypeScriptStatements(method);
            
            for (String statement : statements) {
                ActionConfig action = convertStatementToAction(statement, frameworkType, LanguageType.TYPESCRIPT, testType);
                if (action != null) {
                    actions.add(action);
                }
            }
        }
    }
    
    /**
     * Remove comments from code.
     * 
     * @param code Code to process
     * @return Code without comments
     */
    private String removeComments(String code) {
        // Remove line comments
        String result = code.replaceAll("//.*?\\n", "\n");
        
        // Remove block comments
        result = result.replaceAll("/\\*.*?\\*/", "");
        
        return result;
    }
    
    /**
     * Extract methods from Java code.
     * 
     * @param code Java code
     * @return List of method bodies
     */
    private List<String> extractMethods(String code) {
        List<String> methods = new ArrayList<>();
        
        // Method pattern: public|private|protected [static] returnType methodName() { ... }
        Pattern methodPattern = Pattern.compile("(public|private|protected)\\s+(static\\s+)?(\\w+)\\s+(\\w+)\\s*\\([^)]*\\)\\s*\\{([^}]*(?:\\{[^}]*\\}[^}]*)*)\\}");
        java.util.regex.Matcher matcher = methodPattern.matcher(code);
        
        while (matcher.find()) {
            String methodBody = matcher.group(5);
            methods.add(methodBody);
        }
        
        return methods;
    }
    
    /**
     * Extract methods and lambdas from TypeScript code.
     * 
     * @param code TypeScript code
     * @return List of method bodies
     */
    private List<String> extractTypeScriptMethods(String code) {
        List<String> methods = new ArrayList<>();
        
        // Method pattern: [public|private|protected] [async] methodName(): returnType { ... }
        Pattern methodPattern = Pattern.compile("(public|private|protected)?\\s*(async\\s+)?(\\w+)\\s*\\([^)]*\\)\\s*(:\\s*\\w+)?\\s*\\{([^}]*(?:\\{[^}]*\\}[^}]*)*)\\}");
        java.util.regex.Matcher methodMatcher = methodPattern.matcher(code);
        
        while (methodMatcher.find()) {
            String methodBody = methodMatcher.group(5);
            methods.add(methodBody);
        }
        
        // Lambda pattern: [async] () => { ... }
        Pattern lambdaPattern = Pattern.compile("(async\\s+)?\\([^)]*\\)\\s*=>\\s*\\{([^}]*(?:\\{[^}]*\\}[^}]*)*)\\}");
        java.util.regex.Matcher lambdaMatcher = lambdaPattern.matcher(code);
        
        while (lambdaMatcher.find()) {
            String lambdaBody = lambdaMatcher.group(2);
            methods.add(lambdaBody);
        }
        
        return methods;
    }
    
    /**
     * Extract statements from method body.
     * 
     * @param methodBody Method body
     * @return List of statements
     */
    private List<String> extractStatements(String methodBody) {
        List<String> statements = new ArrayList<>();
        
        // Split by semicolons and handle nested blocks
        int startIndex = 0;
        int braceCount = 0;
        
        for (int i = 0; i < methodBody.length(); i++) {
            char c = methodBody.charAt(i);
            
            if (c == '{') {
                braceCount++;
            } else if (c == '}') {
                braceCount--;
            } else if (c == ';' && braceCount == 0) {
                String statement = methodBody.substring(startIndex, i).trim();
                if (!statement.isEmpty()) {
                    statements.add(statement);
                }
                startIndex = i + 1;
            }
        }
        
        // Add the last statement if there is one
        if (startIndex < methodBody.length()) {
            String statement = methodBody.substring(startIndex).trim();
            if (!statement.isEmpty()) {
                statements.add(statement);
            }
        }
        
        return statements;
    }
    
    /**
     * Extract statements from TypeScript method body.
     * 
     * @param methodBody Method body
     * @return List of statements
     */
    private List<String> extractTypeScriptStatements(String methodBody) {
        List<String> statements = new ArrayList<>();
        
        // Split by semicolons and handle nested blocks
        int startIndex = 0;
        int braceCount = 0;
        
        for (int i = 0; i < methodBody.length(); i++) {
            char c = methodBody.charAt(i);
            
            if (c == '{') {
                braceCount++;
            } else if (c == '}') {
                braceCount--;
            } else if (c == ';' && braceCount == 0) {
                String statement = methodBody.substring(startIndex, i).trim();
                if (!statement.isEmpty()) {
                    statements.add(statement);
                }
                startIndex = i + 1;
            }
        }
        
        // Add the last statement if there is one
        if (startIndex < methodBody.length()) {
            String statement = methodBody.substring(startIndex).trim();
            if (!statement.isEmpty()) {
                statements.add(statement);
            }
        }
        
        return statements;
    }
    
    /**
     * Convert a statement to an action.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ActionConfig or null if not recognized
     */
    private ActionConfig convertStatementToAction(String statement, FrameworkType frameworkType, 
            LanguageType languageType, TestType testType) {
        
        if (statement == null || statement.trim().isEmpty()) {
            return null;
        }
        
        String cleanStatement = statement.trim();
        
        // Check for click action
        ActionConfig action = detectClickAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for sendKeys/type action
        action = detectTypeAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for navigate action
        action = detectNavigateAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for assert action
        action = detectAssertAction(cleanStatement, frameworkType, languageType, testType);
        if (action != null) {
            return action;
        }
        
        // Check for wait action
        action = detectWaitAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for select action
        action = detectSelectAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for hover action
        action = detectHoverAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for screenshot action
        action = detectScreenshotAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for drag and drop action
        action = detectDragDropAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for frame switch action
        action = detectSwitchFrameAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for window switch action
        action = detectSwitchWindowAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Check for execute script action
        action = detectExecuteScriptAction(cleanStatement, frameworkType, languageType);
        if (action != null) {
            return action;
        }
        
        // Add more action type detections as needed
        
        return null;
    }
    
    /**
     * Detect click action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a click action
     */
    private ActionConfig detectClickAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: element.click()
            if (statement.matches(".*\\.click\\(\\).*")) {
                // Extract element variable name
                Pattern elementPattern = Pattern.compile("([\\w.]+)\\.click\\(\\)");
                java.util.regex.Matcher matcher = elementPattern.matcher(statement);
                
                if (matcher.find()) {
                    String elementVar = matcher.group(1);
                    
                    ActionConfig clickAction = new ActionConfig();
                    clickAction.setId(UUID.randomUUID().toString());
                    clickAction.setActionType(ActionType.CLICK);
                    clickAction.setName("Click action");
                    clickAction.setProperty("element", elementVar);
                    clickAction.setProperty("sourceCode", statement);
                    
                    // Try to extract locator from previous statements
                    // This is a simplified approach; in a real implementation, 
                    // you would scan previous statements to find where the element was defined
                    
                    return clickAction;
                }
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await element.click()
            if (statement.matches(".*await.*\\.click\\(\\).*")) {
                // Extract element variable name
                Pattern elementPattern = Pattern.compile("await\\s+([\\w.]+)\\.click\\(\\)");
                java.util.regex.Matcher matcher = elementPattern.matcher(statement);
                
                if (matcher.find()) {
                    String elementVar = matcher.group(1);
                    
                    ActionConfig clickAction = new ActionConfig();
                    clickAction.setId(UUID.randomUUID().toString());
                    clickAction.setActionType(ActionType.CLICK);
                    clickAction.setName("Click action");
                    clickAction.setProperty("element", elementVar);
                    clickAction.setProperty("sourceCode", statement);
                    
                    return clickAction;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detect type action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a type action
     */
    private ActionConfig detectTypeAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: element.sendKeys(text) or element.fill(text)
            if (statement.matches(".*\\.sendKeys\\(.*\\).*") || statement.matches(".*\\.fill\\(.*\\).*")) {
                Pattern pattern = statement.contains("sendKeys") ? 
                        Pattern.compile("([\\w.]+)\\.sendKeys\\((.+)\\)") : 
                        Pattern.compile("([\\w.]+)\\.fill\\((.+)\\)");
                
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String elementVar = matcher.group(1);
                    String text = matcher.group(2).trim();
                    
                    // Remove quotes if present
                    if ((text.startsWith("\"") && text.endsWith("\"")) || (text.startsWith("'") && text.endsWith("'"))) {
                        text = text.substring(1, text.length() - 1);
                    }
                    
                    ActionConfig typeAction = new ActionConfig();
                    typeAction.setId(UUID.randomUUID().toString());
                    typeAction.setActionType(ActionType.TYPE);
                    typeAction.setName("Type action");
                    typeAction.setProperty("element", elementVar);
                    typeAction.setProperty("text", text);
                    typeAction.setProperty("sourceCode", statement);
                    
                    return typeAction;
                }
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await element.sendKeys(text) or await element.fill(text)
            if (statement.matches(".*await.*\\.sendKeys\\(.*\\).*") || statement.matches(".*await.*\\.fill\\(.*\\).*")) {
                Pattern pattern = statement.contains("sendKeys") ? 
                        Pattern.compile("await\\s+([\\w.]+)\\.sendKeys\\((.+)\\)") : 
                        Pattern.compile("await\\s+([\\w.]+)\\.fill\\((.+)\\)");
                
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String elementVar = matcher.group(1);
                    String text = matcher.group(2).trim();
                    
                    // Remove quotes if present
                    if ((text.startsWith("\"") && text.endsWith("\"")) || (text.startsWith("'") && text.endsWith("'"))) {
                        text = text.substring(1, text.length() - 1);
                    }
                    
                    ActionConfig typeAction = new ActionConfig();
                    typeAction.setId(UUID.randomUUID().toString());
                    typeAction.setActionType(ActionType.TYPE);
                    typeAction.setName("Type action");
                    typeAction.setProperty("element", elementVar);
                    typeAction.setProperty("text", text);
                    typeAction.setProperty("sourceCode", statement);
                    
                    return typeAction;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detect navigate action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a navigate action
     */
    private ActionConfig detectNavigateAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: driver.get(url) or driver.navigate().to(url)
            if (statement.matches(".*\\.get\\(.*\\).*") || statement.matches(".*\\.navigate\\(\\)\\.to\\(.*\\).*")) {
                Pattern pattern = statement.contains("get") ? 
                        Pattern.compile("([\\w.]+)\\.get\\((.+)\\)") : 
                        Pattern.compile("([\\w.]+)\\.navigate\\(\\)\\.to\\((.+)\\)");
                
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String url = matcher.group(2).trim();
                    
                    // Remove quotes if present
                    if ((url.startsWith("\"") && url.endsWith("\"")) || (url.startsWith("'") && url.endsWith("'"))) {
                        url = url.substring(1, url.length() - 1);
                    }
                    
                    ActionConfig navigateAction = new ActionConfig();
                    navigateAction.setId(UUID.randomUUID().toString());
                    navigateAction.setActionType(ActionType.NAVIGATE);
                    navigateAction.setName("Navigate action");
                    navigateAction.setProperty("url", url);
                    navigateAction.setProperty("sourceCode", statement);
                    
                    return navigateAction;
                }
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await driver.get(url) or await page.goto(url)
            if (statement.matches(".*await.*\\.get\\(.*\\).*") || statement.matches(".*await.*\\.goto\\(.*\\).*")) {
                Pattern pattern = statement.contains("get") ? 
                        Pattern.compile("await\\s+([\\w.]+)\\.get\\((.+)\\)") : 
                        Pattern.compile("await\\s+([\\w.]+)\\.goto\\((.+)\\)");
                
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String url = matcher.group(2).trim();
                    
                    // Remove quotes if present
                    if ((url.startsWith("\"") && url.endsWith("\"")) || (url.startsWith("'") && url.endsWith("'"))) {
                        url = url.substring(1, url.length() - 1);
                    }
                    
                    // Remove options object if present
                    int commaIndex = url.indexOf(',');
                    if (commaIndex > 0) {
                        url = url.substring(0, commaIndex).trim();
                        
                        // Remove quotes again if needed
                        if ((url.startsWith("\"") && url.endsWith("\"")) || (url.startsWith("'") && url.endsWith("'"))) {
                            url = url.substring(1, url.length() - 1);
                        }
                    }
                    
                    ActionConfig navigateAction = new ActionConfig();
                    navigateAction.setId(UUID.randomUUID().toString());
                    navigateAction.setActionType(ActionType.NAVIGATE);
                    navigateAction.setName("Navigate action");
                    navigateAction.setProperty("url", url);
                    navigateAction.setProperty("sourceCode", statement);
                    
                    return navigateAction;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detect assert action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @param testType Test type
     * @return ActionConfig or null if not an assert action
     */
    private ActionConfig detectAssertAction(String statement, FrameworkType frameworkType, 
            LanguageType languageType, TestType testType) {
        
        if (languageType == LanguageType.JAVA) {
            // Java pattern: Assert.xxx(...)
            if (statement.matches(".*Assert\\..*\\(.*\\).*")) {
                Pattern pattern = Pattern.compile("Assert\\.(\\w+)\\((.+?)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String assertType = matcher.group(1);
                    String assertArgs = matcher.group(2);
                    
                    AssertionActionConfig assertAction = new AssertionActionConfig();
                    assertAction.setId(UUID.randomUUID().toString());
                    assertAction.setActionType(ActionType.ASSERT);
                    assertAction.setName("Assert " + assertType);
                    assertAction.setProperty("sourceCode", statement);
                    
                    // Parse assertion type and arguments
                    if (assertType.equals("assertTrue")) {
                        assertAction.setAssertionType("BOOLEAN_TRUE");
                        assertAction.setActualValue(assertArgs.split(",", 2)[assertArgs.contains(",") ? 1 : 0].trim());
                    } else if (assertType.equals("assertFalse")) {
                        assertAction.setAssertionType("BOOLEAN_FALSE");
                        assertAction.setActualValue(assertArgs.split(",", 2)[assertArgs.contains(",") ? 1 : 0].trim());
                    } else if (assertType.equals("assertEquals")) {
                        assertAction.setAssertionType("VALUE_EQUALS");
                        
                        String[] parts = assertArgs.split(",", 3);
                        if (parts.length >= 2) {
                            // Handle message parameter if present
                            int expectedIndex = parts.length == 3 ? 1 : 0;
                            int actualIndex = parts.length == 3 ? 2 : 1;
                            
                            assertAction.setExpectedValue(parts[expectedIndex].trim());
                            assertAction.setActualValue(parts[actualIndex].trim());
                        }
                    } else if (assertType.equals("assertNotEquals")) {
                        assertAction.setAssertionType("VALUE_NOT_EQUALS");
                        
                        String[] parts = assertArgs.split(",", 3);
                        if (parts.length >= 2) {
                            // Handle message parameter if present
                            int expectedIndex = parts.length == 3 ? 1 : 0;
                            int actualIndex = parts.length == 3 ? 2 : 1;
                            
                            assertAction.setExpectedValue(parts[expectedIndex].trim());
                            assertAction.setActualValue(parts[actualIndex].trim());
                        }
                    } else if (assertType.equals("assertNull")) {
                        assertAction.setAssertionType("VALUE_NULL");
                        assertAction.setActualValue(assertArgs.split(",", 2)[assertArgs.contains(",") ? 1 : 0].trim());
                    } else if (assertType.equals("assertNotNull")) {
                        assertAction.setAssertionType("VALUE_NOT_NULL");
                        assertAction.setActualValue(assertArgs.split(",", 2)[assertArgs.contains(",") ? 1 : 0].trim());
                    }
                    
                    return assertAction;
                }
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: expect(...).to.xxx(...)
            if (statement.matches(".*expect\\(.*\\)\\.to\\..*\\(.*\\).*")) {
                Pattern pattern = Pattern.compile("expect\\((.+?)\\)\\.to\\.(\\w+)\\((.*)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String actual = matcher.group(1);
                    String assertType = matcher.group(2);
                    String expected = matcher.group(3);
                    
                    AssertionActionConfig assertAction = new AssertionActionConfig();
                    assertAction.setId(UUID.randomUUID().toString());
                    assertAction.setActionType(ActionType.ASSERT);
                    assertAction.setName("Assert " + assertType);
                    assertAction.setActualValue(actual);
                    assertAction.setProperty("sourceCode", statement);
                    
                    // Parse assertion type and arguments
                    if (assertType.equals("equal")) {
                        assertAction.setAssertionType("VALUE_EQUALS");
                        assertAction.setExpectedValue(expected);
                    } else if (assertType.equals("not.equal")) {
                        assertAction.setAssertionType("VALUE_NOT_EQUALS");
                        assertAction.setExpectedValue(expected);
                    } else if (assertType.equals("be") && expected.equals("true")) {
                        assertAction.setAssertionType("BOOLEAN_TRUE");
                    } else if (assertType.equals("be") && expected.equals("false")) {
                        assertAction.setAssertionType("BOOLEAN_FALSE");
                    } else if (assertType.equals("be") && expected.equals("null")) {
                        assertAction.setAssertionType("VALUE_NULL");
                    } else if (assertType.equals("not.be") && expected.equals("null")) {
                        assertAction.setAssertionType("VALUE_NOT_NULL");
                    } else if (assertType.equals("contain")) {
                        assertAction.setAssertionType("VALUE_CONTAINS");
                        assertAction.setExpectedValue(expected);
                    }
                    
                    return assertAction;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detect wait action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a wait action
     */
    private ActionConfig detectWaitAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: waitStrategy, Thread.sleep, or explicit wait
            if (statement.matches(".*[Ww]ait.*") || statement.matches(".*Thread\\.sleep\\(.*\\).*")) {
                WaitActionConfig waitAction = new WaitActionConfig();
                waitAction.setId(UUID.randomUUID().toString());
                waitAction.setActionType(ActionType.WAIT);
                waitAction.setProperty("sourceCode", statement);
                
                if (statement.contains("Thread.sleep(")) {
                    // Sleep wait
                    Pattern pattern = Pattern.compile("Thread\\.sleep\\((\\d+)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String timeout = matcher.group(1);
                        int timeoutMs = Integer.parseInt(timeout);
                        
                        waitAction.setWaitType("FIXED_TIME");
                        waitAction.setTimeout(timeoutMs / 1000); // Convert ms to seconds
                        waitAction.setName("Wait for " + (timeoutMs / 1000) + " seconds");
                        
                        return waitAction;
                    }
                } else if (statement.contains("waitForElementToBeVisible") || statement.contains("waitForVisible")) {
                    // Element visibility wait
                    Pattern pattern = Pattern.compile("([\\w.]+)\\.waitForElementToBeVisible\\((\\d+)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (!matcher.find()) {
                        pattern = Pattern.compile("([\\w.]+)\\.waitForVisible\\((\\d+)\\)");
                        matcher = pattern.matcher(statement);
                    }
                    
                    if (matcher.find()) {
                        String elementVar = matcher.group(1);
                        String timeout = matcher.group(2);
                        int timeoutMs = Integer.parseInt(timeout);
                        
                        waitAction.setWaitType("ELEMENT_VISIBLE");
                        waitAction.setTimeout(timeoutMs / 1000); // Convert ms to seconds
                        waitAction.setName("Wait for element to be visible");
                        waitAction.setProperty("element", elementVar);
                        
                        return waitAction;
                    }
                } else if (statement.contains("waitForElementToBeClickable") || statement.contains("waitForClickable")) {
                    // Element clickable wait
                    Pattern pattern = Pattern.compile("([\\w.]+)\\.waitForElementToBeClickable\\((\\d+)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (!matcher.find()) {
                        pattern = Pattern.compile("([\\w.]+)\\.waitForClickable\\((\\d+)\\)");
                        matcher = pattern.matcher(statement);
                    }
                    
                    if (matcher.find()) {
                        String elementVar = matcher.group(1);
                        String timeout = matcher.group(2);
                        int timeoutMs = Integer.parseInt(timeout);
                        
                        waitAction.setWaitType("ELEMENT_CLICKABLE");
                        waitAction.setTimeout(timeoutMs / 1000); // Convert ms to seconds
                        waitAction.setName("Wait for element to be clickable");
                        waitAction.setProperty("element", elementVar);
                        
                        return waitAction;
                    }
                }
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await waitStrategy, await sleep, or explicit wait
            if (statement.matches(".*await.*[Ww]ait.*") || statement.matches(".*await.*sleep\\(.*\\).*")) {
                WaitActionConfig waitAction = new WaitActionConfig();
                waitAction.setId(UUID.randomUUID().toString());
                waitAction.setActionType(ActionType.WAIT);
                waitAction.setProperty("sourceCode", statement);
                
                if (statement.contains("sleep(")) {
                    // Sleep wait
                    Pattern pattern = Pattern.compile("await\\s+([\\w.]+\\.)?sleep\\((\\d+)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String timeout = matcher.group(2);
                        int timeoutMs = Integer.parseInt(timeout);
                        
                        waitAction.setWaitType("FIXED_TIME");
                        waitAction.setTimeout(timeoutMs / 1000); // Convert ms to seconds
                        waitAction.setName("Wait for " + (timeoutMs / 1000) + " seconds");
                        
                        return waitAction;
                    }
                } else if (statement.contains("waitForElementToBeVisible") || statement.contains("waitForVisible")) {
                    // Element visibility wait
                    Pattern pattern = Pattern.compile("await\\s+([\\w.]+)\\.waitForElementToBeVisible\\((\\d+)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (!matcher.find()) {
                        pattern = Pattern.compile("await\\s+([\\w.]+)\\.waitForVisible\\((\\d+)\\)");
                        matcher = pattern.matcher(statement);
                    }
                    
                    if (matcher.find()) {
                        String elementVar = matcher.group(1);
                        String timeout = matcher.group(2);
                        int timeoutMs = Integer.parseInt(timeout);
                        
                        waitAction.setWaitType("ELEMENT_VISIBLE");
                        waitAction.setTimeout(timeoutMs / 1000); // Convert ms to seconds
                        waitAction.setName("Wait for element to be visible");
                        waitAction.setProperty("element", elementVar);
                        
                        return waitAction;
                    }
                } else if (statement.contains("waitForElementToBeClickable") || statement.contains("waitForClickable")) {
                    // Element clickable wait
                    Pattern pattern = Pattern.compile("await\\s+([\\w.]+)\\.waitForElementToBeClickable\\((\\d+)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (!matcher.find()) {
                        pattern = Pattern.compile("await\\s+([\\w.]+)\\.waitForClickable\\((\\d+)\\)");
                        matcher = pattern.matcher(statement);
                    }
                    
                    if (matcher.find()) {
                        String elementVar = matcher.group(1);
                        String timeout = matcher.group(2);
                        int timeoutMs = Integer.parseInt(timeout);
                        
                        waitAction.setWaitType("ELEMENT_CLICKABLE");
                        waitAction.setTimeout(timeoutMs / 1000); // Convert ms to seconds
                        waitAction.setName("Wait for element to be clickable");
                        waitAction.setProperty("element", elementVar);
                        
                        return waitAction;
                    }
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detect select action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a select action
     */
    private ActionConfig detectSelectAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: CSSelect select = new CSSelect(...); select.selectBy...
            if (statement.matches(".*\\.selectBy(VisibleText|Value|Index)\\(.*\\).*")) {
                Pattern pattern = Pattern.compile("([\\w.]+)\\.selectBy(VisibleText|Value|Index)\\((.+)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String selectVar = matcher.group(1);
                    String selectType = matcher.group(2);
                    String option = matcher.group(3).trim();
                    
                    // Remove quotes if present
                    if ((option.startsWith("\"") && option.endsWith("\"")) || (option.startsWith("'") && option.endsWith("'"))) {
                        option = option.substring(1, option.length() - 1);
                    }
                    
                    ActionConfig selectAction = new ActionConfig();
                    selectAction.setId(UUID.randomUUID().toString());
                    selectAction.setActionType(ActionType.SELECT);
                    selectAction.setName("Select action");
                    selectAction.setProperty("element", selectVar);
                    selectAction.setProperty("option", option);
                    
                    if (selectType.equals("VisibleText")) {
                        selectAction.setProperty("selectBy", "TEXT");
                    } else if (selectType.equals("Value")) {
                        selectAction.setProperty("selectBy", "VALUE");
                    } else if (selectType.equals("Index")) {
                        selectAction.setProperty("selectBy", "INDEX");
                    }
                    
                    selectAction.setProperty("sourceCode", statement);
                    
                    return selectAction;
                }
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await select.selectBy...
            if (statement.matches(".*await.*\\.selectBy(VisibleText|Value|Index)\\(.*\\).*")) {
                Pattern pattern = Pattern.compile("await\\s+([\\w.]+)\\.selectBy(VisibleText|Value|Index)\\((.+)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String selectVar = matcher.group(1);
                    String selectType = matcher.group(2);
                    String option = matcher.group(3).trim();
                    
                    // Remove quotes if present
                    if ((option.startsWith("\"") && option.endsWith("\"")) || (option.startsWith("'") && option.endsWith("'"))) {
                        option = option.substring(1, option.length() - 1);
                    }
                    
                    ActionConfig selectAction = new ActionConfig();
                    selectAction.setId(UUID.randomUUID().toString());
                    selectAction.setActionType(ActionType.SELECT);
                    selectAction.setName("Select action");
                    selectAction.setProperty("element", selectVar);
                    selectAction.setProperty("option", option);
                    
                    if (selectType.equals("VisibleText")) {
                        selectAction.setProperty("selectBy", "TEXT");
                    } else if (selectType.equals("Value")) {
                        selectAction.setProperty("selectBy", "VALUE");
                    } else if (selectType.equals("Index")) {
                        selectAction.setProperty("selectBy", "INDEX");
                    }
                    
                    selectAction.setProperty("sourceCode", statement);
                    
                    return selectAction;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detect hover action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a hover action
     */
    private ActionConfig detectHoverAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: element.hover()
            if (statement.matches(".*\\.hover\\(\\).*")) {
                Pattern pattern = Pattern.compile("([\\w.]+)\\.hover\\(\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String elementVar = matcher.group(1);
                    
                    ActionConfig hoverAction = new ActionConfig();
                    hoverAction.setId(UUID.randomUUID().toString());
                    hoverAction.setActionType(ActionType.HOVER);
                    hoverAction.setName("Hover action");
                    hoverAction.setProperty("element", elementVar);
                    hoverAction.setProperty("sourceCode", statement);
                    
                    return hoverAction;
                }
            } else if (statement.matches(".*Actions.*\\.moveToElement\\(.*\\).*")) {
                // Alternative pattern with Actions class
                Pattern pattern = Pattern.compile(".*\\.moveToElement\\(([^,)]+).*\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String elementVar = matcher.group(1).trim();
                    
                    ActionConfig hoverAction = new ActionConfig();
                    hoverAction.setId(UUID.randomUUID().toString());
                    hoverAction.setActionType(ActionType.HOVER);
                    hoverAction.setName("Hover action");
                    hoverAction.setProperty("element", elementVar);
                    hoverAction.setProperty("sourceCode", statement);
                    
                    return hoverAction;
                }
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await element.hover()
            if (statement.matches(".*await.*\\.hover\\(\\).*")) {
                Pattern pattern = Pattern.compile("await\\s+([\\w.]+)\\.hover\\(\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String elementVar = matcher.group(1);
                    
                    ActionConfig hoverAction = new ActionConfig();
                    hoverAction.setId(UUID.randomUUID().toString());
                    hoverAction.setActionType(ActionType.HOVER);
                    hoverAction.setName("Hover action");
                    hoverAction.setProperty("element", elementVar);
                    hoverAction.setProperty("sourceCode", statement);
                    
                    return hoverAction;
                }
            } else if (statement.matches(".*await.*\\.actions\\(\\).*\\.move\\(.*\\).*")) {
                // Alternative pattern with actions
                Pattern pattern = Pattern.compile(".*\\.move\\(\\{\\s*target:\\s*([^,}]+).*\\}\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String elementVar = matcher.group(1).trim();
                    
                    ActionConfig hoverAction = new ActionConfig();
                    hoverAction.setId(UUID.randomUUID().toString());
                    hoverAction.setActionType(ActionType.HOVER);
                    hoverAction.setName("Hover action");
                    hoverAction.setProperty("element", elementVar);
                    hoverAction.setProperty("sourceCode", statement);
                    
                    return hoverAction;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detect screenshot action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a screenshot action
     */
    private ActionConfig detectScreenshotAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: CSScreenshotManager.capture...
            if (statement.matches(".*CSScreenshotManager\\.capture.*\\(.*\\).*")) {
                ActionConfig screenshotAction = new ActionConfig();
                screenshotAction.setId(UUID.randomUUID().toString());
                screenshotAction.setActionType(ActionType.SCREENSHOT);
                screenshotAction.setName("Screenshot action");
                screenshotAction.setProperty("sourceCode", statement);
                
                if (statement.contains("captureFullPageScreenshot")) {
                    screenshotAction.setProperty("fullPage", true);
                    
                    // Parse file name parameter
                    Pattern pattern = Pattern.compile("captureFullPageScreenshot\\((.+?)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String params = matcher.group(1);
                        String[] paramArray = params.split(",");
                        
                        if (paramArray.length > 0) {
                            String fileName = paramArray[0].trim();
                            // Remove quotes if present
                            if ((fileName.startsWith("\"") && fileName.endsWith("\"")) || 
                                (fileName.startsWith("'") && fileName.endsWith("'"))) {
                                fileName = fileName.substring(1, fileName.length() - 1);
                            }
                            screenshotAction.setProperty("fileName", fileName);
                        }
                        
                        if (paramArray.length > 1) {
                            String directory = paramArray[1].trim();
                            // Remove quotes if present
                            if ((directory.startsWith("\"") && directory.endsWith("\"")) || 
                                (directory.startsWith("'") && directory.endsWith("'"))) {
                                directory = directory.substring(1, directory.length() - 1);
                            }
                            screenshotAction.setProperty("directory", directory);
                        }
                    }
                } else if (statement.contains("captureElementScreenshot")) {
                    // Parse element and file name parameters
                    Pattern pattern = Pattern.compile("captureElementScreenshot\\((.+?),\\s*(.+?)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String element = matcher.group(1).trim();
                        String fileName = matcher.group(2).trim();
                        
                        screenshotAction.setProperty("element", element);
                        
                        // Remove quotes if present
                        if ((fileName.startsWith("\"") && fileName.endsWith("\"")) || 
                            (fileName.startsWith("'") && fileName.endsWith("'"))) {
                            fileName = fileName.substring(1, fileName.length() - 1);
                        }
                        screenshotAction.setProperty("fileName", fileName);
                    }
                } else if (statement.contains("captureScreenshot")) {
                    // Parse file name parameter
                    Pattern pattern = Pattern.compile("captureScreenshot\\((.+?)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String params = matcher.group(1);
                        String[] paramArray = params.split(",");
                        
                        if (paramArray.length > 0) {
                            String fileName = paramArray[0].trim();
                            // Remove quotes if present
                            if ((fileName.startsWith("\"") && fileName.endsWith("\"")) || 
                                (fileName.startsWith("'") && fileName.endsWith("'"))) {
                                fileName = fileName.substring(1, fileName.length() - 1);
                            }
                            screenshotAction.setProperty("fileName", fileName);
                        }
                        
                        if (paramArray.length > 1) {
                            String directory = paramArray[1].trim();
                            // Remove quotes if present
                            if ((directory.startsWith("\"") && directory.endsWith("\"")) || 
                                (directory.startsWith("'") && directory.endsWith("'"))) {
                                directory = directory.substring(1, directory.length() - 1);
                            }
                            screenshotAction.setProperty("directory", directory);
                        }
                    }
                }
                
                return screenshotAction;
            } else if (statement.matches(".*\\.screenshot\\(.*\\).*") || 
                      statement.matches(".*\\.getScreenshotAs\\(.*\\).*")) {
                // Alternative patterns for screenshots
                ActionConfig screenshotAction = new ActionConfig();
                screenshotAction.setId(UUID.randomUUID().toString());
                screenshotAction.setActionType(ActionType.SCREENSHOT);
                screenshotAction.setName("Screenshot action");
                screenshotAction.setProperty("sourceCode", statement);
                
                // Try to extract file path if available
                Pattern pattern = Pattern.compile(".*\\.screenshot\\(\"(.+?)\"\\).*");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String fileName = matcher.group(1);
                    screenshotAction.setProperty("fileName", fileName);
                }
                
                return screenshotAction;
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await CSScreenshotManager.capture...
            if (statement.matches(".*await.*CSScreenshotManager\\.capture.*\\(.*\\).*")) {
                ActionConfig screenshotAction = new ActionConfig();
                screenshotAction.setId(UUID.randomUUID().toString());
                screenshotAction.setActionType(ActionType.SCREENSHOT);
                screenshotAction.setName("Screenshot action");
                screenshotAction.setProperty("sourceCode", statement);
                
                if (statement.contains("captureFullPageScreenshot")) {
                    screenshotAction.setProperty("fullPage", true);
                    
                    // Parse file name parameter
                    Pattern pattern = Pattern.compile("captureFullPageScreenshot\\((.+?)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String params = matcher.group(1);
                        String[] paramArray = params.split(",");
                        
                        if (paramArray.length > 0) {
                            String fileName = paramArray[0].trim();
                            // Remove quotes if present
                            if ((fileName.startsWith("\"") && fileName.endsWith("\"")) || 
                                (fileName.startsWith("'") && fileName.endsWith("'"))) {
                                fileName = fileName.substring(1, fileName.length() - 1);
                            }
                            screenshotAction.setProperty("fileName", fileName);
                        }
                        
                        if (paramArray.length > 1) {
                            String directory = paramArray[1].trim();
                            // Remove quotes if present
                            if ((directory.startsWith("\"") && directory.endsWith("\"")) || 
                                (directory.startsWith("'") && directory.endsWith("'"))) {
                                directory = directory.substring(1, directory.length() - 1);
                            }
                            screenshotAction.setProperty("directory", directory);
                        }
                    }
                } else if (statement.contains("captureElementScreenshot")) {
                    // Parse element and file name parameters
                    Pattern pattern = Pattern.compile("captureElementScreenshot\\((.+?),\\s*(.+?)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String element = matcher.group(1).trim();
                        String fileName = matcher.group(2).trim();
                        
                        screenshotAction.setProperty("element", element);
                        
                        // Remove quotes if present
                        if ((fileName.startsWith("\"") && fileName.endsWith("\"")) || 
                            (fileName.startsWith("'") && fileName.endsWith("'"))) {
                            fileName = fileName.substring(1, fileName.length() - 1);
                        }
                        screenshotAction.setProperty("fileName", fileName);
                    }
                } else if (statement.contains("captureScreenshot")) {
                    // Parse file name parameter
                    Pattern pattern = Pattern.compile("captureScreenshot\\((.+?)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String params = matcher.group(1);
                        String[] paramArray = params.split(",");
                        
                        if (paramArray.length > 0) {
                            String fileName = paramArray[0].trim();
                            // Remove quotes if present
                            if ((fileName.startsWith("\"") && fileName.endsWith("\"")) || 
                                (fileName.startsWith("'") && fileName.endsWith("'"))) {
                                fileName = fileName.substring(1, fileName.length() - 1);
                            }
                            screenshotAction.setProperty("fileName", fileName);
                        }
                        
                        if (paramArray.length > 1) {
                            String directory = paramArray[1].trim();
                            // Remove quotes if present
                            if ((directory.startsWith("\"") && directory.endsWith("\"")) || 
                                (directory.startsWith("'") && directory.endsWith("'"))) {
                                directory = directory.substring(1, directory.length() - 1);
                            }
                            screenshotAction.setProperty("directory", directory);
                        }
                    }
                }
                
                return screenshotAction;
            } else if (statement.matches(".*await.*\\.screenshot\\(.*\\).*")) {
                // Alternative patterns for screenshots
                ActionConfig screenshotAction = new ActionConfig();
                screenshotAction.setId(UUID.randomUUID().toString());
                screenshotAction.setActionType(ActionType.SCREENSHOT);
                screenshotAction.setName("Screenshot action");
                screenshotAction.setProperty("sourceCode", statement);
                
                // Try to extract file path if available
                Pattern pattern = Pattern.compile(".*\\.screenshot\\(\\{\\s*path:\\s*['\"](.+?)['\"].*\\}\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String fileName = matcher.group(1);
                    screenshotAction.setProperty("fileName", fileName);
                }
                
                // Check for fullPage option
                if (statement.contains("fullPage: true")) {
                    screenshotAction.setProperty("fullPage", true);
                }
                
                return screenshotAction;
            }
        }
        
        return null;
    }
    
    /**
     * Detect drag and drop action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a drag and drop action
     */
    private ActionConfig detectDragDropAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: element.dragAndDropTo(target)
            if (statement.matches(".*\\.dragAndDropTo\\(.*\\).*")) {
                Pattern pattern = Pattern.compile("([\\w.]+)\\.dragAndDropTo\\((.+?)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String sourceElementVar = matcher.group(1);
                    String targetElementVar = matcher.group(2).trim();
                    
                    ActionConfig dragDropAction = new ActionConfig();
                    dragDropAction.setId(UUID.randomUUID().toString());
                    dragDropAction.setActionType(ActionType.DRAG_DROP);
                    dragDropAction.setName("Drag and drop action");
                    dragDropAction.setProperty("sourceElement", sourceElementVar);
                    dragDropAction.setProperty("targetElement", targetElementVar);
                    dragDropAction.setProperty("sourceCode", statement);
                    
                    return dragDropAction;
                }
            } else if (statement.matches(".*Actions.*\\.dragAndDrop\\(.*\\).*")) {
                // Alternative pattern with Actions class
                Pattern pattern = Pattern.compile(".*\\.dragAndDrop\\((.+?),\\s*(.+?)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String sourceElementVar = matcher.group(1).trim();
                    String targetElementVar = matcher.group(2).trim();
                    
                    ActionConfig dragDropAction = new ActionConfig();
                    dragDropAction.setId(UUID.randomUUID().toString());
                    dragDropAction.setActionType(ActionType.DRAG_DROP);
                    dragDropAction.setName("Drag and drop action");
                    dragDropAction.setProperty("sourceElement", sourceElementVar);
                    dragDropAction.setProperty("targetElement", targetElementVar);
                    dragDropAction.setProperty("sourceCode", statement);
                    
                    return dragDropAction;
                }
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await element.dragAndDropTo(target)
            if (statement.matches(".*await.*\\.dragAndDropTo\\(.*\\).*")) {
                Pattern pattern = Pattern.compile("await\\s+([\\w.]+)\\.dragAndDropTo\\((.+?)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String sourceElementVar = matcher.group(1);
                    String targetElementVar = matcher.group(2).trim();
                    
                    ActionConfig dragDropAction = new ActionConfig();
                    dragDropAction.setId(UUID.randomUUID().toString());
                    dragDropAction.setActionType(ActionType.DRAG_DROP);
                    dragDropAction.setName("Drag and drop action");
                    dragDropAction.setProperty("sourceElement", sourceElementVar);
                    dragDropAction.setProperty("targetElement", targetElementVar);
                    dragDropAction.setProperty("sourceCode", statement);
                    
                    return dragDropAction;
                }
            } else if (statement.matches(".*await.*\\.dragTo\\(.*\\).*")) {
                // Playwright pattern for drag
                Pattern pattern = Pattern.compile("await\\s+([\\w.]+)\\.dragTo\\((.+?)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String sourceElementVar = matcher.group(1);
                    String targetElementVar = matcher.group(2).trim();
                    
                    ActionConfig dragDropAction = new ActionConfig();
                    dragDropAction.setId(UUID.randomUUID().toString());
                    dragDropAction.setActionType(ActionType.DRAG_DROP);
                    dragDropAction.setName("Drag and drop action");
                    dragDropAction.setProperty("sourceElement", sourceElementVar);
                    dragDropAction.setProperty("targetElement", targetElementVar);
                    dragDropAction.setProperty("sourceCode", statement);
                    
                    return dragDropAction;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detect switch frame action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a switch frame action
     */
    private ActionConfig detectSwitchFrameAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: driver.switchTo().frame(...)
            if (statement.matches(".*\\.switchTo\\(\\)\\.frame\\(.*\\).*")) {
                ActionConfig switchFrameAction = new ActionConfig();
                switchFrameAction.setId(UUID.randomUUID().toString());
                switchFrameAction.setActionType(ActionType.SWITCH_FRAME);
                switchFrameAction.setName("Switch frame action");
                switchFrameAction.setProperty("sourceCode", statement);
                
                if (statement.matches(".*\\.switchTo\\(\\)\\.defaultContent\\(\\).*")) {
                    // Switch to default content
                    switchFrameAction.setProperty("switchToDefault", true);
                } else if (statement.matches(".*\\.switchTo\\(\\)\\.parentFrame\\(\\).*")) {
                    // Switch to parent frame
                    switchFrameAction.setProperty("switchToParent", true);
                } else {
                    // Switch to specific frame
                    Pattern pattern = Pattern.compile(".*\\.switchTo\\(\\)\\.frame\\((.+?)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String frameLocator = matcher.group(1).trim();
                        
                        // Check if it's an index
                        if (frameLocator.matches("\\d+")) {
                            switchFrameAction.setProperty("frameLocator", frameLocator);
                            switchFrameAction.setProperty("frameLocatorType", "INDEX");
                        } else {
                            // Assume it's an element
                            switchFrameAction.setProperty("frameElement", frameLocator);
                        }
                    }
                }
                
                return switchFrameAction;
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await driver.switchTo().frame(...)
            if (statement.matches(".*await.*\\.switchTo\\(\\)\\.frame\\(.*\\).*")) {
                ActionConfig switchFrameAction = new ActionConfig();
                switchFrameAction.setId(UUID.randomUUID().toString());
                switchFrameAction.setActionType(ActionType.SWITCH_FRAME);
                switchFrameAction.setName("Switch frame action");
                switchFrameAction.setProperty("sourceCode", statement);
                
                if (statement.matches(".*\\.switchTo\\(\\)\\.defaultContent\\(\\).*")) {
                    // Switch to default content
                    switchFrameAction.setProperty("switchToDefault", true);
                } else if (statement.matches(".*\\.switchTo\\(\\)\\.parentFrame\\(\\).*")) {
                    // Switch to parent frame
                    switchFrameAction.setProperty("switchToParent", true);
                } else {
                    // Switch to specific frame
                    Pattern pattern = Pattern.compile(".*\\.switchTo\\(\\)\\.frame\\((.+?)\\)");
                    java.util.regex.Matcher matcher = pattern.matcher(statement);
                    
                    if (matcher.find()) {
                        String frameLocator = matcher.group(1).trim();
                        
                        // Check if it's an index
                        if (frameLocator.matches("\\d+")) {
                            switchFrameAction.setProperty("frameLocator", frameLocator);
                            switchFrameAction.setProperty("frameLocatorType", "INDEX");
                        } else {
                            // Assume it's an element
                            switchFrameAction.setProperty("frameElement", frameLocator);
                        }
                    }
                }
                
                return switchFrameAction;
            } else if (statement.matches(".*await.*\\.frame\\(.*\\).*") || 
                       statement.matches(".*await.*\\.frameLocator\\(.*\\).*")) {
                // Playwright pattern: await page.frame(...) or page.frameLocator(...)
                ActionConfig switchFrameAction = new ActionConfig();
                switchFrameAction.setId(UUID.randomUUID().toString());
                switchFrameAction.setActionType(ActionType.SWITCH_FRAME);
                switchFrameAction.setName("Switch frame action");
                switchFrameAction.setProperty("sourceCode", statement);
                
                Pattern pattern = statement.contains("frameLocator") ? 
                        Pattern.compile(".*\\.frameLocator\\((.+?)\\)") : 
                        Pattern.compile(".*\\.frame\\((.+?)\\)");
                
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String frameLocator = matcher.group(1).trim();
                    
                    // Check if it's an index or name
                    if (frameLocator.matches("\\d+")) {
                        switchFrameAction.setProperty("frameLocator", frameLocator);
                        switchFrameAction.setProperty("frameLocatorType", "INDEX");
                    } else {
                        // Remove quotes if present
                        if ((frameLocator.startsWith("\"") && frameLocator.endsWith("\"")) || 
                            (frameLocator.startsWith("'") && frameLocator.endsWith("'"))) {
                            frameLocator = frameLocator.substring(1, frameLocator.length() - 1);
                        }
                        
                        switchFrameAction.setProperty("frameLocator", frameLocator);
                        
                        // Try to determine locator type
                        if (frameLocator.startsWith("//")) {
                            switchFrameAction.setProperty("frameLocatorType", "XPATH");
                        } else {
                            switchFrameAction.setProperty("frameLocatorType", "CSS");
                        }
                    }
                }
                
                return switchFrameAction;
            }
        }
        
        return null;
    }
    
    /**
     * Detect switch window action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not a switch window action
     */
    private ActionConfig detectSwitchWindowAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: driver.switchTo().window(...)
            if (statement.matches(".*\\.switchTo\\(\\)\\.window\\(.*\\).*")) {
                ActionConfig switchWindowAction = new ActionConfig();
                switchWindowAction.setId(UUID.randomUUID().toString());
                switchWindowAction.setActionType(ActionType.SWITCH_WINDOW);
                switchWindowAction.setName("Switch window action");
                switchWindowAction.setProperty("sourceCode", statement);
                
                Pattern pattern = Pattern.compile(".*\\.switchTo\\(\\)\\.window\\((.+?)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String windowHandle = matcher.group(1).trim();
                    
                    // Check if it's a window handle variable or a direct string
                    if ((windowHandle.startsWith("\"") && windowHandle.endsWith("\"")) || 
                        (windowHandle.startsWith("'") && windowHandle.endsWith("'"))) {
                        // Direct window handle string
                        windowHandle = windowHandle.substring(1, windowHandle.length() - 1);
                        switchWindowAction.setProperty("windowHandle", windowHandle);
                    } else {
                        // Variable containing window handle or index
                        switchWindowAction.setProperty("windowHandleVariable", windowHandle);
                        
                        // Try to determine if it's an index from context
                        if (statement.contains("windowHandles.get(") || statement.contains("handles.get(")) {
                            Pattern indexPattern = Pattern.compile("get\\((\\d+)\\)");
                            java.util.regex.Matcher indexMatcher = indexPattern.matcher(statement);
                            
                            if (indexMatcher.find()) {
                                String indexStr = indexMatcher.group(1);
                                int index = Integer.parseInt(indexStr);
                                switchWindowAction.setProperty("windowIndex", index);
                            }
                        }
                    }
                }
                
                return switchWindowAction;
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await driver.switchTo().window(...)
            if (statement.matches(".*await.*\\.switchTo\\(\\)\\.window\\(.*\\).*")) {
                ActionConfig switchWindowAction = new ActionConfig();
                switchWindowAction.setId(UUID.randomUUID().toString());
                switchWindowAction.setActionType(ActionType.SWITCH_WINDOW);
                switchWindowAction.setName("Switch window action");
                switchWindowAction.setProperty("sourceCode", statement);
                
                Pattern pattern = Pattern.compile(".*\\.switchTo\\(\\)\\.window\\((.+?)\\)");
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String windowHandle = matcher.group(1).trim();
                    
                    // Check if it's a window handle variable or a direct string
                    if ((windowHandle.startsWith("\"") && windowHandle.endsWith("\"")) || 
                        (windowHandle.startsWith("'") && windowHandle.endsWith("'"))) {
                        // Direct window handle string
                        windowHandle = windowHandle.substring(1, windowHandle.length() - 1);
                        switchWindowAction.setProperty("windowHandle", windowHandle);
                    } else {
                        // Variable containing window handle or index
                        switchWindowAction.setProperty("windowHandleVariable", windowHandle);
                        
                        // Try to determine if it's an index from context
                        if (statement.contains("windowHandles[") || statement.contains("handles[")) {
                            Pattern indexPattern = Pattern.compile("\\[(\\d+)\\]");
                            java.util.regex.Matcher indexMatcher = indexPattern.matcher(statement);
                            
                            if (indexMatcher.find()) {
                                String indexStr = indexMatcher.group(1);
                                int index = Integer.parseInt(indexStr);
                                switchWindowAction.setProperty("windowIndex", index);
                            }
                        }
                    }
                }
                
                return switchWindowAction;
            } else if (frameworkType == FrameworkType.PLAYWRIGHT && 
                      (statement.contains("context.pages()") || statement.contains("browser.contexts"))) {
                // Playwright pattern for switching context/page
                ActionConfig switchWindowAction = new ActionConfig();
                switchWindowAction.setId(UUID.randomUUID().toString());
                switchWindowAction.setActionType(ActionType.SWITCH_WINDOW);
                switchWindowAction.setName("Switch window action");
                switchWindowAction.setProperty("sourceCode", statement);
                
                if (statement.contains("pages[")) {
                    // Switching by index
                    Pattern indexPattern = Pattern.compile("pages\\[(\\d+)\\]");
                    java.util.regex.Matcher indexMatcher = indexPattern.matcher(statement);
                    
                    if (indexMatcher.find()) {
                        String indexStr = indexMatcher.group(1);
                        int index = Integer.parseInt(indexStr);
                        switchWindowAction.setProperty("windowIndex", index);
                    }
                } else if (statement.contains("page.goto")) {
                    // Extract URL for better context
                    Pattern urlPattern = Pattern.compile("goto\\(['\"](.+?)['\"]");
                    java.util.regex.Matcher urlMatcher = urlPattern.matcher(statement);
                    
                    if (urlMatcher.find()) {
                        String url = urlMatcher.group(1);
                        switchWindowAction.setProperty("windowUrl", url);
                    }
                }
                
                return switchWindowAction;
            }
        }
        
        return null;
    }
    
    /**
     * Detect execute script action from statement.
     * 
     * @param statement Code statement
     * @param frameworkType Framework type
     * @param languageType Language type
     * @return ActionConfig or null if not an execute script action
     */
    private ActionConfig detectExecuteScriptAction(String statement, FrameworkType frameworkType, LanguageType languageType) {
        if (languageType == LanguageType.JAVA) {
            // Java pattern: JavascriptExecutor jsExecutor = (JavascriptExecutor) driver; jsExecutor.executeScript(...)
            if (statement.matches(".*\\.executeScript\\(.*\\).*") || statement.matches(".*\\.executeAsyncScript\\(.*\\).*")) {
                ActionConfig executeScriptAction = new ActionConfig();
                executeScriptAction.setId(UUID.randomUUID().toString());
                executeScriptAction.setActionType(ActionType.EXECUTE_SCRIPT);
                executeScriptAction.setName("Execute script action");
                executeScriptAction.setProperty("sourceCode", statement);
                
                Pattern pattern = statement.contains("executeAsyncScript") ? 
                        Pattern.compile(".*\\.executeAsyncScript\\((.+)\\)") : 
                        Pattern.compile(".*\\.executeScript\\((.+)\\)");
                
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String scriptArgs = matcher.group(1).trim();
                    
                    // Extract script
                    if ((scriptArgs.startsWith("\"") && scriptArgs.contains("\")")) || 
                        (scriptArgs.startsWith("'") && scriptArgs.contains("')"))) {
                        
                        // Find the end of the script string
                        int scriptEndIndex;
                        if (scriptArgs.startsWith("\"")) {
                            scriptEndIndex = scriptArgs.indexOf("\")");
                            if (scriptEndIndex == -1) {
                                scriptEndIndex = scriptArgs.lastIndexOf("\"");
                            }
                        } else {
                            scriptEndIndex = scriptArgs.indexOf("')");
                            if (scriptEndIndex == -1) {
                                scriptEndIndex = scriptArgs.lastIndexOf("'");
                            }
                        }
                        
                        if (scriptEndIndex > 0) {
                            String script = scriptArgs.substring(1, scriptEndIndex);
                            executeScriptAction.setProperty("script", script);
                            
                            // Extract arguments if any
                            if (scriptEndIndex + 1 < scriptArgs.length()) {
                                String argsStr = scriptArgs.substring(scriptEndIndex + 1).trim();
                                if (argsStr.startsWith(",")) {
                                    argsStr = argsStr.substring(1).trim();
                                    String[] args = argsStr.split(",");
                                    
                                    List<String> argList = new ArrayList<>();
                                    for (String arg : args) {
                                        argList.add(arg.trim());
                                    }
                                    
                                    executeScriptAction.setProperty("arguments", argList);
                                }
                            }
                            
                            // Check if result is stored
                            if (statement.matches(".*\\w+\\s*=\\s*.*\\.executeScript.*")) {
                                Pattern resultPattern = Pattern.compile("(\\w+)\\s*=\\s*.*\\.executeScript");
                                java.util.regex.Matcher resultMatcher = resultPattern.matcher(statement);
                                
                                if (resultMatcher.find()) {
                                    String resultVar = resultMatcher.group(1);
                                    executeScriptAction.setProperty("resultVariable", resultVar);
                                }
                            }
                        }
                    }
                }
                
                return executeScriptAction;
            }
        } else if (languageType == LanguageType.TYPESCRIPT) {
            // TypeScript pattern: await driver.executeScript(...) or await page.evaluate(...)
            if (statement.matches(".*await.*\\.executeScript\\(.*\\).*") || 
                statement.matches(".*await.*\\.evaluate\\(.*\\).*")) {
                
                ActionConfig executeScriptAction = new ActionConfig();
                executeScriptAction.setId(UUID.randomUUID().toString());
                executeScriptAction.setActionType(ActionType.EXECUTE_SCRIPT);
                executeScriptAction.setName("Execute script action");
                executeScriptAction.setProperty("sourceCode", statement);
                
                Pattern pattern = statement.contains("evaluate") ? 
                        Pattern.compile(".*\\.evaluate\\((.+)\\)") : 
                        Pattern.compile(".*\\.executeScript\\((.+)\\)");
                
                java.util.regex.Matcher matcher = pattern.matcher(statement);
                
                if (matcher.find()) {
                    String scriptArgs = matcher.group(1).trim();
                    
                    // Extract script
                    if ((scriptArgs.startsWith("`") && scriptArgs.contains("`")) || 
                        (scriptArgs.startsWith("\"") && scriptArgs.contains("\"")) || 
                        (scriptArgs.startsWith("'") && scriptArgs.contains("'"))) {
                        
                        // Find the end of the script string
                        int scriptEndIndex;
                        char scriptDelimiter;
                        
                        if (scriptArgs.startsWith("`")) {
                            scriptDelimiter = '`';
                        } else if (scriptArgs.startsWith("\"")) {
                            scriptDelimiter = '"';
                        } else {
                            scriptDelimiter = '\'';
                        }
                        
                        // Find closing quotation mark
                        scriptEndIndex = -1;
                        for (int i = 1; i < scriptArgs.length(); i++) {
                            if (scriptArgs.charAt(i) == scriptDelimiter && 
                                (i == 0 || scriptArgs.charAt(i - 1) != '\\')) {
                                scriptEndIndex = i;
                                break;
                            }
                        }
                        
                        if (scriptEndIndex > 0) {
                            String script = scriptArgs.substring(1, scriptEndIndex);
                            executeScriptAction.setProperty("script", script);
                            
                            // Extract arguments if any
                            if (scriptEndIndex + 1 < scriptArgs.length()) {
                                String argsStr = scriptArgs.substring(scriptEndIndex + 1).trim();
                                if (argsStr.startsWith(",")) {
                                    argsStr = argsStr.substring(1).trim();
                                    String[] args = argsStr.split(",");
                                    
                                    List<String> argList = new ArrayList<>();
                                    for (String arg : args) {
                                        argList.add(arg.trim());
                                    }
                                    
                                    executeScriptAction.setProperty("arguments", argList);
                                }
                            }
                            
                            // Check if result is stored
                            if (statement.matches(".*const\\s+\\w+\\s*=\\s*await.*")) {
                                Pattern resultPattern = Pattern.compile("const\\s+(\\w+)\\s*=\\s*await");
                                java.util.regex.Matcher resultMatcher = resultPattern.matcher(statement);
                                
                                if (resultMatcher.find()) {
                                    String resultVar = resultMatcher.group(1);
                                    executeScriptAction.setProperty("resultVariable", resultVar);
                                }
                            } else if (statement.matches(".*let\\s+\\w+\\s*=\\s*await.*")) {
                                Pattern resultPattern = Pattern.compile("let\\s+(\\w+)\\s*=\\s*await");
                                java.util.regex.Matcher resultMatcher = resultPattern.matcher(statement);
                                
                                if (resultMatcher.find()) {
                                    String resultVar = resultMatcher.group(1);
                                    executeScriptAction.setProperty("resultVariable", resultVar);
                                }
                            } else if (statement.matches(".*var\\s+\\w+\\s*=\\s*await.*")) {
                                Pattern resultPattern = Pattern.compile("var\\s+(\\w+)\\s*=\\s*await");
                                java.util.regex.Matcher resultMatcher = resultPattern.matcher(statement);
                                
                                if (resultMatcher.find()) {
                                    String resultVar = resultMatcher.group(1);
                                    executeScriptAction.setProperty("resultVariable", resultVar);
                                }
                            }
                        }
                    }
                }
                
                return executeScriptAction;
            }
        }
        
        return null;
    }
}
