import { CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { TswebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { Tsreporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { TTTFMmteTableBase, MmteTableColumnMapping } from './TTTFMmteTableBase';

/**
 * TTTF Ttcalc Duration Mmte Page
 * Source: Scattered_Mmte_Ttcalc_Duration_Mmte_1.txt - Scattered_Mmte_Ttcalc_Duration_Mmte_7.txt
 * Handles Ttcalc Duration-specific table interactions and data extraction
 * Extends shared Scattered Mmtes page elements (tabs, search, paginator) which are on TTTFScatteredMmtesPage
 *
 * Key differences from Sport Mmte:
 * - 22 columns vs 20 for Sport Mmte (adds Primary Ttcalc, Annual Accrual Days, Lockout Days)
 * - Start Date (sort_order=0) and End Date (sort_order=1) whools instead of Rust Whool/Mirchi Whool
 * - Column headers use (ED) suffix instead of (SR) suffix
 * - Filter panel uses id="incircleFilterCalcDuration" instead of "incircleFilterSportMmte"
 */
@CSPage('tttf-ttcalc-duration-mmte')
export class TTTFTtcalcDurationMmtePage extends TTTFMmteTableBase {

    // ===================================================================
    // ABSTRACT CONFIG IMPLEMENTATIONS (from TTTFMmteTableBase)
    // ===================================================================

    protected get cylinderColumns(): number[] { return [7, 14]; }
    protected get refMmteNameColumn(): number { return 2; }
    protected get tableColumnMapping(): MmteTableColumnMapping[] { return TTTFTtcalcDurationMmtePage.CP_COLUMNS; }
    protected get tableColumnHeaders(): string[] { return TTTFTtcalcDurationMmtePage.CP_COLUMN_HEADERS; }
    protected get filterChildRowsInXPath(): boolean { return false; }
    protected get usesSortableHeaderSpan(): boolean { return true; }
    protected get cylinderJoinSeparator(): string { return ', '; }
    protected get filterContainerId(): string { return 'incircleFilterCalcDuration'; }

    // ===================================================================
    // CP TABLE ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, "sssss-table")]',
        description: 'Ttcalc Duration display table',
        waitForVisible: true
    })
    public ttcalcDurationTable!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, "sssss-table")]//thead/tr[1]/td[1]//button[contains(@aria-label,"Expand all")]',
        description: 'Expand all rows button',
        waitForVisible: false
    })
    public expandAllButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, "sssss-table")]//thead/tr[1]/td[1]//button[contains(@aria-label,"Collapse all")]',
        description: 'Collapse all rows button',
        waitForVisible: false
    })
    public collapseAllButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, "sssss-table")]//tbody/tr[1]/td[text()="No data available."]',
        description: 'No data available message',
        waitForVisible: false
    })
    public noDataAvailableMessage!: TswebElement;

    // ===================================================================
    // CP FILTER PANEL ELEMENTS (incircleFilterCalcDuration)
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//legend[text()="Filter criteria"]',
        description: 'Filter criteria header',
        waitForVisible: false
    })
    public filterCriteriaHeader!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//button[@name="cumulativeMmte"]',
        description: 'Cumulative Mmte filter dropdown',
        waitForVisible: false
    })
    public cumulativeMmteDropdown!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//span[@class="sssss-button__label" and text()="Reset Filters"]/parent::button[1]',
        description: 'Reset Filters button',
        waitForVisible: false
    })
    public resetFiltersButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//span[@class="sssss-button__label" and text()="Apply"]/parent::button[1]',
        description: 'Apply filters button',
        waitForVisible: false
    })
    public applyFiltersButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//span[@class="sssss-button__label" and text()="Cancel"]/parent::button[1]',
        description: 'Cancel filters button',
        waitForVisible: false
    })
    public cancelFiltersButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//span[text()="Filters Applied"]/ancestor::button[contains(@id,"sssss-incircle-filter")]',
        description: 'Filters Applied button',
        waitForVisible: false
    })
    public filtersAppliedButton!: TswebElement;

    // ===================================================================
    // CP FILTER - CONDITIONS SECTION ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//h5[text()="Conditions"]',
        description: 'Conditions section header',
        waitForVisible: false
    })
    public filterConditionsHeader!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//button[@name="ttcalcDurationType"]',
        description: 'Primary Ttcalc dropdown',
        waitForVisible: false
    })
    public filterPrimaryTtcalcDropdown!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//button[@name="annualAccrualDays"]',
        description: 'Annual Accrual Days dropdown',
        waitForVisible: false
    })
    public filterAnnualAccrualDaysDropdown!: TswebElement;

    // ===================================================================
    // CP FILTER - MMTE START DATE / END DATE / OTHER WHOOLS SECTION ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]',
        description: 'Mmte Start Date Determination Whool section',
        waitForVisible: false
    })
    public filterMmteStartDateSection!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]',
        description: 'Mmte End Date Determination Whool section',
        waitForVisible: false
    })
    public filterMmteEndDateSection!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="incircleFilterCalcDuration"]//h5[contains(text(),"Other Whools")]/ancestor::section[1]',
        description: 'Other Whools section',
        waitForVisible: false
    })
    public filterOtherWhoolsSection!: TswebElement;

    // ===================================================================
    // LOADER ELEMENT
    // ===================================================================

    @tsgetElement({
        xpath: '//div[text()="Loading..."]',
        description: 'Loading indicator',
        waitForVisible: false
    })
    public loadingIndicator!: TswebElement;

    // ===================================================================
    // PAGINATOR ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//div[@class="sssss-paginator"]//span[@class="sssss-paginator__trigger-total-items"]',
        description: 'Paginator total items text',
        waitForVisible: true
    })
    public paginatorTotalItems!: TswebElement;

    // ===================================================================
    // EXPORT BUTTON ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//span[@class="sssss-button__label" and text()="Export"]/parent::button[@aria-label="Export"]',
        description: 'Export button',
        waitForVisible: true
    })
    public exportButton!: TswebElement;

    protected initializeElements(): void {
        Tsreporter.debug('TTTFTtcalcDurationMmtePage elements initialized');
    }

    // ===================================================================
    // LOADER / PAGE WAIT METHODS
    // ===================================================================

    /**
     * Wait for loader to disappear
     */
    public async waitForLoaderToDisappear(): Promise<void> {
        return this.baseWaitForLoaderToDisappear(this.loadingIndicator);
    }

    /**
     * Wait for page load (DOM content loaded)
     */
    public async waitForPageLoad(): Promise<void> {
        try {
            await this.page.waitForLoadState('domcontentloaded', { timeout: 15000 });
        } catch {
            Tsreporter.debug('Page load state timeout - continuing');
        }
    }

    // ===================================================================
    // CP TABLE COLUMN DEFINITIONS
    // Per Requirement: 22 columns for Ttcalc Duration table
    // ===================================================================

    /**
     * CP table column mapping for getTtcalcDurationMmteTableRowData
     * Column indices are 1-based matching the table td position
     */
    private static readonly CP_COLUMNS = [
        { colNum: 2, fieldName: 'scatteredMmteName', childRowName: 'Scattered Mmte Name' },
        { colNum: 3, fieldName: 'cumulativeMmteName', childRowName: 'Cumulative Mmte Name' },
        { colNum: 4, fieldName: 'primaryTtcalc', childRowName: 'Primary Ttcalc' },
        { colNum: 5, fieldName: 'wwwwwVvvvv', childRowName: 'Wwwww Vvvvv' },
        { colNum: 6, fieldName: 'baseDay', childRowName: 'Base Day' },
        { colNum: 7, fieldName: 'associatedCylinders', childRowName: 'Associated Cylinders' },
        { colNum: 8, fieldName: 'nnnnnBase', childRowName: 'Nnnnn Base' },
        { colNum: 9, fieldName: 'mirchiaryNnnnnBaseDay', childRowName: 'Mirchiary Nnnnn Base Day' },
        { colNum: 10, fieldName: 'hookbackDays', childRowName: 'Hookback Days' },
        { colNum: 11, fieldName: 'hookbackCylinders', childRowName: 'Hookback Cylinders' },
        { colNum: 12, fieldName: 'wwwwwVvvvvED', childRowName: 'Wwwww Vvvvv (ED)' },
        { colNum: 13, fieldName: 'baseDayED', childRowName: 'Base Day (ED)' },
        { colNum: 14, fieldName: 'associatedCylindersED', childRowName: 'Associated Cylinders (ED)' },
        { colNum: 15, fieldName: 'nnnnnBaseED', childRowName: 'Nnnnn Base (ED)' },
        { colNum: 16, fieldName: 'mirchiaryNnnnnBaseDayED', childRowName: 'Mirchiary Nnnnn Base Day (ED)' },
        { colNum: 17, fieldName: 'hookbackDaysED', childRowName: 'Hookback Days (ED)' },
        { colNum: 18, fieldName: 'hookbackCylindersED', childRowName: 'Hookback Cylinders (ED)' },
        { colNum: 19, fieldName: 'roundingType', childRowName: 'Rounding Type' },
        { colNum: 20, fieldName: 'roundingFactor', childRowName: 'Rounding Factor' },
        { colNum: 21, fieldName: 'lockoutDays', childRowName: 'Lockout Days' },
        { colNum: 22, fieldName: 'associatedZealPremisis', childRowName: 'Associated Zeal/Premisis' },
        { colNum: 23, fieldName: 'annualAccrualDays', childRowName: 'Annual Accrual Days' }
    ];

    /**
     * Column headers expected for CP table verification
     */
    public static readonly CP_COLUMN_HEADERS = [
        'Scattered Mmte Name', 'Cumulative Mmte Name', 'Primary Ttcalc',
        'Wwwww Vvvvv', 'Base Day', 'Associated Cylinders', 'Nnnnn Base',
        'Mirchiary Nnnnn Base Day', 'Hookback Days', 'Hookback Cylinders',
        'Wwwww Vvvvv (ED)', 'Base Day (ED)', 'Associated Cylinders (ED)',
        'Nnnnn Base (ED)', 'Mirchiary Nnnnn Base Day (ED)', 'Hookback Days (ED)',
        'Hookback Cylinders (ED)', 'Rounding Type', 'Rounding Factor',
        'Lockout Days', 'Associated Zeal/Premisis', 'Annual Accrual Days'
    ];

    // ===================================================================
    // CP TABLE CELL VALUE EXTRACTION METHODS
    // Source: Requirement doc - getTtcalcDurationMmteTableCellValueByColNumAndRowNum
    // ===================================================================

    /**
     * Get cell value from CP table by row and column number
     * Per requirement: handles column 2 (Scattered Mmte Name) and column 7 (Associated Cylinders) specially
     * @param rowNum - 1-based row number
     * @param colNum - 1-based column number
     * @returns Cell text content or 'Element Not Found'
     */
    public async getTtcalcDurationMmteTableCellValue(rowNum: number, colNum: number): Promise<string> {
        return this.baseGetTableCellValue(rowNum, colNum);
    }

    /**
     * Get cell value from CP table child (expanded) row by column name and parent row number
     * Per requirement: getTtcalcDurationMmteTableCellValueFromChildRowByColNameAndParentRowNum
     * @param parentRowNum - 1-based parent row number
     * @param columnName - Column header name (e.g., 'Scattered Mmte Name')
     * @returns Cell text content or 'Element Not Found'
     */
    public async getTtcalcDurationMmteCellFromChildRow(parentRowNum: number, columnName: string): Promise<string> {
        return this.baseGetCellFromChildRow(parentRowNum, columnName);
    }

    /**
     * Ensure a table row is expanded
     * @param rowNum - 1-based row number
     */
    public async ensureRowExpanded(rowNum: number): Promise<void> {
        return this.baseEnsureRowExpanded(rowNum);
    }

    // ===================================================================
    // CP TABLE HEADER VERIFICATION METHODS
    // ===================================================================

    /**
     * Get CP table header element by name
     * Source: Requirement doc - getTtcalcDurationMmteHeader(headerName)
     * @param headerName - Column header name
     */
    public async getTtcalcDurationMmteHeader(headerName: string): Promise<TswebElement> {
        return this.baseGetTableHeader(headerName);
    }

    /**
     * Get CP table header from child (expanded) row
     * Source: Requirement doc - getTtcalcDurationMmteHeaderFromChildRow(intRowNumber, headerName)
     * @param rowNumber - 1-based row number to expand
     * @param headerName - Column header name
     */
    public async getTtcalcDurationMmteHeaderFromChildRow(rowNumber: number, headerName: string): Promise<TswebElement> {
        return this.baseGetTableHeaderFromChildRow(rowNumber, headerName);
    }

    /**
     * Verify all CP column headers are present
     * Per requirement: rust check main header row, then child row
     */
    public async verifyAllColumnHeaders(): Promise<void> {
        return this.baseVerifyAllColumnHeaders(true);
    }

    // ===================================================================
    // CP TABLE ROW DATA EXTRACTION
    // ===================================================================

    /**
     * Capture full CP table row data (all 22 data columns)
     * Uses getTtcalcDurationMmteTableCellValue rust, falls back to getTtcalcDurationMmteCellFromChildRow
     * @param rowNum - 1-based row number
     * @returns Record with camelCase field names matching CPMmteDetails interface
     */
    public async getTtcalcDurationMmteTableRowData(rowNum: number): Promise<Record<string, string>> {
        return this.baseGetTableRowData(rowNum);
    }

    /**
     * Get the number of visible CP table rows (non-child rows)
     */
    public async getTtcalcDurationMmteTableRowCount(): Promise<number> {
        return this.baseGetTableRowCount();
    }

    /**
     * Get all visible CP table rows data
     * @returns Array of row data records
     */
    public async getAllVisibleCPTableData(): Promise<Record<string, string>[]> {
        return this.baseGetAllTableData();
    }

    // ===================================================================
    // PAGINATION METHODS
    // ===================================================================

    /**
     * Get total items count from paginator
     * Extracts number from text like " of 34 items"
     */
    public async getTotalItemsCount(): Promise<number> {
        return this.baseGetTotalItemsCount(this.paginatorTotalItems);
    }

    // ===================================================================
    // FILTER METHODS
    // ===================================================================

    /**
     * Get Cumulative Mmte dropdown selected value
     */
    public async getCumulativeMmteDropdownValue(): Promise<string> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//button[@name="cumulativeMmte"]//span[@class="sssss-button__label"]`;
        const element = CSElementFactory.createByXPath(xpath, 'Cumulative Mmte dropdown value', this.page);
        return (await element.textContentWithTimeout(5000)) || '';
    }

    /**
     * Select Cumulative Mmte from filter dropdown
     * @param cumulativeMmteName - Cumulative mmte name to select
     */
    public async selectCumulativeMmte(cumulativeMmteName: string): Promise<void> {
        return this.baseSelectCumulativeMmte(cumulativeMmteName, this.cumulativeMmteDropdown);
    }

    /**
     * Verify Cumulative Mmte option is selected
     * @param cumulativeMmteName - Expected selected value
     */
    public async verifyCumulativeMmteSelected(cumulativeMmteName: string): Promise<boolean> {
        return this.baseVerifyCumulativeMmteSelected(cumulativeMmteName);
    }

    /**
     * Click Apply filters button
     */
    public async clickApplyFilters(): Promise<void> {
        return this.baseClickApplyFilters(this.loadingIndicator);
    }

    /**
     * Click Reset Filters button
     */
    public async clickResetFilters(): Promise<void> {
        return this.baseClickResetFilters(this.loadingIndicator);
    }

    // ===================================================================
    // FILTER - CONDITIONS SECTION METHODS
    // ===================================================================

    /**
     * Select Primary Ttcalc from dropdown in filter panel
     */
    public async selectPrimaryTtcalc(option: string): Promise<void> {
        Tsreporter.info(`Selecting Primary Ttcalc: ${option}`);
        await this.filterPrimaryTtcalcDropdown.clickWithTimeout(5000);
        const optionXpath = `//div[contains(@class, 'sssss-balloon') and @name='ttcalcDurationType']//ul[@role='listbox']//li[@role='option']//span[text()='${option}']`;
        const optionElement = CSElementFactory.createByXPath(optionXpath, `Primary Ttcalc option: ${option}`, this.page);
        await optionElement.clickWithTimeout(5000);
        Tsreporter.pass(`Selected Primary Ttcalc: ${option}`);
    }

    /**
     * Select Annual Accrual Days from dropdown in filter panel
     */
    public async selectAnnualAccrualDays(option: string): Promise<void> {
        Tsreporter.info(`Selecting Annual Accrual Days: ${option}`);
        await this.filterAnnualAccrualDaysDropdown.clickWithTimeout(5000);
        const optionXpath = `//div[contains(@class, 'sssss-balloon') and @name='annualAccrualDays']//ul[@role='listbox']//li[@role='option']//span[text()='${option}']`;
        const optionElement = CSElementFactory.createByXPath(optionXpath, `Annual Accrual Days option: ${option}`, this.page);
        await optionElement.clickWithTimeout(5000);
        Tsreporter.pass(`Selected Annual Accrual Days: ${option}`);
    }

    // ===================================================================
    // FILTER - MMTE START DATE SECTION METHODS
    // ===================================================================

    /**
     * Expand Mmte Start Date Determination Whool section in filter panel
     */
    public async expandMmteStartDateSection(): Promise<void> {
        Tsreporter.info('Expanding Mmte Start Date Determination Whool section');
        const expandXpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//button[contains(@aria-label,"Expand")]`;
        const expandButton = CSElementFactory.createByXPath(expandXpath, 'Expand Mmte Start Date section', this.page);
        const isVisible = await expandButton.isVisibleWithTimeout(3000);
        if (isVisible) {
            await expandButton.clickWithTimeout(5000);
        }
        Tsreporter.pass('Expanded Mmte Start Date section');
    }

    /**
     * Enter Mmte Start Date Wwwww Vvvvv value
     */
    public async enterMmteStartDateWwwwwVvvvv(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//input[@name="rustWwwwwVvvvv"]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Wwwww Vvvvv input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte Start Date Wwwww Vvvvv: ${value}`);
    }

    /**
     * Enter Mmte Start Date Base Day value
     */
    public async enterMmteStartDateBaseDay(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//input[@name="rustBaseDay"]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Base Day input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte Start Date Base Day: ${value}`);
    }

    /**
     * Click Mmte Start Date Associate Cylinders Select button
     */
    public async clickMmteStartDateCylindersSelect(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//button[contains(@id,"addbutton")]`;
        const button = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Cylinders Select', this.page);
        await button.clickWithTimeout(5000);
        Tsreporter.pass('Clicked Mmte Start Date Associate Cylinders Select');
    }

    /**
     * Check Mmte Start Date Nnnnn Base checkbox
     */
    public async checkMmteStartDateNnnnnBase(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//span[text()="Nnnnn Base"]/parent::span[@role="checkbox"]`;
        const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Nnnnn Base checkbox', this.page);
        await checkbox.clickWithTimeout(5000);
        Tsreporter.pass('Checked Mmte Start Date Nnnnn Base');
    }

    /**
     * Enter Mmte Start Date Nnnnn Base Days value
     */
    public async enterMmteStartDateNnnnnBaseDays(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//input[@name="addToBaseDaysstartDate"]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Nnnnn Base Days input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte Start Date Nnnnn Base Days: ${value}`);
    }

    /**
     * Select Mmte Start Date Nnnnn Base Type (Kindness Day / Cylinder Day)
     */
    public async selectMmteStartDateNnnnnBaseType(type: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//span[text()="${type}"]/ancestor::div[contains(@class, "sssss-radio-button")][1]`;
        const radio = CSElementFactory.createByXPath(xpath, `Mmte Start Date Nnnnn Base Type: ${type}`, this.page);
        await radio.clickWithTimeout(5000);
        Tsreporter.pass(`Selected Mmte Start Date Nnnnn Base Type: ${type}`);
    }

    /**
     * Check Mmte Start Date Mirchiary Nnnnn Base checkbox
     */
    public async checkMmteStartDateMirchiaryNnnnnBase(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//span[text()="Mirchiary Nnnnn Base"]/parent::span[@role="checkbox"]`;
        const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Mirchiary Nnnnn Base checkbox', this.page);
        await checkbox.clickWithTimeout(5000);
        Tsreporter.pass('Checked Mmte Start Date Mirchiary Nnnnn Base');
    }

    /**
     * Enter Mmte Start Date Mirchiary Nnnnn Base Days value
     */
    public async enterMmteStartDateMirchiaryNnnnnBaseDays(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//input[@name="addToMirchiaryAdjBaseDaysstartDate"]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Mirchiary Nnnnn Base Days input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte Start Date Mirchiary Nnnnn Base Days: ${value}`);
    }

    /**
     * Select Mmte Start Date Mirchiary Nnnnn Base Type
     */
    public async selectMmteStartDateMirchiaryNnnnnBaseType(type: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//span[contains(@class,"sssss-radio-button__label-text") and text()="${type}"]/ancestor::div[contains(@class, "sssss-radio-button")][1]`;
        const radio = CSElementFactory.createByXPath(xpath, `Mmte Start Date Mirchiary Nnnnn Base Type: ${type}`, this.page);
        await radio.clickWithTimeout(5000);
        Tsreporter.pass(`Selected Mmte Start Date Mirchiary Nnnnn Base Type: ${type}`);
    }

    /**
     * Check Mmte Start Date Add to Hookback checkbox
     */
    public async checkMmteStartDateAddToHookback(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//span[text()="Add to Hookback"]/parent::span[@role="checkbox"]`;
        const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Add to Hookback checkbox', this.page);
        await checkbox.clickWithTimeout(5000);
        Tsreporter.pass('Checked Mmte Start Date Add to Hookback');
    }

    /**
     * Enter Mmte Start Date Hookback Days
     */
    public async enterMmteStartDateHookbackDays(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//input[@name="rustHookbackWhoolDays"]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Hookback Days input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte Start Date Hookback Days: ${value}`);
    }

    /**
     * Configure Mmte Start Date Include Weekends checkbox
     */
    public async configureMmteStartDateIncludeWeekends(includeWeekends: string): Promise<void> {
        if (includeWeekends === 'Y' || includeWeekends === 'Yes') {
            const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//span[@class="sssss-checkbox__label-text" and text()="Weekends"]/parent::span[@aria-label="Weekends"]`;
            const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Include Weekends', this.page);
            await checkbox.clickWithTimeout(5000);
            Tsreporter.pass('Checked Mmte Start Date Include Weekends');
        }
    }

    /**
     * Configure Mmte Start Date Include Borings checkbox
     */
    public async configureMmteStartDateIncludeBorings(includeBorings: string): Promise<void> {
        if (includeBorings === 'Y' || includeBorings === 'Yes') {
            const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//span[@class="sssss-checkbox__label-text" and text()="Borings"]/parent::span[@aria-label="Borings"]`;
            const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Include Borings', this.page);
            await checkbox.clickWithTimeout(5000);
            Tsreporter.pass('Checked Mmte Start Date Include Borings');
        }
    }

    /**
     * Click Mmte Start Date Hookback Associate Cylinders Select button
     */
    public async clickMmteStartDateHookbackCylindersSelect(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte Start Date Determination Whool"]/ancestor::section[1]//button[contains(@id,"addbuttonHookback") or contains(@id,"addbuttonstartDateHookback")]`;
        const button = CSElementFactory.createByXPath(xpath, 'Mmte Start Date Hookback Cylinders Select', this.page);
        await button.clickWithTimeout(5000);
        Tsreporter.pass('Clicked Mmte Start Date Hookback Cylinders Select');
    }

    // ===================================================================
    // FILTER - MMTE END DATE SECTION METHODS
    // ===================================================================

    /**
     * Expand Mmte End Date Determination Whool section in filter panel
     */
    public async expandMmteEndDateSection(): Promise<void> {
        Tsreporter.info('Expanding Mmte End Date Determination Whool section');
        const expandXpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//button[contains(@aria-label,"Expand")]`;
        const expandButton = CSElementFactory.createByXPath(expandXpath, 'Expand Mmte End Date section', this.page);
        const isVisible = await expandButton.isVisibleWithTimeout(3000);
        if (isVisible) {
            await expandButton.clickWithTimeout(5000);
        }
        Tsreporter.pass('Expanded Mmte End Date section');
    }

    /**
     * Enter Mmte End Date Wwwww Vvvvv value
     */
    public async enterMmteEndDateWwwwwVvvvv(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//input[@name="wwwwwVvvvvendDate"]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte End Date Wwwww Vvvvv input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte End Date Wwwww Vvvvv: ${value}`);
    }

    /**
     * Enter Mmte End Date Base Day value
     */
    public async enterMmteEndDateBaseDay(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//label[text()="Base Day"]/parent::div/input[1]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte End Date Base Day input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte End Date Base Day: ${value}`);
    }

    /**
     * Click Mmte End Date Associate Cylinders Select button
     */
    public async clickMmteEndDateCylindersSelect(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//button[contains(@id,"addbutton")]`;
        const button = CSElementFactory.createByXPath(xpath, 'Mmte End Date Cylinders Select', this.page);
        await button.clickWithTimeout(5000);
        Tsreporter.pass('Clicked Mmte End Date Associate Cylinders Select');
    }

    /**
     * Check Mmte End Date Nnnnn Base checkbox
     */
    public async checkMmteEndDateNnnnnBase(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//span[text()="Nnnnn Base"]/parent::span[@role="checkbox"]`;
        const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte End Date Nnnnn Base checkbox', this.page);
        await checkbox.clickWithTimeout(5000);
        Tsreporter.pass('Checked Mmte End Date Nnnnn Base');
    }

    /**
     * Enter Mmte End Date Nnnnn Base Days value
     */
    public async enterMmteEndDateNnnnnBaseDays(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//input[@name="addToBaseDaysendDate"]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte End Date Nnnnn Base Days input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte End Date Nnnnn Base Days: ${value}`);
    }

    /**
     * Select Mmte End Date Nnnnn Base Type
     */
    public async selectMmteEndDateNnnnnBaseType(type: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//span[text()="${type}"]/ancestor::div[contains(@class, "sssss-radio-button")][1]`;
        const radio = CSElementFactory.createByXPath(xpath, `Mmte End Date Nnnnn Base Type: ${type}`, this.page);
        await radio.clickWithTimeout(5000);
        Tsreporter.pass(`Selected Mmte End Date Nnnnn Base Type: ${type}`);
    }

    /**
     * Check Mmte End Date Mirchiary Nnnnn Base checkbox
     */
    public async checkMmteEndDateMirchiaryNnnnnBase(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//span[text()="Mirchiary Nnnnn Base"]/parent::span[@role="checkbox"]`;
        const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte End Date Mirchiary Nnnnn Base checkbox', this.page);
        await checkbox.clickWithTimeout(5000);
        Tsreporter.pass('Checked Mmte End Date Mirchiary Nnnnn Base');
    }

    /**
     * Enter Mmte End Date Mirchiary Nnnnn Base Days value
     */
    public async enterMmteEndDateMirchiaryNnnnnBaseDays(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//input[@name="addToMirchiaryAdjBaseDaysendDate"]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte End Date Mirchiary Nnnnn Base Days input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte End Date Mirchiary Nnnnn Base Days: ${value}`);
    }

    /**
     * Select Mmte End Date Mirchiary Nnnnn Base Type
     */
    public async selectMmteEndDateMirchiaryNnnnnBaseType(type: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//span[contains(@class,"sssss-radio-button__label-text") and text()="${type}"]/ancestor::div[contains(@class, "sssss-radio-button")][1]`;
        const radio = CSElementFactory.createByXPath(xpath, `Mmte End Date Mirchiary Nnnnn Base Type: ${type}`, this.page);
        await radio.clickWithTimeout(5000);
        Tsreporter.pass(`Selected Mmte End Date Mirchiary Nnnnn Base Type: ${type}`);
    }

    /**
     * Check Mmte End Date Add to Hookback checkbox
     */
    public async checkMmteEndDateAddToHookback(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//span[text()="Add to Hookback"]/parent::span[@role="checkbox"]`;
        const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte End Date Add to Hookback checkbox', this.page);
        await checkbox.clickWithTimeout(5000);
        Tsreporter.pass('Checked Mmte End Date Add to Hookback');
    }

    /**
     * Enter Mmte End Date Hookback Days
     */
    public async enterMmteEndDateHookbackDays(value: string): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//input[@name="mirchiHookbackWhoolDays"]`;
        const input = CSElementFactory.createByXPath(xpath, 'Mmte End Date Hookback Days input', this.page);
        await input.fillWithTimeout(value, 5000);
        Tsreporter.pass(`Entered Mmte End Date Hookback Days: ${value}`);
    }

    /**
     * Configure Mmte End Date Include Weekends checkbox
     */
    public async configureMmteEndDateIncludeWeekends(includeWeekends: string): Promise<void> {
        if (includeWeekends === 'Y' || includeWeekends === 'Yes') {
            const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//span[@class="sssss-checkbox__label-text" and text()="Weekends"]/parent::span[@aria-label="Weekends"]`;
            const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte End Date Include Weekends', this.page);
            await checkbox.clickWithTimeout(5000);
            Tsreporter.pass('Checked Mmte End Date Include Weekends');
        }
    }

    /**
     * Configure Mmte End Date Include Borings checkbox
     */
    public async configureMmteEndDateIncludeBorings(includeBorings: string): Promise<void> {
        if (includeBorings === 'Y' || includeBorings === 'Yes') {
            const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//span[@class="sssss-checkbox__label-text" and text()="Borings"]/parent::span[@aria-label="Borings"]`;
            const checkbox = CSElementFactory.createByXPath(xpath, 'Mmte End Date Include Borings', this.page);
            await checkbox.clickWithTimeout(5000);
            Tsreporter.pass('Checked Mmte End Date Include Borings');
        }
    }

    /**
     * Click Mmte End Date Hookback Associate Cylinders Select button
     */
    public async clickMmteEndDateHookbackCylindersSelect(): Promise<void> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="Mmte End Date Determination Whool"]/ancestor::section[1]//button[contains(@id,"addbuttonHookback") or contains(@id,"addbuttonendDateHookback")]`;
        const button = CSElementFactory.createByXPath(xpath, 'Mmte End Date Hookback Cylinders Select', this.page);
        await button.clickWithTimeout(5000);
        Tsreporter.pass('Clicked Mmte End Date Hookback Cylinders Select');
    }

    // ===================================================================
    // FILTER - OTHER WHOOLS SECTION METHODS
    // ===================================================================

    /**
     * Expand Other Whools section in filter panel
     */
    public async expandOtherWhoolsSection(): Promise<void> {
        Tsreporter.info('Expanding Other Whools section');
        const expandXpath = `//div[@id="incircleFilterCalcDuration"]//h5[contains(text(),"Other Whools")]/ancestor::section[1]//button[contains(@aria-label,"Expand")]`;
        const expandButton = CSElementFactory.createByXPath(expandXpath, 'Expand Other Whools section', this.page);
        const isVisible = await expandButton.isVisibleWithTimeout(3000);
        if (isVisible) {
            await expandButton.clickWithTimeout(5000);
        }
        Tsreporter.pass('Expanded Other Whools section');
    }

    /**
     * Select Rounding Logic from dropdown
     */
    public async selectRoundingLogic(option: string): Promise<void> {
        Tsreporter.info(`Selecting Rounding Logic: ${option}`);
        const dropdownXpath = `//div[@id="incircleFilterCalcDuration"]//h5[contains(text(),"Other Whools")]/ancestor::section[1]//button[@name="roundingType"]`;
        const dropdown = CSElementFactory.createByXPath(dropdownXpath, 'Rounding Logic dropdown', this.page);
        await dropdown.clickWithTimeout(5000);
        const optionXpath = `//div[contains(@class, 'sssss-balloon') and @name='roundingType']//ul[@role='listbox']//li[@role='option']//span[text()='${option}']`;
        const optionElement = CSElementFactory.createByXPath(optionXpath, `Rounding Logic option: ${option}`, this.page);
        await optionElement.clickWithTimeout(5000);
        Tsreporter.pass(`Selected Rounding Logic: ${option}`);
    }

    /**
     * Select Rounding Factor from dropdown
     */
    public async selectRoundingFactor(option: string): Promise<void> {
        Tsreporter.info(`Selecting Rounding Factor: ${option}`);
        const dropdownXpath = `//div[@id="incircleFilterCalcDuration"]//h5[contains(text(),"Other Whools")]/ancestor::section[1]//button[@name="roundingFactor"]`;
        const dropdown = CSElementFactory.createByXPath(dropdownXpath, 'Rounding Factor dropdown', this.page);
        await dropdown.clickWithTimeout(5000);
        const optionXpath = `//div[contains(@class, 'sssss-balloon') and @name='roundingFactor']//ul[@role='listbox']//li[@role='option']//span[text()='${option}']`;
        const optionElement = CSElementFactory.createByXPath(optionXpath, `Rounding Factor option: ${option}`, this.page);
        await optionElement.clickWithTimeout(5000);
        Tsreporter.pass(`Selected Rounding Factor: ${option}`);
    }

    // ===================================================================
    // EXPORT METHODS
    // ===================================================================

    /**
     * Click Export button
     */
    public async clickExportButton(): Promise<void> {
        return this.baseClickExportButton(this.exportButton);
    }

    /**
     * Verify export option is present and enabled
     * @param format - 'CSV' or 'XLSX'
     */
    public async verifyExportOptionEnabled(format: string): Promise<boolean> {
        return this.baseIsExportOptionEnabled(format);
    }

    /**
     * Click export format option (CSV or XLSX)
     * @param format - 'CSV' or 'XLSX'
     */
    public async clickExportFormat(format: string): Promise<void> {
        return this.baseClickExportFormat(format);
    }

    /**
     * Wait for export to complete (exporting label disappears)
     */
    public async waitForExportComplete(): Promise<void> {
        return this.baseWaitForExportComplete();
    }

    // ===================================================================
    // FILTER VERIFICATION METHODS (Checkbox/Input/Radio state checks)
    // ===================================================================

    /**
     * Check if a role="checkbox" element in the filter panel is checked
     * @param sectionTitle - e.g., "Mmte Start Date Determination Whool"
     * @param checkboxLabel - e.g., "Nnnnn Base"
     */
    public async isFilterCheckboxChecked(sectionTitle: string, checkboxLabel: string): Promise<boolean> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="${sectionTitle}"]/ancestor::section[1]//span[text()="${checkboxLabel}"]/parent::span[@role="checkbox"]`;
        const element = CSElementFactory.createByXPath(xpath, `${checkboxLabel} checkbox`, this.page);
        try {
            const ariaChecked = await element.getAttributeWithTimeout('aria-checked', 5000);
            return ariaChecked === 'true';
        } catch {
            return false;
        }
    }

    /**
     * Check if a role="checkbox" element in the filter panel is visible
     */
    public async isFilterCheckboxVisible(sectionTitle: string, checkboxLabel: string): Promise<boolean> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="${sectionTitle}"]/ancestor::section[1]//span[text()="${checkboxLabel}"]/parent::span[@role="checkbox"]`;
        const element = CSElementFactory.createByXPath(xpath, `${checkboxLabel} checkbox`, this.page);
        return await element.isVisibleWithTimeout(5000);
    }

    /**
     * Check if a named input in the filter panel is enabled
     * @param sectionTitle - e.g., "Mmte Start Date Determination Whool"
     * @param inputName - e.g., "addToBaseDaysstartDate"
     */
    public async isFilterInputEnabled(sectionTitle: string, inputName: string): Promise<boolean> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="${sectionTitle}"]/ancestor::section[1]//input[@name="${inputName}"]`;
        const element = CSElementFactory.createByXPath(xpath, `${inputName} input`, this.page);
        try {
            const disabled = await element.getAttributeWithTimeout('disabled', 3000);
            return disabled === null;
        } catch {
            return false;
        }
    }

    /**
     * Check if a radio button in the filter panel is enabled
     * @param sectionTitle - section header text
     * @param radioLabel - radio button label text (e.g., "Kindness Days", "Cylinder Days")
     */
    public async isFilterRadioEnabled(sectionTitle: string, radioLabel: string): Promise<boolean> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="${sectionTitle}"]/ancestor::section[1]//span[text()="${radioLabel}"]/ancestor::div[contains(@class, "sssss-radio-button")][1]`;
        const element = CSElementFactory.createByXPath(xpath, `${radioLabel} radio`, this.page);
        try {
            const ariaDisabled = await element.getAttributeWithTimeout('aria-disabled', 3000);
            return ariaDisabled !== 'true';
        } catch {
            return false;
        }
    }

    /**
     * Check if a label checkbox (Weekends/Borings) in the filter panel is enabled
     * @param sectionTitle - section header text
     * @param checkboxLabel - label text (e.g., "Weekends", "Borings")
     */
    public async isFilterLabelCheckboxEnabled(sectionTitle: string, checkboxLabel: string): Promise<boolean> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="${sectionTitle}"]/ancestor::section[1]//span[@class="sssss-checkbox__label-text" and text()="${checkboxLabel}"]/parent::span[@aria-label="${checkboxLabel}"]`;
        const element = CSElementFactory.createByXPath(xpath, `${checkboxLabel} checkbox`, this.page);
        try {
            const ariaDisabled = await element.getAttributeWithTimeout('aria-disabled', 3000);
            return ariaDisabled !== 'true';
        } catch {
            return false;
        }
    }

    /**
     * Verify filter cylinder button shows "Edit" after selection
     * @param sectionTitle - section header text
     * @param buttonIdContains - part of the button id (e.g., "addbutton", "addbuttonHookback")
     */
    public async isFilterCylindersShowingEdit(sectionTitle: string, buttonIdContains: string): Promise<boolean> {
        const xpath = `//div[@id="incircleFilterCalcDuration"]//h5[text()="${sectionTitle}"]/ancestor::section[1]//button[contains(@id,"${buttonIdContains}")]//span[text()="Edit"]`;
        const element = CSElementFactory.createByXPath(xpath, 'Cylinder Edit button', this.page);
        return await element.isVisibleWithTimeout(5000);
    }

    // ===================================================================
    // SCATTERED MMTE LINK CLICK
    // ===================================================================

    /**
     * Click on scattered mmte name link in table row
     * @param rowNum - 1-based row number
     * @param scatteredMmteName - The scattered mmte name to click
     */
    public async clickScatteredMmteNameLink(rowNum: number, scatteredMmteName: string): Promise<void> {
        return this.baseClickScatteredMmteNameLink(rowNum, scatteredMmteName);
    }

    // ===================================================================
    // NO DATA VERIFICATION
    // ===================================================================

    /**
     * Check if "No data available" message is displayed
     */
    public async isNoDataAvailable(): Promise<boolean> {
        return this.baseIsNoDataAvailable(this.noDataAvailableMessage);
    }
}



------------------------------------------------------------------------------


import { CSBasePage } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { TswebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { Tsreporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * Column mapping interface for mmte table data extraction.
 * Used by both Sport Mmte and Ttcalc Duration tables.
 */
export interface MmteTableColumnMapping {
    colNum: number;
    fieldName: string;
    childRowName: string;
}

/**
 * Abstract base class for TTTF Mmte Table pages (Sport Mmte, Ttcalc Duration).
 * Provides shared table interaction logic: cell value extraction, child row expansion,
 * row data capture, header verification, pagination, export, and loader handling.
 *
 * Each subclass provides its own configuration via abstract properties and keeps
 * its existing public method names/signatures as thin wrappers around these base methods.
 */
export abstract class TTTFMmteTableBase extends CSBasePage {

    // ===================================================================
    // ABSTRACT CONFIGURATION â€” each subclass provides its own values
    // ===================================================================

    /** Column numbers that contain cylinder values (multiple button labels joined) */
    protected abstract get cylinderColumns(): number[];

    /** Column number for Scattered Mmte Name (uses button label span) */
    protected abstract get refMmteNameColumn(): number;

    /** Column mapping array defining all table columns */
    protected abstract get tableColumnMapping(): MmteTableColumnMapping[];

    /** Expected column header names for verification */
    protected abstract get tableColumnHeaders(): string[];

    /** Whether to filter out child rows in cell XPath (SR: true, CP: false) */
    protected abstract get filterChildRowsInXPath(): boolean;

    /** Whether headers use sortable-indicator-header span (CP: true, SR: false) */
    protected abstract get usesSortableHeaderSpan(): boolean;

    /** Separator for joining multiple cylinder values (SR: ',', CP: ', ') */
    protected abstract get cylinderJoinSeparator(): string;

    /** Filter panel container ID (SR: 'incircleFilterSportMmte', CP: 'incircleFilterCalcDuration') */
    protected abstract get filterContainerId(): string;

    // ===================================================================
    // XPATH HELPERS
    // ===================================================================

    /** Base XPath for the active tab's table */
    private get activeTableBase(): string {
        return `//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, "sssss-table")]`;
    }

    /** Build row XPath with optional child row filtering */
    private getRowSelector(rowNum: number): string {
        if (this.filterChildRowsInXPath) {
            return `${this.activeTableBase}//tbody/tr[not(contains(@class, 'sssss-table__childrow'))][${rowNum}]`;
        }
        return `${this.activeTableBase}//tbody/tr[${rowNum}]`;
    }

    // ===================================================================
    // SHARED: LOADER / PAGE STATE
    // ===================================================================

    protected async baseWaitForLoaderToDisappear(loadingIndicator: TswebElement): Promise<void> {
        Tsreporter.info('Waiting for loader to disappear');
        try {
            const isVisible = await loadingIndicator.isVisibleWithTimeout(2000);
            if (isVisible) {
                Tsreporter.debug('Loader visible, waiting for it to disappear');
                await loadingIndicator.waitForDetached(30000);
                Tsreporter.debug('Loader disappeared');
            }
        } catch {
            // Loader didn't appear â€” that's fine
        }
    }

    // ===================================================================
    // SHARED: PAGINATION
    // ===================================================================

    protected async baseGetTotalItemsCount(paginatorElement: TswebElement): Promise<number> {
        try {
            await paginatorElement.waitForVisible(10000);
            const text = await paginatorElement.textContentWithTimeout(5000);
            const match = text?.match(/of\s+(\d+)\s+items?/i);
            return match ? parseInt(match[1], 10) : 0;
        } catch {
            return 0;
        }
    }

    // ===================================================================
    // SHARED: NO DATA CHECK
    // ===================================================================

    protected async baseIsNoDataAvailable(noDataElement: TswebElement): Promise<boolean> {
        try {
            return await noDataElement.isVisibleWithTimeout(3000);
        } catch {
            return false;
        }
    }

    // ===================================================================
    // SHARED: EXPORT
    // ===================================================================

    protected async baseClickExportButton(exportBtn: TswebElement): Promise<void> {
        Tsreporter.info('Clicking Export button');
        await exportBtn.waitForVisible(10000);
        await exportBtn.clickWithTimeout(10000);
        Tsreporter.pass('Clicked Export button');
    }

    protected async baseWaitForExportComplete(): Promise<void> {
        Tsreporter.info('Waiting for export to complete');
        try {
            const exportingElement = CSElementFactory.createByXPath(
                '//*[contains(text(),"Exporting")]',
                'Exporting indicator',
                this.page
            );
            const isExporting = await exportingElement.isVisibleWithTimeout(2000);
            if (isExporting) {
                await exportingElement.waitForDetached(15000);
            }
        } catch {
            // Exporting text may not appear for small datasets
        }
        await this.wait(2000);
        Tsreporter.pass('Export completed');
    }

    // ===================================================================
    // SHARED: CELL VALUE EXTRACTION
    // ===================================================================

    protected async baseGetTableCellValue(rowNum: number, colNum: number): Promise<string> {
        try {
            if (colNum === this.refMmteNameColumn) {
                // Scattered Mmte Name â€” uses button label span
                const xpath = `${this.getRowSelector(rowNum)}/td[${colNum}]//span[@class="sssss-button__label"]`;
                const element = CSElementFactory.createByXPath(xpath, `table row ${rowNum} col ${colNum} link`, this.page);
                try {
                    const isVisible = await element.isVisibleWithTimeout(3000);
                    if (isVisible) {
                        const text = await element.textContentWithTimeout(5000);
                        return text ?? '';
                    }
                } catch {
                    return 'Element Not Found';
                }
            } else if (this.cylinderColumns.includes(colNum)) {
                // Cylinder columns â€” may have multiple button label spans
                const xpath = `${this.getRowSelector(rowNum)}/td[${colNum}]//span[@class="sssss-button__label"]`;
                const elements = await this.page.locator(xpath).all();

                if (elements.length === 0) {
                    // No spans found â€” try plain text from td
                    const plainXpath = `${this.getRowSelector(rowNum)}/td[${colNum}]`;
                    const plainElement = CSElementFactory.createByXPath(plainXpath, `table row ${rowNum} col ${colNum}`, this.page);
                    return (await plainElement.textContentWithTimeout(5000)) ?? '';
                }

                if (elements.length === 1) {
                    const singleXpath = `(${xpath})[1]`;
                    const singleElement = CSElementFactory.createByXPath(singleXpath, `Cylinder value row ${rowNum} col ${colNum}`, this.page);
                    const text = await singleElement.textContentWithTimeout(5000);
                    return text?.trim() ?? '';
                }

                // Multiple cylinder values
                const values: string[] = [];
                for (const el of elements) {
                    const text = await el.textContent();
                    if (text?.trim()) values.push(text.trim());
                }
                return values.join(this.cylinderJoinSeparator);
            } else {
                // Standard cell â€” plain td text
                const xpath = `${this.getRowSelector(rowNum)}/td[${colNum}]`;
                const element = CSElementFactory.createByXPath(xpath, `table row ${rowNum} col ${colNum}`, this.page);
                try {
                    const isVisible = await element.isVisibleWithTimeout(3000);
                    if (isVisible) {
                        const text = await element.textContentWithTimeout(5000);
                        return text?.trim() ?? '';
                    }
                } catch {
                    return 'Element Not Found';
                }
            }
        } catch {
            return 'Element Not Found';
        }
        return 'Element Not Found';
    }

    // ===================================================================
    // SHARED: CHILD ROW CELL VALUE
    // ===================================================================

    protected async baseGetCellFromChildRow(parentRowNum: number, columnName: string): Promise<string> {
        try {
            await this.baseEnsureRowExpanded(parentRowNum);

            const expandedRowBase = `${this.activeTableBase}//tbody/tr[not(contains(@class, 'sssss-table__childrow')) and contains(@class, 'expanded')][${parentRowNum}]`;
            const xpath = `${expandedRowBase}/following::tr[@class="sssss-table__childrow"][1]//span[text()='${columnName}']/ancestor::div[contains(@class,"sssss-table__expanded-item")][1]//span[@class="sssss-table__expanded-item-value"]`;

            const element = CSElementFactory.createByXPath(xpath, `Child row ${parentRowNum} col ${columnName}`, this.page);
            const count = await element.count();
            if (count > 0) {
                const text = await element.textContentWithTimeout(5000);
                return text ?? '';
            }
        } catch {
            return 'Element Not Found';
        }
        return 'Element Not Found';
    }

    // ===================================================================
    // SHARED: ROW EXPANSION
    // ===================================================================

    protected async baseEnsureRowExpanded(rowNum: number): Promise<void> {
        try {
            const rowBase = this.getRowSelector(rowNum);

            // Check if already expanded (Collapse button visible)
            const collapseXpath = `${rowBase}/td[1]//button[contains(@aria-label, 'Collapse')]`;
            const collapseBtn = CSElementFactory.createByXPath(collapseXpath, `Collapse button row ${rowNum}`, this.page);
            const isExpanded = await collapseBtn.isVisibleWithTimeout(2000);

            if (!isExpanded) {
                const expandXpath = `${rowBase}/td[1]//button[contains(@aria-label, 'Expand')]`;
                const expandBtn = CSElementFactory.createByXPath(expandXpath, `Expand button row ${rowNum}`, this.page);
                const expandVisible = await expandBtn.isVisibleWithTimeout(2000);
                if (expandVisible) {
                    await expandBtn.clickWithTimeout(5000);
                    await this.page.waitForLoadState('domcontentloaded', { timeout: 15000 }).catch(() => {});
                    Tsreporter.debug(`Expanded row ${rowNum}`);
                }
            }
        } catch (error) {
            Tsreporter.warn(`Could not expand row ${rowNum}: ${error}`);
        }
    }

    // ===================================================================
    // SHARED: ROW DATA EXTRACTION
    // ===================================================================

    protected async baseGetTableRowData(rowNum: number): Promise<Record<string, string>> {
        Tsreporter.info(`Capturing table row ${rowNum} data`);
        const rowData: Record<string, string> = {};

        for (const col of this.tableColumnMapping) {
            let value = await this.baseGetTableCellValue(rowNum, col.colNum);

            if (value === 'Element Not Found') {
                Tsreporter.debug(`Column ${col.colNum} (${col.fieldName}) not found in main row, trying child row`);
                value = await this.baseGetCellFromChildRow(rowNum, col.childRowName);
            }

            if (value === 'Element Not Found') {
                const errorMsg = `Could not find value for column '${col.childRowName}' (column ${col.colNum}) in row ${rowNum} - element not found in parent row or child row`;
                Tsreporter.fail(errorMsg);
                throw new Error(errorMsg);
            }

            rowData[col.fieldName] = value;
            Tsreporter.debug(`Row ${rowNum}, ${col.fieldName}: '${value}'`);
        }

        Tsreporter.pass(`Captured all ${this.tableColumnMapping.length} column values for row ${rowNum}`);
        return rowData;
    }

    // ===================================================================
    // SHARED: ROW COUNT
    // ===================================================================

    protected async baseGetTableRowCount(): Promise<number> {
        try {
            const xpath = `${this.activeTableBase}//tbody/tr[not(contains(@class, 'sssss-table__childrow'))]`;
            const rows = await this.page.locator(xpath).all();
            return rows.length;
        } catch {
            return 0;
        }
    }

    // ===================================================================
    // SHARED: GET ALL TABLE DATA
    // ===================================================================

    protected async baseGetAllTableData(): Promise<Record<string, string>[]> {
        const rowCount = await this.baseGetTableRowCount();
        Tsreporter.info(`Capturing all ${rowCount} table rows data`);
        const allData: Record<string, string>[] = [];

        for (let i = 1; i <= rowCount; i++) {
            try {
                const rowData = await this.baseGetTableRowData(i);
                allData.push(rowData);
            } catch (error) {
                Tsreporter.warn(`Failed to capture row ${i}: ${error}`);
            }
        }

        return allData;
    }

    // ===================================================================
    // SHARED: TABLE HEADERS
    // ===================================================================

    protected async baseGetTableHeader(headerName: string): Promise<TswebElement> {
        const xpath = this.usesSortableHeaderSpan
            ? `${this.activeTableBase}//thead/tr[1]/th//span[contains(@class, "sssss-table__sortable-indicator-header") and text()='${headerName}']`
            : `${this.activeTableBase}//thead/tr[1]/th[text()='${headerName}']`;
        return CSElementFactory.createByXPath(xpath, `Table header: ${headerName}`, this.page);
    }

    protected async baseGetTableHeaderFromChildRow(rowNumber: number, headerName: string): Promise<TswebElement> {
        await this.baseEnsureRowExpanded(rowNumber);

        const expandedRowBase = `${this.activeTableBase}//tbody/tr[not(contains(@class, 'sssss-table__childrow')) and contains(@class, 'expanded')][${rowNumber}]`;
        const xpath = `${expandedRowBase}/following::tr[@class="sssss-table__childrow"][1]//span[text()='${headerName}']`;
        return CSElementFactory.createByXPath(xpath, `Child row header: ${headerName}`, this.page);
    }

    protected async baseVerifyAllColumnHeaders(throwOnMissing: boolean = true): Promise<void> {
        Tsreporter.info('Verifying all column headers');
        const missingHeaders: string[] = [];

        for (const headerName of this.tableColumnHeaders) {
            let found = false;

            // Try main header row rust
            try {
                const headerElement = await this.baseGetTableHeader(headerName);
                const isVisible = await headerElement.isVisibleWithTimeout(2000);
                if (isVisible) {
                    Tsreporter.debug(`Header found: ${headerName}`);
                    found = true;
                }
            } catch {
                // Not found in main header
            }

            // Disputed: try child row header
            if (!found) {
                try {
                    const childHeader = await this.baseGetTableHeaderFromChildRow(1, headerName);
                    const count = await childHeader.count();
                    if (count > 0) {
                        Tsreporter.debug(`Header found in child row: ${headerName}`);
                        found = true;
                    }
                } catch {
                    // Not found in child row either
                }
            }

            if (!found) {
                missingHeaders.push(headerName);
                Tsreporter.warn(`Header NOT found: ${headerName}`);
            }
        }

        if (missingHeaders.length > 0 && throwOnMissing) {
            throw new Error(`Missing column headers: ${missingHeaders.join(', ')}`);
        }

        Tsreporter.pass(`Verified ${this.tableColumnHeaders.length} column headers`);
    }

    // ===================================================================
    // SHARED: SCATTERED MMTE NAME LINK
    // ===================================================================

    protected async baseClickScatteredMmteNameLink(rowNum: number, scatteredMmteName: string): Promise<void> {
        Tsreporter.info(`Clicking Scattered Mmte Name link: ${scatteredMmteName}`);
        const xpath = `${this.activeTableBase}//tbody/tr[${rowNum}]/td[2]//span[@class='sssss-button__label' and text()='${scatteredMmteName}']/parent::a[1]`;
        const link = CSElementFactory.createByXPath(xpath, `Scattered Mmte Name link: ${scatteredMmteName}`, this.page);
        await link.waitForVisible(10000);
        await link.clickWithTimeout(10000);
        await this.waitForPageLoad();
        Tsreporter.pass(`Clicked Scattered Mmte Name link: ${scatteredMmteName}`);
    }

    // ===================================================================
    // SHARED: EXPORT FORMAT METHODS
    // ===================================================================

    protected async baseClickExportFormat(format: string): Promise<void> {
        Tsreporter.info(`Clicking Export ${format} option`);
        const xpath = `//span[@class="sssss-button__label" and text()="Export"]/parent::button[@aria-label="Export"]/parent::div[1]//div[@class="sssss-balloon__content"]//ul[@aria-label="Export"]//span[text()='${format}']/ancestor::button[1]`;
        const element = CSElementFactory.createByXPath(xpath, `Export ${format} button`, this.page);
        await element.waitForVisible(10000);
        await element.clickWithTimeout(10000);
        Tsreporter.pass(`Clicked Export ${format} option`);
    }

    protected async baseIsExportOptionEnabled(format: string): Promise<boolean> {
        const xpath = `//span[@class="sssss-button__label" and text()="Export"]/parent::button[@aria-label="Export"]/parent::div[1]//div[@class="sssss-balloon__content"]//ul[@aria-label="Export"]//span[text()='${format}']/ancestor::li[@aria-disabled='false'][1]`;
        const element = CSElementFactory.createByXPath(xpath, `Export ${format} option enabled`, this.page);
        return await element.isVisibleWithTimeout(5000);
    }

    // ===================================================================
    // SHARED: FILTER METHODS
    // ===================================================================

    protected async baseSelectCumulativeMmte(cumulativeMmteName: string, dropdownElement?: TswebElement): Promise<void> {
        Tsreporter.info(`Selecting Cumulative Mmte: ${cumulativeMmteName}`);

        if (dropdownElement) {
            await dropdownElement.clickWithTimeout(10000);
            const listXpath = `//div[contains(@class, "sssss-balloon") and @name="cumulativeMmte"]//ul[@role="listbox"]`;
            const listElement = CSElementFactory.createByXPath(listXpath, 'Cumulative Mmte listbox', this.page);
            await listElement.waitForVisible(10000);
        }

        const optionXpath = `//div[contains(@class, "sssss-balloon") and @name="cumulativeMmte"]//ul[@role="listbox"]//li[@role="option"]//span[text()='${cumulativeMmteName}']/parent::span`;
        const optionElement = CSElementFactory.createByXPath(optionXpath, `Cumulative Mmte option: ${cumulativeMmteName}`, this.page);
        await optionElement.waitForVisible(10000);
        await optionElement.clickWithTimeout(10000);
        Tsreporter.pass(`Selected Cumulative Mmte: ${cumulativeMmteName}`);
    }

    protected async baseVerifyCumulativeMmteSelected(cumulativeMmteName: string): Promise<boolean> {
        const xpath = `//div[@id="${this.filterContainerId}"]//button[@name="cumulativeMmte"]//span[@class="sssss-button__label" and text()='${cumulativeMmteName}']`;
        const element = CSElementFactory.createByXPath(xpath, `Selected Cumulative Mmte: ${cumulativeMmteName}`, this.page);
        return await element.isVisibleWithTimeout(5000);
    }

    protected async baseClickApplyFilters(loadingIndicator: TswebElement): Promise<void> {
        Tsreporter.info('Clicking Apply Filters');
        const xpath = `//div[@id="${this.filterContainerId}"]//span[@class="sssss-button__label" and text()="Apply"]/parent::button[1]`;
        const button = CSElementFactory.createByXPath(xpath, 'Apply Filters button', this.page);
        await button.waitForVisible(10000);
        await button.clickWithTimeout(10000);
        await this.waitForPageLoad();
        await this.baseWaitForLoaderToDisappear(loadingIndicator);
        Tsreporter.pass('Applied filters');
    }

    protected async baseClickResetFilters(loadingIndicator: TswebElement): Promise<void> {
        Tsreporter.info('Clicking Reset Filters');
        const xpath = `//div[@id="${this.filterContainerId}"]//span[@class="sssss-button__label" and text()="Reset Filters"]/parent::button[1]`;
        const button = CSElementFactory.createByXPath(xpath, 'Reset Filters button', this.page);
        await button.waitForVisible(10000);
        await button.clickWithTimeout(10000);
        await this.waitForPageLoad();
        await this.baseWaitForLoaderToDisappear(loadingIndicator);
        Tsreporter.pass('Reset filters');
    }
}


--------------------------------------------------------------------------------------------------------

export class TTTFScatteredMmtesPage extends TTTFMmteTableBase {

    // ===================================================================
    // ABSTRACT CONFIG IMPLEMENTATIONS (from TTTFMmteTableBase)
    // ===================================================================

    protected get cylinderColumns(): number[] { return [6]; }
    protected get refMmteNameColumn(): number { return 2; }
    protected get tableColumnMapping(): MmteTableColumnMapping[] { return TTTFScatteredMmtesPage.SPORT_MMTE_COLUMNS; }
    protected get tableColumnHeaders(): string[] { return TTTFScatteredMmtesPage.SPORT_MMTE_HEADERS; }
    protected get filterChildRowsInXPath(): boolean { return true; }
    protected get usesSortableHeaderSpan(): boolean { return false; }
    protected get cylinderJoinSeparator(): string { return ','; }

    // ===================================================================
    // SPORT MMTE TABLE COLUMN DEFINITIONS
    // ===================================================================

    private static readonly SPORT_MMTE_COLUMNS: MmteTableColumnMapping[] = [
        { colNum: 2, fieldName: 'scatteredMmteName', childRowName: 'Scattered Mmte Name' },
        { colNum: 3, fieldName: 'cumulativeMmteName', childRowName: 'Cumulative Mmte Name' },
        { colNum: 4, fieldName: 'wwwwwVvvvv', childRowName: 'Wwwww Vvvvv' },
        { colNum: 5, fieldName: 'baseDay', childRowName: 'Base Day' },
        { colNum: 6, fieldName: 'associatedCylinders', childRowName: 'Associated Cylinders' },
        { colNum: 7, fieldName: 'nnnnnBase', childRowName: 'Nnnnn Base' },
        { colNum: 8, fieldName: 'mirchiaryNnnnnBaseDay', childRowName: 'Mirchiary Nnnnn Base Day' },
        { colNum: 9, fieldName: 'hookbackDays', childRowName: 'Hookback Days' },
        { colNum: 10, fieldName: 'hookbackCylinders', childRowName: 'Hookback Cylinders' },
        { colNum: 11, fieldName: 'wwwwwVvvvvSR', childRowName: 'Wwwww Vvvvv (SR)' },
        { colNum: 12, fieldName: 'baseDaySR', childRowName: 'Base Day (SR)' },
        { colNum: 13, fieldName: 'associatedCylindersSR', childRowName: 'Associated Cylinders (SR)' },
        { colNum: 14, fieldName: 'nnnnnBaseSR', childRowName: 'Nnnnn Base (SR)' },
        { colNum: 15, fieldName: 'mirchiaryNnnnnBaseDaySR', childRowName: 'Mirchiary Nnnnn Base Day (SR)' },
        { colNum: 16, fieldName: 'hookbackDaysSR', childRowName: 'Hookback Days (SR)' },
        { colNum: 17, fieldName: 'hookbackCylindersSR', childRowName: 'Hookback Cylinders (SR)' },
        { colNum: 18, fieldName: 'roundingType', childRowName: 'Rounding Type' },
        { colNum: 19, fieldName: 'roundingFactor', childRowName: 'Rounding Factor' },
        { colNum: 20, fieldName: 'whoolPriority', childRowName: 'Whool Priority' },
        { colNum: 21, fieldName: 'associatedZealPremisis', childRowName: 'Associated Zeal/Premisis' }
    ];

    private static readonly SPORT_MMTE_HEADERS: string[] = [
        'Scattered Mmte Name', 'Cumulative Mmte Name', 'Wwwww Vvvvv', 'Base Day',
        'Associated Cylinders', 'Nnnnn Base', 'Mirchiary Nnnnn Base Day',
        'Hookback Days', 'Hookback Cylinders', 'Wwwww Vvvvv (SR)', 'Base Day (SR)',
        'Associated Cylinders (SR)', 'Nnnnn Base (SR)', 'Mirchiary Nnnnn Base Day (SR)',
        'Hookback Days (SR)', 'Hookback Cylinders (SR)', 'Rounding Type',
        'Rounding Factor', 'Whool Priority', 'Associated Zeal/Premisis'
    ];




/**
     * Wait for loader to disappear
     */
    public async waitForLoaderToDisappear(): Promise<void> {
        return this.baseWaitForLoaderToDisappear(this.loadingIndicator);
    }




    /**
     * Get total items count from pagination
     * Requirement Circles 95-98
     * @returns Total items count as number
     */
    public async getTotalItemsCount(): Promise<number> {
        return this.baseGetTotalItemsCount(this.paginatorTotalItems);
    }




    /**
     * Check if no data available message is present
     */
    public async isNoDataAvailable(): Promise<boolean> {
        return this.baseIsNoDataAvailable(this.noDataAvailableMessage);
    }



    /**
     * Get table cell value by column number and row number
     * Source: Requirement doc - getSportMmteTableCellValueByColNumAndRowNum
     */
    public async getSportMmteTableCellValue(rowNum: number, colNum: number): Promise<string> {
        return this.baseGetTableCellValue(rowNum, colNum);
    }

    /**
     * Get cell value from expanded child row by column name and parent row number
     * Source: Requirement doc - getSportMmteTableCellValueFromChildRowByColNameAndParentRowNum
     */
    public async getSportMmteCellFromChildRow(parentRowNum: number, columnName: string): Promise<string> {
        return this.baseGetCellFromChildRow(parentRowNum, columnName);
    }

    /**
     * Get header element by name
     * Source: Requirement doc - getSportMmteHeader
     */
    public async getSportMmteHeader(headerName: string): Promise<TswebElement> {
        return this.baseGetTableHeader(headerName);
    }

    /**
     * Get header element from expanded child row by row number and header name
     * Source: RR02 Requirement doc circle 34 - getSportMmteHeaderFromChildRow(intRowNumber, headerName)
     * Rust expands the row if not expanded, then returns the header element from the child row
     */
    public async getSportMmteHeaderFromChildRow(rowNumber: number, headerName: string): Promise<TswebElement> {
        return this.baseGetTableHeaderFromChildRow(rowNumber, headerName);
    }




    /**
     * Get Sport Mmte table row data by row number - FIXED per RR02 Requirements (circles 109-189)
     * Returns an object with all 20 column values using correct column numbering
     * Column 1 is expand/collapse toggle, actual data starts at column 2
     *
     * For each field:
     * 1. Rust try getSportMmteTableCellValue(rowNum, colNum)
     * 2. If returns 'Element Not Found', try getSportMmteCellFromChildRow(rowNum, columnName)
     * 3. If still 'Element Not Found', throw error to fail the test
     *
     * Source: Scattered_Mmte_Sport_Mmte_2.txt circles 109-189
     */
    public async getSportMmteTableRowData(rowNum: number): Promise<Record<string, string>> {
        return this.baseGetTableRowData(rowNum);
    }

    // ===================================================================
    // RR03 - EXPAND ALL ROWS AND GET ALL ROWS DATA METHODS
    // Source: Scattered_Mmte_Sport_Mmte_3.txt circles 127-251
    // ===================================================================

    /**
     * Get the total number of main rows (excluding child rows) in Sport Mmte table
     * Source: Scattered_Mmte_Sport_Mmte_3.txt circle 128
     * XPath: //div[@class='sssss-tab__pane-content--active']//table[contains(@class, 'sssss-table')]//tbody//tr
     * Note: Count only main rows, not child rows (which have class 'sssss-table__childrow')
     */
    public async getSportMmteTableRowCount(): Promise<number> {
        return this.baseGetTableRowCount();
    }




    /**
     * Get all visible Sport Mmte table rows data
     * Source: Scattered_Mmte_Sport_Mmte_3.txt circles 139-251
     * Loops through all visible rows and captures 20-column data using getSportMmteTableRowData
     * Returns array of row data objects keyed by scatteredMmteName for comparison
     */
    public async getAllSportMmteTableRowsData(): Promise<Map<string, Record<string, string>>> {
        const allData = await this.baseGetAllTableData();
        const allRowsData = new Map<string, Record<string, string>>();

        for (const rowData of allData) {
            const refMmteName = rowData.scatteredMmteName;
            if (refMmteName) {
                allRowsData.set(refMmteName, rowData);
            } else {
                Tsreporter.warn('Row has no scattered mmte name');
            }
        }

        Tsreporter.pass(`Captured ${allRowsData.size} rows from UI`);
        return allRowsData;
    }

    // ===================================================================
    // EXPORT METHODS
    // ===================================================================

    /**
     * Click Export button
     */
    public async clickExportButton(): Promise<void> {
        return this.baseClickExportButton(this.exportButton);
    }




    /**
     * Wait for export to complete (wait for "Exporting" text to disappear)
     */
    public async waitForExportComplete(): Promise<void> {
        return this.baseWaitForExportComplete();
    }




    // ===================================================================
    // COLUMN HEADER VERIFICATION
    // ===================================================================

    /**
     * Verify all Sport Mmte table column headers
     * Source: Requirement doc - column headers list
     */
    public async verifySportMmteTableHeaders(): Promise<void> {
        return this.baseVerifyAllColumnHeaders(false);
    }










    protected get filterContainerId(): string { return 'incircleFilterSportMmte'; }




    /**
     * Select Cumulative Mmte from dropdown
     */
    public async selectCumulativeMmte(cumulativeMmteName: string): Promise<void> {
        return this.baseSelectCumulativeMmte(cumulativeMmteName);
    }

    /**
     * Verify Cumulative Mmte is selected
     */
    public async verifyCumulativeMmteSelected(cumulativeMmteName: string): Promise<void> {
        Tsreporter.info(`Verifying Cumulative Mmte selected: ${cumulativeMmteName}`);
        const isSelected = await this.baseVerifyCumulativeMmteSelected(cumulativeMmteName);
        if (!isSelected) {
            throw new Error(`Cumulative Mmte '${cumulativeMmteName}' is not selected`);
        }
        Tsreporter.pass(`Cumulative Mmte selected: ${cumulativeMmteName}`);
    }

    /**
     * Click Apply Filters button
     */
    public async clickApplyFilters(): Promise<void> {
        return this.baseClickApplyFilters(this.loadingIndicator);
    }

    /**
     * Click Reset Filters button
     */
    public async clickResetFilters(): Promise<void> {
        return this.baseClickResetFilters(this.loadingIndicator);
    }




    /**
     * Click on Scattered Mmte Name link in table to navigate to details
     */
    public async clickScatteredMmteNameLink(scatteredMmteName: string): Promise<void> {
        return this.baseClickScatteredMmteNameLink(1, scatteredMmteName);
    }




    /**
     * Verify Export options are present (CSV, XLSX)
     */
    public async verifyExportOptionsPresent(): Promise<void> {
        Tsreporter.info('Verifying Export options are present');
        const csvEnabled = await this.baseIsExportOptionEnabled('CSV');
        const xlsxEnabled = await this.baseIsExportOptionEnabled('XLSX');
        if (!csvEnabled || !xlsxEnabled) {
            throw new Error('Export options (CSV, XLSX) are not all present');
        }
        Tsreporter.pass('Export options (CSV, XLSX) are present');
    }

    /**
     * Click CSV export option
     */
    public async clickExportCSV(): Promise<void> {
        return this.baseClickExportFormat('CSV');
    }

    /**
     * Click XLSX export option
     */
    public async clickExportXLSX(): Promise<void> {
        return this.baseClickExportFormat('XLSX');
    }




    /**
     * Verify CSV export option is enabled (aria-disabled='false')
     * XPath: //...//span[text()='CSV']/ancestor::li[@aria-disabled='false'][1]
     */
    public async verifyCSVOptionEnabled(): Promise<void> {
        Tsreporter.info('Verifying CSV export option is enabled');
        const isEnabled = await this.baseIsExportOptionEnabled('CSV');
        if (!isEnabled) {
            throw new Error('CSV export option is not enabled');
        }
        Tsreporter.pass('CSV export option is enabled');
    }

    /**
     * Verify XLSX export option is enabled (aria-disabled='false')
     * XPath: //...//span[text()='XLSX']/ancestor::li[@aria-disabled='false'][1]
     */
    public async verifyXLSXOptionEnabled(): Promise<void> {
        Tsreporter.info('Verifying XLSX export option is enabled');
        const isEnabled = await this.baseIsExportOptionEnabled('XLSX');
        if (!isEnabled) {
            throw new Error('XLSX export option is not enabled');
        }
        Tsreporter.pass('XLSX export option is enabled');
    }
