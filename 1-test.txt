const originalWarn = CSReporter.warn.bind(CSReporter);


// Wrap warn to also add to BDD action tracker
            (CSReporter as any).warn = function(message: string): void {
                originalWarn(message);
                // Skip framework internal messages
                const passesFilter = !message.startsWith('[') &&
                    !message.startsWith('╔') &&
                    !message.startsWith('╚') &&
                    !message.startsWith('║') &&
                    !message.startsWith('▶') &&
                    !message.startsWith('Step ') &&
                    !message.startsWith('Feature:') &&
                    !message.startsWith('  Scenario:') &&
                    !message.startsWith('    ');

                if (passesFilter) {
                    context.addStepAction(`⚠ ${message}`, 'pass');
                }
            };


---------------------------------------------------------------------------

// Check for reporter statement prefixes (✓, ✗, ℹ, ⚠) first


} else if (trimmedAction.startsWith('⚠') || trimmedAction.startsWith('⚠️')) {
                // Warn statement from CSReporter.warn()
                icon = '⚠️';
                actionType = 'warn';
                isReporterStatement = true;


 // Remove reporter statement prefix (✓, ✗, ℹ, ⚠) since icon already shows status
            if (isReporterStatement) {
                displayText = displayText.replace(/^[✓✔✗✘❌ℹℹ️⚠⚠️]\s*/, '');
            }


-------------------------------------------------------

const originalWarn = CSReporter.warn.bind(CSReporter);

// Wrap warn to also add to step tracker
        (CSReporter as any).warn = function(message: string): void {
            originalWarn(message);
            // Add all user-facing warn messages to step tracker
            // Skip framework internal messages (those with special prefixes)
            const passesFilter = !message.startsWith('[') &&
                !message.startsWith('╔') &&
                !message.startsWith('╚') &&
                !message.startsWith('║') &&
                !message.startsWith('▶') &&
                !message.startsWith('Step ');

            if (currentStepTracker && passesFilter) {
                currentStepTracker.reporterAction(`⚠ ${message}`, 'passed');
                CSReporter.debug(`[StepTracker] Added warn action: ${message.substring(0, 50)}... (step: ${currentStepTracker.getCurrentStepName() || 'none'})`);
            } else if (passesFilter) {
                CSReporter.debug(`[StepTracker] No step tracker for warn: ${message.substring(0, 50)}...`);
            }
        };
---------------------------------------------------------------


/**
     * Format date with custom format
     * Supported tokens: YYYY, YY, MMMM, MMM, MM, M, DD, D, HH, H, hh, h, mm, m, ss, s, SSS, A, a
     * - MMMM: Full month name (January, February, etc.)
     * - MMM: Short month name uppercase (JAN, FEB, etc.)
     */
    static format(date: Date, format: string): string {
        const monthNamesShort = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const monthNamesFull = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

        const tokens: Record<string, string> = {
            'YYYY': String(date.getFullYear()),
            'YY': String(date.getFullYear()).slice(-2),
            'MMMM': monthNamesFull[date.getMonth()],
            'MMM': monthNamesShort[date.getMonth()],
            'MM': String(date.getMonth() + 1).padStart(2, '0'),
            'M': String(date.getMonth() + 1),
            'DD': String(date.getDate()).padStart(2, '0'),
            'D': String(date.getDate()),
            'HH': String(date.getHours()).padStart(2, '0'),
            'H': String(date.getHours()),
            'hh': String(date.getHours() % 12 || 12).padStart(2, '0'),
            'h': String(date.getHours() % 12 || 12),
            'mm': String(date.getMinutes()).padStart(2, '0'),
            'm': String(date.getMinutes()),
            'ss': String(date.getSeconds()).padStart(2, '0'),
            's': String(date.getSeconds()),
            'SSS': String(date.getMilliseconds()).padStart(3, '0'),
            'A': date.getHours() >= 12 ? 'PM' : 'AM',
            'a': date.getHours() >= 12 ? 'pm' : 'am'
        };

        let result = format;
        // Sort tokens by length descending to avoid partial replacements (e.g., 'MMMM' before 'MMM' before 'MM')
        const sortedTokens = Object.keys(tokens).sort((a, b) => b.length - a.length);
        for (const token of sortedTokens) {
            result = result.replace(new RegExp(token, 'g'), tokens[token]);
        }
        return result;
    }




/**
     * Format date with custom format in the default timezone (Americas)
     * Supported tokens: YYYY, YY, MMMM, MMM, MM, M, DD, D, HH, H, hh, h, mm, m, ss, s, SSS, A, a
     * - MMMM: Full month name (January, February, etc.)
     * - MMM: Short month name uppercase (JAN, FEB, etc.)
     * @param date - Date to format
     * @param format - Format string
     * @param timezone - IANA timezone string (defaults to defaultTimezone)
     */
    static formatInTimezone(date: Date, format: string, timezone?: string): string {
        const c = this.getDateComponentsInTimezone(date, timezone);
        const monthNamesShort = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const monthNamesFull = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

        const tokens: Record<string, string> = {
            'YYYY': String(c.year),
            'YY': String(c.year).slice(-2),
            'MMMM': monthNamesFull[c.month - 1],
            'MMM': monthNamesShort[c.month - 1],
            'MM': String(c.month).padStart(2, '0'),
            'M': String(c.month),
            'DD': String(c.day).padStart(2, '0'),
            'D': String(c.day),
            'HH': String(c.hour).padStart(2, '0'),
            'H': String(c.hour),
            'hh': String(c.hour % 12 || 12).padStart(2, '0'),
            'h': String(c.hour % 12 || 12),
            'mm': String(c.minute).padStart(2, '0'),
            'm': String(c.minute),
            'ss': String(c.second).padStart(2, '0'),
            's': String(c.second),
            'SSS': String(c.millisecond).padStart(3, '0'),
            'A': c.hour >= 12 ? 'PM' : 'AM',
            'a': c.hour >= 12 ? 'pm' : 'am'
        };

        let result = format;
        // Sort tokens by length descending to avoid partial replacements (e.g., 'MMMM' before 'MMM' before 'MM')
        const sortedTokens = Object.keys(tokens).sort((a, b) => b.length - a.length);
        for (const token of sortedTokens) {
            result = result.replace(new RegExp(token, 'g'), tokens[token]);
        }
        return result;
    }



-------------------------------------------------------------

/**
     * Convert a Date object or date string from database to DD-MMM-YY format
     * Uses CSDateTimeUtility.format() with 'DD-MMM-YY' pattern
     * Handles JavaScript Date objects returned by database drivers
     * @param dateValue - Date object or string from database
     * @returns Date in format "DD-MMM-YY" (e.g., "01-JAN-26")
     */
    public static formatDbDateToString(dateValue: Date | string | null | undefined): string {
        if (!dateValue) return '';

        let date: Date;
        if (dateValue instanceof Date) {
            date = dateValue;
        } else if (typeof dateValue === 'string') {
            // If already in DD-MMM-YY format, return as-is
            if (/^\d{2}-[A-Z]{3}-\d{2}$/.test(dateValue)) {
                return dateValue;
            }
            // Try to parse the string as a date
            date = new Date(dateValue);
            if (isNaN(date.getTime())) {
                return dateValue; // Return original if can't parse
            }
        } else {
            return '';
        }

        // Use framework utility with MMM token for uppercase month abbreviation
        return CSDateTimeUtility.format(date, 'DD-MMM-YY');
    }

    
    public static getFirstDayOfLastMonth(): string {
        const lastMonth = CSDateTimeUtility.startOfMonth(CSDateTimeUtility.subtractMonths(new Date(), 1));
        return CSDateTimeUtility.format(lastMonth, 'DD-MMM-YY');
    }
