async waitForFullPageLoad(): Promise<void> {
        CSReporter.info('Waiting for CRM page to fully load...');

        // Block PowerApps web player resources BEFORE waiting for page load.
        // The PowerApps component embedded in Dynamics 365 tries to authenticate
        // with service.powerapps.com via a sandboxed iframe, which fails on VDI
        // and shows an infinite "Sign in required" popup loop. Blocking the web
        // player resources prevents this component from loading entirely.
        // This does NOT affect CRM functionality — only the embedded PowerApps player.
        await this.blockPowerAppsWebPlayer();

        // Wait for DOM content, then dismiss any sign-in popup that may have
        // already appeared, then wait for network idle.
        await this.waitForDomContentLoaded();
        await this.dismissSignInPopupIfPresent();

        try {
            await this.waitForNetworkIdle();
        } catch {
            // Network idle may timeout due to CRM long-polling — check for popup
            // one more time in case it appeared during the wait
            await this.dismissSignInPopupIfPresent();
            CSReporter.debug('Network idle timeout — continuing (CRM uses long-polling)');
        }

        CSReporter.pass('CRM page loaded');
    }

    /**
     * Block PowerApps web player resources that cause the infinite "Sign in required" popup.
     *
     * The PowerApps web player (content.powerapps.com/resource/webplayerbus/) is an embedded
     * component in Dynamics 365 that handles Power Apps canvases. It independently tries to
     * authenticate with service.powerapps.com via a hidden sandboxed iframe with prompt=none.
     * On VDI environments with persistent context, this silent auth fails because:
     *   - The iframe is sandboxed (can't navigate top-level window)
     *   - The token exchange returns 400 (VDI token conflicts)
     * MSAL.js then shows an interactive "Sign in" prompt, but clicking it just retries
     * the same failing flow — creating an infinite loop.
     *
     * Blocking these resources prevents the component from initializing. This is safe
     * because the CRM UI (Focus, dashboards, entity forms) works without the PowerApps player.
     */
    private async blockPowerAppsWebPlayer(): Promise<void> {
        try {
            await this.page.route(/content\.powerapps\.com.*webplayer/, async (route: any) => {
                CSReporter.debug(`Blocked PowerApps web player: ${route.request().url().substring(0, 100)}`);
                await route.abort('blockedbyclient');
            });
            CSReporter.debug('PowerApps web player route block active');
        } catch (error: any) {
            CSReporter.debug(`Could not set up PowerApps block: ${error.message}`);
        }
    }

    /**
     * Dismiss the "Sign in required" popup by closing/cancelling it (NOT by clicking "Sign in").
     * Clicking "Sign in" triggers a retry of the same failing auth flow — infinite loop.
     * Instead, we look for close/cancel/dismiss buttons or remove the dialog from the DOM.
     */
    private async dismissSignInPopupIfPresent(): Promise<void> {
        try {
            const dismissed = await this.page.evaluate(() => {
                const bodyText = document.body?.innerText?.toLowerCase() || '';

                const signInRequired =
                    (bodyText.includes('required') && bodyText.includes('sign in')) ||
                    (bodyText.includes('sign in') && bodyText.includes('features')) ||
                    bodyText.includes('sign in to continue') ||
                    bodyText.includes('session has expired') ||
                    bodyText.includes('your session has timed out');

                if (!signInRequired) return false;

                // Strategy 1: Click close/cancel/X buttons (NOT "Sign in")
                const dismissSelectors = ['button', 'a', '[role="button"]', 'span'];
                for (const selector of dismissSelectors) {
                    const elements = Array.from(document.querySelectorAll(selector));
                    for (const el of elements) {
                        const text = ((el as HTMLElement).innerText || '').trim().toLowerCase();
                        const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();
                        const title = (el.getAttribute('title') || '').toLowerCase();

                        if (text === 'close' || text === 'cancel' || text === 'dismiss' ||
                            text === 'x' || text === 'ok' || text === 'not now' ||
                            ariaLabel === 'close' || ariaLabel.includes('dismiss') ||
                            title === 'close' || title.includes('dismiss')) {
                            (el as HTMLElement).click();
                            return true;
                        }
                    }
                }

                // Strategy 2: Remove dialog/overlay elements from the DOM entirely
                const dialogSelectors = [
                    '[role="dialog"]',
                    '[role="alertdialog"]',
                    '.ms-Dialog',
                    '.ms-Modal',
                    '[class*="dialog"]',
                    '[class*="Dialog"]',
                    '[class*="modal"]',
                    '[class*="Modal"]',
                    '[class*="popup"]',
                    '[class*="Popup"]',
                ];
                for (const selector of dialogSelectors) {
                    const dialogs = Array.from(document.querySelectorAll(selector));
                    for (const dialog of dialogs) {
                        const dialogText = ((dialog as HTMLElement).innerText || '').toLowerCase();
                        if (dialogText.includes('sign in') && (dialogText.includes('required') || dialogText.includes('features'))) {
                            (dialog as HTMLElement).remove();
                            return true;
                        }
                    }
                }

                // Strategy 3: Remove overlay/backdrop
                const overlays = document.querySelectorAll('[class*="overlay"], [class*="Overlay"], [class*="backdrop"], .ms-Overlay');
                overlays.forEach(overlay => {
                    const style = window.getComputedStyle(overlay);
                    if (style.position === 'fixed' || style.position === 'absolute') {
                        (overlay as HTMLElement).remove();
                    }
                });

                return false;
            });

            if (dismissed) {
                CSReporter.info('"Sign in required" popup dismissed');
            }
        } catch (error: any) {
            CSReporter.debug(`Popup dismiss check: ${error.message}`);
        }
    }
