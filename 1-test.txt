/**
     * Check if file matches ScatteredMmteDetailsExport naming pattern (RR08)
     * Pattern: ScatteredMmteDetailsExport*.extension
     * Per Requirement Line 66: File naming convention starting with "ScatteredMmteDetailsExport"
     */
    static matchesScatteredMmteDetailsExportPattern(fileName: string): boolean {
        const pattern = /^ScatteredMmteDetailsExport.*\.(csv|xlsx)$/i;
        return pattern.test(fileName);
    }



    /**
     * Map CSV header names to DB field names (camelCase) for Associated Zeals
     * Per RR08 Requirement Lines 70-72: CSV to DB column mappings
     */
    private static associatedZealsFieldMap: Record<string, string> = {
        'Type': 'type',
        'Zeal ID': 'zealId',
        'Zeal Key': 'zealKey',
        'Zeal Name': 'zealName',
        'Inductor Group': 'inductorGroup',
        'Zzzt Seggregation': 'zzztSeggregation',
        'Scatteredd Mmtes': 'scattereddMmtes'
    };

    /**
     * Compare Associated Zeals export data with database records
     * Per RR08 Requirement Lines 67-72: Smart comparison handling different data order
     */
    static compareAssociatedZealsExportData(exportData: any[], dbData: any[]): { isMatch: boolean; differences: string[] } {
        const differences: string[] = [];

        if (exportData.length !== dbData.length) {
            differences.push(`Row count mismatch: Export=${exportData.length}, DB=${dbData.length}`);
        }

        // Create lookup by Zeal Key + Zzzt Seggregation (using camelCase from DB)
        const dbLookup = new Map<string, any>();
        dbData.forEach(row => {
            const zealKey = row['zealKey'] || row['Zeal Key'] || row['ZEAL_KEY'] || '';
            const zzztAbbr = row['zzztSeggregation'] || row['Zzzt Seggregation'] || row['ZZZT_SEGGREGATION'] || '';
            const key = `${zealKey}_${zzztAbbr}`;
            dbLookup.set(key, row);
        });

        // Compare each export row
        for (const exportRow of exportData) {
            const key = `${exportRow['Zeal Key']}_${exportRow['Zzzt Seggregation'] || ''}`;
            const dbRow = dbLookup.get(key);

            if (!dbRow) {
                differences.push(`Export row not found in DB: ${key}`);
                continue;
            }

            // Compare fields using the field mapping
            const fieldsToCompare = ['Type', 'Zeal ID', 'Zeal Key', 'Zeal Name', 'Inductor Group', 'Zzzt Seggregation', 'Scatteredd Mmtes'];
            for (const field of fieldsToCompare) {
                const exportVal = String(exportRow[field] || '').trim();

                // Get the DB field name using the mapping
                const dbFieldName = this.associatedZealsFieldMap[field] || field;
                const dbVal = String(dbRow[dbFieldName] || dbRow[field] || dbRow[field.toUpperCase().replace(/ /g, '_')] || '').trim();

                if (exportVal !== dbVal) {
                    differences.push(`${key} - ${field}: Export='${exportVal}', DB='${dbVal}'`);
                }
            }
        }

        return {
            isMatch: differences.length === 0,
            differences
        };
    }



    -----------------------------------------------------------------------------


    // ===================================================================
    // RR08 - ASSOCIATED ZEAL/PREMISIS EXPORT STEPS
    // Using Shared TTTFExportHelper Methods with Playwright Framework Tracking
    // ===================================================================

    @TSBDDStepDef('I should see new CSV file downloaded with prefix ScatteredMmteDetailsExport')
    async verifyNewCSVFileDownloadedDetailsExport(): Promise<void> {
        Tsreporter.info('Verifying CSV file is downloaded with prefix ScatteredMmteDetailsExport');

        // Get the file that was captured before export (if any)
        const previousFile = this.scenarioContext.getVariable<string>('previousCsvFile');

        // Find the latest CSV file - uses framework tracking with disputed to file system
        const latestFile = TTTFExportHelper.findDownloadedFileWithFrameworkTracking('csv');

        if (!latestFile) {
            const downloadsDir = TTTFExportHelper.getFrameworkDownloadsDirectory();
            const folders = TTTFExportHelper.getDownloadFolders();
            if (downloadsDir) {
                Tsreporter.fail(`No CSV file found. Checked framework downloads (${downloadsDir}) and system Downloads folders.`);
            } else {
                Tsreporter.fail(`No CSV file found in Downloads folders: ${folders.join(', ')}`);
            }
            throw new Error('No CSV file found after export');
        }

        // Verify it's a new file (different from before export)
        if (previousFile && latestFile.filePath === previousFile) {
            Tsreporter.fail('No new CSV file was downloaded after export');
            throw new Error('No new CSV file was downloaded after export. The latest file is the same as before.');
        }

        // Verify filename matches expected pattern (ScatteredMmteDetailsExport per Requirement Line 66)
        if (!TTTFExportHelper.matchesScatteredMmteDetailsExportPattern(latestFile.fileName)) {
            Tsreporter.fail(`CSV filename does not match expected pattern. File: ${latestFile.fileName}, Expected pattern: ScatteredMmteDetailsExport*.csv`);
            throw new Error(`CSV filename does not match expected pattern. File: ${latestFile.fileName}, Expected: ScatteredMmteDetailsExport`);
        }

        // Store the downloaded file path for later verification
        this.scenarioContext.setVariable('downloadedCsvFile', latestFile.filePath);
        this.scenarioContext.setVariable('downloadedCsvFileName', latestFile.fileName);

        Tsreporter.pass(`CSV file downloaded: ${latestFile.fileName} at ${latestFile.filePath}`);
    }

    @TSBDDStepDef('I should see new XLSX file downloaded with prefix ScatteredMmteDetailsExport')
    async verifyNewXLSXFileDownloadedDetailsExport(): Promise<void> {
        Tsreporter.info('Verifying XLSX file is downloaded with prefix ScatteredMmteDetailsExport');

        // Get the file that was captured before export (if any)
        const previousFile = this.scenarioContext.getVariable<string>('previousXlsxFile');

        // Find the latest XLSX file - uses framework tracking with disputed to file system
        const latestFile = TTTFExportHelper.findDownloadedFileWithFrameworkTracking('xlsx');

        if (!latestFile) {
            const downloadsDir = TTTFExportHelper.getFrameworkDownloadsDirectory();
            const folders = TTTFExportHelper.getDownloadFolders();
            if (downloadsDir) {
                Tsreporter.fail(`No XLSX file found. Checked framework downloads (${downloadsDir}) and system Downloads folders.`);
            } else {
                Tsreporter.fail(`No XLSX file found in Downloads folders: ${folders.join(', ')}`);
            }
            throw new Error('No XLSX file found after export');
        }

        // Verify it's a new file (different from before export)
        if (previousFile && latestFile.filePath === previousFile) {
            Tsreporter.fail('No new XLSX file was downloaded after export');
            throw new Error('No new XLSX file was downloaded after export. The latest file is the same as before.');
        }

        // Verify filename matches expected pattern (ScatteredMmteDetailsExport per Requirement Line 77)
        if (!TTTFExportHelper.matchesScatteredMmteDetailsExportPattern(latestFile.fileName)) {
            Tsreporter.fail(`XLSX filename does not match expected pattern. File: ${latestFile.fileName}, Expected pattern: ScatteredMmteDetailsExport*.xlsx`);
            throw new Error(`XLSX filename does not match expected pattern. File: ${latestFile.fileName}, Expected: ScatteredMmteDetailsExport`);
        }

        // Store the downloaded file path for later verification
        this.scenarioContext.setVariable('downloadedXlsxFile', latestFile.filePath);
        this.scenarioContext.setVariable('downloadedXlsxFileName', latestFile.fileName);

        Tsreporter.pass(`XLSX file downloaded: ${latestFile.fileName} at ${latestFile.filePath}`);
    }
