// ========================================================================
    // VALUE-IN-FIELD ASSERTIONS (Priority 103)
    // Handles: Verify 'X' is displayed in the Y field [in the Z section]
    // Must be higher priority than assert-visible to capture the "in the Y" part
    // ========================================================================
    {
        id: 'assert-value-displayed-in',
        pattern: /^(?:verify|assert|check|confirm|ensure)\s+(?:that\s+)?__QUOTED_(\d+)__\s+(?:is\s+)?(?:displayed|shown|visible|present|appearing|available)\s+(?:in|on|at|under|within)\s+(?:the\s+)?(.+)$/i,
        category: 'assertion',
        intent: 'verify-text',
        priority: 103,
        extract: (match, quotedStrings) => {
            const expectedValue = quotedStrings[parseInt(match[1])] || '';
            const rawTarget = match[2].trim();
            return {
                targetText: rawTarget,
                elementType: inferElementType(rawTarget),
                expectedValue
            };
        },
        examples: [
            "Verify 'John Smith' is displayed in the Full Name field in the User Details section",
            "Assert 'USD' is shown in the Currency dropdown",
            "Check 'Active' is visible in the Status field on the Details page"
        ]
    },


-----------------------------------------

case 'verify-text': {
                this.requireElement(element, 'verify-text');
                const el = this.createWrappedElement(element!, timeout);
                if (parameters.expectedValue !== undefined) {
                    const expected = parameters.expectedValue.trim();
                    if (modifiers.negated) {
                        await this.assertWithRetryAndScreenshot(
                            async () => {
                                const text = this.normalizeWhitespace(await el.textContent() || '');
                                return text !== expected && !text.includes(expected);
                            },
                            `Expected text to NOT be "${expected}"`,
                            timeout
                        );
                    } else {
                        await this.assertWithRetryAndScreenshot(
                            async () => {
                                const text = this.normalizeWhitespace(await el.textContent() || '');
                                // Try exact match first, then containment
                                if (text === expected || text.includes(expected)) return true;

                                // Table layout fallback: if the matched element is a <th> or label,
                                // the value is in the adjacent <td>. Check the parent <tr> row text
                                // which contains both label and value. Common in legacy IE-era apps:
                                //   <tr><th>Full Name</th><td>John Smith</td></tr>
                                try {
                                    const rowText = await element!.locator.evaluate((el: Element) => {
                                        // Walk up to find the closest <tr>
                                        let parent: Element | null = el.parentElement;
                                        for (let i = 0; i < 5 && parent; i++) {
                                            if (parent.tagName === 'TR') {
                                                // Get text from <td> siblings only (exclude the <th> label)
                                                const tds = parent.querySelectorAll('td');
                                                return Array.from(tds).map(td => td.textContent?.trim() || '').join(' ');
                                            }
                                            parent = parent.parentElement;
                                        }
                                        return '';
                                    });
                                    if (rowText && (rowText === expected || rowText.includes(expected))) {
                                        return true;
                                    }
                                } catch {
                                    // Non-critical fallback
                                }

                                return false;
                            },
                            `Expected text "${expected}" but got different content`,
                            timeout
                        );
                    }
                } else {
                    await this.assertWithRetryAndScreenshot(
                        async () => {
                            const text = (await el.textContent() || '').trim();
                            return text.length > 0;
                        },
                        `Expected element to have text but it was empty`,
                        timeout
                    );
                }
                return this.success('verify-text');
            }
