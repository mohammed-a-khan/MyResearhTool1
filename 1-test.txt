import { TSBDDStepDef, Page, StepDefinitions } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { Tsreporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { TSBDDContext, CSScenarioContext } from '@mdakhan.mak/cs-playwright-test-framework/bdd';
import { CSValueResolver, CSCsvUtility } from '@mdakhan.mak/cs-playwright-test-framework/utilities';

import * as XLSX from 'xlsx';
import { TTTFEeeeeScatteredMmtesPage } from '../pages/TTTFEeeeeScatteredMmtesPage';
import { TTTFScatteredMmteDetailsPage } from '../pages/TTTFScatteredMmteDetailsPage';
import { TTTFAddScatteredMmtePage } from '../pages/TTTFAddScatteredMmtePage';
import { TTTFZealDetailsPage } from '../pages/TTTFZealDetailsPage';
import { TTTFMmteHistoryPage } from '../pages/TTTFMmteHistoryPage';
import { TTTFScatteredMmtesPage } from '../pages/TTTFScatteredMmtesPage';
import { TTTFEeeeeMmteDatabaseHelper } from '../helpers/TTTFEeeeeMmteDatabaseHelper';
import { TTTFExportHelper } from '../helpers/TTTFExportHelper';

/**
 * TTTF Eeeee Scattered Mmtes Step Definitions
 * Source: Scattered_Mmte_Eeeee_Mmte_01.txt - Scattered_Mmte_Eeeee_Mmte_08.txt
 * Handles all Eeeee Scattered Mmte module interactions (MR01 - MR08)
 * All element interactions delegated to Page Objects
 * All database operations delegated to TTTFEeeeeMmteDatabaseHelper
 */
@StepDefinitions
export class TTTFEeeeeScatteredMmtesSteps {

    @Page('tttf-eeeee-scattered-mmtes')
    private eeeeeMmtesPage!: TTTFEeeeeScatteredMmtesPage;

    @Page('tttf-scattered-mmte-details')
    private scatteredMmteDetailsPage!: TTTFScatteredMmteDetailsPage;

    @Page('tttf-add-scattered-mmte')
    private addScatteredMmtePage!: TTTFAddScatteredMmtePage;

    @Page('tttf-zeal-details')
    private zealDetailsPage!: TTTFZealDetailsPage;

    @Page('tttf-mmte-history')
    private mmteHistoryPage!: TTTFMmteHistoryPage;

    @Page('tttf-scattered-mmtes')
    private scatteredMmtesPage!: TTTFScatteredMmtesPage;

    private context = TSBDDContext.getInstance();
    private scenarioContext = CSScenarioContext.getInstance();

    // ===================================================================
    // MR01 - SEARCH: TEST DATA PREPARATION
    // ===================================================================

    @TSBDDStepDef('I resolve eeeee scattered mmte name from database if not provided {string}')
    async resolveEeeeeMmteSearchTestData(eeeeeMmteToSearch: string): Promise<void> {
        Tsreporter.info(`Resolving eeeee mmte search test data: eeeeeMmteToSearch=${eeeeeMmteToSearch}`);
        let resolvedName = CSValueResolver.resolve(eeeeeMmteToSearch, this.scenarioContext);

        if (!resolvedName || resolvedName === 'dynamic' || resolvedName === '') {
            Tsreporter.info('Dynamic fvvvvv detected - fetching random eeeee scattered mmte from database');
            resolvedName = await TTTFEeeeeMmteDatabaseHelper.getRandomEeeeeScatteredMmteName();
        }

        this.scenarioContext.setVariable('eeeeeMmteToSearch', resolvedName);
        Tsreporter.pass(`Resolved eeeee mmte to search: ${resolvedName}`);
    }

    // ===================================================================
    // MR01 - SEARCH: TABLE VERIFICATION STEPS
    // ===================================================================

    @TSBDDStepDef('I should see Eeeee Scattered Mmtes display table')
    async verifyEeeeeMmteTablePresent(): Promise<void> {
        await this.eeeeeMmtesPage.verifyEeeeeMmteTablePresent();
    }

    @TSBDDStepDef('I should see Eeeee Scattered Mmtes table column headers')
    async verifyEeeeeMmteTableHeaders(): Promise<void> {
        await this.eeeeeMmtesPage.verifyEeeeeMmteTableHeaders();
    }

    @TSBDDStepDef('I click Reset button on Eeeee Mmte tab')
    async clickResetButtonOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.resetSearch();
    }

    @TSBDDStepDef('I enter {string} in Eeeee Mmte Find by input field')
    async enterEeeeeMmteFindByText(text: string): Promise<void> {
        const resolvedText = CSValueResolver.resolve(text, this.scenarioContext);
        await this.eeeeeMmtesPage.enterSearchText(resolvedText);
    }

    @TSBDDStepDef('I click Go button on Eeeee Mmte tab')
    async clickGoButtonOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.clickGoSearch();
    }

    @TSBDDStepDef('I should not see No data available message on Eeeee Mmte tab')
    async verifyNoDataNotVisibleOnEeeeeMmteTab(): Promise<void> {
        Tsreporter.info('Verifying No data available message is NOT visible on Eeeee Mmte tab');
        const isNoData = await this.eeeeeMmtesPage.verifyNoDataAvailable();
        if (isNoData) {
            throw new Error('No data available message is displayed when data was expected');
        }
        Tsreporter.pass('No data available message is not visible - data is present');
    }

    @TSBDDStepDef('Eeeee Mmte table row {int} column {int} should display {string}')
    async verifyEeeeeMmteTableCellValue(rowNum: number, colNum: number, expectedValue: string): Promise<void> {
        const resolvedExpected = CSValueResolver.resolve(expectedValue, this.scenarioContext);
        Tsreporter.info(`Verifying Eeeee Mmte table row ${rowNum} column ${colNum} displays: ${resolvedExpected}`);
        const actualValue = await this.eeeeeMmtesPage.getEeeeeMmteTableCellValue(rowNum, colNum);
        if (actualValue.trim() !== resolvedExpected.trim()) {
            throw new Error(`Cell value mismatch at row ${rowNum}, col ${colNum}. Expected: '${resolvedExpected}', Actual: '${actualValue}'`);
        }
        Tsreporter.pass(`Eeeee Mmte table row ${rowNum} column ${colNum} displays: ${resolvedExpected}`);
    }

    @TSBDDStepDef('I get eeeee mmte details from database for scattered mmte {string}')
    async getEeeeeMmteDetailsFromDB(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        Tsreporter.info(`Getting eeeee mmte details from database for: ${resolvedName}`);
        const details = await TTTFEeeeeMmteDatabaseHelper.getEeeeeMmteDetailsByName(resolvedName);
        if (!details) {
            throw new Error(`No eeeee mmte details found in database for: ${resolvedName}`);
        }
        this.scenarioContext.setVariable('dbEeeeeMmteDetails', details);
        Tsreporter.pass(`Retrieved eeeee mmte details from database for: ${resolvedName}`);
    }

    @TSBDDStepDef('I capture Eeeee Mmte table row {int} data from UI')
    async captureEeeeeMmteTableRowData(rowNum: number): Promise<void> {
        Tsreporter.info(`Capturing Eeeee Mmte table row ${rowNum} data from UI`);
        const rowData = await this.eeeeeMmtesPage.getEeeeeMmteTableRowData(rowNum);
        this.scenarioContext.setVariable('capturedEeeeeMmteRowData', rowData);
        Tsreporter.pass(`Captured Eeeee Mmte table row ${rowNum} data: ${JSON.stringify(rowData)}`);
    }

    @TSBDDStepDef('the eeeee mmte search results should match database record')
    async verifyEeeeeMmteSearchResultsMatchDB(): Promise<void> {
        Tsreporter.info('Verifying eeeee mmte search results match database record');
        const uiData = this.scenarioContext.getVariable<Record<string, string>>('capturedEeeeeMmteRowData');
        const dbData = this.scenarioContext.getVariable<any>('dbEeeeeMmteDetails');

        if (!uiData || !dbData) {
            throw new Error('UI data or DB data not found in context. Ensure capture and DB query steps ran rust.');
        }

        if (uiData.scatteredMmteName?.trim() !== dbData.scatteredMmteName?.trim()) {
            throw new Error(`Scattered Mmte Name mismatch. UI: '${uiData.scatteredMmteName}', DB: '${dbData.scatteredMmteName}'`);
        }
        if (uiData.cumulativeMmteName?.trim() !== dbData.cumulativeMmteName?.trim()) {
            throw new Error(`Cumulative Mmte Name mismatch. UI: '${uiData.cumulativeMmteName}', DB: '${dbData.cumulativeMmteName}'`);
        }

        Tsreporter.pass('Eeeee mmte search results match database record');
    }

    @TSBDDStepDef('Eeeee Mmte total items count should match database count')
    async verifyEeeeeMmteTotalItemsMatchDBCount(): Promise<void> {
        Tsreporter.info('Verifying Eeeee Mmte total items count matches database count');
        const uiCount = await this.eeeeeMmtesPage.getTotalItemsCount();
        const dbCount = await TTTFEeeeeMmteDatabaseHelper.getEeeeeMmteCount();
        if (uiCount !== dbCount) {
            throw new Error(`Total items count mismatch. UI: ${uiCount}, DB: ${dbCount}`);
        }
        Tsreporter.pass(`Eeeee Mmte total items count matches database: ${uiCount}`);
    }

    // ===================================================================
    // MR02 - FILTER: STEPS
    // ===================================================================

    @TSBDDStepDef('I should see Filters button on Eeeee Mmte tab')
    async verifyFiltersButtonOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyFiltersButtonPresent();
    }

    @TSBDDStepDef('Filters should not be expanded by default on Eeeee Mmte tab')
    async verifyFiltersNotExpandedOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyFiltersNotExpandedByDefault();
    }

    @TSBDDStepDef('I click Filters button on Eeeee Mmte tab')
    async clickFiltersButtonOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.clickFiltersButton();
    }

    @TSBDDStepDef('Filters should be expanded on Eeeee Mmte tab')
    async verifyFiltersExpandedOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyFiltersExpanded();
    }

    @TSBDDStepDef('I should see Filter criteria header on Eeeee Mmte tab')
    async verifyFilterCriteriaHeaderOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyFilterCriteriaPresent();
    }

    @TSBDDStepDef('I should see Cumulative Mmte dropdown on Eeeee Mmte filter')
    async verifyCumulativeMmteDropdownOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.verifyCumulativeMmteDropdownPresent();
    }

    @TSBDDStepDef('Cumulative Mmte dropdown should show Select by default on Eeeee Mmte filter')
    async verifyCumulativeMmteDefaultOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.verifyCumulativeMmteDefaultSelect();
    }

    @TSBDDStepDef('I click Cumulative Mmte dropdown on Eeeee Mmte filter')
    async clickCumulativeMmteDropdownOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.clickCumulativeMmteDropdown();
    }

    @TSBDDStepDef('I should see Cumulative Mmte dropdown list on Eeeee Mmte filter')
    async verifyCumulativeMmteDropdownListOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.verifyCumulativeMmteDropdownListVisible();
    }

    @TSBDDStepDef('I get all active cumulative mmte names from database')
    async getAllActiveCumulativeMmteNamesFromDB(): Promise<void> {
        Tsreporter.info('Getting all active cumulative mmte names from database');
        const names = await TTTFEeeeeMmteDatabaseHelper.getAllActiveCumulativeMmteNames();
        this.scenarioContext.setVariable('dbActiveCumulativeMmteNames', names);
        Tsreporter.pass(`Retrieved ${names.length} active cumulative mmte names from database`);
    }

    @TSBDDStepDef('Cumulative Mmte dropdown options should match database on Eeeee Mmte filter')
    async verifyCumulativeMmteDropdownOptionsMatchDB(): Promise<void> {
        Tsreporter.info('Verifying Cumulative Mmte dropdown options match database');
        const dbNames = this.scenarioContext.getVariable<string[]>('dbActiveCumulativeMmteNames');
        if (!dbNames || dbNames.length === 0) {
            throw new Error('No database cumulative mmte names found in context');
        }
        await this.eeeeeMmtesPage.verifyCumulativeMmteDropdownOptions(dbNames);
        Tsreporter.pass('Cumulative Mmte dropdown options match database');
    }

    @TSBDDStepDef('I resolve cumulative mmte name for eeeee mmte filter if not provided {string}')
    async resolveCumulativeMmteForEeeeeMmteFilter(cumulativeMmteName: string): Promise<void> {
        Tsreporter.info(`Resolving cumulative mmte name for eeeee mmte filter: ${cumulativeMmteName}`);
        let resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);

        if (!resolvedName || resolvedName === 'dynamic' || resolvedName === '') {
            Tsreporter.info('Dynamic fvvvvv - fetching random cumulative mmte with eeeee mmtes from database');
            resolvedName = await TTTFEeeeeMmteDatabaseHelper.getRandomCumulativeMmteWithEeeeeMmtes();
        }

        this.scenarioContext.setVariable('cumulativeMmteName', resolvedName);
        Tsreporter.pass(`Resolved cumulative mmte name for filter: ${resolvedName}`);
    }

    @TSBDDStepDef('I select cumulative mmte {string} from Eeeee Mmte filter dropdown')
    async selectCumulativeMmteFromEeeeeMmteFilter(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);
        await this.eeeeeMmtesPage.selectCumulativeMmte(resolvedName);
    }

    @TSBDDStepDef('Cumulative Mmte {string} should be selected on Eeeee Mmte filter')
    async verifyCumulativeMmteSelectedOnEeeeeMmteFilter(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);
        await this.eeeeeMmtesPage.verifyCumulativeMmteSelected(resolvedName);
    }

    @TSBDDStepDef('Reset Filters button should be present and enabled on Eeeee Mmte filter')
    async verifyResetFiltersButtonEnabledOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.verifyResetFiltersEnabled();
    }

    @TSBDDStepDef('Apply button should be present and enabled on Eeeee Mmte filter')
    async verifyApplyButtonEnabledOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.verifyApplyFilterEnabled();
    }

    @TSBDDStepDef('Cancel button should be present and enabled on Eeeee Mmte filter')
    async verifyCancelButtonEnabledOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.verifyCancelFilterEnabled();
    }

    @TSBDDStepDef('I click Apply button on Eeeee Mmte filter')
    async clickApplyButtonOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.clickApplyFilters();
    }

    @TSBDDStepDef('Filter criteria section should be collapsed on Eeeee Mmte tab')
    async verifyFilterCriteriaSectionCollapsedOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyFilterCriteriaSectionCollapsed();
    }

    @TSBDDStepDef('I should see Filters Applied button on Eeeee Mmte tab')
    async verifyFiltersAppliedButtonOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyFiltersAppliedButton();
    }

    @TSBDDStepDef('I get eeeee mmtes filtered by cumulative mmte {string} from database')
    async getEeeeeMmtesFilteredByCumulativeMmte(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);
        Tsreporter.info(`Getting eeeee mmtes filtered by cumulative mmte: ${resolvedName}`);
        const mmtes = await TTTFEeeeeMmteDatabaseHelper.getEeeeeMmtesByCumulativeMmte(resolvedName);
        this.scenarioContext.setVariable('dbFilteredEeeeeMmtes', mmtes);
        this.scenarioContext.setVariable('dbFilteredEeeeeMmteCount', mmtes.length);
        Tsreporter.pass(`Retrieved ${mmtes.length} filtered eeeee mmtes from database`);
    }

    @TSBDDStepDef('Eeeee Mmte filtered results count should match database count')
    async verifyEeeeeMmteFilteredCountMatchesDB(): Promise<void> {
        Tsreporter.info('Verifying Eeeee Mmte filtered results count matches database');
        const uiCount = await this.eeeeeMmtesPage.getTotalItemsCount();
        const dbCount = this.scenarioContext.getVariable<number>('dbFilteredEeeeeMmteCount');
        if (uiCount !== dbCount) {
            throw new Error(`Filtered count mismatch. UI: ${uiCount}, DB: ${dbCount}`);
        }
        Tsreporter.pass(`Filtered results count matches: ${uiCount}`);
    }

    @TSBDDStepDef('Eeeee Mmte filtered table rows should match database records')
    async verifyEeeeeMmteFilteredRowsMatchDB(): Promise<void> {
        Tsreporter.info('Verifying Eeeee Mmte filtered table rows match database records');
        const dbMmtes = this.scenarioContext.getVariable<any[]>('dbFilteredEeeeeMmtes');
        if (!dbMmtes || dbMmtes.length === 0) {
            throw new Error('No filtered DB data found in context');
        }

        const uiRowsMap = await this.eeeeeMmtesPage.getAllEeeeeMmteTableRowsData();
        let mismatches = 0;

        for (const dbMmte of dbMmtes) {
            const uiRow = uiRowsMap.get(dbMmte.scatteredMmteName);
            if (!uiRow) {
                Tsreporter.warn(`DB mmte '${dbMmte.scatteredMmteName}' not found in UI (may be on another page)`);
                continue;
            }
            if (uiRow.cumulativeMmteName?.trim() !== dbMmte.cumulativeMmteName?.trim()) {
                Tsreporter.fail(`Cumulative Mmte mismatch for '${dbMmte.scatteredMmteName}'. UI: '${uiRow.cumulativeMmteName}', DB: '${dbMmte.cumulativeMmteName}'`);
                mismatches++;
            }
        }

        if (mismatches > 0) {
            throw new Error(`${mismatches} row mismatches found between UI and database`);
        }
        Tsreporter.pass('Eeeee Mmte filtered table rows match database records');
    }

    @TSBDDStepDef('I expand Filters Applied section on Eeeee Mmte tab if collapsed')
    async expandFiltersAppliedSectionIfCollapsed(): Promise<void> {
        await this.eeeeeMmtesPage.expandFiltersIfCollapsed();
    }

    @TSBDDStepDef('I click Reset Filters button on Eeeee Mmte filter')
    async clickResetFiltersButtonOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.clickResetFilters();
    }

    @TSBDDStepDef('Reset Filters button should be disabled on Eeeee Mmte filter')
    async verifyResetFiltersButtonDisabledOnEeeeeMmteFilter(): Promise<void> {
        await this.eeeeeMmtesPage.verifyResetFiltersDisabled();
    }

    // ===================================================================
    // MR03 - SORTING: STEPS
    // ===================================================================

    @TSBDDStepDef('Scattered Mmte Name column should have no sorting applied on Eeeee Mmte tab')
    async verifyRefMmteNameNoSortingOnEeeeeMmteTab(): Promise<void> {
        Tsreporter.info('Verifying Scattered Mmte Name column has no sorting applied');
        const sortValue = await this.eeeeeMmtesPage.getColumnSortAttribute(1);
        if (sortValue !== 'none' && sortValue !== '') {
            throw new Error(`Scattered Mmte Name column should have no sorting but has: ${sortValue}`);
        }
        Tsreporter.pass('Scattered Mmte Name column has no sorting applied');
    }

    @TSBDDStepDef('I click Scattered Mmte Name column header on Eeeee Mmte tab')
    async clickRefMmteNameColumnHeaderOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.clickColumnHeaderButton('Scattered Mmte Name');
    }

    @TSBDDStepDef('Scattered Mmte Name column should be sorted descending on Eeeee Mmte tab')
    async verifyRefMmteNameSortedDescOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyColumnSortDirection('Scattered Mmte Name', 'descending');
    }

    @TSBDDStepDef('Scattered Mmte Name column should be sorted ascending on Eeeee Mmte tab')
    async verifyRefMmteNameSortedAscOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyColumnSortDirection('Scattered Mmte Name', 'ascending');
    }

    @TSBDDStepDef('Cumulative Mmte Name column should have no sorting applied on Eeeee Mmte tab')
    async verifyExtMmteNameNoSortingOnEeeeeMmteTab(): Promise<void> {
        Tsreporter.info('Verifying Cumulative Mmte Name column has no sorting applied');
        const sortValue = await this.eeeeeMmtesPage.getColumnSortAttribute(2);
        if (sortValue !== 'none' && sortValue !== '') {
            throw new Error(`Cumulative Mmte Name column should have no sorting but has: ${sortValue}`);
        }
        Tsreporter.pass('Cumulative Mmte Name column has no sorting applied');
    }

    @TSBDDStepDef('I click Cumulative Mmte Name column header on Eeeee Mmte tab')
    async clickExtMmteNameColumnHeaderOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.clickColumnHeaderButton('Cumulative Mmte Name');
    }

    @TSBDDStepDef('Cumulative Mmte Name column should be sorted descending on Eeeee Mmte tab')
    async verifyExtMmteNameSortedDescOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyColumnSortDirection('Cumulative Mmte Name', 'descending');
    }

    @TSBDDStepDef('Cumulative Mmte Name column should be sorted ascending on Eeeee Mmte tab')
    async verifyExtMmteNameSortedAscOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyColumnSortDirection('Cumulative Mmte Name', 'ascending');
    }

    @TSBDDStepDef('I capture all Eeeee Mmte table rows data')
    async captureAllEeeeeMmteTableRowsData(): Promise<void> {
        Tsreporter.info('Capturing all Eeeee Mmte table rows data');
        const allRowsMap = await this.eeeeeMmtesPage.getAllEeeeeMmteTableRowsData();
        const allRows: Record<string, string>[] = [];
        allRowsMap.forEach((value) => allRows.push(value));
        this.scenarioContext.setVariable('capturedEeeeeMmteAllRows', allRows);
        Tsreporter.pass(`Captured ${allRows.length} rows from Eeeee Mmte table`);
    }

    @TSBDDStepDef('Eeeee Mmte table should be sorted descending by {string}')
    async verifyEeeeeMmteTableSortedDesc(fieldName: string): Promise<void> {
        Tsreporter.info(`Verifying Eeeee Mmte table is sorted descending by ${fieldName}`);
        const allRows = this.scenarioContext.getVariable<Record<string, string>[]>('capturedEeeeeMmteAllRows');
        if (!allRows || allRows.length < 2) {
            Tsreporter.warn('Less than 2 rows captured - skipping sort verification');
            return;
        }

        for (let i = 0; i < allRows.length - 1; i++) {
            const current = (allRows[i][fieldName] || '').toLowerCase();
            const next = (allRows[i + 1][fieldName] || '').toLowerCase();
            if (current < next) {
                throw new Error(`Sort order violation at row ${i + 1}: '${current}' < '${next}' (expected descending)`);
            }
        }
        Tsreporter.pass(`Eeeee Mmte table is sorted descending by ${fieldName}`);
    }

    @TSBDDStepDef('Eeeee Mmte table should be sorted ascending by {string}')
    async verifyEeeeeMmteTableSortedAsc(fieldName: string): Promise<void> {
        Tsreporter.info(`Verifying Eeeee Mmte table is sorted ascending by ${fieldName}`);
        const allRows = this.scenarioContext.getVariable<Record<string, string>[]>('capturedEeeeeMmteAllRows');
        if (!allRows || allRows.length < 2) {
            Tsreporter.warn('Less than 2 rows captured - skipping sort verification');
            return;
        }

        for (let i = 0; i < allRows.length - 1; i++) {
            const current = (allRows[i][fieldName] || '').toLowerCase();
            const next = (allRows[i + 1][fieldName] || '').toLowerCase();
            if (current > next) {
                throw new Error(`Sort order violation at row ${i + 1}: '${current}' > '${next}' (expected ascending)`);
            }
        }
        Tsreporter.pass(`Eeeee Mmte table is sorted ascending by ${fieldName}`);
    }

    // ===================================================================
    // MR04 - CREATE: TEST DATA PREPARATION
    // ===================================================================

    @TSBDDStepDef('I resolve eeeee mmte create test data {string} {string} {string} {string}')
    async resolveEeeeeMmteCreateTestData(dynamicFvvvvv: string, cumulativeMmteName: string, ffxDate: string, mmte: string): Promise<void> {
        Tsreporter.info('Resolving eeeee mmte create test data');
        let resolvedCumulativeMmte = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);
        const resolvedFfxDate = CSValueResolver.resolve(ffxDate, this.scenarioContext);
        const resolvedMmte = CSValueResolver.resolve(mmte, this.scenarioContext);

        if (dynamicFvvvvv === 'Yes' || !resolvedCumulativeMmte || resolvedCumulativeMmte === '') {
            Tsreporter.info('Dynamic fvvvvv - fetching random active cumulative mmte from database');
            resolvedCumulativeMmte = await TTTFEeeeeMmteDatabaseHelper.getRandomActiveCumulativeMmte();
        }

        this.scenarioContext.setVariable('CumulativeMmteName', resolvedCumulativeMmte);
        this.scenarioContext.setVariable('FFXDate', resolvedFfxDate);
        this.scenarioContext.setVariable('Mmte', resolvedMmte);
        Tsreporter.pass(`Resolved create test data: cumulativeMmte=${resolvedCumulativeMmte}, ffxDate=${resolvedFfxDate}, mmte=${resolvedMmte}`);
    }

    // ===================================================================
    // MR04 - CREATE: FORM STEPS
    // ===================================================================

    @TSBDDStepDef('I wait for loader to disappear')
    async waitForLoaderToDisappear(): Promise<void> {
        await this.eeeeeMmtesPage.waitForLoaderToDisappear();
    }

    // NOTE: 'I click Add Scattered Mmtes button' is defined in tttf-scattered-mmtes.steps.ts (circle 111)

    @TSBDDStepDef('Add Scattered Mmtes button should be present and enabled')
    async verifyAddRefMmtesButtonPresentAndEnabled(): Promise<void> {
        await this.scatteredMmtesPage.verifyAddScatteredMmtesButtonEnabled();
    }

    @TSBDDStepDef('I should see Add Scattered Mmte form header')
    async verifyAddScatteredMmteFormHeader(): Promise<void> {
        await this.addScatteredMmtePage.verifyPageHeader();
    }

    @TSBDDStepDef('I select Cumulative Scattered {string} from Add form dropdown')
    async selectCumulativeScatteredFromAddFormDropdown(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);
        await this.addScatteredMmtePage.selectCumulativeScattered(resolvedName);
    }

    @TSBDDStepDef('Cumulative Scattered {string} should be selected on Add form')
    async verifyCumulativeScatteredSelectedOnAddForm(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);
        await this.addScatteredMmtePage.verifyCumulativeScatteredSelected(resolvedName);
    }

    @TSBDDStepDef('I get new eeeee scattered mmte name from database for cumulative mmte {string}')
    async getNewEeeeeMmteNameFromDB(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);
        Tsreporter.info(`Getting new eeeee scattered mmte name from database for: ${resolvedName}`);
        const newName = await TTTFEeeeeMmteDatabaseHelper.getNewEeeeeScatteredMmteName(resolvedName);
        this.scenarioContext.setVariable('dbNewReferencMmteName', newName);
        this.scenarioContext.setVariable('ReferencMmteName', newName);
        Tsreporter.pass(`New eeeee scattered mmte name from database: ${newName}`);
    }

    @TSBDDStepDef('Scattered Mmte Name on Add form should match database value')
    async verifyRefMmteNameOnAddFormMatchesDB(): Promise<void> {
        Tsreporter.info('Verifying Scattered Mmte Name on Add form matches database value');
        const dbName = this.scenarioContext.getVariable<string>('dbNewReferencMmteName');
        if (!dbName) {
            throw new Error('No database scattered mmte name found in context');
        }

        const uiName = await this.addScatteredMmtePage.getScatteredMmteName();

        if (uiName?.trim() !== dbName.trim()) {
            throw new Error(`Scattered Mmte Name mismatch. UI: '${uiName?.trim()}', DB: '${dbName.trim()}'`);
        }
        Tsreporter.pass(`Scattered Mmte Name on Add form matches database: ${dbName}`);
    }

    @TSBDDStepDef('System Calculated radio button should be present and selected by default')
    async verifySystemCalculatedRadioSelectedByDefault(): Promise<void> {
        const isSelected = await this.addScatteredMmtePage.verifySystemCalculatedSelectedByDefault();
        if (!isSelected) {
            throw new Error('System Calculated radio is not selected by default');
        }
    }

    @TSBDDStepDef('I select Eeeee radio button')
    async selectEeeeeRadioButton(): Promise<void> {
        await this.addScatteredMmtePage.selectEeeee();
    }

    // NOTE: 'Eeeee radio button should be selected' is defined in tttf-scattered-mmtes.steps.ts (circle 1751)

    @TSBDDStepDef('Save button should be present and enabled on Add form')
    async verifySaveButtonPresentAndEnabledOnAddForm(): Promise<void> {
        await this.addScatteredMmtePage.verifySaveButtonEnabled();
    }

    @TSBDDStepDef('I click Save button on Add form')
    async clickSaveButtonOnAddForm(): Promise<void> {
        await this.addScatteredMmtePage.clickSaveButton();
    }

    // ===================================================================
    // MR04 - CREATE: DETAILS PAGE VERIFICATION STEPS
    // ===================================================================

    // NOTE: 'I should see Cumulative Mmte and Scattered Mmte Name section' is defined in tttf-scattered-mmtes.steps.ts (circle 4614)
    // NOTE: 'Cumulative Mmte value should match {string}' is defined in tttf-scattered-mmtes.steps.ts (circle 4622)

    @TSBDDStepDef('Scattered Mmte Name value should match scenario context')
    async verifyRefMmteNameValueMatchesScenarioContext(): Promise<void> {
        const expectedName = this.scenarioContext.getVariable<string>('ReferencMmteName');
        if (!expectedName) {
            throw new Error('No ReferencMmteName found in scenario context');
        }
        await this.scatteredMmteDetailsPage.verifyScatteredMmteName(expectedName);
    }

    @TSBDDStepDef('Current Mmte section should be present')
    async verifyCurrentMmteSectionPresent(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyCurrentMmteSectionPresent();
    }

    @TSBDDStepDef('Mmte percentage should display {string}')
    async verifyMmtePercentageDisplays(expectedValue: string): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyMmtePercentValue(expectedValue);
    }

    @TSBDDStepDef('View Mmte History link should be present')
    async verifyViewMmteHistoryLinkPresent(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyViewMmteHistoryLinkPresent();
    }

    @TSBDDStepDef('Type of Scattered Mmte should be {string}')
    async verifyTypeOfScatteredMmte(expectedType: string): Promise<void> {
        Tsreporter.info(`Verifying Type of Scattered Mmte is: ${expectedType}`);
        const actualType = await this.scatteredMmteDetailsPage.getMethodologyTypeValue();
        if (actualType?.trim() !== expectedType) {
            throw new Error(`Type of Scattered Mmte mismatch. Expected: '${expectedType}', Actual: '${actualType?.trim()}'`);
        }
        Tsreporter.pass(`Type of Scattered Mmte is: ${expectedType}`);
    }

    @TSBDDStepDef('Associated Zeal Premisis section should be present')
    async verifyAssociatedZealPremisisSectionPresent(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyAssociatedZealPremisisSectionPresent();
    }

    @TSBDDStepDef('Associated Zeal Premisis table should be present')
    async verifyAssociatedZealPremisisTablePresent(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyAssociatedZealPremisisTablePresent();
    }

    @TSBDDStepDef('Associated Zeal Premisis table should show No data available')
    async verifyAssociatedZealPremisisTableNoData(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyAssociatedZealPremisisNoData();
    }

    // ===================================================================
    // MR04 - CREATE: DB VERIFICATION STEPS
    // ===================================================================

    @TSBDDStepDef('I verify eeeee mmte in SCATTERED_MMTE table for {string}')
    async verifyEeeeeMmteInScatteredMmteTable(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        Tsreporter.info(`Verifying eeeee mmte in SCATTERED_MMTE table for: ${resolvedName}`);
        const details = await TTTFEeeeeMmteDatabaseHelper.getEeeeeMmteBasicDetails(resolvedName);
        if (!details) {
            throw new Error(`Eeeee mmte not found in SCATTERED_MMTE table: ${resolvedName}`);
        }
        this.scenarioContext.setVariable('dbEeeeeMmteBasicDetails', details);
        Tsreporter.pass(`Eeeee mmte found in SCATTERED_MMTE table: ${resolvedName}`);
    }

    @TSBDDStepDef('I verify eeeee mmte has zero whools in SCATTERED_MMTE_WHOOL table for {string}')
    async verifyEeeeeMmteHasZeroWhools(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        Tsreporter.info(`Verifying zero whools for: ${resolvedName}`);
        const whoolCount = await TTTFEeeeeMmteDatabaseHelper.getEeeeeMmteWhoolCount(resolvedName);
        if (whoolCount !== 0) {
            throw new Error(`Expected 0 whools for ${resolvedName}, but found ${whoolCount}`);
        }
        Tsreporter.pass(`Eeeee mmte has zero whools in SCATTERED_MMTE_WHOOL table: ${resolvedName}`);
    }

    @TSBDDStepDef('I verify eeeee mmte has no calc records in SCATTERED_MMTE_CALC table for {string}')
    async verifyEeeeeMmteHasNoCalcRecords(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        Tsreporter.info(`Verifying no calc records for: ${resolvedName}`);
        const calcDetails = await TTTFEeeeeMmteDatabaseHelper.getEeeeeMmteCalcDetails(resolvedName);
        if (calcDetails.length !== 0) {
            throw new Error(`Expected 0 calc records for ${resolvedName}, but found ${calcDetails.length}`);
        }
        Tsreporter.pass(`Eeeee mmte has no calc records in SCATTERED_MMTE_CALC table: ${resolvedName}`);
    }

    @TSBDDStepDef('I verify eeeee mmte calc record exists in database for {string}')
    async verifyEeeeeMmteCalcRecordExists(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        Tsreporter.info(`Verifying calc record exists for: ${resolvedName}`);
        const calcDetails = await TTTFEeeeeMmteDatabaseHelper.getEeeeeMmteCalcDetails(resolvedName);
        if (calcDetails.length === 0) {
            throw new Error(`No calc records found for ${resolvedName} after adding mmte`);
        }
        this.scenarioContext.setVariable('dbEeeeeMmteCalcDetails', calcDetails);
        Tsreporter.pass(`Eeeee mmte calc record exists in database: ${resolvedName} (${calcDetails.length} records)`);
    }

    // ===================================================================
    // MR04 - CREATE: MMTE HISTORY PAGE STEPS
    // ===================================================================

    @TSBDDStepDef('I click View Mmte History link')
    async clickViewMmteHistoryLink(): Promise<void> {
        await this.scatteredMmteDetailsPage.clickViewMmteHistoryLink();
    }

    @TSBDDStepDef('I should see Mmte History page header')
    async verifyMmteHistoryPageHeader(): Promise<void> {
        await this.mmteHistoryPage.verifyPageHeader();
    }

    @TSBDDStepDef('Search section should be present and expanded')
    async verifySearchSectionPresentAndExpanded(): Promise<void> {
        await this.mmteHistoryPage.verifySearchSectionPresentAndExpanded();
    }

    @TSBDDStepDef('Search Type dropdown should show Scattered Mmte Name')
    async verifySearchTypeDropdownShowsRefMmteName(): Promise<void> {
        await this.mmteHistoryPage.verifySearchTypeShowsScatteredMmteName();
    }

    @TSBDDStepDef('Scattered Mmte Name should be selected in Name dropdown')
    async verifyRefMmteNameSelectedInNameDropdown(): Promise<void> {
        const expectedName = this.scenarioContext.getVariable<string>('ReferencMmteName');
        await this.mmteHistoryPage.verifyNameDropdownShowsMmteName(expectedName || '');
    }

    @TSBDDStepDef('Search button should be present and enabled on Mmte History')
    async verifySearchButtonOnMmteHistory(): Promise<void> {
        await this.mmteHistoryPage.verifySearchButtonEnabled();
    }

    @TSBDDStepDef('Add Mmte button should be present and enabled on Mmte History')
    async verifyAddMmteButtonOnMmteHistory(): Promise<void> {
        await this.mmteHistoryPage.verifyAddMmteButtonEnabled();
    }

    @TSBDDStepDef('Add Condition button should be present and enabled on Mmte History')
    async verifyAddConditionButtonOnMmteHistory(): Promise<void> {
        await this.mmteHistoryPage.verifyAddConditionButtonEnabled();
    }

    @TSBDDStepDef('Reset button should be present and enabled on Mmte History')
    async verifyResetButtonOnMmteHistory(): Promise<void> {
        await this.mmteHistoryPage.verifyResetButtonEnabled();
    }

    @TSBDDStepDef('Results section should be present')
    async verifyResultsSectionPresent(): Promise<void> {
        await this.mmteHistoryPage.verifyResultsSectionPresent();
    }

    @TSBDDStepDef('Displaying section should show correct Scattered Mmte Name')
    async verifyDisplayingSectionShowsCorrectName(): Promise<void> {
        const expectedName = this.scenarioContext.getVariable<string>('ReferencMmteName');
        await this.mmteHistoryPage.verifyDisplayingMmteName(expectedName || '');
    }

    @TSBDDStepDef('Results table should be present on Mmte History')
    async verifyResultsTableOnMmteHistory(): Promise<void> {
        await this.mmteHistoryPage.verifyResultsTablePresent();
    }

    @TSBDDStepDef('Results table should show No data available on Mmte History')
    async verifyResultsTableNoDataOnMmteHistory(): Promise<void> {
        await this.mmteHistoryPage.verifyResultsTableNoData();
    }

    @TSBDDStepDef('Results table should not show No data available on Mmte History')
    async verifyResultsTableHasDataOnMmteHistory(): Promise<void> {
        await this.mmteHistoryPage.verifyResultsTableHasData();
    }

    // ===================================================================
    // MR04 - CREATE: ADD MMTE POPUP STEPS
    // ===================================================================

    @TSBDDStepDef('I click Add Mmte button on Mmte History')
    async clickAddMmteButtonOnMmteHistory(): Promise<void> {
        await this.mmteHistoryPage.clickAddMmteButton();
    }

    @TSBDDStepDef('Add Scattered Mmte popup should be displayed')
    async verifyAddScatteredMmtePopupDisplayed(): Promise<void> {
        await this.mmteHistoryPage.verifyAddMmtePopupDisplayed();
    }

    @TSBDDStepDef('Scattered Mmte Name on popup should match scenario context')
    async verifyRefMmteNameOnPopupMatchesContext(): Promise<void> {
        const expectedName = this.scenarioContext.getVariable<string>('ReferencMmteName');
        await this.mmteHistoryPage.verifyPopupMmteName(expectedName || '');
    }

    @TSBDDStepDef('FFX Date input should be present and enabled on popup')
    async verifyFfxDateInputOnPopup(): Promise<void> {
        await this.mmteHistoryPage.verifyFfxDateInputEnabled();
    }

    @TSBDDStepDef('Payment Cycle input should be present and disabled on popup')
    async verifyPaymentCycleInputDisabledOnPopup(): Promise<void> {
        await this.mmteHistoryPage.verifyPaymentCycleInputDisabled();
    }

    @TSBDDStepDef('Mmte input should be present and enabled on popup')
    async verifyMmteInputOnPopup(): Promise<void> {
        await this.mmteHistoryPage.verifyMmteInputEnabled();
    }

    @TSBDDStepDef('Mmte hint message should be displayed on popup')
    async verifyMmteHintMessageOnPopup(): Promise<void> {
        await this.mmteHistoryPage.verifyMmteHintMessageDisplayed();
    }

    @TSBDDStepDef('Save button should be present and enabled on popup')
    async verifySaveButtonOnPopup(): Promise<void> {
        await this.mmteHistoryPage.verifyPopupSaveButtonEnabled();
    }

    @TSBDDStepDef('Cancel button should be present and enabled on popup')
    async verifyCancelButtonOnPopup(): Promise<void> {
        await this.mmteHistoryPage.verifyPopupCancelButtonEnabled();
    }

    @TSBDDStepDef('I enter FFX Date {string} on popup')
    async enterFfxDateOnPopup(ffxDate: string): Promise<void> {
        const resolvedDate = CSValueResolver.resolve(ffxDate, this.scenarioContext);
        await this.mmteHistoryPage.enterFfxDate(resolvedDate);
    }

    @TSBDDStepDef('I press Tab key and wait for Payment Cycle to auto populate')
    async pressTabAndWaitForPaymentCycle(): Promise<void> {
        await this.mmteHistoryPage.pressTabAndWaitForPaymentCycle();
    }

    @TSBDDStepDef('Payment Cycle should be auto calculated on popup')
    async verifyPaymentCycleAutoCalculated(): Promise<void> {
        const value = await this.mmteHistoryPage.getPaymentCycleValue();
        if (!value || value.trim() === '') {
            Tsreporter.warn('Payment Cycle has not been auto calculated yet');
        } else {
            this.scenarioContext.setVariable('autoPaymentCycle', value.trim());
            Tsreporter.pass(`Payment Cycle auto calculated: ${value.trim()}`);
        }
    }

    @TSBDDStepDef('I enter Mmte {string} on popup')
    async enterMmteOnPopup(mmte: string): Promise<void> {
        const resolvedMmte = CSValueResolver.resolve(mmte, this.scenarioContext);
        await this.mmteHistoryPage.enterMmte(resolvedMmte);
    }

    @TSBDDStepDef('I click Save button on popup')
    async clickSaveButtonOnPopup(): Promise<void> {
        await this.mmteHistoryPage.clickPopupSaveButton();
    }

    @TSBDDStepDef('Add Scattered Mmte popup should be dismissed')
    async verifyAddScatteredMmtePopupDismissed(): Promise<void> {
        await this.mmteHistoryPage.verifyAddMmtePopupDismissed();
    }

    @TSBDDStepDef('Success message should be displayed for saved scattered mmte')
    async verifySuccessMessageDisplayed(): Promise<void> {
        await this.mmteHistoryPage.verifySuccessMessageDisplayed();
    }

    @TSBDDStepDef('Results table row 1 should display correct mmte data')
    async verifyResultsTableRow1Data(): Promise<void> {
        await this.mmteHistoryPage.verifyResultsTableHasData();
    }

    @TSBDDStepDef('Edit button should be present in Action column')
    async verifyEditButtonInActionColumn(): Promise<void> {
        await this.mmteHistoryPage.verifyEditButtonInActionColumn(1);
    }

    @TSBDDStepDef('Remove button should be present in Action column')
    async verifyRemoveButtonInActionColumn(): Promise<void> {
        await this.mmteHistoryPage.verifyRemoveButtonInActionColumn(1);
    }

    @TSBDDStepDef('Update Ffx button should be displayed')
    async verifyUpdateFfxButtonDisplayed(): Promise<void> {
        await this.mmteHistoryPage.verifyUpdateFfxButtonDisplayed();
    }

    @TSBDDStepDef('I click Scattered Mmte Name link in results table row 1')
    async clickRefMmteNameLinkInResultsRow1(): Promise<void> {
        await this.mmteHistoryPage.clickMmteNameLinkInResultsRow(1);
    }

    @TSBDDStepDef('Mmte percentage should display the newly added mmte')
    async verifyMmtePercentageDisplaysNewlyAddedMmte(): Promise<void> {
        Tsreporter.info('Verifying Mmte percentage displays the newly added mmte');
        const mmteValue = await this.scatteredMmteDetailsPage.getMmtePercentValue();
        if (mmteValue === 'N/A' || mmteValue === '') {
            throw new Error('Mmte percentage still shows N/A after adding a mmte');
        }
        Tsreporter.pass(`Mmte percentage displays: ${mmteValue}`);
    }

    // ===================================================================
    // MR05 - COPY: TEST DATA PREPARATION & STEPS
    // ===================================================================

    @TSBDDStepDef('I resolve eeeee mmte copy test data {string} {string} {string}')
    async resolveEeeeeMmteCopyTestData(dynamicFvvvvv: string, cumulativeMmteName: string, scatteredMmteName: string): Promise<void> {
        Tsreporter.info('Resolving eeeee mmte copy test data');
        let resolvedCumulativeMmte = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);
        let resolvedRefMmteName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);

        if (dynamicFvvvvv === 'Yes' || !resolvedRefMmteName || resolvedRefMmteName === '') {
            Tsreporter.info('Dynamic fvvvvv - fetching random eeeee mmte for copy from database');
            const mmteForCopy = await TTTFEeeeeMmteDatabaseHelper.getRandomEeeeeMmteForCopy();
            resolvedRefMmteName = mmteForCopy.scatteredMmteName;
            resolvedCumulativeMmte = mmteForCopy.cumulativeMmteName;
        }

        this.scenarioContext.setVariable('ExistingReferencMmte', resolvedRefMmteName);
        this.scenarioContext.setVariable('CumulativeMmteName', resolvedCumulativeMmte);
        Tsreporter.pass(`Resolved copy test data: refMmte=${resolvedRefMmteName}, cumulativeMmte=${resolvedCumulativeMmte}`);
    }

    @TSBDDStepDef('I click eeeee mmte name link {string} in table')
    async clickEeeeeMmteNameLinkInTable(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        await this.eeeeeMmtesPage.clickEeeeeMmteNameLink(resolvedName);
    }

    @TSBDDStepDef('Scattered Mmte Name on details page should match {string}')
    async verifyRefMmteNameOnDetailsPageMatches(expectedName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(expectedName, this.scenarioContext);
        await this.scatteredMmteDetailsPage.verifyScatteredMmteName(resolvedName);
    }

    @TSBDDStepDef('Copy button should be present and enabled on details page')
    async verifyCopyButtonPresentAndEnabled(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyCopyButtonEnabled();
    }

    // NOTE: 'I click Copy button on details page' is defined in tttf-scattered-mmtes.steps.ts (circle 1376)

    @TSBDDStepDef('Cumulative Scattered on Add form should show {string}')
    async verifyCumulativeScatteredOnAddFormShows(expectedValue: string): Promise<void> {
        const resolvedValue = CSValueResolver.resolve(expectedValue, this.scenarioContext);
        await this.addScatteredMmtePage.verifyCumulativeScatteredSelected(resolvedValue);
    }

    @TSBDDStepDef('I get new eeeee mmte name for copy from database for cumulative mmte {string}')
    async getNewEeeeeMmteNameForCopy(cumulativeMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(cumulativeMmteName, this.scenarioContext);
        Tsreporter.info(`Getting new eeeee mmte name for copy for cumulative mmte: ${resolvedName}`);
        const newName = await TTTFEeeeeMmteDatabaseHelper.getNewEeeeeMmteNameForCopy(resolvedName);
        this.scenarioContext.setVariable('dbNewReferencMmteName', newName);
        this.scenarioContext.setVariable('NewReferencMmteName', newName);
        Tsreporter.pass(`New eeeee mmte name for copy: ${newName}`);
    }

    @TSBDDStepDef('New Scattered Mmte Name value should match scenario context')
    async verifyNewRefMmteNameMatchesScenarioContext(): Promise<void> {
        const expectedName = this.scenarioContext.getVariable<string>('NewReferencMmteName');
        if (!expectedName) {
            throw new Error('No NewReferencMmteName found in scenario context');
        }
        await this.scatteredMmteDetailsPage.verifyScatteredMmteName(expectedName);
    }

    // ===================================================================
    // MR06 - EXPORT: EEEEE MMTES LIST STEPS
    // ===================================================================

    @TSBDDStepDef('I get all eeeee scattered mmtes for export from database')
    async getAllEeeeeMmtesForExportFromDB(): Promise<void> {
        Tsreporter.info('Getting all eeeee scattered mmtes for export from database');
        const mmtes = await TTTFEeeeeMmteDatabaseHelper.getAllEeeeeMmtesForExport();
        this.scenarioContext.setVariable('dbEeeeeMmtesExport', mmtes);
        this.scenarioContext.setVariable('dbEeeeeMmtesExportCount', mmtes.length);
        Tsreporter.pass(`Retrieved ${mmtes.length} eeeee scattered mmtes for export from database`);
    }

    @TSBDDStepDef('Eeeee Mmte total items count should match database count for export')
    async verifyEeeeeMmteTotalItemsMatchDBCountForExport(): Promise<void> {
        Tsreporter.info('Verifying Eeeee Mmte total items count matches database count for export');
        const uiCount = await this.eeeeeMmtesPage.getTotalItemsCount();
        const dbCount = this.scenarioContext.getVariable<number>('dbEeeeeMmtesExportCount');
        if (uiCount !== dbCount) {
            throw new Error(`Export count mismatch. UI: ${uiCount}, DB: ${dbCount}`);
        }
        Tsreporter.pass(`Eeeee Mmte total items count matches for export: ${uiCount}`);
    }

    @TSBDDStepDef('Export button should be present and enabled on Eeeee Mmte tab')
    async verifyExportButtonOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyExportButtonEnabled();
    }

    @TSBDDStepDef('I click Export button on Eeeee Mmte tab')
    async clickExportButtonOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.clickExportButton();
    }

    @TSBDDStepDef('I should see CSV export option enabled on Eeeee Mmte tab')
    async verifyCSVExportOptionEnabledOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyCSVOptionEnabled();
    }

    @TSBDDStepDef('I should see XLSX export option enabled on Eeeee Mmte tab')
    async verifyXLSXExportOptionEnabledOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.verifyXLSXOptionEnabled();
    }

    @TSBDDStepDef('I capture latest CSV file from Downloads folder for Eeeee Mmte')
    async captureLatestCSVFileForEeeeeMmte(): Promise<void> {
        Tsreporter.info('Capturing latest CSV file from Downloads folder for Eeeee Mmte');
        const latestFile = TTTFExportHelper.findLatestDownloadedFile('csv');
        this.scenarioContext.setVariable('previousCsvFile_EeeeeMmte', latestFile ? latestFile.filePath : null);
        Tsreporter.pass('Captured latest CSV file state for Eeeee Mmte');
    }

    @TSBDDStepDef('I click CSV export option on Eeeee Mmte tab')
    async clickCSVExportOptionOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.clickExportCSV();
    }

    @TSBDDStepDef('I wait for Eeeee Mmte export to complete')
    async waitForEeeeeMmteExportToComplete(): Promise<void> {
        await this.eeeeeMmtesPage.waitForExportComplete();
    }

    @TSBDDStepDef('I should see new CSV file downloaded with prefix ScatteredMmteExport for Eeeee Mmte')
    async verifyNewCSVFileForEeeeeMmte(): Promise<void> {
        Tsreporter.info('Verifying CSV file downloaded for Eeeee Mmte');
        const previousFile = this.scenarioContext.getVariable<string>('previousCsvFile_EeeeeMmte');
        const latestFile = TTTFExportHelper.findDownloadedFileWithFrameworkTracking('csv');

        if (!latestFile) {
            throw new Error('No CSV file found after Eeeee Mmte export');
        }
        if (previousFile && latestFile.filePath === previousFile) {
            throw new Error('No new CSV file downloaded for Eeeee Mmte export');
        }
        if (!TTTFExportHelper.matchesScatteredMmteExportPattern(latestFile.fileName)) {
            throw new Error(`CSV filename does not match expected pattern: ${latestFile.fileName}`);
        }

        this.scenarioContext.setVariable('downloadedCsvFile_EeeeeMmte', latestFile.filePath);
        Tsreporter.pass(`CSV file downloaded for Eeeee Mmte: ${latestFile.fileName}`);
    }

    @TSBDDStepDef('I read exported CSV file data for Eeeee Mmte')
    async readExportedCSVFileDataForEeeeeMmte(): Promise<void> {
        Tsreporter.info('Reading exported CSV file data for Eeeee Mmte');
        const csvFilePath = this.scenarioContext.getVariable<string>('downloadedCsvFile_EeeeeMmte');
        if (!csvFilePath) {
            throw new Error('No downloaded CSV file path found for Eeeee Mmte');
        }

        const csvData = CSCsvUtility.readAsJSON(csvFilePath, { columns: true, skipEmptyCircles: true, trim: true });
        if (!csvData || csvData.length === 0) {
            throw new Error('Eeeee Mmte CSV file is empty or could not be read');
        }

        this.scenarioContext.setVariable('exportedEeeeeMmteCsvData', csvData);
        Tsreporter.pass(`Read ${csvData.length} rows from Eeeee Mmte CSV file`);
    }

    @TSBDDStepDef('exported Eeeee Mmte CSV data should match database records')
    async verifyEeeeeMmteCSVDataMatchesDB(): Promise<void> {
        Tsreporter.info('Verifying Eeeee Mmte CSV data matches database records');
        const csvData = this.scenarioContext.getVariable<any[]>('exportedEeeeeMmteCsvData');
        const dbData = this.scenarioContext.getVariable<any[]>('dbEeeeeMmtesExport');

        if (!csvData || !dbData) {
            throw new Error('CSV or DB data not found in context');
        }

        Tsreporter.info(`CSV has ${csvData.length} rows, DB has ${dbData.length} records`);
        const comparison = TTTFExportHelper.compareExportData(csvData, dbData);
        if (!comparison.isMatch) {
            const mismatchMsg = comparison.differences.slice(0, 10).join('\n');
            throw new Error(`Eeeee Mmte CSV data mismatch:\n${mismatchMsg}`);
        }
        Tsreporter.pass(`Eeeee Mmte CSV data matches database records. Verified ${csvData.length} rows.`);
    }

    @TSBDDStepDef('I capture latest XLSX file from Downloads folder for Eeeee Mmte')
    async captureLatestXLSXFileForEeeeeMmte(): Promise<void> {
        Tsreporter.info('Capturing latest XLSX file from Downloads folder for Eeeee Mmte');
        const latestFile = TTTFExportHelper.findLatestDownloadedFile('xlsx');
        this.scenarioContext.setVariable('previousXlsxFile_EeeeeMmte', latestFile ? latestFile.filePath : null);
        Tsreporter.pass('Captured latest XLSX file state for Eeeee Mmte');
    }

    @TSBDDStepDef('I click XLSX export option on Eeeee Mmte tab')
    async clickXLSXExportOptionOnEeeeeMmteTab(): Promise<void> {
        await this.eeeeeMmtesPage.clickExportXLSX();
    }

    @TSBDDStepDef('I should see new XLSX file downloaded with prefix ScatteredMmteExport for Eeeee Mmte')
    async verifyNewXLSXFileForEeeeeMmte(): Promise<void> {
        Tsreporter.info('Verifying XLSX file downloaded for Eeeee Mmte');
        const previousFile = this.scenarioContext.getVariable<string>('previousXlsxFile_EeeeeMmte');
        const latestFile = TTTFExportHelper.findDownloadedFileWithFrameworkTracking('xlsx');

        if (!latestFile) {
            throw new Error('No XLSX file found after Eeeee Mmte export');
        }
        if (previousFile && latestFile.filePath === previousFile) {
            throw new Error('No new XLSX file downloaded for Eeeee Mmte export');
        }
        if (!TTTFExportHelper.matchesScatteredMmteExportPattern(latestFile.fileName)) {
            throw new Error(`XLSX filename does not match expected pattern: ${latestFile.fileName}`);
        }

        this.scenarioContext.setVariable('downloadedXlsxFile_EeeeeMmte', latestFile.filePath);
        Tsreporter.pass(`XLSX file downloaded for Eeeee Mmte: ${latestFile.fileName}`);
    }

    @TSBDDStepDef('I read exported XLSX file data for Eeeee Mmte')
    async readExportedXLSXFileDataForEeeeeMmte(): Promise<void> {
        Tsreporter.info('Reading exported XLSX file data for Eeeee Mmte');
        const xlsxFilePath = this.scenarioContext.getVariable<string>('downloadedXlsxFile_EeeeeMmte');
        if (!xlsxFilePath) {
            throw new Error('No downloaded XLSX file path found for Eeeee Mmte');
        }

        const workbook = XLSX.readFile(xlsxFilePath);
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const xlsxData = XLSX.utils.sheet_to_json(worksheet) as any[];

        if (!xlsxData || xlsxData.length === 0) {
            throw new Error('Eeeee Mmte XLSX file is empty or could not be read');
        }

        this.scenarioContext.setVariable('exportedEeeeeMmteXlsxData', xlsxData);
        Tsreporter.pass(`Read ${xlsxData.length} rows from Eeeee Mmte XLSX file`);
    }

    @TSBDDStepDef('exported Eeeee Mmte XLSX data should match database records')
    async verifyEeeeeMmteXLSXDataMatchesDB(): Promise<void> {
        Tsreporter.info('Verifying Eeeee Mmte XLSX data matches database records');
        const xlsxData = this.scenarioContext.getVariable<any[]>('exportedEeeeeMmteXlsxData');
        const dbData = this.scenarioContext.getVariable<any[]>('dbEeeeeMmtesExport');

        if (!xlsxData || !dbData) {
            throw new Error('XLSX or DB data not found in context');
        }

        Tsreporter.info(`XLSX has ${xlsxData.length} rows, DB has ${dbData.length} records`);
        const comparison = TTTFExportHelper.compareExportData(xlsxData, dbData);
        if (!comparison.isMatch) {
            const mismatchMsg = comparison.differences.slice(0, 10).join('\n');
            throw new Error(`Eeeee Mmte XLSX data mismatch:\n${mismatchMsg}`);
        }
        Tsreporter.pass(`Eeeee Mmte XLSX data matches database records. Verified ${xlsxData.length} rows.`);
    }

    // ===================================================================
    // MR07 - EXPORT ASSOCIATED ZEALS: STEPS
    // ===================================================================

    @TSBDDStepDef('I get associated zeals from database for eeeee mmte {string}')
    async getAssociatedZealsFromDB(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        Tsreporter.info(`Getting associated zeals from database for: ${resolvedName}`);
        const zeals = await TTTFEeeeeMmteDatabaseHelper.getEeeeeMmteAssociatedZeals(resolvedName);
        this.scenarioContext.setVariable('dbAssociatedZeals', zeals);
        this.scenarioContext.setVariable('dbAssociatedZealsCount', zeals.length);
        Tsreporter.pass(`Retrieved ${zeals.length} associated zeals from database for: ${resolvedName}`);
    }

    @TSBDDStepDef('Associated Zeal Premisis total items count should match database count')
    async verifyAssociatedZealPremisisTotalMatchesDB(): Promise<void> {
        Tsreporter.info('Verifying Associated Zeal Premisis total items count matches database');
        const uiCount = await this.scatteredMmteDetailsPage.getAssociatedZealPremisisTotalCount();
        const dbCount = this.scenarioContext.getVariable<number>('dbAssociatedZealsCount');
        if (uiCount !== dbCount) {
            throw new Error(`Associated Zeal Premisis count mismatch. UI: ${uiCount}, DB: ${dbCount}`);
        }
        Tsreporter.pass(`Associated Zeal Premisis total items count matches: ${uiCount}`);
    }

    @TSBDDStepDef('Export button should be present and enabled on details page')
    async verifyExportButtonOnDetailsPage(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyExportButtonEnabled();
    }

    // NOTE: 'I click Export button on details page' is defined in tttf-scattered-mmtes.steps.ts (circle 1596)

    @TSBDDStepDef('I should see CSV export option enabled on details page')
    async verifyCSVExportOptionEnabledOnDetailsPage(): Promise<void> {
        // verifyExportOptionsPresent() verifies both CSV and XLSX are visible
        await this.scatteredMmteDetailsPage.verifyExportOptionsPresent();
    }

    @TSBDDStepDef('I should see XLSX export option enabled on details page')
    async verifyXLSXExportOptionEnabledOnDetailsPage(): Promise<void> {
        // Already verified by verifyExportOptionsPresent() in the CSV step above
        // Both steps are called sequentially in the feature file
        await this.scatteredMmteDetailsPage.verifyExportOptionsPresent();
    }

    @TSBDDStepDef('I capture latest CSV file from Downloads folder for Associated Zeals')
    async captureLatestCSVFileForAssociatedZeals(): Promise<void> {
        Tsreporter.info('Capturing latest CSV file for Associated Zeals');
        const latestFile = TTTFExportHelper.findLatestDownloadedFile('csv');
        this.scenarioContext.setVariable('previousCsvFile', latestFile ? latestFile.filePath : null);
        Tsreporter.pass('Captured latest CSV file state for Associated Zeals');
    }

    @TSBDDStepDef('I click CSV export option on details page')
    async clickCSVExportOptionOnDetailsPage(): Promise<void> {
        await this.scatteredMmteDetailsPage.clickExportCSV();
    }

    @TSBDDStepDef('I wait for Associated Zeals export to complete')
    async waitForAssociatedZealsExportComplete(): Promise<void> {
        await this.scatteredMmteDetailsPage.waitForExportComplete();
    }

    // NOTE: 'I should see new CSV file downloaded with prefix ScatteredMmteDetailsExport' is defined in tttf-scattered-mmtes.steps.ts (circle 1222)
    // It reads from 'previousCsvFile' and sets 'downloadedCsvFile'

    @TSBDDStepDef('I read exported Associated Zeals CSV file data')
    async readExportedAssociatedZealsCSVData(): Promise<void> {
        Tsreporter.info('Reading exported Associated Zeals CSV file data');
        const csvFilePath = this.scenarioContext.getVariable<string>('downloadedCsvFile');
        if (!csvFilePath) {
            throw new Error('No downloaded CSV file path for Associated Zeals');
        }
        const csvData = CSCsvUtility.readAsJSON(csvFilePath, { columns: true, skipEmptyCircles: true, trim: true });
        if (!csvData || csvData.length === 0) {
            throw new Error('Associated Zeals CSV file is empty');
        }
        this.scenarioContext.setVariable('exportedAssocZealsCsvData', csvData);
        Tsreporter.pass(`Read ${csvData.length} rows from Associated Zeals CSV file`);
    }

    @TSBDDStepDef('exported Associated Zeals CSV data should match database records')
    async verifyAssociatedZealsCSVDataMatchesDB(): Promise<void> {
        Tsreporter.info('Verifying Associated Zeals CSV data matches database');
        const csvData = this.scenarioContext.getVariable<any[]>('exportedAssocZealsCsvData');
        const dbData = this.scenarioContext.getVariable<any[]>('dbAssociatedZeals');

        if (!csvData || !dbData) {
            throw new Error('CSV or DB data not found');
        }

        Tsreporter.info(`CSV has ${csvData.length} rows, DB has ${dbData.length} records`);
        const comparison = TTTFExportHelper.compareExportData(csvData, dbData);
        if (!comparison.isMatch) {
            const mismatchMsg = comparison.differences.slice(0, 10).join('\n');
            throw new Error(`Associated Zeals CSV mismatch:\n${mismatchMsg}`);
        }
        Tsreporter.pass(`Associated Zeals CSV data matches database. Verified ${csvData.length} rows.`);
    }

    @TSBDDStepDef('I capture latest XLSX file from Downloads folder for Associated Zeals')
    async captureLatestXLSXFileForAssociatedZeals(): Promise<void> {
        Tsreporter.info('Capturing latest XLSX file for Associated Zeals');
        const latestFile = TTTFExportHelper.findLatestDownloadedFile('xlsx');
        this.scenarioContext.setVariable('previousXlsxFile', latestFile ? latestFile.filePath : null);
        Tsreporter.pass('Captured latest XLSX file state for Associated Zeals');
    }

    @TSBDDStepDef('I click XLSX export option on details page')
    async clickXLSXExportOptionOnDetailsPage(): Promise<void> {
        await this.scatteredMmteDetailsPage.clickExportXLSX();
    }

    // NOTE: 'I should see new XLSX file downloaded with prefix ScatteredMmteDetailsExport' is defined in tttf-scattered-mmtes.steps.ts (circle 1262)
    // It reads from 'previousXlsxFile' and sets 'downloadedXlsxFile'

    @TSBDDStepDef('I read exported Associated Zeals XLSX file data')
    async readExportedAssociatedZealsXLSXData(): Promise<void> {
        Tsreporter.info('Reading exported Associated Zeals XLSX file data');
        const xlsxFilePath = this.scenarioContext.getVariable<string>('downloadedXlsxFile');
        if (!xlsxFilePath) {
            throw new Error('No downloaded XLSX file path for Associated Zeals');
        }
        const workbook = XLSX.readFile(xlsxFilePath);
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const xlsxData = XLSX.utils.sheet_to_json(worksheet) as any[];

        if (!xlsxData || xlsxData.length === 0) {
            throw new Error('Associated Zeals XLSX file is empty');
        }
        this.scenarioContext.setVariable('exportedAssocZealsXlsxData', xlsxData);
        Tsreporter.pass(`Read ${xlsxData.length} rows from Associated Zeals XLSX file`);
    }

    @TSBDDStepDef('exported Associated Zeals XLSX data should match database records')
    async verifyAssociatedZealsXLSXDataMatchesDB(): Promise<void> {
        Tsreporter.info('Verifying Associated Zeals XLSX data matches database');
        const xlsxData = this.scenarioContext.getVariable<any[]>('exportedAssocZealsXlsxData');
        const dbData = this.scenarioContext.getVariable<any[]>('dbAssociatedZeals');

        if (!xlsxData || !dbData) {
            throw new Error('XLSX or DB data not found');
        }

        Tsreporter.info(`XLSX has ${xlsxData.length} rows, DB has ${dbData.length} records`);
        const comparison = TTTFExportHelper.compareExportData(xlsxData, dbData);
        if (!comparison.isMatch) {
            const mismatchMsg = comparison.differences.slice(0, 10).join('\n');
            throw new Error(`Associated Zeals XLSX mismatch:\n${mismatchMsg}`);
        }
        Tsreporter.pass(`Associated Zeals XLSX data matches database. Verified ${xlsxData.length} rows.`);
    }

    // ===================================================================
    // MR08 - NAVIGATION: STEPS
    // ===================================================================

    @TSBDDStepDef('I capture Associated Zeal Premisis rust row data')
    async captureAssociatedZealPremisisRustRowData(): Promise<void> {
        Tsreporter.info('Capturing Associated Zeal Premisis rust row data');
        const rowData: Record<string, string> = {};

        for (let col = 1; col <= 7; col++) {
            const value = await this.scatteredMmteDetailsPage.getAssociatedZealPremisisTableCellValue(1, col);
            const colNames = ['type', 'zealId', 'zealKey', 'zealName', 'inductorGroup', 'zzztSeggregation', 'scattereddMmtes'];
            rowData[colNames[col - 1]] = value;
        }

        this.scenarioContext.setVariable('capturedAssociatedZealRow1', rowData);
        Tsreporter.pass(`Captured Associated Zeal Premisis rust row: ${JSON.stringify(rowData)}`);
    }

    @TSBDDStepDef('I click Zeal Key link in Associated Zeal Premisis row {int}')
    async clickZealKeyLinkInAssociatedZealPremisisRow(rowNum: number): Promise<void> {
        await this.scatteredMmteDetailsPage.clickZealKeyLink(rowNum);
    }

    @TSBDDStepDef('Edit button should be present and enabled on Zeal Details')
    async verifyEditButtonOnZealDetails(): Promise<void> {
        await this.zealDetailsPage.verifyEditButtonEnabled();
    }

    @TSBDDStepDef('Details tab should be present and selected by default on Zeal Details')
    async verifyDetailsTabOnZealDetails(): Promise<void> {
        await this.zealDetailsPage.verifyDetailsTabSelected();
    }

    @TSBDDStepDef('Scattered Mmte Name {string} should be listed under Associated Scattered Mmtes')
    async verifyRefMmteNameUnderAssociatedRefMmtes(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        await this.zealDetailsPage.verifyScatteredMmteInAssociatedSection(resolvedName);
    }

    @TSBDDStepDef('I click scattered mmte name link {string} on Zeal Details')
    async clickRefMmteNameLinkOnZealDetails(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        await this.zealDetailsPage.clickScatteredMmteLinkInAssociatedSection(resolvedName);
    }

    @TSBDDStepDef('Scattered Mmte Details popup should be displayed')
    async verifyRefMmteDetailsPopupDisplayed(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyPopupDisplayed();
    }

    @TSBDDStepDef('Scattered Mmte Details popup header should be displayed')
    async verifyRefMmteDetailsPopupHeader(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyPopupHeaderDisplayed();
    }

    @TSBDDStepDef('Copy button should be present on popup')
    async verifyCopyButtonOnPopup(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyPopupCopyButtonEnabled();
    }

    @TSBDDStepDef('Scattered Mmte Name {string} should be displayed on popup')
    async verifyRefMmteNameOnPopup(scatteredMmteName: string): Promise<void> {
        const resolvedName = CSValueResolver.resolve(scatteredMmteName, this.scenarioContext);
        await this.scatteredMmteDetailsPage.verifyPopupScatteredMmteNameMatches(resolvedName);
    }

    @TSBDDStepDef('Close button should be present on popup')
    async verifyCloseButtonOnPopup(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyPopupCloseButtonEnabled();
    }

    @TSBDDStepDef('View All Details button should be present on popup')
    async verifyViewAllDetailsButtonOnPopup(): Promise<void> {
        await this.scatteredMmteDetailsPage.verifyPopupViewAllDetailsButtonEnabled();
    }

    @TSBDDStepDef('I click View All Details button on popup')
    async clickViewAllDetailsButtonOnPopup(): Promise<void> {
        await this.scatteredMmteDetailsPage.clickPopupViewAllDetailsButton();
    }
}
