/**
 * TTTF Eeeee Scattered Mmte Database Helper
 *
 * Encapsulates all database operations for TTTF Eeeee Scattered Mmte modules:
 * - Eeeee Scattered Mmte Search (MR01)
 * - Eeeee Scattered Mmte Filter (MR02)
 * - Eeeee Scattered Mmte Create (MR04)
 * - Eeeee Scattered Mmte Copy (MR05)
 * - Eeeee Scattered Mmte Export (MR06)
 * - Eeeee Scattered Mmte Associated Zeals (MR07, MR08)
 *
 * All queries are defined in: config/tttf/common/tttf-eeeee-scattered-mmtes-db-queries.env
 * All queries are prefixed with DB_QUERY_ in the env files.
 * CSDBUtils automatically resolves query names without the prefix.
 *
 * Usage: Call these methods from step definitions to perform database operations
 * without exposing SQL queries or database details in feature files.
 */

import { CSDBUtils } from '@mdakhan.mak/cs-playwright-test-framework/database-utils';
import { Tsreporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

// ==============================================================================
// EEEEE SCATTERED MMTE INTERFACES
// ==============================================================================

export interface EeeeeMmteDetails {
    scatteredMmteName: string;
    cumulativeMmteName: string;
}

export interface EeeeeMmteBasicDetails {
    cumulativeMmteName: string;
    scatteredMmteName: string;
    methodologyType: string;
    sportMmteWhoolPriorityType: string;
    primaryTtcalcType: string;
    roundingType: string;
    roundingNearestFractionAmt: string;
    isWhoolsEeeee: string;
}

export interface EeeeeMmteCalcDetail {
    scatteredMmteName: string;
    sportMmteDeterminationDate: string;
    ffxDate: string;
    cycleDate: string;
    mmte: string;
    mmteDt: string;
}

export interface EeeeeMmteAssociatedZeal {
    type: string;
    zealId: string;
    zealKey: string;
    zealName: string;
    inductorGroup: string;
    zzztSeggregation: string;
    scattereddMmtes: number;
}

export interface EeeeeMmteExportRecord {
    scatteredMmteName: string;
    cumulativeMmteName: string;
    wwwwwVvvvv: string;
    baseDay: string;
    associatedCylinders: string;
    nnnnnBase: string;
    mirchiaryNnnnnBaseDay: string;
    hookwithDays: string;
    hookwithCylinders: string;
    wwwwwVvvvvSR: string;
    baseDaySR: string;
    associatedCylindersSR: string;
    nnnnnBaseSR: string;
    mirchiaryNnnnnBaseDaySR: string;
    hookwithDaysSR: string;
    hookwithCylindersSR: string;
    roundingType: string;
    roundingFactor: string;
    whoolPriority: string;
    associatedZealPremisis: string;
}

export class TTTFEeeeeMmteDatabaseHelper {
    private static readonly DB_ALIAS = 'TTTF_ORACLE';

    // ===================================================================
    // MR01 - SEARCH METHODS
    // ===================================================================

    /**
     * Get random eeeee scattered mmte name from database for test data setup (MR01)
     * Query: DB_QUERY_GET_RANDOM_EEEEE_SCATTERED_MMTE
     * Returns a random eeeee scattered mmte name that has associated zeals
     */
    public static async getRandomEeeeeScatteredMmteName(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_RANDOM_EEEEE_SCATTERED_MMTE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No eeeee scattered mmte names found in database');
        }

        const mmteName = result.rows[0].scattered_mmte_name || result.rows[0].SCATTERED_MMTE_NAME;
        Tsreporter.debug(`Retrieved random eeeee scattered mmte name: ${mmteName}`);
        return mmteName;
    }

    /**
     * Get eeeee mmte details by scattered mmte name for search verification (MR01)
     * Query: DB_QUERY_GET_EEEEE_MMTE_DETAILS_BY_NAME
     * @param scatteredMmteName - The scattered mmte name to search
     * @returns Object with scatteredMmteName and cumulativeMmteName, or null if not found
     */
    public static async getEeeeeMmteDetailsByName(scatteredMmteName: string): Promise<EeeeeMmteDetails | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EEEEE_MMTE_DETAILS_BY_NAME',
            [scatteredMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            Tsreporter.warn(`No eeeee mmte details found for: ${scatteredMmteName}`);
            return null;
        }

        const row = result.rows[0];
        const details: EeeeeMmteDetails = {
            scatteredMmteName: row.scattered_mmte_name || row.SCATTERED_MMTE_NAME || '',
            cumulativeMmteName: row.cumulative_mmte_name || row.CUMULATIVE_MMTE_NAME || ''
        };

        Tsreporter.debug(`Retrieved eeeee mmte details for ${scatteredMmteName}: cumulativeMmte=${details.cumulativeMmteName}`);
        return details;
    }

    // ===================================================================
    // MR02 - FILTER METHODS
    // ===================================================================

    /**
     * Get all active cumulative mmte names for dropdown verification (MR02)
     * Query: DB_QUERY_GET_ALL_ACTIVE_CUMULATIVE_MMTES
     * Returns array of cumulative mmte name strings ordered by index
     */
    public static async getAllActiveCumulativeMmteNames(): Promise<string[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ALL_ACTIVE_CUMULATIVE_MMTES'
        );

        if (!result.rows || result.rows.length === 0) {
            Tsreporter.warn('No active cumulative mmte names found in database');
            return [];
        }

        const names = result.rows.map((row: any) => row.cumulative_mmte_name || row.CUMULATIVE_MMTE_NAME);
        Tsreporter.debug(`Retrieved ${names.length} active cumulative mmte names`);
        return names;
    }

    /**
     * Get random active cumulative mmte that has eeeee scattered mmtes (MR02)
     * Query: DB_QUERY_GET_RANDOM_CUMULATIVE_MMTE_WITH_EEEEE_MMTES
     * Returns an cumulative mmte name that has at least one eeeee scattered mmte associated
     */
    public static async getRandomCumulativeMmteWithEeeeeMmtes(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_RANDOM_CUMULATIVE_MMTE_WITH_EEEEE_MMTES'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No active cumulative mmte with eeeee scattered mmtes found in database');
        }

        const mmteName = result.rows[0].cumulative_mmte_name || result.rows[0].CUMULATIVE_MMTE_NAME;
        Tsreporter.debug(`Retrieved random cumulative mmte with eeeee mmtes: ${mmteName}`);
        return mmteName;
    }

    /**
     * Get eeeee mmtes filtered by cumulative mmte name (MR02)
     * Query: DB_QUERY_GET_EEEEE_MMTES_BY_CUMULATIVE_MMTE
     * @param cumulativeMmteName - The cumulative mmte name to filter by
     * @returns Array of eeeee mmte details matching the filter
     */
    public static async getEeeeeMmtesByCumulativeMmte(cumulativeMmteName: string): Promise<EeeeeMmteDetails[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EEEEE_MMTES_BY_CUMULATIVE_MMTE',
            [cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            Tsreporter.warn(`No eeeee mmtes found for cumulative mmte: ${cumulativeMmteName}`);
            return [];
        }

        const mmtes = result.rows.map((row: any) => ({
            scatteredMmteName: row.scattered_mmte_name || row.SCATTERED_MMTE_NAME || '',
            cumulativeMmteName: row.cumulative_mmte_name || row.CUMULATIVE_MMTE_NAME || ''
        }));

        Tsreporter.debug(`Retrieved ${mmtes.length} eeeee mmtes for cumulative mmte: ${cumulativeMmteName}`);
        return mmtes;
    }

    // ===================================================================
    // MR04 - CREATE METHODS
    // ===================================================================

    /**
     * Get random active cumulative mmte for create test data (MR04)
     * Query: DB_QUERY_GET_RANDOM_ACTIVE_CUMULATIVE_MMTE
     * Returns a random active cumulative mmte name
     */
    public static async getRandomActiveCumulativeMmte(): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_RANDOM_ACTIVE_CUMULATIVE_MMTE'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No active cumulative mmtes found in database');
        }

        const mmteName = result.rows[0].cumulative_mmte_name || result.rows[0].CUMULATIVE_MMTE_NAME;
        Tsreporter.debug(`Retrieved random active cumulative mmte: ${mmteName}`);
        return mmteName;
    }

    /**
     * Get auto-genemmted new scattered mmte name (MR04)
     * Query: DB_QUERY_GET_NEW_EEEEE_SCATTERED_MMTE_NAME
     * Uses cumulative mmte prefix + padded sequence number from latest scattered mmte
     * @param cumulativeMmteName - The cumulative mmte name to genemmte new scattered mmte name for
     * @returns The auto-genemmted new scattered mmte name
     */
    public static async getNewEeeeeScatteredMmteName(cumulativeMmteName: string): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_NEW_EEEEE_SCATTERED_MMTE_NAME',
            [cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error(`Could not genemmte new eeeee scattered mmte name for cumulative mmte: ${cumulativeMmteName}`);
        }

        const newName = result.rows[0].new_scattered_mmte_name || result.rows[0].NEW_SCATTERED_MMTE_NAME;
        Tsreporter.debug(`Genemmted new eeeee scattered mmte name: ${newName} for cumulative mmte: ${cumulativeMmteName}`);
        return newName;
    }

    /**
     * Verify scattered mmte basic details after creation (MR04, MR05)
     * Query: DB_QUERY_GET_EEEEE_MMTE_BASIC_DETAILS
     * @param scatteredMmteName - The scattered mmte name to verify
     * @returns Object with all basic detail fields, or null if not found
     */
    public static async getEeeeeMmteBasicDetails(scatteredMmteName: string): Promise<EeeeeMmteBasicDetails | null> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EEEEE_MMTE_BASIC_DETAILS',
            [scatteredMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            Tsreporter.warn(`No eeeee mmte basic details found for: ${scatteredMmteName}`);
            return null;
        }

        const row = result.rows[0];
        const details: EeeeeMmteBasicDetails = {
            cumulativeMmteName: row.cumulative_mmte_name || row.CUMULATIVE_MMTE_NAME || '',
            scatteredMmteName: row.scattered_mmte_name || row.SCATTERED_MMTE_NAME || '',
            methodologyType: row.methodology_type || row.METHODOLOGY_TYPE || '',
            sportMmteWhoolPriorityType: row.sport_mmte_whool_priority_type || row.SPORT_MMTE_WHOOL_PRIORITY_TYPE || '',
            primaryTtcalcType: row.primary_ttcalc_type || row.PRIMARY_TTCALC_TYPE || '',
            roundingType: row.rounding_type || row.ROUNDING_TYPE || '',
            roundingNearestFractionAmt: String(row.rounding_nearest_fraction_amt || row.ROUNDING_NEAREST_FRACTION_AMT || ''),
            isWhoolsEeeee: row.is_whools_eeeee || row.IS_WHOOLS_EEEEE || ''
        };

        Tsreporter.debug(`Retrieved eeeee mmte basic details for ${scatteredMmteName}: methodology=${details.methodologyType}, cumulativeMmte=${details.cumulativeMmteName}`);
        return details;
    }

    /**
     * Get scattered mmte whool count (MR04, MR05) - should be 0 for eeeee mmtes
     * Query: DB_QUERY_GET_EEEEE_MMTE_WHOOL_COUNT
     * @param scatteredMmteName - The scattered mmte name to check
     * @returns The count of scattered mmte whools
     */
    public static async getEeeeeMmteWhoolCount(scatteredMmteName: string): Promise<number> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EEEEE_MMTE_WHOOL_COUNT',
            [scatteredMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            Tsreporter.debug(`No whool count result for: ${scatteredMmteName}, returning 0`);
            return 0;
        }

        const count = parseInt(result.rows[0].count || result.rows[0].COUNT || '0');
        Tsreporter.debug(`Eeeee mmte whool count for ${scatteredMmteName}: ${count}`);
        return count;
    }

    /**
     * Get scattered mmte calc details (MR04)
     * Query: DB_QUERY_GET_EEEEE_MMTE_CALC_DETAILS
     * @param scatteredMmteName - The scattered mmte name to get calc details for
     * @returns Array of calc detail records
     */
    public static async getEeeeeMmteCalcDetails(scatteredMmteName: string): Promise<EeeeeMmteCalcDetail[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EEEEE_MMTE_CALC_DETAILS',
            [scatteredMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            Tsreporter.warn(`No eeeee mmte calc details found for: ${scatteredMmteName}`);
            return [];
        }

        const details = result.rows.map((row: any) => ({
            scatteredMmteName: row.scattered_mmte_name || row.SCATTERED_MMTE_NAME || '',
            sportMmteDeterminationDate: row.sport_mmte_determination_date || row.SPORT_MMTE_DETERMINATION_DATE || '',
            ffxDate: row.ffx_date || row.FFX_DATE || '',
            cycleDate: row.cycle_date || row.CYCLE_DATE || '',
            mmte: String(row.mmte || row.MMTE || ''),
            mmteDt: row.mmte_dt || row.MMTE_DT || ''
        }));

        Tsreporter.debug(`Retrieved ${details.length} eeeee mmte calc details for: ${scatteredMmteName}`);
        return details;
    }

    // ===================================================================
    // MR05 - COPY METHODS
    // ===================================================================

    /**
     * Get random existing eeeee scattered mmte for copy (MR05)
     * Query: DB_QUERY_GET_RANDOM_EEEEE_MMTE_FOR_COPY
     * Returns a random eeeee scattered mmte with associated zeals for copy testing
     */
    public static async getRandomEeeeeMmteForCopy(): Promise<EeeeeMmteDetails> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_RANDOM_EEEEE_MMTE_FOR_COPY'
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error('No eeeee scattered mmte available for copy');
        }

        const row = result.rows[0];
        const details: EeeeeMmteDetails = {
            scatteredMmteName: row.scattered_mmte_name || row.SCATTERED_MMTE_NAME || '',
            cumulativeMmteName: row.cumulative_mmte_name || row.CUMULATIVE_MMTE_NAME || ''
        };

        Tsreporter.debug(`Retrieved eeeee mmte for copy: ${details.scatteredMmteName} (cumulative: ${details.cumulativeMmteName})`);
        return details;
    }

    /**
     * Get auto-genemmted new scattered mmte name for copy (MR05) - includes +1
     * Query: DB_QUERY_GET_NEW_EEEEE_MMTE_NAME_FOR_COPY
     * Note: This query adds +1 to the sequence number (different from MR04 create)
     * @param cumulativeMmteName - The cumulative mmte name to genemmte copy name for
     * @returns The auto-genemmted new scattered mmte name for copy
     */
    public static async getNewEeeeeMmteNameForCopy(cumulativeMmteName: string): Promise<string> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_NEW_EEEEE_MMTE_NAME_FOR_COPY',
            [cumulativeMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            throw new Error(`Could not genemmte new eeeee mmte name for copy with cumulative mmte: ${cumulativeMmteName}`);
        }

        const newName = result.rows[0].new_scattered_mmte_name || result.rows[0].NEW_SCATTERED_MMTE_NAME;
        Tsreporter.debug(`Genemmted new eeeee mmte name for copy: ${newName} for cumulative mmte: ${cumulativeMmteName}`);
        return newName;
    }

    // ===================================================================
    // MR06 - EXPORT METHODS
    // ===================================================================

    /**
     * Column names for eeeee mmte export (matches the SQL query column aliases)
     * Used for export verification comparisons
     */
    public static readonly EeeeeMmteExportColumns = [
        'Scattered Mmte Name', 'Cumulative Mmte Name', 'Wwwww Vvvvv', 'Base Day',
        'Associated Cylinders', 'Nnnnn Base', 'Mirchiary Nnnnn Base Day',
        'Hookwith Days', 'Hookwith Cylinders', 'Wwwww Vvvvv (SR)', 'Base Day (SR)',
        'Associated Cylinders(SR)', 'Nnnnn Base (SR)', 'Mirchiary Nnnnn Base Day (SR)',
        'Hookwith Days (SR)', 'Hookwith Cylinders (SR)', 'Rounding Type',
        'Rounding Factor', 'Whool Priority', 'Associated Zeal/Premisis'
    ];

    /**
     * Get all eeeee scattered mmtes for export verification (MR06)
     * Query: DB_QUERY_GET_ALL_EEEEE_MMTES_FOR_EXPORT
     * Returns all eeeee mmtes with all 20 export columns mapped to camelCase
     */
    public static async getAllEeeeeMmtesForExport(): Promise<EeeeeMmteExportRecord[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_ALL_EEEEE_MMTES_FOR_EXPORT'
        );

        if (!result.rows || result.rows.length === 0) {
            Tsreporter.warn('No eeeee scattered mmtes found for export');
            return [];
        }

        const records = result.rows.map((row: any) => ({
            scatteredMmteName: row['Scattered Mmte Name'] || row.scattered_mmte_name || '',
            cumulativeMmteName: row['Cumulative Mmte Name'] || row.cumulative_mmte_name || '',
            wwwwwVvvvv: String(row['Wwwww Vvvvv'] || row.wwwww_vvvvv || '0'),
            baseDay: String(row['Base Day'] || row.base_day || '0'),
            associatedCylinders: row['Associated Cylinders'] || row.associated_cylinders || '',
            nnnnnBase: row['Nnnnn Base'] || row.nnnnn_base || '',
            mirchiaryNnnnnBaseDay: row['Mirchiary Nnnnn Base Day'] || row.mirchiary_nnnnn_base_day || '',
            hookwithDays: row['Hookwith Days'] || row.hookwith_days || '',
            hookwithCylinders: row['Hookwith Cylinders'] || row.hookwith_cylinders || '',
            wwwwwVvvvvSR: String(row['Wwwww Vvvvv (SR)'] || row.wwwww_vvvvv_sr || '0'),
            baseDaySR: String(row['Base Day (SR)'] || row.base_day_sr || '0'),
            associatedCylindersSR: row['Associated Cylinders(SR)'] || row.associated_cylinders_sr || '',
            nnnnnBaseSR: row['Nnnnn Base (SR)'] || row.nnnnn_base_sr || '',
            mirchiaryNnnnnBaseDaySR: row['Mirchiary Nnnnn Base Day (SR)'] || row.mirchiary_nnnnn_base_day_sr || '',
            hookwithDaysSR: row['Hookwith Days (SR)'] || row.hookwith_days_sr || '',
            hookwithCylindersSR: row['Hookwith Cylinders (SR)'] || row.hookwith_cylinders_sr || '',
            roundingType: row['Rounding Type'] || row.rounding_type || '',
            roundingFactor: row['Rounding Factor'] || row.rounding_factor || '',
            whoolPriority: row['Whool Priority'] || row.whool_priority || '',
            associatedZealPremisis: String(row['Associated Zeal/Premisis'] || row.associated_zeal_premisis || '0')
        }));

        Tsreporter.debug(`Retrieved ${records.length} eeeee scattered mmtes for export`);
        return records;
    }

    /**
     * Get count of all eeeee scattered mmtes (MR06)
     * Query: DB_QUERY_GET_EEEEE_MMTE_COUNT
     * Returns total count for pagination verification
     */
    public static async getEeeeeMmteCount(): Promise<number> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EEEEE_MMTE_COUNT'
        );

        if (!result.rows || result.rows.length === 0) {
            Tsreporter.debug('No eeeee mmte count result, returning 0');
            return 0;
        }

        const count = parseInt(result.rows[0].total_count || result.rows[0].TOTAL_COUNT || '0');
        Tsreporter.debug(`Eeeee scattered mmte count: ${count}`);
        return count;
    }

    // ===================================================================
    // MR07, MR08 - ASSOCIATED ZEALS METHODS
    // ===================================================================

    /**
     * Get associated zeal/premisis for a eeeee scattered mmte (MR07, MR08)
     * Query: DB_QUERY_GET_EEEEE_MMTE_ASSOCIATED_ZEALS
     * NOTE: This query has TWO ? placeholders (UNION for zeals and premisis),
     * both should be the same scatteredMmteName
     * @param scatteredMmteName - The scattered mmte name (used for BOTH placeholders)
     * @returns Array of associated zeal/premisis records
     */
    public static async getEeeeeMmteAssociatedZeals(scatteredMmteName: string): Promise<EeeeeMmteAssociatedZeal[]> {
        const result = await CSDBUtils.executeQuery(
            this.DB_ALIAS,
            'GET_EEEEE_MMTE_ASSOCIATED_ZEALS',
            [scatteredMmteName, scatteredMmteName]
        );

        if (!result.rows || result.rows.length === 0) {
            Tsreporter.warn(`No associated zeals found for eeeee mmte: ${scatteredMmteName}`);
            return [];
        }

        const zeals = result.rows.map((row: any) => ({
            type: row['Type'] || row.type_value || row.TYPE || '',
            zealId: String(row['Zeal ID'] || row.zeal_id || row.ZEAL_ID || ''),
            zealKey: row['Zeal Key'] || row.zeal_key || row.ZEAL_KEY || '',
            zealName: row['Zeal Name'] || row.zeal_name || row.ZEAL_NAME || '',
            inductorGroup: row['Inductor Group'] || row.inductor_group || row.INDUCTOR_GROUP || '',
            zzztSeggregation: row['Zzzt Seggregation'] || row.zzzt_seggregation || row.ZZZT_SEGGREGATION || '',
            scattereddMmtes: parseInt(row['Scatteredd Mmtes'] || row.associated_mmtes || row.SCATTEREDD_MMTES || '0')
        }));

        Tsreporter.debug(`Retrieved ${zeals.length} associated zeals for eeeee mmte: ${scatteredMmteName}`);
        return zeals;
    }
}



------------------------------------------------------------------------------------------------------------


import { CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { TswebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { Tsreporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';
import { TTTFMmteTableBase, MmteTableColumnMapping } from './TTTFMmteTableBase';

/**
 * TTTF Eeeee Scattered Mmtes Page
 * Handles the Eeeee Scattered Mmtes tab on the Scattered Mmtes listing page.
 * Provides table interaction, search, filter, sort, pagination, and export functionality.
 * All XPath locators use BEM convention with double underscores for active tab pane.
 */
@CSPage('tttf-eeeee-scattered-mmtes')
export class TTTFEeeeeScatteredMmtesPage extends TTTFMmteTableBase {

    // ===================================================================
    // ABSTRACT CONFIG IMPLEMENTATIONS (from TTTFMmteTableBase)
    // ===================================================================

    protected get cylinderColumns(): number[] { return []; }
    protected get refMmteNameColumn(): number { return 1; }
    protected get tableColumnMapping(): MmteTableColumnMapping[] { return TTTFEeeeeScatteredMmtesPage.EEEEE_MMTE_COLUMNS; }
    protected get tableColumnHeaders(): string[] { return TTTFEeeeeScatteredMmtesPage.EEEEE_MMTE_HEADERS; }
    protected get usesSortableHeaderSpan(): boolean { return false; }
    protected get cylinderJoinSeparator(): string { return ','; }
    protected get filterContainerId(): string { return 'incircleFilterEeeeeRefMmte'; }

    // ===================================================================
    // EEEEE MMTE TABLE COLUMN DEFINITIONS
    // ===================================================================

    private static readonly EEEEE_MMTE_COLUMNS: MmteTableColumnMapping[] = [
        { colNum: 1, fieldName: 'scatteredMmteName', childRowName: 'Scattered Mmte Name' },
        { colNum: 2, fieldName: 'cumulativeMmteName', childRowName: 'Cumulative Mmte Name' }
    ];

    private static readonly EEEEE_MMTE_HEADERS: string[] = [
        'Scattered Mmte Name', 'Cumulative Mmte Name'
    ];

    // ===================================================================
    // TABLE ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, \'sssss-table\')]',
        description: 'Eeeee Scattered Mmtes display table',
        waitForVisible: true
    })
    public eeeeeMmteTable!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, \'sssss-table\')]//tbody/tr[1]/td[text()=\'No data available.\']',
        description: 'No data available message',
        waitForVisible: false
    })
    public noDataMessage!: TswebElement;

    // ===================================================================
    // SEARCH ELEMENTS (Find By)
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//div[contains(@class, \'sssss-find-by_container\')]//input[contains(@aria-labelledby,\'sssss-find-by\')]',
        description: 'Find by input field',
        waitForVisible: true
    })
    public findByInput!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//div[contains(@class, \'sssss-find-by_container\')]//span[@class=\'sssss-button__label\' and text()=\'Go\']/parent::button[@aria-label=\'Go search data\']',
        description: 'Go search button',
        waitForEnabled: true
    })
    public goSearchButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//div[contains(@class, \'sssss-find-by_container\')]//span[@class=\'sssss-button__label\' and text()=\'Reset\']/parent::button[@aria-label=\'Reset results and clear\']',
        description: 'Reset search button',
        waitForEnabled: true
    })
    public resetSearchButton!: TswebElement;

    // ===================================================================
    // PAGINATOR ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//div[@class=\'sssss-paginator\']//span[@class=\'sssss-paginator__trigger-total-items\']',
        description: 'Paginator total items text',
        waitForVisible: true
    })
    public paginatorTotalItems!: TswebElement;

    // ===================================================================
    // EXPORT BUTTON ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//span[@class=\'sssss-button__label\' and text()=\'Export\']/parent::button[@aria-label=\'Export\']',
        description: 'Export button',
        waitForVisible: true
    })
    public exportButton!: TswebElement;

    // ===================================================================
    // LOADER ELEMENT
    // ===================================================================

    @tsgetElement({
        xpath: '//div[text()=\'Loading...\']',
        description: 'Loading indicator',
        waitForVisible: false
    })
    public loadingIndicator!: TswebElement;

    // ===================================================================
    // FILTER ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//span[text()=\'Filters\']/ancestor::button[contains(@id,\'sssss-incircle-filter\')]',
        description: 'Filters button',
        waitForVisible: true
    })
    public filtersButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="sssss-tab__pane-content--active"]//span[text()=\'Filters Applied\']/ancestor::button[contains(@id,\'sssss-incircle-filter\')]',
        description: 'Filters Applied button (shown when filters are active)',
        waitForVisible: false
    })
    public filtersAppliedButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id=\'incircleFilterEeeeeRefMmte\']//legend[text()=\'Filter criteria\']',
        description: 'Filter criteria header',
        waitForVisible: false
    })
    public filterCriteriaHeader!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id=\'incircleFilterEeeeeRefMmte\']//button[@name=\'cumulativeMmte\']',
        description: 'Cumulative Mmte dropdown button',
        waitForVisible: false
    })
    public cumulativeMmteDropdownButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id=\'incircleFilterEeeeeRefMmte\']//button[@name=\'cumulativeMmte\']//span[@class=\'sssss-button__label\']',
        description: 'Cumulative Mmte dropdown label',
        waitForVisible: false
    })
    public cumulativeMmteDropdownLabel!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id=\'incircleFilterEeeeeRefMmte\']//span[@class=\'sssss-button__label\' and text()=\'Apply\']/parent::button[1]',
        description: 'Apply filter button',
        waitForVisible: false
    })
    public applyFilterButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id=\'incircleFilterEeeeeRefMmte\']//span[@class=\'sssss-button__label\' and text()=\'Reset Filters\']/parent::button[1]',
        description: 'Reset Filters button',
        waitForVisible: false
    })
    public resetFilterButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id=\'incircleFilterEeeeeRefMmte\']//span[@class=\'sssss-button__label\' and text()=\'Cancel\']/parent::button[1]',
        description: 'Cancel filter button',
        waitForVisible: false
    })
    public cancelFilterButton!: TswebElement;

    // ===================================================================
    // ELEMENT INITIALIZATION
    // ===================================================================

    protected initializeElements(): void {
        Tsreporter.debug('TTTFEeeeeScatteredMmtesPage elements initialized');
    }

    // ===================================================================
    // LOADER METHODS
    // ===================================================================

    /**
     * Wait for loader to disappear
     */
    public async waitForLoaderToDisappear(): Promise<void> {
        return this.baseWaitForLoaderToDisappear(this.loadingIndicator);
    }

    // ===================================================================
    // TABLE METHODS
    // ===================================================================

    /**
     * Verify Eeeee Scattered Mmtes table is present and visible
     */
    public async verifyEeeeeMmteTablePresent(): Promise<void> {
        Tsreporter.info('Verifying Eeeee Scattered Mmtes table is present');
        await this.eeeeeMmteTable.waitForVisible(15000);
        Tsreporter.pass('Eeeee Scattered Mmtes table is present');
    }

    /**
     * Check if no data available message is displayed
     * @returns true if "No data available." message is visible
     */
    public async verifyNoDataAvailable(): Promise<boolean> {
        return this.baseIsNoDataAvailable(this.noDataMessage);
    }

    /**
     * Get table cell value by row number and column number
     * @param rowNum Row number (1-based)
     * @param colNum Column number (1-based)
     * @returns Cell text content
     */
    public async getEeeeeMmteTableCellValue(rowNum: number, colNum: number): Promise<string> {
        return this.baseGetTableCellValue(rowNum, colNum);
    }

    /**
     * Get all column data for a specific row
     * @param rowNum Row number (1-based)
     * @returns Object with fieldName keys and cell value strings
     */
    public async getEeeeeMmteTableRowData(rowNum: number): Promise<Record<string, string>> {
        return this.baseGetTableRowData(rowNum);
    }

    /**
     * Get total number of visible rows (excluding child rows) in the eeeee mmte table
     * @returns Row count
     */
    public async getEeeeeMmteTableRowCount(): Promise<number> {
        return this.baseGetTableRowCount();
    }

    /**
     * Get all visible eeeee mmte table rows data keyed by scatteredMmteName
     * @returns Map with scatteredMmteName as key and row data record as value
     */
    public async getAllEeeeeMmteTableRowsData(): Promise<Map<string, Record<string, string>>> {
        const allData = await this.baseGetAllTableData();
        const allRowsData = new Map<string, Record<string, string>>();

        for (const rowData of allData) {
            const refMmteName = rowData.scatteredMmteName;
            if (refMmteName) {
                allRowsData.set(refMmteName, rowData);
            } else {
                Tsreporter.warn('Row has no scattered mmte name');
            }
        }

        Tsreporter.pass(`Captured ${allRowsData.size} rows from Eeeee Scattered Mmtes table`);
        return allRowsData;
    }

    /**
     * Click on Scattered Mmte Name link in the eeeee mmte table to navigate to details
     * @param scatteredMmteName The name of the scattered mmte to click
     */
    public async clickEeeeeMmteNameLink(scatteredMmteName: string): Promise<void> {
        Tsreporter.info(`Clicking Eeeee Mmte Name link: ${scatteredMmteName}`);
        const xpath = `//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, "sssss-table")]//tbody/tr/td[1]//span[@class='sssss-button__label' and text()='${scatteredMmteName}']/parent::a[1]`;
        const link = CSElementFactory.createByXPath(xpath, `Eeeee Mmte Name link: ${scatteredMmteName}`, this.page);
        await link.waitForVisible(10000);
        await link.clickWithTimeout(10000);
        await this.waitForPageLoad();
        Tsreporter.pass(`Clicked Eeeee Mmte Name link: ${scatteredMmteName}`);
    }

    // ===================================================================
    // SEARCH METHODS
    // ===================================================================

    /**
     * Click Reset search button to clear previous search
     */
    public async resetSearch(): Promise<void> {
        Tsreporter.info('Clicking Reset search button');
        await this.resetSearchButton.waitForVisible(10000);
        await this.resetSearchButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        Tsreporter.pass('Clicked Reset search button');
    }

    /**
     * Enter text in the Find By search input field
     * @param text Search text to enter
     */
    public async enterSearchText(text: string): Promise<void> {
        Tsreporter.info(`Entering search text: ${text}`);
        await this.findByInput.waitForVisible(10000);
        await this.findByInput.clear();
        await this.findByInput.fillWithTimeout(text, 10000);
        Tsreporter.pass(`Entered search text: ${text}`);
    }

    /**
     * Click Go search button and wait for results to load
     */
    public async clickGoSearch(): Promise<void> {
        Tsreporter.info('Clicking Go search button');
        await this.goSearchButton.waitForVisible(10000);
        await this.goSearchButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        await this.waitForLoaderToDisappear();
        Tsreporter.pass('Clicked Go search button');
    }

    /**
     * Search for a eeeee scattered mmte by name
     * Combines reset, entering text, and clicking Go
     * @param name The eeeee scattered mmte name to search for
     */
    public async searchEeeeeMmte(name: string): Promise<void> {
        Tsreporter.info(`Searching for eeeee scattered mmte: ${name}`);
        await this.resetSearch();
        await this.enterSearchText(name);
        await this.clickGoSearch();
        Tsreporter.pass(`Searched for eeeee scattered mmte: ${name}`);
    }

    // ===================================================================
    // FILTER METHODS
    // ===================================================================

    /**
     * Verify Filters button is present
     */
    public async verifyFiltersButtonPresent(): Promise<void> {
        Tsreporter.info('Verifying Filters button is present');
        await this.filtersButton.waitForVisible(10000);
        Tsreporter.pass('Filters button is present');
    }

    /**
     * Verify Cumulative Mmte dropdown is present
     */
    public async verifyCumulativeMmteDropdownPresent(): Promise<void> {
        Tsreporter.info('Verifying Cumulative Mmte dropdown is present');
        await this.cumulativeMmteDropdownButton.waitForVisible(10000);
        Tsreporter.pass('Cumulative Mmte dropdown is present');
    }

    /**
     * Verify Reset Filters button is present and enabled
     */
    public async verifyResetFiltersEnabled(): Promise<void> {
        Tsreporter.info('Verifying Reset Filters button is present and enabled');
        await this.resetFilterButton.waitForVisible(10000);
        const isEnabled = await this.resetFilterButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Reset Filters button is not enabled');
        }
        Tsreporter.pass('Reset Filters button is present and enabled');
    }

    /**
     * Verify Export button is present and enabled
     */
    public async verifyExportButtonEnabled(): Promise<void> {
        Tsreporter.info('Verifying Export button is present and enabled');
        await this.exportButton.waitForVisible(10000);
        const isEnabled = await this.exportButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Export button is not enabled');
        }
        Tsreporter.pass('Export button is present and enabled');
    }

    /**
     * Verify Filters button is present and not expanded by default
     */
    public async verifyFiltersNotExpandedByDefault(): Promise<void> {
        Tsreporter.info('Verifying Filters area is not expanded by default');
        await this.filtersButton.waitForVisible(10000);
        const ariaExpanded = await this.filtersButton.getAttributeWithTimeout('aria-expanded', 5000);
        if (ariaExpanded !== 'false') {
            throw new Error('Filters area is unexpectedly expanded');
        }
        Tsreporter.pass('Filters area is not expanded by default');
    }

    /**
     * Click Filters button to expand/collapse filters panel
     */
    public async clickFiltersButton(): Promise<void> {
        Tsreporter.info('Clicking Filters button');
        await this.filtersButton.waitForVisible(10000);
        await this.filtersButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        Tsreporter.pass('Clicked Filters button');
    }

    /**
     * Verify Filter criteria header is present (when filters are expanded)
     */
    public async verifyFilterCriteriaPresent(): Promise<void> {
        Tsreporter.info('Verifying Filter criteria header is present');
        await this.filterCriteriaHeader.waitForVisible(10000);
        Tsreporter.pass('Filter criteria header is present');
    }

    /**
     * Verify Filter criteria section is collapsed (header not visible)
     */
    public async verifyFilterCriteriaSectionCollapsed(): Promise<void> {
        Tsreporter.info('Verifying Filter criteria section is collapsed');
        const isVisible = await this.filterCriteriaHeader.isVisibleWithTimeout(3000);
        if (isVisible) {
            throw new Error('Filter criteria section is unexpectedly visible (should be collapsed)');
        }
        Tsreporter.pass('Filter criteria section is collapsed');
    }

    /**
     * Verify Cumulative Mmte dropdown default selection is "Select"
     */
    public async verifyCumulativeMmteDefaultSelect(): Promise<void> {
        Tsreporter.info('Verifying Cumulative Mmte dropdown default is Select');
        await this.cumulativeMmteDropdownLabel.waitForVisible(10000);
        const text = await this.cumulativeMmteDropdownLabel.textContentWithTimeout(5000);
        if (text?.trim() !== 'Select') {
            throw new Error(`Cumulative Mmte dropdown default should be 'Select' but was '${text?.trim()}'`);
        }
        Tsreporter.pass('Cumulative Mmte dropdown default is Select');
    }

    /**
     * Click Cumulative Mmte dropdown to open the options list
     */
    public async clickCumulativeMmteDropdown(): Promise<void> {
        Tsreporter.info('Clicking Cumulative Mmte dropdown');
        await this.cumulativeMmteDropdownButton.waitForVisible(10000);
        await this.cumulativeMmteDropdownButton.clickWithTimeout(10000);
        Tsreporter.pass('Clicked Cumulative Mmte dropdown');
    }

    /**
     * Verify Cumulative Mmte dropdown list is visible (balloon is open)
     */
    public async verifyCumulativeMmteDropdownListVisible(): Promise<void> {
        Tsreporter.info('Verifying Cumulative Mmte dropdown list is visible');
        const listElement = CSElementFactory.createByXPath(
            `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmte']//ul[@role='listbox']`,
            'Cumulative Mmte dropdown list',
            this.page
        );
        await listElement.waitForVisible(10000);
        Tsreporter.pass('Cumulative Mmte dropdown list is visible');
    }

    /**
     * Verify each expected option is present in the Cumulative Mmte dropdown list
     * @param expectedOptions Array of expected option labels
     */
    public async verifyCumulativeMmteDropdownOptions(expectedOptions: string[]): Promise<void> {
        Tsreporter.info('Verifying Cumulative Mmte dropdown options');

        for (const option of expectedOptions) {
            const optionElement = CSElementFactory.createByXPath(
                `//div[contains(@class, 'sssss-balloon') and @name='cumulativeMmte']//ul[@role='listbox']//li[@role='option']//span[contains(@class, 'sssss-menu-item__label')]//span[text()='${option}']`,
                `Cumulative Mmte option: ${option}`,
                this.page
            );
            await optionElement.waitForVisible(10000);
            Tsreporter.debug(`Option '${option}' is present`);
        }

        Tsreporter.pass(`All ${expectedOptions.length} Cumulative Mmte dropdown options verified`);
    }

    /**
     * Select an Cumulative Mmte from the dropdown list
     * @param cumulativeMmteName The cumulative mmte name to select
     */
    public async selectCumulativeMmte(cumulativeMmteName: string): Promise<void> {
        return this.baseSelectCumulativeMmte(cumulativeMmteName);
    }

    /**
     * Verify that the specified Cumulative Mmte is currently selected
     * @param cumulativeMmteName The cumulative mmte name to verify
     */
    public async verifyCumulativeMmteSelected(cumulativeMmteName: string): Promise<void> {
        Tsreporter.info(`Verifying Cumulative Mmte selected: ${cumulativeMmteName}`);
        const isSelected = await this.baseVerifyCumulativeMmteSelected(cumulativeMmteName);
        if (!isSelected) {
            throw new Error(`Cumulative Mmte '${cumulativeMmteName}' is not selected`);
        }
        Tsreporter.pass(`Cumulative Mmte selected: ${cumulativeMmteName}`);
    }

    /**
     * Click Apply Filters button and wait for table to reload
     */
    public async clickApplyFilters(): Promise<void> {
        return this.baseClickApplyFilters(this.loadingIndicator);
    }

    /**
     * Click Reset Filters button and wait for table to reload
     */
    public async clickResetFilters(): Promise<void> {
        return this.baseClickResetFilters(this.loadingIndicator);
    }

    /**
     * Click Cancel Filters button to close the filter panel without applying
     */
    public async clickCancelFilters(): Promise<void> {
        Tsreporter.info('Clicking Cancel Filters button');
        await this.cancelFilterButton.waitForVisible(10000);
        await this.cancelFilterButton.clickWithTimeout(10000);
        Tsreporter.pass('Clicked Cancel Filters button');
    }

    /**
     * Verify Reset Filters button is disabled
     */
    public async verifyResetFiltersDisabled(): Promise<void> {
        Tsreporter.info('Verifying Reset Filters button is disabled');
        const isEnabled = await this.resetFilterButton.isEnabledWithTimeout(5000);
        if (isEnabled) {
            throw new Error('Reset Filters button should be disabled');
        }
        Tsreporter.pass('Reset Filters button is disabled');
    }

    /**
     * Verify Apply Filter button is enabled
     */
    public async verifyApplyFilterEnabled(): Promise<void> {
        Tsreporter.info('Verifying Apply Filter button is enabled');
        await this.applyFilterButton.waitForVisible(10000);
        const isEnabled = await this.applyFilterButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Apply Filter button should be enabled');
        }
        Tsreporter.pass('Apply Filter button is enabled');
    }

    /**
     * Verify Cancel Filter button is enabled
     */
    public async verifyCancelFilterEnabled(): Promise<void> {
        Tsreporter.info('Verifying Cancel Filter button is enabled');
        await this.cancelFilterButton.waitForVisible(10000);
        const isEnabled = await this.cancelFilterButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Cancel Filter button should be enabled');
        }
        Tsreporter.pass('Cancel Filter button is enabled');
    }

    /**
     * Verify "Filters Applied" button is visible (shown after filters have been applied)
     */
    public async verifyFiltersAppliedButton(): Promise<void> {
        Tsreporter.info('Verifying Filters Applied button is visible');
        await this.filtersAppliedButton.waitForVisible(10000);
        Tsreporter.pass('Filters Applied button is visible');
    }

    /**
     * Get the expanded state of the Filters button (works with both Filters and Filters Applied)
     * @returns true if the filters panel is expanded, false otherwise
     */
    public async getFiltersButtonExpandedState(): Promise<boolean> {
        Tsreporter.info('Getting Filters button expanded state');

        // Try Filters Applied button rust (after filters have been applied)
        const filtersAppliedVisible = await this.filtersAppliedButton.isVisibleWithTimeout(2000);

        if (filtersAppliedVisible) {
            const ariaExpanded = await this.filtersAppliedButton.getAttributeWithTimeout('aria-expanded', 5000);
            return ariaExpanded === 'true';
        }

        // Fall back to Filters button (before filters have been applied)
        const filtersVisible = await this.filtersButton.isVisibleWithTimeout(2000);
        if (filtersVisible) {
            const ariaExpanded = await this.filtersButton.getAttributeWithTimeout('aria-expanded', 5000);
            return ariaExpanded === 'true';
        }

        Tsreporter.warn('Neither Filters nor Filters Applied button found');
        return false;
    }

    /**
     * Expand filters panel if it is currently collapsed
     */
    public async expandFiltersIfCollapsed(): Promise<void> {
        Tsreporter.info('Expanding Filters section if collapsed');
        const isExpanded = await this.getFiltersButtonExpandedState();
        if (!isExpanded) {
            const filtersAppliedVisible = await this.filtersAppliedButton.isVisibleWithTimeout(2000);
            if (filtersAppliedVisible) {
                await this.filtersAppliedButton.clickWithTimeout(10000);
            } else {
                await this.filtersButton.clickWithTimeout(10000);
            }
        }
        Tsreporter.pass('Filters section is expanded');
    }

    /**
     * Verify Filters area is expanded
     */
    public async verifyFiltersExpanded(): Promise<void> {
        Tsreporter.info('Verifying Filters are expanded');
        const isExpanded = await this.getFiltersButtonExpandedState();
        if (!isExpanded) {
            throw new Error('Filters should be expanded but are not');
        }
        Tsreporter.pass('Filters are expanded');
    }

    // ===================================================================
    // SORTING METHODS
    // ===================================================================

    /**
     * Get the aria-sort attribute value from a column header by column number
     * @param colNum Column number (1-based)
     * @returns The aria-sort attribute value (e.g., 'ascending', 'descending', 'none')
     */
    public async getColumnSortAttribute(colNum: number): Promise<string> {
        Tsreporter.info(`Getting sort attribute for column ${colNum}`);
        const xpath = `//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, "sssss-table")]//thead/tr[1]/th[${colNum}]`;
        const thElement = CSElementFactory.createByXPath(xpath, `Table header th[${colNum}]`, this.page);
        await thElement.waitForVisible(10000);
        const ariaSortValue = await thElement.getAttributeWithTimeout('aria-sort', 5000);
        const sortValue = ariaSortValue ?? 'none';
        Tsreporter.debug(`Column ${colNum} aria-sort: ${sortValue}`);
        return sortValue;
    }

    /**
     * Click a sortable column header button by header name
     * @param headerName The visible text of the column header button
     */
    public async clickColumnHeaderButton(headerName: string): Promise<void> {
        Tsreporter.info(`Clicking column header button: ${headerName}`);
        const xpath = `//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, "sssss-table")]//thead//button[text()='${headerName}']`;
        const headerButton = CSElementFactory.createByXPath(xpath, `Column header button: ${headerName}`, this.page);
        await headerButton.waitForVisible(10000);
        await headerButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        await this.waitForLoaderToDisappear();
        Tsreporter.pass(`Clicked column header button: ${headerName}`);
    }

    /**
     * Verify the sort direction of a column by checking the aria-sort attribute on the parent th
     * @param headerName The visible text of the column header
     * @param direction Expected sort direction (e.g., 'ascending', 'descending')
     */
    public async verifyColumnSortDirection(headerName: string, direction: string): Promise<void> {
        Tsreporter.info(`Verifying column '${headerName}' is sorted ${direction}`);
        const xpath = `//div[@class="sssss-tab__pane-content--active"]//table[contains(@class, "sssss-table")]//thead//button[text()='${headerName}']/ancestor::th[1][@aria-sort='${direction}']`;
        const thElement = CSElementFactory.createByXPath(xpath, `Column header th sorted ${direction}: ${headerName}`, this.page);
        const isVisible = await thElement.isVisibleWithTimeout(10000);
        if (!isVisible) {
            throw new Error(`Column '${headerName}' is not sorted ${direction}`);
        }
        Tsreporter.pass(`Column '${headerName}' is sorted ${direction}`);
    }

    // ===================================================================
    // PAGINATION METHODS
    // ===================================================================

    /**
     * Get total items count from the paginator
     * @returns Total items count as number
     */
    public async getTotalItemsCount(): Promise<number> {
        return this.baseGetTotalItemsCount(this.paginatorTotalItems);
    }

    /**
     * Verify total items count matches the expected count
     * @param expectedCount Expected total items count
     */
    public async verifyTotalItemsCount(expectedCount: number): Promise<void> {
        Tsreporter.info(`Verifying total items count matches: ${expectedCount}`);
        const actualCount = await this.getTotalItemsCount();
        if (actualCount === expectedCount) {
            Tsreporter.pass(`Total items count matches: ${actualCount}`);
        } else {
            Tsreporter.fail(`Total items count mismatch: expected ${expectedCount}, actual ${actualCount}`);
            throw new Error(`Total items count mismatch: expected ${expectedCount}, actual ${actualCount}`);
        }
    }

    // ===================================================================
    // EXPORT METHODS
    // ===================================================================

    /**
     * Click Export button to open export options
     */
    public async clickExportButton(): Promise<void> {
        return this.baseClickExportButton(this.exportButton);
    }

    /**
     * Verify Export options (CSV and XLSX) are present and enabled
     */
    public async verifyExportOptionsPresent(): Promise<void> {
        Tsreporter.info('Verifying Export options are present');
        const csvEnabled = await this.baseIsExportOptionEnabled('CSV');
        const xlsxEnabled = await this.baseIsExportOptionEnabled('XLSX');
        if (!csvEnabled || !xlsxEnabled) {
            throw new Error('Export options (CSV, XLSX) are not all present');
        }
        Tsreporter.pass('Export options (CSV, XLSX) are present');
    }

    /**
     * Verify CSV export option is enabled
     */
    public async verifyCSVOptionEnabled(): Promise<void> {
        Tsreporter.info('Verifying CSV export option is enabled');
        const isEnabled = await this.baseIsExportOptionEnabled('CSV');
        if (!isEnabled) {
            throw new Error('CSV export option is not enabled');
        }
        Tsreporter.pass('CSV export option is enabled');
    }

    /**
     * Verify XLSX export option is enabled
     */
    public async verifyXLSXOptionEnabled(): Promise<void> {
        Tsreporter.info('Verifying XLSX export option is enabled');
        const isEnabled = await this.baseIsExportOptionEnabled('XLSX');
        if (!isEnabled) {
            throw new Error('XLSX export option is not enabled');
        }
        Tsreporter.pass('XLSX export option is enabled');
    }

    /**
     * Click CSV export option
     */
    public async clickExportCSV(): Promise<void> {
        return this.baseClickExportFormat('CSV');
    }

    /**
     * Click XLSX export option
     */
    public async clickExportXLSX(): Promise<void> {
        return this.baseClickExportFormat('XLSX');
    }

    /**
     * Wait for export to complete (wait for "Exporting" text to disappear)
     */
    public async waitForExportComplete(): Promise<void> {
        return this.baseWaitForExportComplete();
    }

    // ===================================================================
    // COLUMN HEADER VERIFICATION
    // ===================================================================

    /**
     * Verify all Eeeee Scattered Mmtes table column headers
     */
    public async verifyEeeeeMmteTableHeaders(): Promise<void> {
        return this.baseVerifyAllColumnHeaders(false);
    }
}




------------------------------------------------------------------------------------------------------------------

import { CSBasePage, CSPage, CSGetElement } from '@mdakhan.mak/cs-playwright-test-framework/core';
import { TswebElement, CSElementFactory } from '@mdakhan.mak/cs-playwright-test-framework/element';
import { Tsreporter } from '@mdakhan.mak/cs-playwright-test-framework/reporter';

/**
 * TTTF Mmte History Page
 * Source: Scattered_Mmte_Eeeee_Mmte_04.txt (Circles 136-253)
 * Handles Mmte History screen  search section, results table, Add Scattered Mmte popup
 * All XPath locators taken directly from requirements
 */
@CSPage('tttf-mmte-history')
export class TTTFMmteHistoryPage extends CSBasePage {

    // ===================================================================
    // PAGE HEADER
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@class="body-container"]//h1[text()="Mmte History"]',
        description: 'Mmte History page header',
        waitForVisible: true
    })
    public mmteHistoryHeader!: TswebElement;

    // ===================================================================
    // SEARCH SECTION ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]',
        description: 'Search section container',
        waitForVisible: true
    })
    public searchSection!: TswebElement;

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//button[@aria-label="Collapse Search"]',
        description: 'Collapse Search button (present when expanded)',
        waitForVisible: false
    })
    public collapseSearchButton!: TswebElement;

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//div[text()="Search By"]',
        description: 'Search By label',
        waitForVisible: true
    })
    public searchByLabel!: TswebElement;

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//button[@name="searchType"]',
        description: 'Type dropdown button',
        waitForVisible: true
    })
    public searchTypeDropdown!: TswebElement;

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//button[@name="scatteredMmteId"]',
        description: 'Name dropdown button',
        waitForVisible: true
    })
    public nameDropdown!: TswebElement;

    // ===================================================================
    // SEARCH ACTION BUTTONS
    // ===================================================================

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//div[@class="button-bar-container"]//span[text()="Search"]/parent::button[1]',
        description: 'Search button',
        waitForVisible: true
    })
    public searchButton!: TswebElement;

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//div[@class="button-bar-container"]//span[text()="Add Mmte"]/parent::button[1]',
        description: 'Add Mmte button',
        waitForVisible: true
    })
    public addMmteButton!: TswebElement;

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//div[@class="button-bar-container"]//span[text()="Add Condition"]/parent::button[1]',
        description: 'Add Condition button',
        waitForVisible: true
    })
    public addConditionButton!: TswebElement;

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//div[@class="button-bar-container"]//span[text()="Reset"]/parent::button[1]',
        description: 'Reset button',
        waitForVisible: true
    })
    public resetButton!: TswebElement;

    @tsgetElement({
        xpath: '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//div[@class="button-bar-container"]//span[text()="Update Ffx"]/parent::button[1]',
        description: 'Update Ffx button (appears after adding mmte)',
        waitForVisible: false
    })
    public updateFfxButton!: TswebElement;

    // ===================================================================
    // RESULTS SECTION ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@class="body-container"]//h2[text()="Results"]',
        description: 'Results section header',
        waitForVisible: true
    })
    public resultsSectionHeader!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="body-container"]//h5[text()="Displaying"]',
        description: 'Displaying section header',
        waitForVisible: true
    })
    public displayingHeader!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="body-container"]//h5[text()="Displaying"]/parent::div[1]//div[@class="horizontal-list-item"]//div[text()="Scattered Mmte Name"]',
        description: 'Scattered Mmte Name label in Displaying section',
        waitForVisible: true
    })
    public displayingMmteNameLabel!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="body-container"]//h5[text()="Displaying"]/parent::div[1]//div[@class="horizontal-list-item"]//div[text()="Scattered Mmte Name"]/following-sibling::div[1]',
        description: 'Scattered Mmte Name value in Displaying section',
        waitForVisible: true
    })
    public displayingMmteNameValue!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="body-container"]//h5[text()="Displaying"]/parent::div[1]/following-sibling::div[1]//table[@class="sssss-table"]',
        description: 'Results table',
        waitForVisible: true
    })
    public resultsTable!: TswebElement;

    @tsgetElement({
        xpath: '//div[@class="body-container"]//h5[text()="Displaying"]/parent::div[1]/following-sibling::div[1]//table[@class="sssss-table"]//tbody/tr/td[@class="sssss-table__empty-data-message-content" and text()="No data available."]',
        description: 'No data available message in results table',
        waitForVisible: false
    })
    public resultsNoDataMessage!: TswebElement;

    // ===================================================================
    // ADD SCATTERED MMTE POPUP ELEMENTS
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]',
        description: 'Add Scattered Mmte popup container',
        waitForVisible: false
    })
    public addMmtePopup!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//h5[@class="sssss-panel__title" and text()="Add Scattered Mmte"]',
        description: 'Add Scattered Mmte popup header',
        waitForVisible: false
    })
    public addMmtePopupHeader!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//div[contains(@class, "sssss-panel__header")]//span[text()="Close"]/ancestor::button[1]',
        description: 'Popup X close button',
        waitForVisible: false
    })
    public popupCloseXButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//label[@class="sssss-field__label" and text()="Scattered Mmte Name"]',
        description: 'Scattered Mmte Name label on popup',
        waitForVisible: false
    })
    public popupMmteNameLabel!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//label[@class="sssss-field__label" and text()="Scattered Mmte Name"]/following-sibling::div[contains(@class, "sssss-field__content")]',
        description: 'Scattered Mmte Name value on popup',
        waitForVisible: false
    })
    public popupMmteNameValue!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//input[@name="ffxDate"]',
        description: 'FFX Date input on popup',
        waitForVisible: false
    })
    public popupFfxDateInput!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//input[@name="cycleDate"]',
        description: 'Payment Cycle input on popup (auto-populated, disabled)',
        waitForVisible: false
    })
    public popupPaymentCycleInput!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-panel__body"]//input[@name="mmte"]',
        description: 'Mmte % input on popup',
        waitForVisible: false
    })
    public popupMmteInput!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//div[@class="sssss-field-footer__hint" and text()="Mmte must be numeric and not more than 100%"]',
        description: 'Mmte hint message on popup',
        waitForVisible: false
    })
    public popupMmteHintMessage!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//div[@class="button-bar-container"]//span[@class="sssss-button__label" and text()="Save"]/parent::button[1]',
        description: 'Save button on popup',
        waitForVisible: false
    })
    public popupSaveButton!: TswebElement;

    @tsgetElement({
        xpath: '//div[@id="sssss-modal-portal"]//div[@class="sssss-panel__content-wrapper"]//div[@class="button-bar-container"]//span[@class="sssss-button__label" and text()="Cancel"]/parent::button[1]',
        description: 'Cancel button on popup',
        waitForVisible: false
    })
    public popupCancelButton!: TswebElement;

    // ===================================================================
    // LOADER ELEMENT
    // ===================================================================

    @tsgetElement({
        xpath: '//div[text()="Loading..."]',
        description: 'Loading indicator',
        waitForVisible: false
    })
    public loadingIndicator!: TswebElement;

    // ===================================================================
    // SUCCESS MESSAGE ELEMENT
    // ===================================================================

    @tsgetElement({
        xpath: '//div[@id="sssss-message-bar-portal"]//div[contains(@class, "sssss-message-bar__messages")]',
        description: 'Message bar portal',
        waitForVisible: false
    })
    public messageBar!: TswebElement;

    protected initializeElements(): void {
        Tsreporter.debug('TTTFMmteHistoryPage elements initialized');
    }

    // ===================================================================
    // LOADER METHODS
    // ===================================================================

    /**
     * Wait for loader to disappear
     */
    public async waitForLoaderToDisappear(): Promise<void> {
        Tsreporter.info('Waiting for loader to disappear');
        try {
            const isVisible = await this.loadingIndicator.isVisibleWithTimeout(2000);
            if (isVisible) {
                await this.loadingIndicator.waitForDetached(30000);
            }
        } catch {
            // Loader didn't appear  fine
        }
    }

    // ===================================================================
    // PAGE HEADER METHODS
    // ===================================================================

    /**
     * Verify Mmte History page header is displayed
     */
    public async verifyPageHeader(): Promise<void> {
        Tsreporter.info('Verifying Mmte History page header');
        await this.mmteHistoryHeader.waitForVisible(15000);
        Tsreporter.pass('Mmte History page header is displayed');
    }

    // ===================================================================
    // SEARCH SECTION METHODS
    // ===================================================================

    /**
     * Verify Search section is present and expanded
     */
    public async verifySearchSectionPresentAndExpanded(): Promise<void> {
        Tsreporter.info('Verifying Search section is present and expanded');
        await this.searchSection.waitForVisible(10000);
        const isCollapseVisible = await this.collapseSearchButton.isVisibleWithTimeout(5000);
        if (!isCollapseVisible) {
            throw new Error('Search section is not expanded (Collapse Search button not found)');
        }
        Tsreporter.pass('Search section is present and expanded');
    }

    /**
     * Verify Search Type dropdown shows Scattered Mmte Name selected
     */
    public async verifySearchTypeShowsScatteredMmteName(): Promise<void> {
        Tsreporter.info('Verifying Search Type dropdown shows Scattered Mmte Name');
        const selectedElement = CSElementFactory.createByXPath(
            '//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//button[@name="searchType"]//span[@class="sssss-button__label" and text()="Scattered Mmte Name"]',
            'Search Type Scattered Mmte Name selected',
            this.page
        );
        await selectedElement.waitForVisible(10000);
        Tsreporter.pass('Search Type dropdown shows Scattered Mmte Name');
    }

    /**
     * Verify Scattered Mmte Name is selected in the Name dropdown
     * @param scatteredMmteName The expected scattered mmte name
     */
    public async verifyNameDropdownShowsMmteName(scatteredMmteName: string): Promise<void> {
        Tsreporter.info(`Verifying Name dropdown shows: ${scatteredMmteName}`);
        const selectedElement = CSElementFactory.createByXPath(
            `//h5[text()="Search"]/ancestor::section[@data-testid="searchForm"]//div[@class="sssss-section__body-content"]//button[@name="scatteredMmteId"]//span[@class="sssss-button__label" and text()='${scatteredMmteName}']`,
            `Name dropdown: ${scatteredMmteName}`,
            this.page
        );
        await selectedElement.waitForVisible(10000);
        Tsreporter.pass(`Name dropdown shows: ${scatteredMmteName}`);
    }

    // ===================================================================
    // SEARCH BUTTON METHODS
    // ===================================================================

    /**
     * Verify Search button is present and enabled
     */
    public async verifySearchButtonEnabled(): Promise<void> {
        Tsreporter.info('Verifying Search button is present and enabled');
        await this.searchButton.waitForVisible(10000);
        const isEnabled = await this.searchButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Search button is not enabled');
        }
        Tsreporter.pass('Search button is present and enabled');
    }

    /**
     * Verify Add Mmte button is present and enabled
     */
    public async verifyAddMmteButtonEnabled(): Promise<void> {
        Tsreporter.info('Verifying Add Mmte button is present and enabled');
        await this.addMmteButton.waitForVisible(10000);
        const isEnabled = await this.addMmteButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Add Mmte button is not enabled');
        }
        Tsreporter.pass('Add Mmte button is present and enabled');
    }

    /**
     * Verify Add Condition button is present and enabled
     */
    public async verifyAddConditionButtonEnabled(): Promise<void> {
        Tsreporter.info('Verifying Add Condition button is present and enabled');
        await this.addConditionButton.waitForVisible(10000);
        const isEnabled = await this.addConditionButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Add Condition button is not enabled');
        }
        Tsreporter.pass('Add Condition button is present and enabled');
    }

    /**
     * Verify Reset button is present and enabled
     */
    public async verifyResetButtonEnabled(): Promise<void> {
        Tsreporter.info('Verifying Reset button is present and enabled');
        await this.resetButton.waitForVisible(10000);
        const isEnabled = await this.resetButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Reset button is not enabled');
        }
        Tsreporter.pass('Reset button is present and enabled');
    }

    /**
     * Click Add Mmte button
     */
    public async clickAddMmteButton(): Promise<void> {
        Tsreporter.info('Clicking Add Mmte button');
        await this.addMmteButton.waitForVisible(10000);
        await this.addMmteButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        Tsreporter.pass('Clicked Add Mmte button');
    }

    /**
     * Verify Update Ffx button is displayed and enabled
     */
    public async verifyUpdateFfxButtonDisplayed(): Promise<void> {
        Tsreporter.info('Verifying Update Ffx button is displayed and enabled');
        await this.updateFfxButton.waitForVisible(10000);
        const isEnabled = await this.updateFfxButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Update Ffx button is not enabled');
        }
        Tsreporter.pass('Update Ffx button is displayed and enabled');
    }

    // ===================================================================
    // RESULTS SECTION METHODS
    // ===================================================================

    /**
     * Verify Results section is present
     */
    public async verifyResultsSectionPresent(): Promise<void> {
        Tsreporter.info('Verifying Results section is present');
        await this.resultsSectionHeader.waitForVisible(10000);
        Tsreporter.pass('Results section is present');
    }

    /**
     * Verify Displaying section shows correct Scattered Mmte Name
     * @param scatteredMmteName The expected scattered mmte name
     */
    public async verifyDisplayingMmteName(scatteredMmteName: string): Promise<void> {
        Tsreporter.info(`Verifying Displaying section shows: ${scatteredMmteName}`);
        await this.displayingMmteNameLabel.waitForVisible(10000);
        await this.displayingMmteNameValue.waitForVisible(10000);
        const displayedName = await this.displayingMmteNameValue.textContentWithTimeout(5000);
        if (displayedName?.trim() !== scatteredMmteName) {
            Tsreporter.fail(`Displaying Scattered Mmte Name mismatch: expected '${scatteredMmteName}', actual '${displayedName?.trim()}'`);
            throw new Error(`Displaying Scattered Mmte Name mismatch: expected '${scatteredMmteName}', actual '${displayedName?.trim()}'`);
        }
        Tsreporter.pass(`Displaying section shows correct Scattered Mmte Name: ${scatteredMmteName}`);
    }

    /**
     * Verify Results table is present
     */
    public async verifyResultsTablePresent(): Promise<void> {
        Tsreporter.info('Verifying Results table is present');
        await this.resultsTable.waitForVisible(10000);
        Tsreporter.pass('Results table is present');
    }

    /**
     * Verify Results table shows No data available message
     */
    public async verifyResultsTableNoData(): Promise<void> {
        Tsreporter.info('Verifying Results table shows No data available');
        const isVisible = await this.resultsNoDataMessage.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Expected No data available message but data was found in results table');
        }
        Tsreporter.pass('Results table shows No data available');
    }

    /**
     * Verify Results table does NOT show No data available (has data)
     */
    public async verifyResultsTableHasData(): Promise<void> {
        Tsreporter.info('Verifying Results table has data');
        const isVisible = await this.resultsNoDataMessage.isVisibleWithTimeout(3000);
        if (isVisible) {
            Tsreporter.fail('Results table shows No data available but expected data');
            throw new Error('Results table shows No data available but expected data');
        }
        Tsreporter.pass('Results table has data');
    }

    /**
     * Verify Results table column headers
     */
    public async verifyResultsTableHeaders(): Promise<void> {
        Tsreporter.info('Verifying Results table column headers');
        const tableBase = '//div[@class="body-container"]//h5[text()="Displaying"]/parent::div[1]/following-sibling::div[1]//table[@class="sssss-table"]';

        const sortableHeaders = ['FFX Date', 'Payment Cycle', 'Scattered Mmte Name', 'Mmte(%)'];
        for (const header of sortableHeaders) {
            const element = CSElementFactory.createByXPath(
                `${tableBase}//thead/th[@role="columnheader"]//span[text()='${header}']`,
                `Results header: ${header}`,
                this.page
            );
            await element.waitForVisible(10000);
            Tsreporter.debug(`Header verified: ${header}`);
        }

        const plainHeaders = ['Determination Date', 'Associated Zeals/Premisis', 'Action'];
        for (const header of plainHeaders) {
            const element = CSElementFactory.createByXPath(
                `${tableBase}//thead/th[text()='${header}']`,
                `Results header: ${header}`,
                this.page
            );
            await element.waitForVisible(10000);
            Tsreporter.debug(`Header verified: ${header}`);
        }

        Tsreporter.pass('All 7 Results table column headers verified');
    }

    // ===================================================================
    // RESULTS TABLE DATA METHODS
    // ===================================================================

    private get resultsTableBase(): string {
        return '//div[@class="body-container"]//h5[text()="Displaying"]/parent::div[1]/following-sibling::div[1]//table[@class="sssss-table"]';
    }

    /**
     * Get cell value from results table by row and column number
     * @param rowNum Row number (1-based)
     * @param colNum Column number (1-based)
     * @returns Cell text content
     */
    public async getResultsCellValue(rowNum: number, colNum: number): Promise<string> {
        // Column 3 (Scattered Mmte Name) has span button label
        if (colNum === 3) {
            const xpath = `${this.resultsTableBase}//tbody/tr[${rowNum}]//td[${colNum}]//span[@class='sssss-button__label']`;
            const element = CSElementFactory.createByXPath(xpath, `Results row ${rowNum} col ${colNum} link`, this.page);
            const text = await element.textContentWithTimeout(5000);
            return text?.trim() ?? '';
        }

        const xpath = `${this.resultsTableBase}//tbody/tr[${rowNum}]//td[${colNum}]`;
        const element = CSElementFactory.createByXPath(xpath, `Results row ${rowNum} col ${colNum}`, this.page);
        const text = await element.textContentWithTimeout(5000);
        return text?.trim() ?? '';
    }

    /**
     * Verify Edit button is present in Action column for specified row
     * @param rowNum Row number (1-based)
     */
    public async verifyEditButtonInActionColumn(rowNum: number): Promise<void> {
        Tsreporter.info(`Verifying Edit button in Action column for row ${rowNum}`);
        const xpath = `${this.resultsTableBase}//tbody/tr[${rowNum}]//td[7]//span[@class='sssss-button__label' and text()='Edit']/parent::button[1]`;
        const element = CSElementFactory.createByXPath(xpath, `Edit button row ${rowNum}`, this.page);
        await element.waitForVisible(10000);
        const isEnabled = await element.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error(`Edit button in row ${rowNum} is not enabled`);
        }
        Tsreporter.pass(`Edit button present and enabled in Action column for row ${rowNum}`);
    }

    /**
     * Verify Remove button is present in Action column for specified row
     * @param rowNum Row number (1-based)
     */
    public async verifyRemoveButtonInActionColumn(rowNum: number): Promise<void> {
        Tsreporter.info(`Verifying Remove button in Action column for row ${rowNum}`);
        const xpath = `${this.resultsTableBase}//tbody/tr[${rowNum}]//td[7]//span[@class='sssss-button__label' and text()='Remove']/parent::button[1]`;
        const element = CSElementFactory.createByXPath(xpath, `Remove button row ${rowNum}`, this.page);
        await element.waitForVisible(10000);
        const isEnabled = await element.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error(`Remove button in row ${rowNum} is not enabled`);
        }
        Tsreporter.pass(`Remove button present and enabled in Action column for row ${rowNum}`);
    }

    /**
     * Click Scattered Mmte Name link in results table row
     * @param rowNum Row number (1-based)
     */
    public async clickMmteNameLinkInResultsRow(rowNum: number): Promise<void> {
        Tsreporter.info(`Clicking Scattered Mmte Name link in results row ${rowNum}`);
        const xpath = `${this.resultsTableBase}//tbody/tr[${rowNum}]//td[3]//span[@class='sssss-button__label']/parent::button[1]`;
        const element = CSElementFactory.createByXPath(xpath, `Mmte Name link in row ${rowNum}`, this.page);
        await element.waitForVisible(10000);
        await element.clickWithTimeout(10000);
        await this.waitForPageLoad();
        Tsreporter.pass(`Clicked Scattered Mmte Name link in results row ${rowNum}`);
    }

    // ===================================================================
    // ADD SCATTERED MMTE POPUP METHODS
    // ===================================================================

    /**
     * Verify Add Scattered Mmte popup is displayed
     */
    public async verifyAddMmtePopupDisplayed(): Promise<void> {
        Tsreporter.info('Verifying Add Scattered Mmte popup is displayed');
        await this.addMmtePopup.waitForVisible(10000);
        await this.addMmtePopupHeader.waitForVisible(10000);
        Tsreporter.pass('Add Scattered Mmte popup is displayed');
    }

    /**
     * Verify Add Scattered Mmte popup is dismissed (detached from DOM)
     */
    public async verifyAddMmtePopupDismissed(): Promise<void> {
        Tsreporter.info('Verifying Add Scattered Mmte popup is dismissed');
        await this.addMmtePopup.waitForDetached(15000);
        Tsreporter.pass('Add Scattered Mmte popup is dismissed');
    }

    /**
     * Verify Scattered Mmte Name on popup matches expected value
     * @param scatteredMmteName The expected scattered mmte name
     */
    public async verifyPopupMmteName(scatteredMmteName: string): Promise<void> {
        Tsreporter.info(`Verifying popup Scattered Mmte Name matches: ${scatteredMmteName}`);
        await this.popupMmteNameValue.waitForVisible(10000);
        const displayedName = await this.popupMmteNameValue.textContentWithTimeout(5000);
        if (displayedName?.trim() !== scatteredMmteName) {
            Tsreporter.fail(`Popup Scattered Mmte Name mismatch: expected '${scatteredMmteName}', actual '${displayedName?.trim()}'`);
            throw new Error(`Popup Scattered Mmte Name mismatch: expected '${scatteredMmteName}', actual '${displayedName?.trim()}'`);
        }
        Tsreporter.pass(`Popup Scattered Mmte Name matches: ${scatteredMmteName}`);
    }

    /**
     * Verify FFX Date input is present and enabled
     */
    public async verifyFfxDateInputEnabled(): Promise<void> {
        Tsreporter.info('Verifying FFX Date input is present and enabled');
        await this.popupFfxDateInput.waitForVisible(10000);
        const isEnabled = await this.popupFfxDateInput.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('FFX Date input is not enabled');
        }
        Tsreporter.pass('FFX Date input is present and enabled');
    }

    /**
     * Verify Payment Cycle input is present and disabled
     */
    public async verifyPaymentCycleInputDisabled(): Promise<void> {
        Tsreporter.info('Verifying Payment Cycle input is present and disabled');
        await this.popupPaymentCycleInput.waitForVisible(10000);
        const isEnabled = await this.popupPaymentCycleInput.isEnabledWithTimeout(5000);
        if (isEnabled) {
            throw new Error('Payment Cycle input should be disabled but is enabled');
        }
        Tsreporter.pass('Payment Cycle input is present and disabled');
    }

    /**
     * Verify Mmte input is present and enabled
     */
    public async verifyMmteInputEnabled(): Promise<void> {
        Tsreporter.info('Verifying Mmte input is present and enabled');
        await this.popupMmteInput.waitForVisible(10000);
        const isEnabled = await this.popupMmteInput.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Mmte input is not enabled');
        }
        Tsreporter.pass('Mmte input is present and enabled');
    }

    /**
     * Verify Mmte hint message is displayed
     */
    public async verifyMmteHintMessageDisplayed(): Promise<void> {
        Tsreporter.info('Verifying Mmte hint message is displayed');
        await this.popupMmteHintMessage.waitForVisible(10000);
        Tsreporter.pass('Mmte hint message is displayed');
    }

    /**
     * Verify Save button is present and enabled on popup
     */
    public async verifyPopupSaveButtonEnabled(): Promise<void> {
        Tsreporter.info('Verifying Save button is present and enabled on popup');
        await this.popupSaveButton.waitForVisible(10000);
        const isEnabled = await this.popupSaveButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Save button on popup is not enabled');
        }
        Tsreporter.pass('Save button is present and enabled on popup');
    }

    /**
     * Verify Cancel button is present and enabled on popup
     */
    public async verifyPopupCancelButtonEnabled(): Promise<void> {
        Tsreporter.info('Verifying Cancel button is present and enabled on popup');
        await this.popupCancelButton.waitForVisible(10000);
        const isEnabled = await this.popupCancelButton.isEnabledWithTimeout(5000);
        if (!isEnabled) {
            throw new Error('Cancel button on popup is not enabled');
        }
        Tsreporter.pass('Cancel button is present and enabled on popup');
    }

    /**
     * Enter FFX Date value on popup
     * @param ffxDate The date value to enter (mm/dd/yyyy format)
     */
    public async enterFfxDate(ffxDate: string): Promise<void> {
        Tsreporter.info(`Entering FFX Date: ${ffxDate}`);
        await this.popupFfxDateInput.waitForVisible(10000);
        await this.popupFfxDateInput.clear();
        await this.popupFfxDateInput.fillWithTimeout(ffxDate, 10000);
        Tsreporter.pass(`Entered FFX Date: ${ffxDate}`);
    }

    /**
     * Press Tab key on FFX Date input and wait for Payment Cycle to auto-populate
     */
    public async pressTabAndWaitForPaymentCycle(): Promise<void> {
        Tsreporter.info('Pressing Tab key and waiting for Payment Cycle to auto-populate');
        await this.popupFfxDateInput.waitForVisible(10000);
        await this.page.keyboard.press('Tab');
        await this.wait(1500);
        Tsreporter.pass('Pressed Tab key and waited for Payment Cycle auto-populate');
    }

    /**
     * Get the Payment Cycle auto-populated value
     * @returns The Payment Cycle date string
     */
    public async getPaymentCycleValue(): Promise<string> {
        Tsreporter.info('Getting Payment Cycle value');
        await this.popupPaymentCycleInput.waitForVisible(10000);
        const value = await this.popupPaymentCycleInput.inputValueWithTimeout(5000);
        Tsreporter.info(`Payment Cycle value: ${value}`);
        return value ?? '';
    }

    /**
     * Enter Mmte value on popup
     * @param mmte The mmte value to enter
     */
    public async enterMmte(mmte: string): Promise<void> {
        Tsreporter.info(`Entering Mmte: ${mmte}`);
        await this.popupMmteInput.waitForVisible(10000);
        await this.popupMmteInput.clear();
        await this.popupMmteInput.fillWithTimeout(mmte, 10000);
        Tsreporter.pass(`Entered Mmte: ${mmte}`);
    }

    /**
     * Click Save button on popup
     */
    public async clickPopupSaveButton(): Promise<void> {
        Tsreporter.info('Clicking Save button on popup');
        await this.popupSaveButton.waitForVisible(10000);
        await this.popupSaveButton.clickWithTimeout(10000);
        await this.waitForPageLoad();
        Tsreporter.pass('Clicked Save button on popup');
    }

    /**
     * Verify success message is displayed after saving
     */
    public async verifySuccessMessageDisplayed(): Promise<void> {
        Tsreporter.info('Verifying success message is displayed');
        const messageElement = CSElementFactory.createByXPath(
            '//div[@id="sssss-message-bar-portal"]//div[contains(@class, "sssss-message-bar__messages") and contains(text(),"Scattered Mmte with Id") and contains(text(), "Saved")]',
            'Success message for saved scattered mmte',
            this.page
        );
        await messageElement.waitForVisible(15000);
        Tsreporter.pass('Success message is displayed for saved scattered mmte');
    }
}





----------------------------------------------------------------------------------------------------------------

@tsgetElement({
        xpath: '//div[@class="body-container"]//h2[text()="Associated Zeal/Premisis"]/following-sibling::div[1]//table[@class="sssss-table"]//tbody/tr[1]/td[text()="No data available."]',
        description: 'Associated Zeal/Premisis No data available message',
    })
    public associatedZealPremisisNoData!: TswebElement;



    /**
     * Click View Mmte History link and wait for page load
     */
    public async clickViewMmteHistoryLink(): Promise<void> {
        Tsreporter.info('Clicking View Mmte History link');
        await this.viewMmteHistoryLink.waitForVisible(10000);
        await this.viewMmteHistoryLink.clickWithTimeout(10000);
        await this.waitForPageLoad();
        Tsreporter.pass('Clicked View Mmte History link');
    }



    /**
     * Verify Associated Zeal/Premisis table shows No data available
     */
    public async verifyAssociatedZealPremisisNoData(): Promise<void> {
        Tsreporter.info('Verifying Associated Zeal/Premisis table shows No data available');
        const isVisible = await this.associatedZealPremisisNoData.isVisibleWithTimeout(5000);
        if (!isVisible) {
            throw new Error('Associated Zeal Premisis table does not show "No data available."');
        }
        Tsreporter.pass('Associated Zeal/Premisis table shows No data available');
    }
