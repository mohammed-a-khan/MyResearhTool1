package com.cstestforge.framework.core.data;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.testng.ITestContext;
import org.testng.ITestNGMethod;
import org.testng.annotations.DataProvider;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.data.sources.CSDataSource;
import com.cstestforge.framework.core.utils.CSLogger;

/**
 * Processor for CSTestForgeDataProvider annotation.
 * This class handles the processing of data provider annotations
 * and retrieves data from various sources based on the annotation parameters.
 */
public class CSTestForgeDataProviderProcessor {
    
    private static final CSTestForgeDataProviderProcessor INSTANCE = new CSTestForgeDataProviderProcessor();
    
    // Cache for data sources to improve performance
    private final Map<String, Object[][]> dataCache = new ConcurrentHashMap<>();
    
    private CSTestForgeDataProviderProcessor() {
        // Private constructor to enforce singleton pattern
    }
    
    /**
     * Gets the singleton instance of the processor.
     * 
     * @return The singleton instance
     */
    public static CSTestForgeDataProviderProcessor getInstance() {
        return INSTANCE;
    }
    
    /**
     * TestNG DataProvider method that processes CSTestForgeDataProvider annotation.
     * 
     * @param method The test method
     * @param context The test context
     * @return Data for the test method
     */
    @DataProvider(name = "CSTestForgeDataProvider")
    public Object[][] provideData(Method method, ITestContext context) {
        if (method == null) {
            throw new IllegalArgumentException("Method cannot be null");
        }
        
        CSTestForgeDataProvider dataProviderAnnotation = method.getAnnotation(CSTestForgeDataProvider.class);
        if (dataProviderAnnotation == null) {
            throw new IllegalArgumentException("Method must be annotated with @CSTestForgeDataProvider");
        }
        
        // Get cache key
        String cacheKey = getCacheKey(method, dataProviderAnnotation);
        
        // Check if data is already cached
        if (dataCache.containsKey(cacheKey) && !dataProviderAnnotation.forceRefresh()) {
            return dataCache.get(cacheKey);
        }
        
        // Get data from source
        Object[][] data = fetchDataFromSource(dataProviderAnnotation, method, context);
        
        // Apply transformations if needed
        if (dataProviderAnnotation.transform()) {
            data = transformData(data, dataProviderAnnotation, method);
        }
        
        // Cache the data if caching is enabled
        if (dataProviderAnnotation.cache()) {
            dataCache.put(cacheKey, data);
        }
        
        return data;
    }
    
    /**
     * Clears the data cache for all data providers.
     */
    public void clearCache() {
        dataCache.clear();
    }
    
    /**
     * Clears the data cache for a specific method.
     * 
     * @param method The method to clear cache for
     */
    public void clearCache(Method method) {
        if (method == null) {
            return;
        }
        
        CSTestForgeDataProvider dataProviderAnnotation = method.getAnnotation(CSTestForgeDataProvider.class);
        if (dataProviderAnnotation == null) {
            return;
        }
        
        String cacheKey = getCacheKey(method, dataProviderAnnotation);
        dataCache.remove(cacheKey);
    }
    
    /**
     * Generates a cache key for the method and data provider.
     * 
     * @param method The method
     * @param dataProvider The data provider annotation
     * @return The cache key
     */
    private String getCacheKey(Method method, CSTestForgeDataProvider dataProvider) {
        StringBuilder keyBuilder = new StringBuilder();
        keyBuilder.append(method.getDeclaringClass().getName())
                 .append("#")
                 .append(method.getName())
                 .append("#")
                 .append(dataProvider.source())
                 .append("#")
                 .append(dataProvider.path());
        
        // Add filters to the key if present
        if (dataProvider.filters().length > 0) {
            keyBuilder.append("#");
            for (String filter : dataProvider.filters()) {
                keyBuilder.append(filter).append(",");
            }
        }
        
        return keyBuilder.toString();
    }
    
    /**
     * Fetches data from the specified source.
     * 
     * @param dataProvider The data provider annotation
     * @param method The method
     * @param context The test context
     * @return The data from the source
     */
    private Object[][] fetchDataFromSource(CSTestForgeDataProvider dataProvider, Method method, ITestContext context) {
        try {
            // Create data source
            CSDataSource dataSource = CSDataSourceFactory.createDataSource(
                    dataProvider.source(), 
                    dataProvider.path(),
                    dataProvider.filters(),
                    dataProvider.parameters()
            );
            
            // Load the data
            List<Map<String, Object>> data = dataSource.loadData();
            
            // Map the data to the method parameters
            return mapDataToParameters(data, method, dataProvider);
        } catch (Exception e) {
            CSLogger.error("Failed to fetch data from source: " + dataProvider.source() + " - " + dataProvider.path(), e);
            throw new RuntimeException("Failed to fetch data from source", e);
        }
    }
    
    /**
     * Maps the loaded data to method parameters.
     * 
     * @param data The loaded data
     * @param method The method
     * @param dataProvider The data provider annotation
     * @return The mapped data
     */
    private Object[][] mapDataToParameters(List<Map<String, Object>> data, Method method, CSTestForgeDataProvider dataProvider) {
        if (data == null || data.isEmpty()) {
            if (dataProvider.emptyDataAllowed()) {
                return new Object[0][0];
            } else {
                throw new RuntimeException("No data found for data provider");
            }
        }
        
        // Get parameter names from method
        String[] parameterNames = dataProvider.parameters();
        
        // If parameter names not explicitly defined, use method parameter names
        if (parameterNames.length == 0) {
            // Implementation depends on your parameter name discovery mechanism
            // This example uses a placeholder method
            parameterNames = getMethodParameterNames(method);
        }
        
        // Create the result array
        Object[][] result = new Object[data.size()][parameterNames.length];
        
        // Fill the result array
        for (int i = 0; i < data.size(); i++) {
            Map<String, Object> row = data.get(i);
            for (int j = 0; j < parameterNames.length; j++) {
                String paramName = parameterNames[j];
                result[i][j] = row.getOrDefault(paramName, null);
            }
        }
        
        return result;
    }
    
    /**
     * Gets the parameter names of a method.
     * This is a placeholder for actual implementation.
     * 
     * @param method The method
     * @return The parameter names
     */
    private String[] getMethodParameterNames(Method method) {
        // This would be implemented based on your parameter name discovery mechanism
        // Options include:
        // 1. Using ASM to read debug information
        // 2. Using Java 8+ Parameter.getName() if -parameters compiler flag is used
        // 3. Using a convention like the parameter index
        
        // For this example, we'll return a placeholder
        String[] names = new String[method.getParameterCount()];
        for (int i = 0; i < names.length; i++) {
            names[i] = "param" + i;
        }
        return names;
    }
    
    /**
     * Transforms the data based on the transformation rules.
     * 
     * @param data The original data
     * @param dataProvider The data provider annotation
     * @param method The method
     * @return The transformed data
     */
    private Object[][] transformData(Object[][] data, CSTestForgeDataProvider dataProvider, Method method) {
        try {
            // Create data transformer
            CSDataTransformer transformer = new CSDataTransformer();
            
            // Apply transformations
            return transformer.transform(data, dataProvider.transformationRules());
        } catch (Exception e) {
            CSLogger.error("Failed to transform data", e);
            throw new RuntimeException("Failed to transform data", e);
        }
    }
    
    /**
     * Factory method for data provider used in TestNG tests.
     * 
     * @param dataSourceType The data source type
     * @param path The path to the data source
     * @param filters Optional filters to apply
     * @return The data for the test
     */
    public Iterator<Object[]> createDataProvider(String dataSourceType, String path, String... filters) {
        try {
            // Create data source
            CSDataSource dataSource = CSDataSourceFactory.createDataSource(dataSourceType, path, filters, new String[0]);
            
            // Load the data
            List<Map<String, Object>> data = dataSource.loadData();
            
            // Convert to Object[]
            List<Object[]> result = new ArrayList<>();
            for (Map<String, Object> row : data) {
                result.add(row.values().toArray());
            }
            
            return result.iterator();
        } catch (Exception e) {
            CSLogger.error("Failed to create data provider: " + dataSourceType + " - " + path, e);
            throw new RuntimeException("Failed to create data provider", e);
        }
    }
    
    /**
     * Registers this processor with TestNG.
     * 
     * @param context The test context
     */
    public void registerWithTestNG(ITestContext context) {
        for (ITestNGMethod method : context.getAllTestMethods()) {
            Method javaMethod = method.getConstructorOrMethod().getMethod();
            if (javaMethod.isAnnotationPresent(CSTestForgeDataProvider.class)) {
                // Register this data provider for the method
                method.setDataProviderMethod(getClass().getMethods()[0]); // Assumes provideData is first method
            }
        }
    }
}



package com.cstestforge.framework.core.data;

import java.lang.reflect.Method;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;
import java.util.HashMap;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import com.cstestforge.framework.core.utils.CSDateUtils;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSTextUtils;

/**
 * Utility class for transforming test data.
 * Provides methods to apply various transformations to test data.
 */
public class CSDataTransformer {

    // Map of built-in transformation functions
    private final Map<String, Function<Object, Object>> transformationFunctions = new HashMap<>();
    
    /**
     * Constructor initializes built-in transformation functions.
     */
    public CSDataTransformer() {
        initializeTransformationFunctions();
    }
    
    /**
     * Initializes the map of built-in transformation functions.
     */
    private void initializeTransformationFunctions() {
        // String transformations
        transformationFunctions.put("toUpperCase", obj -> obj instanceof String ? ((String) obj).toUpperCase() : obj);
        transformationFunctions.put("toLowerCase", obj -> obj instanceof String ? ((String) obj).toLowerCase() : obj);
        transformationFunctions.put("trim", obj -> obj instanceof String ? ((String) obj).trim() : obj);
        transformationFunctions.put("reverse", obj -> obj instanceof String ? new StringBuilder((String) obj).reverse().toString() : obj);
        
        // Numeric transformations
        transformationFunctions.put("toInt", obj -> {
            if (obj instanceof String) {
                try {
                    return Integer.parseInt((String) obj);
                } catch (NumberFormatException e) {
                    CSLogger.warn("Failed to parse string to int: " + obj);
                    return obj;
                }
            } else if (obj instanceof Number) {
                return ((Number) obj).intValue();
            }
            return obj;
        });
        
        transformationFunctions.put("toDouble", obj -> {
            if (obj instanceof String) {
                try {
                    return Double.parseDouble((String) obj);
                } catch (NumberFormatException e) {
                    CSLogger.warn("Failed to parse string to double: " + obj);
                    return obj;
                }
            } else if (obj instanceof Number) {
                return ((Number) obj).doubleValue();
            }
            return obj;
        });
        
        transformationFunctions.put("increment", obj -> {
            if (obj instanceof Integer) {
                return (Integer) obj + 1;
            } else if (obj instanceof Long) {
                return (Long) obj + 1;
            } else if (obj instanceof Double) {
                return (Double) obj + 1;
            } else if (obj instanceof Float) {
                return (Float) obj + 1;
            }
            return obj;
        });
        
        transformationFunctions.put("decrement", obj -> {
            if (obj instanceof Integer) {
                return (Integer) obj - 1;
            } else if (obj instanceof Long) {
                return (Long) obj - 1;
            } else if (obj instanceof Double) {
                return (Double) obj - 1;
            } else if (obj instanceof Float) {
                return (Float) obj - 1;
            }
            return obj;
        });
        
        // Date transformations
        transformationFunctions.put("formatDate", obj -> {
            if (obj instanceof Date) {
                return CSDateUtils.formatDate((Date) obj, "yyyy-MM-dd");
            } else if (obj instanceof String) {
                try {
                    Date date = new SimpleDateFormat("yyyy-MM-dd").parse((String) obj);
                    return CSDateUtils.formatDate(date, "yyyy-MM-dd");
                } catch (ParseException e) {
                    CSLogger.warn("Failed to parse date string: " + obj);
                    return obj;
                }
            }
            return obj;
        });
        
        transformationFunctions.put("currentDate", obj -> new Date());
        
        // Boolean transformations
        transformationFunctions.put("toBoolean", obj -> {
            if (obj instanceof String) {
                String str = (String) obj;
                return Boolean.parseBoolean(str) || "yes".equalsIgnoreCase(str) || "1".equals(str) || "true".equalsIgnoreCase(str);
            }
            return obj;
        });
        
        transformationFunctions.put("not", obj -> {
            if (obj instanceof Boolean) {
                return !(Boolean) obj;
            }
            return obj;
        });
        
        // Null handling
        transformationFunctions.put("nullToEmpty", obj -> obj == null ? "" : obj);
        transformationFunctions.put("emptyToNull", obj -> (obj instanceof String && ((String) obj).isEmpty()) ? null : obj);
        
        // Regular expression
        transformationFunctions.put("regexExtract", obj -> {
            if (obj instanceof String) {
                // This transformation requires additional parameters
                // It will be handled specially in the applyTransformation method
                return obj;
            }
            return obj;
        });
    }
    
    /**
     * Transforms the data based on the specified transformation rules.
     * 
     * @param data The original data
     * @param transformationRules The transformation rules to apply
     * @return The transformed data
     */
    public Object[][] transform(Object[][] data, String[] transformationRules) {
        if (data == null || data.length == 0 || transformationRules == null || transformationRules.length == 0) {
            return data;
        }
        
        // Parse transformation rules
        Map<Integer, Map<String, String>> parsedRules = parseTransformationRules(transformationRules);
        
        // Create a new array for transformed data
        Object[][] transformedData = new Object[data.length][];
        
        // Apply transformations to each row
        for (int i = 0; i < data.length; i++) {
            Object[] row = data[i];
            Object[] transformedRow = new Object[row.length];
            
            // Copy and transform each value
            for (int j = 0; j < row.length; j++) {
                Object value = row[j];
                
                // Apply transformations for this column if specified
                if (parsedRules.containsKey(j)) {
                    Map<String, String> columnRules = parsedRules.get(j);
                    for (Map.Entry<String, String> rule : columnRules.entrySet()) {
                        value = applyTransformation(value, rule.getKey(), rule.getValue());
                    }
                }
                
                transformedRow[j] = value;
            }
            
            transformedData[i] = transformedRow;
        }
        
        return transformedData;
    }
    
    /**
     * Parses the transformation rules into a structured format.
     * 
     * @param transformationRules The transformation rules to parse
     * @return A map of column index to transformation functions
     */
    private Map<Integer, Map<String, String>> parseTransformationRules(String[] transformationRules) {
        Map<Integer, Map<String, String>> result = new HashMap<>();
        
        for (String rule : transformationRules) {
            // Rule format: "column:function:param"
            String[] parts = rule.split(":");
            
            if (parts.length < 2) {
                CSLogger.warn("Invalid transformation rule: " + rule);
                continue;
            }
            
            try {
                // Parse the column index
                int columnIndex = Integer.parseInt(parts[0]);
                
                // Get the transformation function
                String function = parts[1];
                
                // Get the parameter if present
                String param = parts.length > 2 ? parts[2] : "";
                
                // Add to the result map
                Map<String, String> columnRules = result.computeIfAbsent(columnIndex, k -> new HashMap<>());
                columnRules.put(function, param);
            } catch (NumberFormatException e) {
                CSLogger.warn("Invalid column index in transformation rule: " + rule);
            }
        }
        
        return result;
    }
    
    /**
     * Applies a specific transformation to a value.
     * 
     * @param value The value to transform
     * @param function The transformation function name
     * @param parameter The parameter for the transformation
     * @return The transformed value
     */
    private Object applyTransformation(Object value, String function, String parameter) {
        // Check for predefined transformations
        if (transformationFunctions.containsKey(function)) {
            Function<Object, Object> transformer = transformationFunctions.get(function);
            
            // Special handling for transformations that require parameters
            if ("regexExtract".equals(function) && value instanceof String && !parameter.isEmpty()) {
                try {
                    Pattern pattern = Pattern.compile(parameter);
                    Matcher matcher = pattern.matcher((String) value);
                    if (matcher.find() && matcher.groupCount() > 0) {
                        return matcher.group(1);
                    }
                } catch (Exception e) {
                    CSLogger.warn("Failed to apply regex extraction: " + e.getMessage());
                }
                return value;
            }
            
            // Apply the standard transformation
            return transformer.apply(value);
        } 
        // Check for custom JavaScript transformation
        else if ("script".equals(function) && !parameter.isEmpty()) {
            // This would be implemented using a script engine
            // For simplicity, we'll just return the original value
            CSLogger.warn("JavaScript transformations not implemented yet");
            return value;
        }
        // Dynamic method invocation
        else if (function.startsWith("method:") && !parameter.isEmpty()) {
            String methodName = function.substring(7);
            try {
                // Find the method in CSTextUtils class
                Method method = CSTextUtils.class.getMethod(methodName, Object.class, String.class);
                return method.invoke(null, value, parameter);
            } catch (Exception e) {
                CSLogger.warn("Failed to invoke method: " + methodName, e);
            }
            return value;
        }
        
        CSLogger.warn("Unknown transformation function: " + function);
        return value;
    }
    
    /**
     * Registers a custom transformation function.
     * 
     * @param name The name of the transformation
     * @param function The transformation function
     */
    public void registerTransformation(String name, Function<Object, Object> function) {
        if (name == null || name.isEmpty() || function == null) {
            throw new IllegalArgumentException("Name and function must not be null or empty");
        }
        
        transformationFunctions.put(name, function);
    }
}


package com.cstestforge.framework.core.data.sources;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.DataFormatter;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;

/**
 * Implementation of CSDataSource for Excel files.
 * Supports both XLS and XLSX formats.
 */
public class ExcelDataSource implements CSDataSource {

    private final String filePath;
    private final String[] filters;
    private final String[] parameters;
    private String sheetName;
    private int headerRow = 0;
    private int startRow = 1;
    private int endRow = -1;
    
    /**
     * Constructor for ExcelDataSource.
     * 
     * @param filePath The path to the Excel file
     * @param filters Optional filters in format "key=value"
     * @param parameters Optional parameters for additional configuration
     */
    public ExcelDataSource(String filePath, String[] filters, String[] parameters) {
        this.filePath = filePath;
        this.filters = filters != null ? filters : new String[0];
        this.parameters = parameters != null ? parameters : new String[0];
        
        parseParameters();
    }
    
    /**
     * Parses additional parameters.
     */
    private void parseParameters() {
        for (String param : parameters) {
            String[] parts = param.split("=", 2);
            if (parts.length != 2) {
                continue;
            }
            
            String key = parts[0].trim();
            String value = parts[1].trim();
            
            switch (key) {
                case "sheet":
                    sheetName = value;
                    break;
                case "headerRow":
                    try {
                        headerRow = Integer.parseInt(value);
                    } catch (NumberFormatException e) {
                        CSLogger.warn("Invalid headerRow value: " + value);
                    }
                    break;
                case "startRow":
                    try {
                        startRow = Integer.parseInt(value);
                    } catch (NumberFormatException e) {
                        CSLogger.warn("Invalid startRow value: " + value);
                    }
                    break;
                case "endRow":
                    try {
                        endRow = Integer.parseInt(value);
                    } catch (NumberFormatException e) {
                        CSLogger.warn("Invalid endRow value: " + value);
                    }
                    break;
                default:
                    CSLogger.warn("Unknown parameter: " + key);
                    break;
            }
        }
    }

    /**
     * Loads data from the Excel file.
     * 
     * @return List of maps containing the data
     */
    @Override
    public List<Map<String, Object>> loadData() throws IOException {
        List<Map<String, Object>> result = new ArrayList<>();
        
        // Resolve the file path
        String resolvedPath = CSPathUtils.resolvePath(filePath);
        File file = new File(resolvedPath);
        
        if (!file.exists()) {
            throw new IOException("Excel file not found: " + resolvedPath);
        }
        
        try (FileInputStream fis = new FileInputStream(file);
             Workbook workbook = WorkbookFactory.create(fis)) {
            
            // Get the sheet
            Sheet sheet;
            if (sheetName != null && !sheetName.isEmpty()) {
                sheet = workbook.getSheet(sheetName);
                if (sheet == null) {
                    throw new IOException("Sheet not found: " + sheetName);
                }
            } else {
                sheet = workbook.getSheetAt(0);
            }
            
            // Get the header row
            Row header = sheet.getRow(headerRow);
            if (header == null) {
                throw new IOException("Header row not found at index: " + headerRow);
            }
            
            // Collect header names
            List<String> headerNames = new ArrayList<>();
            for (Cell cell : header) {
                String headerName = getStringCellValue(cell);
                headerNames.add(headerName);
            }
            
            // Calculate the end row if not specified
            int lastRow = endRow >= 0 ? endRow : sheet.getLastRowNum();
            
            // Process data rows
            DataFormatter formatter = new DataFormatter();
            for (int i = startRow; i <= lastRow; i++) {
                Row row = sheet.getRow(i);
                if (row == null) {
                    continue;
                }
                
                Map<String, Object> rowData = new HashMap<>();
                
                // Fill row data
                for (int j = 0; j < headerNames.size(); j++) {
                    Cell cell = row.getCell(j, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL);
                    Object cellValue = getCellValue(cell, formatter);
                    rowData.put(headerNames.get(j), cellValue);
                }
                
                // Apply filters
                if (applyFilters(rowData)) {
                    result.add(rowData);
                }
            }
        } catch (Exception e) {
            CSLogger.error("Error reading Excel file: " + resolvedPath, e);
            throw new IOException("Error reading Excel file: " + e.getMessage(), e);
        }
        
        return result;
    }
    
    /**
     * Gets the value from a cell based on its type.
     * 
     * @param cell The cell to extract value from
     * @param formatter DataFormatter for consistent string conversion
     * @return The cell value as the appropriate type
     */
    private Object getCellValue(Cell cell, DataFormatter formatter) {
        if (cell == null) {
            return null;
        }
        
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                // Check if the cell contains a date
                if (org.apache.poi.ss.usermodel.DateUtil.isCellDateFormatted(cell)) {
                    return cell.getDateCellValue();
                } else {
                    // Use DataFormatter to handle numeric values consistently
                    String formattedValue = formatter.formatCellValue(cell);
                    
                    // Try to convert to appropriate numeric type
                    try {
                        // Check if it's an integer value
                        double numericValue = cell.getNumericCellValue();
                        if (numericValue == Math.floor(numericValue)) {
                            if (numericValue <= Integer.MAX_VALUE && numericValue >= Integer.MIN_VALUE) {
                                return (int) numericValue;
                            } else {
                                return (long) numericValue;
                            }
                        } else {
                            return numericValue;
                        }
                    } catch (Exception e) {
                        // Fall back to string value
                        return formattedValue;
                    }
                }
            case BOOLEAN:
                return cell.getBooleanCellValue();
            case FORMULA:
                // Evaluate formulas to get actual value
                CellType formulaResultType = cell.getCachedFormulaResultType();
                switch (formulaResultType) {
                    case STRING:
                        return cell.getStringCellValue();
                    case NUMERIC:
                        if (org.apache.poi.ss.usermodel.DateUtil.isCellDateFormatted(cell)) {
                            return cell.getDateCellValue();
                        } else {
                            return cell.getNumericCellValue();
                        }
                    case BOOLEAN:
                        return cell.getBooleanCellValue();
                    default:
                        return formatter.formatCellValue(cell);
                }
            default:
                return formatter.formatCellValue(cell);
        }
    }
    
    /**
     * Gets the string value from a cell.
     * 
     * @param cell The cell to extract string value from
     * @return The cell value as string
     */
    private String getStringCellValue(Cell cell) {
        if (cell == null) {
            return "";
        }
        
        DataFormatter formatter = new DataFormatter();
        return formatter.formatCellValue(cell).trim();
    }
    
    /**
     * Applies filters to a row of data.
     * 
     * @param rowData The row data to filter
     * @return True if the row passes all filters, false otherwise
     */
    private boolean applyFilters(Map<String, Object> rowData) {
        if (filters.length == 0) {
            return true;
        }
        
        for (String filter : filters) {
            String[] parts = filter.split("=", 2);
            if (parts.length != 2) {
                continue;
            }
            
            String key = parts[0].trim();
            String value = parts[1].trim();
            
            Object cellValue = rowData.get(key);
            if (cellValue == null) {
                return false;
            }
            
            String cellValueStr = cellValue.toString();
            
            // Handle different filter types
            if (value.startsWith("regex:")) {
                // Regex filter
                String regex = value.substring(6);
                if (!cellValueStr.matches(regex)) {
                    return false;
                }
            } else if (value.startsWith("contains:")) {
                // Contains filter
                String substring = value.substring(9);
                if (!cellValueStr.contains(substring)) {
                    return false;
                }
            } else if (value.startsWith("startsWith:")) {
                // StartsWith filter
                String prefix = value.substring(11);
                if (!cellValueStr.startsWith(prefix)) {
                    return false;
                }
            } else if (value.startsWith("endsWith:")) {
                // EndsWith filter
                String suffix = value.substring(9);
                if (!cellValueStr.endsWith(suffix)) {
                    return false;
                }
            } else if (value.startsWith("gt:")) {
                // Greater than filter
                String numValue = value.substring(3);
                try {
                    double numCellValue = Double.parseDouble(cellValueStr);
                    double numFilterValue = Double.parseDouble(numValue);
                    if (numCellValue <= numFilterValue) {
                        return false;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            } else if (value.startsWith("lt:")) {
                // Less than filter
                String numValue = value.substring(3);
                try {
                    double numCellValue = Double.parseDouble(cellValueStr);
                    double numFilterValue = Double.parseDouble(numValue);
                    if (numCellValue >= numFilterValue) {
                        return false;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            } else {
                // Exact match filter
                if (!cellValueStr.equals(value)) {
                    return false;
                }
            }
        }
        
        return true;
    }
}


package com.cstestforge.framework.core.data.sources;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;
import com.cstestforge.framework.core.utils.CSTextUtils;

/**
 * Implementation of CSDataSource for CSV files.
 * Supports standard CSV format with customizable delimiter and quote character.
 */
public class CsvDataSource implements CSDataSource {

    private final String filePath;
    private final String[] filters;
    private final String[] parameters;
    private char delimiter = ',';
    private char quoteChar = '"';
    private boolean hasHeader = true;
    private int startRow = 1;
    private int endRow = -1;
    
    /**
     * Constructor for CsvDataSource.
     * 
     * @param filePath The path to the CSV file
     * @param filters Optional filters in format "key=value"
     * @param parameters Optional parameters for additional configuration
     */
    public CsvDataSource(String filePath, String[] filters, String[] parameters) {
        this.filePath = filePath;
        this.filters = filters != null ? filters : new String[0];
        this.parameters = parameters != null ? parameters : new String[0];
        
        parseParameters();
    }
    
    /**
     * Parses additional parameters.
     */
    private void parseParameters() {
        for (String param : parameters) {
            String[] parts = param.split("=", 2);
            if (parts.length != 2) {
                continue;
            }
            
            String key = parts[0].trim();
            String value = parts[1].trim();
            
            switch (key) {
                case "delimiter":
                    if (value.length() == 1) {
                        delimiter = value.charAt(0);
                    } else if (value.equals("\\t")) {
                        delimiter = '\t';
                    } else {
                        CSLogger.warn("Invalid delimiter value: " + value);
                    }
                    break;
                case "quoteChar":
                    if (value.length() == 1) {
                        quoteChar = value.charAt(0);
                    } else {
                        CSLogger.warn("Invalid quoteChar value: " + value);
                    }
                    break;
                case "hasHeader":
                    hasHeader = Boolean.parseBoolean(value);
                    break;
                case "startRow":
                    try {
                        startRow = Integer.parseInt(value);
                    } catch (NumberFormatException e) {
                        CSLogger.warn("Invalid startRow value: " + value);
                    }
                    break;
                case "endRow":
                    try {
                        endRow = Integer.parseInt(value);
                    } catch (NumberFormatException e) {
                        CSLogger.warn("Invalid endRow value: " + value);
                    }
                    break;
                default:
                    CSLogger.warn("Unknown parameter: " + key);
                    break;
            }
        }
    }
    
    /**
     * Loads data from the CSV file.
     * 
     * @return List of maps containing the data
     */
    @Override
    public List<Map<String, Object>> loadData() throws IOException {
        List<Map<String, Object>> result = new ArrayList<>();
        
        // Resolve the file path
        String resolvedPath = CSPathUtils.resolvePath(filePath);
        File file = new File(resolvedPath);
        
        if (!file.exists()) {
            throw new IOException("CSV file not found: " + resolvedPath);
        }
        
        List<String[]> csvData = readCsvFile(file);
        if (csvData.isEmpty()) {
            return result;
        }
        
        // Get header names
        String[] headerRow;
        int dataStartRow;
        
        if (hasHeader) {
            headerRow = csvData.get(0);
            dataStartRow = Math.max(1, startRow);
        } else {
            // Generate column names if no header
            headerRow = new String[csvData.get(0).length];
            for (int i = 0; i < headerRow.length; i++) {
                headerRow[i] = "Column" + (i + 1);
            }
            dataStartRow = Math.max(0, startRow);
        }
        
        // Calculate the end row if not specified
        int lastRow = endRow >= 0 ? Math.min(endRow, csvData.size() - 1) : csvData.size() - 1;
        
        // Process data rows
        for (int i = dataStartRow; i <= lastRow; i++) {
            if (i >= csvData.size()) {
                break;
            }
            
            String[] row = csvData.get(i);
            Map<String, Object> rowData = new HashMap<>();
            
            // Fill row data
            for (int j = 0; j < headerRow.length && j < row.length; j++) {
                String columnName = headerRow[j];
                String cellValue = row[j];
                Object convertedValue = convertValue(cellValue);
                rowData.put(columnName, convertedValue);
            }
            
            // Apply filters
            if (applyFilters(rowData)) {
                result.add(rowData);
            }
        }
        
        return result;
    }
    
    /**
     * Reads a CSV file into a list of string arrays.
     * 
     * @param file The CSV file to read
     * @return List of string arrays representing CSV rows
     */
    private List<String[]> readCsvFile(File file) throws IOException {
        List<String[]> lines = new ArrayList<>();
        
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] values = parseCsvLine(line);
                lines.add(values);
            }
        }
        
        return lines;
    }
    
    /**
     * Parses a CSV line, handling quoted fields and delimiters.
     * 
     * @param line The CSV line to parse
     * @return Array of field values
     */
    private String[] parseCsvLine(String line) {
        List<String> tokens = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        boolean inQuotes = false;
        
        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            
            if (c == quoteChar) {
                // Check for escaped quotes (doubled quotes)
                if (inQuotes && i + 1 < line.length() && line.charAt(i + 1) == quoteChar) {
                    sb.append(quoteChar);
                    i++; // Skip the next quote
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (c == delimiter && !inQuotes) {
                // End of field
                tokens.add(sb.toString());
                sb.setLength(0);
            } else {
                sb.append(c);
            }
        }
        
        // Add the last token
        tokens.add(sb.toString());
        
        return tokens.toArray(new String[0]);
    }
    
    /**
     * Converts a string value to an appropriate type.
     * 
     * @param value The string value to convert
     * @return The converted value
     */
    private Object convertValue(String value) {
        if (value == null || value.isEmpty()) {
            return null;
        }
        
        // Try to convert to a number
        try {
            // Check if it's an integer
            if (value.matches("-?\\d+")) {
                long longValue = Long.parseLong(value);
                if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) {
                    return (int) longValue;
                } else {
                    return longValue;
                }
            }
            
            // Check if it's a decimal number
            if (value.matches("-?\\d+\\.\\d+")) {
                return Double.parseDouble(value);
            }
        } catch (NumberFormatException e) {
            // Not a number, continue with string
        }
        
        // Check if it's a boolean
        if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) {
            return Boolean.parseBoolean(value);
        }
        
        // Return as string
        return value;
    }
    
    /**
     * Applies filters to a row of data.
     * 
     * @param rowData The row data to filter
     * @return True if the row passes all filters, false otherwise
     */
    private boolean applyFilters(Map<String, Object> rowData) {
        if (filters.length == 0) {
            return true;
        }
        
        for (String filter : filters) {
            String[] parts = filter.split("=", 2);
            if (parts.length != 2) {
                continue;
            }
            
            String key = parts[0].trim();
            String value = parts[1].trim();
            
            Object cellValue = rowData.get(key);
            if (cellValue == null) {
                if (!value.equals("null") && !value.isEmpty()) {
                    return false;
                }
                continue;
            }
            
            String cellValueStr = cellValue.toString();
            
            // Handle different filter types
            if (value.startsWith("regex:")) {
                // Regex filter
                String regex = value.substring(6);
                if (!cellValueStr.matches(regex)) {
                    return false;
                }
            } else if (value.startsWith("contains:")) {
                // Contains filter
                String substring = value.substring(9);
                if (!cellValueStr.contains(substring)) {
                    return false;
                }
            } else if (value.startsWith("startsWith:")) {
                // StartsWith filter
                String prefix = value.substring(11);
                if (!cellValueStr.startsWith(prefix)) {
                    return false;
                }
            } else if (value.startsWith("endsWith:")) {
                // EndsWith filter
                String suffix = value.substring(9);
                if (!cellValueStr.endsWith(suffix)) {
                    return false;
                }
            } else if (value.startsWith("gt:")) {
                // Greater than filter
                String numValue = value.substring(3);
                try {
                    double numCellValue = Double.parseDouble(cellValueStr);
                    double numFilterValue = Double.parseDouble(numValue);
                    if (numCellValue <= numFilterValue) {
                        return false;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            } else if (value.startsWith("lt:")) {
                // Less than filter
                String numValue = value.substring(3);
                try {
                    double numCellValue = Double.parseDouble(cellValueStr);
                    double numFilterValue = Double.parseDouble(numValue);
                    if (numCellValue >= numFilterValue) {
                        return false;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            } else {
                // Exact match filter
                if (!cellValueStr.equals(value)) {
                    return false;
                }
            }
        }
        
        return true;
    }
}


package com.cstestforge.framework.core.data.sources;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;

/**
 * Implementation of CSDataSource for JSON files.
 * Supports both JSON arrays and objects with configurable path extraction.
 */
public class JsonDataSource implements CSDataSource {

    private final String filePath;
    private final String[] filters;
    private final String[] parameters;
    private String dataPath = "";
    private boolean flattenObjects = false;
    
    /**
     * Constructor for JsonDataSource.
     * 
     * @param filePath The path to the JSON file
     * @param filters Optional filters in format "key=value"
     * @param parameters Optional parameters for additional configuration
     */
    public JsonDataSource(String filePath, String[] filters, String[] parameters) {
        this.filePath = filePath;
        this.filters = filters != null ? filters : new String[0];
        this.parameters = parameters != null ? parameters : new String[0];
        
        parseParameters();
    }
    
    /**
     * Parses additional parameters.
     */
    private void parseParameters() {
        for (String param : parameters) {
            String[] parts = param.split("=", 2);
            if (parts.length != 2) {
                continue;
            }
            
            String key = parts[0].trim();
            String value = parts[1].trim();
            
            switch (key) {
                case "dataPath":
                    dataPath = value;
                    break;
                case "flattenObjects":
                    flattenObjects = Boolean.parseBoolean(value);
                    break;
                default:
                    CSLogger.warn("Unknown parameter: " + key);
                    break;
            }
        }
    }
    
    /**
     * Loads data from the JSON file.
     * 
     * @return List of maps containing the data
     */
    @Override
    public List<Map<String, Object>> loadData() throws IOException {
        List<Map<String, Object>> result = new ArrayList<>();
        
        // Resolve the file path
        String resolvedPath = CSPathUtils.resolvePath(filePath);
        File file = new File(resolvedPath);
        
        if (!file.exists()) {
            throw new IOException("JSON file not found: " + resolvedPath);
        }
        
        try (Reader reader = new FileReader(file)) {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode rootNode = mapper.readTree(reader);
            
            // Extract data based on path
            JsonNode dataNode = extractDataNode(rootNode);
            
            // Convert to list of maps
            if (dataNode.isArray()) {
                ArrayNode arrayNode = (ArrayNode) dataNode;
                for (JsonNode node : arrayNode) {
                    Map<String, Object> rowData = convertNodeToMap(node);
                    if (applyFilters(rowData)) {
                        result.add(rowData);
                    }
                }
            } else if (dataNode.isObject()) {
                if (flattenObjects) {
                    // Treat each field as a separate row with the field name as a column
                    Iterator<Map.Entry<String, JsonNode>> fields = dataNode.fields();
                    while (fields.hasNext()) {
                        Map.Entry<String, JsonNode> field = fields.next();
                        Map<String, Object> rowData = new HashMap<>();
                        rowData.put("key", field.getKey());
                        
                        JsonNode value = field.getValue();
                        if (value.isObject()) {
                            // Add all fields from the object
                            Map<String, Object> valueMap = convertNodeToMap(value);
                            rowData.putAll(valueMap);
                        } else {
                            // Add the value with a default column name
                            rowData.put("value", convertJsonValue(value));
                        }
                        
                        if (applyFilters(rowData)) {
                            result.add(rowData);
                        }
                    }
                } else {
                    // Treat the object as a single row
                    Map<String, Object> rowData = convertNodeToMap(dataNode);
                    if (applyFilters(rowData)) {
                        result.add(rowData);
                    }
                }
            }
        } catch (Exception e) {
            CSLogger.error("Error reading JSON file: " + resolvedPath, e);
            throw new IOException("Error reading JSON file: " + e.getMessage(), e);
        }
        
        return result;
    }
    
    /**
     * Extracts a JSON node based on the specified path.
     * 
     * @param rootNode The root JSON node
     * @return The extracted data node
     */
    private JsonNode extractDataNode(JsonNode rootNode) {
        if (dataPath == null || dataPath.isEmpty()) {
            return rootNode;
        }
        
        // Split the path by dots or brackets
        String[] pathParts = dataPath.split("\\.|\\[|\\]");
        
        JsonNode currentNode = rootNode;
        for (String part : pathParts) {
            part = part.trim();
            if (part.isEmpty()) {
                continue;
            }
            
            // Check if part is an array index
            if (part.matches("\\d+")) {
                int index = Integer.parseInt(part);
                if (currentNode.isArray() && index < currentNode.size()) {
                    currentNode = currentNode.get(index);
                } else {
                    CSLogger.warn("Invalid array index in path: " + part);
                    return rootNode;
                }
            } else {
                // Part is an object field
                if (currentNode.has(part)) {
                    currentNode = currentNode.get(part);
                } else {
                    CSLogger.warn("Field not found in JSON: " + part);
                    return rootNode;
                }
            }
        }
        
        return currentNode;
    }
    
    /**
     * Converts a JSON node to a map.
     * 
     * @param node The JSON node to convert
     * @return A map representation of the node
     */
    private Map<String, Object> convertNodeToMap(JsonNode node) {
        Map<String, Object> map = new HashMap<>();
        
        Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> field = fields.next();
            String key = field.getKey();
            JsonNode value = field.getValue();
            
            map.put(key, convertJsonValue(value));
        }
        
        return map;
    }
    
    /**
     * Converts a JSON value to a Java object.
     * 
     * @param node The JSON node to convert
     * @return The converted Java object
     */
    private Object convertJsonValue(JsonNode node) {
        if (node.isNull()) {
            return null;
        } else if (node.isTextual()) {
            return node.asText();
        } else if (node.isInt()) {
            return node.asInt();
        } else if (node.isLong()) {
            return node.asLong();
        } else if (node.isDouble()) {
            return node.asDouble();
        } else if (node.isBoolean()) {
            return node.asBoolean();
        } else if (node.isObject()) {
            // Convert nested objects to maps
            return convertNodeToMap(node);
        } else if (node.isArray()) {
            // Convert arrays to lists
            List<Object> list = new ArrayList<>();
            for (JsonNode element : node) {
                list.add(convertJsonValue(element));
            }
            return list;
        } else {
            // Default to string representation
            return node.toString();
        }
    }
    
    /**
     * Applies filters to a row of data.
     * 
     * @param rowData The row data to filter
     * @return True if the row passes all filters, false otherwise
     */
    private boolean applyFilters(Map<String, Object> rowData) {
        if (filters.length == 0) {
            return true;
        }
        
        for (String filter : filters) {
            String[] parts = filter.split("=", 2);
            if (parts.length != 2) {
                continue;
            }
            
            String key = parts[0].trim();
            String value = parts[1].trim();
            
            // Handle nested keys with dot notation
            Object cellValue = getNestedValue(rowData, key);
            if (cellValue == null) {
                if (!value.equals("null") && !value.isEmpty()) {
                    return false;
                }
                continue;
            }
            
            String cellValueStr = cellValue.toString();
            
            // Handle different filter types
            if (value.startsWith("regex:")) {
                // Regex filter
                String regex = value.substring(6);
                if (!cellValueStr.matches(regex)) {
                    return false;
                }
            } else if (value.startsWith("contains:")) {
                // Contains filter
                String substring = value.substring(9);
                if (!cellValueStr.contains(substring)) {
                    return false;
                }
            } else if (value.startsWith("startsWith:")) {
                // StartsWith filter
                String prefix = value.substring(11);
                if (!cellValueStr.startsWith(prefix)) {
                    return false;
                }
            } else if (value.startsWith("endsWith:")) {
                // EndsWith filter
                String suffix = value.substring(9);
                if (!cellValueStr.endsWith(suffix)) {
                    return false;
                }
            } else if (value.startsWith("gt:")) {
                // Greater than filter
                String numValue = value.substring(3);
                try {
                    double numCellValue = Double.parseDouble(cellValueStr);
                    double numFilterValue = Double.parseDouble(numValue);
                    if (numCellValue <= numFilterValue) {
                        return false;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            } else if (value.startsWith("lt:")) {
                // Less than filter
                String numValue = value.substring(3);
                try {
                    double numCellValue = Double.parseDouble(cellValueStr);
                    double numFilterValue = Double.parseDouble(numValue);
                    if (numCellValue >= numFilterValue) {
                        return false;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            } else {
                // Exact match filter
                if (!cellValueStr.equals(value)) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    /**
     * Gets a nested value from a map using dot notation.
     * 
     * @param data The map to get value from
     * @param key The key with optional dot notation for nested values
     * @return The value or null if not found
     */
    @SuppressWarnings("unchecked")
    private Object getNestedValue(Map<String, Object> data, String key) {
        if (!key.contains(".")) {
            return data.get(key);
        }
        
        String[] parts = key.split("\\.", 2);
        String firstKey = parts[0];
        String remainingKey = parts[1];
        
        Object value = data.get(firstKey);
        if (value instanceof Map) {
            return getNestedValue((Map<String, Object>) value, remainingKey);
        } else {
            return null;
        }
    }
}


package com.cstestforge.framework.core.data.sources;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSEncryptionUtils;
import com.cstestforge.framework.core.utils.CSLogger;

/**
 * Implementation of CSDataSource for database connections.
 * Supports various database types with configurable connection parameters.
 */
public class DatabaseDataSource implements CSDataSource {

    private final String query;
    private final String[] filters;
    private final String[] parameters;
    private String driverClass;
    private String connectionUrl;
    private String username;
    private String password;
    private int maxRows = 1000;
    private int queryTimeout = 60;
    private boolean usePreparedStatement = false;
    private Object[] preparedValues;
    
    /**
     * Constructor for DatabaseDataSource.
     * 
     * @param query The SQL query
     * @param filters Optional filters in format "key=value"
     * @param parameters Optional parameters for additional configuration
     */
    public DatabaseDataSource(String query, String[] filters, String[] parameters) {
        this.query = query;
        this.filters = filters != null ? filters : new String[0];
        this.parameters = parameters != null ? parameters : new String[0];
        
        parseParameters();
        
        // Load default connection info if not specified
        loadDefaultConnectionInfo();
    }
    
    /**
     * Parses additional parameters.
     */
    private void parseParameters() {
        for (String param : parameters) {
            String[] parts = param.split("=", 2);
            if (parts.length != 2) {
                continue;
            }
            
            String key = parts[0].trim();
            String value = parts[1].trim();
            
            switch (key) {
                case "driver":
                    driverClass = value;
                    break;
                case "url":
                    connectionUrl = value;
                    break;
                case "username":
                    username = value;
                    break;
                case "password":
                    // Password might be encrypted
                    try {
                        password = CSEncryptionUtils.decrypt(value);
                    } catch (Exception e) {
                        // If decryption fails, use the value as-is
                        password = value;
                    }
                    break;
                case "maxRows":
                    try {
                        maxRows = Integer.parseInt(value);
                    } catch (NumberFormatException e) {
                        CSLogger.warn("Invalid maxRows value: " + value);
                    }
                    break;
                case "queryTimeout":
                    try {
                        queryTimeout = Integer.parseInt(value);
                    } catch (NumberFormatException e) {
                        CSLogger.warn("Invalid queryTimeout value: " + value);
                    }
                    break;
                case "usePreparedStatement":
                    usePreparedStatement = Boolean.parseBoolean(value);
                    break;
                case "preparedValues":
                    // Format: "value1,value2,value3" or "value1|value2|value3"
                    String[] values = value.contains("|") ? value.split("\\|") : value.split(",");
                    preparedValues = new Object[values.length];
                    for (int i = 0; i < values.length; i++) {
                        preparedValues[i] = values[i].trim();
                    }
                    break;
                default:
                    CSLogger.warn("Unknown parameter: " + key);
                    break;
            }
        }
    }
    
    /**
     * Loads default connection information from configuration.
     */
    private void loadDefaultConnectionInfo() {
        if (driverClass == null || connectionUrl == null) {
            ConfigurationManager config = ConfigurationManager.getInstance();
            
            // Try to load database configuration
            if (driverClass == null) {
                driverClass = config.getProperty("database.driver");
            }
            
            if (connectionUrl == null) {
                connectionUrl = config.getProperty("database.url");
            }
            
            if (username == null) {
                username = config.getProperty("database.username");
            }
            
            if (password == null) {
                String encryptedPassword = config.getProperty("database.password");
                if (encryptedPassword != null) {
                    try {
                        password = CSEncryptionUtils.decrypt(encryptedPassword);
                    } catch (Exception e) {
                        // If decryption fails, use the value as-is
                        password = encryptedPassword;
                    }
                }
            }
        }
        
        // Validate required fields
        if (driverClass == null || driverClass.isEmpty()) {
            throw new IllegalArgumentException("Database driver class is required. Specify it in parameters or configuration.");
        }
        
        if (connectionUrl == null || connectionUrl.isEmpty()) {
            throw new IllegalArgumentException("Database connection URL is required. Specify it in parameters or configuration.");
        }
    }
    
    /**
     * Loads data from the database.
     * 
     * @return List of maps containing the data
     */
    @Override
    public List<Map<String, Object>> loadData() throws IOException {
        List<Map<String, Object>> result = new ArrayList<>();
        
        if (query == null || query.trim().isEmpty()) {
            throw new IOException("SQL query is required");
        }
        
        Connection connection = null;
        PreparedStatement prepStmt = null;
        Statement stmt = null;
        ResultSet resultSet = null;
        
        try {
            // Load the JDBC driver
            Class.forName(driverClass);
            
            // Create connection properties
            Properties props = new Properties();
            if (username != null) {
                props.setProperty("user", username);
            }
            if (password != null) {
                props.setProperty("password", password);
            }
            
            // Connect to the database
            connection = DriverManager.getConnection(connectionUrl, props);
            
            // Create statement
            if (usePreparedStatement) {
                prepStmt = connection.prepareStatement(query);
                prepStmt.setQueryTimeout(queryTimeout);
                prepStmt.setMaxRows(maxRows);
                
                // Set prepared statement parameters if provided
                if (preparedValues != null) {
                    for (int i = 0; i < preparedValues.length; i++) {
                        setPreparedParameter(prepStmt, i + 1, preparedValues[i]);
                    }
                }
                
                resultSet = prepStmt.executeQuery();
            } else {
                stmt = connection.createStatement();
                stmt.setQueryTimeout(queryTimeout);
                stmt.setMaxRows(maxRows);
                
                resultSet = stmt.executeQuery(query);
            }
            
            // Process the result set
            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();
            
            // Get column names
            String[] columnNames = new String[columnCount];
            for (int i = 0; i < columnCount; i++) {
                columnNames[i] = metaData.getColumnLabel(i + 1);
                if (columnNames[i] == null || columnNames[i].isEmpty()) {
                    columnNames[i] = metaData.getColumnName(i + 1);
                }
            }
            
            // Process data rows
            while (resultSet.next()) {
                Map<String, Object> rowData = new HashMap<>();
                
                // Fill row data
                for (int i = 0; i < columnCount; i++) {
                    String columnName = columnNames[i];
                    Object value = getColumnValue(resultSet, i + 1, metaData.getColumnType(i + 1));
                    rowData.put(columnName, value);
                }
                
                // Apply filters
                if (applyFilters(rowData)) {
                    result.add(rowData);
                }
            }
        } catch (ClassNotFoundException e) {
            CSLogger.error("Database driver not found: " + driverClass, e);
            throw new IOException("Database driver not found: " + e.getMessage(), e);
        } catch (SQLException e) {
            CSLogger.error("Database error: " + e.getMessage(), e);
            throw new IOException("Database error: " + e.getMessage(), e);
        } finally {
            // Close resources
            try {
                if (resultSet != null) resultSet.close();
                if (prepStmt != null) prepStmt.close();
                if (stmt != null) stmt.close();
                if (connection != null) connection.close();
            } catch (SQLException e) {
                CSLogger.warn("Error closing database resources", e);
            }
        }
        
        return result;
    }
    
    /**
     * Sets a parameter in a prepared statement.
     * 
     * @param stmt The prepared statement
     * @param index The parameter index (1-based)
     * @param value The parameter value
     * @throws SQLException If an error occurs
     */
    private void setPreparedParameter(PreparedStatement stmt, int index, Object value) throws SQLException {
        if (value == null) {
            stmt.setNull(index, Types.VARCHAR);
            return;
        }
        
        // String special cases
        if (value instanceof String) {
            String strValue = (String) value;
            
            // Handle special value types
            if (strValue.startsWith("date:")) {
                String dateStr = strValue.substring(5).trim();
                try {
                    java.sql.Date date = java.sql.Date.valueOf(dateStr);
                    stmt.setDate(index, date);
                    return;
                } catch (IllegalArgumentException e) {
                    throw new SQLException("Invalid date format: " + dateStr + ". Expected format: yyyy-MM-dd");
                }
            } else if (strValue.startsWith("timestamp:")) {
                String timestampStr = strValue.substring(10).trim();
                try {
                    java.sql.Timestamp timestamp = java.sql.Timestamp.valueOf(timestampStr);
                    stmt.setTimestamp(index, timestamp);
                    return;
                } catch (IllegalArgumentException e) {
                    throw new SQLException("Invalid timestamp format: " + timestampStr + 
                                          ". Expected format: yyyy-MM-dd HH:mm:ss[.nnn]");
                }
            } else if (strValue.startsWith("time:")) {
                String timeStr = strValue.substring(5).trim();
                try {
                    java.sql.Time time = java.sql.Time.valueOf(timeStr);
                    stmt.setTime(index, time);
                    return;
                } catch (IllegalArgumentException e) {
                    throw new SQLException("Invalid time format: " + timeStr + ". Expected format: HH:mm:ss");
                }
            } else if (strValue.equals("null")) {
                stmt.setNull(index, Types.VARCHAR);
                return;
            }
            
            // Regular string
            stmt.setString(index, strValue);
            return;
        }
        
        // Handle basic Java types
        if (value instanceof Integer) {
            stmt.setInt(index, (Integer) value);
        } else if (value instanceof Long) {
            stmt.setLong(index, (Long) value);
        } else if (value instanceof Double) {
            stmt.setDouble(index, (Double) value);
        } else if (value instanceof Float) {
            stmt.setFloat(index, (Float) value);
        } else if (value instanceof Boolean) {
            stmt.setBoolean(index, (Boolean) value);
        } else if (value instanceof java.sql.Date) {
            stmt.setDate(index, (java.sql.Date) value);
        } else if (value instanceof java.sql.Timestamp) {
            stmt.setTimestamp(index, (java.sql.Timestamp) value);
        } else if (value instanceof java.sql.Time) {
            stmt.setTime(index, (java.sql.Time) value);
        } else if (value instanceof byte[]) {
            stmt.setBytes(index, (byte[]) value);
        } else {
            // Default to string
            stmt.setString(index, value.toString());
        }
    }
    
    /**
     * Gets a column value from a result set.
     * 
     * @param rs The result set
     * @param columnIndex The column index (1-based)
     * @param sqlType The SQL type of the column
     * @return The column value
     * @throws SQLException If an error occurs
     */
    private Object getColumnValue(ResultSet rs, int columnIndex, int sqlType) throws SQLException {
        // Handle null values
        if (rs.getObject(columnIndex) == null) {
            return null;
        }
        
        // Handle different SQL types
        switch (sqlType) {
            case Types.INTEGER:
            case Types.SMALLINT:
            case Types.TINYINT:
                return rs.getInt(columnIndex);
                
            case Types.BIGINT:
                return rs.getLong(columnIndex);
                
            case Types.FLOAT:
            case Types.REAL:
                return rs.getFloat(columnIndex);
                
            case Types.DOUBLE:
            case Types.DECIMAL:
            case Types.NUMERIC:
                return rs.getDouble(columnIndex);
                
            case Types.BOOLEAN:
            case Types.BIT:
                return rs.getBoolean(columnIndex);
                
            case Types.CHAR:
            case Types.VARCHAR:
            case Types.LONGVARCHAR:
            case Types.NCHAR:
            case Types.NVARCHAR:
            case Types.LONGNVARCHAR:
                return rs.getString(columnIndex);
                
            case Types.DATE:
                return rs.getDate(columnIndex);
                
            case Types.TIME:
                return rs.getTime(columnIndex);
                
            case Types.TIMESTAMP:
                return rs.getTimestamp(columnIndex);
                
            case Types.BINARY:
            case Types.VARBINARY:
            case Types.LONGVARBINARY:
                return rs.getBytes(columnIndex);
                
            case Types.BLOB:
                return rs.getBlob(columnIndex).getBytes(1, (int) rs.getBlob(columnIndex).length());
                
            case Types.CLOB:
            case Types.NCLOB:
                return rs.getString(columnIndex);
                
            default:
                // Default to string for unknown types
                return rs.getString(columnIndex);
        }
    }
    
    /**
     * Applies filters to a row of data.
     * 
     * @param rowData The row data to filter
     * @return True if the row passes all filters, false otherwise
     */
    private boolean applyFilters(Map<String, Object> rowData) {
        if (filters.length == 0) {
            return true;
        }
        
        for (String filter : filters) {
            String[] parts = filter.split("=", 2);
            if (parts.length != 2) {
                continue;
            }
            
            String key = parts[0].trim();
            String value = parts[1].trim();
            
            Object cellValue = rowData.get(key);
            if (cellValue == null) {
                if (!value.equals("null") && !value.isEmpty()) {
                    return false;
                }
                continue;
            }
            
            String cellValueStr = cellValue.toString();
            
            // Handle different filter types
            if (value.startsWith("regex:")) {
                // Regex filter
                String regex = value.substring(6);
                if (!cellValueStr.matches(regex)) {
                    return false;
                }
            } else if (value.startsWith("contains:")) {
                // Contains filter
                String substring = value.substring(9);
                if (!cellValueStr.contains(substring)) {
                    return false;
                }
            } else if (value.startsWith("startsWith:")) {
                // StartsWith filter
                String prefix = value.substring(11);
                if (!cellValueStr.startsWith(prefix)) {
                    return false;
                }
            } else if (value.startsWith("endsWith:")) {
                // EndsWith filter
                String suffix = value.substring(9);
                if (!cellValueStr.endsWith(suffix)) {
                    return false;
                }
            } else if (value.startsWith("gt:")) {
                // Greater than filter
                String numValue = value.substring(3);
                try {
                    double numCellValue = Double.parseDouble(cellValueStr);
                    double numFilterValue = Double.parseDouble(numValue);
                    if (numCellValue <= numFilterValue) {
                        return false;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            } else if (value.startsWith("lt:")) {
                // Less than filter
                String numValue = value.substring(3);
                try {
                    double numCellValue = Double.parseDouble(cellValueStr);
                    double numFilterValue = Double.parseDouble(numValue);
                    if (numCellValue >= numFilterValue) {
                        return false;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            } else if (value.startsWith("between:")) {
                // Between filter (inclusive)
                String betweenValue = value.substring(8);
                String[] bounds = betweenValue.split(",");
                if (bounds.length != 2) {
                    return false;
                }
                
                try {
                    double numCellValue = Double.parseDouble(cellValueStr);
                    double lowerBound = Double.parseDouble(bounds[0].trim());
                    double upperBound = Double.parseDouble(bounds[1].trim());
                    if (numCellValue < lowerBound || numCellValue > upperBound) {
                        return false;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            } else if (value.startsWith("in:")) {
                // In filter
                String inValue = value.substring(3);
                String[] options = inValue.split(",");
                boolean found = false;
                
                for (String option : options) {
                    if (cellValueStr.equals(option.trim())) {
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    return false;
                }
            } else {
                // Exact match filter
                if (!cellValueStr.equals(value)) {
                    return false;
                }
            }
        }
        
        return true;
    }
}


package com.cstestforge.framework.core.data;

import java.util.HashMap;
import java.util.Map;
import java.util.ServiceLoader;

import com.cstestforge.framework.core.data.sources.CSDataSource;
import com.cstestforge.framework.core.data.sources.CsvDataSource;
import com.cstestforge.framework.core.data.sources.DatabaseDataSource;
import com.cstestforge.framework.core.data.sources.ExcelDataSource;
import com.cstestforge.framework.core.data.sources.JsonDataSource;
import com.cstestforge.framework.core.utils.CSLogger;

/**
 * Factory for creating data sources based on type.
 * Supports built-in data sources and custom data sources via ServiceLoader.
 */
public class CSDataSourceFactory {
    
    // Map of built-in data source types to their implementation classes
    private static final Map<String, Class<? extends CSDataSource>> BUILTIN_DATA_SOURCES = new HashMap<>();
    
    // Map of custom data source types registered at runtime
    private static final Map<String, Class<? extends CSDataSource>> CUSTOM_DATA_SOURCES = new HashMap<>();
    
    // Initialize built-in data sources
    static {
        // Register built-in data sources
        BUILTIN_DATA_SOURCES.put("excel", ExcelDataSource.class);
        BUILTIN_DATA_SOURCES.put("xls", ExcelDataSource.class);
        BUILTIN_DATA_SOURCES.put("xlsx", ExcelDataSource.class);
        BUILTIN_DATA_SOURCES.put("csv", CsvDataSource.class);
        BUILTIN_DATA_SOURCES.put("json", JsonDataSource.class);
        BUILTIN_DATA_SOURCES.put("db", DatabaseDataSource.class);
        BUILTIN_DATA_SOURCES.put("database", DatabaseDataSource.class);
        BUILTIN_DATA_SOURCES.put("sql", DatabaseDataSource.class);
        
        // Load custom data sources via ServiceLoader
        loadCustomDataSources();
    }
    
    /**
     * Loads custom data sources using ServiceLoader.
     */
    private static void loadCustomDataSources() {
        try {
            ServiceLoader<CSDataSource> loader = ServiceLoader.load(CSDataSource.class);
            for (CSDataSource dataSource : loader) {
                // Get data source type from provider annotation or class name
                String type = getDataSourceType(dataSource.getClass());
                
                if (type != null && !type.isEmpty()) {
                    CUSTOM_DATA_SOURCES.put(type.toLowerCase(), dataSource.getClass());
                    CSLogger.info("Loaded custom data source: " + type + " -> " + dataSource.getClass().getName());
                }
            }
        } catch (Exception e) {
            CSLogger.warn("Failed to load custom data sources", e);
        }
    }
    
    /**
     * Gets the data source type from a class.
     * Looks for DataSourceProvider annotation or falls back to class name.
     * 
     * @param clazz The data source class
     * @return The data source type
     */
    private static String getDataSourceType(Class<? extends CSDataSource> clazz) {
        // Check for DataSourceProvider annotation
        if (clazz.isAnnotationPresent(DataSourceProvider.class)) {
            DataSourceProvider annotation = clazz.getAnnotation(DataSourceProvider.class);
            return annotation.value();
        }
        
        // Fall back to class name without "DataSource" suffix
        String className = clazz.getSimpleName();
        if (className.endsWith("DataSource")) {
            return className.substring(0, className.length() - "DataSource".length()).toLowerCase();
        }
        
        return className.toLowerCase();
    }
    
    /**
     * Creates a data source based on the specified type.
     * 
     * @param source The data source type
     * @param path The path to the data source
     * @param filters Optional filters to apply
     * @param parameters Optional parameters for additional configuration
     * @return The created data source
     * @throws IllegalArgumentException If the data source type is not supported
     */
    public static CSDataSource createDataSource(String source, String path, String[] filters, String[] parameters) {
        if (source == null || source.isEmpty()) {
            throw new IllegalArgumentException("Data source type cannot be null or empty");
        }
        
        // Convert source to lowercase for case-insensitive matching
        String sourceType = source.toLowerCase();
        
        // Try to infer type from path if source is "auto"
        if ("auto".equals(sourceType) && path != null && !path.isEmpty()) {
            sourceType = inferTypeFromPath(path);
        }
        
        // Check if it's a built-in data source
        Class<? extends CSDataSource> dataSourceClass = BUILTIN_DATA_SOURCES.get(sourceType);
        
        // If not found, check custom data sources
        if (dataSourceClass == null) {
            dataSourceClass = CUSTOM_DATA_SOURCES.get(sourceType);
        }
        
        // If still not found, throw an exception
        if (dataSourceClass == null) {
            throw new IllegalArgumentException("Unsupported data source type: " + source);
        }
        
        try {
            // Special handling for database data source
            if (dataSourceClass.equals(DatabaseDataSource.class)) {
                return new DatabaseDataSource(path, filters, parameters);
            }
            
            // Create instance through constructor
            return dataSourceClass.getConstructor(String.class, String[].class, String[].class)
                    .newInstance(path, filters, parameters);
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException("Data source class must have a constructor with (String, String[], String[]) parameters", e);
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to create data source instance", e);
        }
    }
    
    /**
     * Infers the data source type from a path.
     * 
     * @param path The path to the data source
     * @return The inferred data source type
     */
    private static String inferTypeFromPath(String path) {
        if (path == null || path.isEmpty()) {
            return "csv"; // Default to CSV
        }
        
        String lowercasePath = path.toLowerCase();
        
        // Check for file extensions
        if (lowercasePath.endsWith(".xlsx") || lowercasePath.endsWith(".xls")) {
            return "excel";
        } else if (lowercasePath.endsWith(".csv")) {
            return "csv";
        } else if (lowercasePath.endsWith(".json")) {
            return "json";
        } else if (lowercasePath.contains("jdbc:") || lowercasePath.startsWith("SELECT ") || 
                  lowercasePath.startsWith("select ") || lowercasePath.contains(" FROM ") || 
                  lowercasePath.contains(" from ")) {
            return "database";
        }
        
        // Default to CSV
        return "csv";
    }
    
    /**
     * Registers a custom data source type.
     * 
     * @param type The data source type
     * @param dataSourceClass The data source class
     */
    public static void registerDataSource(String type, Class<? extends CSDataSource> dataSourceClass) {
        if (type == null || type.isEmpty()) {
            throw new IllegalArgumentException("Data source type cannot be null or empty");
        }
        
        if (dataSourceClass == null) {
            throw new IllegalArgumentException("Data source class cannot be null");
        }
        
        // Check if the class has the required constructor
        try {
            dataSourceClass.getConstructor(String.class, String[].class, String[].class);
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException("Data source class must have a constructor with (String, String[], String[]) parameters", e);
        }
        
        // Convert type to lowercase for case-insensitive matching
        String lowerType = type.toLowerCase();
        
        // Register the data source
        CUSTOM_DATA_SOURCES.put(lowerType, dataSourceClass);
        CSLogger.info("Registered custom data source: " + lowerType + " -> " + dataSourceClass.getName());
    }
    
    /**
     * Gets all registered data source types.
     * 
     * @return Array of registered data source types
     */
    public static String[] getRegisteredDataSourceTypes() {
        // Combine built-in and custom data sources
        Map<String, Class<? extends CSDataSource>> allDataSources = new HashMap<>();
        allDataSources.putAll(BUILTIN_DATA_SOURCES);
        allDataSources.putAll(CUSTOM_DATA_SOURCES);
        
        return allDataSources.keySet().toArray(new String[0]);
    }
}



package com.cstestforge.framework.core.data;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for data source provider classes.
 * Used to specify the type of a custom data source.
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface DataSourceProvider {
    
    /**
     * The type identifier for the data source.
     * This will be used when specifying the source type in data providers.
     * 
     * @return The type identifier for the data source
     */
    String value();
    
    /**
     * Optional description of the data source.
     * 
     * @return Description of the data source
     */
    String description() default "";
    
    /**
     * Optional version of the data source.
     * 
     * @return Version of the data source
     */
    String version() default "1.0";
    
    /**
     * Optional author of the data source.
     * 
     * @return Author of the data source
     */
    String author() default "";
    
    /**
     * Whether the data source supports filtering.
     * 
     * @return True if the data source supports filtering, false otherwise
     */
    boolean supportsFiltering() default true;
    
    /**
     * Whether the data source supports parameters.
     * 
     * @return True if the data source supports parameters, false otherwise
     */
    boolean supportsParameters() default true;
    
    /**
     * Supported parameter names for this data source.
     * 
     * @return Array of supported parameter names
     */
    String[] supportedParameters() default {};
}




package com.cstestforge.framework.core.data.sources;

import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Interface for all data sources in the CSTestForge framework.
 * Implementations provide data from various sources (Excel, CSV, JSON, database, etc.)
 * for data-driven testing.
 */
public interface CSDataSource {
    
    /**
     * Loads data from the data source.
     * 
     * @return List of maps containing the data, where each map represents a row
     * and map keys are column names
     * @throws IOException If an error occurs while loading the data
     */
    List<Map<String, Object>> loadData() throws IOException;
    
    /**
     * Optional method to check if the data source is available.
     * Default implementation returns true.
     * 
     * @return True if the data source is available, false otherwise
     */
    default boolean isAvailable() {
        return true;
    }
    
    /**
     * Optional method to get the total number of data rows.
     * Default implementation returns -1, indicating unknown row count.
     * 
     * @return The total number of data rows, or -1 if unknown
     */
    default int getTotalRowCount() {
        return -1;
    }
    
    /**
     * Optional method to get column names.
     * Default implementation returns null, indicating that column names
     * are only available after loading the data.
     * 
     * @return Array of column names, or null if not available without loading
     */
    default String[] getColumnNames() {
        return null;
    }
    
    /**
     * Optional method to get sample data without loading all data.
     * Default implementation returns null, indicating that sample data
     * is not available without loading all data.
     * 
     * @param sampleSize The number of sample rows to retrieve
     * @return List of maps containing the sample data, or null if not supported
     * @throws IOException If an error occurs while retrieving the sample data
     */
    default List<Map<String, Object>> getSampleData(int sampleSize) throws IOException {
        return null;
    }
    
    /**
     * Optional method to validate the data source.
     * Default implementation returns true.
     * 
     * @return True if the data source is valid, false otherwise
     */
    default boolean validate() {
        return true;
    }
    
    /**
     * Optional method to get validation errors.
     * Default implementation returns null.
     * 
     * @return Array of validation error messages, or null if no validation errors
     */
    default String[] getValidationErrors() {
        return null;
    }
    
    /**
     * Optional method to close the data source and release resources.
     * Default implementation does nothing.
     */
    default void close() {
        // Default implementation does nothing
    }
    
    /**
     * Optional method to get the data source type.
     * Default implementation uses class name without "DataSource" suffix.
     * 
     * @return The data source type
     */
    default String getType() {
        String className = getClass().getSimpleName();
        if (className.endsWith("DataSource")) {
            return className.substring(0, className.length() - "DataSource".length()).toLowerCase();
        }
        return className.toLowerCase();
    }
    
    /**
     * Optional method to get metadata about the data source.
     * Default implementation returns null.
     * 
     * @return Map of metadata, or null if not available
     */
    default Map<String, Object> getMetadata() {
        return null;
    }
}



package com.cstestforge.framework.core.reporting;

import java.io.File;
import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 * Core reporting interface for the CSTestForge framework.
 * Defines methods for generating and managing test reports.
 */
public interface CSReporter {
    
    /**
     * Starts a new test suite.
     * 
     * @param suiteName The name of the test suite
     * @param description Optional description of the test suite
     * @return The ID of the created test suite
     */
    String startTestSuite(String suiteName, String description);
    
    /**
     * Starts a new test suite with additional attributes.
     * 
     * @param suiteName The name of the test suite
     * @param description Optional description of the test suite
     * @param attributes Additional attributes for the test suite
     * @return The ID of the created test suite
     */
    String startTestSuite(String suiteName, String description, Map<String, Object> attributes);
    
    /**
     * Starts a new test case within the current test suite.
     * 
     * @param testName The name of the test case
     * @param description Optional description of the test case
     * @return The ID of the created test case
     */
    String startTest(String testName, String description);
    
    /**
     * Starts a new test case within the current test suite with additional attributes.
     * 
     * @param testName The name of the test case
     * @param description Optional description of the test case
     * @param attributes Additional attributes for the test case
     * @return The ID of the created test case
     */
    String startTest(String testName, String description, Map<String, Object> attributes);
    
    /**
     * Starts a new test case within a specific test suite.
     * 
     * @param suiteId The ID of the test suite
     * @param testName The name of the test case
     * @param description Optional description of the test case
     * @return The ID of the created test case
     */
    String startTest(String suiteId, String testName, String description);
    
    /**
     * Starts a new test case within a specific test suite with additional attributes.
     * 
     * @param suiteId The ID of the test suite
     * @param testName The name of the test case
     * @param description Optional description of the test case
     * @param attributes Additional attributes for the test case
     * @return The ID of the created test case
     */
    String startTest(String suiteId, String testName, String description, Map<String, Object> attributes);
    
    /**
     * Logs a test step within the current test case.
     * 
     * @param stepName The name of the test step
     * @param description Optional description of the test step
     * @param status The status of the test step
     * @return The ID of the created test step
     */
    String logStep(String stepName, String description, CSTestStatus status);
    
    /**
     * Logs a test step within the current test case with additional attributes.
     * 
     * @param stepName The name of the test step
     * @param description Optional description of the test step
     * @param status The status of the test step
     * @param attributes Additional attributes for the test step
     * @return The ID of the created test step
     */
    String logStep(String stepName, String description, CSTestStatus status, Map<String, Object> attributes);
    
    /**
     * Logs a test step within a specific test case.
     * 
     * @param testId The ID of the test case
     * @param stepName The name of the test step
     * @param description Optional description of the test step
     * @param status The status of the test step
     * @return The ID of the created test step
     */
    String logStep(String testId, String stepName, String description, CSTestStatus status);
    
    /**
     * Logs a test step within a specific test case with additional attributes.
     * 
     * @param testId The ID of the test case
     * @param stepName The name of the test step
     * @param description Optional description of the test step
     * @param status The status of the test step
     * @param attributes Additional attributes for the test step
     * @return The ID of the created test step
     */
    String logStep(String testId, String stepName, String description, CSTestStatus status, Map<String, Object> attributes);
    
    /**
     * Attaches a screenshot to the current test step.
     * 
     * @param screenshotFile The screenshot file
     * @param title Optional title for the screenshot
     * @param description Optional description of the screenshot
     * @return The ID of the attached screenshot
     */
    String attachScreenshot(File screenshotFile, String title, String description);
    
    /**
     * Attaches a screenshot to a specific test step.
     * 
     * @param stepId The ID of the test step
     * @param screenshotFile The screenshot file
     * @param title Optional title for the screenshot
     * @param description Optional description of the screenshot
     * @return The ID of the attached screenshot
     */
    String attachScreenshot(String stepId, File screenshotFile, String title, String description);
    
    /**
     * Attaches a screenshot to the current test step.
     * 
     * @param screenshotData The screenshot data as a byte array
     * @param title Optional title for the screenshot
     * @param description Optional description of the screenshot
     * @return The ID of the attached screenshot
     */
    String attachScreenshot(byte[] screenshotData, String title, String description);
    
    /**
     * Attaches a screenshot to a specific test step.
     * 
     * @param stepId The ID of the test step
     * @param screenshotData The screenshot data as a byte array
     * @param title Optional title for the screenshot
     * @param description Optional description of the screenshot
     * @return The ID of the attached screenshot
     */
    String attachScreenshot(String stepId, byte[] screenshotData, String title, String description);
    
    /**
     * Attaches a file to the current test step.
     * 
     * @param file The file to attach
     * @param title Optional title for the file
     * @param description Optional description of the file
     * @return The ID of the attached file
     */
    String attachFile(File file, String title, String description);
    
    /**
     * Attaches a file to a specific test step.
     * 
     * @param stepId The ID of the test step
     * @param file The file to attach
     * @param title Optional title for the file
     * @param description Optional description of the file
     * @return The ID of the attached file
     */
    String attachFile(String stepId, File file, String title, String description);
    
    /**
     * Logs a message with a specific log level.
     * 
     * @param level The log level
     * @param message The log message
     */
    void log(CSLogLevel level, String message);
    
    /**
     * Logs a message with a specific log level for a specific test step.
     * 
     * @param stepId The ID of the test step
     * @param level The log level
     * @param message The log message
     */
    void log(String stepId, CSLogLevel level, String message);
    
    /**
     * Adds a custom metric to the current test case.
     * 
     * @param name The name of the metric
     * @param value The value of the metric
     */
    void addMetric(String name, Object value);
    
    /**
     * Adds a custom metric to a specific test case.
     * 
     * @param testId The ID of the test case
     * @param name The name of the metric
     * @param value The value of the metric
     */
    void addMetric(String testId, String name, Object value);
    
    /**
     * Ends the current test case with the given status.
     * 
     * @param status The status of the test case
     */
    void endTest(CSTestStatus status);
    
    /**
     * Ends a specific test case with the given status.
     * 
     * @param testId The ID of the test case
     * @param status The status of the test case
     */
    void endTest(String testId, CSTestStatus status);
    
    /**
     * Ends the current test suite.
     */
    void endTestSuite();
    
    /**
     * Ends a specific test suite.
     * 
     * @param suiteId The ID of the test suite
     */
    void endTestSuite(String suiteId);
    
    /**
     * Generates a report for the given test suite.
     * 
     * @param suiteId The ID of the test suite
     * @return The generated report
     */
    CSReport generateReport(String suiteId);
    
    /**
     * Generates a report for the given test suite with the specified format.
     * 
     * @param suiteId The ID of the test suite
     * @param format The format of the report (e.g., "html", "pdf", "xml", "json")
     * @return The generated report
     */
    CSReport generateReport(String suiteId, String format);
    
    /**
     * Generates a report for all test suites.
     * 
     * @return The generated report
     */
    CSReport generateReport();
    
    /**
     * Generates a report for all test suites with the specified format.
     * 
     * @param format The format of the report (e.g., "html", "pdf", "xml", "json")
     * @return The generated report
     */
    CSReport generateReport(String format);
    
    /**
     * Exports a report to a file.
     * 
     * @param report The report to export
     * @param file The file to export to
     * @return True if the export was successful, false otherwise
     */
    boolean exportReport(CSReport report, File file);
    
    /**
     * Gets all active test suites.
     * 
     * @return List of active test suites
     */
    List<CSTestSuite> getActiveSuites();
    
    /**
     * Gets a specific test suite by ID.
     * 
     * @param suiteId The ID of the test suite
     * @return The test suite, or null if not found
     */
    CSTestSuite getTestSuite(String suiteId);
    
    /**
     * Gets a specific test case by ID.
     * 
     * @param testId The ID of the test case
     * @return The test case, or null if not found
     */
    CSTestCase getTestCase(String testId);
    
    /**
     * Gets a specific test step by ID.
     * 
     * @param stepId The ID of the test step
     * @return The test step, or null if not found
     */
    CSTestStep getTestStep(String stepId);
    
    /**
     * Flushes all pending writes to storage.
     */
    void flush();
    
    /**
     * Cleans up resources.
     * This method should be called when the reporter is no longer needed.
     */
    void cleanup();
    
    /**
     * Clears all recorded data.
     */
    void clearAll();
    
    /**
     * Gets the supported report formats.
     * 
     * @return Array of supported report formats
     */
    String[] getSupportedFormats();
    
    /**
     * Checks if a specific report format is supported.
     * 
     * @param format The format to check
     * @return True if the format is supported, false otherwise
     */
    boolean isFormatSupported(String format);
    
    /**
     * Gets the last error message.
     * 
     * @return The last error message, or null if no error occurred
     */
    String getLastError();
    
    /**
     * Sets a global property that will be available in all reports.
     * 
     * @param name The property name
     * @param value The property value
     */
    void setGlobalProperty(String name, Object value);
    
    /**
     * Gets a global property.
     * 
     * @param name The property name
     * @return The property value, or null if not found
     */
    Object getGlobalProperty(String name);
    
    /**
     * Creates a dashboard for the given test suite.
     * 
     * @param suiteId The ID of the test suite
     * @return The created dashboard
     */
    CSDashboard createDashboard(String suiteId);
    
    /**
     * Creates a dashboard for all test suites.
     * 
     * @return The created dashboard
     */
    CSDashboard createDashboard();
    
    /**
     * Gets the start time of a test suite.
     * 
     * @param suiteId The ID of the test suite
     * @return The start time, or null if not found
     */
    Date getSuiteStartTime(String suiteId);
    
    /**
     * Gets the end time of a test suite.
     * 
     * @param suiteId The ID of the test suite
     * @return The end time, or null if not found or not ended
     */
    Date getSuiteEndTime(String suiteId);
    
    /**
     * Gets the test report directory.
     * 
     * @return The test report directory
     */
    File getReportDirectory();
    
    /**
     * Sets the test report directory.
     * 
     * @param directory The test report directory
     */
    void setReportDirectory(File directory);
    
    /**
     * Gets the number of passed tests in a test suite.
     * 
     * @param suiteId The ID of the test suite
     * @return The number of passed tests
     */
    int getPassedTestCount(String suiteId);
    
    /**
     * Gets the number of failed tests in a test suite.
     * 
     * @param suiteId The ID of the test suite
     * @return The number of failed tests
     */
    int getFailedTestCount(String suiteId);
    
    /**
     * Gets the number of skipped tests in a test suite.
     * 
     * @param suiteId The ID of the test suite
     * @return The number of skipped tests
     */
    int getSkippedTestCount(String suiteId);
    
    /**
     * Gets the total number of tests in a test suite.
     * 
     * @param suiteId The ID of the test suite
     * @return The total number of tests
     */
    int getTotalTestCount(String suiteId);
    
    /**
     * Gets the pass percentage for a test suite.
     * 
     * @param suiteId The ID of the test suite
     * @return The pass percentage (0-100)
     */
    double getPassPercentage(String suiteId);
}



package com.cstestforge.framework.core.reporting;

/**
 * Enum for test status in the CSTestForge framework.
 * Represents the possible states of a test case or test step.
 */
public enum CSTestStatus {
    /**
     * Test passed successfully.
     */
    PASS("Pass", "success", "#4CAF50"),
    
    /**
     * Test failed.
     */
    FAIL("Fail", "danger", "#F44336"),
    
    /**
     * Test was skipped or not run.
     */
    SKIP("Skip", "warning", "#FFC107"),
    
    /**
     * Test is blocked and cannot be run.
     */
    BLOCKED("Blocked", "secondary", "#9E9E9E"),
    
    /**
     * Test is currently in progress.
     */
    IN_PROGRESS("In Progress", "info", "#2196F3"),
    
    /**
     * Test contains a warning but did not fail.
     */
    WARNING("Warning", "warning", "#FF9800"),
    
    /**
     * Test had an error during execution.
     */
    ERROR("Error", "danger", "#E91E63"),
    
    /**
     * Test was retried after a failure.
     */
    RETRY("Retry", "info", "#00BCD4"),
    
    /**
     * Test status is unknown.
     */
    UNKNOWN("Unknown", "light", "#9E9E9E"),
    
    /**
     * Test is pending execution.
     */
    PENDING("Pending", "light", "#607D8B"),
    
    /**
     * Test resulted in a crash or exception.
     */
    CRASH("Crash", "danger", "#D32F2F"),
    
    /**
     * Test was interrupted during execution.
     */
    INTERRUPTED("Interrupted", "warning", "#FF5722"),
    
    /**
     * Test was not applicable in the current context.
     */
    NOT_APPLICABLE("Not Applicable", "secondary", "#607D8B"),
    
    /**
     * Test was conditionally executed based on certain conditions.
     */
    CONDITIONAL("Conditional", "info", "#3F51B5");
    
    private final String displayName;
    private final String bootstrapClass;
    private final String colorCode;
    
    /**
     * Constructor for CSTestStatus.
     * 
     * @param displayName The display name of the status
     * @param bootstrapClass The Bootstrap class name for styling
     * @param colorCode The hex color code for the status
     */
    CSTestStatus(String displayName, String bootstrapClass, String colorCode) {
        this.displayName = displayName;
        this.bootstrapClass = bootstrapClass;
        this.colorCode = colorCode;
    }
    
    /**
     * Gets the display name of the status.
     * 
     * @return The display name
     */
    public String getDisplayName() {
        return displayName;
    }
    
    /**
     * Gets the Bootstrap class name for styling.
     * 
     * @return The Bootstrap class name
     */
    public String getBootstrapClass() {
        return bootstrapClass;
    }
    
    /**
     * Gets the hex color code for the status.
     * 
     * @return The hex color code
     */
    public String getColorCode() {
        return colorCode;
    }
    
    /**
     * Gets the CSS style for the status.
     * 
     * @return The CSS style
     */
    public String getCssStyle() {
        return "background-color: " + colorCode + "; color: white;";
    }
    
    /**
     * Gets the status from a display name.
     * 
     * @param displayName The display name
     * @return The status, or UNKNOWN if not found
     */
    public static CSTestStatus fromDisplayName(String displayName) {
        if (displayName == null || displayName.isEmpty()) {
            return UNKNOWN;
        }
        
        for (CSTestStatus status : values()) {
            if (status.getDisplayName().equalsIgnoreCase(displayName)) {
                return status;
            }
        }
        
        return UNKNOWN;
    }
    
    /**
     * Gets the status from a string representation.
     * 
     * @param name The string representation
     * @return The status, or UNKNOWN if not found
     */
    public static CSTestStatus fromString(String name) {
        if (name == null || name.isEmpty()) {
            return UNKNOWN;
        }
        
        try {
            return valueOf(name.toUpperCase());
        } catch (IllegalArgumentException e) {
            return fromDisplayName(name);
        }
    }
    
    /**
     * Determines if the status is a failure status.
     * 
     * @return True if the status represents a failure, false otherwise
     */
    public boolean isFailure() {
        return this == FAIL || this == ERROR || this == CRASH;
    }
    
    /**
     * Determines if the status is a success status.
     * 
     * @return True if the status represents a success, false otherwise
     */
    public boolean isSuccess() {
        return this == PASS;
    }
    
    /**
     * Determines if the status is a warning status.
     * 
     * @return True if the status represents a warning, false otherwise
     */
    public boolean isWarning() {
        return this == WARNING || this == INTERRUPTED;
    }
    
    /**
     * Determines if the status is a neutral status.
     * 
     * @return True if the status is neutral, false otherwise
     */
    public boolean isNeutral() {
        return this == SKIP || this == BLOCKED || this == NOT_APPLICABLE || 
               this == UNKNOWN || this == PENDING || this == CONDITIONAL;
    }
    
    /**
     * Determines if the status is an in-progress status.
     * 
     * @return True if the status represents in-progress, false otherwise
     */
    public boolean isInProgress() {
        return this == IN_PROGRESS || this == RETRY;
    }
    
    /**
     * Gets the integer value of the status for sorting purposes.
     * 
     * @return The integer value
     */
    public int getValue() {
        switch (this) {
            case PASS:
                return 0;
            case FAIL:
                return 100;
            case WARNING:
                return 50;
            case ERROR:
                return 90;
            case CRASH:
                return 95;
            case SKIP:
                return 30;
            case BLOCKED:
                return 40;
            case IN_PROGRESS:
                return 10;
            case RETRY:
                return 20;
            case INTERRUPTED:
                return 60;
            case NOT_APPLICABLE:
                return 25;
            case PENDING:
                return 15;
            case CONDITIONAL:
                return 35;
            case UNKNOWN:
            default:
                return 70;
        }
    }
    
    /**
     * Gets an icon class for the status (Font Awesome).
     * 
     * @return The icon class
     */
    public String getIconClass() {
        switch (this) {
            case PASS:
                return "fa-check-circle";
            case FAIL:
                return "fa-times-circle";
            case WARNING:
                return "fa-exclamation-triangle";
            case ERROR:
                return "fa-exclamation-circle";
            case CRASH:
                return "fa-bomb";
            case SKIP:
                return "fa-forward";
            case BLOCKED:
                return "fa-ban";
            case IN_PROGRESS:
                return "fa-spinner fa-spin";
            case RETRY:
                return "fa-redo";
            case INTERRUPTED:
                return "fa-hand-paper";
            case NOT_APPLICABLE:
                return "fa-minus-circle";
            case PENDING:
                return "fa-clock";
            case CONDITIONAL:
                return "fa-random";
            case UNKNOWN:
            default:
                return "fa-question-circle";
        }
    }
    
    /**
     * Converts the status to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        return "{" +
               "\"status\": \"" + name() + "\"," +
               "\"displayName\": \"" + displayName + "\"," +
               "\"colorCode\": \"" + colorCode + "\"," +
               "\"bootstrapClass\": \"" + bootstrapClass + "\"," +
               "\"isFailure\": " + isFailure() + "," +
               "\"isSuccess\": " + isSuccess() + "," +
               "\"isWarning\": " + isWarning() + "," +
               "\"isNeutral\": " + isNeutral() + "," +
               "\"isInProgress\": " + isInProgress() +
               "}";
    }
    
    @Override
    public String toString() {
        return displayName;
    }
}


package com.cstestforge.framework.core.reporting;

/**
 * Enum for log levels in the CSTestForge framework.
 * Represents the severity of log messages.
 */
public enum CSLogLevel {
    /**
     * Trace level for detailed debugging information.
     */
    TRACE(0, "Trace", "#9E9E9E"),
    
    /**
     * Debug level for debugging information.
     */
    DEBUG(1, "Debug", "#607D8B"),
    
    /**
     * Info level for informational messages.
     */
    INFO(2, "Info", "#2196F3"),
    
    /**
     * Warning level for potential issues.
     */
    WARN(3, "Warning", "#FF9800"),
    
    /**
     * Error level for error conditions.
     */
    ERROR(4, "Error", "#F44336"),
    
    /**
     * Fatal level for severe errors that cause premature termination.
     */
    FATAL(5, "Fatal", "#D32F2F");
    
    private final int value;
    private final String displayName;
    private final String colorCode;
    
    /**
     * Constructor for CSLogLevel.
     * 
     * @param value The numeric value of the log level
     * @param displayName The display name of the log level
     * @param colorCode The hex color code for the log level
     */
    CSLogLevel(int value, String displayName, String colorCode) {
        this.value = value;
        this.displayName = displayName;
        this.colorCode = colorCode;
    }
    
    /**
     * Gets the numeric value of the log level.
     * 
     * @return The numeric value
     */
    public int getValue() {
        return value;
    }
    
    /**
     * Gets the display name of the log level.
     * 
     * @return The display name
     */
    public String getDisplayName() {
        return displayName;
    }
    
    /**
     * Gets the hex color code for the log level.
     * 
     * @return The hex color code
     */
    public String getColorCode() {
        return colorCode;
    }
    
    /**
     * Gets the CSS style for the log level.
     * 
     * @return The CSS style
     */
    public String getCssStyle() {
        return "color: " + colorCode + ";";
    }
    
    /**
     * Gets the log level from a string representation.
     * 
     * @param name The string representation
     * @return The log level, or INFO if not found
     */
    public static CSLogLevel fromString(String name) {
        if (name == null || name.isEmpty()) {
            return INFO;
        }
        
        try {
            return valueOf(name.toUpperCase());
        } catch (IllegalArgumentException e) {
            // Try by display name
            for (CSLogLevel level : values()) {
                if (level.getDisplayName().equalsIgnoreCase(name)) {
                    return level;
                }
            }
            
            // Try by numeric value
            try {
                int numericValue = Integer.parseInt(name);
                for (CSLogLevel level : values()) {
                    if (level.getValue() == numericValue) {
                        return level;
                    }
                }
            } catch (NumberFormatException ex) {
                // Ignore
            }
            
            return INFO;
        }
    }
    
    /**
     * Gets the Bootstrap class name for styling.
     * 
     * @return The Bootstrap class name
     */
    public String getBootstrapClass() {
        switch (this) {
            case TRACE:
                return "secondary";
            case DEBUG:
                return "light";
            case INFO:
                return "info";
            case WARN:
                return "warning";
            case ERROR:
                return "danger";
            case FATAL:
                return "danger";
            default:
                return "light";
        }
    }
    
    /**
     * Gets an icon class for the log level (Font Awesome).
     * 
     * @return The icon class
     */
    public String getIconClass() {
        switch (this) {
            case TRACE:
                return "fa-microscope";
            case DEBUG:
                return "fa-bug";
            case INFO:
                return "fa-info-circle";
            case WARN:
                return "fa-exclamation-triangle";
            case ERROR:
                return "fa-exclamation-circle";
            case FATAL:
                return "fa-skull";
            default:
                return "fa-info-circle";
        }
    }
    
    /**
     * Checks if this log level is enabled for the given minimum level.
     * 
     * @param minimumLevel The minimum log level
     * @return True if this log level is enabled, false otherwise
     */
    public boolean isEnabled(CSLogLevel minimumLevel) {
        return this.value >= minimumLevel.value;
    }
    
    /**
     * Converts the log level to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        return "{" +
               "\"level\": \"" + name() + "\"," +
               "\"value\": " + value + "," +
               "\"displayName\": \"" + displayName + "\"," +
               "\"colorCode\": \"" + colorCode + "\"," +
               "\"bootstrapClass\": \"" + getBootstrapClass() + "\"" +
               "}";
    }
    
    @Override
    public String toString() {
        return displayName;
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Represents a test suite in the CSTestForge framework.
 * A test suite is a collection of test cases.
 */
public class CSTestSuite implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private final String id;
    private final String name;
    private String description;
    private final Date startTime;
    private Date endTime;
    private final Map<String, CSTestCase> testCases;
    private final List<CSTestCase> testCaseOrder;
    private final Map<String, Object> attributes;
    private final AtomicInteger passCount;
    private final AtomicInteger failCount;
    private final AtomicInteger skipCount;
    private final AtomicInteger totalCount;
    private final List<String> tags;
    private String environment;
    private String browser;
    private String operatingSystem;
    private String deviceName;
    private String framework;
    
    /**
     * Constructor for CSTestSuite.
     * 
     * @param name The name of the test suite
     * @param description The description of the test suite
     */
    public CSTestSuite(String name, String description) {
        this(UUID.randomUUID().toString(), name, description, new Date());
    }
    
    /**
     * Constructor for CSTestSuite with additional attributes.
     * 
     * @param name The name of the test suite
     * @param description The description of the test suite
     * @param attributes Additional attributes for the test suite
     */
    public CSTestSuite(String name, String description, Map<String, Object> attributes) {
        this(UUID.randomUUID().toString(), name, description, new Date(), attributes);
    }
    
    /**
     * Constructor for CSTestSuite with a specific ID.
     * 
     * @param id The ID of the test suite
     * @param name The name of the test suite
     * @param description The description of the test suite
     * @param startTime The start time of the test suite
     */
    public CSTestSuite(String id, String name, String description, Date startTime) {
        this(id, name, description, startTime, new HashMap<>());
    }
    
    /**
     * Constructor for CSTestSuite with a specific ID and additional attributes.
     * 
     * @param id The ID of the test suite
     * @param name The name of the test suite
     * @param description The description of the test suite
     * @param startTime The start time of the test suite
     * @param attributes Additional attributes for the test suite
     */
    public CSTestSuite(String id, String name, String description, Date startTime, Map<String, Object> attributes) {
        this.id = id;
        this.name = name;
        this.description = description;
        this.startTime = startTime;
        this.testCases = new ConcurrentHashMap<>();
        this.testCaseOrder = new CopyOnWriteArrayList<>();
        this.attributes = new ConcurrentHashMap<>(attributes);
        this.passCount = new AtomicInteger(0);
        this.failCount = new AtomicInteger(0);
        this.skipCount = new AtomicInteger(0);
        this.totalCount = new AtomicInteger(0);
        this.tags = new CopyOnWriteArrayList<>();
    }
    
    /**
     * Gets the ID of the test suite.
     * 
     * @return The ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Gets the name of the test suite.
     * 
     * @return The name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Gets the description of the test suite.
     * 
     * @return The description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the description of the test suite.
     * 
     * @param description The description
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * Gets the start time of the test suite.
     * 
     * @return The start time
     */
    public Date getStartTime() {
        return startTime;
    }
    
    /**
     * Gets the end time of the test suite.
     * 
     * @return The end time, or null if not ended
     */
    public Date getEndTime() {
        return endTime;
    }
    
    /**
     * Sets the end time of the test suite.
     * 
     * @param endTime The end time
     */
    public void setEndTime(Date endTime) {
        this.endTime = endTime;
    }
    
    /**
     * Gets the duration of the test suite in milliseconds.
     * 
     * @return The duration, or -1 if not ended
     */
    public long getDuration() {
        if (endTime == null) {
            return -1;
        }
        return endTime.getTime() - startTime.getTime();
    }
    
    /**
     * Gets the formatted duration of the test suite.
     * 
     * @return The formatted duration, or "In Progress" if not ended
     */
    public String getFormattedDuration() {
        long duration = getDuration();
        if (duration < 0) {
            return "In Progress";
        }
        
        long seconds = duration / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        
        seconds %= 60;
        minutes %= 60;
        
        StringBuilder sb = new StringBuilder();
        if (hours > 0) {
            sb.append(hours).append("h ");
        }
        if (minutes > 0 || hours > 0) {
            sb.append(minutes).append("m ");
        }
        sb.append(seconds).append("s");
        
        return sb.toString();
    }
    
    /**
     * Gets a test case by ID.
     * 
     * @param testId The ID of the test case
     * @return The test case, or null if not found
     */
    public CSTestCase getTestCase(String testId) {
        return testCases.get(testId);
    }
    
    /**
     * Gets all test cases.
     * 
     * @return List of all test cases in the order they were added
     */
    public List<CSTestCase> getTestCases() {
        return new ArrayList<>(testCaseOrder);
    }
    
    /**
     * Gets the number of test cases.
     * 
     * @return The number of test cases
     */
    public int getTestCaseCount() {
        return testCases.size();
    }
    
    /**
     * Adds a test case to the test suite.
     * 
     * @param testCase The test case to add
     */
    public void addTestCase(CSTestCase testCase) {
        testCases.put(testCase.getId(), testCase);
        testCaseOrder.add(testCase);
        totalCount.incrementAndGet();
    }
    
    /**
     * Removes a test case from the test suite.
     * 
     * @param testId The ID of the test case to remove
     * @return The removed test case, or null if not found
     */
    public CSTestCase removeTestCase(String testId) {
        CSTestCase testCase = testCases.remove(testId);
        if (testCase != null) {
            testCaseOrder.remove(testCase);
            totalCount.decrementAndGet();
            
            CSTestStatus status = testCase.getStatus();
            if (status != null) {
                if (status.isSuccess()) {
                    passCount.decrementAndGet();
                } else if (status.isFailure()) {
                    failCount.decrementAndGet();
                } else if (status.isNeutral()) {
                    skipCount.decrementAndGet();
                }
            }
        }
        return testCase;
    }
    
    /**
     * Gets an attribute value.
     * 
     * @param name The attribute name
     * @return The attribute value, or null if not found
     */
    public Object getAttribute(String name) {
        return attributes.get(name);
    }
    
    /**
     * Gets all attributes.
     * 
     * @return Map of all attributes
     */
    public Map<String, Object> getAttributes() {
        return new HashMap<>(attributes);
    }
    
    /**
     * Sets an attribute value.
     * 
     * @param name The attribute name
     * @param value The attribute value
     */
    public void setAttribute(String name, Object value) {
        attributes.put(name, value);
    }
    
    /**
     * Removes an attribute.
     * 
     * @param name The attribute name
     * @return The removed attribute value, or null if not found
     */
    public Object removeAttribute(String name) {
        return attributes.remove(name);
    }
    
    /**
     * Gets the number of passed tests.
     * 
     * @return The number of passed tests
     */
    public int getPassCount() {
        return passCount.get();
    }
    
    /**
     * Gets the number of failed tests.
     * 
     * @return The number of failed tests
     */
    public int getFailCount() {
        return failCount.get();
    }
    
    /**
     * Gets the number of skipped tests.
     * 
     * @return The number of skipped tests
     */
    public int getSkipCount() {
        return skipCount.get();
    }
    
    /**
     * Gets the total number of tests.
     * 
     * @return The total number of tests
     */
    public int getTotalCount() {
        return totalCount.get();
    }
    
    /**
     * Increments the pass count.
     */
    public void incrementPassCount() {
        passCount.incrementAndGet();
    }
    
    /**
     * Increments the fail count.
     */
    public void incrementFailCount() {
        failCount.incrementAndGet();
    }
    
    /**
     * Increments the skip count.
     */
    public void incrementSkipCount() {
        skipCount.incrementAndGet();
    }
    
    /**
     * Gets the pass percentage.
     * 
     * @return The pass percentage (0-100), or 0 if no tests
     */
    public double getPassPercentage() {
        int total = getTotalCount();
        if (total == 0) {
            return 0;
        }
        return (double) getPassCount() / total * 100;
    }
    
    /**
     * Gets the fail percentage.
     * 
     * @return The fail percentage (0-100), or 0 if no tests
     */
    public double getFailPercentage() {
        int total = getTotalCount();
        if (total == 0) {
            return 0;
        }
        return (double) getFailCount() / total * 100;
    }
    
    /**
     * Gets the skip percentage.
     * 
     * @return The skip percentage (0-100), or 0 if no tests
     */
    public double getSkipPercentage() {
        int total = getTotalCount();
        if (total == 0) {
            return 0;
        }
        return (double) getSkipCount() / total * 100;
    }
    
    /**
     * Gets the list of tags.
     * 
     * @return The list of tags
     */
    public List<String> getTags() {
        return new ArrayList<>(tags);
    }
    
    /**
     * Adds a tag.
     * 
     * @param tag The tag to add
     */
    public void addTag(String tag) {
        if (tag != null && !tag.isEmpty()) {
            tags.add(tag);
        }
    }
    
    /**
     * Adds multiple tags.
     * 
     * @param newTags The tags to add
     */
    public void addTags(List<String> newTags) {
        if (newTags != null) {
            for (String tag : newTags) {
                addTag(tag);
            }
        }
    }
    
    /**
     * Removes a tag.
     * 
     * @param tag The tag to remove
     * @return True if the tag was removed, false otherwise
     */
    public boolean removeTag(String tag) {
        return tags.remove(tag);
    }
    
    /**
     * Gets the environment.
     * 
     * @return The environment
     */
    public String getEnvironment() {
        return environment;
    }
    
    /**
     * Sets the environment.
     * 
     * @param environment The environment
     */
    public void setEnvironment(String environment) {
        this.environment = environment;
    }
    
    /**
     * Gets the browser.
     * 
     * @return The browser
     */
    public String getBrowser() {
        return browser;
    }
    
    /**
     * Sets the browser.
     * 
     * @param browser The browser
     */
    public void setBrowser(String browser) {
        this.browser = browser;
    }
    
    /**
     * Gets the operating system.
     * 
     * @return The operating system
     */
    public String getOperatingSystem() {
        return operatingSystem;
    }
    
    /**
     * Sets the operating system.
     * 
     * @param operatingSystem The operating system
     */
    public void setOperatingSystem(String operatingSystem) {
        this.operatingSystem = operatingSystem;
    }
    
    /**
     * Gets the device name.
     * 
     * @return The device name
     */
    public String getDeviceName() {
        return deviceName;
    }
    
    /**
     * Sets the device name.
     * 
     * @param deviceName The device name
     */
    public void setDeviceName(String deviceName) {
        this.deviceName = deviceName;
    }
    
    /**
     * Gets the framework.
     * 
     * @return The framework
     */
    public String getFramework() {
        return framework;
    }
    
    /**
     * Sets the framework.
     * 
     * @param framework The framework
     */
    public void setFramework(String framework) {
        this.framework = framework;
    }
    
    /**
     * Ends the test suite.
     * Sets the end time to the current time if not already set.
     */
    public void end() {
        if (endTime == null) {
            endTime = new Date();
        }
    }
    
    /**
     * Converts the test suite to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append("\"id\": \"").append(id).append("\",");
        sb.append("\"name\": \"").append(name).append("\",");
        sb.append("\"description\": \"").append(description != null ? escapeJson(description) : "").append("\",");
        sb.append("\"startTime\": \"").append(startTime).append("\",");
        sb.append("\"endTime\": ").append(endTime != null ? "\"" + endTime + "\"" : "null").append(",");
        sb.append("\"duration\": ").append(getDuration()).append(",");
        sb.append("\"formattedDuration\": \"").append(getFormattedDuration()).append("\",");
        sb.append("\"passCount\": ").append(getPassCount()).append(",");
        sb.append("\"failCount\": ").append(getFailCount()).append(",");
        sb.append("\"skipCount\": ").append(getSkipCount()).append(",");
        sb.append("\"totalCount\": ").append(getTotalCount()).append(",");
        sb.append("\"passPercentage\": ").append(getPassPercentage()).append(",");
        sb.append("\"failPercentage\": ").append(getFailPercentage()).append(",");
        sb.append("\"skipPercentage\": ").append(getSkipPercentage()).append(",");
        sb.append("\"environment\": ").append(environment != null ? "\"" + environment + "\"" : "null").append(",");
        sb.append("\"browser\": ").append(browser != null ? "\"" + browser + "\"" : "null").append(",");
        sb.append("\"operatingSystem\": ").append(operatingSystem != null ? "\"" + operatingSystem + "\"" : "null").append(",");
        sb.append("\"deviceName\": ").append(deviceName != null ? "\"" + deviceName + "\"" : "null").append(",");
        sb.append("\"framework\": ").append(framework != null ? "\"" + framework + "\"" : "null").append(",");
        
        // Tags
        sb.append("\"tags\": [");
        for (int i = 0; i < tags.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("\"").append(tags.get(i)).append("\"");
        }
        sb.append("],");
        
        // Attributes
        sb.append("\"attributes\": {");
        int attrIndex = 0;
        for (Map.Entry<String, Object> entry : attributes.entrySet()) {
            if (attrIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": ");
            appendJsonValue(sb, entry.getValue());
            attrIndex++;
        }
        sb.append("},");
        
        // Test cases
        sb.append("\"testCases\": [");
        for (int i = 0; i < testCaseOrder.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("\"").append(testCaseOrder.get(i).getId()).append("\"");
        }
        sb.append("]");
        
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Appends a JSON value to a StringBuilder.
     * 
     * @param sb The StringBuilder to append to
     * @param value The value to append
     */
    private void appendJsonValue(StringBuilder sb, Object value) {
        if (value == null) {
            sb.append("null");
        } else if (value instanceof Number || value instanceof Boolean) {
            sb.append(value);
        } else if (value instanceof Date) {
            sb.append("\"").append(value).append("\"");
        } else if (value instanceof Map) {
            sb.append("{");
            int index = 0;
            @SuppressWarnings("unchecked")
            Map<Object, Object> map = (Map<Object, Object>) value;
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                if (index > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\": ");
                appendJsonValue(sb, entry.getValue());
                index++;
            }
            sb.append("}");
        } else if (value instanceof List) {
            sb.append("[");
            int index = 0;
            @SuppressWarnings("unchecked")
            List<Object> list = (List<Object>) value;
            for (Object item : list) {
                if (index > 0) {
                    sb.append(",");
                }
                appendJsonValue(sb, item);
                index++;
            }
            sb.append("]");
        } else {
            sb.append("\"").append(escapeJson(value.toString())).append("\"");
        }
    }
    
    /**
     * Escapes a string for JSON.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\r", "\\r")
                .replace("\n", "\\n")
                .replace("\t", "\\t");
    }
    
    @Override
    public String toString() {
        return "CSTestSuite{" +
               "id='" + id + '\'' +
               ", name='" + name + '\'' +
               ", testCases=" + getTestCaseCount() +
               ", pass=" + getPassCount() +
               ", fail=" + getFailCount() +
               ", skip=" + getSkipCount() +
               '}';
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Represents a test case in the CSTestForge framework.
 * A test case is a collection of test steps.
 */
public class CSTestCase implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private final String id;
    private final String suiteId;
    private final String name;
    private String description;
    private final Date startTime;
    private Date endTime;
    private CSTestStatus status;
    private final List<CSTestStep> steps;
    private final Map<String, CSTestStep> stepsMap;
    private final Map<String, Object> attributes;
    private final List<String> categories;
    private final List<String> tags;
    private String author;
    
    /**
     * Constructor for CSTestCase.
     * 
     * @param suiteId The ID of the test suite
     * @param name The name of the test case
     * @param description The description of the test case
     */
    public CSTestCase(String suiteId, String name, String description) {
        this(UUID.randomUUID().toString(), suiteId, name, description, new Date());
    }
    
    /**
     * Constructor for CSTestCase with additional attributes.
     * 
     * @param suiteId The ID of the test suite
     * @param name The name of the test case
     * @param description The description of the test case
     * @param attributes Additional attributes for the test case
     */
    public CSTestCase(String suiteId, String name, String description, Map<String, Object> attributes) {
        this(UUID.randomUUID().toString(), suiteId, name, description, new Date(), attributes);
    }
    
    /**
     * Constructor for CSTestCase with a specific ID.
     * 
     * @param id The ID of the test case
     * @param suiteId The ID of the test suite
     * @param name The name of the test case
     * @param description The description of the test case
     * @param startTime The start time of the test case
     */
    public CSTestCase(String id, String suiteId, String name, String description, Date startTime) {
        this(id, suiteId, name, description, startTime, new HashMap<>());
    }
    
    /**
     * Constructor for CSTestCase with a specific ID and additional attributes.
     * 
     * @param id The ID of the test case
     * @param suiteId The ID of the test suite
     * @param name The name of the test case
     * @param description The description of the test case
     * @param startTime The start time of the test case
     * @param attributes Additional attributes for the test case
     */
    public CSTestCase(String id, String suiteId, String name, String description, 
                     Date startTime, Map<String, Object> attributes) {
        this.id = id;
        this.suiteId = suiteId;
        this.name = name;
        this.description = description;
        this.startTime = startTime;
        this.status = CSTestStatus.IN_PROGRESS;
        this.steps = new CopyOnWriteArrayList<>();
        this.stepsMap = new ConcurrentHashMap<>();
        this.attributes = new ConcurrentHashMap<>(attributes);
        this.categories = new CopyOnWriteArrayList<>();
        this.tags = new CopyOnWriteArrayList<>();
    }
    
    /**
     * Gets the ID of the test case.
     * 
     * @return The ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Gets the ID of the test suite.
     * 
     * @return The suite ID
     */
    public String getSuiteId() {
        return suiteId;
    }
    
    /**
     * Gets the name of the test case.
     * 
     * @return The name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Gets the description of the test case.
     * 
     * @return The description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the description of the test case.
     * 
     * @param description The description
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * Gets the start time of the test case.
     * 
     * @return The start time
     */
    public Date getStartTime() {
        return startTime;
    }
    
    /**
     * Gets the end time of the test case.
     * 
     * @return The end time, or null if not ended
     */
    public Date getEndTime() {
        return endTime;
    }
    
    /**
     * Sets the end time of the test case.
     * 
     * @param endTime The end time
     */
    public void setEndTime(Date endTime) {
        this.endTime = endTime;
    }
    
    /**
     * Gets the status of the test case.
     * 
     * @return The status
     */
    public CSTestStatus getStatus() {
        return status;
    }
    
    /**
     * Sets the status of the test case.
     * 
     * @param status The status
     */
    public void setStatus(CSTestStatus status) {
        this.status = status;
    }
    
    /**
     * Gets the duration of the test case in milliseconds.
     * 
     * @return The duration, or -1 if not ended
     */
    public long getDuration() {
        if (endTime == null) {
            return -1;
        }
        return endTime.getTime() - startTime.getTime();
    }
    
    /**
     * Gets the formatted duration of the test case.
     * 
     * @return The formatted duration, or "In Progress" if not ended
     */
    public String getFormattedDuration() {
        long duration = getDuration();
        if (duration < 0) {
            return "In Progress";
        }
        
        long seconds = duration / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        
        seconds %= 60;
        minutes %= 60;
        
        StringBuilder sb = new StringBuilder();
        if (hours > 0) {
            sb.append(hours).append("h ");
        }
        if (minutes > 0 || hours > 0) {
            sb.append(minutes).append("m ");
        }
        sb.append(seconds).append("s");
        
        return sb.toString();
    }
    
    /**
     * Gets all test steps.
     * 
     * @return List of all test steps in the order they were added
     */
    public List<CSTestStep> getSteps() {
        return new ArrayList<>(steps);
    }
    
    /**
     * Gets a test step by ID.
     * 
     * @param stepId The ID of the test step
     * @return The test step, or null if not found
     */
    public CSTestStep getStep(String stepId) {
        return stepsMap.get(stepId);
    }
    
    /**
     * Gets the number of test steps.
     * 
     * @return The number of test steps
     */
    public int getStepCount() {
        return steps.size();
    }
    
    /**
     * Adds a test step to the test case.
     * 
     * @param step The test step to add
     */
    public void addStep(CSTestStep step) {
        steps.add(step);
        stepsMap.put(step.getId(), step);
    }
    
    /**
     * Removes a test step from the test case.
     * 
     * @param stepId The ID of the test step to remove
     * @return The removed test step, or null if not found
     */
    public CSTestStep removeStep(String stepId) {
        CSTestStep step = stepsMap.remove(stepId);
        if (step != null) {
            steps.remove(step);
        }
        return step;
    }
    
    /**
     * Gets an attribute value.
     * 
     * @param name The attribute name
     * @return The attribute value, or null if not found
     */
    public Object getAttribute(String name) {
        return attributes.get(name);
    }
    
    /**
     * Gets all attributes.
     * 
     * @return Map of all attributes
     */
    public Map<String, Object> getAttributes() {
        return new HashMap<>(attributes);
    }
    
    /**
     * Sets an attribute value.
     * 
     * @param name The attribute name
     * @param value The attribute value
     */
    public void setAttribute(String name, Object value) {
        attributes.put(name, value);
    }
    
    /**
     * Removes an attribute.
     * 
     * @param name The attribute name
     * @return The removed attribute value, or null if not found
     */
    public Object removeAttribute(String name) {
        return attributes.remove(name);
    }
    
    /**
     * Gets the list of categories.
     * 
     * @return The list of categories
     */
    public List<String> getCategories() {
        return new ArrayList<>(categories);
    }
    
    /**
     * Adds a category.
     * 
     * @param category The category to add
     */
    public void addCategory(String category) {
        if (category != null && !category.isEmpty()) {
            categories.add(category);
        }
    }
    
    /**
     * Adds multiple categories.
     * 
     * @param newCategories The categories to add
     */
    public void addCategories(List<String> newCategories) {
        if (newCategories != null) {
            for (String category : newCategories) {
                addCategory(category);
            }
        }
    }
    
    /**
     * Removes a category.
     * 
     * @param category The category to remove
     * @return True if the category was removed, false otherwise
     */
    public boolean removeCategory(String category) {
        return categories.remove(category);
    }
    
    /**
     * Gets the list of tags.
     * 
     * @return The list of tags
     */
    public List<String> getTags() {
        return new ArrayList<>(tags);
    }
    
    /**
     * Adds a tag.
     * 
     * @param tag The tag to add
     */
    public void addTag(String tag) {
        if (tag != null && !tag.isEmpty()) {
            tags.add(tag);
        }
    }
    
    /**
     * Adds multiple tags.
     * 
     * @param newTags The tags to add
     */
    public void addTags(List<String> newTags) {
        if (newTags != null) {
            for (String tag : newTags) {
                addTag(tag);
            }
        }
    }
    
    /**
     * Removes a tag.
     * 
     * @param tag The tag to remove
     * @return True if the tag was removed, false otherwise
     */
    public boolean removeTag(String tag) {
        return tags.remove(tag);
    }
    
    /**
     * Gets the author of the test case.
     * 
     * @return The author
     */
    public String getAuthor() {
        return author;
    }
    
    /**
     * Sets the author of the test case.
     * 
     * @param author The author
     */
    public void setAuthor(String author) {
        this.author = author;
    }
    
    /**
     * Gets the number of passed steps.
     * 
     * @return The number of passed steps
     */
    public int getPassedStepCount() {
        int count = 0;
        for (CSTestStep step : steps) {
            if (step.getStatus().isSuccess()) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Gets the number of failed steps.
     * 
     * @return The number of failed steps
     */
    public int getFailedStepCount() {
        int count = 0;
        for (CSTestStep step : steps) {
            if (step.getStatus().isFailure()) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Gets the number of skipped steps.
     * 
     * @return The number of skipped steps
     */
    public int getSkippedStepCount() {
        int count = 0;
        for (CSTestStep step : steps) {
            if (step.getStatus().isNeutral()) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Gets the pass percentage for steps.
     * 
     * @return The pass percentage (0-100), or 0 if no steps
     */
    public double getPassPercentage() {
        int total = getStepCount();
        if (total == 0) {
            return 0;
        }
        return (double) getPassedStepCount() / total * 100;
    }
    
    /**
     * Gets the last step added to the test case.
     * 
     * @return The last step, or null if no steps
     */
    public CSTestStep getLastStep() {
        if (steps.isEmpty()) {
            return null;
        }
        return steps.get(steps.size() - 1);
    }
    
    /**
     * Ends the test case with the given status.
     * Sets the end time to the current time if not already set.
     * 
     * @param status The status of the test case
     */
    public void end(CSTestStatus status) {
        this.status = status;
        if (endTime == null) {
            endTime = new Date();
        }
    }
    
    /**
     * Creates a log step with the given log level and message.
     * 
     * @param level The log level
     * @param message The message
     * @return The created test step
     */
    public CSTestStep log(CSLogLevel level, String message) {
        CSTestStep step = new CSTestStep(getId(), "Log", message, CSTestStatus.PASS);
        step.setLogLevel(level);
        addStep(step);
        return step;
    }
    
    /**
     * Calculates the overall status based on the status of all steps.
     * 
     * @return The calculated status
     */
    public CSTestStatus calculateStatus() {
        if (steps.isEmpty()) {
            return CSTestStatus.UNKNOWN;
        }
        
        boolean hasFailures = false;
        boolean hasWarnings = false;
        boolean allSkipped = true;
        
        for (CSTestStep step : steps) {
            CSTestStatus stepStatus = step.getStatus();
            
            if (stepStatus.isFailure()) {
                hasFailures = true;
            }
            
            if (stepStatus.isWarning()) {
                hasWarnings = true;
            }
            
            if (!stepStatus.isNeutral()) {
                allSkipped = false;
            }
        }
        
        if (hasFailures) {
            return CSTestStatus.FAIL;
        } else if (hasWarnings) {
            return CSTestStatus.WARNING;
        } else if (allSkipped) {
            return CSTestStatus.SKIP;
        } else {
            return CSTestStatus.PASS;
        }
    }
    
    /**
     * Adds a metric to the test case.
     * 
     * @param name The name of the metric
     * @param value The value of the metric
     */
    public void addMetric(String name, Object value) {
        setAttribute("metric." + name, value);
    }
    
    /**
     * Gets all metrics.
     * 
     * @return Map of all metrics
     */
    public Map<String, Object> getMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        for (Map.Entry<String, Object> entry : attributes.entrySet()) {
            if (entry.getKey().startsWith("metric.")) {
                String metricName = entry.getKey().substring("metric.".length());
                metrics.put(metricName, entry.getValue());
            }
        }
        
        return metrics;
    }
    
    /**
     * Converts the test case to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append("\"id\": \"").append(id).append("\",");
        sb.append("\"suiteId\": \"").append(suiteId).append("\",");
        sb.append("\"name\": \"").append(name).append("\",");
        sb.append("\"description\": \"").append(description != null ? escapeJson(description) : "").append("\",");
        sb.append("\"startTime\": \"").append(startTime).append("\",");
        sb.append("\"endTime\": ").append(endTime != null ? "\"" + endTime + "\"" : "null").append(",");
        sb.append("\"duration\": ").append(getDuration()).append(",");
        sb.append("\"formattedDuration\": \"").append(getFormattedDuration()).append("\",");
        sb.append("\"status\": ").append(status != null ? status.toJson() : "null").append(",");
        sb.append("\"author\": ").append(author != null ? "\"" + author + "\"" : "null").append(",");
        sb.append("\"passedStepCount\": ").append(getPassedStepCount()).append(",");
        sb.append("\"failedStepCount\": ").append(getFailedStepCount()).append(",");
        sb.append("\"skippedStepCount\": ").append(getSkippedStepCount()).append(",");
        sb.append("\"totalStepCount\": ").append(getStepCount()).append(",");
        sb.append("\"passPercentage\": ").append(getPassPercentage()).append(",");
        
        // Categories
        sb.append("\"categories\": [");
        for (int i = 0; i < categories.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("\"").append(categories.get(i)).append("\"");
        }
        sb.append("],");
        
        // Tags
        sb.append("\"tags\": [");
        for (int i = 0; i < tags.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("\"").append(tags.get(i)).append("\"");
        }
        sb.append("],");
        
        // Attributes
        sb.append("\"attributes\": {");
        int attrIndex = 0;
        for (Map.Entry<String, Object> entry : attributes.entrySet()) {
            if (attrIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": ");
            appendJsonValue(sb, entry.getValue());
            attrIndex++;
        }
        sb.append("},");
        
        // Metrics
        sb.append("\"metrics\": {");
        Map<String, Object> metrics = getMetrics();
        int metricIndex = 0;
        for (Map.Entry<String, Object> entry : metrics.entrySet()) {
            if (metricIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": ");
            appendJsonValue(sb, entry.getValue());
            metricIndex++;
        }
        sb.append("},");
        
        // Steps
        sb.append("\"steps\": [");
        for (int i = 0; i < steps.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("\"").append(steps.get(i).getId()).append("\"");
        }
        sb.append("]");
        
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Appends a JSON value to a StringBuilder.
     * 
     * @param sb The StringBuilder to append to
     * @param value The value to append
     */
    private void appendJsonValue(StringBuilder sb, Object value) {
        if (value == null) {
            sb.append("null");
        } else if (value instanceof Number || value instanceof Boolean) {
            sb.append(value);
        } else if (value instanceof Date) {
            sb.append("\"").append(value).append("\"");
        } else if (value instanceof Map) {
            sb.append("{");
            int index = 0;
            @SuppressWarnings("unchecked")
            Map<Object, Object> map = (Map<Object, Object>) value;
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                if (index > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\": ");
                appendJsonValue(sb, entry.getValue());
                index++;
            }
            sb.append("}");
        } else if (value instanceof List) {
            sb.append("[");
            int index = 0;
            @SuppressWarnings("unchecked")
            List<Object> list = (List<Object>) value;
            for (Object item : list) {
                if (index > 0) {
                    sb.append(",");
                }
                appendJsonValue(sb, item);
                index++;
            }
            sb.append("]");
        } else {
            sb.append("\"").append(escapeJson(value.toString())).append("\"");
        }
    }
    
    /**
     * Escapes a string for JSON.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\r", "\\r")
                .replace("\n", "\\n")
                .replace("\t", "\\t");
    }
    
    @Override
    public String toString() {
        return "CSTestCase{" +
               "id='" + id + '\'' +
               ", name='" + name + '\'' +
               ", status=" + status +
               ", steps=" + getStepCount() +
               '}';
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.File;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Represents a test step in the CSTestForge framework.
 * A test step is an atomic action in a test case.
 */
public class CSTestStep implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private final String id;
    private final String testId;
    private final String name;
    private String description;
    private final Date timestamp;
    private CSTestStatus status;
    private CSLogLevel logLevel;
    private final List<CSScreenshot> screenshots;
    private final Map<String, CSScreenshot> screenshotsMap;
    private final List<CSAttachment> attachments;
    private final Map<String, CSAttachment> attachmentsMap;
    private final List<CSLog> logs;
    private final Map<String, Object> attributes;
    private long duration;
    private String stackTrace;
    private String expectedResult;
    private String actualResult;
    private String errorMessage;
    private String selector;
    private String action;
    private Map<String, String> actionParams;
    
    /**
     * Constructor for CSTestStep.
     * 
     * @param testId The ID of the test case
     * @param name The name of the test step
     * @param description The description of the test step
     * @param status The status of the test step
     */
    public CSTestStep(String testId, String name, String description, CSTestStatus status) {
        this(UUID.randomUUID().toString(), testId, name, description, new Date(), status);
    }
    
    /**
     * Constructor for CSTestStep with additional attributes.
     * 
     * @param testId The ID of the test case
     * @param name The name of the test step
     * @param description The description of the test step
     * @param status The status of the test step
     * @param attributes Additional attributes for the test step
     */
    public CSTestStep(String testId, String name, String description, CSTestStatus status, 
                     Map<String, Object> attributes) {
        this(UUID.randomUUID().toString(), testId, name, description, new Date(), status, attributes);
    }
    
    /**
     * Constructor for CSTestStep with a specific ID.
     * 
     * @param id The ID of the test step
     * @param testId The ID of the test case
     * @param name The name of the test step
     * @param description The description of the test step
     * @param timestamp The timestamp of the test step
     * @param status The status of the test step
     */
    public CSTestStep(String id, String testId, String name, String description, 
                     Date timestamp, CSTestStatus status) {
        this(id, testId, name, description, timestamp, status, new HashMap<>());
    }
    
    /**
     * Constructor for CSTestStep with a specific ID and additional attributes.
     * 
     * @param id The ID of the test step
     * @param testId The ID of the test case
     * @param name The name of the test step
     * @param description The description of the test step
     * @param timestamp The timestamp of the test step
     * @param status The status of the test step
     * @param attributes Additional attributes for the test step
     */
    public CSTestStep(String id, String testId, String name, String description, 
                     Date timestamp, CSTestStatus status, Map<String, Object> attributes) {
        this.id = id;
        this.testId = testId;
        this.name = name;
        this.description = description;
        this.timestamp = timestamp;
        this.status = status;
        this.logLevel = CSLogLevel.INFO;
        this.screenshots = new CopyOnWriteArrayList<>();
        this.screenshotsMap = new ConcurrentHashMap<>();
        this.attachments = new CopyOnWriteArrayList<>();
        this.attachmentsMap = new ConcurrentHashMap<>();
        this.logs = new CopyOnWriteArrayList<>();
        this.attributes = new ConcurrentHashMap<>(attributes);
        this.actionParams = new ConcurrentHashMap<>();
    }

  /**
     * Gets the ID of the test step.
     * 
     * @return The ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Gets the ID of the test case.
     * 
     * @return The test case ID
     */
    public String getTestId() {
        return testId;
    }
    
    /**
     * Gets the name of the test step.
     * 
     * @return The name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Gets the description of the test step.
     * 
     * @return The description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the description of the test step.
     * 
     * @param description The description
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * Gets the timestamp of the test step.
     * 
     * @return The timestamp
     */
    public Date getTimestamp() {
        return timestamp;
    }
    
    /**
     * Gets the status of the test step.
     * 
     * @return The status
     */
    public CSTestStatus getStatus() {
        return status;
    }
    
    /**
     * Sets the status of the test step.
     * 
     * @param status The status
     */
    public void setStatus(CSTestStatus status) {
        this.status = status;
    }
    
    /**
     * Gets the log level of the test step.
     * 
     * @return The log level
     */
    public CSLogLevel getLogLevel() {
        return logLevel;
    }
    
    /**
     * Sets the log level of the test step.
     * 
     * @param logLevel The log level
     */
    public void setLogLevel(CSLogLevel logLevel) {
        this.logLevel = logLevel;
    }
    
    /**
     * Gets all screenshots.
     * 
     * @return List of all screenshots
     */
    public List<CSScreenshot> getScreenshots() {
        return new ArrayList<>(screenshots);
    }
    
    /**
     * Gets a screenshot by ID.
     * 
     * @param screenshotId The ID of the screenshot
     * @return The screenshot, or null if not found
     */
    public CSScreenshot getScreenshot(String screenshotId) {
        return screenshotsMap.get(screenshotId);
    }
    
    /**
     * Gets the number of screenshots.
     * 
     * @return The number of screenshots
     */
    public int getScreenshotCount() {
        return screenshots.size();
    }
    
    /**
     * Adds a screenshot to the test step.
     * 
     * @param screenshot The screenshot to add
     */
    public void addScreenshot(CSScreenshot screenshot) {
        screenshots.add(screenshot);
        screenshotsMap.put(screenshot.getId(), screenshot);
    }
    
    /**
     * Creates and adds a screenshot to the test step.
     * 
     * @param file The screenshot file
     * @param title The title of the screenshot
     * @param description The description of the screenshot
     * @return The created screenshot
     */
    public CSScreenshot addScreenshot(File file, String title, String description) {
        CSScreenshot screenshot = new CSScreenshot(id, file, title, description);
        addScreenshot(screenshot);
        return screenshot;
    }
    
    /**
     * Creates and adds a screenshot to the test step.
     * 
     * @param data The screenshot data
     * @param title The title of the screenshot
     * @param description The description of the screenshot
     * @return The created screenshot
     */
    public CSScreenshot addScreenshot(byte[] data, String title, String description) {
        CSScreenshot screenshot = new CSScreenshot(id, data, title, description);
        addScreenshot(screenshot);
        return screenshot;
    }
    
    /**
     * Removes a screenshot from the test step.
     * 
     * @param screenshotId The ID of the screenshot to remove
     * @return The removed screenshot, or null if not found
     */
    public CSScreenshot removeScreenshot(String screenshotId) {
        CSScreenshot screenshot = screenshotsMap.remove(screenshotId);
        if (screenshot != null) {
            screenshots.remove(screenshot);
        }
        return screenshot;
    }
    
    /**
     * Gets all attachments.
     * 
     * @return List of all attachments
     */
    public List<CSAttachment> getAttachments() {
        return new ArrayList<>(attachments);
    }
    
    /**
     * Gets an attachment by ID.
     * 
     * @param attachmentId The ID of the attachment
     * @return The attachment, or null if not found
     */
    public CSAttachment getAttachment(String attachmentId) {
        return attachmentsMap.get(attachmentId);
    }
    
    /**
     * Gets the number of attachments.
     * 
     * @return The number of attachments
     */
    public int getAttachmentCount() {
        return attachments.size();
    }
    
    /**
     * Adds an attachment to the test step.
     * 
     * @param attachment The attachment to add
     */
    public void addAttachment(CSAttachment attachment) {
        attachments.add(attachment);
        attachmentsMap.put(attachment.getId(), attachment);
    }
    
    /**
     * Creates and adds an attachment to the test step.
     * 
     * @param file The attachment file
     * @param title The title of the attachment
     * @param description The description of the attachment
     * @return The created attachment
     */
    public CSAttachment addAttachment(File file, String title, String description) {
        CSAttachment attachment = new CSAttachment(id, file, title, description);
        addAttachment(attachment);
        return attachment;
    }
    
    /**
     * Creates and adds an attachment to the test step.
     * 
     * @param data The attachment data
     * @param fileName The file name of the attachment
     * @param contentType The content type of the attachment
     * @param title The title of the attachment
     * @param description The description of the attachment
     * @return The created attachment
     */
    public CSAttachment addAttachment(byte[] data, String fileName, String contentType, 
                                     String title, String description) {
        CSAttachment attachment = new CSAttachment(id, data, fileName, contentType, title, description);
        addAttachment(attachment);
        return attachment;
    }
    
    /**
     * Removes an attachment from the test step.
     * 
     * @param attachmentId The ID of the attachment to remove
     * @return The removed attachment, or null if not found
     */
    public CSAttachment removeAttachment(String attachmentId) {
        CSAttachment attachment = attachmentsMap.remove(attachmentId);
        if (attachment != null) {
            attachments.remove(attachment);
        }
        return attachment;
    }
    
    /**
     * Gets all logs.
     * 
     * @return List of all logs
     */
    public List<CSLog> getLogs() {
        return new ArrayList<>(logs);
    }
    
    /**
     * Gets the number of logs.
     * 
     * @return The number of logs
     */
    public int getLogCount() {
        return logs.size();
    }
    
    /**
     * Adds a log to the test step.
     * 
     * @param log The log to add
     */
    public void addLog(CSLog log) {
        logs.add(log);
    }
    
    /**
     * Creates and adds a log to the test step.
     * 
     * @param level The log level
     * @param message The log message
     * @return The created log
     */
    public CSLog addLog(CSLogLevel level, String message) {
        CSLog log = new CSLog(id, level, message);
        addLog(log);
        return log;
    }
    
    /**
     * Gets an attribute value.
     * 
     * @param name The attribute name
     * @return The attribute value, or null if not found
     */
    public Object getAttribute(String name) {
        return attributes.get(name);
    }
    
    /**
     * Gets all attributes.
     * 
     * @return Map of all attributes
     */
    public Map<String, Object> getAttributes() {
        return new HashMap<>(attributes);
    }
    
    /**
     * Sets an attribute value.
     * 
     * @param name The attribute name
     * @param value The attribute value
     */
    public void setAttribute(String name, Object value) {
        attributes.put(name, value);
    }
    
    /**
     * Removes an attribute.
     * 
     * @param name The attribute name
     * @return The removed attribute value, or null if not found
     */
    public Object removeAttribute(String name) {
        return attributes.remove(name);
    }
    
    /**
     * Gets the duration of the test step in milliseconds.
     * 
     * @return The duration
     */
    public long getDuration() {
        return duration;
    }
    
    /**
     * Sets the duration of the test step in milliseconds.
     * 
     * @param duration The duration
     */
    public void setDuration(long duration) {
        this.duration = duration;
    }
    
    /**
     * Gets the formatted duration of the test step.
     * 
     * @return The formatted duration
     */
    public String getFormattedDuration() {
        if (duration < 1000) {
            return duration + " ms";
        } else if (duration < 60000) {
            double seconds = duration / 1000.0;
            return String.format("%.2f s", seconds);
        } else {
            long seconds = duration / 1000;
            long minutes = seconds / 60;
            seconds %= 60;
            return String.format("%d m %d s", minutes, seconds);
        }
    }
    
    /**
     * Gets the stack trace of the test step.
     * 
     * @return The stack trace
     */
    public String getStackTrace() {
        return stackTrace;
    }
    
    /**
     * Sets the stack trace of the test step.
     * 
     * @param stackTrace The stack trace
     */
    public void setStackTrace(String stackTrace) {
        this.stackTrace = stackTrace;
    }
    
    /**
     * Gets the expected result of the test step.
     * 
     * @return The expected result
     */
    public String getExpectedResult() {
        return expectedResult;
    }
    
    /**
     * Sets the expected result of the test step.
     * 
     * @param expectedResult The expected result
     */
    public void setExpectedResult(String expectedResult) {
        this.expectedResult = expectedResult;
    }
    
    /**
     * Gets the actual result of the test step.
     * 
     * @return The actual result
     */
    public String getActualResult() {
        return actualResult;
    }
    
    /**
     * Sets the actual result of the test step.
     * 
     * @param actualResult The actual result
     */
    public void setActualResult(String actualResult) {
        this.actualResult = actualResult;
    }
    
    /**
     * Gets the error message of the test step.
     * 
     * @return The error message
     */
    public String getErrorMessage() {
        return errorMessage;
    }
    
    /**
     * Sets the error message of the test step.
     * 
     * @param errorMessage The error message
     */
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
    
    /**
     * Gets the selector of the test step.
     * 
     * @return The selector
     */
    public String getSelector() {
        return selector;
    }
    
    /**
     * Sets the selector of the test step.
     * 
     * @param selector The selector
     */
    public void setSelector(String selector) {
        this.selector = selector;
    }
    
    /**
     * Gets the action of the test step.
     * 
     * @return The action
     */
    public String getAction() {
        return action;
    }
    
    /**
     * Sets the action of the test step.
     * 
     * @param action The action
     */
    public void setAction(String action) {
        this.action = action;
    }
    
    /**
     * Gets all action parameters.
     * 
     * @return Map of all action parameters
     */
    public Map<String, String> getActionParams() {
        return new HashMap<>(actionParams);
    }
    
    /**
     * Gets an action parameter value.
     * 
     * @param name The parameter name
     * @return The parameter value, or null if not found
     */
    public String getActionParam(String name) {
        return actionParams.get(name);
    }
    
    /**
     * Sets an action parameter value.
     * 
     * @param name The parameter name
     * @param value The parameter value
     */
    public void setActionParam(String name, String value) {
        actionParams.put(name, value);
    }
    
    /**
     * Sets all action parameters.
     * 
     * @param params The parameters
     */
    public void setActionParams(Map<String, String> params) {
        this.actionParams.clear();
        if (params != null) {
            this.actionParams.putAll(params);
        }
    }
    
    /**
     * Removes an action parameter.
     * 
     * @param name The parameter name
     * @return The removed parameter value, or null if not found
     */
    public String removeActionParam(String name) {
        return actionParams.remove(name);
    }
    
    /**
     * Gets a formatted description of the test step.
     * 
     * @return The formatted description
     */
    public String getFormattedDescription() {
        if (action != null && !action.isEmpty()) {
            StringBuilder sb = new StringBuilder();
            sb.append(action);
            
            if (selector != null && !selector.isEmpty()) {
                sb.append(" on element with selector '").append(selector).append("'");
            }
            
            if (!actionParams.isEmpty()) {
                sb.append(" with parameters: ");
                int index = 0;
                for (Map.Entry<String, String> entry : actionParams.entrySet()) {
                    if (index > 0) {
                        sb.append(", ");
                    }
                    sb.append(entry.getKey()).append("=").append(entry.getValue());
                    index++;
                }
            }
            
            return sb.toString();
        } else {
            return description;
        }
    }
    
    /**
     * Converts the test step to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append("\"id\": \"").append(id).append("\",");
        sb.append("\"testId\": \"").append(testId).append("\",");
        sb.append("\"name\": \"").append(name).append("\",");
        sb.append("\"description\": \"").append(description != null ? escapeJson(description) : "").append("\",");
        sb.append("\"timestamp\": \"").append(timestamp).append("\",");
        sb.append("\"status\": ").append(status != null ? status.toJson() : "null").append(",");
        sb.append("\"logLevel\": ").append(logLevel != null ? logLevel.toJson() : "null").append(",");
        sb.append("\"duration\": ").append(duration).append(",");
        sb.append("\"formattedDuration\": \"").append(getFormattedDuration()).append("\",");
        sb.append("\"expectedResult\": ").append(expectedResult != null ? "\"" + escapeJson(expectedResult) + "\"" : "null").append(",");
        sb.append("\"actualResult\": ").append(actualResult != null ? "\"" + escapeJson(actualResult) + "\"" : "null").append(",");
        sb.append("\"errorMessage\": ").append(errorMessage != null ? "\"" + escapeJson(errorMessage) + "\"" : "null").append(",");
        sb.append("\"stackTrace\": ").append(stackTrace != null ? "\"" + escapeJson(stackTrace) + "\"" : "null").append(",");
        sb.append("\"selector\": ").append(selector != null ? "\"" + escapeJson(selector) + "\"" : "null").append(",");
        sb.append("\"action\": ").append(action != null ? "\"" + escapeJson(action) + "\"" : "null").append(",");
        
        // Action parameters
        sb.append("\"actionParams\": {");
        int paramIndex = 0;
        for (Map.Entry<String, String> entry : actionParams.entrySet()) {
            if (paramIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": \"").append(escapeJson(entry.getValue())).append("\"");
            paramIndex++;
        }
        sb.append("},");
        
        // Attributes
        sb.append("\"attributes\": {");
        int attrIndex = 0;
        for (Map.Entry<String, Object> entry : attributes.entrySet()) {
            if (attrIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": ");
            appendJsonValue(sb, entry.getValue());
            attrIndex++;
        }
        sb.append("},");
        
        // Screenshots
        sb.append("\"screenshots\": [");
        for (int i = 0; i < screenshots.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("\"").append(screenshots.get(i).getId()).append("\"");
        }
        sb.append("],");
        
        // Attachments
        sb.append("\"attachments\": [");
        for (int i = 0; i < attachments.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("\"").append(attachments.get(i).getId()).append("\"");
        }
        sb.append("],");
        
        // Logs
        sb.append("\"logs\": [");
        for (int i = 0; i < logs.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append(logs.get(i).toJson());
        }
        sb.append("]");
        
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Appends a JSON value to a StringBuilder.
     * 
     * @param sb The StringBuilder to append to
     * @param value The value to append
     */
    private void appendJsonValue(StringBuilder sb, Object value) {
        if (value == null) {
            sb.append("null");
        } else if (value instanceof Number || value instanceof Boolean) {
            sb.append(value);
        } else if (value instanceof Date) {
            sb.append("\"").append(value).append("\"");
        } else if (value instanceof Map) {
            sb.append("{");
            int index = 0;
            @SuppressWarnings("unchecked")
            Map<Object, Object> map = (Map<Object, Object>) value;
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                if (index > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\": ");
                appendJsonValue(sb, entry.getValue());
                index++;
            }
            sb.append("}");
        } else if (value instanceof List) {
            sb.append("[");
            int index = 0;
            @SuppressWarnings("unchecked")
            List<Object> list = (List<Object>) value;
            for (Object item : list) {
                if (index > 0) {
                    sb.append(",");
                }
                appendJsonValue(sb, item);
                index++;
            }
            sb.append("]");
        } else {
            sb.append("\"").append(escapeJson(value.toString())).append("\"");
        }
    }
    
    /**
     * Escapes a string for JSON.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\r", "\\r")
                .replace("\n", "\\n")
                .replace("\t", "\\t");
    }
    
    @Override
    public String toString() {
        return "CSTestStep{" +
               "id='" + id + '\'' +
               ", name='" + name + '\'' +
               ", status=" + status +
               '}';
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.Serializable;
import java.nio.file.Files;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;

/**
 * Represents a screenshot in the CSTestForge framework.
 */
public class CSScreenshot implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private final String id;
    private final String stepId;
    private final String title;
    private String description;
    private final Date timestamp;
    private final String fileName;
    private final String contentType;
    private byte[] thumbnailData;
    private final Map<String, Object> attributes;
    private String filePath;
    private transient byte[] data;
    private boolean inMemory;
    private int width;
    private int height;
    private String highlightSelector;
    private String browser;
    private String viewport;
    
    /**
     * Constructor for CSScreenshot with a file.
     * 
     * @param stepId The ID of the test step
     * @param file The screenshot file
     * @param title The title of the screenshot
     * @param description The description of the screenshot
     */
    public CSScreenshot(String stepId, File file, String title, String description) {
        this(UUID.randomUUID().toString(), stepId, title, description, new Date());
        
        if (file != null && file.exists()) {
            try {
                this.fileName = file.getName();
                this.contentType = getContentTypeFromFileName(fileName);
                this.filePath = file.getAbsolutePath();
                this.inMemory = false;
                
                // Read file dimensions if it's an image
                if (isImage()) {
                    readImageDimensions(file);
                }
            } catch (Exception e) {
                CSLogger.error("Error reading screenshot file: " + file.getAbsolutePath(), e);
                throw new RuntimeException("Error reading screenshot file", e);
            }
        } else {
            throw new IllegalArgumentException("Screenshot file does not exist: " + 
                                              (file != null ? file.getAbsolutePath() : "null"));
        }
    }
    
    /**
     * Constructor for CSScreenshot with data.
     * 
     * @param stepId The ID of the test step
     * @param data The screenshot data
     * @param title The title of the screenshot
     * @param description The description of the screenshot
     */
    public CSScreenshot(String stepId, byte[] data, String title, String description) {
        this(UUID.randomUUID().toString(), stepId, title, description, new Date());
        
        if (data != null && data.length > 0) {
            this.data = data;
            this.fileName = "screenshot_" + id + ".png";
            this.contentType = "image/png";
            this.inMemory = true;
            
            // Read image dimensions if it's an image
            if (isImage()) {
                readImageDimensions(data);
            }
            
            // Generate thumbnail
            generateThumbnail();
        } else {
            throw new IllegalArgumentException("Screenshot data is null or empty");
        }
    }
    
    /**
     * Constructor for CSScreenshot with specific ID.
     * 
     * @param id The ID of the screenshot
     * @param stepId The ID of the test step
     * @param title The title of the screenshot
     * @param description The description of the screenshot
     * @param timestamp The timestamp of the screenshot
     */
    private CSScreenshot(String id, String stepId, String title, String description, Date timestamp) {
        this.id = id;
        this.stepId = stepId;
        this.title = title;
        this.description = description;
        this.timestamp = timestamp;
        this.attributes = new ConcurrentHashMap<>();
        this.fileName = null;
        this.contentType = null;
    }
    
    /**
     * Gets the ID of the screenshot.
     * 
     * @return The ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Gets the ID of the test step.
     * 
     * @return The step ID
     */
    public String getStepId() {
        return stepId;
    }
    
    /**
     * Gets the title of the screenshot.
     * 
     * @return The title
     */
    public String getTitle() {
        return title;
    }
    
    /**
     * Gets the description of the screenshot.
     * 
     * @return The description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the description of the screenshot.
     * 
     * @param description The description
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * Gets the timestamp of the screenshot.
     * 
     * @return The timestamp
     */
    public Date getTimestamp() {
        return timestamp;
    }
    
    /**
     * Gets the file name of the screenshot.
     * 
     * @return The file name
     */
    public String getFileName() {
        return fileName;
    }
    
    /**
     * Gets the content type of the screenshot.
     * 
     * @return The content type
     */
    public String getContentType() {
        return contentType;
    }
    
    /**
     * Gets the file path of the screenshot.
     * 
     * @return The file path, or null if in-memory
     */
    public String getFilePath() {
        return filePath;
    }
    
    /**
     * Sets the file path of the screenshot.
     * 
     * @param filePath The file path
     */
    public void setFilePath(String filePath) {
        this.filePath = filePath;
        this.inMemory = false;
    }
    
    /**
     * Gets the data of the screenshot.
     * 
     * @return The data
     */
    public byte[] getData() {
        if (inMemory) {
            return data;
        } else if (filePath != null) {
            try {
                // Lazy loading of data from file
                return Files.readAllBytes(new File(filePath).toPath());
            } catch (IOException e) {
                CSLogger.error("Error reading screenshot file: " + filePath, e);
                return null;
            }
        } else {
            return null;
        }
    }
    
    /**
     * Gets the thumbnail data of the screenshot.
     * 
     * @return The thumbnail data
     */
    public byte[] getThumbnailData() {
        if (thumbnailData == null) {
            generateThumbnail();
        }
        return thumbnailData;
    }
    
    /**
     * Checks if the screenshot is stored in memory.
     * 
     * @return True if in-memory, false if file-based
     */
    public boolean isInMemory() {
        return inMemory;
    }
    
    /**
     * Gets an attribute value.
     * 
     * @param name The attribute name
     * @return The attribute value, or null if not found
     */
    public Object getAttribute(String name) {
        return attributes.get(name);
    }
    
    /**
     * Gets all attributes.
     * 
     * @return Map of all attributes
     */
    public Map<String, Object> getAttributes() {
        return new HashMap<>(attributes);
    }
    
    /**
     * Sets an attribute value.
     * 
     * @param name The attribute name
     * @param value The attribute value
     */
    public void setAttribute(String name, Object value) {
        attributes.put(name, value);
    }
    
    /**
     * Removes an attribute.
     * 
     * @param name The attribute name
     * @return The removed attribute value, or null if not found
     */
    public Object removeAttribute(String name) {
        return attributes.remove(name);
    }
    
    /**
     * Gets the width of the screenshot.
     * 
     * @return The width
     */
    public int getWidth() {
        return width;
    }
    
    /**
     * Sets the width of the screenshot.
     * 
     * @param width The width
     */
    public void setWidth(int width) {
        this.width = width;
    }
    
    /**
     * Gets the height of the screenshot.
     * 
     * @return The height
     */
    public int getHeight() {
        return height;
    }
    
    /**
     * Sets the height of the screenshot.
     * 
     * @param height The height
     */
    public void setHeight(int height) {
        this.height = height;
    }
    
    /**
     * Gets the highlight selector of the screenshot.
     * 
     * @return The highlight selector
     */
    public String getHighlightSelector() {
        return highlightSelector;
    }
    
    /**
     * Sets the highlight selector of the screenshot.
     * 
     * @param highlightSelector The highlight selector
     */
    public void setHighlightSelector(String highlightSelector) {
        this.highlightSelector = highlightSelector;
    }
    
    /**
     * Gets the browser used to take the screenshot.
     * 
     * @return The browser
     */
    public String getBrowser() {
        return browser;
    }
    
    /**
     * Sets the browser used to take the screenshot.
     * 
     * @param browser The browser
     */
    public void setBrowser(String browser) {
        this.browser = browser;
    }
    
    /**
     * Gets the viewport used to take the screenshot.
     * 
     * @return The viewport
     */
    public String getViewport() {
        return viewport;
    }
    
    /**
     * Sets the viewport used to take the screenshot.
     * 
     * @param viewport The viewport
     */
    public void setViewport(String viewport) {
        this.viewport = viewport;
    }
    
    /**
     * Saves the screenshot to a file.
     * 
     * @param file The file to save to
     * @return True if successful, false otherwise
     */
    public boolean saveToFile(File file) {
        try {
            if (inMemory && data != null) {
                CSFileUtils.writeBytes(file, data);
                return true;
            } else if (filePath != null) {
                File sourceFile = new File(filePath);
                if (sourceFile.exists()) {
                    CSFileUtils.copyFile(sourceFile, file);
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            CSLogger.error("Error saving screenshot to file: " + file.getAbsolutePath(), e);
            return false;
        }
    }
    
    /**
     * Checks if the screenshot is an image.
     * 
     * @return True if it's an image, false otherwise
     */
    public boolean isImage() {
        return contentType != null && contentType.startsWith("image/");
    }
    
    /**
     * Gets the content type from a file name.
     * 
     * @param fileName The file name
     * @return The content type
     */
    private String getContentTypeFromFileName(String fileName) {
        if (fileName == null) {
            return "application/octet-stream";
        }
        
        String extension = "";
        int i = fileName.lastIndexOf('.');
        if (i > 0) {
            extension = fileName.substring(i + 1).toLowerCase();
        }
        
        switch (extension) {
            case "png":
                return "image/png";
            case "jpg":
            case "jpeg":
                return "image/jpeg";
            case "gif":
                return "image/gif";
            case "bmp":
                return "image/bmp";
            case "webp":
                return "image/webp";
            default:
                return "application/octet-stream";
        }
    }
    
    /**
     * Reads the dimensions of an image file.
     * 
     * @param file The image file
     */
    private void readImageDimensions(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            // This is a simplified implementation
            // In a real implementation, you would use libraries like ImageIO
            // to read the actual dimensions of the image
            
            // For PNG files, the dimensions are stored at a specific offset
            if (contentType.equals("image/png")) {
                fis.skip(16); // Skip to the width/height data
                width = readInt(fis);
                height = readInt(fis);
            } else {
                // For other formats, we would need format-specific code
                // For simplicity, we'll just set default values
                width = 800;
                height = 600;
            }
        } catch (Exception e) {
            CSLogger.warn("Could not read image dimensions: " + file.getAbsolutePath(), e);
            // Set default dimensions
            width = 800;
            height = 600;
        }
    }
    
    /**
     * Reads the dimensions of an image from byte array.
     * 
     * @param imageData The image data
     */
    private void readImageDimensions(byte[] imageData) {
        // This is a simplified implementation
        // In a real implementation, you would use libraries like ImageIO
        // to read the actual dimensions of the image
        
        // For simplicity, we'll just set default values
        width = 800;
        height = 600;
    }
    
    /**
     * Reads a 4-byte integer from an input stream.
     * 
     * @param is The input stream
     * @return The integer value
     * @throws IOException If an I/O error occurs
     */
    private int readInt(FileInputStream is) throws IOException {
        byte[] buf = new byte[4];
        is.read(buf);
        return ((buf[0] & 0xFF) << 24) | ((buf[1] & 0xFF) << 16) |
               ((buf[2] & 0xFF) << 8) | (buf[3] & 0xFF);
    }
    
    /**
     * Generates a thumbnail of the screenshot.
     */
    private void generateThumbnail() {
        // This is a simplified implementation
        // In a real implementation, you would use libraries like ImageIO
        // to generate an actual thumbnail
        
        // For simplicity, we'll just use the original data
        if (inMemory && data != null) {
            thumbnailData = data;
        } else if (filePath != null) {
            try {
                thumbnailData = Files.readAllBytes(new File(filePath).toPath());
            } catch (IOException e) {
                CSLogger.error("Error generating thumbnail: " + filePath, e);
            }
        }
    }
    
    /**
     * Converts the screenshot to a base64 data URL.
     * 
     * @return The base64 data URL
     */
    public String toBase64DataUrl() {
        byte[] imageData = getData();
        if (imageData != null) {
            String base64 = java.util.Base64.getEncoder().encodeToString(imageData);
            return "data:" + contentType + ";base64," + base64;
        } else {
            return null;
        }
    }
    
    /**
     * Converts the screenshot to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append("\"id\": \"").append(id).append("\",");
        sb.append("\"stepId\": \"").append(stepId).append("\",");
        sb.append("\"title\": \"").append(title).append("\",");
        sb.append("\"description\": \"").append(description != null ? escapeJson(description) : "").append("\",");
        sb.append("\"timestamp\": \"").append(timestamp).append("\",");
        sb.append("\"fileName\": \"").append(fileName).append("\",");
        sb.append("\"contentType\": \"").append(contentType).append("\",");
        sb.append("\"filePath\": ").append(filePath != null ? "\"" + escapeJson(filePath) + "\"" : "null").append(",");
        sb.append("\"inMemory\": ").append(inMemory).append(",");
        sb.append("\"width\": ").append(width).append(",");
        sb.append("\"height\": ").append(height).append(",");
        sb.append("\"browser\": ").append(browser != null ? "\"" + browser + "\"" : "null").append(",");
        sb.append("\"viewport\": ").append(viewport != null ? "\"" + viewport + "\"" : "null").append(",");
        sb.append("\"highlightSelector\": ").append(highlightSelector != null ? "\"" + escapeJson(highlightSelector) + "\"" : "null").append(",");
        
        // Attributes
        sb.append("\"attributes\": {");
        int attrIndex = 0;
        for (Map.Entry<String, Object> entry : attributes.entrySet()) {
            if (attrIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": ");
            appendJsonValue(sb, entry.getValue());
            attrIndex++;
        }
        sb.append("},");
        
        // Include a data URL for small images
        if (inMemory && data != null && data.length < 1024 * 10) { // 10KB max
            sb.append("\"dataUrl\": \"").append(toBase64DataUrl()).append("\"");
        } else {
            sb.append("\"dataUrl\": null");
        }
        
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Appends a JSON value to a StringBuilder.
     * 
     * @param sb The StringBuilder to append to
     * @param value The value to append
     */
    private void appendJsonValue(StringBuilder sb, Object value) {
        if (value == null) {
            sb.append("null");
        } else if (value instanceof Number || value instanceof Boolean) {
            sb.append(value);
        } else if (value instanceof Date) {
            sb.append("\"").append(value).append("\"");
        } else if (value instanceof Map) {
            sb.append("{");
            int index = 0;
            @SuppressWarnings("unchecked")
            Map<Object, Object> map = (Map<Object, Object>) value;
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                if (index > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\": ");
                appendJsonValue(sb, entry.getValue());
                index++;
            }
            sb.append("}");
        } else if (value instanceof Iterable) {
            sb.append("[");
            int index = 0;
            for (Object item : (Iterable<?>) value) {
                if (index > 0) {
                    sb.append(",");
                }
                appendJsonValue(sb, item);
                index++;
            }
            sb.append("]");
        } else {
            sb.append("\"").append(escapeJson(value.toString())).append("\"");
        }
    }
    
    /**
     * Escapes a string for JSON.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\r", "\\r")
                .replace("\n", "\\n")
                .replace("\t", "\\t");
    }
    
    @Override
    public String toString() {
        return "CSScreenshot{" +
               "id='" + id + '\'' +
               ", title='" + title + '\'' +
               ", fileName='" + fileName + '\'' +
               '}';
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.nio.file.Files;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.framework.core.utils.CSLogger;

/**
 * Represents an attachment in the CSTestForge framework.
 */
public class CSAttachment implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private final String id;
    private final String stepId;
    private final String title;
    private String description;
    private final Date timestamp;
    private final String fileName;
    private final String contentType;
    private final Map<String, Object> attributes;
    private String filePath;
    private transient byte[] data;
    private boolean inMemory;
    private long size;
    
    /**
     * Constructor for CSAttachment with a file.
     * 
     * @param stepId The ID of the test step
     * @param file The attachment file
     * @param title The title of the attachment
     * @param description The description of the attachment
     */
    public CSAttachment(String stepId, File file, String title, String description) {
        this(UUID.randomUUID().toString(), stepId, title, description, new Date());
        
        if (file != null && file.exists()) {
            try {
                this.fileName = file.getName();
                this.contentType = getContentTypeFromFileName(fileName);
                this.filePath = file.getAbsolutePath();
                this.inMemory = false;
                this.size = file.length();
            } catch (Exception e) {
                CSLogger.error("Error reading attachment file: " + file.getAbsolutePath(), e);
                throw new RuntimeException("Error reading attachment file", e);
            }
        } else {
            throw new IllegalArgumentException("Attachment file does not exist: " + 
                                               (file != null ? file.getAbsolutePath() : "null"));
        }
    }
    
    /**
     * Constructor for CSAttachment with data.
     * 
     * @param stepId The ID of the test step
     * @param data The attachment data
     * @param fileName The file name of the attachment
     * @param contentType The content type of the attachment
     * @param title The title of the attachment
     * @param description The description of the attachment
     */
    public CSAttachment(String stepId, byte[] data, String fileName, String contentType, 
                       String title, String description) {
        this(UUID.randomUUID().toString(), stepId, title, description, new Date());
        
        if (data != null && data.length > 0) {
            this.data = data;
            this.fileName = fileName != null ? fileName : "attachment_" + id;
            this.contentType = contentType != null ? contentType : getContentTypeFromFileName(this.fileName);
            this.inMemory = true;
            this.size = data.length;
        } else {
            throw new IllegalArgumentException("Attachment data is null or empty");
        }
    }
    
    /**
     * Constructor for CSAttachment with specific ID.
     * 
     * @param id The ID of the attachment
     * @param stepId The ID of the test step
     * @param title The title of the attachment
     * @param description The description of the attachment
     * @param timestamp The timestamp of the attachment
     */
    private CSAttachment(String id, String stepId, String title, String description, Date timestamp) {
        this.id = id;
        this.stepId = stepId;
        this.title = title;
        this.description = description;
        this.timestamp = timestamp;
        this.attributes = new ConcurrentHashMap<>();
        this.fileName = null;
        this.contentType = null;
    }
    
    /**
     * Gets the ID of the attachment.
     * 
     * @return The ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Gets the ID of the test step.
     * 
     * @return The step ID
     */
    public String getStepId() {
        return stepId;
    }
    
    /**
     * Gets the title of the attachment.
     * 
     * @return The title
     */
    public String getTitle() {
        return title;
    }
    
    /**
     * Gets the description of the attachment.
     * 
     * @return The description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the description of the attachment.
     * 
     * @param description The description
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * Gets the timestamp of the attachment.
     * 
     * @return The timestamp
     */
    public Date getTimestamp() {
        return timestamp;
    }
    
    /**
     * Gets the file name of the attachment.
     * 
     * @return The file name
     */
    public String getFileName() {
        return fileName;
    }
    
    /**
     * Gets the content type of the attachment.
     * 
     * @return The content type
     */
    public String getContentType() {
        return contentType;
    }
    
    /**
     * Gets the file path of the attachment.
     * 
     * @return The file path, or null if in-memory
     */
    public String getFilePath() {
        return filePath;
    }
    
    /**
     * Sets the file path of the attachment.
     * 
     * @param filePath The file path
     */
    public void setFilePath(String filePath) {
        this.filePath = filePath;
        this.inMemory = false;
    }
    
    /**
     * Gets the data of the attachment.
     * 
     * @return The data
     */
    public byte[] getData() {
        if (inMemory) {
            return data;
        } else if (filePath != null) {
            try {
                // Lazy loading of data from file
                return Files.readAllBytes(new File(filePath).toPath());
            } catch (IOException e) {
                CSLogger.error("Error reading attachment file: " + filePath, e);
                return null;
            }
        } else {
            return null;
        }
    }
    
    /**
     * Checks if the attachment is stored in memory.
     * 
     * @return True if in-memory, false if file-based
     */
    public boolean isInMemory() {
        return inMemory;
    }
    
    /**
     * Gets the size of the attachment in bytes.
     * 
     * @return The size
     */
    public long getSize() {
        return size;
    }
    
    /**
     * Gets the formatted size of the attachment.
     * 
     * @return The formatted size
     */
    public String getFormattedSize() {
        if (size < 1024) {
            return size + " B";
        } else if (size < 1024 * 1024) {
            double sizeKB = size / 1024.0;
            return String.format("%.2f KB", sizeKB);
        } else if (size < 1024 * 1024 * 1024) {
            double sizeMB = size / (1024.0 * 1024.0);
            return String.format("%.2f MB", sizeMB);
        } else {
            double sizeGB = size / (1024.0 * 1024.0 * 1024.0);
            return String.format("%.2f GB", sizeGB);
        }
    }
    
    /**
     * Gets an attribute value.
     * 
     * @param name The attribute name
     * @return The attribute value, or null if not found
     */
    public Object getAttribute(String name) {
        return attributes.get(name);
    }
    
    /**
     * Gets all attributes.
     * 
     * @return Map of all attributes
     */
    public Map<String, Object> getAttributes() {
        return new HashMap<>(attributes);
    }
    
    /**
     * Sets an attribute value.
     * 
     * @param name The attribute name
     * @param value The attribute value
     */
    public void setAttribute(String name, Object value) {
        attributes.put(name, value);
    }
    
    /**
     * Removes an attribute.
     * 
     * @param name The attribute name
     * @return The removed attribute value, or null if not found
     */
    public Object removeAttribute(String name) {
        return attributes.remove(name);
    }
    
    /**
     * Saves the attachment to a file.
     * 
     * @param file The file to save to
     * @return True if successful, false otherwise
     */
    public boolean saveToFile(File file) {
        try {
            if (inMemory && data != null) {
                CSFileUtils.writeBytes(file, data);
                return true;
            } else if (filePath != null) {
                File sourceFile = new File(filePath);
                if (sourceFile.exists()) {
                    CSFileUtils.copyFile(sourceFile, file);
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            CSLogger.error("Error saving attachment to file: " + file.getAbsolutePath(), e);
            return false;
        }
    }
    
    /**
     * Gets the content type from a file name.
     * 
     * @param fileName The file name
     * @return The content type
     */
    private String getContentTypeFromFileName(String fileName) {
        if (fileName == null) {
            return "application/octet-stream";
        }
        
        String extension = "";
        int i = fileName.lastIndexOf('.');
        if (i > 0) {
            extension = fileName.substring(i + 1).toLowerCase();
        }
        
        switch (extension) {
            case "html":
            case "htm":
                return "text/html";
            case "css":
                return "text/css";
            case "js":
                return "application/javascript";
            case "json":
                return "application/json";
            case "xml":
                return "application/xml";
            case "txt":
                return "text/plain";
            case "pdf":
                return "application/pdf";
            case "doc":
                return "application/msword";
            case "docx":
                return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
            case "xls":
                return "application/vnd.ms-excel";
            case "xlsx":
                return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            case "ppt":
                return "application/vnd.ms-powerpoint";
            case "pptx":
                return "application/vnd.openxmlformats-officedocument.presentationml.presentation";
            case "png":
                return "image/png";
            case "jpg":
            case "jpeg":
                return "image/jpeg";
            case "gif":
                return "image/gif";
            case "bmp":
                return "image/bmp";
            case "svg":
                return "image/svg+xml";
            case "zip":
                return "application/zip";
            case "rar":
                return "application/x-rar-compressed";
            case "tar":
                return "application/x-tar";
            case "7z":
                return "application/x-7z-compressed";
            case "mp3":
                return "audio/mpeg";
            case "mp4":
                return "video/mp4";
            case "avi":
                return "video/x-msvideo";
            case "mov":
                return "video/quicktime";
            case "log":
                return "text/plain";
            case "csv":
                return "text/csv";
            case "tsv":
                return "text/tab-separated-values";
            default:
                return "application/octet-stream";
        }
    }
    
    /**
     * Checks if the attachment is a text file.
     * 
     * @return True if it's a text file, false otherwise
     */
    public boolean isText() {
        return contentType != null && 
               (contentType.startsWith("text/") || 
                contentType.equals("application/json") || 
                contentType.equals("application/xml") || 
                contentType.equals("application/javascript"));
    }
    
    /**
     * Checks if the attachment is an image.
     * 
     * @return True if it's an image, false otherwise
     */
    public boolean isImage() {
        return contentType != null && contentType.startsWith("image/");
    }
    
    /**
     * Checks if the attachment is a PDF.
     * 
     * @return True if it's a PDF, false otherwise
     */
    public boolean isPdf() {
        return contentType != null && contentType.equals("application/pdf");
    }
    
    /**
     * Checks if the attachment is a video.
     * 
     * @return True if it's a video, false otherwise
     */
    public boolean isVideo() {
        return contentType != null && contentType.startsWith("video/");
    }
    
    /**
     * Checks if the attachment is an audio file.
     * 
     * @return True if it's an audio file, false otherwise
     */
    public boolean isAudio() {
        return contentType != null && contentType.startsWith("audio/");
    }
    
    /**
     * Gets the text content of the attachment.
     * 
     * @return The text content, or null if not a text file or an error occurs
     */
    public String getTextContent() {
        if (!isText()) {
            return null;
        }
        
        byte[] contentData = getData();
        if (contentData != null) {
            try {
                return new String(contentData, "UTF-8");
            } catch (Exception e) {
                CSLogger.error("Error reading text content", e);
                return null;
            }
        } else {
            return null;
        }
    }
    
    /**
     * Converts the attachment to a base64 data URL.
     * 
     * @return The base64 data URL
     */
    public String toBase64DataUrl() {
        byte[] attachmentData = getData();
        if (attachmentData != null) {
            String base64 = java.util.Base64.getEncoder().encodeToString(attachmentData);
            return "data:" + contentType + ";base64," + base64;
        } else {
            return null;
        }
    }
    
    /**
     * Converts the attachment to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append("\"id\": \"").append(id).append("\",");
        sb.append("\"stepId\": \"").append(stepId).append("\",");
        sb.append("\"title\": \"").append(title).append("\",");
        sb.append("\"description\": \"").append(description != null ? escapeJson(description) : "").append("\",");
        sb.append("\"timestamp\": \"").append(timestamp).append("\",");
        sb.append("\"fileName\": \"").append(fileName).append("\",");
        sb.append("\"contentType\": \"").append(contentType).append("\",");
        sb.append("\"filePath\": ").append(filePath != null ? "\"" + escapeJson(filePath) + "\"" : "null").append(",");
        sb.append("\"inMemory\": ").append(inMemory).append(",");
        sb.append("\"size\": ").append(size).append(",");
        sb.append("\"formattedSize\": \"").append(getFormattedSize()).append("\",");
        sb.append("\"isText\": ").append(isText()).append(",");
        sb.append("\"isImage\": ").append(isImage()).append(",");
        sb.append("\"isPdf\": ").append(isPdf()).append(",");
        sb.append("\"isVideo\": ").append(isVideo()).append(",");
        sb.append("\"isAudio\": ").append(isAudio()).append(",");
        
        // Attributes
        sb.append("\"attributes\": {");
        int attrIndex = 0;
        for (Map.Entry<String, Object> entry : attributes.entrySet()) {
            if (attrIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": ");
            appendJsonValue(sb, entry.getValue());
            attrIndex++;
        }
        sb.append("},");
        
        // Include a data URL for small text files
        if (isText() && size < 1024 * 10) { // 10KB max
            String textContent = getTextContent();
            if (textContent != null) {
                sb.append("\"textContent\": \"").append(escapeJson(textContent)).append("\",");
            } else {
                sb.append("\"textContent\": null,");
            }
        } else {
            sb.append("\"textContent\": null,");
        }
        
        // Include a data URL for small images
        if (isImage() && size < 1024 * 10) { // 10KB max
            sb.append("\"dataUrl\": \"").append(toBase64DataUrl()).append("\"");
        } else {
            sb.append("\"dataUrl\": null");
        }
        
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Appends a JSON value to a StringBuilder.
     * 
     * @param sb The StringBuilder to append to
     * @param value The value to append
     */
    private void appendJsonValue(StringBuilder sb, Object value) {
        if (value == null) {
            sb.append("null");
        } else if (value instanceof Number || value instanceof Boolean) {
            sb.append(value);
        } else if (value instanceof Date) {
            sb.append("\"").append(value).append("\"");
        } else if (value instanceof Map) {
            sb.append("{");
            int index = 0;
            @SuppressWarnings("unchecked")
            Map<Object, Object> map = (Map<Object, Object>) value;
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                if (index > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\": ");
                appendJsonValue(sb, entry.getValue());
                index++;
            }
            sb.append("}");
        } else if (value instanceof Iterable) {
            sb.append("[");
            int index = 0;
            for (Object item : (Iterable<?>) value) {
                if (index > 0) {
                    sb.append(",");
                }
                appendJsonValue(sb, item);
                index++;
            }
            sb.append("]");
        } else {
            sb.append("\"").append(escapeJson(value.toString())).append("\"");
        }
    }
    
    /**
     * Escapes a string for JSON.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\r", "\\r")
                .replace("\n", "\\n")
                .replace("\t", "\\t");
    }
    
    @Override
    public String toString() {
        return "CSAttachment{" +
               "id='" + id + '\'' +
               ", title='" + title + '\'' +
               ", fileName='" + fileName + '\'' +
               ", size=" + getFormattedSize() +
               '}';
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.Serializable;
import java.util.Date;
import java.util.UUID;

/**
 * Represents a log entry in the CSTestForge framework.
 */
public class CSLog implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private final String id;
    private final String stepId;
    private final CSLogLevel level;
    private final String message;
    private final Date timestamp;
    private String threadName;
    private String className;
    private String methodName;
    private int lineNumber;
    private String loggerName;
    private transient Throwable throwable;
    private String throwableString;
    
    /**
     * Constructor for CSLog.
     * 
     * @param stepId The ID of the test step
     * @param level The log level
     * @param message The log message
     */
    public CSLog(String stepId, CSLogLevel level, String message) {
        this(UUID.randomUUID().toString(), stepId, level, message, new Date());
    }
    
    /**
     * Constructor for CSLog with a throwable.
     * 
     * @param stepId The ID of the test step
     * @param level The log level
     * @param message The log message
     * @param throwable The throwable
     */
    public CSLog(String stepId, CSLogLevel level, String message, Throwable throwable) {
        this(UUID.randomUUID().toString(), stepId, level, message, new Date());
        setThrowable(throwable);
    }
    
    /**
     * Constructor for CSLog with a specific ID.
     * 
     * @param id The ID of the log
     * @param stepId The ID of the test step
     * @param level The log level
     * @param message The log message
     * @param timestamp The timestamp of the log
     */
    public CSLog(String id, String stepId, CSLogLevel level, String message, Date timestamp) {
        this.id = id;
        this.stepId = stepId;
        this.level = level;
        this.message = message;
        this.timestamp = timestamp;
        this.threadName = Thread.currentThread().getName();
        
        // Capture caller information
        captureCallerInfo();
    }
    
    /**
     * Gets the ID of the log.
     * 
     * @return The ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Gets the ID of the test step.
     * 
     * @return The step ID
     */
    public String getStepId() {
        return stepId;
    }
    
    /**
     * Gets the log level.
     * 
     * @return The log level
     */
    public CSLogLevel getLevel() {
        return level;
    }
    
    /**
     * Gets the log message.
     * 
     * @return The message
     */
    public String getMessage() {
        return message;
    }
    
    /**
     * Gets the timestamp of the log.
     * 
     * @return The timestamp
     */
    public Date getTimestamp() {
        return timestamp;
    }
    
    /**
     * Gets the thread name.
     * 
     * @return The thread name
     */
    public String getThreadName() {
        return threadName;
    }
    
    /**
     * Sets the thread name.
     * 
     * @param threadName The thread name
     */
    public void setThreadName(String threadName) {
        this.threadName = threadName;
    }
    
    /**
     * Gets the class name.
     * 
     * @return The class name
     */
    public String getClassName() {
        return className;
    }
    
    /**
     * Sets the class name.
     * 
     * @param className The class name
     */
    public void setClassName(String className) {
        this.className = className;
    }
    
    /**
     * Gets the method name.
     * 
     * @return The method name
     */
    public String getMethodName() {
        return methodName;
    }
    
    /**
     * Sets the method name.
     * 
     * @param methodName The method name
     */
    public void setMethodName(String methodName) {
        this.methodName = methodName;
    }
    
    /**
     * Gets the line number.
     * 
     * @return The line number
     */
    public int getLineNumber() {
        return lineNumber;
    }
    
    /**
     * Sets the line number.
     * 
     * @param lineNumber The line number
     */
    public void setLineNumber(int lineNumber) {
        this.lineNumber = lineNumber;
    }
    
    /**
     * Gets the logger name.
     * 
     * @return The logger name
     */
    public String getLoggerName() {
        return loggerName;
    }
    
    /**
     * Sets the logger name.
     * 
     * @param loggerName The logger name
     */
    public void setLoggerName(String loggerName) {
        this.loggerName = loggerName;
    }
    
    /**
     * Gets the throwable.
     * 
     * @return The throwable
     */
    public Throwable getThrowable() {
        return throwable;
    }
    
    /**
     * Sets the throwable.
     * 
     * @param throwable The throwable
     */
    public void setThrowable(Throwable throwable) {
        this.throwable = throwable;
        if (throwable != null) {
            StringBuilder sb = new StringBuilder();
            sb.append(throwable.toString()).append("\n");
            
            for (StackTraceElement element : throwable.getStackTrace()) {
                sb.append("\tat ").append(element.toString()).append("\n");
            }
            
            Throwable cause = throwable.getCause();
            while (cause != null) {
                sb.append("Caused by: ").append(cause.toString()).append("\n");
                for (StackTraceElement element : cause.getStackTrace()) {
                    sb.append("\tat ").append(element.toString()).append("\n");
                }
                cause = cause.getCause();
            }
            
            this.throwableString = sb.toString();
        } else {
            this.throwableString = null;
        }
    }
    
    /**
     * Gets the throwable as a string.
     * 
     * @return The throwable string
     */
    public String getThrowableString() {
        return throwableString;
    }
    
    /**
     * Sets the throwable string.
     * 
     * @param throwableString The throwable string
     */
    public void setThrowableString(String throwableString) {
        this.throwableString = throwableString;
    }
    
    /**
     * Gets the location information as a string.
     * 
     * @return The location information
     */
    public String getLocationInfo() {
        if (className != null && methodName != null) {
            return className + "." + methodName + 
                  (lineNumber > 0 ? ":" + lineNumber : "");
        } else {
            return "";
        }
    }
    
    /**
     * Gets the formatted timestamp.
     * 
     * @return The formatted timestamp
     */
    public String getFormattedTimestamp() {
        return timestamp.toString();
    }
    
    /**
     * Captures caller information (class, method, line number).
     */
    private void captureCallerInfo() {
        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
        
        // Find the first entry that is not part of this class or Thread class
        for (int i = 0; i < stackTrace.length; i++) {
            StackTraceElement element = stackTrace[i];
            String className = element.getClassName();
            
            if (!className.equals(getClass().getName()) && 
                !className.equals(Thread.class.getName()) &&
                !className.contains("java.lang.reflect") &&
                !className.contains("sun.reflect")) {
                
                this.className = className;
                this.methodName = element.getMethodName();
                this.lineNumber = element.getLineNumber();
                
                // Try to extract logger name from class name
                int lastDot = className.lastIndexOf('.');
                if (lastDot > 0) {
                    this.loggerName = className.substring(0, lastDot);
                } else {
                    this.loggerName = className;
                }
                
                break;
            }
        }
    }
    
    /**
     * Formats the log entry as a string.
     * 
     * @return The formatted log entry
     */
    public String format() {
        StringBuilder sb = new StringBuilder();
        
        sb.append(getFormattedTimestamp())
          .append(" [").append(threadName).append("] ")
          .append(level).append(" - ");
        
        if (className != null && methodName != null) {
            sb.append(className).append(".").append(methodName)
              .append("(").append(lineNumber).append(") - ");
        }
        
        sb.append(message);
        
        if (throwableString != null && !throwableString.isEmpty()) {
            sb.append("\n").append(throwableString);
        }
        
        return sb.toString();
    }
    
    /**
     * Converts the log to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append("\"id\": \"").append(id).append("\",");
        sb.append("\"stepId\": \"").append(stepId).append("\",");
        sb.append("\"level\": ").append(level != null ? level.toJson() : "null").append(",");
        sb.append("\"message\": \"").append(escapeJson(message)).append("\",");
        sb.append("\"timestamp\": \"").append(timestamp).append("\",");
        sb.append("\"formattedTimestamp\": \"").append(getFormattedTimestamp()).append("\",");
        sb.append("\"threadName\": \"").append(threadName).append("\",");
        sb.append("\"className\": ").append(className != null ? "\"" + className + "\"" : "null").append(",");
        sb.append("\"methodName\": ").append(methodName != null ? "\"" + methodName + "\"" : "null").append(",");
        sb.append("\"lineNumber\": ").append(lineNumber).append(",");
        sb.append("\"loggerName\": ").append(loggerName != null ? "\"" + loggerName + "\"" : "null").append(",");
        sb.append("\"throwableString\": ").append(throwableString != null ? "\"" + escapeJson(throwableString) + "\"" : "null").append(",");
        sb.append("\"locationInfo\": \"").append(getLocationInfo()).append("\"");
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Escapes a string for JSON.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\r", "\\r")
                .replace("\n", "\\n")
                .replace("\t", "\\t");
    }
    
    @Override
    public String toString() {
        return format();
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.File;
import java.io.Serializable;
import java.util.List;
import java.util.Map;

/**
 * Interface for a test report in the CSTestForge framework.
 * A report is a collection of test suites with aggregated results and metrics.
 */
public interface CSReport extends Serializable {
    
    /**
     * Gets the ID of the report.
     * 
     * @return The report ID
     */
    String getId();
    
    /**
     * Gets the name of the report.
     * 
     * @return The report name
     */
    String getName();
    
    /**
     * Gets the format of the report.
     * 
     * @return The report format (e.g., "html", "pdf", "xml", "json")
     */
    String getFormat();
    
    /**
     * Gets the generation time of the report.
     * 
     * @return The generation time
     */
    java.util.Date getGenerationTime();
    
    /**
     * Gets the list of test suites in the report.
     * 
     * @return The list of test suites
     */
    List<CSTestSuite> getTestSuites();
    
    /**
     * Gets a test suite by ID.
     * 
     * @param suiteId The ID of the test suite
     * @return The test suite, or null if not found
     */
    CSTestSuite getTestSuite(String suiteId);
    
    /**
     * Gets the total number of test suites in the report.
     * 
     * @return The total number of test suites
     */
    int getTestSuiteCount();
    
    /**
     * Gets the total number of test cases in the report.
     * 
     * @return The total number of test cases
     */
    int getTotalTestCount();
    
    /**
     * Gets the number of passed tests in the report.
     * 
     * @return The number of passed tests
     */
    int getPassedTestCount();
    
    /**
     * Gets the number of failed tests in the report.
     * 
     * @return The number of failed tests
     */
    int getFailedTestCount();
    
    /**
     * Gets the number of skipped tests in the report.
     * 
     * @return The number of skipped tests
     */
    int getSkippedTestCount();
    
    /**
     * Gets the pass percentage for all tests in the report.
     * 
     * @return The pass percentage (0-100)
     */
    double getPassPercentage();
    
    /**
     * Gets the total duration of all test suites in the report.
     * 
     * @return The total duration in milliseconds
     */
    long getTotalDuration();
    
    /**
     * Gets the formatted total duration of all test suites in the report.
     * 
     * @return The formatted total duration
     */
    String getFormattedTotalDuration();
    
    /**
     * Gets the dashboard for the report.
     * 
     * @return The dashboard
     */
    CSDashboard getDashboard();
    
    /**
     * Gets a property value.
     * 
     * @param name The property name
     * @return The property value, or null if not found
     */
    Object getProperty(String name);
    
    /**
     * Gets all properties.
     * 
     * @return Map of all properties
     */
    Map<String, Object> getProperties();
    
    /**
     * Sets a property value.
     * 
     * @param name The property name
     * @param value The property value
     */
    void setProperty(String name, Object value);
    
    /**
     * Removes a property.
     * 
     * @param name The property name
     * @return The removed property value, or null if not found
     */
    Object removeProperty(String name);
    
    /**
     * Gets the content of the report.
     * 
     * @return The report content as a byte array
     */
    byte[] getContent();
    
    /**
     * Gets the content type of the report.
     * 
     * @return The content type
     */
    String getContentType();
    
    /**
     * Saves the report to a file.
     * 
     * @param file The file to save to
     * @return True if successful, false otherwise
     */
    boolean saveToFile(File file);
    
    /**
     * Gets the path of the saved report file.
     * 
     * @return The file path, or null if not saved
     */
    String getFilePath();
    
    /**
     * Gets the URL of the report.
     * 
     * @return The URL, or null if not available
     */
    String getUrl();
    
    /**
     * Gets all metrics.
     * 
     * @return Map of all metrics
     */
    Map<String, Object> getMetrics();
    
    /**
     * Gets a metric value.
     * 
     * @param name The metric name
     * @return The metric value, or null if not found
     */
    Object getMetric(String name);
    
    /**
     * Adds a metric.
     * 
     * @param name The metric name
     * @param value The metric value
     */
    void addMetric(String name, Object value);
    
    /**
     * Removes a metric.
     * 
     * @param name The metric name
     * @return The removed metric value, or null if not found
     */
    Object removeMetric(String name);
    
    /**
     * Gets the environments used in the report.
     * 
     * @return List of environments
     */
    List<String> getEnvironments();
    
    /**
     * Gets the browsers used in the report.
     * 
     * @return List of browsers
     */
    List<String> getBrowsers();
    
    /**
     * Gets the operating systems used in the report.
     * 
     * @return List of operating systems
     */
    List<String> getOperatingSystems();
    
    /**
     * Gets all categories used in the report.
     * 
     * @return List of categories
     */
    List<String> getCategories();
    
    /**
     * Gets all tags used in the report.
     * 
     * @return List of tags
     */
    List<String> getTags();
    
    /**
     * Gets all test cases with the specified status.
     * 
     * @param status The status
     * @return List of test cases with the specified status
     */
    List<CSTestCase> getTestCasesByStatus(CSTestStatus status);
    
    /**
     * Gets all test cases with the specified tag.
     * 
     * @param tag The tag
     * @return List of test cases with the specified tag
     */
    List<CSTestCase> getTestCasesByTag(String tag);
    
    /**
     * Gets all test cases with the specified category.
     * 
     * @param category The category
     * @return List of test cases with the specified category
     */
    List<CSTestCase> getTestCasesByCategory(String category);
    
    /**
     * Gets charts for the report.
     * 
     * @return Map of chart name to chart data
     */
    Map<String, Object> getCharts();
    
    /**
     * Gets attachments for the report.
     * 
     * @return List of attachments
     */
    List<CSAttachment> getAttachments();
    
    /**
     * Adds an attachment to the report.
     * 
     * @param attachment The attachment to add
     */
    void addAttachment(CSAttachment attachment);
    
    /**
     * Gets the summary of the report.
     * 
     * @return The summary
     */
    String getSummary();
    
    /**
     * Gets the status of the report.
     * 
     * @return The status
     */
    CSTestStatus getStatus();
    
    /**
     * Converts the report to a JSON representation.
     * 
     * @return The JSON representation
     */
    String toJson();
    
    /**
     * Converts the report to XML.
     * 
     * @return The XML representation
     */
    String toXml();
    
    /**
     * Gets the full path for assets in the report.
     * 
     * @param assetPath The relative asset path
     * @return The full asset path
     */
    String getAssetPath(String assetPath);
    
    /**
     * Gets the report directory.
     * 
     * @return The report directory
     */
    File getReportDirectory();
    
    /**
     * Sets the report directory.
     * 
     * @param directory The report directory
     */
    void setReportDirectory(File directory);
    
    /**
     * Gets custom templates for the report.
     * 
     * @return Map of template name to template content
     */
    Map<String, String> getCustomTemplates();
    
    /**
     * Sets a custom template.
     * 
     * @param name The template name
     * @param content The template content
     */
    void setCustomTemplate(String name, String content);
}


package com.cstestforge.framework.core.reporting;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Represents a dashboard in the CSTestForge framework.
 * A dashboard is a collection of metrics, charts, and other visualizations.
 */
public class CSDashboard implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private final String id;
    private final String name;
    private final Date creationTime;
    private Date lastUpdateTime;
    private final Map<String, CSChart> charts;
    private final Map<String, CSMetric> metrics;
    private final List<CSAttachment> attachments;
    private final Map<String, String> properties;
    private final List<CSTestSuite> testSuites;
    private String htmlContent;
    private String cssContent;
    private String jsContent;
    private final Map<String, Object> dataCache;
    
    /**
     * Constructor for CSDashboard.
     * 
     * @param name The name of the dashboard
     */
    public CSDashboard(String name) {
        this(UUID.randomUUID().toString(), name, new Date());
    }
    
    /**
     * Constructor for CSDashboard with a specific ID.
     * 
     * @param id The ID of the dashboard
     * @param name The name of the dashboard
     * @param creationTime The creation time of the dashboard
     */
    public CSDashboard(String id, String name, Date creationTime) {
        this.id = id;
        this.name = name;
        this.creationTime = creationTime;
        this.lastUpdateTime = creationTime;
        this.charts = new ConcurrentHashMap<>();
        this.metrics = new ConcurrentHashMap<>();
        this.attachments = new CopyOnWriteArrayList<>();
        this.properties = new ConcurrentHashMap<>();
        this.testSuites = new CopyOnWriteArrayList<>();
        this.dataCache = new ConcurrentHashMap<>();
    }
    
    /**
     * Gets the ID of the dashboard.
     * 
     * @return The ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Gets the name of the dashboard.
     * 
     * @return The name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Gets the creation time of the dashboard.
     * 
     * @return The creation time
     */
    public Date getCreationTime() {
        return creationTime;
    }
    
    /**
     * Gets the last update time of the dashboard.
     * 
     * @return The last update time
     */
    public Date getLastUpdateTime() {
        return lastUpdateTime;
    }
    
    /**
     * Updates the last update time of the dashboard to the current time.
     */
    public void updateLastUpdateTime() {
        this.lastUpdateTime = new Date();
    }
    
    /**
     * Gets all charts.
     * 
     * @return Map of chart ID to chart
     */
    public Map<String, CSChart> getCharts() {
        return new HashMap<>(charts);
    }
    
    /**
     * Gets a chart by ID.
     * 
     * @param chartId The ID of the chart
     * @return The chart, or null if not found
     */
    public CSChart getChart(String chartId) {
        return charts.get(chartId);
    }
    
    /**
     * Adds a chart to the dashboard.
     * 
     * @param chart The chart to add
     */
    public void addChart(CSChart chart) {
        charts.put(chart.getId(), chart);
        updateLastUpdateTime();
    }
    
    /**
     * Creates and adds a chart to the dashboard.
     * 
     * @param title The title of the chart
     * @param type The type of the chart
     * @param data The data for the chart
     * @return The created chart
     */
    public CSChart addChart(String title, String type, Object data) {
        CSChart chart = new CSChart(title, type, data);
        addChart(chart);
        return chart;
    }
    
    /**
     * Removes a chart from the dashboard.
     * 
     * @param chartId The ID of the chart to remove
     * @return The removed chart, or null if not found
     */
    public CSChart removeChart(String chartId) {
        CSChart chart = charts.remove(chartId);
        if (chart != null) {
            updateLastUpdateTime();
        }
        return chart;
    }
    
    /**
     * Gets all metrics.
     * 
     * @return Map of metric ID to metric
     */
    public Map<String, CSMetric> getMetrics() {
        return new HashMap<>(metrics);
    }
    
    /**
     * Gets a metric by ID.
     * 
     * @param metricId The ID of the metric
     * @return The metric, or null if not found
     */
    public CSMetric getMetric(String metricId) {
        return metrics.get(metricId);
    }
    
    /**
     * Adds a metric to the dashboard.
     * 
     * @param metric The metric to add
     */
    public void addMetric(CSMetric metric) {
        metrics.put(metric.getId(), metric);
        updateLastUpdateTime();
    }
    
    /**
     * Creates and adds a metric to the dashboard.
     * 
     * @param name The name of the metric
     * @param value The value of the metric
     * @param unit The unit of the metric
     * @return The created metric
     */
    public CSMetric addMetric(String name, Object value, String unit) {
        CSMetric metric = new CSMetric(name, value, unit);
        addMetric(metric);
        return metric;
    }
    
    /**
     * Removes a metric from the dashboard.
     * 
     * @param metricId The ID of the metric to remove
     * @return The removed metric, or null if not found
     */
    public CSMetric removeMetric(String metricId) {
        CSMetric metric = metrics.remove(metricId);
        if (metric != null) {
            updateLastUpdateTime();
        }
        return metric;
    }
    
    /**
     * Gets all attachments.
     * 
     * @return List of attachments
     */
    public List<CSAttachment> getAttachments() {
        return new ArrayList<>(attachments);
    }
    
    /**
     * Adds an attachment to the dashboard.
     * 
     * @param attachment The attachment to add
     */
    public void addAttachment(CSAttachment attachment) {
        attachments.add(attachment);
        updateLastUpdateTime();
    }
    
    /**
     * Removes an attachment from the dashboard.
     * 
     * @param attachmentId The ID of the attachment to remove
     * @return The removed attachment, or null if not found
     */
    public CSAttachment removeAttachment(String attachmentId) {
        for (CSAttachment attachment : attachments) {
            if (attachment.getId().equals(attachmentId)) {
                attachments.remove(attachment);
                updateLastUpdateTime();
                return attachment;
            }
        }
        return null;
    }
    
    /**
     * Gets a property value.
     * 
     * @param name The property name
     * @return The property value, or null if not found
     */
    public String getProperty(String name) {
        return properties.get(name);
    }
    
    /**
     * Gets all properties.
     * 
     * @return Map of all properties
     */
    public Map<String, String> getProperties() {
        return new HashMap<>(properties);
    }
    
    /**
     * Sets a property value.
     * 
     * @param name The property name
     * @param value The property value
     */
    public void setProperty(String name, String value) {
        properties.put(name, value);
        updateLastUpdateTime();
    }
    
    /**
     * Removes a property.
     * 
     * @param name The property name
     * @return The removed property value, or null if not found
     */
    public String removeProperty(String name) {
        return properties.remove(name);
    }
    
    /**
     * Gets all test suites.
     * 
     * @return List of test suites
     */
    public List<CSTestSuite> getTestSuites() {
        return new ArrayList<>(testSuites);
    }
    
    /**
     * Adds a test suite to the dashboard.
     * 
     * @param testSuite The test suite to add
     */
    public void addTestSuite(CSTestSuite testSuite) {
        testSuites.add(testSuite);
        updateLastUpdateTime();
        clearDataCache();
    }
    
    /**
     * Removes a test suite from the dashboard.
     * 
     * @param testSuiteId The ID of the test suite to remove
     * @return The removed test suite, or null if not found
     */
    public CSTestSuite removeTestSuite(String testSuiteId) {
        for (CSTestSuite testSuite : testSuites) {
            if (testSuite.getId().equals(testSuiteId)) {
                testSuites.remove(testSuite);
                updateLastUpdateTime();
                clearDataCache();
                return testSuite;
            }
        }
        return null;
    }
    
    /**
     * Gets the HTML content of the dashboard.
     * 
     * @return The HTML content
     */
    public String getHtmlContent() {
        return htmlContent;
    }
    
    /**
     * Sets the HTML content of the dashboard.
     * 
     * @param htmlContent The HTML content
     */
    public void setHtmlContent(String htmlContent) {
        this.htmlContent = htmlContent;
        updateLastUpdateTime();
    }
    
    /**
     * Gets the CSS content of the dashboard.
     * 
     * @return The CSS content
     */
    public String getCssContent() {
        return cssContent;
    }
    
    /**
     * Sets the CSS content of the dashboard.
     * 
     * @param cssContent The CSS content
     */
    public void setCssContent(String cssContent) {
        this.cssContent = cssContent;
        updateLastUpdateTime();
    }
    
    /**
     * Gets the JavaScript content of the dashboard.
     * 
     * @return The JavaScript content
     */
    public String getJsContent() {
        return jsContent;
    }
    
    /**
     * Sets the JavaScript content of the dashboard.
     * 
     * @param jsContent The JavaScript content
     */
    public void setJsContent(String jsContent) {
        this.jsContent = jsContent;
        updateLastUpdateTime();
    }
    
    /**
     * Gets cached data.
     * 
     * @param key The cache key
     * @return The cached data, or null if not found
     */
    public Object getCachedData(String key) {
        return dataCache.get(key);
    }
    
    /**
     * Caches data.
     * 
     * @param key The cache key
     * @param data The data to cache
     */
    public void cacheData(String key, Object data) {
        dataCache.put(key, data);
    }
    
    /**
     * Clears the data cache.
     */
    public void clearDataCache() {
        dataCache.clear();
    }
    
    /**
     * Gets the total number of test cases.
     * 
     * @return The total number of test cases
     */
    public int getTotalTestCount() {
        int total = 0;
        for (CSTestSuite testSuite : testSuites) {
            total += testSuite.getTotalCount();
        }
        return total;
    }
    
    /**
     * Gets the number of passed tests.
     * 
     * @return The number of passed tests
     */
    public int getPassedTestCount() {
        int passed = 0;
        for (CSTestSuite testSuite : testSuites) {
            passed += testSuite.getPassCount();
        }
        return passed;
    }
    
    /**
     * Gets the number of failed tests.
     * 
     * @return The number of failed tests
     */
    public int getFailedTestCount() {
        int failed = 0;
        for (CSTestSuite testSuite : testSuites) {
            failed += testSuite.getFailCount();
        }
        return failed;
    }
    
    /**
     * Gets the number of skipped tests.
     * 
     * @return The number of skipped tests
     */
    public int getSkippedTestCount() {
        int skipped = 0;
        for (CSTestSuite testSuite : testSuites) {
            skipped += testSuite.getSkipCount();
        }
        return skipped;
    }
    
    /**
     * Gets the pass percentage for all tests.
     * 
     * @return The pass percentage (0-100)
     */
    public double getPassPercentage() {
        int total = getTotalTestCount();
        if (total == 0) {
            return 0;
        }
        return (double) getPassedTestCount() / total * 100;
    }
    
    /**
     * Gets the total duration of all test suites.
     * 
     * @return The total duration in milliseconds
     */
    public long getTotalDuration() {
        long total = 0;
        for (CSTestSuite testSuite : testSuites) {
            long duration = testSuite.getDuration();
            if (duration > 0) {
                total += duration;
            }
        }
        return total;
    }
    
    /**
     * Gets the formatted total duration of all test suites.
     * 
     * @return The formatted total duration
     */
    public String getFormattedTotalDuration() {
        long duration = getTotalDuration();
        if (duration < 0) {
            return "In Progress";
        }
        
        long seconds = duration / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        
        seconds %= 60;
        minutes %= 60;
        
        StringBuilder sb = new StringBuilder();
        if (hours > 0) {
            sb.append(hours).append("h ");
        }
        if (minutes > 0 || hours > 0) {
            sb.append(minutes).append("m ");
        }
        sb.append(seconds).append("s");
        
        return sb.toString();
    }
    
    /**
     * Gets all categories used in test suites.
     * 
     * @return List of categories
     */
    public List<String> getCategories() {
        Map<String, Boolean> categoriesMap = new HashMap<>();
        
        for (CSTestSuite testSuite : testSuites) {
            for (CSTestCase testCase : testSuite.getTestCases()) {
                for (String category : testCase.getCategories()) {
                    categoriesMap.put(category, true);
                }
            }
        }
        
        return new ArrayList<>(categoriesMap.keySet());
    }
    
    /**
     * Gets all tags used in test suites.
     * 
     * @return List of tags
     */
    public List<String> getTags() {
        Map<String, Boolean> tagsMap = new HashMap<>();
        
        for (CSTestSuite testSuite : testSuites) {
            for (String tag : testSuite.getTags()) {
                tagsMap.put(tag, true);
            }
            
            for (CSTestCase testCase : testSuite.getTestCases()) {
                for (String tag : testCase.getTags()) {
                    tagsMap.put(tag, true);
                }
            }
        }
        
        return new ArrayList<>(tagsMap.keySet());
    }
    
    /**
     * Gets all environments used in test suites.
     * 
     * @return List of environments
     */
    public List<String> getEnvironments() {
        Map<String, Boolean> environmentsMap = new HashMap<>();
        
        for (CSTestSuite testSuite : testSuites) {
            String environment = testSuite.getEnvironment();
            if (environment != null && !environment.isEmpty()) {
                environmentsMap.put(environment, true);
            }
        }
        
        return new ArrayList<>(environmentsMap.keySet());
    }
    
    /**
     * Gets all browsers used in test suites.
     * 
     * @return List of browsers
     */
    public List<String> getBrowsers() {
        Map<String, Boolean> browsersMap = new HashMap<>();
        
        for (CSTestSuite testSuite : testSuites) {
            String browser = testSuite.getBrowser();
            if (browser != null && !browser.isEmpty()) {
                browsersMap.put(browser, true);
            }
        }
        
        return new ArrayList<>(browsersMap.keySet());
    }
    
    /**
     * Gets summary metrics for all test suites.
     * 
     * @return Map of metric name to value
     */
    public Map<String, Object> getSummaryMetrics() {
        Map<String, Object> summary = new LinkedHashMap<>();
        
        summary.put("totalTestSuites", testSuites.size());
        summary.put("totalTests", getTotalTestCount());
        summary.put("passedTests", getPassedTestCount());
        summary.put("failedTests", getFailedTestCount());
        summary.put("skippedTests", getSkippedTestCount());
        summary.put("passPercentage", getPassPercentage());
        summary.put("totalDuration", getTotalDuration());
        summary.put("formattedTotalDuration", getFormattedTotalDuration());
        summary.put("environments", getEnvironments());
        summary.put("browsers", getBrowsers());
        summary.put("categories", getCategories());
        summary.put("tags", getTags());
        
        return summary;
    }
    
    /**
     * Generates HTML markup for the dashboard.
     * 
     * @return The HTML markup
     */
    public String generateHtml() {
        StringBuilder html = new StringBuilder();
        html.append("<!DOCTYPE html>\n");
        html.append("<html lang=\"en\">\n");
        html.append("<head>\n");
        html.append("    <meta charset=\"UTF-8\">\n");
        html.append("    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
        html.append("    <title>").append(name).append(" - Test Dashboard</title>\n");
        
        // Include CSS
        html.append("    <style>\n");
        if (cssContent != null && !cssContent.isEmpty()) {
            html.append(cssContent).append("\n");
        } else {
            // Default CSS
            html.append("        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }\n");
            html.append("        .dashboard { max-width: 1200px; margin: 0 auto; }\n");
            html.append("        .dashboard-header { margin-bottom: 20px; }\n");
            html.append("        .metrics-container { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; }\n");
            html.append("        .metric-card { flex: 1; min-width: 200px; padding: 15px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }\n");
            html.append("        .metric-value { font-size: 24px; font-weight: bold; }\n");
            html.append("        .metric-name { font-size: 14px; color: #666; }\n");
            html.append("        .charts-container { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; }\n");
            html.append("        .chart-card { flex: 1; min-width: 400px; padding: 15px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }\n");
            html.append("        .chart-title { font-size: 16px; font-weight: bold; margin-bottom: 10px; }\n");
            html.append("        .pass { color: #4CAF50; }\n");
            html.append("        .fail { color: #F44336; }\n");
            html.append("        .skip { color: #FFC107; }\n");
        }
        html.append("    </style>\n");
        
        html.append("</head>\n");
        html.append("<body>\n");
        html.append("    <div class=\"dashboard\">\n");
        html.append("        <div class=\"dashboard-header\">\n");
        html.append("            <h1>").append(name).append("</h1>\n");
        html.append("            <p>Generated on ").append(new Date()).append("</p>\n");
        html.append("        </div>\n");
        
        // Summary metrics
        html.append("        <div class=\"metrics-container\">\n");
        
        // Test counts
        html.append("            <div class=\"metric-card\">\n");
        html.append("                <div class=\"metric-value\">").append(getTotalTestCount()).append("</div>\n");
        html.append("                <div class=\"metric-name\">Total Tests</div>\n");
        html.append("            </div>\n");
        
        // Passed tests
        html.append("            <div class=\"metric-card\">\n");
        html.append("                <div class=\"metric-value pass\">").append(getPassedTestCount()).append("</div>\n");
        html.append("                <div class=\"metric-name\">Passed Tests</div>\n");
        html.append("            </div>\n");
        
        // Failed tests
        html.append("            <div class=\"metric-card\">\n");
        html.append("                <div class=\"metric-value fail\">").append(getFailedTestCount()).append("</div>\n");
        html.append("                <div class=\"metric-name\">Failed Tests</div>\n");
        html.append("            </div>\n");
        
        // Skipped tests
        html.append("            <div class=\"metric-card\">\n");
        html.append("                <div class=\"metric-value skip\">").append(getSkippedTestCount()).append("</div>\n");
        html.append("                <div class=\"metric-name\">Skipped Tests</div>\n");
        html.append("            </div>\n");
        
        // Pass percentage
        html.append("            <div class=\"metric-card\">\n");
        html.append("                <div class=\"metric-value\">").append(String.format("%.2f%%", getPassPercentage())).append("</div>\n");
        html.append("                <div class=\"metric-name\">Pass Percentage</div>\n");
        html.append("            </div>\n");
        
        // Duration
        html.append("            <div class=\"metric-card\">\n");
        html.append("                <div class=\"metric-value\">").append(getFormattedTotalDuration()).append("</div>\n");
        html.append("                <div class=\"metric-name\">Total Duration</div>\n");
        html.append("            </div>\n");
        
        // Custom metrics
        for (CSMetric metric : metrics.values()) {
            html.append("            <div class=\"metric-card\">\n");
            html.append("                <div class=\"metric-value\">").append(metric.getFormattedValue()).append("</div>\n");
            html.append("                <div class=\"metric-name\">").append(metric.getName()).append("</div>\n");
            html.append("            </div>\n");
        }
        
        html.append("        </div>\n");
        
        // Charts
        if (!charts.isEmpty()) {
            html.append("        <div class=\"charts-container\">\n");
            for (CSChart chart : charts.values()) {
                html.append("            <div class=\"chart-card\">\n");
                html.append("                <div class=\"chart-title\">").append(chart.getTitle()).append("</div>\n");
                html.append("                <div class=\"chart\" id=\"chart-").append(chart.getId()).append("\"></div>\n");
                html.append("            </div>\n");
            }
            html.append("        </div>\n");
        }
        
        // Custom HTML content
        if (htmlContent != null && !htmlContent.isEmpty()) {
            html.append(htmlContent).append("\n");
        }
        
        html.append("    </div>\n");
        
        // Include JavaScript
        html.append("    <script>\n");
        if (jsContent != null && !jsContent.isEmpty()) {
            html.append(jsContent).append("\n");
        } else if (!charts.isEmpty()) {
            // Default chart rendering logic would go here
            // This is a placeholder - actual implementation would use a charting library
            html.append("        // Chart rendering logic would go here\n");
        }
        html.append("    </script>\n");
        
        html.append("</body>\n");
        html.append("</html>");
        
        return html.toString();
    }
    
    /**
     * Converts the dashboard to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append("\"id\": \"").append(id).append("\",");
        sb.append("\"name\": \"").append(name).append("\",");
        sb.append("\"creationTime\": \"").append(creationTime).append("\",");
        sb.append("\"lastUpdateTime\": \"").append(lastUpdateTime).append("\",");
        
        // Summary metrics
        sb.append("\"summary\": {");
        sb.append("\"totalTestSuites\": ").append(testSuites.size()).append(",");
        sb.append("\"totalTests\": ").append(getTotalTestCount()).append(",");
        sb.append("\"passedTests\": ").append(getPassedTestCount()).append(",");
        sb.append("\"failedTests\": ").append(getFailedTestCount()).append(",");
        sb.append("\"skippedTests\": ").append(getSkippedTestCount()).append(",");
        sb.append("\"passPercentage\": ").append(getPassPercentage()).append(",");
        sb.append("\"totalDuration\": ").append(getTotalDuration()).append(",");
        sb.append("\"formattedTotalDuration\": \"").append(getFormattedTotalDuration()).append("\"");
        sb.append("},");
        
        // Charts
        sb.append("\"charts\": {");
        int chartIndex = 0;
        for (Map.Entry<String, CSChart> entry : charts.entrySet()) {
            if (chartIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": ").append(entry.getValue().toJson());
            chartIndex++;
        }
        sb.append("},");
        
        // Metrics
        sb.append("\"metrics\": {");
        int metricIndex = 0;
        for (Map.Entry<String, CSMetric> entry : metrics.entrySet()) {
            if (metricIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": ").append(entry.getValue().toJson());
            metricIndex++;
        }
        sb.append("},");
        
        // Properties
        sb.append("\"properties\": {");
        int propIndex = 0;
        for (Map.Entry<String, String> entry : properties.entrySet()) {
            if (propIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": \"").append(escapeJson(entry.getValue())).append("\"");
            propIndex++;
        }
        sb.append("},");
        
        // Test Suite IDs
        sb.append("\"testSuiteIds\": [");
        for (int i = 0; i < testSuites.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("\"").append(testSuites.get(i).getId()).append("\"");
        }
        sb.append("],");
        
        // Attachment IDs
        sb.append("\"attachmentIds\": [");
        for (int i = 0; i < attachments.size(); i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("\"").append(attachments.get(i).getId()).append("\"");
        }
        sb.append("],");
        
        // HTML, CSS, JS content flags (not including actual content to keep JSON smaller)
        sb.append("\"hasHtmlContent\": ").append(htmlContent != null && !htmlContent.isEmpty()).append(",");
        sb.append("\"hasCssContent\": ").append(cssContent != null && !cssContent.isEmpty()).append(",");
        sb.append("\"hasJsContent\": ").append(jsContent != null && !jsContent.isEmpty());
        
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Escapes a string for JSON.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\r", "\\r")
                .replace("\n", "\\n")
                .replace("\t", "\\t");
    }
    
    @Override
    public String toString() {
        return "CSDashboard{" +
               "id='" + id + '\'' +
               ", name='" + name + '\'' +
               ", testSuites=" + testSuites.size() +
               ", charts=" + charts.size() +
               ", metrics=" + metrics.size() +
               '}';
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import com.cstestforge.framework.core.utils.CSLogger;

/**
 * Represents a chart in the CSTestForge framework.
 * A chart is a visual representation of data.
 */
public class CSChart implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    /**
     * Enum for chart types.
     */
    public enum ChartType {
        BAR("bar"),
        LINE("line"),
        PIE("pie"),
        DONUT("donut"),
        AREA("area"),
        SCATTER("scatter"),
        BUBBLE("bubble"),
        RADAR("radar"),
        POLAR("polar"),
        HEATMAP("heatmap"),
        TIMELINE("timeline"),
        TREEMAP("treemap"),
        SUNBURST("sunburst"),
        GAUGE("gauge"),
        FUNNEL("funnel"),
        BOXPLOT("boxplot"),
        CANDLESTICK("candlestick"),
        WATERFALL("waterfall"),
        SANKEY("sankey"),
        CHORD("chord"),
        CUSTOM("custom");
        
        private final String value;
        
        ChartType(String value) {
            this.value = value;
        }
        
        public String getValue() {
            return value;
        }
        
        public static ChartType fromString(String value) {
            for (ChartType type : ChartType.values()) {
                if (type.getValue().equalsIgnoreCase(value)) {
                    return type;
                }
            }
            return CUSTOM;
        }
    }
    
    private final String id;
    private String title;
    private final ChartType type;
    private final Map<String, Object> options;
    private transient Object data;
    private String serializedData;
    private final Map<String, Object> config;
    private int width;
    private int height;
    private String cssClass;
    private boolean responsive;
    private boolean animate;
    private String tooltipTemplate;
    private String legendTemplate;
    private String axisLabelTemplate;
    private final Map<String, Object> customOptions;
    
    /**
     * Constructor for CSChart.
     * 
     * @param title The title of the chart
     * @param type The type of the chart
     * @param data The data for the chart
     */
    public CSChart(String title, String type, Object data) {
        this(UUID.randomUUID().toString(), title, ChartType.fromString(type), data);
    }
    
    /**
     * Constructor for CSChart with a specific ID.
     * 
     * @param id The ID of the chart
     * @param title The title of the chart
     * @param type The type of the chart
     * @param data The data for the chart
     */
    public CSChart(String id, String title, ChartType type, Object data) {
        this.id = id;
        this.title = title;
        this.type = type;
        this.data = data;
        this.options = new ConcurrentHashMap<>();
        this.config = new ConcurrentHashMap<>();
        this.customOptions = new ConcurrentHashMap<>();
        this.width = 0;
        this.height = 0;
        this.responsive = true;
        this.animate = true;
        
        // Serialize data to string if possible
        serializeData();
    }
    
    /**
     * Gets the ID of the chart.
     * 
     * @return The ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Gets the title of the chart.
     * 
     * @return The title
     */
    public String getTitle() {
        return title;
    }
    
    /**
     * Sets the title of the chart.
     * 
     * @param title The title
     */
    public void setTitle(String title) {
        this.title = title;
    }
    
    /**
     * Gets the type of the chart.
     * 
     * @return The type
     */
    public ChartType getType() {
        return type;
    }
    
    /**
     * Gets the data for the chart.
     * 
     * @return The data
     */
    public Object getData() {
        return data;
    }
    
    /**
     * Sets the data for the chart.
     * 
     * @param data The data
     */
    public void setData(Object data) {
        this.data = data;
        serializeData();
    }
    
    /**
     * Gets the serialized data for the chart.
     * 
     * @return The serialized data
     */
    public String getSerializedData() {
        return serializedData;
    }
    
    /**
     * Gets an option value.
     * 
     * @param name The option name
     * @return The option value, or null if not found
     */
    public Object getOption(String name) {
        return options.get(name);
    }
    
    /**
     * Gets all options.
     * 
     * @return Map of all options
     */
    public Map<String, Object> getOptions() {
        return new HashMap<>(options);
    }
    
    /**
     * Sets an option value.
     * 
     * @param name The option name
     * @param value The option value
     */
    public void setOption(String name, Object value) {
        options.put(name, value);
    }
    
    /**
     * Removes an option.
     * 
     * @param name The option name
     * @return The removed option value, or null if not found
     */
    public Object removeOption(String name) {
        return options.remove(name);
    }
    
    /**
     * Gets a config value.
     * 
     * @param name The config name
     * @return The config value, or null if not found
     */
    public Object getConfig(String name) {
        return config.get(name);
    }
    
    /**
     * Gets all config values.
     * 
     * @return Map of all config values
     */
    public Map<String, Object> getConfig() {
        return new HashMap<>(config);
    }
    
    /**
     * Sets a config value.
     * 
     * @param name The config name
     * @param value The config value
     */
    public void setConfig(String name, Object value) {
        config.put(name, value);
    }
    
    /**
     * Removes a config value.
     * 
     * @param name The config name
     * @return The removed config value, or null if not found
     */
    public Object removeConfig(String name) {
        return config.remove(name);
    }
    
    /**
     * Gets the width of the chart.
     * 
     * @return The width, or 0 if responsive
     */
    public int getWidth() {
        return width;
    }
    
    /**
     * Sets the width of the chart.
     * 
     * @param width The width
     */
    public void setWidth(int width) {
        this.width = width;
    }
    
    /**
     * Gets the height of the chart.
     * 
     * @return The height, or 0 if responsive
     */
    public int getHeight() {
        return height;
    }
    
    /**
     * Sets the height of the chart.
     * 
     * @param height The height
     */
    public void setHeight(int height) {
        this.height = height;
    }
    
    /**
     * Gets the CSS class of the chart.
     * 
     * @return The CSS class
     */
    public String getCssClass() {
        return cssClass;
    }
    
    /**
     * Sets the CSS class of the chart.
     * 
     * @param cssClass The CSS class
     */
    public void setCssClass(String cssClass) {
        this.cssClass = cssClass;
    }
    
    /**
     * Checks if the chart is responsive.
     * 
     * @return True if responsive, false otherwise
     */
    public boolean isResponsive() {
        return responsive;
    }
    
    /**
     * Sets whether the chart is responsive.
     * 
     * @param responsive Whether the chart is responsive
     */
    public void setResponsive(boolean responsive) {
        this.responsive = responsive;
    }
    
    /**
     * Checks if the chart is animated.
     * 
     * @return True if animated, false otherwise
     */
    public boolean isAnimate() {
        return animate;
    }
    
    /**
     * Sets whether the chart is animated.
     * 
     * @param animate Whether the chart is animated
     */
    public void setAnimate(boolean animate) {
        this.animate = animate;
    }
    
    /**
     * Gets the tooltip template.
     * 
     * @return The tooltip template
     */
    public String getTooltipTemplate() {
        return tooltipTemplate;
    }
    
    /**
     * Sets the tooltip template.
     * 
     * @param tooltipTemplate The tooltip template
     */
    public void setTooltipTemplate(String tooltipTemplate) {
        this.tooltipTemplate = tooltipTemplate;
    }
    
    /**
     * Gets the legend template.
     * 
     * @return The legend template
     */
    public String getLegendTemplate() {
        return legendTemplate;
    }
    
    /**
     * Sets the legend template.
     * 
     * @param legendTemplate The legend template
     */
    public void setLegendTemplate(String legendTemplate) {
        this.legendTemplate = legendTemplate;
    }
    
    /**
     * Gets the axis label template.
     * 
     * @return The axis label template
     */
    public String getAxisLabelTemplate() {
        return axisLabelTemplate;
    }
    
    /**
     * Sets the axis label template.
     * 
     * @param axisLabelTemplate The axis label template
     */
    public void setAxisLabelTemplate(String axisLabelTemplate) {
        this.axisLabelTemplate = axisLabelTemplate;
    }
    
    /**
     * Gets a custom option value.
     * 
     * @param name The option name
     * @return The option value, or null if not found
     */
    public Object getCustomOption(String name) {
        return customOptions.get(name);
    }
    
    /**
     * Gets all custom options.
     * 
     * @return Map of all custom options
     */
    public Map<String, Object> getCustomOptions() {
        return new HashMap<>(customOptions);
    }
    
    /**
     * Sets a custom option value.
     * 
     * @param name The option name
     * @param value The option value
     */
    public void setCustomOption(String name, Object value) {
        customOptions.put(name, value);
    }
    
    /**
     * Removes a custom option.
     * 
     * @param name The option name
     * @return The removed option value, or null if not found
     */
    public Object removeCustomOption(String name) {
        return customOptions.remove(name);
    }
    
    /**
     * Serializes the chart data to a string.
     * This is used to store the data in a format that can be deserialized later.
     */
    @SuppressWarnings("unchecked")
    private void serializeData() {
        if (data == null) {
            serializedData = null;
            return;
        }
        
        try {
            if (data instanceof Map) {
                StringBuilder sb = new StringBuilder();
                sb.append("{");
                Map<String, Object> map = (Map<String, Object>) data;
                int index = 0;
                for (Map.Entry<String, Object> entry : map.entrySet()) {
                    if (index > 0) {
                        sb.append(",");
                    }
                    sb.append("\"").append(entry.getKey()).append("\":");
                    appendJsonValue(sb, entry.getValue());
                    index++;
                }
                sb.append("}");
                serializedData = sb.toString();
            } else if (data instanceof List) {
                StringBuilder sb = new StringBuilder();
                sb.append("[");
                List<Object> list = (List<Object>) data;
                for (int i = 0; i < list.size(); i++) {
                    if (i > 0) {
                        sb.append(",");
                    }
                    appendJsonValue(sb, list.get(i));
                }
                sb.append("]");
                serializedData = sb.toString();
            } else if (data instanceof String) {
                // If it's already a JSON string, use it as-is
                String dataStr = (String) data;
                if (dataStr.startsWith("{") && dataStr.endsWith("}") ||
                    dataStr.startsWith("[") && dataStr.endsWith("]")) {
                    serializedData = dataStr;
                } else {
                    serializedData = "\"" + escapeJson(dataStr) + "\"";
                }
            } else if (data instanceof Number || data instanceof Boolean) {
                serializedData = data.toString();
            } else {
                // Try to use toString() as a fallback
                serializedData = "\"" + escapeJson(data.toString()) + "\"";
            }
        } catch (Exception e) {
            CSLogger.error("Failed to serialize chart data", e);
            serializedData = "null";
        }
    }
    
    /**
     * Generates JavaScript code to render the chart.
     * This can be used in HTML reports to render the chart.
     * 
     * @param containerId The ID of the container element
     * @return The JavaScript code
     */
    public String generateRenderCode(String containerId) {
        StringBuilder sb = new StringBuilder();
        
        // Common chart setup
        sb.append("(function() {\n");
        sb.append("    var container = document.getElementById('").append(containerId).append("');\n");
        sb.append("    if (!container) return;\n");
        
        // Set dimensions
        if (width > 0 && height > 0) {
            sb.append("    container.style.width = '").append(width).append("px';\n");
            sb.append("    container.style.height = '").append(height).append("px';\n");
        } else if (width > 0) {
            sb.append("    container.style.width = '").append(width).append("px';\n");
        } else if (height > 0) {
            sb.append("    container.style.height = '").append(height).append("px';\n");
        }
        
        // Add CSS class if specified
        if (cssClass != null && !cssClass.isEmpty()) {
            sb.append("    container.className += ' ").append(cssClass).append("';\n");
        }
        
        // Create chart configuration
        sb.append("    var data = ").append(serializedData != null ? serializedData : "null").append(";\n");
        sb.append("    var options = ").append(generateOptionsJson()).append(";\n");
        
        // Generate chart based on type
        sb.append("    // Create chart using custom chart library\n");
        sb.append("    CSChart.create(container, '").append(type.getValue()).append("', data, options);\n");
        
        sb.append("})();\n");
        
        return sb.toString();
    }
    
    /**
     * Generates SVG markup for the chart.
     * This can be used for static representations of the chart.
     * 
     * @return The SVG markup
     */
    public String generateSvg() {
        // This would typically use a charting library like D3.js
        // Since we're implementing everything from scratch without third-party libraries,
        // we'll need our own SVG generation code
        
        StringBuilder svg = new StringBuilder();
        svg.append("<svg xmlns=\"http://www.w3.org/2000/svg\" ");
        
        if (width > 0 && height > 0) {
            svg.append("width=\"").append(width).append("\" height=\"").append(height).append("\" ");
        } else {
            svg.append("width=\"600\" height=\"400\" ");
        }
        
        svg.append("viewBox=\"0 0 600 400\" ");
        
        if (cssClass != null && !cssClass.isEmpty()) {
            svg.append("class=\"").append(cssClass).append("\" ");
        }
        
        svg.append(">\n");
        
        // Title
        svg.append("  <title>").append(title).append("</title>\n");
        
        // Basic SVG structure
        svg.append("  <rect x=\"0\" y=\"0\" width=\"600\" height=\"400\" fill=\"#f8f9fa\" />\n");
        svg.append("  <text x=\"300\" y=\"30\" text-anchor=\"middle\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\">");
        svg.append(title).append("</text>\n");
        
        // Generate chart content based on type
        if (data != null) {
            try {
                svg.append(generateSvgContent());
            } catch (Exception e) {
                svg.append("  <text x=\"300\" y=\"200\" text-anchor=\"middle\" font-family=\"Arial\" font-size=\"14\">");
                svg.append("Error generating chart: ").append(e.getMessage()).append("</text>\n");
            }
        } else {
            svg.append("  <text x=\"300\" y=\"200\" text-anchor=\"middle\" font-family=\"Arial\" font-size=\"14\">");
            svg.append("No data available").append("</text>\n");
        }
        
        svg.append("</svg>");
        
        return svg.toString();
    }
    
    /**
     * Generates SVG content for the chart based on its type and data.
     * 
     * @return The SVG content
     */
    @SuppressWarnings("unchecked")
    private String generateSvgContent() {
        StringBuilder svg = new StringBuilder();
        
        // Placeholder for actual SVG generation based on chart type
        // In a production implementation, this would contain specific rendering code
        // for each chart type (bar, line, pie, etc.)
        
        // For now, we'll implement a basic rendering for the most common chart types
        if (type == ChartType.BAR) {
            if (data instanceof List) {
                List<Object> dataList = (List<Object>) data;
                int barCount = dataList.size();
                if (barCount > 0) {
                    double barWidth = 500.0 / barCount;
                    double maxValue = 0;
                    
                    // Find maximum value for scaling
                    for (Object item : dataList) {
                        if (item instanceof Number) {
                            double value = ((Number) item).doubleValue();
                            if (value > maxValue) {
                                maxValue = value;
                            }
                        } else if (item instanceof Map) {
                            Map<String, Object> dataPoint = (Map<String, Object>) item;
                            for (Object value : dataPoint.values()) {
                                if (value instanceof Number) {
                                    double numValue = ((Number) value).doubleValue();
                                    if (numValue > maxValue) {
                                        maxValue = numValue;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (maxValue > 0) {
                        // Draw axes
                        svg.append("  <line x1=\"50\" y1=\"50\" x2=\"50\" y2=\"350\" stroke=\"#333\" stroke-width=\"1\" />\n");
                        svg.append("  <line x1=\"50\" y1=\"350\" x2=\"550\" y2=\"350\" stroke=\"#333\" stroke-width=\"1\" />\n");
                        
                        // Draw bars
                        for (int i = 0; i < dataList.size(); i++) {
                            Object item = dataList.get(i);
                            if (item instanceof Number) {
                                double value = ((Number) item).doubleValue();
                                double height = (value / maxValue) * 250;
                                double x = 50 + (i * barWidth) + 5;
                                double y = 350 - height;
                                
                                // Calculate color based on position
                                String color = String.format("#%02x%02x%02x", 
                                                           100 + (i * 155 / barCount), 
                                                           50 + (i * 155 / barCount), 
                                                           200);
                                
                                svg.append("  <rect x=\"").append(x).append("\" y=\"").append(y).append("\" ");
                                svg.append("width=\"").append(barWidth - 10).append("\" height=\"").append(height).append("\" ");
                                svg.append("fill=\"").append(color).append("\" />\n");
                                
                                // Add value label
                                svg.append("  <text x=\"").append(x + (barWidth - 10) / 2).append("\" y=\"").append(y - 5).append("\" ");
                                svg.append("text-anchor=\"middle\" font-family=\"Arial\" font-size=\"12\">");
                                svg.append(value).append("</text>\n");
                            }
                        }
                    }
                }
            }
        } else if (type == ChartType.PIE) {
            if (data instanceof List) {
                List<Object> dataList = (List<Object>) data;
                if (!dataList.isEmpty()) {
                    double total = 0;
                    
                    // Calculate total for percentage calculation
                    for (Object item : dataList) {
                        if (item instanceof Number) {
                            total += ((Number) item).doubleValue();
                        } else if (item instanceof Map) {
                            Map<String, Object> dataPoint = (Map<String, Object>) item;
                            Object value = dataPoint.get("value");
                            if (value instanceof Number) {
                                total += ((Number) value).doubleValue();
                            }
                        }
                    }
                    
                    if (total > 0) {
                        double centerX = 300;
                        double centerY = 200;
                        double radius = 150;
                        double startAngle = 0;
                        
                        // Draw pie slices
                        for (int i = 0; i < dataList.size(); i++) {
                            Object item = dataList.get(i);
                            double value = 0;
                            String label = "Item " + (i + 1);
                            
                            if (item instanceof Number) {
                                value = ((Number) item).doubleValue();
                            } else if (item instanceof Map) {
                                Map<String, Object> dataPoint = (Map<String, Object>) item;
                                Object valueObj = dataPoint.get("value");
                                if (valueObj instanceof Number) {
                                    value = ((Number) valueObj).doubleValue();
                                }
                                
                                Object labelObj = dataPoint.get("label");
                                if (labelObj != null) {
                                    label = labelObj.toString();
                                }
                            }
                            
                            double sliceAngle = (value / total) * 2 * Math.PI;
                            double endAngle = startAngle + sliceAngle;
                            
                            // Calculate points
                            double x1 = centerX + radius * Math.cos(startAngle);
                            double y1 = centerY + radius * Math.sin(startAngle);
                            double x2 = centerX + radius * Math.cos(endAngle);
                            double y2 = centerY + radius * Math.sin(endAngle);
                            
                            // Large arc flag is 1 if the angle is greater than 180 degrees
                            int largeArcFlag = (sliceAngle > Math.PI) ? 1 : 0;
                            
                            // Calculate color based on position
                            String color = String.format("#%02x%02x%02x", 
                                                       100 + (i * 155 / dataList.size()), 
                                                       50 + (i * 155 / dataList.size()), 
                                                       200);
                            
                            // Draw slice path
                            svg.append("  <path d=\"M").append(centerX).append(",").append(centerY);
                            svg.append(" L").append(x1).append(",").append(y1);
                            svg.append(" A").append(radius).append(",").append(radius).append(" 0 ");
                            svg.append(largeArcFlag).append(",1 ");
                            svg.append(x2).append(",").append(y2);
                            svg.append(" Z\" fill=\"").append(color).append("\" stroke=\"white\" stroke-width=\"1\" />\n");
                            
                            // Add label
                            double labelAngle = startAngle + (sliceAngle / 2);
                            double labelRadius = radius * 0.7;
                            double labelX = centerX + labelRadius * Math.cos(labelAngle);
                            double labelY = centerY + labelRadius * Math.sin(labelAngle);
                            
                            svg.append("  <text x=\"").append(labelX).append("\" y=\"").append(labelY).append("\" ");
                            svg.append("text-anchor=\"middle\" font-family=\"Arial\" font-size=\"12\" fill=\"white\">");
                            svg.append(label).append("</text>\n");
                            
                            // Move to next slice
                            startAngle = endAngle;
                        }
                    }
                }
            }
        } else if (type == ChartType.LINE) {
            if (data instanceof List) {
                List<Object> dataList = (List<Object>) data;
                if (dataList.size() > 1) {
                    double maxValue = 0;
                    
                    // Find maximum value for scaling
                    for (Object item : dataList) {
                        if (item instanceof Number) {
                            double value = ((Number) item).doubleValue();
                            if (value > maxValue) {
                                maxValue = value;
                            }
                        } else if (item instanceof Map) {
                            Map<String, Object> dataPoint = (Map<String, Object>) item;
                            for (Object value : dataPoint.values()) {
                                if (value instanceof Number) {
                                    double numValue = ((Number) value).doubleValue();
                                    if (numValue > maxValue) {
                                        maxValue = numValue;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (maxValue > 0) {
                        // Draw axes
                        svg.append("  <line x1=\"50\" y1=\"50\" x2=\"50\" y2=\"350\" stroke=\"#333\" stroke-width=\"1\" />\n");
                        svg.append("  <line x1=\"50\" y1=\"350\" x2=\"550\" y2=\"350\" stroke=\"#333\" stroke-width=\"1\" />\n");
                        
                        // Draw line
                        double pointSpacing = 500.0 / (dataList.size() - 1);
                        StringBuilder pathData = new StringBuilder();
                        pathData.append("M");
                        
                        // Generate points
                        for (int i = 0; i < dataList.size(); i++) {
                            Object item = dataList.get(i);
                            double value = 0;
                            
                            if (item instanceof Number) {
                                value = ((Number) item).doubleValue();
                            } else if (item instanceof Map) {
                                Map<String, Object> dataPoint = (Map<String, Object>) item;
                                Object valueObj = dataPoint.get("value");
                                if (valueObj instanceof Number) {
                                    value = ((Number) valueObj).doubleValue();
                                }
                            }
                            
                            double x = 50 + (i * pointSpacing);
                            double y = 350 - ((value / maxValue) * 250);
                            
                            if (i == 0) {
                                pathData.append(x).append(",").append(y);
                            } else {
                                pathData.append(" L").append(x).append(",").append(y);
                            }
                            
                            // Draw points
                            svg.append("  <circle cx=\"").append(x).append("\" cy=\"").append(y).append("\" r=\"4\" ");
                            svg.append("fill=\"#3498db\" stroke=\"white\" stroke-width=\"1\" />\n");
                            
                            // Add value label
                            svg.append("  <text x=\"").append(x).append("\" y=\"").append(y - 10).append("\" ");
                            svg.append("text-anchor=\"middle\" font-family=\"Arial\" font-size=\"12\">");
                            svg.append(value).append("</text>\n");
                        }
                        
                        // Draw path
                        svg.append("  <path d=\"").append(pathData).append("\" fill=\"none\" stroke=\"#3498db\" stroke-width=\"2\" />\n");
                    }
                }
            }
        } else {
            // Default rendering for unsupported chart types
            svg.append("  <text x=\"300\" y=\"200\" text-anchor=\"middle\" font-family=\"Arial\" font-size=\"14\">");
            svg.append("Chart type '").append(type.getValue()).append("' rendering not implemented</text>\n");
        }
        
        return svg.toString();
    }
    
    /**
     * Generates a JSON representation of the chart options.
     * 
     * @return The JSON representation
     */
    private String generateOptionsJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        
        // Add standard options
        sb.append("\"title\":\"").append(escapeJson(title)).append("\",");
        sb.append("\"responsive\":").append(responsive).append(",");
        sb.append("\"animate\":").append(animate).append(",");
        
        if (width > 0) {
            sb.append("\"width\":").append(width).append(",");
        }
        
        if (height > 0) {
            sb.append("\"height\":").append(height).append(",");
        }
        
        if (tooltipTemplate != null && !tooltipTemplate.isEmpty()) {
            sb.append("\"tooltipTemplate\":\"").append(escapeJson(tooltipTemplate)).append("\",");
        }
        
        if (legendTemplate != null && !legendTemplate.isEmpty()) {
            sb.append("\"legendTemplate\":\"").append(escapeJson(legendTemplate)).append("\",");
        }
        
        if (axisLabelTemplate != null && !axisLabelTemplate.isEmpty()) {
            sb.append("\"axisLabelTemplate\":\"").append(escapeJson(axisLabelTemplate)).append("\",");
        }
        
        // Add custom options
        if (!customOptions.isEmpty()) {
            sb.append("\"customOptions\":{");
            int index = 0;
            for (Map.Entry<String, Object> entry : customOptions.entrySet()) {
                if (index > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\":");
                appendJsonValue(sb, entry.getValue());
                index++;
            }
            sb.append("},");
        }
        
        // Add regular options
        if (!options.isEmpty()) {
            int index = 0;
            for (Map.Entry<String, Object> entry : options.entrySet()) {
                if (index > 0 || sb.charAt(sb.length() - 1) == ',') {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\":");
                appendJsonValue(sb, entry.getValue());
                index++;
            }
        }
        
        // Remove trailing comma if present
        if (sb.charAt(sb.length() - 1) == ',') {
            sb.setLength(sb.length() - 1);
        }
        
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Appends a JSON value to a StringBuilder.
     * 
     * @param sb The StringBuilder to append to
     * @param value The value to append
     */
    @SuppressWarnings("unchecked")
    private void appendJsonValue(StringBuilder sb, Object value) {
        if (value == null) {
            sb.append("null");
        } else if (value instanceof Number || value instanceof Boolean) {
            sb.append(value);
        } else if (value instanceof String) {
            sb.append("\"").append(escapeJson((String) value)).append("\"");
        } else if (value instanceof Map) {
            sb.append("{");
            Map<String, Object> map = (Map<String, Object>) value;
            int index = 0;
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                if (index > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\":");
                appendJsonValue(sb, entry.getValue());
                index++;
            }
            sb.append("}");
        } else if (value instanceof List) {
            sb.append("[");
            List<Object> list = (List<Object>) value;
            for (int i = 0; i < list.size(); i++) {
                if (i > 0) {
                    sb.append(",");
                }
                appendJsonValue(sb, list.get(i));
            }
            sb.append("]");
        } else {
            // Default to string representation
            sb.append("\"").append(escapeJson(value.toString())).append("\"");
        }
    }
    
    /**
     * Escapes a string for JSON.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\r", "\\r")
                .replace("\n", "\\n")
                .replace("\t", "\\t");
    }
    
    /**
     * Converts the chart to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append("\"id\": \"").append(id).append("\",");
        sb.append("\"title\": \"").append(escapeJson(title)).append("\",");
        sb.append("\"type\": \"").append(type.getValue()).append("\",");
        sb.append("\"width\": ").append(width).append(",");
        sb.append("\"height\": ").append(height).append(",");
        sb.append("\"responsive\": ").append(responsive).append(",");
        sb.append("\"animate\": ").append(animate).append(",");
        
        sb.append("\"data\": ").append(serializedData != null ? serializedData : "null").append(",");
        
        // Options
        sb.append("\"options\": ").append(generateOptionsJson()).append(",");
        
        // Templates
        sb.append("\"tooltipTemplate\": ").append(tooltipTemplate != null ? "\"" + escapeJson(tooltipTemplate) + "\"" : "null").append(",");
        sb.append("\"legendTemplate\": ").append(legendTemplate != null ? "\"" + escapeJson(legendTemplate) + "\"" : "null").append(",");
        sb.append("\"axisLabelTemplate\": ").append(axisLabelTemplate != null ? "\"" + escapeJson(axisLabelTemplate) + "\"" : "null").append(",");
        sb.append("\"cssClass\": ").append(cssClass != null ? "\"" + escapeJson(cssClass) + "\"" : "null");
        
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public String toString() {
        return "CSChart{" +
               "id='" + id + '\'' +
               ", title='" + title + '\'' +
               ", type=" + type +
               ", width=" + width +
               ", height=" + height +
               '}';
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.Serializable;
import java.text.DecimalFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Represents a metric in the CSTestForge framework.
 * A metric is a measurement or value that can be displayed in reports.
 */
public class CSMetric implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    private final String id;
    private String name;
    private Object value;
    private String unit;
    private String formatPattern;
    private double threshold;
    private double warningThreshold;
    private boolean thresholdEnabled;
    private final Date timestamp;
    private String description;
    private String category;
    private final Map<String, Object> attributes;
    
    /**
     * Constructor for CSMetric.
     * 
     * @param name The name of the metric
     * @param value The value of the metric
     * @param unit The unit of the metric
     */
    public CSMetric(String name, Object value, String unit) {
        this(UUID.randomUUID().toString(), name, value, unit, new Date());
    }
    
    /**
     * Constructor for CSMetric with a specific ID.
     * 
     * @param id The ID of the metric
     * @param name The name of the metric
     * @param value The value of the metric
     * @param unit The unit of the metric
     * @param timestamp The timestamp of the metric
     */
    public CSMetric(String id, String name, Object value, String unit, Date timestamp) {
        this.id = id;
        this.name = name;
        this.value = value;
        this.unit = unit;
        this.timestamp = timestamp;
        this.attributes = new ConcurrentHashMap<>();
        this.thresholdEnabled = false;
        this.threshold = 0;
        this.warningThreshold = 0;
    }
    
    /**
     * Gets the ID of the metric.
     * 
     * @return The ID
     */
    public String getId() {
        return id;
    }
    
    /**
     * Gets the name of the metric.
     * 
     * @return The name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Sets the name of the metric.
     * 
     * @param name The name
     */
    public void setName(String name) {
        this.name = name;
    }
    
    /**
     * Gets the value of the metric.
     * 
     * @return The value
     */
    public Object getValue() {
        return value;
    }
    
    /**
     * Sets the value of the metric.
     * 
     * @param value The value
     */
    public void setValue(Object value) {
        this.value = value;
    }
    
    /**
     * Gets the unit of the metric.
     * 
     * @return The unit
     */
    public String getUnit() {
        return unit;
    }
    
    /**
     * Sets the unit of the metric.
     * 
     * @param unit The unit
     */
    public void setUnit(String unit) {
        this.unit = unit;
    }
    
    /**
     * Gets the format pattern of the metric.
     * 
     * @return The format pattern
     */
    public String getFormatPattern() {
        return formatPattern;
    }
    
    /**
     * Sets the format pattern of the metric.
     * 
     * @param formatPattern The format pattern
     */
    public void setFormatPattern(String formatPattern) {
        this.formatPattern = formatPattern;
    }
    
    /**
     * Gets the threshold of the metric.
     * 
     * @return The threshold
     */
    public double getThreshold() {
        return threshold;
    }
    
    /**
     * Sets the threshold of the metric.
     * 
     * @param threshold The threshold
     */
    public void setThreshold(double threshold) {
        this.threshold = threshold;
    }
    
    /**
     * Gets the warning threshold of the metric.
     * 
     * @return The warning threshold
     */
    public double getWarningThreshold() {
        return warningThreshold;
    }
    
    /**
     * Sets the warning threshold of the metric.
     * 
     * @param warningThreshold The warning threshold
     */
    public void setWarningThreshold(double warningThreshold) {
        this.warningThreshold = warningThreshold;
    }
    
    /**
     * Checks if threshold comparison is enabled.
     * 
     * @return True if threshold comparison is enabled, false otherwise
     */
    public boolean isThresholdEnabled() {
        return thresholdEnabled;
    }
    
    /**
     * Sets whether threshold comparison is enabled.
     * 
     * @param thresholdEnabled Whether threshold comparison is enabled
     */
    public void setThresholdEnabled(boolean thresholdEnabled) {
        this.thresholdEnabled = thresholdEnabled;
    }
    
    /**
     * Gets the timestamp of the metric.
     * 
     * @return The timestamp
     */
    public Date getTimestamp() {
        return timestamp;
    }
    
    /**
     * Gets the description of the metric.
     * 
     * @return The description
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Sets the description of the metric.
     * 
     * @param description The description
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * Gets the category of the metric.
     * 
     * @return The category
     */
    public String getCategory() {
        return category;
    }
    
    /**
     * Sets the category of the metric.
     * 
     * @param category The category
     */
    public void setCategory(String category) {
        this.category = category;
    }
    
    /**
     * Gets an attribute value.
     * 
     * @param name The attribute name
     * @return The attribute value, or null if not found
     */
    public Object getAttribute(String name) {
        return attributes.get(name);
    }
    
    /**
     * Gets all attributes.
     * 
     * @return Map of all attributes
     */
    public Map<String, Object> getAttributes() {
        return new HashMap<>(attributes);
    }
    
    /**
     * Sets an attribute value.
     * 
     * @param name The attribute name
     * @param value The attribute value
     */
    public void setAttribute(String name, Object value) {
        attributes.put(name, value);
    }
    
    /**
     * Removes an attribute.
     * 
     * @param name The attribute name
     * @return The removed attribute value, or null if not found
     */
    public Object removeAttribute(String name) {
        return attributes.remove(name);
    }
    
    /**
     * Gets the numeric value of the metric.
     * 
     * @return The numeric value, or NaN if the value is not numeric
     */
    public double getNumericValue() {
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        } else if (value instanceof String) {
            try {
                return Double.parseDouble((String) value);
            } catch (NumberFormatException e) {
                return Double.NaN;
            }
        }
        return Double.NaN;
    }
    
    /**
     * Gets the formatted value of the metric.
     * 
     * @return The formatted value
     */
    public String getFormattedValue() {
        if (value == null) {
            return "N/A";
        }
        
        if (value instanceof Number) {
            double numValue = ((Number) value).doubleValue();
            
            if (formatPattern != null && !formatPattern.isEmpty()) {
                try {
                    DecimalFormat formatter = new DecimalFormat(formatPattern);
                    String formatted = formatter.format(numValue);
                    return unit != null && !unit.isEmpty() ? formatted + " " + unit : formatted;
                } catch (Exception e) {
                    // If format fails, fall back to default
                }
            }
            
            // Default formatting
            if (numValue == (long) numValue) {
                return unit != null && !unit.isEmpty() ? (long) numValue + " " + unit : Long.toString((long) numValue);
            } else {
                return unit != null && !unit.isEmpty() ? numValue + " " + unit : Double.toString(numValue);
            }
        } else if (value instanceof Date) {
            if (formatPattern != null && !formatPattern.isEmpty()) {
                try {
                    java.text.SimpleDateFormat formatter = new java.text.SimpleDateFormat(formatPattern);
                    return formatter.format((Date) value);
                } catch (Exception e) {
                    // If format fails, fall back to default
                }
            }
            return value.toString();
        } else if (value instanceof String && unit != null && !unit.isEmpty()) {
            return value + " " + unit;
        } else {
            return value.toString();
        }
    }
    
    /**
     * Checks if the value exceeds the threshold.
     * 
     * @return True if the value exceeds the threshold, false otherwise
     */
    public boolean isExceedsThreshold() {
        if (!thresholdEnabled) {
            return false;
        }
        
        double numValue = getNumericValue();
        if (Double.isNaN(numValue)) {
            return false;
        }
        
        return numValue > threshold;
    }
    
    /**
     * Checks if the value exceeds the warning threshold.
     * 
     * @return True if the value exceeds the warning threshold, false otherwise
     */
    public boolean isExceedsWarningThreshold() {
        if (!thresholdEnabled) {
            return false;
        }
        
        double numValue = getNumericValue();
        if (Double.isNaN(numValue)) {
            return false;
        }
        
        return numValue > warningThreshold && numValue <= threshold;
    }
    
    /**
     * Gets the status of the metric based on thresholds.
     * 
     * @return The status
     */
    public CSTestStatus getStatus() {
        if (!thresholdEnabled) {
            return CSTestStatus.PASS;
        }
        
        if (isExceedsThreshold()) {
            return CSTestStatus.FAIL;
        } else if (isExceedsWarningThreshold()) {
            return CSTestStatus.WARNING;
        } else {
            return CSTestStatus.PASS;
        }
    }
    
    /**
     * Gets the CSS class for styling based on thresholds.
     * 
     * @return The CSS class
     */
    public String getCssClass() {
        if (!thresholdEnabled) {
            return "metric-normal";
        }
        
        if (isExceedsThreshold()) {
            return "metric-critical";
        } else if (isExceedsWarningThreshold()) {
            return "metric-warning";
        } else {
            return "metric-normal";
        }
    }
    
    /**
     * Gets the color for styling based on thresholds.
     * 
     * @return The color
     */
    public String getColor() {
        if (!thresholdEnabled) {
            return "#333333";
        }
        
        if (isExceedsThreshold()) {
            return "#FF0000";
        } else if (isExceedsWarningThreshold()) {
            return "#FFA500";
        } else {
            return "#008000";
        }
    }
    
    /**
     * Calculates the percentage of the value compared to the threshold.
     * 
     * @return The percentage
     */
    public double getPercentageOfThreshold() {
        if (!thresholdEnabled || threshold == 0) {
            return 0;
        }
        
        double numValue = getNumericValue();
        if (Double.isNaN(numValue)) {
            return 0;
        }
        
        return (numValue / threshold) * 100;
    }
    
    /**
     * Converts the metric to a JSON representation.
     * 
     * @return The JSON representation
     */
    public String toJson() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append("\"id\": \"").append(id).append("\",");
        sb.append("\"name\": \"").append(escapeJson(name)).append("\",");
        sb.append("\"value\": ");
        
        if (value == null) {
            sb.append("null");
        } else if (value instanceof Number) {
            sb.append(value);
        } else if (value instanceof Boolean) {
            sb.append(value);
        } else if (value instanceof Date) {
            sb.append("\"").append(value).append("\"");
        } else {
            sb.append("\"").append(escapeJson(value.toString())).append("\"");
        }
        
        sb.append(",");
        sb.append("\"unit\": ").append(unit != null ? "\"" + escapeJson(unit) + "\"" : "null").append(",");
        sb.append("\"formattedValue\": \"").append(escapeJson(getFormattedValue())).append("\",");
        sb.append("\"formatPattern\": ").append(formatPattern != null ? "\"" + escapeJson(formatPattern) + "\"" : "null").append(",");
        sb.append("\"timestamp\": \"").append(timestamp).append("\",");
        sb.append("\"description\": ").append(description != null ? "\"" + escapeJson(description) + "\"" : "null").append(",");
        sb.append("\"category\": ").append(category != null ? "\"" + escapeJson(category) + "\"" : "null").append(",");
        sb.append("\"thresholdEnabled\": ").append(thresholdEnabled).append(",");
        sb.append("\"threshold\": ").append(threshold).append(",");
        sb.append("\"warningThreshold\": ").append(warningThreshold).append(",");
        sb.append("\"exceedsThreshold\": ").append(isExceedsThreshold()).append(",");
        sb.append("\"exceedsWarningThreshold\": ").append(isExceedsWarningThreshold()).append(",");
        sb.append("\"status\": \"").append(getStatus()).append("\",");
        sb.append("\"cssClass\": \"").append(getCssClass()).append("\",");
        sb.append("\"color\": \"").append(getColor()).append("\",");
        sb.append("\"percentageOfThreshold\": ").append(getPercentageOfThreshold()).append(",");
        
        // Attributes
        sb.append("\"attributes\": {");
        int attrIndex = 0;
        for (Map.Entry<String, Object> entry : attributes.entrySet()) {
            if (attrIndex > 0) {
                sb.append(",");
            }
            sb.append("\"").append(entry.getKey()).append("\": ");
            appendJsonValue(sb, entry.getValue());
            attrIndex++;
        }
        sb.append("}");
        
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Appends a JSON value to a StringBuilder.
     * 
     * @param sb The StringBuilder to append to
     * @param value The value to append
     */
    @SuppressWarnings("unchecked")
    private void appendJsonValue(StringBuilder sb, Object value) {
        if (value == null) {
            sb.append("null");
        } else if (value instanceof Number || value instanceof Boolean) {
            sb.append(value);
        } else if (value instanceof String) {
            sb.append("\"").append(escapeJson((String) value)).append("\"");
        } else if (value instanceof Date) {
            sb.append("\"").append(value).append("\"");
        } else if (value instanceof Map) {
            sb.append("{");
            Map<String, Object> map = (Map<String, Object>) value;
            int index = 0;
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                if (index > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\":");
                appendJsonValue(sb, entry.getValue());
                index++;
            }
            sb.append("}");
        } else if (value instanceof Iterable) {
            sb.append("[");
            int index = 0;
            for (Object item : (Iterable<?>) value) {
                if (index > 0) {
                    sb.append(",");
                }
                appendJsonValue(sb, item);
                index++;
            }
            sb.append("]");
        } else {
            // Default to string representation
            sb.append("\"").append(escapeJson(value.toString())).append("\"");
        }
    }
    
    /**
     * Escapes a string for JSON.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\r", "\\r")
                .replace("\n", "\\n")
                .replace("\t", "\\t");
    }
    
    @Override
    public String toString() {
        return "CSMetric{" +
               "id='" + id + '\'' +
               ", name='" + name + '\'' +
               ", value=" + value +
               ", unit='" + unit + '\'' +
               '}';
    }
}


package com.cstestforge.framework.core.reporting;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.stream.Collectors;

import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;

/**
 * HTML report generator for the CSTestForge framework.
 * Generates HTML reports with interactive dashboards.
 */
public class CSHtmlReportGenerator implements CSReportGenerator {
    
    // Template resource paths
    private static final String TEMPLATE_PATH = "/templates/reporting/html";
    private static final String TEMPLATE_MAIN = TEMPLATE_PATH + "/main.html";
    private static final String TEMPLATE_DASHBOARD = TEMPLATE_PATH + "/dashboard.html";
    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + "/index.html";
    private static final String TEMPLATE_SUITE = TEMPLATE_PATH + "/suite.html";
    private static final String TEMPLATE_TESTCASE = TEMPLATE_PATH + "/testcase.html";
    private static final String TEMPLATE_STEP = TEMPLATE_PATH + "/step.html";
    
    // CSS and JavaScript resources
    private static final String CSS_MAIN = TEMPLATE_PATH + "/css/styles.css";
    private static final String CSS_BOOTSTRAP = TEMPLATE_PATH + "/css/bootstrap.min.css";
    private static final String CSS_FONTAWESOME = TEMPLATE_PATH + "/css/fontawesome.min.css";
    private static final String JS_MAIN = TEMPLATE_PATH + "/js/main.js";
    private static final String JS_JQUERY = TEMPLATE_PATH + "/js/jquery.min.js";
    private static final String JS_BOOTSTRAP = TEMPLATE_PATH + "/js/bootstrap.min.js";
    private static final String JS_CHART = TEMPLATE_PATH + "/js/chart.js";
    
    // Resource directories in the output
    private static final String DIR_CSS = "css";
    private static final String DIR_JS = "js";
    private static final String DIR_IMAGES = "images";
    private static final String DIR_SCREENSHOTS = "screenshots";
    private static final String DIR_ATTACHMENTS = "attachments";
    
    // Default templates (in case resource loading fails)
    private static final String DEFAULT_TEMPLATE_MAIN = "<!DOCTYPE html><html><head><title>${title}</title></head><body>${content}</body></html>";
    private static final String DEFAULT_TEMPLATE_INDEX = "<h1>Test Report</h1><p>Generated on ${timestamp}</p>${suiteList}";
    private static final String DEFAULT_TEMPLATE_DASHBOARD = "<div class=\"dashboard\">${summary}${charts}</div>";
    private static final String DEFAULT_TEMPLATE_SUITE = "<div class=\"suite\"><h2>${name}</h2><p>${description}</p>${testList}</div>";
    private static final String DEFAULT_TEMPLATE_TESTCASE = "<div class=\"test-case\"><h3>${name}</h3><p>${description}</p>${stepList}</div>";
    private static final String DEFAULT_TEMPLATE_STEP = "<div class=\"test-step\"><h4>${name}</h4><p>${description}</p></div>";
    
    // Logo and icons
    private static final String LOGO_PATH = TEMPLATE_PATH + "/images/logo.png";
    private static final String FAVICON_PATH = TEMPLATE_PATH + "/images/favicon.ico";
    
    private final Map<String, String> templateCache = new ConcurrentHashMap<>();
    private final Map<String, byte[]> resourceCache = new ConcurrentHashMap<>();
    private final Map<String, String> customTemplates = new ConcurrentHashMap<>();
    
    private File reportDirectory;
    private String reportTitle;
    private boolean embedScreenshots;
    private boolean embedAttachments;
    private boolean minifyOutput;
    private boolean includeDashboard;
    private boolean includeCharts;
    private boolean includeLogs;
    private String logoUrl;
    private String faviconUrl;
    private String cssUrl;
    private String jsUrl;
    private Map<String, Object> globalVariables;
    private boolean createIndexPage;
    private boolean frameworkBranding;
    private String customCss;
    private String customJs;
    private boolean responsiveDesign;
    private String themeColor;
    private boolean darkMode;
    private boolean printFriendly;
    private String dateTimeFormat;
    
    /**
     * Constructor for CSHtmlReportGenerator.
     */
    public CSHtmlReportGenerator() {
        this.reportDirectory = new File(System.getProperty("java.io.tmpdir"), "cstestforge-reports");
        this.reportTitle = "CSTestForge Test Report";
        this.embedScreenshots = true;
        this.embedAttachments = false;
        this.minifyOutput = false;
        this.includeDashboard = true;
        this.includeCharts = true;
        this.includeLogs = true;
        this.createIndexPage = true;
        this.frameworkBranding = true;
        this.responsiveDesign = true;
        this.themeColor = "#C54B8C"; // Primary brand color
        this.darkMode = false;
        this.printFriendly = true;
        this.dateTimeFormat = "yyyy-MM-dd HH:mm:ss";
        this.globalVariables = new HashMap<>();
    }
    
    /**
     * Sets the report directory.
     * 
     * @param reportDirectory The report directory
     */
    public void setReportDirectory(File reportDirectory) {
        this.reportDirectory = reportDirectory;
    }
    
    /**
     * Gets the report directory.
     * 
     * @return The report directory
     */
    public File getReportDirectory() {
        return reportDirectory;
    }
    
    /**
     * Sets the report title.
     * 
     * @param reportTitle The report title
     */
    public void setReportTitle(String reportTitle) {
        this.reportTitle = reportTitle;
    }
    
    /**
     * Gets the report title.
     * 
     * @return The report title
     */
    public String getReportTitle() {
        return reportTitle;
    }
    
    /**
     * Sets whether screenshots should be embedded in the HTML report.
     * 
     * @param embedScreenshots Whether to embed screenshots
     */
    public void setEmbedScreenshots(boolean embedScreenshots) {
        this.embedScreenshots = embedScreenshots;
    }
    
    /**
     * Checks if screenshots should be embedded in the HTML report.
     * 
     * @return True if screenshots should be embedded, false otherwise
     */
    public boolean isEmbedScreenshots() {
        return embedScreenshots;
    }
    
    /**
     * Sets whether attachments should be embedded in the HTML report.
     * 
     * @param embedAttachments Whether to embed attachments
     */
    public void setEmbedAttachments(boolean embedAttachments) {
        this.embedAttachments = embedAttachments;
    }
    
    /**
     * Checks if attachments should be embedded in the HTML report.
     * 
     * @return True if attachments should be embedded, false otherwise
     */
    public boolean isEmbedAttachments() {
        return embedAttachments;
    }
    
    /**
     * Sets whether the output HTML should be minified.
     * 
     * @param minifyOutput Whether to minify the output
     */
    public void setMinifyOutput(boolean minifyOutput) {
        this.minifyOutput = minifyOutput;
    }
    
    /**
     * Checks if the output HTML should be minified.
     * 
     * @return True if the output should be minified, false otherwise
     */
    public boolean isMinifyOutput() {
        return minifyOutput;
    }
    
    /**
     * Sets whether to include the dashboard in the report.
     * 
     * @param includeDashboard Whether to include the dashboard
     */
    public void setIncludeDashboard(boolean includeDashboard) {
        this.includeDashboard = includeDashboard;
    }
    
    /**
     * Checks if the dashboard should be included in the report.
     * 
     * @return True if the dashboard should be included, false otherwise
     */
    public boolean isIncludeDashboard() {
        return includeDashboard;
    }
    
    /**
     * Sets whether to include charts in the report.
     * 
     * @param includeCharts Whether to include charts
     */
    public void setIncludeCharts(boolean includeCharts) {
        this.includeCharts = includeCharts;
    }
    
    /**
     * Checks if charts should be included in the report.
     * 
     * @return True if charts should be included, false otherwise
     */
    public boolean isIncludeCharts() {
        return includeCharts;
    }
    
    /**
     * Sets whether to include logs in the report.
     * 
     * @param includeLogs Whether to include logs
     */
    public void setIncludeLogs(boolean includeLogs) {
        this.includeLogs = includeLogs;
    }
    
    /**
     * Checks if logs should be included in the report.
     * 
     * @return True if logs should be included, false otherwise
     */
    public boolean isIncludeLogs() {
        return includeLogs;
    }
    
    /**
     * Sets the logo URL.
     * 
     * @param logoUrl The logo URL
     */
    public void setLogoUrl(String logoUrl) {
        this.logoUrl = logoUrl;
    }
    
    /**
     * Gets the logo URL.
     * 
     * @return The logo URL
     */
    public String getLogoUrl() {
        return logoUrl;
    }
    
    /**
     * Sets the favicon URL.
     * 
     * @param faviconUrl The favicon URL
     */
    public void setFaviconUrl(String faviconUrl) {
        this.faviconUrl = faviconUrl;
    }
    
    /**
     * Gets the favicon URL.
     * 
     * @return The favicon URL
     */
    public String getFaviconUrl() {
        return faviconUrl;
    }
    
    /**
     * Sets the CSS URL.
     * 
     * @param cssUrl The CSS URL
     */
    public void setCssUrl(String cssUrl) {
        this.cssUrl = cssUrl;
    }
    
    /**
     * Gets the CSS URL.
     * 
     * @return The CSS URL
     */
    public String getCssUrl() {
        return cssUrl;
    }
    
    /**
     * Sets the JavaScript URL.
     * 
     * @param jsUrl The JavaScript URL
     */
    public void setJsUrl(String jsUrl) {
        this.jsUrl = jsUrl;
    }
    
    /**
     * Gets the JavaScript URL.
     * 
     * @return The JavaScript URL
     */
    public String getJsUrl() {
        return jsUrl;
    }
    
    /**
     * Sets whether to create an index page.
     * 
     * @param createIndexPage Whether to create an index page
     */
    public void setCreateIndexPage(boolean createIndexPage) {
        this.createIndexPage = createIndexPage;
    }
    
    /**
     * Checks if an index page should be created.
     * 
     * @return True if an index page should be created, false otherwise
     */
    public boolean isCreateIndexPage() {
        return createIndexPage;
    }
    
    /**
     * Sets whether to include framework branding.
     * 
     * @param frameworkBranding Whether to include framework branding
     */
    public void setFrameworkBranding(boolean frameworkBranding) {
        this.frameworkBranding = frameworkBranding;
    }
    
    /**
     * Checks if framework branding should be included.
     * 
     * @return True if framework branding should be included, false otherwise
     */
    public boolean isFrameworkBranding() {
        return frameworkBranding;
    }
    
    /**
     * Sets custom CSS content.
     * 
     * @param customCss The custom CSS content
     */
    public void setCustomCss(String customCss) {
        this.customCss = customCss;
    }
    
    /**
     * Gets the custom CSS content.
     * 
     * @return The custom CSS content
     */
    public String getCustomCss() {
        return customCss;
    }
    
    /**
     * Sets custom JavaScript content.
     * 
     * @param customJs The custom JavaScript content
     */
    public void setCustomJs(String customJs) {
        this.customJs = customJs;
    }
    
    /**
     * Gets the custom JavaScript content.
     * 
     * @return The custom JavaScript content
     */
    public String getCustomJs() {
        return customJs;
    }
    
    /**
     * Sets whether the report should use responsive design.
     * 
     * @param responsiveDesign Whether the report should use responsive design
     */
    public void setResponsiveDesign(boolean responsiveDesign) {
        this.responsiveDesign = responsiveDesign;
    }
    
    /**
     * Checks if the report should use responsive design.
     * 
     * @return True if the report should use responsive design, false otherwise
     */
    public boolean isResponsiveDesign() {
        return responsiveDesign;
    }
    
    /**
     * Sets the theme color.
     * 
     * @param themeColor The theme color
     */
    public void setThemeColor(String themeColor) {
        this.themeColor = themeColor;
    }
    
    /**
     * Gets the theme color.
     * 
     * @return The theme color
     */
    public String getThemeColor() {
        return themeColor;
    }
    
    /**
     * Sets whether the report should use dark mode.
     * 
     * @param darkMode Whether the report should use dark mode
     */
    public void setDarkMode(boolean darkMode) {
        this.darkMode = darkMode;
    }
    
    /**
     * Checks if the report should use dark mode.
     * 
     * @return True if the report should use dark mode, false otherwise
     */
    public boolean isDarkMode() {
        return darkMode;
    }
    
    /**
     * Sets whether the report should be print-friendly.
     * 
     * @param printFriendly Whether the report should be print-friendly
     */
    public void setPrintFriendly(boolean printFriendly) {
        this.printFriendly = printFriendly;
    }
    
    /**
     * Checks if the report should be print-friendly.
     * 
     * @return True if the report should be print-friendly, false otherwise
     */
    public boolean isPrintFriendly() {
        return printFriendly;
    }
    
    /**
     * Sets the date and time format.
     * 
     * @param dateTimeFormat The date and time format
     */
    public void setDateTimeFormat(String dateTimeFormat) {
        this.dateTimeFormat = dateTimeFormat;
    }
    
    /**
     * Gets the date and time format.
     * 
     * @return The date and time format
     */
    public String getDateTimeFormat() {
        return dateTimeFormat;
    }
    
    /**
     * Sets a global variable.
     * 
     * @param name The variable name
     * @param value The variable value
     */
    public void setGlobalVariable(String name, Object value) {
        this.globalVariables.put(name, value);
    }
    
    /**
     * Gets a global variable.
     * 
     * @param name The variable name
     * @return The variable value, or null if not found
     */
    public Object getGlobalVariable(String name) {
        return this.globalVariables.get(name);
    }
    
    /**
     * Gets all global variables.
     * 
     * @return Map of global variables
     */
    public Map<String, Object> getGlobalVariables() {
        return new HashMap<>(globalVariables);
    }
    
    /**
     * Sets a custom template.
     * 
     * @param name The template name
     * @param content The template content
     */
    public void setCustomTemplate(String name, String content) {
        customTemplates.put(name, content);
    }
    
    /**
     * Gets a custom template.
     * 
     * @param name The template name
     * @return The template content, or null if not found
     */
    public String getCustomTemplate(String name) {
        return customTemplates.get(name);
    }
    
    /**
     * Gets all custom templates.
     * 
     * @return Map of custom templates
     */
    public Map<String, String> getCustomTemplates() {
        return new HashMap<>(customTemplates);
    }
    
    /**
     * Generates a report for a test suite.
     * 
     * @param testSuite The test suite
     * @return The generated report
     */
    @Override
    public CSReport generateReport(CSTestSuite testSuite) {
        List<CSTestSuite> suites = new ArrayList<>();
        suites.add(testSuite);
        return generateReport(suites);
    }
    
    /**
     * Generates a report for multiple test suites.
     * 
     * @param testSuites The test suites
     * @return The generated report
     */
    @Override
    public CSReport generateReport(List<CSTestSuite> testSuites) {
        // Create the report directory if it doesn't exist
        if (!reportDirectory.exists()) {
            reportDirectory.mkdirs();
        }
        
        // Generate a unique ID for the report
        String reportId = UUID.randomUUID().toString();
        String reportFileName = "report_" + reportId + ".html";
        File reportFile = new File(reportDirectory, reportFileName);
        
        try {
            // Copy required resources
            copyResources();
            
            // Generate the HTML content
            String htmlContent = generateHtmlContent(testSuites);
            
            // Minify the HTML if requested
            if (minifyOutput) {
                htmlContent = minifyHtml(htmlContent);
            }
            
            // Write the HTML to the file
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(reportFile))) {
                writer.write(htmlContent);
            }
            
            // Create an index page if requested
            if (createIndexPage) {
                createIndexPage(testSuites, reportFileName);
            }
            
            // Create individual suite pages
            createSuitePages(testSuites);
            
            // Create individual test case pages
            createTestCasePages(testSuites);
            
            // Create the report object
            CSReport report = new CSHtmlReport(reportId, reportTitle, reportFile, testSuites);
            
            return report;
        } catch (IOException e) {
            CSLogger.error("Failed to generate HTML report", e);
            throw new RuntimeException("Failed to generate HTML report: " + e.getMessage(), e);
        }
    }
    
    /**
     * Generates the HTML content for a report.
     * 
     * @param testSuites The test suites
     * @return The HTML content
     */
    private String generateHtmlContent(List<CSTestSuite> testSuites) {
        Map<String, Object> variables = new HashMap<>(globalVariables);
        variables.put("title", reportTitle);
        variables.put("timestamp", formatDate(new Date()));
        variables.put("passCount", getPassCount(testSuites));
        variables.put("failCount", getFailCount(testSuites));
        variables.put("skipCount", getSkipCount(testSuites));
        variables.put("totalCount", getTotalCount(testSuites));
        variables.put("passPercentage", getPassPercentage(testSuites));
        variables.put("duration", getTotalDuration(testSuites));
        variables.put("formattedDuration", getFormattedTotalDuration(testSuites));
        variables.put("themeColor", themeColor);
        variables.put("darkMode", darkMode);
        variables.put("responsive", responsiveDesign);
        variables.put("printFriendly", printFriendly);
        
        // Add logo and favicon if specified
        if (logoUrl != null) {
            variables.put("logo", logoUrl);
        }
        if (faviconUrl != null) {
            variables.put("favicon", faviconUrl);
        }
        
        // Generate dashboard content if requested
        if (includeDashboard) {
            variables.put("dashboard", generateDashboardContent(testSuites));
        } else {
            variables.put("dashboard", "");
        }
        
        // Generate suite list
        StringBuilder suiteListBuilder = new StringBuilder();
        for (CSTestSuite suite : testSuites) {
            suiteListBuilder.append(generateSuiteContent(suite));
        }
        variables.put("suiteList", suiteListBuilder.toString());
        
        // Generate custom CSS and JS
        StringBuilder customCssBuilder = new StringBuilder();
        if (customCss != null && !customCss.isEmpty()) {
            customCssBuilder.append("<style>\n").append(customCss).append("\n</style>\n");
        }
        variables.put("customCss", customCssBuilder.toString());
        
        StringBuilder customJsBuilder = new StringBuilder();
        if (customJs != null && !customJs.isEmpty()) {
            customJsBuilder.append("<script>\n").append(customJs).append("\n</script>\n");
        }
        variables.put("customJs", customJsBuilder.toString());
        
        // Get the main template
        String template = getTemplate("main", TEMPLATE_MAIN, DEFAULT_TEMPLATE_MAIN);
        
        // Replace variables in the template
        return replaceVariables(template, variables);
    }
    
    /**
     * Generates the dashboard content for a report.
     * 
     * @param testSuites The test suites
     * @return The dashboard content
     */
    private String generateDashboardContent(List<CSTestSuite> testSuites) {
        Map<String, Object> variables = new HashMap<>();
        variables.put("passCount", getPassCount(testSuites));
        variables.put("failCount", getFailCount(testSuites));
        variables.put("skipCount", getSkipCount(testSuites));
        variables.put("totalCount", getTotalCount(testSuites));
        variables.put("passPercentage", getPassPercentage(testSuites));
        variables.put("duration", getTotalDuration(testSuites));
        variables.put("formattedDuration", getFormattedTotalDuration(testSuites));
        
        // Generate charts if requested
        if (includeCharts) {
            variables.put("charts", generateChartsContent(testSuites));
        } else {
            variables.put("charts", "");
        }
        
        // Generate summary content
        variables.put("summary", generateSummaryContent(testSuites));
        
        // Get the dashboard template
        String template = getTemplate("dashboard", TEMPLATE_DASHBOARD, DEFAULT_TEMPLATE_DASHBOARD);
        
        // Replace variables in the template
        return replaceVariables(template, variables);
    }
    
    /**
     * Generates the summary content for a dashboard.
     * 
     * @param testSuites The test suites
     * @return The summary content
     */
    private String generateSummaryContent(List<CSTestSuite> testSuites) {
        StringBuilder sb = new StringBuilder();
        
        sb.append("<div class=\"summary\">");
        sb.append("<div class=\"summary-item\">");
        sb.append("<div class=\"summary-value total\">").append(getTotalCount(testSuites)).append("</div>");
        sb.append("<div class=\"summary-label\">Total Tests</div>");
        sb.append("</div>");
        
        sb.append("<div class=\"summary-item\">");
        sb.append("<div class=\"summary-value pass\">").append(getPassCount(testSuites)).append("</div>");
        sb.append("<div class=\"summary-label\">Passed</div>");
        sb.append("</div>");
        
        sb.append("<div class=\"summary-item\">");
        sb.append("<div class=\"summary-value fail\">").append(getFailCount(testSuites)).append("</div>");
        sb.append("<div class=\"summary-label\">Failed</div>");
        sb.append("</div>");
        
        sb.append("<div class=\"summary-item\">");
        sb.append("<div class=\"summary-value skip\">").append(getSkipCount(testSuites)).append("</div>");
        sb.append("<div class=\"summary-label\">Skipped</div>");
        sb.append("</div>");
        
        sb.append("<div class=\"summary-item\">");
        sb.append("<div class=\"summary-value\">").append(String.format("%.2f%%", getPassPercentage(testSuites))).append("</div>");
        sb.append("<div class=\"summary-label\">Pass Rate</div>");
        sb.append("</div>");
        
        sb.append("<div class=\"summary-item\">");
        sb.append("<div class=\"summary-value\">").append(getFormattedTotalDuration(testSuites)).append("</div>");
        sb.append("<div class=\"summary-label\">Duration</div>");
        sb.append("</div>");
        
        sb.append("</div>");
        
        return sb.toString();
    }
    
    /**
     * Generates the charts content for a dashboard.
     * 
     * @param testSuites The test suites
     * @return The charts content
     */
    private String generateChartsContent(List<CSTestSuite> testSuites) {
        StringBuilder sb = new StringBuilder();
        
        sb.append("<div class=\"charts\">");
        
        // Status pie chart
        sb.append("<div class=\"chart-container\">");
        sb.append("<canvas id=\"statusChart\"></canvas>");
        sb.append("</div>");
        
        // Duration bar chart
        sb.append("<div class=\"chart-container\">");
        sb.append("<canvas id=\"durationChart\"></canvas>");
        sb.append("</div>");
        
        sb.append("</div>");
        
        // Chart initialization script
        sb.append("<script>");
        sb.append("document.addEventListener('DOMContentLoaded', function() {");
        
        // Status pie chart
        sb.append("var statusCtx = document.getElementById('statusChart').getContext('2d');");
        sb.append("var statusChart = new Chart(statusCtx, {");
        sb.append("    type: 'pie',");
        sb.append("    data: {");
        sb.append("        labels: ['Passed', 'Failed', 'Skipped'],");
        sb.append("        datasets: [{");
        sb.append("            data: [").append(getPassCount(testSuites)).append(", ")
                                      .append(getFailCount(testSuites)).append(", ")
                                      .append(getSkipCount(testSuites)).append("],");
        sb.append("            backgroundColor: ['#4CAF50', '#F44336', '#FFC107']");
        sb.append("        }]");
        sb.append("    },");
        sb.append("    options: {");
        sb.append("        responsive: true,");
        sb.append("        title: {");
        sb.append("            display: true,");
        sb.append("            text: 'Test Status'");
        sb.append("        }");
        sb.append("    }");
        sb.append("});");
        
        // Duration bar chart (top 10 longest tests)
        List<CSTestCase> allTests = getAllTestCases(testSuites);
        allTests.sort((t1, t2) -> Long.compare(t2.getDuration(), t1.getDuration())); // Sort by duration (descending)
        
        int maxTests = Math.min(10, allTests.size());
        if (maxTests > 0) {
            sb.append("var durationCtx = document.getElementById('durationChart').getContext('2d');");
            sb.append("var durationChart = new Chart(durationCtx, {");
            sb.append("    type: 'bar',");
            sb.append("    data: {");
            sb.append("        labels: [");
            
            for (int i = 0; i < maxTests; i++) {
                if (i > 0) {
                    sb.append(", ");
                }
                sb.append("'").append(escapeJs(allTests.get(i).getName())).append("'");
            }
            
            sb.append("],");
            sb.append("        datasets: [{");
            sb.append("            label: 'Duration (seconds)',");
            sb.append("            data: [");
            
            for (int i = 0; i < maxTests; i++) {
                if (i > 0) {
                    sb.append(", ");
                }
                sb.append(allTests.get(i).getDuration() / 1000.0);
            }
            
            sb.append("],");
            sb.append("            backgroundColor: '").append(themeColor).append("'");
            sb.append("        }]");
            sb.append("    },");
            sb.append("    options: {");
            sb.append("        responsive: true,");
            sb.append("        title: {");
            sb.append("            display: true,");
            sb.append("            text: 'Top ").append(maxTests).append(" Longest Tests'");
            sb.append("        }");
            sb.append("    }");
            sb.append("});");
        }
        
        sb.append("});");
        sb.append("</script>");
        
        return sb.toString();
    }
    
    /**
     * Generates the content for a test suite.
     * 
     * @param suite The test suite
     * @return The suite content
     */
    private String generateSuiteContent(CSTestSuite suite) {
        Map<String, Object> variables = new HashMap<>();
        variables.put("id", suite.getId());
        variables.put("name", suite.getName());
        variables.put("description", suite.getDescription() != null ? suite.getDescription() : "");
        variables.put("startTime", formatDate(suite.getStartTime()));
        variables.put("endTime", suite.getEndTime() != null ? formatDate(suite.getEndTime()) : "In Progress");
        variables.put("duration", suite.getDuration());
        variables.put("formattedDuration", suite.getFormattedDuration());
        variables.put("passCount", suite.getPassCount());
        variables.put("failCount", suite.getFailCount());
        variables.put("skipCount", suite.getSkipCount());
        variables.put("totalCount", suite.getTotalCount());
        variables.put("passPercentage", suite.getPassPercentage());
        variables.put("environment", suite.getEnvironment() != null ? suite.getEnvironment() : "");
        variables.put("browser", suite.getBrowser() != null ? suite.getBrowser() : "");
        
        // Generate test list
        StringBuilder testListBuilder = new StringBuilder();
        for (CSTestCase testCase : suite.getTestCases()) {
            testListBuilder.append(generateTestCaseSummary(testCase));
        }
        variables.put("testList", testListBuilder.toString());
        
        // Get the suite template
        String template = getTemplate("suite", TEMPLATE_SUITE, DEFAULT_TEMPLATE_SUITE);
        
        // Replace variables in the template
        return replaceVariables(template, variables);
    }
    
    /**
     * Generates a summary of a test case for inclusion in a suite.
     * 
     * @param testCase The test case
     * @return The test case summary
     */
    private String generateTestCaseSummary(CSTestCase testCase) {
        StringBuilder sb = new StringBuilder();
        
        String statusClass = "";
        if (testCase.getStatus().isSuccess()) {
            statusClass = "pass";
        } else if (testCase.getStatus().isFailure()) {
            statusClass = "fail";
        } else if (testCase.getStatus().isNeutral()) {
            statusClass = "skip";
        }
        
        sb.append("<div class=\"test-case-summary ").append(statusClass).append("\">");
        sb.append("<div class=\"test-case-header\">");
        sb.append("<span class=\"status-icon\"></span>");
        sb.append("<a href=\"testcase_").append(testCase.getId()).append(".html\" class=\"test-case-name\">")
          .append(testCase.getName()).append("</a>");
        sb.append("<span class=\"test-case-duration\">").append(testCase.getFormattedDuration()).append("</span>");
        sb.append("</div>");
        
        if (testCase.getDescription() != null && !testCase.getDescription().isEmpty()) {
            sb.append("<div class=\"test-case-description\">").append(testCase.getDescription()).append("</div>");
        }
        
        sb.append("</div>");
        
        return sb.toString();
    }
    
    /**
     * Generates the content for a test case.
     * 
     * @param testCase The test case
     * @return The test case content
     */
    private String generateTestCaseContent(CSTestCase testCase) {
        Map<String, Object> variables = new HashMap<>();
        variables.put("id", testCase.getId());
        variables.put("name", testCase.getName());
        variables.put("description", testCase.getDescription() != null ? testCase.getDescription() : "");
        variables.put("status", testCase.getStatus().getDisplayName());
        variables.put("statusClass", getStatusClass(testCase.getStatus()));
        variables.put("startTime", formatDate(testCase.getStartTime()));
        variables.put("endTime", testCase.getEndTime() != null ? formatDate(testCase.getEndTime()) : "In Progress");
        variables.put("duration", testCase.getDuration());
        variables.put("formattedDuration", testCase.getFormattedDuration());
        variables.put("suiteId", testCase.getSuiteId());
        variables.put("suiteName", getSuiteName(testCase.getSuiteId()));
        variables.put("passedStepCount", testCase.getPassedStepCount());
        variables.put("failedStepCount", testCase.getFailedStepCount());
        variables.put("skippedStepCount", testCase.getSkippedStepCount());
        variables.put("totalStepCount", testCase.getStepCount());
        variables.put("author", testCase.getAuthor() != null ? testCase.getAuthor() : "");
        
        // Generate step list
        StringBuilder stepListBuilder = new StringBuilder();
        for (CSTestStep step : testCase.getSteps()) {
            stepListBuilder.append(generateTestStepContent(step));
        }
        variables.put("stepList", stepListBuilder.toString());
        
        // Get the test case template
        String template = getTemplate("testcase", TEMPLATE_TESTCASE, DEFAULT_TEMPLATE_TESTCASE);
        
        // Replace variables in the template
        return replaceVariables(template, variables);
    }
    
    /**
     * Generates the content for a test step.
     * 
     * @param step The test step
     * @return The test step content
     */
    private String generateTestStepContent(CSTestStep step) {
        Map<String, Object> variables = new HashMap<>();
        variables.put("id", step.getId());
        variables.put("name", step.getName());
        variables.put("description", step.getDescription() != null ? step.getDescription() : "");
        variables.put("status", step.getStatus().getDisplayName());
        variables.put("statusClass", getStatusClass(step.getStatus()));
        variables.put("timestamp", formatDate(step.getTimestamp()));
        variables.put("duration", step.getDuration());
        variables.put("formattedDuration", step.getFormattedDuration());
        variables.put("expectedResult", step.getExpectedResult() != null ? step.getExpectedResult() : "");
        variables.put("actualResult", step.getActualResult() != null ? step.getActualResult() : "");
        variables.put("errorMessage", step.getErrorMessage() != null ? step.getErrorMessage() : "");
        variables.put("stackTrace", step.getStackTrace() != null ? step.getStackTrace() : "");
        variables.put("selector", step.getSelector() != null ? step.getSelector() : "");
        variables.put("action", step.getAction() != null ? step.getAction() : "");
        
        // Generate screenshots list
        StringBuilder screenshotsBuilder = new StringBuilder();
        for (CSScreenshot screenshot : step.getScreenshots()) {
            screenshotsBuilder.append(generateScreenshotContent(screenshot));
        }
        variables.put("screenshots", screenshotsBuilder.toString());
        
        // Generate attachments list
        StringBuilder attachmentsBuilder = new StringBuilder();
        for (CSAttachment attachment : step.getAttachments()) {
            attachmentsBuilder.append(generateAttachmentContent(attachment));
        }
        variables.put("attachments", attachmentsBuilder.toString());
        
        // Generate logs list
        StringBuilder logsBuilder = new StringBuilder();
        if (includeLogs) {
            for (CSLog log : step.getLogs()) {
                logsBuilder.append(generateLogContent(log));
            }
        }
        variables.put("logs", logsBuilder.toString());
        
        // Get the step template
        String template = getTemplate("step", TEMPLATE_STEP, DEFAULT_TEMPLATE_STEP);
        
        // Replace variables in the template
        return replaceVariables(template, variables);
    }
    
    /**
     * Generates the content for a screenshot.
     * 
     * @param screenshot The screenshot
     * @return The screenshot content
     */
    private String generateScreenshotContent(CSScreenshot screenshot) {
        StringBuilder sb = new StringBuilder();
        
        String screenshotPath = "";
        if (embedScreenshots) {
            // Embed the screenshot as a data URL
            byte[] data = screenshot.getData();
            if (data != null) {
                String base64Data = java.util.Base64.getEncoder().encodeToString(data);
                screenshotPath = "data:" + screenshot.getContentType() + ";base64," + base64Data;
            }
        } else {
            // Copy the screenshot to the screenshots directory and reference it
            screenshotPath = copyScreenshot(screenshot);
        }
        
        if (!screenshotPath.isEmpty()) {
            sb.append("<div class=\"screenshot\">");
            
            if (screenshot.getTitle() != null && !screenshot.getTitle().isEmpty()) {
                sb.append("<div class=\"screenshot-title\">").append(screenshot.getTitle()).append("</div>");
            }
            
            sb.append("<img src=\"").append(screenshotPath).append("\" alt=\"").append(screenshot.getTitle() != null ? screenshot.getTitle() : "Screenshot").append("\" class=\"screenshot-image\">");
            
            if (screenshot.getDescription() != null && !screenshot.getDescription().isEmpty()) {
                sb.append("<div class=\"screenshot-description\">").append(screenshot.getDescription()).append("</div>");
            }
            
            sb.append("</div>");
        }
        
        return sb.toString();
    }
    
    /**
     * Generates the content for an attachment.
     * 
     * @param attachment The attachment
     * @return The attachment content
     */
    private String generateAttachmentContent(CSAttachment attachment) {
        StringBuilder sb = new StringBuilder();
        
        sb.append("<div class=\"attachment\">");
        
        if (attachment.getTitle() != null && !attachment.getTitle().isEmpty()) {
            sb.append("<div class=\"attachment-title\">").append(attachment.getTitle()).append("</div>");
        }
        
        if (embedAttachments && attachment.isImage()) {
            // Embed the image attachment as a data URL
            byte[] data = attachment.getData();
            if (data != null) {
                String base64Data = java.util.Base64.getEncoder().encodeToString(data);
                String dataUrl = "data:" + attachment.getContentType() + ";base64," + base64Data;
                sb.append("<img src=\"").append(dataUrl).append("\" alt=\"").append(attachment.getTitle() != null ? attachment.getTitle() : "Attachment").append("\" class=\"attachment-image\">");
            }
        } else {
            // Copy the attachment to the attachments directory and reference it
            String attachmentPath = copyAttachment(attachment);
            
            if (!attachmentPath.isEmpty()) {
                sb.append("<a href=\"").append(attachmentPath).append("\" target=\"_blank\" class=\"attachment-link\">");
                sb.append("<span class=\"attachment-icon\"></span>");
                sb.append("<span class=\"attachment-name\">").append(attachment.getFileName()).append("</span>");
                sb.append("<span class=\"attachment-size\">").append(attachment.getFormattedSize()).append("</span>");
                sb.append("</a>");
            }
        }
        
        if (attachment.getDescription() != null && !attachment.getDescription().isEmpty()) {
            sb.append("<div class=\"attachment-description\">").append(attachment.getDescription()).append("</div>");
        }
        
        sb.append("</div>");
        
        return sb.toString();
    }
    
    /**
     * Generates the content for a log entry.
     * 
     * @param log The log entry
     * @return The log content
     */
    private String generateLogContent(CSLog log) {
        StringBuilder sb = new StringBuilder();
        
        String logLevelClass = "";
        switch (log.getLevel()) {
            case TRACE:
                logLevelClass = "trace";
                break;
            case DEBUG:
                logLevelClass = "debug";
                break;
            case INFO:
                logLevelClass = "info";
                break;
            case WARN:
                logLevelClass = "warn";
                break;
            case ERROR:
                logLevelClass = "error";
                break;
            case FATAL:
                logLevelClass = "fatal";
                break;
        }
        
        sb.append("<div class=\"log ").append(logLevelClass).append("\">");
        sb.append("<span class=\"log-timestamp\">").append(formatDate(log.getTimestamp())).append("</span>");
        sb.append("<span class=\"log-level\">").append(log.getLevel()).append("</span>");
        sb.append("<span class=\"log-message\">").append(log.getMessage()).append("</span>");
        
        if (log.getThrowableString() != null && !log.getThrowableString().isEmpty()) {
            sb.append("<pre class=\"log-throwable\">").append(log.getThrowableString()).append("</pre>");
        }
        
        sb.append("</div>");
        
        return sb.toString();
    }
    
    /**
     * Creates an index page for the report.
     * 
     * @param testSuites The test suites
     * @param reportFileName The report file name
     * @throws IOException If an error occurs
     */
    private void createIndexPage(List<CSTestSuite> testSuites, String reportFileName) throws IOException {
        Map<String, Object> variables = new HashMap<>(globalVariables);
        variables.put("title", reportTitle);
        variables.put("timestamp", formatDate(new Date()));
        variables.put("reportLink", reportFileName);
        variables.put("reportTitle", reportTitle);
        variables.put("passCount", getPassCount(testSuites));
        variables.put("failCount", getFailCount(testSuites));
        variables.put("skipCount", getSkipCount(testSuites));
        variables.put("totalCount", getTotalCount(testSuites));
        variables.put("passPercentage", getPassPercentage(testSuites));
        variables.put("duration", getTotalDuration(testSuites));
        variables.put("formattedDuration", getFormattedTotalDuration(testSuites));
        variables.put("themeColor", themeColor);
        variables.put("darkMode", darkMode);
        variables.put("responsive", responsiveDesign);
        
        // Generate suite list
        StringBuilder suiteListBuilder = new StringBuilder();
        for (CSTestSuite suite : testSuites) {
            suiteListBuilder.append("<li><a href=\"suite_").append(suite.getId()).append(".html\">")
                           .append(suite.getName()).append("</a> - ")
                           .append(suite.getPassCount()).append(" passed, ")
                           .append(suite.getFailCount()).append(" failed, ")
                           .append(suite.getSkipCount()).append(" skipped</li>");
        }
        variables.put("suiteList", suiteListBuilder.toString());
        
        // Get the index template
        String template = getTemplate("index", TEMPLATE_INDEX, DEFAULT_TEMPLATE_INDEX);
        
        // Replace variables in the template
        String htmlContent = replaceVariables(template, variables);
        
        // Minify the HTML if requested
        if (minifyOutput) {
            htmlContent = minifyHtml(htmlContent);
        }
        
        // Write the HTML to the file
        File indexFile = new File(reportDirectory, "index.html");
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(indexFile))) {
            writer.write(htmlContent);
        }
    }
    
    /**
     * Creates individual pages for each test suite.
     * 
     * @param testSuites The test suites
     * @throws IOException If an error occurs
     */
    private void createSuitePages(List<CSTestSuite> testSuites) throws IOException {
        for (CSTestSuite suite : testSuites) {
            Map<String, Object> variables = new HashMap<>(globalVariables);
            variables.put("title", suite.getName() + " - " + reportTitle);
            variables.put("timestamp", formatDate(new Date()));
            variables.put("themeColor", themeColor);
            variables.put("darkMode", darkMode);
            variables.put("responsive", responsiveDesign);
            variables.put("content", generateSuiteContent(suite));
            
            // Get the main template
            String template = getTemplate("main", TEMPLATE_MAIN, DEFAULT_TEMPLATE_MAIN);
            
            // Replace variables in the template
            String htmlContent = replaceVariables(template, variables);
            
            // Minify the HTML if requested
            if (minifyOutput) {
                htmlContent = minifyHtml(htmlContent);
            }
            
            // Write the HTML to the file
            File suiteFile = new File(reportDirectory, "suite_" + suite.getId() + ".html");
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(suiteFile))) {
                writer.write(htmlContent);
            }
        }
    }
    
    /**
     * Creates individual pages for each test case.
     * 
     * @param testSuites The test suites
     * @throws IOException If an error occurs
     */
    private void createTestCasePages(List<CSTestSuite> testSuites) throws IOException {
        for (CSTestSuite suite : testSuites) {
            for (CSTestCase testCase : suite.getTestCases()) {
                Map<String, Object> variables = new HashMap<>(globalVariables);
                variables.put("title", testCase.getName() + " - " + reportTitle);
                variables.put("timestamp", formatDate(new Date()));
                variables.put("themeColor", themeColor);
                variables.put("darkMode", darkMode);
                variables.put("responsive", responsiveDesign);
                variables.put("content", generateTestCaseContent(testCase));
                
                // Get the main template
                String template = getTemplate("main", TEMPLATE_MAIN, DEFAULT_TEMPLATE_MAIN);
                
                // Replace variables in the template
                String htmlContent = replaceVariables(template, variables);
                
                // Minify the HTML if requested
                if (minifyOutput) {
                    htmlContent = minifyHtml(htmlContent);
                }
                
                // Write the HTML to the file
                File testCaseFile = new File(reportDirectory, "testcase_" + testCase.getId() + ".html");
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(testCaseFile))) {
                    writer.write(htmlContent);
                }
            }
        }
    }
    
    /**
     * Copies a screenshot to the screenshots directory and returns the path.
     * 
     * @param screenshot The screenshot
     * @return The path to the copied screenshot
     */
    private String copyScreenshot(CSScreenshot screenshot) {
        File screenshotsDir = new File(reportDirectory, DIR_SCREENSHOTS);
        if (!screenshotsDir.exists()) {
            screenshotsDir.mkdirs();
        }
        
        String fileName = "screenshot_" + screenshot.getId() + "_" + 
                         (screenshot.getFileName() != null ? screenshot.getFileName() : "screenshot.png");
        File outputFile = new File(screenshotsDir, fileName);
        
        try {
            if (screenshot.isInMemory()) {
                byte[] data = screenshot.getData();
                if (data != null) {
                    Files.write(outputFile.toPath(), data);
                    return DIR_SCREENSHOTS + "/" + fileName;
                }
            } else if (screenshot.getFilePath() != null) {
                File sourceFile = new File(screenshot.getFilePath());
                if (sourceFile.exists()) {
                    Files.copy(sourceFile.toPath(), outputFile.toPath());
                    return DIR_SCREENSHOTS + "/" + fileName;
                }
            }
        } catch (IOException e) {
            CSLogger.error("Failed to copy screenshot", e);
        }
        
        return "";
    }
    
    /**
     * Copies an attachment to the attachments directory and returns the path.
     * 
     * @param attachment The attachment
     * @return The path to the copied attachment
     */
    private String copyAttachment(CSAttachment attachment) {
        File attachmentsDir = new File(reportDirectory, DIR_ATTACHMENTS);
        if (!attachmentsDir.exists()) {
            attachmentsDir.mkdirs();
        }
        
        String fileName = "attachment_" + attachment.getId() + "_" + 
                         (attachment.getFileName() != null ? attachment.getFileName() : "attachment");
        File outputFile = new File(attachmentsDir, fileName);
        
        try {
            if (attachment.isInMemory()) {
                byte[] data = attachment.getData();
                if (data != null) {
                    Files.write(outputFile.toPath(), data);
                    return DIR_ATTACHMENTS + "/" + fileName;
                }
            } else if (attachment.getFilePath() != null) {
                File sourceFile = new File(attachment.getFilePath());
                if (sourceFile.exists()) {
                    Files.copy(sourceFile.toPath(), outputFile.toPath());
                    return DIR_ATTACHMENTS + "/" + fileName;
                }
            }
        } catch (IOException e) {
            CSLogger.error("Failed to copy attachment", e);
        }
        
        return "";
    }
    
    /**
     * Copies required resources to the report directory.
     * 
     * @throws IOException If an error occurs
     */
    private void copyResources() throws IOException {
        // Create resource directories
        File cssDir = new File(reportDirectory, DIR_CSS);
        if (!cssDir.exists()) {
            cssDir.mkdirs();
        }
        
        File jsDir = new File(reportDirectory, DIR_JS);
        if (!jsDir.exists()) {
            jsDir.mkdirs();
        }
        
        File imagesDir = new File(reportDirectory, DIR_IMAGES);
        if (!imagesDir.exists()) {
            imagesDir.mkdirs();
        }
        
        // Copy CSS resources
        copyResourceToFile(CSS_MAIN, new File(cssDir, "styles.css"));
        copyResourceToFile(CSS_BOOTSTRAP, new File(cssDir, "bootstrap.min.css"));
        copyResourceToFile(CSS_FONTAWESOME, new File(cssDir, "fontawesome.min.css"));
        
        // Copy JavaScript resources
        copyResourceToFile(JS_MAIN, new File(jsDir, "main.js"));
        copyResourceToFile(JS_JQUERY, new File(jsDir, "jquery.min.js"));
        copyResourceToFile(JS_BOOTSTRAP, new File(jsDir, "bootstrap.min.js"));
        copyResourceToFile(JS_CHART, new File(jsDir, "chart.js"));
        
        // Copy logo and favicon if not overridden
        if (logoUrl == null) {
            File logoFile = new File(imagesDir, "logo.png");
            copyResourceToFile(LOGO_PATH, logoFile);
            logoUrl = DIR_IMAGES + "/logo.png";
        }
        
        if (faviconUrl == null) {
            File faviconFile = new File(imagesDir, "favicon.ico");
            copyResourceToFile(FAVICON_PATH, faviconFile);
            faviconUrl = DIR_IMAGES + "/favicon.ico";
        }
    }
    
    /**
     * Copies a resource to a file.
     * 
     * @param resourcePath The resource path
     * @param outputFile The output file
     * @throws IOException If an error occurs
     */
    private void copyResourceToFile(String resourcePath, File outputFile) throws IOException {
        // Check if resource is cached
        byte[] resourceData = resourceCache.get(resourcePath);
        
        if (resourceData == null) {
            // Load resource
            try (InputStream is = getClass().getResourceAsStream(resourcePath)) {
                if (is != null) {
                    resourceData = is.readAllBytes();
                    resourceCache.put(resourcePath, resourceData);
                } else {
                    CSLogger.warn("Resource not found: " + resourcePath);
                    return;
                }
            } catch (IOException e) {
                CSLogger.warn("Failed to load resource: " + resourcePath, e);
                return;
            }
        }
        
        // Write to file
        try (OutputStream os = new FileOutputStream(outputFile)) {
            os.write(resourceData);
        }
    }
    
    /**
     * Gets a template from the template cache or loads it from a resource.
     * 
     * @param name The template name
     * @param resourcePath The resource path
     * @param defaultTemplate The default template to use if the resource cannot be loaded
     * @return The template
     */
    private String getTemplate(String name, String resourcePath, String defaultTemplate) {
        // Check for custom template
        String customTemplate = customTemplates.get(name);
        if (customTemplate != null) {
            return customTemplate;
        }
        
        // Check template cache
        String template = templateCache.get(resourcePath);
        if (template != null) {
            return template;
        }
        
        // Load template from resource
        try (InputStream is = getClass().getResourceAsStream(resourcePath)) {
            if (is != null) {
                template = new String(is.readAllBytes(), StandardCharsets.UTF_8);
                templateCache.put(resourcePath, template);
                return template;
            }
        } catch (Exception e) {
            CSLogger.warn("Failed to load template: " + resourcePath, e);
        }
        
        // Use default template
        return defaultTemplate;
    }
    
    /**
     * Replaces variables in a template.
     * 
     * @param template The template
     * @param variables The variables
     * @return The processed template
     */
    private String replaceVariables(String template, Map<String, Object> variables) {
        String result = template;
        
        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            String placeholder = "${" + entry.getKey() + "}";
            String value = entry.getValue() != null ? entry.getValue().toString() : "";
            result = result.replace(placeholder, value);
        }
        
        return result;
    }
    
    /**
     * Formats a date.
     * 
     * @param date The date
     * @return The formatted date
     */
    private String formatDate(Date date) {
        if (date == null) {
            return "";
        }
        
        SimpleDateFormat formatter = new SimpleDateFormat(dateTimeFormat);
        return formatter.format(date);
    }
    
    /**
     * Gets the CSS class for a test status.
     * 
     * @param status The test status
     * @return The CSS class
     */
    private String getStatusClass(CSTestStatus status) {
        if (status.isSuccess()) {
            return "pass";
        } else if (status.isFailure()) {
            return "fail";
        } else if (status.isNeutral()) {
            return "skip";
        } else if (status.isWarning()) {
            return "warning";
        } else if (status.isInProgress()) {
            return "in-progress";
        } else {
            return "unknown";
        }
    }
    
    /**
     * Gets the name of a test suite by ID.
     * 
     * @param suiteId The suite ID
     * @return The suite name
     */
    private String getSuiteName(String suiteId) {
        // Note: This implementation assumes that the suite is available in memory
        // In a real implementation, you would look up the suite by ID from a registry
        return "Test Suite";
    }
    
    /**
     * Gets the total number of passed tests from multiple suites.
     * 
     * @param testSuites The test suites
     * @return The number of passed tests
     */
    private int getPassCount(List<CSTestSuite> testSuites) {
        int count = 0;
        for (CSTestSuite suite : testSuites) {
            count += suite.getPassCount();
        }
        return count;
    }
    
    /**
     * Gets the total number of failed tests from multiple suites.
     * 
     * @param testSuites The test suites
     * @return The number of failed tests
     */
    private int getFailCount(List<CSTestSuite> testSuites) {
        int count = 0;
        for (CSTestSuite suite : testSuites) {
            count += suite.getFailCount();
        }
        return count;
    }
    
    /**
     * Gets the total number of skipped tests from multiple suites.
     * 
     * @param testSuites The test suites
     * @return The number of skipped tests
     */
    private int getSkipCount(List<CSTestSuite> testSuites) {
        int count = 0;
        for (CSTestSuite suite : testSuites) {
            count += suite.getSkipCount();
        }
        return count;
    }
    
    /**
     * Gets the total number of tests from multiple suites.
     * 
     * @param testSuites The test suites
     * @return The total number of tests
     */
    private int getTotalCount(List<CSTestSuite> testSuites) {
        int count = 0;
        for (CSTestSuite suite : testSuites) {
            count += suite.getTotalCount();
        }
        return count;
    }
    
    /**
     * Gets the pass percentage for all tests from multiple suites.
     * 
     * @param testSuites The test suites
     * @return The pass percentage
     */
    private double getPassPercentage(List<CSTestSuite> testSuites) {
        int total = getTotalCount(testSuites);
        if (total == 0) {
            return 0;
        }
        
        int passed = getPassCount(testSuites);
        return (double) passed / total * 100;
    }
    
    /**
     * Gets the total duration of all suites.
     * 
     * @param testSuites The test suites
     * @return The total duration in milliseconds
     */
    private long getTotalDuration(List<CSTestSuite> testSuites) {
        long total = 0;
        for (CSTestSuite suite : testSuites) {
            long duration = suite.getDuration();
            if (duration > 0) {
                total += duration;
            }
        }
        return total;
    }
    
    /**
     * Gets the formatted total duration of all suites.
     * 
     * @param testSuites The test suites
     * @return The formatted total duration
     */
    private String getFormattedTotalDuration(List<CSTestSuite> testSuites) {
        long duration = getTotalDuration(testSuites);
        if (duration < 0) {
            return "In Progress";
        }
        
        long seconds = duration / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        
        seconds %= 60;
        minutes %= 60;
        
        StringBuilder sb = new StringBuilder();
        if (hours > 0) {
            sb.append(hours).append("h ");
        }
        if (minutes > 0 || hours > 0) {
            sb.append(minutes).append("m ");
        }
        sb.append(seconds).append("s");
        
        return sb.toString();
    }
    
    /**
     * Gets all test cases from multiple suites.
     * 
     * @param testSuites The test suites
     * @return List of all test cases
     */
    private List<CSTestCase> getAllTestCases(List<CSTestSuite> testSuites) {
        List<CSTestCase> allTests = new ArrayList<>();
        for (CSTestSuite suite : testSuites) {
            allTests.addAll(suite.getTestCases());
        }
        return allTests;
    }
    
    /**
     * Minifies HTML content.
     * 
     * @param html The HTML content
     * @return The minified HTML
     */
    private String minifyHtml(String html) {
        if (html == null || html.isEmpty()) {
            return html;
        }
        
        // This is a simple implementation - a real implementation might use a dedicated library
        
        // Remove comments
        html = html.replaceAll("<!--.*?-->", "");
        
        // Remove unnecessary whitespace
        html = html.replaceAll("\\s+", " ");
        html = html.replaceAll("> <", "><");
        html = html.replaceAll(" +", " ");
        html = html.replaceAll("\\s*</", "</");
        html = html.replaceAll("\\s*<", "<");
        html = html.replaceAll(">\\s*", ">");
        
        return html.trim();
    }
    
    /**
     * Escapes a string for JavaScript.
     * 
     * @param input The input string
     * @return The escaped string
     */
    private String escapeJs(String input) {
        if (input == null) {
            return "";
        }
        
        return input.replace("\\", "\\\\")
                   .replace("'", "\\'")
                   .replace("\"", "\\\"")
                   .replace("\r", "\\r")
                   .replace("\n", "\\n")
                   .replace("\t", "\\t");
    }
    
    /**
     * Implementation of CSReport for HTML reports.
     */
    private static class CSHtmlReport implements CSReport {
        
        private final String id;
        private final String name;
        private final File reportFile;
        private final List<CSTestSuite> testSuites;
        private final Date generationTime;
        private final Map<String, Object> properties;
        private final List<CSAttachment> attachments;
        private File reportDirectory;
        private Map<String, String> customTemplates;
        
        /**
         * Constructor for CSHtmlReport.
         * 
         * @param id The report ID
         * @param name The report name
         * @param reportFile The report file
         * @param testSuites The test suites
         */
        public CSHtmlReport(String id, String name, File reportFile, List<CSTestSuite> testSuites) {
            this.id = id;
            this.name = name;
            this.reportFile = reportFile;
            this.testSuites = new ArrayList<>(testSuites);
            this.generationTime = new Date();
            this.properties = new HashMap<>();
            this.attachments = new ArrayList<>();
            this.reportDirectory = reportFile.getParentFile();
            this.customTemplates = new HashMap<>();
        }
        
        @Override
        public String getId() {
            return id;
        }
        
        @Override
        public String getName() {
            return name;
        }
        
        @Override
        public String getFormat() {
            return "html";
        }
        
        @Override
        public Date getGenerationTime() {
            return generationTime;
        }
        
        @Override
        public List<CSTestSuite> getTestSuites() {
            return new ArrayList<>(testSuites);
        }
        
        @Override
        public CSTestSuite getTestSuite(String suiteId) {
            for (CSTestSuite suite : testSuites) {
                if (suite.getId().equals(suiteId)) {
                    return suite;
                }
            }
            return null;
        }
        
        @Override
        public int getTestSuiteCount() {
            return testSuites.size();
        }
        
        @Override
        public int getTotalTestCount() {
            int count = 0;
            for (CSTestSuite suite : testSuites) {
                count += suite.getTotalCount();
            }
            return count;
        }
        
        @Override
        public int getPassedTestCount() {
            int count = 0;
            for (CSTestSuite suite : testSuites) {
                count += suite.getPassCount();
            }
            return count;
        }
        
        @Override
        public int getFailedTestCount() {
            int count = 0;
            for (CSTestSuite suite : testSuites) {
                count += suite.getFailCount();
            }
            return count;
        }
        
        @Override
        public int getSkippedTestCount() {
            int count = 0;
            for (CSTestSuite suite : testSuites) {
                count += suite.getSkipCount();
            }
            return count;
        }
        
        @Override
        public double getPassPercentage() {
            int total = getTotalTestCount();
            if (total == 0) {
                return 0;
            }
            return (double) getPassedTestCount() / total * 100;
        }
        
        @Override
        public long getTotalDuration() {
            long total = 0;
            for (CSTestSuite suite : testSuites) {
                long duration = suite.getDuration();
                if (duration > 0) {
                    total += duration;
                }
            }
            return total;
        }
        
        @Override
        public String getFormattedTotalDuration() {
            long duration = getTotalDuration();
            if (duration < 0) {
                return "In Progress";
            }
            
            long seconds = duration / 1000;
            long minutes = seconds / 60;
            long hours = minutes / 60;
            
            seconds %= 60;
            minutes %= 60;
            
            StringBuilder sb = new StringBuilder();
            if (hours > 0) {
                sb.append(hours).append("h ");
            }
            if (minutes > 0 || hours > 0) {
                sb.append(minutes).append("m ");
            }
            sb.append(seconds).append("s");
            
            return sb.toString();
        }
        
        @Override
        public CSDashboard getDashboard() {
            CSDashboard dashboard = new CSDashboard(name + " Dashboard");
            
            // Add test suites to dashboard
            for (CSTestSuite suite : testSuites) {
                dashboard.addTestSuite(suite);
            }
            
            // Create charts
            // Status pie chart
            Map<String, Object> statusData = new HashMap<>();
            statusData.put("labels", List.of("Passed", "Failed", "Skipped"));
            statusData.put("datasets", List.of(
                Map.of(
                    "data", List.of(getPassedTestCount(), getFailedTestCount(), getSkippedTestCount()),
                    "backgroundColor", List.of("#4CAF50", "#F44336", "#FFC107")
                )
            ));
            
            CSChart statusChart = new CSChart("Test Status", "pie", statusData);
            dashboard.addChart(statusChart);
            
            // Generate some metrics
            dashboard.addMetric("Pass Rate", getPassPercentage(), "%");
            dashboard.addMetric("Total Duration", getTotalDuration(), "ms");
            dashboard.addMetric("Average Duration", getTotalTestCount() > 0 ? getTotalDuration() / getTotalTestCount() : 0, "ms");
            
            return dashboard;
        }
        
        @Override
        public Object getProperty(String name) {
            return properties.get(name);
        }
        
        @Override
        public Map<String, Object> getProperties() {
            return new HashMap<>(properties);
        }
        
        @Override
        public void setProperty(String name, Object value) {
            properties.put(name, value);
        }
        
        @Override
        public Object removeProperty(String name) {
            return properties.remove(name);
        }
        
        @Override
        public byte[] getContent() {
            try {
                return Files.readAllBytes(reportFile.toPath());
            } catch (IOException e) {
                CSLogger.error("Failed to read report file", e);
                return new byte[0];
            }
        }
        
        @Override
        public String getContentType() {
            return "text/html";
        }
        
        @Override
        public boolean saveToFile(File file) {
            try {
                Files.copy(reportFile.toPath(), file.toPath());
                return true;
            } catch (IOException e) {
                CSLogger.error("Failed to save report to file", e);
                return false;
            }
        }
        
        @Override
        public String getFilePath() {
            return reportFile.getAbsolutePath();
        }
        
        @Override
        public String getUrl() {
            return "file://" + reportFile.getAbsolutePath();
        }
        
        @Override
        public Map<String, Object> getMetrics() {
            Map<String, Object> metrics = new HashMap<>();
            metrics.put("testSuiteCount", getTestSuiteCount());
            metrics.put("totalTestCount", getTotalTestCount());
            metrics.put("passedTestCount", getPassedTestCount());
            metrics.put("failedTestCount", getFailedTestCount());
            metrics.put("skippedTestCount", getSkippedTestCount());
            metrics.put("passPercentage", getPassPercentage());
            metrics.put("totalDuration", getTotalDuration());
            metrics.put("formattedTotalDuration", getFormattedTotalDuration());
            return metrics;
        }
        
        @Override
        public Object getMetric(String name) {
            return getMetrics().get(name);
        }
        
        @Override
        public void addMetric(String name, Object value) {
            setProperty("metric." + name, value);
        }
        
        @Override
        public Object removeMetric(String name) {
            return removeProperty("metric." + name);
        }
        
        @Override
        public List<String> getEnvironments() {
            List<String> environments = new ArrayList<>();
            for (CSTestSuite suite : testSuites) {
                String environment = suite.getEnvironment();
                if (environment != null && !environment.isEmpty() && !environments.contains(environment)) {
                    environments.add(environment);
                }
            }
            return environments;
        }
        
        @Override
        public List<String> getBrowsers() {
            List<String> browsers = new ArrayList<>();
            for (CSTestSuite suite : testSuites) {
                String browser = suite.getBrowser();
                if (browser != null && !browser.isEmpty() && !browsers.contains(browser)) {
                    browsers.add(browser);
                }
            }
            return browsers;
        }
        
        @Override
        public List<String> getOperatingSystems() {
            List<String> operatingSystems = new ArrayList<>();
            for (CSTestSuite suite : testSuites) {
                String os = suite.getOperatingSystem();
                if (os != null && !os.isEmpty() && !operatingSystems.contains(os)) {
                    operatingSystems.add(os);
                }
            }
            return operatingSystems;
        }
        
        @Override
        public List<String> getCategories() {
            List<String> categories = new ArrayList<>();
            for (CSTestSuite suite : testSuites) {
                for (CSTestCase testCase : suite.getTestCases()) {
                    for (String category : testCase.getCategories()) {
                        if (!categories.contains(category)) {
                            categories.add(category);
                        }
                    }
                }
            }
            return categories;
        }
        
        @Override
        public List<String> getTags() {
            List<String> tags = new ArrayList<>();
            for (CSTestSuite suite : testSuites) {
                for (String tag : suite.getTags()) {
                    if (!tags.contains(tag)) {
                        tags.add(tag);
                    }
                }
                
                for (CSTestCase testCase : suite.getTestCases()) {
                    for (String tag : testCase.getTags()) {
                        if (!tags.contains(tag)) {
                            tags.add(tag);
                        }
                    }
                }
            }
            return tags;
        }
        
        @Override
        public List<CSTestCase> getTestCasesByStatus(CSTestStatus status) {
            List<CSTestCase> matchingTests = new ArrayList<>();
            for (CSTestSuite suite : testSuites) {
                for (CSTestCase testCase : suite.getTestCases()) {
                    if (testCase.getStatus() == status) {
                        matchingTests.add(testCase);
                    }
                }
            }
            return matchingTests;
        }
        
        @Override
        public List<CSTestCase> getTestCasesByTag(String tag) {
            List<CSTestCase> matchingTests = new ArrayList<>();
            for (CSTestSuite suite : testSuites) {
                for (CSTestCase testCase : suite.getTestCases()) {
                    if (testCase.getTags().contains(tag)) {
                        matchingTests.add(testCase);
                    }
                }
            }
            return matchingTests;
        }
        
        @Override
        public List<CSTestCase> getTestCasesByCategory(String category) {
            List<CSTestCase> matchingTests = new ArrayList<>();
            for (CSTestSuite suite : testSuites) {
                for (CSTestCase testCase : suite.getTestCases()) {
                    if (testCase.getCategories().contains(category)) {
                        matchingTests.add(testCase);
                    }
                }
            }
            return matchingTests;
        }
        
        @Override
        public Map<String, Object> getCharts() {
            Map<String, Object> charts = new HashMap<>();
            
            // Status pie chart data
            Map<String, Object> statusData = new HashMap<>();
            statusData.put("labels", List.of("Passed", "Failed", "Skipped"));
            statusData.put("datasets", List.of(
                Map.of(
                    "data", List.of(getPassedTestCount(), getFailedTestCount(), getSkippedTestCount()),
                    "backgroundColor", List.of("#4CAF50", "#F44336", "#FFC107")
                )
            ));
            charts.put("statusChart", statusData);
            
            return charts;
        }
        
        @Override
        public List<CSAttachment> getAttachments() {
            return new ArrayList<>(attachments);
        }
        
        @Override
        public void addAttachment(CSAttachment attachment) {
            attachments.add(attachment);
        }
        
        @Override
        public String getSummary() {
            StringBuilder sb = new StringBuilder();
            sb.append("Test Summary: ");
            sb.append(getPassedTestCount()).append(" passed, ");
            sb.append(getFailedTestCount()).append(" failed, ");
            sb.append(getSkippedTestCount()).append(" skipped. ");
            sb.append("Pass rate: ").append(String.format("%.2f%%", getPassPercentage())).append(". ");
            sb.append("Total duration: ").append(getFormattedTotalDuration()).append(".");
            return sb.toString();
        }
        
        @Override
        public CSTestStatus getStatus() {
            if (getFailedTestCount() > 0) {
                return CSTestStatus.FAIL;
            } else if (getSkippedTestCount() > 0) {
                return CSTestStatus.WARNING;
            } else {
                return CSTestStatus.PASS;
            }
        }
        
        @Override
        public String toJson() {
            StringBuilder sb = new StringBuilder();
            sb.append("{");
            sb.append("\"id\": \"").append(id).append("\",");
            sb.append("\"name\": \"").append(escapeJson(name)).append("\",");
            sb.append("\"format\": \"html\",");
            sb.append("\"generationTime\": \"").append(generationTime).append("\",");
            sb.append("\"filePath\": \"").append(escapeJson(getFilePath())).append("\",");
            sb.append("\"url\": \"").append(escapeJson(getUrl())).append("\",");
            sb.append("\"status\": \"").append(getStatus()).append("\",");
            sb.append("\"summary\": \"").append(escapeJson(getSummary())).append("\",");
            
            // Metrics
            sb.append("\"metrics\": {");
            sb.append("\"testSuiteCount\": ").append(getTestSuiteCount()).append(",");
            sb.append("\"totalTestCount\": ").append(getTotalTestCount()).append(",");
            sb.append("\"passedTestCount\": ").append(getPassedTestCount()).append(",");
            sb.append("\"failedTestCount\": ").append(getFailedTestCount()).append(",");
            sb.append("\"skippedTestCount\": ").append(getSkippedTestCount()).append(",");
            sb.append("\"passPercentage\": ").append(getPassPercentage()).append(",");
            sb.append("\"totalDuration\": ").append(getTotalDuration()).append(",");
            sb.append("\"formattedTotalDuration\": \"").append(getFormattedTotalDuration()).append("\"");
            sb.append("},");
            
            // Test suite IDs
            sb.append("\"testSuiteIds\": [");
            for (int i = 0; i < testSuites.size(); i++) {
                if (i > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(testSuites.get(i).getId()).append("\"");
            }
            sb.append("],");
            
            // Properties
            sb.append("\"properties\": {");
            int propIndex = 0;
            for (Map.Entry<String, Object> entry : properties.entrySet()) {
                if (propIndex > 0) {
                    sb.append(",");
                }
                sb.append("\"").append(entry.getKey()).append("\": ");
                appendJsonValue(sb, entry.getValue());
                propIndex++;
            }
            sb.append("}");
            
            sb.append("}");
            return sb.toString();
        }
        
        private void appendJsonValue(StringBuilder sb, Object value) {
            if (value == null) {
                sb.append("null");
            } else if (value instanceof Number || value instanceof Boolean) {
                sb.append(value);
            } else if (value instanceof String) {
                sb.append("\"").append(escapeJson((String) value)).append("\"");
            } else if (value instanceof Date) {
                sb.append("\"").append(value).append("\"");
            } else if (value instanceof Map) {
                sb.append("{");
                int index = 0;
                @SuppressWarnings("unchecked")
                Map<String, Object> map = (Map<String, Object>) value;
                for (Map.Entry<String, Object> entry : map.entrySet()) {
                    if (index > 0) {
                        sb.append(",");
                    }
                    sb.append("\"").append(entry.getKey()).append("\":");
                    appendJsonValue(sb, entry.getValue());
                    index++;
                }
                sb.append("}");
            } else if (value instanceof List) {
                sb.append("[");
                int index = 0;
                @SuppressWarnings("unchecked")
                List<Object> list = (List<Object>) value;
                for (Object item : list) {
                    if (index > 0) {
                        sb.append(",");
                    }
                    appendJsonValue(sb, item);
                    index++;
                }
                sb.append("]");
            } else {
                // Default to string representation
                sb.append("\"").append(escapeJson(value.toString())).append("\"");
            }
        }
        
        private String escapeJson(String input) {
            if (input == null) {
                return "";
            }
            return input.replace("\\", "\\\\")
                       .replace("\"", "\\\"")
                       .replace("\r", "\\r")
                       .replace("\n", "\\n")
                       .replace("\t", "\\t");
        }
        
        @Override
        public String toXml() {
            StringBuilder sb = new StringBuilder();
            sb.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
            sb.append("<report id=\"").append(id).append("\" format=\"html\">\n");
            sb.append("  <name>").append(escapeXml(name)).append("</name>\n");
            sb.append("  <generationTime>").append(generationTime).append("</generationTime>\n");
            sb.append("  <filePath>").append(escapeXml(getFilePath())).append("</filePath>\n");
            sb.append("  <url>").append(escapeXml(getUrl())).append("</url>\n");
            sb.append("  <status>").append(getStatus()).append("</status>\n");
            sb.append("  <summary>").append(escapeXml(getSummary())).append("</summary>\n");
            
            // Metrics
            sb.append("  <metrics>\n");
            sb.append("    <testSuiteCount>").append(getTestSuiteCount()).append("</testSuiteCount>\n");
            sb.append("    <totalTestCount>").append(getTotalTestCount()).append("</totalTestCount>\n");
            sb.append("    <passedTestCount>").append(getPassedTestCount()).append("</passedTestCount>\n");
            sb.append("    <failedTestCount>").append(getFailedTestCount()).append("</failedTestCount>\n");
            sb.append("    <skippedTestCount>").append(getSkippedTestCount()).append("</skippedTestCount>\n");
            sb.append("    <passPercentage>").append(getPassPercentage()).append("</passPercentage>\n");
            sb.append("    <totalDuration>").append(getTotalDuration()).append("</totalDuration>\n");
            sb.append("    <formattedTotalDuration>").append(getFormattedTotalDuration()).append("</formattedTotalDuration>\n");
            sb.append("  </metrics>\n");
            
            // Test suites
            sb.append("  <testSuites>\n");
            for (CSTestSuite suite : testSuites) {
                sb.append("    <testSuite id=\"").append(suite.getId()).append("\">\n");
                sb.append("      <name>").append(escapeXml(suite.getName())).append("</name>\n");
                sb.append("      <testCount>").append(suite.getTotalCount()).append("</testCount>\n");
                sb.append("    </testSuite>\n");
            }
            sb.append("  </testSuites>\n");
            
            // Properties
            sb.append("  <properties>\n");
            for (Map.Entry<String, Object> entry : properties.entrySet()) {
                sb.append("    <property name=\"").append(escapeXml(entry.getKey())).append("\">");
                sb.append(escapeXml(entry.getValue() != null ? entry.getValue().toString() : ""));
                sb.append("</property>\n");
            }
            sb.append("  </properties>\n");
            
            sb.append("</report>");
            return sb.toString();
        }
        
        private String escapeXml(String input) {
            if (input == null) {
                return "";
            }
            return input.replace("&", "&amp;")
                       .replace("<", "&lt;")
                       .replace(">", "&gt;")
                       .replace("\"", "&quot;")
                       .replace("'", "&apos;");
        }
        
        @Override
        public String getAssetPath(String assetPath) {
            if (assetPath == null || assetPath.isEmpty()) {
                return "";
            }
            
            File assetFile = new File(reportDirectory, assetPath);
            return assetFile.getAbsolutePath();
        }
        
        @Override
        public File getReportDirectory() {
            return reportDirectory;
        }
        
        @Override
        public void setReportDirectory(File directory) {
            this.reportDirectory = directory;
        }
        
        @Override
        public Map<String, String> getCustomTemplates() {
            return new HashMap<>(customTemplates);
        }
        
        @Override
        public void setCustomTemplate(String name, String content) {
            customTemplates.put(name, content);
        }
    }
}


package com.cstestforge.framework.core.reporting;

import java.util.List;

/**
 * Interface for report generators in the CSTestForge framework.
 * Report generators create reports from test suites.
 */
public interface CSReportGenerator {
    
    /**
     * Generates a report for a test suite.
     * 
     * @param testSuite The test suite
     * @return The generated report
     */
    CSReport generateReport(CSTestSuite testSuite);
    
    /**
     * Generates a report for multiple test suites.
     * 
     * @param testSuites The test suites
     * @return The generated report
     */
    CSReport generateReport(List<CSTestSuite> testSuites);
}


package com.cstestforge.framework.core.reporting.listener;

import java.io.File;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.testng.ITestContext;
import org.testng.ITestListener;
import org.testng.ITestResult;

import com.cstestforge.framework.core.reporting.CSAttachment;
import com.cstestforge.framework.core.reporting.CSLogLevel;
import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.reporting.CSScreenshot;
import com.cstestforge.framework.core.reporting.CSTestStatus;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSScreenshotManager;

/**
 * TestNG listener that integrates with the CSTestForge reporting framework.
 * Listens for test events and updates the report accordingly.
 */
public class CSTestListener implements ITestListener {
    
    private final CSReporter reporter;
    private final Map<String, Long> testStartTimes = new ConcurrentHashMap<>();
    private final Map<String, String> testCaseIds = new ConcurrentHashMap<>();
    private final boolean captureScreenshotOnFailure;
    private final boolean captureScreenshotOnSuccess;
    private final boolean captureLogs;
    private final boolean attachTestNGContext;
    private final CSScreenshotManager screenshotManager;
    
    /**
     * Constructor for CSTestListener.
     * 
     * @param reporter The reporter to use
     */
    public CSTestListener(CSReporter reporter) {
        this(reporter, true, false, true, true);
    }
    
    /**
     * Constructor for CSTestListener with additional options.
     * 
     * @param reporter The reporter to use
     * @param captureScreenshotOnFailure Whether to capture screenshots on test failures
     * @param captureScreenshotOnSuccess Whether to capture screenshots on test successes
     * @param captureLogs Whether to capture logs
     * @param attachTestNGContext Whether to attach TestNG context information
     */
    public CSTestListener(CSReporter reporter, boolean captureScreenshotOnFailure, 
                         boolean captureScreenshotOnSuccess, boolean captureLogs,
                         boolean attachTestNGContext) {
        this.reporter = reporter;
        this.captureScreenshotOnFailure = captureScreenshotOnFailure;
        this.captureScreenshotOnSuccess = captureScreenshotOnSuccess;
        this.captureLogs = captureLogs;
        this.attachTestNGContext = attachTestNGContext;
        this.screenshotManager = new CSScreenshotManager();
    }
    
    @Override
    public void onTestStart(ITestResult result) {
        String methodName = result.getMethod().getMethodName();
        String className = result.getInstanceName();
        String testName = className + "." + methodName;
        String description = result.getMethod().getDescription();
        
        // Start test case if it doesn't exist
        String testId = reporter.startTest(testName, description);
        testCaseIds.put(getTestResultKey(result), testId);
        testStartTimes.put(getTestResultKey(result), System.currentTimeMillis());
        
        // Log test start
        reporter.log(testId, CSLogLevel.INFO, "Test started: " + testName);
        
        if (attachTestNGContext) {
            // Add test parameters as attributes
            Object[] parameters = result.getParameters();
            if (parameters != null && parameters.length > 0) {
                for (int i = 0; i < parameters.length; i++) {
                    reporter.addMetric(testId, "param" + i, String.valueOf(parameters[i]));
                }
            }
        }
    }
    
    @Override
    public void onTestSuccess(ITestResult result) {
        String testId = testCaseIds.get(getTestResultKey(result));
        if (testId == null) {
            // Test was not started properly, start it now
            String methodName = result.getMethod().getMethodName();
            String className = result.getInstanceName();
            String testName = className + "." + methodName;
            String description = result.getMethod().getDescription();
            testId = reporter.startTest(testName, description);
            testCaseIds.put(getTestResultKey(result), testId);
        }
        
        // Log test success
        reporter.log(testId, CSLogLevel.INFO, "Test passed: " + result.getMethod().getMethodName());
        
        // Calculate test duration
        long startTime = testStartTimes.getOrDefault(getTestResultKey(result), System.currentTimeMillis());
        long duration = System.currentTimeMillis() - startTime;
        
        // Capture screenshot if enabled
        if (captureScreenshotOnSuccess) {
            try {
                byte[] screenshot = screenshotManager.captureScreenshot();
                if (screenshot != null) {
                    reporter.attachScreenshot(testId, screenshot, "Success Screenshot", "Screenshot captured on test success");
                }
            } catch (Exception e) {
                CSLogger.warn("Failed to capture screenshot on test success", e);
            }
        }
        
        // End test case
        reporter.endTest(testId, CSTestStatus.PASS);
    }
    
    @Override
    public void onTestFailure(ITestResult result) {
        String testId = testCaseIds.get(getTestResultKey(result));
        if (testId == null) {
            // Test was not started properly, start it now
            String methodName = result.getMethod().getMethodName();
            String className = result.getInstanceName();
            String testName = className + "." + methodName;
            String description = result.getMethod().getDescription();
            testId = reporter.startTest(testName, description);
            testCaseIds.put(getTestResultKey(result), testId);
        }
        
        // Log test failure
        Throwable throwable = result.getThrowable();
        if (throwable != null) {
            reporter.log(testId, CSLogLevel.ERROR, "Test failed: " + result.getMethod().getMethodName() + 
                                                 " - " + throwable.getMessage(), throwable);
        } else {
            reporter.log(testId, CSLogLevel.ERROR, "Test failed: " + result.getMethod().getMethodName());
        }
        
        // Calculate test duration
        long startTime = testStartTimes.getOrDefault(getTestResultKey(result), System.currentTimeMillis());
        long duration = System.currentTimeMillis() - startTime;
        
        // Capture screenshot if enabled
        if (captureScreenshotOnFailure) {
            try {
                byte[] screenshot = screenshotManager.captureScreenshot();
                if (screenshot != null) {
                    reporter.attachScreenshot(testId, screenshot, "Failure Screenshot", "Screenshot captured on test failure");
                }
            } catch (Exception e) {
                CSLogger.warn("Failed to capture screenshot on test failure", e);
            }
        }
        
        // Handle any files from reported exception
        if (throwable != null) {
            if (throwable instanceof org.testng.internal.ExitCodeException) {
                reporter.log(testId, CSLogLevel.ERROR, "Test exited with code: " + 
                           ((org.testng.internal.ExitCodeException) throwable).getExitCode());
            }
            
            // Attach any files referenced in the exception
            attachFilesFromException(testId, throwable);
        }
        
        // End test case
        reporter.endTest(testId, CSTestStatus.FAIL);
    }
    
    @Override
    public void onTestSkipped(ITestResult result) {
        String testId = testCaseIds.get(getTestResultKey(result));
        if (testId == null) {
            // Test was not started properly, start it now
            String methodName = result.getMethod().getMethodName();
            String className = result.getInstanceName();
            String testName = className + "." + methodName;
            String description = result.getMethod().getDescription();
            testId = reporter.startTest(testName, description);
            testCaseIds.put(getTestResultKey(result), testId);
        }
        
        // Log test skipped
        reporter.log(testId, CSLogLevel.INFO, "Test skipped: " + result.getMethod().getMethodName());
        
        // Calculate test duration
        long startTime = testStartTimes.getOrDefault(getTestResultKey(result), System.currentTimeMillis());
        long duration = System.currentTimeMillis() - startTime;
        
        // End test case
        reporter.endTest(testId, CSTestStatus.SKIP);
    }
    
    @Override
    public void onTestFailedButWithinSuccessPercentage(ITestResult result) {
        String testId = testCaseIds.get(getTestResultKey(result));
        if (testId == null) {
            // Test was not started properly, start it now
            String methodName = result.getMethod().getMethodName();
            String className = result.getInstanceName();
            String testName = className + "." + methodName;
            String description = result.getMethod().getDescription();
            testId = reporter.startTest(testName, description);
            testCaseIds.put(getTestResultKey(result), testId);
        }
        
        // Log test warning
        reporter.log(testId, CSLogLevel.WARN, "Test failed but within success percentage: " + 
                   result.getMethod().getMethodName());
        
        // Calculate test duration
        long startTime = testStartTimes.getOrDefault(getTestResultKey(result), System.currentTimeMillis());
        long duration = System.currentTimeMillis() - startTime;
        
        // End test case
        reporter.endTest(testId, CSTestStatus.WARNING);
    }
    
    @Override
    public void onStart(ITestContext context) {
        // Start a test suite for the context
        String suiteName = context.getName();
        String suiteId = reporter.startTestSuite(suiteName, "TestNG Suite: " + suiteName);
        
        if (attachTestNGContext) {
            // Add suite attributes
            Map<String, Object> attributes = new HashMap<>();
            attributes.put("outputDirectory", context.getOutputDirectory());
            attributes.put("includedGroups", String.join(", ", context.getIncludedGroups()));
            attributes.put("excludedGroups", String.join(", ", context.getExcludedGroups()));
            attributes.put("hostName", context.getHost());
            attributes.put("startTime", new Date(context.getStartDate().getTime()));
            
            for (Map.Entry<String, Object> entry : attributes.entrySet()) {
                reporter.addMetric(suiteId, entry.getKey(), entry.getValue().toString());
            }
        }
    }
    
    @Override
    public void onFinish(ITestContext context) {
        // End the test suite
        reporter.endTestSuite();
    }
    
    /**
     * Attaches files referenced in an exception to a test case.
     * 
     * @param testId The test case ID
     * @param throwable The exception
     */
    private void attachFilesFromException(String testId, Throwable throwable) {
        if (throwable == null) {
            return;
        }
        
        String message = throwable.getMessage();
        if (message != null) {
            // Check for file references in the exception message
            // This is a simplified implementation - in practice, you would adapt this to your needs
            if (message.contains("file:")) {
                int index = message.indexOf("file:");
                int endIndex = message.indexOf(" ", index);
                if (endIndex == -1) {
                    endIndex = message.length();
                }
                
                String filePath = message.substring(index + 5, endIndex);
                File file = new File(filePath);
                if (file.exists() && file.isFile()) {
                    reporter.attachFile(testId, file, "Referenced File", "File referenced in exception message");
                }
            }
        }
        
        // Check the cause recursively
        if (throwable.getCause() != null && throwable.getCause() != throwable) {
            attachFilesFromException(testId, throwable.getCause());
        }
    }
    
    /**
     * Gets a unique key for a test result.
     * 
     * @param result The test result
     * @return The key
     */
    private String getTestResultKey(ITestResult result) {
        return result.getTestClass().getName() + "." + result.getMethod().getMethodName();
    }
}


package com.cstestforge.framework.core.ai;

import java.util.List;
import java.util.Map;
import java.util.Set;

import com.cstestforge.framework.core.ai.models.ElementRecognitionModel;
import com.cstestforge.framework.core.ai.models.ElementFeatures;
import com.cstestforge.framework.core.ai.models.ElementMatch;
import com.cstestforge.framework.core.ai.dictionary.ElementDictionary;

/**
 * Service for AI-powered element recognition.
 * Recognizes web elements based on their attributes and context.
 */
public interface ElementRecognitionService {
    
    /**
     * Recognizes an element based on its attributes and context.
     * 
     * @param attributes The element attributes
     * @param innerText The element inner text
     * @param context The element context
     * @return The recognized element type, or null if not recognized
     */
    String recognizeElement(Map<String, String> attributes, String innerText, Map<String, Object> context);
    
    /**
     * Recognizes multiple elements based on their attributes and context.
     * 
     * @param elements List of element information
     * @return List of recognized element types
     */
    List<String> recognizeElements(List<Map<String, Object>> elements);
    
    /**
     * Gets possible element types for an element.
     * 
     * @param attributes The element attributes
     * @param innerText The element inner text
     * @param context The element context
     * @return Map of element types to confidence scores
     */
    Map<String, Double> getElementTypeProbabilities(Map<String, String> attributes, String innerText, 
                                                  Map<String, Object> context);
    
    /**
     * Gets the best match for an element.
     * 
     * @param attributes The element attributes
     * @param innerText The element inner text
     * @param context The element context
     * @return The best element match
     */
    ElementMatch getBestMatch(Map<String, String> attributes, String innerText, Map<String, Object> context);
    
    /**
     * Gets similar elements in the dictionary.
     * 
     * @param attributes The element attributes
     * @param innerText The element inner text
     * @param context The element context
     * @param maxResults The maximum number of results
     * @return List of similar elements
     */
    List<ElementMatch> getSimilarElements(Map<String, String> attributes, String innerText, 
                                        Map<String, Object> context, int maxResults);
    
    /**
     * Trains the recognition model with new examples.
     * 
     * @param examples The training examples
     * @return True if training was successful, false otherwise
     */
    boolean trainModel(List<Map<String, Object>> examples);
    
    /**
     * Adds a new element type to the recognition model.
     * 
     * @param elementType The element type
     * @param features The element features
     * @return True if the element type was added successfully, false otherwise
     */
    boolean addElementType(String elementType, ElementFeatures features);
    
    /**
     * Updates an existing element type in the recognition model.
     * 
     * @param elementType The element type
     * @param features The element features
     * @return True if the element type was updated successfully, false otherwise
     */
    boolean updateElementType(String elementType, ElementFeatures features);
    
    /**
     * Removes an element type from the recognition model.
     * 
     * @param elementType The element type
     * @return True if the element type was removed successfully, false otherwise
     */
    boolean removeElementType(String elementType);
    
    /**
     * Gets all supported element types.
     * 
     * @return Set of supported element types
     */
    Set<String> getSupportedElementTypes();
    
    /**
     * Gets features for an element type.
     * 
     * @param elementType The element type
     * @return The element features, or null if not found
     */
    ElementFeatures getElementFeatures(String elementType);
    
    /**
     * Evaluates the recognition model accuracy.
     * 
     * @param testData The test data
     * @return The accuracy (0-1)
     */
    double evaluateAccuracy(List<Map<String, Object>> testData);
    
    /**
     * Gets the recognition model.
     * 
     * @return The recognition model
     */
    ElementRecognitionModel getModel();
    
    /**
     * Sets the recognition model.
     * 
     * @param model The recognition model
     */
    void setModel(ElementRecognitionModel model);
    
    /**
     * Gets the element dictionary.
     * 
     * @return The element dictionary
     */
    ElementDictionary getDictionary();
    
    /**
     * Sets the element dictionary.
     * 
     * @param dictionary The element dictionary
     */
    void setDictionary(ElementDictionary dictionary);
    
    /**
     * Saves the recognition model to a file.
     * 
     * @param filePath The file path
     * @return True if the model was saved successfully, false otherwise
     */
    boolean saveModel(String filePath);
    
    /**
     * Loads the recognition model from a file.
     * 
     * @param filePath The file path
     * @return True if the model was loaded successfully, false otherwise
     */
    boolean loadModel(String filePath);
}


package com.cstestforge.framework.core.ai;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import com.cstestforge.framework.core.ai.dictionary.ElementDictionary;
import com.cstestforge.framework.core.ai.models.ElementFeatures;
import com.cstestforge.framework.core.ai.models.ElementMatch;
import com.cstestforge.framework.core.ai.models.ElementRecognitionModel;
import com.cstestforge.framework.core.utils.CSLogger;

/**
 * Implementation of the ElementRecognitionService interface.
 * Provides AI-powered element recognition capabilities.
 */
public class ElementRecognitionServiceImpl implements ElementRecognitionService {
    
    private static final String DEFAULT_MODEL_PATH = "data/models/element_recognition_model.bin";
    private static final double SIMILARITY_THRESHOLD = 0.7;
    private static final double CONFIDENCE_THRESHOLD = 0.8;
    private static final int MAX_SIMILAR_RESULTS = 5;
    
    private ElementRecognitionModel model;
    private ElementDictionary dictionary;
    
    /**
     * Default constructor.
     * Initializes with a default model and dictionary.
     */
    public ElementRecognitionServiceImpl() {
        this.model = new ElementRecognitionModel();
        this.dictionary = new ElementDictionary();
        
        // Load default model if available
        try {
            loadModel(DEFAULT_MODEL_PATH);
        } catch (Exception e) {
            CSLogger.info("Default element recognition model not found. Using empty model.");
            initializeDefaultModel();
        }
    }
    
    /**
     * Constructor with a specific model and dictionary.
     * 
     * @param model The element recognition model
     * @param dictionary The element dictionary
     */
    public ElementRecognitionServiceImpl(ElementRecognitionModel model, ElementDictionary dictionary) {
        this.model = model;
        this.dictionary = dictionary;
    }
    
    /**
     * Initializes the default model with common web element types.
     */
    private void initializeDefaultModel() {
        // Initialize model with common web element types
        Map<String, ElementFeatures> defaultElements = getDefaultElements();
        for (Map.Entry<String, ElementFeatures> entry : defaultElements.entrySet()) {
            model.addElementType(entry.getKey(), entry.getValue());
        }
        
        // Initialize dictionary with common terms
        dictionary.loadDefaultTerms();
    }
    
    /**
     * Gets default element types and features.
     * 
     * @return Map of element types to features
     */
    private Map<String, ElementFeatures> getDefaultElements() {
        Map<String, ElementFeatures> defaultElements = new HashMap<>();
        
        // Button element
        ElementFeatures buttonFeatures = new ElementFeatures();
        buttonFeatures.addTagName("button", 1.0);
        buttonFeatures.addTagName("input", 0.8);
        buttonFeatures.addAttribute("type", "button", 1.0);
        buttonFeatures.addAttribute("type", "submit", 0.9);
        buttonFeatures.addAttribute("role", "button", 1.0);
        buttonFeatures.addClassPattern(".*btn.*", 0.8);
        buttonFeatures.addClassPattern(".*button.*", 0.8);
        buttonFeatures.addTextPattern("Submit|Save|Cancel|OK|Yes|No|Close|Apply|Delete|Add|Edit", 0.7);
        defaultElements.put("button", buttonFeatures);
        
        // Text input element
        ElementFeatures textInputFeatures = new ElementFeatures();
        textInputFeatures.addTagName("input", 1.0);
        textInputFeatures.addAttribute("type", "text", 1.0);
        textInputFeatures.addAttribute("type", "email", 0.9);
        textInputFeatures.addAttribute("type", "password", 0.9);
        textInputFeatures.addAttribute("type", "search", 0.9);
        textInputFeatures.addAttribute("type", "tel", 0.9);
        textInputFeatures.addAttribute("type", "url", 0.9);
        textInputFeatures.addClassPattern(".*input.*", 0.7);
        textInputFeatures.addClassPattern(".*field.*", 0.7);
        textInputFeatures.addClassPattern(".*form-control.*", 0.8);
        defaultElements.put("textInput", textInputFeatures);
        
        // Checkbox element
        ElementFeatures checkboxFeatures = new ElementFeatures();
        checkboxFeatures.addTagName("input", 1.0);
        checkboxFeatures.addAttribute("type", "checkbox", 1.0);
        checkboxFeatures.addClassPattern(".*checkbox.*", 0.8);
        defaultElements.put("checkbox", checkboxFeatures);
        
        // Radio button element
        ElementFeatures radioFeatures = new ElementFeatures();
        radioFeatures.addTagName("input", 1.0);
        radioFeatures.addAttribute("type", "radio", 1.0);
        radioFeatures.addClassPattern(".*radio.*", 0.8);
        defaultElements.put("radio", radioFeatures);
        
        // Select/dropdown element
        ElementFeatures selectFeatures = new ElementFeatures();
        selectFeatures.addTagName("select", 1.0);
        selectFeatures.addClassPattern(".*select.*", 0.8);
        selectFeatures.addClassPattern(".*dropdown.*", 0.8);
        selectFeatures.addClassPattern(".*combo.*", 0.7);
        defaultElements.put("select", selectFeatures);
        
        // Link element
        ElementFeatures linkFeatures = new ElementFeatures();
        linkFeatures.addTagName("a", 1.0);
        linkFeatures.addAttribute("href", ".*", 0.9);
        linkFeatures.addClassPattern(".*link.*", 0.7);
        defaultElements.put("link", linkFeatures);
        
        // Image element
        ElementFeatures imageFeatures = new ElementFeatures();
        imageFeatures.addTagName("img", 1.0);
        imageFeatures.addAttribute("src", ".*", 0.9);
        imageFeatures.addAttribute("alt", ".*", 0.6);
        defaultElements.put("image", imageFeatures);
        
        // Table element
        ElementFeatures tableFeatures = new ElementFeatures();
        tableFeatures.addTagName("table", 1.0);
        tableFeatures.addTagName("div", 0.5);
        tableFeatures.addClassPattern(".*table.*", 0.8);
        tableFeatures.addAttribute("role", "grid", 0.9);
        defaultElements.put("table", tableFeatures);
        
        // Form element
        ElementFeatures formFeatures = new ElementFeatures();
        formFeatures.addTagName("form", 1.0);
        formFeatures.addAttribute("action", ".*", 0.7);
        formFeatures.addAttribute("method", ".*", 0.7);
        defaultElements.put("form", formFeatures);
        
        // Heading element
        ElementFeatures headingFeatures = new ElementFeatures();
        headingFeatures.addTagName("h1", 1.0);
        headingFeatures.addTagName("h2", 0.9);
        headingFeatures.addTagName("h3", 0.8);
        headingFeatures.addTagName("h4", 0.7);
        headingFeatures.addTagName("h5", 0.6);
        headingFeatures.addTagName("h6", 0.5);
        defaultElements.put("heading", headingFeatures);
        
        // Paragraph element
        ElementFeatures paragraphFeatures = new ElementFeatures();
        paragraphFeatures.addTagName("p", 1.0);
        defaultElements.put("paragraph", paragraphFeatures);
        
        // List element
        ElementFeatures listFeatures = new ElementFeatures();
        listFeatures.addTagName("ul", 1.0);
        listFeatures.addTagName("ol", 0.9);
        listFeatures.addAttribute("role", "list", 0.9);
        listFeatures.addClassPattern(".*list.*", 0.7);
        defaultElements.put("list", listFeatures);
        
        // List item element
        ElementFeatures listItemFeatures = new ElementFeatures();
        listItemFeatures.addTagName("li", 1.0);
        listItemFeatures.addAttribute("role", "listitem", 0.9);
        listItemFeatures.addClassPattern(".*list-item.*", 0.7);
        defaultElements.put("listItem", listItemFeatures);
        
        // Label element
        ElementFeatures labelFeatures = new ElementFeatures();
        labelFeatures.addTagName("label", 1.0);
        labelFeatures.addAttribute("for", ".*", 0.8);
        defaultElements.put("label", labelFeatures);
        
        // Div element (generic container)
        ElementFeatures divFeatures = new ElementFeatures();
        divFeatures.addTagName("div", 1.0);
        defaultElements.put("div", divFeatures);
        
        // Span element (generic inline element)
        ElementFeatures spanFeatures = new ElementFeatures();
        spanFeatures.addTagName("span", 1.0);
        defaultElements.put("span", spanFeatures);
        
        return defaultElements;
    }
    
    @Override
    public String recognizeElement(Map<String, String> attributes, String innerText, Map<String, Object> context) {
        // Get all element type probabilities
        Map<String, Double> probabilities = getElementTypeProbabilities(attributes, innerText, context);
        
        // Find the highest probability element type
        String bestMatch = null;
        double highestProbability = 0;
        
        for (Map.Entry<String, Double> entry : probabilities.entrySet()) {
            if (entry.getValue() > highestProbability) {
                highestProbability = entry.getValue();
                bestMatch = entry.getKey();
            }
        }
        
        // Return the best match if it meets the confidence threshold
        return (highestProbability >= CONFIDENCE_THRESHOLD) ? bestMatch : null;
    }
    
    @Override
    public List<String> recognizeElements(List<Map<String, Object>> elements) {
        List<String> results = new ArrayList<>();
        
        for (Map<String, Object> element : elements) {
            @SuppressWarnings("unchecked")
            Map<String, String> attributes = (Map<String, String>) element.getOrDefault("attributes", new HashMap<>());
            String innerText = (String) element.getOrDefault("innerText", "");
            
            @SuppressWarnings("unchecked")
            Map<String, Object> context = (Map<String, Object>) element.getOrDefault("context", new HashMap<>());
            
            String elementType = recognizeElement(attributes, innerText, context);
            results.add(elementType);
        }
        
        return results;
    }
    
    @Override
    public Map<String, Double> getElementTypeProbabilities(Map<String, String> attributes, String innerText, 
                                                         Map<String, Object> context) {
        Map<String, Double> probabilities = new HashMap<>();
        
        // Extract features from the element
        ElementFeatures elementFeatures = extractFeaturesFromElement(attributes, innerText, context);
        
        // Calculate probabilities for each element type
        for (String elementType : model.getElementTypes()) {
            ElementFeatures typeFeatures = model.getElementFeatures(elementType);
            double similarity = calculateSimilarity(elementFeatures, typeFeatures);
            probabilities.put(elementType, similarity);
        }
        
        // Sort probabilities in descending order
        return sortByValueDescending(probabilities);
    }
    
    @Override
    public ElementMatch getBestMatch(Map<String, String> attributes, String innerText, Map<String, Object> context) {
        Map<String, Double> probabilities = getElementTypeProbabilities(attributes, innerText, context);
        
        // Find the highest probability element type
        String bestMatchType = null;
        double highestProbability = 0;
        
        for (Map.Entry<String, Double> entry : probabilities.entrySet()) {
            if (entry.getValue() > highestProbability) {
                highestProbability = entry.getValue();
                bestMatchType = entry.getKey();
            }
        }
        
        if (bestMatchType != null && highestProbability >= SIMILARITY_THRESHOLD) {
            return new ElementMatch(bestMatchType, highestProbability, model.getElementFeatures(bestMatchType));
        }
        
        return null;
    }
    
    @Override
    public List<ElementMatch> getSimilarElements(Map<String, String> attributes, String innerText, 
                                               Map<String, Object> context, int maxResults) {
        Map<String, Double> probabilities = getElementTypeProbabilities(attributes, innerText, context);
        List<ElementMatch> matches = new ArrayList<>();
        
        // Convert probabilities to matches
        for (Map.Entry<String, Double> entry : probabilities.entrySet()) {
            if (entry.getValue() >= SIMILARITY_THRESHOLD) {
                ElementMatch match = new ElementMatch(entry.getKey(), entry.getValue(), 
                                                    model.getElementFeatures(entry.getKey()));
                matches.add(match);
            }
        }
        
        // Sort matches by probability (descending) and limit the results
        matches.sort(Comparator.comparing(ElementMatch::getConfidence).reversed());
        
        // Limit the results
        int resultLimit = Math.min(matches.size(), maxResults > 0 ? maxResults : MAX_SIMILAR_RESULTS);
        return matches.subList(0, resultLimit);
    }
    
    @Override
    public boolean trainModel(List<Map<String, Object>> examples) {
        try {
            for (Map<String, Object> example : examples) {
                String elementType = (String) example.get("elementType");
                if (elementType == null || elementType.isEmpty()) {
                    continue;
                }
                
                @SuppressWarnings("unchecked")
                Map<String, String> attributes = (Map<String, String>) example.getOrDefault("attributes", new HashMap<>());
                String innerText = (String) example.getOrDefault("innerText", "");
                
                // Extract features from the example
                ElementFeatures features = extractFeaturesFromElement(attributes, innerText, null);
                
                // Update the model
                if (model.hasElementType(elementType)) {
                    ElementFeatures existingFeatures = model.getElementFeatures(elementType);
                    ElementFeatures mergedFeatures = mergeFeatures(existingFeatures, features);
                    model.updateElementType(elementType, mergedFeatures);
                } else {
                    model.addElementType(elementType, features);
                }
            }
            
            return true;
        } catch (Exception e) {
            CSLogger.error("Failed to train element recognition model", e);
            return false;
        }
    }
    
    @Override
    public boolean addElementType(String elementType, ElementFeatures features) {
        if (elementType == null || elementType.isEmpty() || features == null) {
            return false;
        }
        
        try {
            model.addElementType(elementType, features);
            return true;
        } catch (Exception e) {
            CSLogger.error("Failed to add element type: " + elementType, e);
            return false;
        }
    }
    
    @Override
    public boolean updateElementType(String elementType, ElementFeatures features) {
        if (elementType == null || elementType.isEmpty() || features == null) {
            return false;
        }
        
        try {
            if (!model.hasElementType(elementType)) {
                return false;
            }
            
            model.updateElementType(elementType, features);
            return true;
        } catch (Exception e) {
            CSLogger.error("Failed to update element type: " + elementType, e);
            return false;
        }
    }
    
    @Override
    public boolean removeElementType(String elementType) {
        if (elementType == null || elementType.isEmpty()) {
            return false;
        }
        
        try {
            return model.removeElementType(elementType);
        } catch (Exception e) {
            CSLogger.error("Failed to remove element type: " + elementType, e);
            return false;
        }
    }
    
    @Override
    public Set<String> getSupportedElementTypes() {
        return model.getElementTypes();
    }
    
    @Override
    public ElementFeatures getElementFeatures(String elementType) {
        return model.getElementFeatures(elementType);
    }
    
    @Override
    public double evaluateAccuracy(List<Map<String, Object>> testData) {
        if (testData == null || testData.isEmpty()) {
            return 0;
        }
        
        int correctPredictions = 0;
        
        for (Map<String, Object> example : testData) {
            String actualType = (String) example.get("elementType");
            if (actualType == null || actualType.isEmpty()) {
                continue;
            }
            
            @SuppressWarnings("unchecked")
            Map<String, String> attributes = (Map<String, String>) example.getOrDefault("attributes", new HashMap<>());
            String innerText = (String) example.getOrDefault("innerText", "");
            
            @SuppressWarnings("unchecked")
            Map<String, Object> context = (Map<String, Object>) example.getOrDefault("context", new HashMap<>());
            
            String predictedType = recognizeElement(attributes, innerText, context);
            
            if (actualType.equals(predictedType)) {
                correctPredictions++;
            }
        }
        
        return (double) correctPredictions / testData.size();
    }
    
    @Override
    public ElementRecognitionModel getModel() {
        return model;
    }
    
    @Override
    public void setModel(ElementRecognitionModel model) {
        this.model = model;
    }
    
    @Override
    public ElementDictionary getDictionary() {
        return dictionary;
    }
    
    @Override
    public void setDictionary(ElementDictionary dictionary) {
        this.dictionary = dictionary;
    }
    
    @Override
    public boolean saveModel(String filePath) {
        try {
            File file = new File(filePath);
            
            // Create parent directories if they don't exist
            if (!file.getParentFile().exists()) {
                file.getParentFile().mkdirs();
            }
            
            // Save the model
            try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file))) {
                out.writeObject(model);
            }
            
            return true;
        } catch (IOException e) {
            CSLogger.error("Failed to save element recognition model to: " + filePath, e);
            return false;
        }
    }
    
    @Override
    public boolean loadModel(String filePath) {
        try {
            File file = new File(filePath);
            
            if (!file.exists()) {
                return false;
            }
            
            // Load the model
            try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(file))) {
                model = (ElementRecognitionModel) in.readObject();
            }
            
            return true;
        } catch (IOException | ClassNotFoundException e) {
            CSLogger.error("Failed to load element recognition model from: " + filePath, e);
            return false;
        }
    }
    
    /**
     * Extracts features from an element.
     * 
     * @param attributes The element attributes
     * @param innerText The element inner text
     * @param context The element context
     * @return The extracted features
     */
    private ElementFeatures extractFeaturesFromElement(Map<String, String> attributes, String innerText, 
                                                     Map<String, Object> context) {
        ElementFeatures features = new ElementFeatures();
        
        // Process tag name
        String tagName = attributes.get("tagName");
        if (tagName != null && !tagName.isEmpty()) {
            features.addTagName(tagName.toLowerCase(), 1.0);
        }
        
        // Process attributes
        for (Map.Entry<String, String> entry : attributes.entrySet()) {
            if (!entry.getKey().equals("tagName") && !entry.getKey().equals("class") && 
                !entry.getKey().equals("id") && !entry.getKey().equals("text")) {
                features.addAttribute(entry.getKey().toLowerCase(), entry.getValue(), 1.0);
            }
        }
        
        // Process class names
        String className = attributes.get("class");
        if (className != null && !className.isEmpty()) {
            String[] classes = className.split("\\s+");
            for (String cls : classes) {
                if (!cls.trim().isEmpty()) {
                    features.addClassName(cls.trim(), 1.0);
                }
            }
        }
        
        // Process ID
        String id = attributes.get("id");
        if (id != null && !id.isEmpty()) {
            features.setId(id);
        }
        
        // Process inner text
        if (innerText != null && !innerText.isEmpty()) {
            features.setText(innerText);
            
            // Add text patterns based on dictionary
            Set<String> terms = dictionary.extractTerms(innerText);
            for (String term : terms) {
                features.addTextPattern(term, 0.8);
            }
        }
        
        // Process context if available
        if (context != null) {
            // Process parent elements
            @SuppressWarnings("unchecked")
            List<Map<String, String>> parents = (List<Map<String, String>>) context.get("parents");
            if (parents != null) {
                for (Map<String, String> parent : parents) {
                    String parentTag = parent.get("tagName");
                    if (parentTag != null) {
                        features.addParentTag(parentTag.toLowerCase(), 0.7);
                    }
                }
            }
            
            // Process sibling elements
            @SuppressWarnings("unchecked")
            List<Map<String, String>> siblings = (List<Map<String, String>>) context.get("siblings");
            if (siblings != null) {
                for (Map<String, String> sibling : siblings) {
                    String siblingTag = sibling.get("tagName");
                    if (siblingTag != null) {
                        features.addSiblingTag(siblingTag.toLowerCase(), 0.5);
                    }
                }
            }
            
            // Process position-related context
            Integer index = (Integer) context.get("index");
            if (index != null) {
                features.setIndex(index);
            }
            
            Boolean isFirst = (Boolean) context.get("isFirst");
            if (isFirst != null && isFirst) {
                features.setFirst(true);
            }
            
            Boolean isLast = (Boolean) context.get("isLast");
            if (isLast != null && isLast) {
                features.setLast(true);
            }
            
            // Process visual context
            Integer x = (Integer) context.get("x");
            Integer y = (Integer) context.get("y");
            Integer width = (Integer) context.get("width");
            Integer height = (Integer) context.get("height");
            
            if (x != null && y != null && width != null && height != null) {
                features.setBounds(x, y, width, height);
            }
        }
        
        return features;
    }
    
    /**
     * Calculates the similarity between two sets of element features.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculateSimilarity(ElementFeatures features1, ElementFeatures features2) {
        double score = 0;
        double totalWeight = 0;
        
        // Tag name similarity (high weight)
        double tagNameSimilarity = calculateTagNameSimilarity(features1, features2);
        score += tagNameSimilarity * 0.3;
        totalWeight += 0.3;
        
        // Attribute similarity (high weight)
        double attributeSimilarity = calculateAttributeSimilarity(features1, features2);
        score += attributeSimilarity * 0.25;
        totalWeight += 0.25;
        
        // Class name similarity (medium weight)
        double classNameSimilarity = calculateClassNameSimilarity(features1, features2);
        score += classNameSimilarity * 0.2;
        totalWeight += 0.2;
        
        // Text similarity (medium weight)
        double textSimilarity = calculateTextSimilarity(features1, features2);
        score += textSimilarity * 0.15;
        totalWeight += 0.15;
        
        // Context similarity (low weight)
        double contextSimilarity = calculateContextSimilarity(features1, features2);
        score += contextSimilarity * 0.1;
        totalWeight += 0.1;
        
        // Normalize the score
        return totalWeight > 0 ? score / totalWeight : 0;
    }
    
    /**
     * Calculates the similarity between tag names.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculateTagNameSimilarity(ElementFeatures features1, ElementFeatures features2) {
        Map<String, Double> tagNames1 = features1.getTagNames();
        Map<String, Double> tagNames2 = features2.getTagNames();
        
        if (tagNames1.isEmpty() || tagNames2.isEmpty()) {
            return 0;
        }
        
        double maxSimilarity = 0;
        
        for (Map.Entry<String, Double> entry1 : tagNames1.entrySet()) {
            String tagName1 = entry1.getKey();
            double weight1 = entry1.getValue();
            
            Double weight2 = tagNames2.get(tagName1);
            if (weight2 != null) {
                double similarity = weight1 * weight2;
                maxSimilarity = Math.max(maxSimilarity, similarity);
            }
        }
        
        return maxSimilarity;
    }
    
    /**
     * Calculates the similarity between attributes.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculateAttributeSimilarity(ElementFeatures features1, ElementFeatures features2) {
        Map<String, Map<String, Double>> attributes1 = features1.getAttributes();
        Map<String, Map<String, Double>> attributes2 = features2.getAttributes();
        
        if (attributes1.isEmpty() || attributes2.isEmpty()) {
            return 0;
        }
        
        double totalSimilarity = 0;
        int matchCount = 0;
        
        for (Map.Entry<String, Map<String, Double>> entry1 : attributes1.entrySet()) {
            String name1 = entry1.getKey();
            Map<String, Double> values1 = entry1.getValue();
            
            Map<String, Double> values2 = attributes2.get(name1);
            if (values2 != null) {
                double attributeSimilarity = calculateAttributeValueSimilarity(values1, values2);
                totalSimilarity += attributeSimilarity;
                matchCount++;
            }
        }
        
        return matchCount > 0 ? totalSimilarity / matchCount : 0;
    }
    
    /**
     * Calculates the similarity between attribute values.
     * 
     * @param values1 The first set of attribute values
     * @param values2 The second set of attribute values
     * @return The similarity score (0-1)
     */
    private double calculateAttributeValueSimilarity(Map<String, Double> values1, Map<String, Double> values2) {
        if (values1.isEmpty() || values2.isEmpty()) {
            return 0;
        }
        
        double maxSimilarity = 0;
        
        for (Map.Entry<String, Double> entry1 : values1.entrySet()) {
            String value1 = entry1.getKey();
            double weight1 = entry1.getValue();
            
            // Check for exact match
            Double exactMatch = values2.get(value1);
            if (exactMatch != null) {
                double similarity = weight1 * exactMatch;
                maxSimilarity = Math.max(maxSimilarity, similarity);
                continue;
            }
            
            // Check for pattern match
            for (Map.Entry<String, Double> entry2 : values2.entrySet()) {
                String value2 = entry2.getKey();
                double weight2 = entry2.getValue();
                
                if (isPatternMatch(value1, value2)) {
                    double similarity = weight1 * weight2 * 0.8; // Slight penalty for pattern match
                    maxSimilarity = Math.max(maxSimilarity, similarity);
                }
            }
        }
        
        return maxSimilarity;
    }
    
    /**
     * Checks if a value matches a pattern.
     * 
     * @param value The value
     * @param pattern The pattern
     * @return True if the value matches the pattern, false otherwise
     */
    private boolean isPatternMatch(String value, String pattern) {
        // Treat patterns that start with ".*" and end with ".*" as contains matches
        if (pattern.startsWith(".*") && pattern.endsWith(".*")) {
            String substring = pattern.substring(2, pattern.length() - 2);
            return value.contains(substring);
        }
        
        // Treat patterns that start with ".*" as "endsWith" matches
        if (pattern.startsWith(".*")) {
            String suffix = pattern.substring(2);
            return value.endsWith(suffix);
        }
        
        // Treat patterns that end with ".*" as "startsWith" matches
        if (pattern.endsWith(".*")) {
            String prefix = pattern.substring(0, pattern.length() - 2);
            return value.startsWith(prefix);
        }
        
        // For other patterns, use regex matching
        try {
            return value.matches(pattern);
        } catch (Exception e) {
            // In case of invalid regex
            return false;
        }
    }
    
    /**
     * Calculates the similarity between class names.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculateClassNameSimilarity(ElementFeatures features1, ElementFeatures features2) {
        Map<String, Double> classes1 = features1.getClassNames();
        Map<String, Double> classes2 = features2.getClassNames();
        
        if (classes1.isEmpty() || classes2.isEmpty()) {
            return 0;
        }
        
        double totalSimilarity = 0;
        double totalWeight = 0;
        
        for (Map.Entry<String, Double> entry1 : classes1.entrySet()) {
            String className1 = entry1.getKey();
            double weight1 = entry1.getValue();
            totalWeight += weight1;
            
            Double weight2 = classes2.get(className1);
            if (weight2 != null) {
                totalSimilarity += weight1 * weight2;
                continue;
            }
            
            // Check for pattern matches in class patterns
            Map<String, Double> classPatterns = features2.getClassPatterns();
            for (Map.Entry<String, Double> patternEntry : classPatterns.entrySet()) {
                String pattern = patternEntry.getKey();
                double patternWeight = patternEntry.getValue();
                
                if (isPatternMatch(className1, pattern)) {
                    totalSimilarity += weight1 * patternWeight * 0.8; // Slight penalty for pattern match
                    break;
                }
            }
        }
        
        return totalWeight > 0 ? totalSimilarity / totalWeight : 0;
    }
    
    /**
     * Calculates the similarity between texts.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculateTextSimilarity(ElementFeatures features1, ElementFeatures features2) {
        String text1 = features1.getText();
        String text2 = features2.getText();
        
        double exactMatchScore = 0;
        if (text1 != null && text2 != null && !text1.isEmpty() && !text2.isEmpty()) {
            // Calculate exact match similarity
            if (text1.equalsIgnoreCase(text2)) {
                exactMatchScore = 1.0;
            } else {
                // Calculate Jaccard similarity for partial text match
                exactMatchScore = calculateJaccardSimilarity(text1, text2) * 0.7;
            }
        }
        
        // Calculate text pattern match similarity
        double patternMatchScore = calculateTextPatternSimilarity(features1, features2);
        
        // Return the higher of the two scores
        return Math.max(exactMatchScore, patternMatchScore);
    }
    
    /**
     * Calculates the Jaccard similarity between two texts.
     * 
     * @param text1 The first text
     * @param text2 The second text
     * @return The Jaccard similarity (0-1)
     */
    private double calculateJaccardSimilarity(String text1, String text2) {
        Set<String> words1 = splitIntoWords(text1);
        Set<String> words2 = splitIntoWords(text2);
        
        if (words1.isEmpty() && words2.isEmpty()) {
            return 1.0;
        }
        
        if (words1.isEmpty() || words2.isEmpty()) {
            return 0.0;
        }
        
        // Calculate intersection size
        int intersectionSize = 0;
        for (String word : words1) {
            if (words2.contains(word)) {
                intersectionSize++;
            }
        }
        
        // Calculate union size
        int unionSize = words1.size() + words2.size() - intersectionSize;
        
        return (double) intersectionSize / unionSize;
    }
    
    /**
     * Splits a text into words.
     * 
     * @param text The text
     * @return Set of words
     */
    private Set<String> splitIntoWords(String text) {
        Set<String> words = new HashSet<>();
        if (text == null || text.isEmpty()) {
            return words;
        }
        
        // Split by whitespace and punctuation
        String[] tokens = text.toLowerCase().split("\\s+|\\p{Punct}");
        for (String token : tokens) {
            if (!token.isEmpty()) {
                words.add(token);
            }
        }
        
        return words;
    }
    
    /**
     * Calculates the similarity between text patterns.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculateTextPatternSimilarity(ElementFeatures features1, ElementFeatures features2) {
        Map<String, Double> patterns1 = features1.getTextPatterns();
        Map<String, Double> patterns2 = features2.getTextPatterns();
        
        if (patterns1.isEmpty() || patterns2.isEmpty()) {
            return 0;
        }
        
        double totalSimilarity = 0;
        double totalWeight = 0;
        
        for (Map.Entry<String, Double> entry1 : patterns1.entrySet()) {
            String pattern1 = entry1.getKey();
            double weight1 = entry1.getValue();
            totalWeight += weight1;
            
            Double weight2 = patterns2.get(pattern1);
            if (weight2 != null) {
                totalSimilarity += weight1 * weight2;
                continue;
            }
            
            // Check for pattern matches
            String text = features2.getText();
            if (text != null && !text.isEmpty() && isPatternMatch(text, pattern1)) {
                totalSimilarity += weight1 * 0.8; // Slight penalty for pattern match
            }
        }
        
        return totalWeight > 0 ? totalSimilarity / totalWeight : 0;
    }
    
    /**
     * Calculates the similarity between contexts.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculateContextSimilarity(ElementFeatures features1, ElementFeatures features2) {
        // Calculate parent tag similarity
        double parentSimilarity = calculateParentTagSimilarity(features1, features2);
        
        // Calculate sibling tag similarity
        double siblingSimilarity = calculateSiblingTagSimilarity(features1, features2);
        
        // Calculate position similarity
        double positionSimilarity = calculatePositionSimilarity(features1, features2);
        
        // Weighted average
        return parentSimilarity * 0.5 + siblingSimilarity * 0.3 + positionSimilarity * 0.2;
    }
    
    /**
     * Calculates the similarity between parent tags.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculateParentTagSimilarity(ElementFeatures features1, ElementFeatures features2) {
        Map<String, Double> parents1 = features1.getParentTags();
        Map<String, Double> parents2 = features2.getParentTags();
        
        if (parents1.isEmpty() || parents2.isEmpty()) {
            return 0;
        }
        
        double totalSimilarity = 0;
        double totalWeight = 0;
        
        for (Map.Entry<String, Double> entry1 : parents1.entrySet()) {
            String parent1 = entry1.getKey();
            double weight1 = entry1.getValue();
            totalWeight += weight1;
            
            Double weight2 = parents2.get(parent1);
            if (weight2 != null) {
                totalSimilarity += weight1 * weight2;
            }
        }
        
        return totalWeight > 0 ? totalSimilarity / totalWeight : 0;
    }
    
    /**
     * Calculates the similarity between sibling tags.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculateSiblingTagSimilarity(ElementFeatures features1, ElementFeatures features2) {
        Map<String, Double> siblings1 = features1.getSiblingTags();
        Map<String, Double> siblings2 = features2.getSiblingTags();
        
        if (siblings1.isEmpty() || siblings2.isEmpty()) {
            return 0;
        }
        
        double totalSimilarity = 0;
        double totalWeight = 0;
        
        for (Map.Entry<String, Double> entry1 : siblings1.entrySet()) {
            String sibling1 = entry1.getKey();
            double weight1 = entry1.getValue();
            totalWeight += weight1;
            
            Double weight2 = siblings2.get(sibling1);
            if (weight2 != null) {
                totalSimilarity += weight1 * weight2;
            }
        }
        
        return totalWeight > 0 ? totalSimilarity / totalWeight : 0;
    }
    
    /**
     * Calculates the similarity between positions.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The similarity score (0-1)
     */
    private double calculatePositionSimilarity(ElementFeatures features1, ElementFeatures features2) {
        double similarity = 0;
        double count = 0;
        
        // Compare index
        Integer index1 = features1.getIndex();
        Integer index2 = features2.getIndex();
        if (index1 != null && index2 != null) {
            similarity += (index1.equals(index2)) ? 1.0 : 0.0;
            count++;
        }
        
        // Compare isFirst
        Boolean isFirst1 = features1.isFirst();
        Boolean isFirst2 = features2.isFirst();
        if (isFirst1 != null && isFirst2 != null) {
            similarity += (isFirst1.equals(isFirst2)) ? 1.0 : 0.0;
            count++;
        }
        
        // Compare isLast
        Boolean isLast1 = features1.isLast();
        Boolean isLast2 = features2.isLast();
        if (isLast1 != null && isLast2 != null) {
            similarity += (isLast1.equals(isLast2)) ? 1.0 : 0.0;
            count++;
        }
        
        return count > 0 ? similarity / count : 0;
    }
    
    /**
     * Merges two sets of element features.
     * 
     * @param features1 The first set of features
     * @param features2 The second set of features
     * @return The merged features
     */
    private ElementFeatures mergeFeatures(ElementFeatures features1, ElementFeatures features2) {
        ElementFeatures mergedFeatures = new ElementFeatures();
        
        // Merge tag names
        for (Map.Entry<String, Double> entry : features1.getTagNames().entrySet()) {
            mergedFeatures.addTagName(entry.getKey(), entry.getValue());
        }
        for (Map.Entry<String, Double> entry : features2.getTagNames().entrySet()) {
            double existingWeight = mergedFeatures.getTagNames().getOrDefault(entry.getKey(), 0.0);
            mergedFeatures.addTagName(entry.getKey(), Math.max(existingWeight, entry.getValue()));
        }
        
        // Merge attributes
        for (Map.Entry<String, Map<String, Double>> entry : features1.getAttributes().entrySet()) {
            String attrName = entry.getKey();
            for (Map.Entry<String, Double> valueEntry : entry.getValue().entrySet()) {
                mergedFeatures.addAttribute(attrName, valueEntry.getKey(), valueEntry.getValue());
            }
        }
        for (Map.Entry<String, Map<String, Double>> entry : features2.getAttributes().entrySet()) {
            String attrName = entry.getKey();
            for (Map.Entry<String, Double> valueEntry : entry.getValue().entrySet()) {
                double existingWeight = 0.0;
                Map<String, Double> existingValues = mergedFeatures.getAttributes().get(attrName);
                if (existingValues != null) {
                    existingWeight = existingValues.getOrDefault(valueEntry.getKey(), 0.0);
                }
                mergedFeatures.addAttribute(attrName, valueEntry.getKey(), 
                                          Math.max(existingWeight, valueEntry.getValue()));
            }
        }
        
        // Merge class names
        for (Map.Entry<String, Double> entry : features1.getClassNames().entrySet()) {
            mergedFeatures.addClassName(entry.getKey(), entry.getValue());
        }
        for (Map.Entry<String, Double> entry : features2.getClassNames().entrySet()) {
            double existingWeight = mergedFeatures.getClassNames().getOrDefault(entry.getKey(), 0.0);
            mergedFeatures.addClassName(entry.getKey(), Math.max(existingWeight, entry.getValue()));
        }
        
        // Merge class patterns
        for (Map.Entry<String, Double> entry : features1.getClassPatterns().entrySet()) {
            mergedFeatures.addClassPattern(entry.getKey(), entry.getValue());
        }
        for (Map.Entry<String, Double> entry : features2.getClassPatterns().entrySet()) {
            double existingWeight = mergedFeatures.getClassPatterns().getOrDefault(entry.getKey(), 0.0);
            mergedFeatures.addClassPattern(entry.getKey(), Math.max(existingWeight, entry.getValue()));
        }
        
        // Merge text patterns
        for (Map.Entry<String, Double> entry : features1.getTextPatterns().entrySet()) {
            mergedFeatures.addTextPattern(entry.getKey(), entry.getValue());
        }
        for (Map.Entry<String, Double> entry : features2.getTextPatterns().entrySet()) {
            double existingWeight = mergedFeatures.getTextPatterns().getOrDefault(entry.getKey(), 0.0);
            mergedFeatures.addTextPattern(entry.getKey(), Math.max(existingWeight, entry.getValue()));
        }
        
        // Merge parent tags
        for (Map.Entry<String, Double> entry : features1.getParentTags().entrySet()) {
            mergedFeatures.addParentTag(entry.getKey(), entry.getValue());
        }
        for (Map.Entry<String, Double> entry : features2.getParentTags().entrySet()) {
            double existingWeight = mergedFeatures.getParentTags().getOrDefault(entry.getKey(), 0.0);
            mergedFeatures.addParentTag(entry.getKey(), Math.max(existingWeight, entry.getValue()));
        }
        
        // Merge sibling tags
        for (Map.Entry<String, Double> entry : features1.getSiblingTags().entrySet()) {
            mergedFeatures.addSiblingTag(entry.getKey(), entry.getValue());
        }
        for (Map.Entry<String, Double> entry : features2.getSiblingTags().entrySet()) {
            double existingWeight = mergedFeatures.getSiblingTags().getOrDefault(entry.getKey(), 0.0);
            mergedFeatures.addSiblingTag(entry.getKey(), Math.max(existingWeight, entry.getValue()));
        }
        
        // Set other properties if not already set
        if (mergedFeatures.getText() == null && features1.getText() != null) {
            mergedFeatures.setText(features1.getText());
        } else if (mergedFeatures.getText() == null && features2.getText() != null) {
            mergedFeatures.setText(features2.getText());
        }
        
        if (mergedFeatures.getId() == null && features1.getId() != null) {
            mergedFeatures.setId(features1.getId());
        } else if (mergedFeatures.getId() == null && features2.getId() != null) {
            mergedFeatures.setId(features2.getId());
        }
        
        if (mergedFeatures.getIndex() == null && features1.getIndex() != null) {
            mergedFeatures.setIndex(features1.getIndex());
        } else if (mergedFeatures.getIndex() == null && features2.getIndex() != null) {
            mergedFeatures.setIndex(features2.getIndex());
        }
        
        if (mergedFeatures.isFirst() == null && features1.isFirst() != null) {
            mergedFeatures.setFirst(features1.isFirst());
        } else if (mergedFeatures.isFirst() == null && features2.isFirst() != null) {
            mergedFeatures.setFirst(features2.isFirst());
        }
        
        if (mergedFeatures.isLast() == null && features1.isLast() != null) {
            mergedFeatures.setLast(features1.isLast());
        } else if (mergedFeatures.isLast() == null && features2.isLast() != null) {
            mergedFeatures.setLast(features2.isLast());
        }
        
        if (features1.getBounds() != null) {
            mergedFeatures.setBounds(
                features1.getBounds().getX(),
                features1.getBounds().getY(),
                features1.getBounds().getWidth(),
                features1.getBounds().getHeight()
            );
        } else if (features2.getBounds() != null) {
            mergedFeatures.setBounds(
                features2.getBounds().getX(),
                features2.getBounds().getY(),
                features2.getBounds().getWidth(),
                features2.getBounds().getHeight()
            );
        }
        
        return mergedFeatures;
    }
    
    /**
     * Sorts a map by value in descending order.
     * 
     * @param map The map to sort
     * @return The sorted map
     */
    private <K, V extends Comparable<? super V>> Map<K, V> sortByValueDescending(Map<K, V> map) {
        return map.entrySet()
                 .stream()
                 .sorted(Map.Entry.<K, V>comparingByValue().reversed())
                 .collect(Collectors.toMap(
                     Map.Entry::getKey,
                     Map.Entry::getValue,
                     (e1, e2) -> e1,
                     LinkedHashMap::new
                 ));
    }
}

