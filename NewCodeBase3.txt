CSPlaywrightManager.java
-----------------------------------------

package com.cstestforge.framework.playwright.java.browser;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSConstants;
import com.microsoft.playwright.Browser;
import com.microsoft.playwright.BrowserType;
import com.microsoft.playwright.BrowserType.LaunchOptions;
import com.microsoft.playwright.Playwright;

import java.nio.file.Path;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Manages Playwright browser instances.
 * This class is responsible for creating, caching, and closing Playwright browser instances.
 * It implements thread-safe singleton pattern to ensure resource efficiency.
 */
public class CSPlaywrightManager {
    private static final CSLogger LOGGER = new CSLogger(CSPlaywrightManager.class);
    private static volatile CSPlaywrightManager instance;
    private static final ReentrantLock LOCK = new ReentrantLock();
    
    private final Map<String, Playwright> playwrightInstances = new ConcurrentHashMap<>();
    private final Map<BrowserKey, Browser> browserInstances = new ConcurrentHashMap<>();
    private final ConfigurationManager configManager;
    private final CSLaunchOptionsManager launchOptionsManager;
    
    /**
     * Private constructor to prevent direct instantiation.
     */
    private CSPlaywrightManager() {
        this.configManager = ConfigurationManager.getInstance();
        this.launchOptionsManager = new CSLaunchOptionsManager();
        LOGGER.info("CSPlaywrightManager initialized");
    }
    
    /**
     * Gets the singleton instance of CSPlaywrightManager.
     * 
     * @return The single instance of CSPlaywrightManager
     */
    public static CSPlaywrightManager getInstance() {
        if (instance == null) {
            LOCK.lock();
            try {
                if (instance == null) {
                    instance = new CSPlaywrightManager();
                }
            } finally {
                LOCK.unlock();
            }
        }
        return instance;
    }
    
    /**
     * Gets a Playwright instance, creating it if necessary.
     * 
     * @param sessionId The session identifier for the Playwright instance
     * @return A Playwright instance
     */
    public Playwright getPlaywright(String sessionId) {
        return playwrightInstances.computeIfAbsent(sessionId, id -> {
            LOGGER.info("Creating new Playwright instance for session: {}", id);
            return Playwright.create();
        });
    }
    
    /**
     * Launches a browser with the specified type and options.
     * 
     * @param browserType The type of browser to launch (chromium, firefox, webkit)
     * @param headless Whether to run in headless mode
     * @param sessionId The session identifier for the browser instance
     * @return The launched Browser instance
     */
    public Browser launchBrowser(String browserType, boolean headless, String sessionId) {
        return launchBrowser(browserType, headless, sessionId, null);
    }
    
    /**
     * Launches a browser with the specified type, options, and user data directory.
     * 
     * @param browserType The type of browser to launch (chromium, firefox, webkit)
     * @param headless Whether to run in headless mode
     * @param sessionId The session identifier for the browser instance
     * @param userDataDir The user data directory for persistent browser state
     * @return The launched Browser instance
     */
    public Browser launchBrowser(String browserType, boolean headless, String sessionId, String userDataDir) {
        LaunchOptions options = launchOptionsManager.createLaunchOptions(headless, userDataDir);
        BrowserKey key = new BrowserKey(browserType, sessionId, options);
        
        return browserInstances.computeIfAbsent(key, k -> {
            LOGGER.info("Launching {} browser for session: {}", browserType, sessionId);
            Playwright playwright = getPlaywright(sessionId);
            
            switch (browserType.toLowerCase()) {
                case CSConstants.BROWSER_CHROMIUM:
                    return playwright.chromium().launch(options);
                case CSConstants.BROWSER_FIREFOX:
                    return playwright.firefox().launch(options);
                case CSConstants.BROWSER_WEBKIT:
                    return playwright.webkit().launch(options);
                default:
                    LOGGER.warn("Unsupported browser type: {}. Defaulting to chromium.", browserType);
                    return playwright.chromium().launch(options);
            }
        });
    }
    
    /**
     * Closes the specified browser instance.
     * 
     * @param browser The browser instance to close
     * @param sessionId The session identifier for the browser instance
     */
    public void closeBrowser(Browser browser, String sessionId) {
        if (browser != null) {
            try {
                LOGGER.info("Closing browser for session: {}", sessionId);
                browser.close();
                
                // Remove from cache
                browserInstances.entrySet().removeIf(entry -> 
                    entry.getKey().sessionId.equals(sessionId) && 
                    entry.getValue().equals(browser)
                );
            } catch (Exception e) {
                LOGGER.error("Error closing browser: {}", e.getMessage(), e);
            }
        }
    }
    
    /**
     * Closes all browser instances for the specified session.
     * 
     * @param sessionId The session identifier
     */
    public void closeAllBrowsers(String sessionId) {
        LOGGER.info("Closing all browsers for session: {}", sessionId);
        
        // Close and remove browser instances
        browserInstances.entrySet().removeIf(entry -> {
            if (entry.getKey().sessionId.equals(sessionId)) {
                try {
                    entry.getValue().close();
                    return true;
                } catch (Exception e) {
                    LOGGER.error("Error closing browser: {}", e.getMessage(), e);
                }
            }
            return false;
        });
        
        // Close and remove Playwright instance
        Playwright playwright = playwrightInstances.remove(sessionId);
        if (playwright != null) {
            try {
                playwright.close();
            } catch (Exception e) {
                LOGGER.error("Error closing Playwright: {}", e.getMessage(), e);
            }
        }
    }
    
    /**
     * Closes all browser and Playwright instances.
     * This should be called during application shutdown.
     */
    public void closeAll() {
        LOGGER.info("Closing all browser and Playwright instances");
        
        // Close all browsers
        for (Browser browser : browserInstances.values()) {
            try {
                browser.close();
            } catch (Exception e) {
                LOGGER.error("Error closing browser: {}", e.getMessage(), e);
            }
        }
        browserInstances.clear();
        
        // Close all Playwright instances
        for (Playwright playwright : playwrightInstances.values()) {
            try {
                playwright.close();
            } catch (Exception e) {
                LOGGER.error("Error closing Playwright: {}", e.getMessage(), e);
            }
        }
        playwrightInstances.clear();
    }
    
    /**
     * Composite key for browser instances in the cache.
     */
    private static class BrowserKey {
        private final String browserType;
        private final String sessionId;
        private final LaunchOptions options;
        
        public BrowserKey(String browserType, String sessionId, LaunchOptions options) {
            this.browserType = browserType;
            this.sessionId = sessionId;
            this.options = options;
        }
        
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            
            BrowserKey that = (BrowserKey) o;
            
            if (!browserType.equals(that.browserType)) return false;
            if (!sessionId.equals(that.sessionId)) return false;
            
            // Compare important parts of launch options
            if (options.headless != that.options.headless) return false;
            if (options.channel != null ? !options.channel.equals(that.options.channel) : that.options.channel != null)
                return false;
            
            return true;
        }
        
        @Override
        public int hashCode() {
            int result = browserType.hashCode();
            result = 31 * result + sessionId.hashCode();
            result = 31 * result + (options.headless ? 1 : 0);
            result = 31 * result + (options.channel != null ? options.channel.hashCode() : 0);
            return result;
        }
    }
}


CSLaunchOptionsManager.java
--------------------------------------

package com.cstestforge.framework.playwright.java.browser;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.BrowserType.LaunchOptions;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * Manages browser launch options for Playwright.
 * This class provides methods to create and customize launch options for different browsers.
 */
public class CSLaunchOptionsManager {
    private static final CSLogger LOGGER = new CSLogger(CSLaunchOptionsManager.class);
    private final ConfigurationManager configManager;
    
    /**
     * Constructs a new CSLaunchOptionsManager.
     */
    public CSLaunchOptionsManager() {
        this.configManager = ConfigurationManager.getInstance();
        LOGGER.info("CSLaunchOptionsManager initialized");
    }
    
    /**
     * Creates launch options with the specified headless setting.
     * 
     * @param headless Whether to run in headless mode
     * @return The configured launch options
     */
    public LaunchOptions createLaunchOptions(boolean headless) {
        return createLaunchOptions(headless, null);
    }
    
    /**
     * Creates launch options with the specified headless setting and user data directory.
     * 
     * @param headless Whether to run in headless mode
     * @param userDataDir The user data directory for persistent browser state
     * @return The configured launch options
     */
    public LaunchOptions createLaunchOptions(boolean headless, String userDataDir) {
        LaunchOptions options = new LaunchOptions();
        
        // Set headless mode
        options.headless = headless;
        
        // Set timeout
        options.timeout = getTimeoutFromConfig();
        
        // Set user data directory if specified
        if (userDataDir != null && !userDataDir.isEmpty()) {
            options.userDataDir = Paths.get(userDataDir);
        }
        
        // Set default args based on config
        options.args = getDefaultArgsFromConfig();
        
        // Set environment variables
        options.env = getEnvironmentVariablesFromConfig();
        
        // Set download path from config
        String downloadPath = getDownloadPathFromConfig();
        if (downloadPath != null && !downloadPath.isEmpty()) {
            if (options.env == null) {
                options.env = new HashMap<>();
            }
            options.env.put("PLAYWRIGHT_DOWNLOAD_PATH", downloadPath);
        }
        
        // Set proxy if configured
        setProxyFromConfig(options);
        
        // Set channel if configured (for Chrome/Edge)
        String channel = getBrowserChannelFromConfig();
        if (channel != null && !channel.isEmpty()) {
            options.channel = channel;
        }
        
        // Set slow motion if configured (useful for debugging)
        options.slowMo = getSlowMotionFromConfig();
        
        // Set ignore HTTPS errors if configured
        options.ignoreDefaultArgs = getIgnoreDefaultArgsFromConfig();
        options.ignoreHTTPSErrors = getIgnoreHttpsErrorsFromConfig();
        
        return options;
    }
    
    /**
     * Gets the browser launch timeout from configuration.
     * 
     * @return The timeout in milliseconds
     */
    private int getTimeoutFromConfig() {
        try {
            return configManager.getInt("playwright.browser.timeout", 30000);
        } catch (Exception e) {
            LOGGER.warn("Error getting timeout from config, using default: {}", e.getMessage());
            return 30000;
        }
    }
    
    /**
     * Gets the default browser arguments from configuration.
     * 
     * @return The list of browser arguments
     */
    private List<String> getDefaultArgsFromConfig() {
        try {
            String argsStr = configManager.getString("playwright.browser.args", "");
            if (argsStr.isEmpty()) {
                return getCommonBrowserArgs();
            }
            
            List<String> args = new ArrayList<>(Arrays.asList(argsStr.split(",")));
            args.addAll(getCommonBrowserArgs());
            return args;
        } catch (Exception e) {
            LOGGER.warn("Error getting args from config, using defaults: {}", e.getMessage());
            return getCommonBrowserArgs();
        }
    }
    
    /**
     * Gets common browser arguments that improve stability and performance.
     * 
     * @return List of common browser arguments
     */
    private List<String> getCommonBrowserArgs() {
        return Arrays.asList(
            "--disable-dev-shm-usage",
            "--no-sandbox",
            "--disable-setuid-sandbox",
            "--disable-gpu",
            "--disable-web-security",
            "--disable-features=IsolateOrigins,site-per-process"
        );
    }
    
    /**
     * Gets environment variables from configuration.
     * 
     * @return The map of environment variables
     */
    private Map<String, String> getEnvironmentVariablesFromConfig() {
        try {
            String envStr = configManager.getString("playwright.browser.env", "");
            if (envStr.isEmpty()) {
                return null;
            }
            
            Map<String, String> env = new HashMap<>();
            String[] pairs = envStr.split(",");
            for (String pair : pairs) {
                String[] keyValue = pair.split("=", 2);
                if (keyValue.length == 2) {
                    env.put(keyValue[0].trim(), keyValue[1].trim());
                }
            }
            return env;
        } catch (Exception e) {
            LOGGER.warn("Error getting environment variables from config: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Gets the download path from configuration.
     * 
     * @return The download path
     */
    private String getDownloadPathFromConfig() {
        try {
            return configManager.getString("playwright.browser.download.path", "");
        } catch (Exception e) {
            LOGGER.warn("Error getting download path from config: {}", e.getMessage());
            return "";
        }
    }
    
    /**
     * Sets proxy settings from configuration.
     * 
     * @param options The launch options to configure
     */
    private void setProxyFromConfig(LaunchOptions options) {
        try {
            String proxyServer = configManager.getString("playwright.proxy.server", "");
            if (!proxyServer.isEmpty()) {
                options.proxy = new LaunchOptions.Proxy();
                options.proxy.server = proxyServer;
                
                String proxyUsername = configManager.getString("playwright.proxy.username", "");
                String proxyPassword = configManager.getString("playwright.proxy.password", "");
                if (!proxyUsername.isEmpty() && !proxyPassword.isEmpty()) {
                    options.proxy.username = proxyUsername;
                    options.proxy.password = proxyPassword;
                }
                
                String proxyBypass = configManager.getString("playwright.proxy.bypass", "");
                if (!proxyBypass.isEmpty()) {
                    options.proxy.bypass = proxyBypass;
                }
            }
        } catch (Exception e) {
            LOGGER.warn("Error setting proxy from config: {}", e.getMessage());
        }
    }
    
    /**
     * Gets the browser channel from configuration (stable, beta, dev, etc).
     * 
     * @return The browser channel
     */
    private String getBrowserChannelFromConfig() {
        try {
            return configManager.getString("playwright.browser.channel", "");
        } catch (Exception e) {
            LOGGER.warn("Error getting browser channel from config: {}", e.getMessage());
            return "";
        }
    }
    
    /**
     * Gets the slow motion delay from configuration (useful for debugging).
     * 
     * @return The slow motion delay in milliseconds
     */
    private int getSlowMotionFromConfig() {
        try {
            return configManager.getInt("playwright.browser.slowMo", 0);
        } catch (Exception e) {
            LOGGER.warn("Error getting slow motion delay from config: {}", e.getMessage());
            return 0;
        }
    }
    
    /**
     * Gets the list of default arguments to ignore from configuration.
     * 
     * @return The list of arguments to ignore
     */
    private List<String> getIgnoreDefaultArgsFromConfig() {
        try {
            String ignoreArgsStr = configManager.getString("playwright.browser.ignoreDefaultArgs", "");
            if (ignoreArgsStr.isEmpty()) {
                return null;
            }
            
            return Arrays.asList(ignoreArgsStr.split(","));
        } catch (Exception e) {
            LOGGER.warn("Error getting ignore default args from config: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Gets whether to ignore HTTPS errors from configuration.
     * 
     * @return True if HTTPS errors should be ignored, false otherwise
     */
    private boolean getIgnoreHttpsErrorsFromConfig() {
        try {
            return configManager.getBoolean("playwright.browser.ignoreHttpsErrors", false);
        } catch (Exception e) {
            LOGGER.warn("Error getting ignore HTTPS errors from config: {}", e.getMessage());
            return false;
        }
    }
}



CSBrowserContextManager.java
----------------------------------------------

package com.cstestforge.framework.playwright.java.browser;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.Browser;
import com.microsoft.playwright.BrowserContext;
import com.microsoft.playwright.Browser.NewContextOptions;
import com.microsoft.playwright.options.Geolocation;
import com.microsoft.playwright.options.HttpCredentials;
import com.microsoft.playwright.options.ViewportSize;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Manages browser contexts for Playwright.
 * This class is responsible for creating, caching, and closing browser contexts.
 */
public class CSBrowserContextManager {
    private static final CSLogger LOGGER = new CSLogger(CSBrowserContextManager.class);
    private final Map<String, BrowserContext> contextCache = new ConcurrentHashMap<>();
    private final ConfigurationManager configManager;
    
    /**
     * Constructs a new CSBrowserContextManager.
     */
    public CSBrowserContextManager() {
        this.configManager = ConfigurationManager.getInstance();
        LOGGER.info("CSBrowserContextManager initialized");
    }
    
    /**
     * Creates a new browser context with default options.
     * 
     * @param browser The browser instance
     * @param contextId The context identifier
     * @return The created browser context
     */
    public BrowserContext createContext(Browser browser, String contextId) {
        return createContext(browser, contextId, new NewContextOptions());
    }
    
    /**
     * Creates a new browser context with the specified options.
     * 
     * @param browser The browser instance
     * @param contextId The context identifier
     * @param options The browser context options
     * @return The created browser context
     */
    public BrowserContext createContext(Browser browser, String contextId, NewContextOptions options) {
        if (contextCache.containsKey(contextId)) {
            LOGGER.info("Returning existing browser context for id: {}", contextId);
            return contextCache.get(contextId);
        }
        
        LOGGER.info("Creating new browser context with id: {}", contextId);
        applyDefaultOptions(options);
        
        BrowserContext context = browser.newContext(options);
        configureContext(context);
        contextCache.put(contextId, context);
        
        return context;
    }
    
    /**
     * Creates a browser context from a stored browser state.
     * 
     * @param browser The browser instance
     * @param contextId The context identifier
     * @param statePath The path to the stored browser state
     * @return The created browser context
     */
    public BrowserContext createContextFromStoredState(Browser browser, String contextId, String statePath) {
        if (contextCache.containsKey(contextId)) {
            LOGGER.info("Returning existing browser context for id: {}", contextId);
            return contextCache.get(contextId);
        }
        
        LOGGER.info("Creating new browser context from stored state with id: {}", contextId);
        NewContextOptions options = new NewContextOptions();
        applyDefaultOptions(options);
        
        // Set stored state path
        options.storageStatePath = Paths.get(statePath);
        
        BrowserContext context = browser.newContext(options);
        configureContext(context);
        contextCache.put(contextId, context);
        
        return context;
    }
    
    /**
     * Gets a browser context by its identifier.
     * 
     * @param contextId The context identifier
     * @return The browser context, or null if not found
     */
    public BrowserContext getContext(String contextId) {
        return contextCache.get(contextId);
    }
    
    /**
     * Closes a browser context and removes it from the cache.
     * 
     * @param contextId The context identifier
     */
    public void closeContext(String contextId) {
        BrowserContext context = contextCache.remove(contextId);
        if (context != null) {
            try {
                LOGGER.info("Closing browser context with id: {}", contextId);
                context.close();
            } catch (Exception e) {
                LOGGER.error("Error closing browser context: {}", e.getMessage(), e);
            }
        }
    }
    
    /**
     * Closes all browser contexts in the cache.
     */
    public void closeAllContexts() {
        LOGGER.info("Closing all browser contexts");
        for (Map.Entry<String, BrowserContext> entry : contextCache.entrySet()) {
            try {
                LOGGER.info("Closing browser context with id: {}", entry.getKey());
                entry.getValue().close();
            } catch (Exception e) {
                LOGGER.error("Error closing browser context: {}", e.getMessage(), e);
            }
        }
        contextCache.clear();
    }
    
    /**
     * Applies default options to browser context options.
     * 
     * @param options The options to configure
     */
    private void applyDefaultOptions(NewContextOptions options) {
        // Set viewport size
        options.viewport = getViewportSizeFromConfig();
        
        // Set geolocation if configured
        Geolocation geo = getGeolocationFromConfig();
        if (geo != null) {
            options.geolocation = geo;
            options.permissions = Arrays.asList("geolocation");
        }
        
        // Set user agent if configured
        String userAgent = getUserAgentFromConfig();
        if (userAgent != null && !userAgent.isEmpty()) {
            options.userAgent = userAgent;
        }
        
        // Set locale and timezone if configured
        String locale = getLocaleFromConfig();
        if (locale != null && !locale.isEmpty()) {
            options.locale = locale;
        }
        
        String timezone = getTimezoneFromConfig();
        if (timezone != null && !timezone.isEmpty()) {
            options.timezoneId = timezone;
        }
        
        // Set HTTP credentials if configured
        HttpCredentials credentials = getHttpCredentialsFromConfig();
        if (credentials != null) {
            options.httpCredentials = credentials;
        }
        
        // Configure offline mode if needed
        options.offline = getOfflineModeFromConfig();
        
        // Set ignore HTTPS errors if configured
        options.ignoreHTTPSErrors = getIgnoreHttpsErrorsFromConfig();
        
        // Set device scale factor if configured
        Double deviceScaleFactor = getDeviceScaleFactorFromConfig();
        if (deviceScaleFactor != null) {
            options.deviceScaleFactor = deviceScaleFactor;
        }
        
        // Set has touch if configured
        options.hasTouch = getHasTouchFromConfig();
        
        // Set color scheme if configured
        String colorScheme = getColorSchemeFromConfig();
        if (colorScheme != null && !colorScheme.isEmpty()) {
            options.colorScheme = colorScheme;
        }
        
        // Set reduced motion if configured
        String reducedMotion = getReducedMotionFromConfig();
        if (reducedMotion != null && !reducedMotion.isEmpty()) {
            options.reducedMotion = reducedMotion;
        }
        
        // Set forced colors if configured
        String forcedColors = getForcedColorsFromConfig();
        if (forcedColors != null && !forcedColors.isEmpty()) {
            options.forcedColors = forcedColors;
        }
        
        // Set record video if configured
        String recordVideoDir = getRecordVideoDirFromConfig();
        if (recordVideoDir != null && !recordVideoDir.isEmpty()) {
            options.recordVideo = new Browser.RecordVideoOptions()
                .setDir(Paths.get(recordVideoDir))
                .setSize(getRecordVideoSizeFromConfig());
        }
    }
    
    /**
     * Configures a browser context after creation.
     * 
     * @param context The browser context to configure
     */
    private void configureContext(BrowserContext context) {
        // Set request interception if configured
        boolean interceptRequests = getInterceptRequestsFromConfig();
        if (interceptRequests) {
            context.route("**/*", route -> {
                // Implementation will be part of the request interception service
                route.resume();
            });
        }
        
        // Set default navigation timeout
        int navigationTimeout = getNavigationTimeoutFromConfig();
        if (navigationTimeout > 0) {
            context.setDefaultNavigationTimeout(navigationTimeout);
        }
        
        // Set default timeout
        int timeout = getTimeoutFromConfig();
        if (timeout > 0) {
            context.setDefaultTimeout(timeout);
        }
    }
    
    /**
     * Gets the viewport size from configuration.
     * 
     * @return The configured viewport size
     */
    private ViewportSize getViewportSizeFromConfig() {
        try {
            int width = configManager.getInt("playwright.context.viewport.width", 1280);
            int height = configManager.getInt("playwright.context.viewport.height", 720);
            return new ViewportSize(width, height);
        } catch (Exception e) {
            LOGGER.warn("Error getting viewport size from config, using default: {}", e.getMessage());
            return new ViewportSize(1280, 720);
        }
    }
    
    /**
     * Gets the geolocation from configuration.
     * 
     * @return The configured geolocation, or null if not configured
     */
    private Geolocation getGeolocationFromConfig() {
        try {
            String geoStr = configManager.getString("playwright.context.geolocation", "");
            if (geoStr.isEmpty()) {
                return null;
            }
            
            String[] parts = geoStr.split(",");
            if (parts.length >= 2) {
                double latitude = Double.parseDouble(parts[0].trim());
                double longitude = Double.parseDouble(parts[1].trim());
                Double accuracy = parts.length > 2 ? Double.parseDouble(parts[2].trim()) : null;
                
                return new Geolocation(latitude, longitude, accuracy);
            }
            return null;
        } catch (Exception e) {
            LOGGER.warn("Error getting geolocation from config: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Gets the user agent from configuration.
     * 
     * @return The configured user agent
     */
    private String getUserAgentFromConfig() {
        try {
            return configManager.getString("playwright.context.userAgent", "");
        } catch (Exception e) {
            LOGGER.warn("Error getting user agent from config: {}", e.getMessage());
            return "";
        }
    }
    
    /**
     * Gets the locale from configuration.
     * 
     * @return The configured locale
     */
    private String getLocaleFromConfig() {
        try {
            return configManager.getString("playwright.context.locale", "en-US");
        } catch (Exception e) {
            LOGGER.warn("Error getting locale from config, using default: {}", e.getMessage());
            return "en-US";
        }
    }
    
    /**
     * Gets the timezone from configuration.
     * 
     * @return The configured timezone
     */
    private String getTimezoneFromConfig() {
        try {
            return configManager.getString("playwright.context.timezone", "UTC");
        } catch (Exception e) {
            LOGGER.warn("Error getting timezone from config, using default: {}", e.getMessage());
            return "UTC";
        }
    }
    
    /**
     * Gets the HTTP credentials from configuration.
     * 
     * @return The configured HTTP credentials, or null if not configured
     */
    private HttpCredentials getHttpCredentialsFromConfig() {
        try {
            String username = configManager.getString("playwright.context.auth.username", "");
            String password = configManager.getString("playwright.context.auth.password", "");
            
            if (!username.isEmpty() && !password.isEmpty()) {
                return new HttpCredentials(username, password);
            }
            return null;
        } catch (Exception e) {
            LOGGER.warn("Error getting HTTP credentials from config: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Gets whether offline mode is enabled from configuration.
     * 
     * @return True if offline mode is enabled, false otherwise
     */
    private boolean getOfflineModeFromConfig() {
        try {
            return configManager.getBoolean("playwright.context.offline", false);
        } catch (Exception e) {
            LOGGER.warn("Error getting offline mode from config: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Gets whether to ignore HTTPS errors from configuration.
     * 
     * @return True if HTTPS errors should be ignored, false otherwise
     */
    private boolean getIgnoreHttpsErrorsFromConfig() {
        try {
            return configManager.getBoolean("playwright.context.ignoreHttpsErrors", false);
        } catch (Exception e) {
            LOGGER.warn("Error getting ignore HTTPS errors from config: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Gets the device scale factor from configuration.
     * 
     * @return The configured device scale factor, or null if not configured
     */
    private Double getDeviceScaleFactorFromConfig() {
        try {
            double factor = configManager.getDouble("playwright.context.deviceScaleFactor", -1);
            return factor > 0 ? factor : null;
        } catch (Exception e) {
            LOGGER.warn("Error getting device scale factor from config: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Gets whether touch is enabled from configuration.
     * 
     * @return True if touch is enabled, false otherwise
     */
    private boolean getHasTouchFromConfig() {
        try {
            return configManager.getBoolean("playwright.context.hasTouch", false);
        } catch (Exception e) {
            LOGGER.warn("Error getting has touch from config: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Gets the color scheme from configuration.
     * 
     * @return The configured color scheme
     */
    private String getColorSchemeFromConfig() {
        try {
            return configManager.getString("playwright.context.colorScheme", "");
        } catch (Exception e) {
            LOGGER.warn("Error getting color scheme from config: {}", e.getMessage());
            return "";
        }
    }
    
    /**
     * Gets the reduced motion setting from configuration.
     * 
     * @return The configured reduced motion setting
     */
    private String getReducedMotionFromConfig() {
        try {
            return configManager.getString("playwright.context.reducedMotion", "");
        } catch (Exception e) {
            LOGGER.warn("Error getting reduced motion from config: {}", e.getMessage());
            return "";
        }
    }
    
    /**
     * Gets the forced colors setting from configuration.
     * 
     * @return The configured forced colors setting
     */
    private String getForcedColorsFromConfig() {
        try {
            return configManager.getString("playwright.context.forcedColors", "");
        } catch (Exception e) {
            LOGGER.warn("Error getting forced colors from config: {}", e.getMessage());
            return "";
        }
    }
    
    /**
     * Gets the record video directory from configuration.
     * 
     * @return The configured record video directory
     */
    private String getRecordVideoDirFromConfig() {
        try {
            return configManager.getString("playwright.context.recordVideo.dir", "");
        } catch (Exception e) {
            LOGGER.warn("Error getting record video directory from config: {}", e.getMessage());
            return "";
        }
    }
    
    /**
     * Gets the record video size from configuration.
     * 
     * @return The configured record video size
     */
    private ViewportSize getRecordVideoSizeFromConfig() {
        try {
            int width = configManager.getInt("playwright.context.recordVideo.width", 1280);
            int height = configManager.getInt("playwright.context.recordVideo.height", 720);
            return new ViewportSize(width, height);
        } catch (Exception e) {
            LOGGER.warn("Error getting record video size from config, using default: {}", e.getMessage());
            return new ViewportSize(1280, 720);
        }
    }
    
    /**
     * Gets whether to intercept requests from configuration.
     * 
     * @return True if requests should be intercepted, false otherwise
     */
    private boolean getInterceptRequestsFromConfig() {
        try {
            return configManager.getBoolean("playwright.context.interceptRequests", false);
        } catch (Exception e) {
            LOGGER.warn("Error getting intercept requests from config: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Gets the navigation timeout from configuration.
     * 
     * @return The configured navigation timeout in milliseconds
     */
    private int getNavigationTimeoutFromConfig() {
        try {
            return configManager.getInt("playwright.context.navigationTimeout", 30000);
        } catch (Exception e) {
            LOGGER.warn("Error getting navigation timeout from config, using default: {}", e.getMessage());
            return 30000;
        }
    }
    
    /**
     * Gets the timeout from configuration.
     * 
     * @return The configured timeout in milliseconds
     */
    private int getTimeoutFromConfig() {
        try {
            return configManager.getInt("playwright.context.timeout", 30000);
        } catch (Exception e) {
            LOGGER.warn("Error getting timeout from config, using default: {}", e.getMessage());
            return 30000;
        }
    }
}


CSPageManager.java
-----------------------------

package com.cstestforge.framework.playwright.java.browser;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.BrowserContext;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.LoadState;
import com.microsoft.playwright.options.WaitForSelectorOptions;
import com.microsoft.playwright.options.WaitUntilState;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

/**
 * Manages Playwright pages.
 * This class is responsible for creating, tracking, and closing Playwright pages.
 */
public class CSPageManager {
    private static final CSLogger LOGGER = new CSLogger(CSPageManager.class);
    private final Map<String, List<Page>> pagesByContextId = new ConcurrentHashMap<>();
    private final Map<String, Page> pagesById = new ConcurrentHashMap<>();
    private final ConfigurationManager configManager;
    
    /**
     * Constructs a new CSPageManager.
     */
    public CSPageManager() {
        this.configManager = ConfigurationManager.getInstance();
        LOGGER.info("CSPageManager initialized");
    }
    
    /**
     * Creates a new page in the specified browser context.
     * 
     * @param context The browser context
     * @param contextId The context identifier
     * @return The created page
     */
    public Page createPage(BrowserContext context, String contextId) {
        return createPage(context, contextId, null);
    }
    
    /**
     * Creates a new page in the specified browser context with a unique page ID.
     * 
     * @param context The browser context
     * @param contextId The context identifier
     * @param pageId The page identifier (optional)
     * @return The created page
     */
    public Page createPage(BrowserContext context, String contextId, String pageId) {
        LOGGER.info("Creating new page in context: {}", contextId);
        Page page = context.newPage();
        
        // Configure page settings
        configurePage(page);
        
        // Generate page ID if not provided
        if (pageId == null || pageId.isEmpty()) {
            pageId = contextId + "_page_" + System.currentTimeMillis();
        }
        
        // Cache the page
        pagesById.put(pageId, page);
        pagesByContextId.computeIfAbsent(contextId, k -> new ArrayList<>()).add(page);
        
        return page;
    }
    
    /**
     * Navigates to a URL using the specified page.
     * 
     * @param page The page to navigate
     * @param url The URL to navigate to
     * @return The page after navigation
     */
    public Page navigateTo(Page page, String url) {
        return navigateTo(page, url, null);
    }
    
    /**
     * Navigates to a URL using the specified page with custom options.
     * 
     * @param page The page to navigate
     * @param url The URL to navigate to
     * @param waitUntil The wait until state for navigation
     * @return The page after navigation
     */
    public Page navigateTo(Page page, String url, WaitUntilState waitUntil) {
        try {
            LOGGER.info("Navigating to URL: {}", url);
            
            if (waitUntil == null) {
                waitUntil = getDefaultWaitUntilStateFromConfig();
            }
            
            int timeout = getNavigationTimeoutFromConfig();
            
            page.navigate(url, new Page.NavigateOptions()
                .setWaitUntil(waitUntil)
                .setTimeout(timeout));
            
            // Wait for page to be fully loaded based on load state from config
            waitForLoadState(page);
            
            return page;
        } catch (Exception e) {
            LOGGER.error("Error navigating to URL: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets a page by its identifier.
     * 
     * @param pageId The page identifier
     * @return The page, or null if not found
     */
    public Page getPage(String pageId) {
        return pagesById.get(pageId);
    }
    
    /**
     * Gets all pages for a specific context.
     * 
     * @param contextId The context identifier
     * @return The list of pages for the context
     */
    public List<Page> getPagesByContext(String contextId) {
        return pagesByContextId.getOrDefault(contextId, new ArrayList<>());
    }
    
    /**
     * Closes a page by its identifier.
     * 
     * @param pageId The page identifier
     */
    public void closePage(String pageId) {
        Page page = pagesById.remove(pageId);
        if (page != null) {
            try {
                LOGGER.info("Closing page with id: {}", pageId);
                page.close();
                
                // Remove from context list
                for (List<Page> pages : pagesByContextId.values()) {
                    pages.remove(page);
                }
            } catch (Exception e) {
                LOGGER.error("Error closing page: {}", e.getMessage(), e);
            }
        }
    }
    
    /**
     * Closes all pages for a specific context.
     * 
     * @param contextId The context identifier
     */
    public void closeAllPagesForContext(String contextId) {
        List<Page> pages = pagesByContextId.remove(contextId);
        if (pages != null) {
            LOGGER.info("Closing all pages for context with id: {}", contextId);
            for (Page page : pages) {
                try {
                    page.close();
                    
                    // Remove from pages by ID map
                    pagesById.entrySet().removeIf(entry -> entry.getValue().equals(page));
                } catch (Exception e) {
                    LOGGER.error("Error closing page: {}", e.getMessage(), e);
                }
            }
        }
    }
    
    /**
     * Closes all pages.
     */
    public void closeAllPages() {
        LOGGER.info("Closing all pages");
        
        for (Page page : pagesById.values()) {
            try {
                page.close();
            } catch (Exception e) {
                LOGGER.error("Error closing page: {}", e.getMessage(), e);
            }
        }
        
        pagesById.clear();
        pagesByContextId.clear();
    }
    
    /**
     * Refreshes a page.
     * 
     * @param page The page to refresh
     * @return The refreshed page
     */
    public Page refreshPage(Page page) {
        try {
            LOGGER.info("Refreshing page");
            
            WaitUntilState waitUntil = getDefaultWaitUntilStateFromConfig();
            int timeout = getNavigationTimeoutFromConfig();
            
            page.reload(new Page.ReloadOptions()
                .setWaitUntil(waitUntil)
                .setTimeout(timeout));
            
            // Wait for page to be fully loaded based on load state from config
            waitForLoadState(page);
            
            return page;
        } catch (Exception e) {
            LOGGER.error("Error refreshing page: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Goes back in browser history.
     * 
     * @param page The page to navigate
     * @return The page after navigation
     */
    public Page goBack(Page page) {
        try {
            LOGGER.info("Navigating back");
            
            WaitUntilState waitUntil = getDefaultWaitUntilStateFromConfig();
            int timeout = getNavigationTimeoutFromConfig();
            
            page.goBack(new Page.GoBackOptions()
                .setWaitUntil(waitUntil)
                .setTimeout(timeout));
            
            // Wait for page to be fully loaded based on load state from config
            waitForLoadState(page);
            
            return page;
        } catch (Exception e) {
            LOGGER.error("Error navigating back: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Goes forward in browser history.
     * 
     * @param page The page to navigate
     * @return The page after navigation
     */
    public Page goForward(Page page) {
        try {
            LOGGER.info("Navigating forward");
            
            WaitUntilState waitUntil = getDefaultWaitUntilStateFromConfig();
            int timeout = getNavigationTimeoutFromConfig();
            
            page.goForward(new Page.GoForwardOptions()
                .setWaitUntil(waitUntil)
                .setTimeout(timeout));
            
            // Wait for page to be fully loaded based on load state from config
            waitForLoadState(page);
            
            return page;
        } catch (Exception e) {
            LOGGER.error("Error navigating forward: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Takes a screenshot of the page.
     * 
     * @param page The page to screenshot
     * @param path The path to save the screenshot
     * @param fullPage Whether to take a screenshot of the full page
     */
    public void takeScreenshot(Page page, String path, boolean fullPage) {
        try {
            LOGGER.info("Taking screenshot: {}", path);
            page.screenshot(new Page.ScreenshotOptions()
                .setPath(java.nio.file.Paths.get(path))
                .setFullPage(fullPage)
                .setType("png")
                .setQuality(90)
                .setOmitBackground(false));
        } catch (Exception e) {
            LOGGER.error("Error taking screenshot: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Sets up page event handlers.
     * 
     * @param page The page to configure
     * @param onPageError Consumer for page errors
     * @param onConsoleMessage Consumer for console messages
     * @param onDialog Consumer for dialogs
     * @param onNavigation Consumer for navigation events
     */
    public void setupPageEventHandlers(
            Page page,
            Consumer<String> onPageError,
            Consumer<String> onConsoleMessage,
            Consumer<Page.Dialog> onDialog,
            Consumer<String> onNavigation) {
        
        if (onPageError != null) {
            page.onPageError(exception -> {
                LOGGER.error("Page error: {}", exception);
                onPageError.accept(exception);
            });
        }
        
        if (onConsoleMessage != null) {
            page.onConsoleMessage(message -> {
                LOGGER.debug("Console message: {} [{}]", message.text(), message.type());
                onConsoleMessage.accept(message.text());
            });
        }
        
        if (onDialog != null) {
            page.onDialog(dialog -> {
                LOGGER.info("Dialog: {} [{}]", dialog.message(), dialog.type());
                onDialog.accept(dialog);
            });
        }
        
        if (onNavigation != null) {
            page.onRequest(request -> {
                if (request.isNavigationRequest()) {
                    LOGGER.info("Navigation request: {}", request.url());
                    onNavigation.accept(request.url());
                }
            });
        }
    }
    
    /**
     * Waits for the page to reach a specific load state.
     * 
     * @param page The page to wait for
     */
    public void waitForLoadState(Page page) {
        try {
            String loadState = getLoadStateFromConfig();
            int timeout = getLoadStateTimeoutFromConfig();
            
            LOGGER.debug("Waiting for load state: {}", loadState);
            switch (loadState.toLowerCase()) {
                case "domcontentloaded":
                    page.waitForLoadState(LoadState.DOMCONTENTLOADED, 
                                         new Page.WaitForLoadStateOptions().setTimeout(timeout));
                    break;
                case "load":
                    page.waitForLoadState(LoadState.LOAD, 
                                         new Page.WaitForLoadStateOptions().setTimeout(timeout));
                    break;
                case "networkidle":
                    page.waitForLoadState(LoadState.NETWORKIDLE, 
                                         new Page.WaitForLoadStateOptions().setTimeout(timeout));
                    break;
                default:
                    LOGGER.warn("Unknown load state: {}, using LOAD", loadState);
                    page.waitForLoadState(LoadState.LOAD, 
                                         new Page.WaitForLoadStateOptions().setTimeout(timeout));
            }
        } catch (Exception e) {
            LOGGER.error("Error waiting for load state: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Configures a page after creation.
     * 
     * @param page The page to configure
     */
    private void configurePage(Page page) {
        // Set default navigation timeout
        int navigationTimeout = getNavigationTimeoutFromConfig();
        if (navigationTimeout > 0) {
            page.setDefaultNavigationTimeout(navigationTimeout);
        }
        
        // Set default timeout
        int timeout = getTimeoutFromConfig();
        if (timeout > 0) {
            page.setDefaultTimeout(timeout);
        }
        
        // Configure auto-wait behavior
        setupPageAutoWait(page);
        
        // Apply JavaScript on new page
        applyInitialJavaScript(page);
        
        // Setup basic error handling
        page.onPageError(error -> {
            LOGGER.error("Page error: {}", error);
        });
    }
    
    /**
     * Sets up auto-wait behavior for the page.
     * 
     * @param page The page to configure
     */
    private void setupPageAutoWait(Page page) {
        String autoWait = getAutoWaitFromConfig();
        if ("enabled".equalsIgnoreCase(autoWait)) {
            // Enable auto-waiting for all actions
            page.setDefaultTimeout(getTimeoutFromConfig());
        }
    }
    
    /**
     * Applies initial JavaScript to the page.
     * 
     * @param page The page to configure
     */
    private void applyInitialJavaScript(Page page) {
        String initialScript = getInitialScriptFromConfig();
        if (initialScript != null && !initialScript.isEmpty()) {
            try {
                page.addInitScript(initialScript);
            } catch (Exception e) {
                LOGGER.error("Error applying initial JavaScript: {}", e.getMessage(), e);
            }
        }
    }
    
    /**
     * Gets the default wait until state from configuration.
     * 
     * @return The configured wait until state
     */
    private WaitUntilState getDefaultWaitUntilStateFromConfig() {
        try {
            String waitUntil = configManager.getString("playwright.page.waitUntil", "load").toLowerCase();
            
            switch (waitUntil) {
                case "domcontentloaded":
                    return WaitUntilState.DOMCONTENTLOADED;
                case "networkidle":
                    return WaitUntilState.NETWORKIDLE;
                case "commit":
                    return WaitUntilState.COMMIT;
                case "load":
                default:
                    return WaitUntilState.LOAD;
            }
        } catch (Exception e) {
            LOGGER.warn("Error getting wait until state from config, using default: {}", e.getMessage());
            return WaitUntilState.LOAD;
        }
    }
    
    /**
     * Gets the load state from configuration.
     * 
     * @return The configured load state
     */
    private String getLoadStateFromConfig() {
        try {
            return configManager.getString("playwright.page.loadState", "load");
        } catch (Exception e) {
            LOGGER.warn("Error getting load state from config, using default: {}", e.getMessage());
            return "load";
        }
    }
    
    /**
     * Gets the navigation timeout from configuration.
     * 
     * @return The configured navigation timeout in milliseconds
     */
    private int getNavigationTimeoutFromConfig() {
        try {
            return configManager.getInt("playwright.page.navigationTimeout", 30000);
        } catch (Exception e) {
            LOGGER.warn("Error getting navigation timeout from config, using default: {}", e.getMessage());
            return 30000;
        }
    }
    
    /**
     * Gets the timeout from configuration.
     * 
     * @return The configured timeout in milliseconds
     */
    private int getTimeoutFromConfig() {
        try {
            return configManager.getInt("playwright.page.timeout", 30000);
        } catch (Exception e) {
            LOGGER.warn("Error getting timeout from config, using default: {}", e.getMessage());
            return 30000;
        }
    }
    
    /**
     * Gets the load state timeout from configuration.
     * 
     * @return The configured load state timeout in milliseconds
     */
    private int getLoadStateTimeoutFromConfig() {
        try {
            return configManager.getInt("playwright.page.loadStateTimeout", 30000);
        } catch (Exception e) {
            LOGGER.warn("Error getting load state timeout from config, using default: {}", e.getMessage());
            return 30000;
        }
    }
    
    /**
     * Gets the auto-wait setting from configuration.
     * 
     * @return The configured auto-wait setting
     */
    private String getAutoWaitFromConfig() {
        try {
            return configManager.getString("playwright.page.autoWait", "enabled");
        } catch (Exception e) {
            LOGGER.warn("Error getting auto-wait from config, using default: {}", e.getMessage());
            return "enabled";
        }
    }
    
    /**
     * Gets the initial script from configuration.
     * 
     * @return The configured initial script
     */
    private String getInitialScriptFromConfig() {
        try {
            return configManager.getString("playwright.page.initialScript", "");
        } catch (Exception e) {
            LOGGER.warn("Error getting initial script from config: {}", e.getMessage());
            return "";
        }
    }
}



ConfigurationManager.java
---------------------------------------


package com.cstestforge.framework.core.config;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.framework.core.utils.CSConstants;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.Collections;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

/**
 * Singleton class that manages configuration settings for the CSTestForge framework.
 * Loads configuration from various sources including properties files, environment variables, and command line arguments.
 * Supports hierarchical configuration with property overrides and environment-specific configs.
 */
public class ConfigurationManager {
    private static final CSLogger LOGGER = new CSLogger(ConfigurationManager.class);
    private static volatile ConfigurationManager instance;
    private static final ReentrantLock LOCK = new ReentrantLock();
    
    private final Map<String, String> configProperties = new ConcurrentHashMap<>();
    private final Map<String, Map<String, String>> environmentConfigs = new ConcurrentHashMap<>();
    private final Map<String, Long> fileLastModifiedTimes = new ConcurrentHashMap<>();
    private final List<String> configFiles = new ArrayList<>();
    private String currentEnvironment;
    private boolean autoReload = false;
    private final long autoReloadInterval;
    private long lastReloadCheck = 0;
    
    // Encryption settings
    private static final String ENCRYPTION_KEY_ENV = "CSTESTFORGE_ENCRYPT_KEY";
    private static final String ENCRYPTION_KEY_PROP = "cstestforge.encrypt.key";
    private static final String ENCRYPTION_PREFIX = "ENC(";
    private static final String ENCRYPTION_SUFFIX = ")";
    private static final Pattern ENCRYPTED_PATTERN = Pattern.compile("ENC\\(([^)]+)\\)");
    
    /**
     * Private constructor to prevent direct instantiation.
     * Initializes the configuration from default locations and environment variables.
     */
    private ConfigurationManager() {
        LOGGER.info("Initializing ConfigurationManager");
        
        // Load default configuration
        loadDefaultConfiguration();
        
        // Set current environment
        currentEnvironment = getString("cstestforge.environment", "default");
        LOGGER.info("Current environment: {}", currentEnvironment);
        
        // Load environment-specific configuration
        loadEnvironmentConfiguration(currentEnvironment);
        
        // Check for auto-reload setting
        autoReload = getBoolean("cstestforge.config.autoReload", false);
        autoReloadInterval = getLong("cstestforge.config.autoReloadInterval", 30000);
        LOGGER.info("Auto-reload configuration: {}, interval: {} ms", autoReload, autoReloadInterval);
        
        LOGGER.info("ConfigurationManager initialized successfully");
    }
    
    /**
     * Gets the singleton instance of ConfigurationManager.
     * 
     * @return The single instance of ConfigurationManager
     */
    public static ConfigurationManager getInstance() {
        if (instance == null) {
            LOCK.lock();
            try {
                if (instance == null) {
                    instance = new ConfigurationManager();
                }
            } finally {
                LOCK.unlock();
            }
        }
        
        // Check if auto-reload is enabled and if it's time to reload
        if (instance.autoReload && (System.currentTimeMillis() - instance.lastReloadCheck > instance.autoReloadInterval)) {
            instance.reloadChangedConfigurations();
            instance.lastReloadCheck = System.currentTimeMillis();
        }
        
        return instance;
    }
    
    /**
     * Loads the default configuration from default locations.
     */
    private void loadDefaultConfiguration() {
        // First, load the built-in default configuration
        loadResourceConfiguration("/config/default-config.properties");
        
        // Next, look for a config directory in the application's working directory
        Path configPath = Paths.get("config");
        if (Files.exists(configPath) && Files.isDirectory(configPath)) {
            try {
                List<Path> configFiles = Files.list(configPath)
                    .filter(path -> path.toString().endsWith(".properties"))
                    .collect(Collectors.toList());
                
                for (Path configFile : configFiles) {
                    loadFileConfiguration(configFile.toFile());
                }
            } catch (IOException e) {
                LOGGER.error("Error listing config files: {}", e.getMessage(), e);
            }
        }
        
        // Load from explicitly specified config file location
        String configFileLocation = System.getProperty("cstestforge.config.file");
        if (configFileLocation != null && !configFileLocation.isEmpty()) {
            File configFile = new File(configFileLocation);
            if (configFile.exists() && configFile.isFile()) {
                loadFileConfiguration(configFile);
            } else {
                LOGGER.warn("Specified config file does not exist: {}", configFileLocation);
            }
        }
        
        // Finally, load from system properties and environment variables
        loadSystemProperties();
        loadEnvironmentVariables();
    }
    
    /**
     * Loads configuration from a resource on the classpath.
     * 
     * @param resourcePath The path to the resource
     */
    private void loadResourceConfiguration(String resourcePath) {
        try (InputStream inputStream = getClass().getResourceAsStream(resourcePath)) {
            if (inputStream != null) {
                Properties properties = new Properties();
                properties.load(inputStream);
                
                for (String key : properties.stringPropertyNames()) {
                    String value = properties.getProperty(key);
                    configProperties.put(key, value);
                }
                
                LOGGER.info("Loaded configuration from resource: {}", resourcePath);
            } else {
                LOGGER.debug("Resource not found: {}", resourcePath);
            }
        } catch (IOException e) {
            LOGGER.error("Error loading configuration from resource: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Loads configuration from a file.
     * 
     * @param file The configuration file
     */
    private void loadFileConfiguration(File file) {
        try (FileInputStream inputStream = new FileInputStream(file)) {
            Properties properties = new Properties();
            properties.load(inputStream);
            
            for (String key : properties.stringPropertyNames()) {
                String value = properties.getProperty(key);
                configProperties.put(key, value);
            }
            
            // Record the file path and last modified time for auto-reload
            String filePath = file.getAbsolutePath();
            configFiles.add(filePath);
            fileLastModifiedTimes.put(filePath, file.lastModified());
            
            LOGGER.info("Loaded configuration from file: {}", file.getAbsolutePath());
        } catch (IOException e) {
            LOGGER.error("Error loading configuration from file: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Loads environment-specific configuration.
     * 
     * @param environment The environment name
     */
    private void loadEnvironmentConfiguration(String environment) {
        if (environment == null || environment.isEmpty() || "default".equalsIgnoreCase(environment)) {
            return;
        }
        
        // Look for environment-specific config file in the config directory
        Path envConfigPath = Paths.get("config", "config-" + environment + ".properties");
        if (Files.exists(envConfigPath) && Files.isRegularFile(envConfigPath)) {
            try (FileInputStream inputStream = new FileInputStream(envConfigPath.toFile())) {
                Properties properties = new Properties();
                properties.load(inputStream);
                
                Map<String, String> envProperties = new HashMap<>();
                for (String key : properties.stringPropertyNames()) {
                    String value = properties.getProperty(key);
                    envProperties.put(key, value);
                    
                    // Also update the main properties map with environment-specific value
                    configProperties.put(key, value);
                }
                
                environmentConfigs.put(environment, envProperties);
                
                // Record the file path and last modified time for auto-reload
                String filePath = envConfigPath.toAbsolutePath().toString();
                configFiles.add(filePath);
                fileLastModifiedTimes.put(filePath, Files.getLastModifiedTime(envConfigPath).toMillis());
                
                LOGGER.info("Loaded environment configuration for: {}", environment);
            } catch (IOException e) {
                LOGGER.error("Error loading environment configuration: {}", e.getMessage(), e);
            }
        } else {
            LOGGER.debug("No specific configuration found for environment: {}", environment);
        }
    }
    
    /**
     * Loads configuration from system properties.
     */
    private void loadSystemProperties() {
        Properties sysProps = System.getProperties();
        for (String key : sysProps.stringPropertyNames()) {
            if (key.startsWith("cstestforge.")) {
                String value = sysProps.getProperty(key);
                configProperties.put(key, value);
            }
        }
        LOGGER.info("Loaded configuration from system properties");
    }
    
    /**
     * Loads configuration from environment variables.
     */
    private void loadEnvironmentVariables() {
        Map<String, String> envVars = System.getenv();
        for (Map.Entry<String, String> entry : envVars.entrySet()) {
            String key = entry.getKey();
            if (key.startsWith("CSTESTFORGE_")) {
                // Convert environment variable name to property name (CSTESTFORGE_EXAMPLE_PROPERTY -> cstestforge.example.property)
                String propertyKey = "cstestforge." + key.substring(12).toLowerCase().replace('_', '.');
                configProperties.put(propertyKey, entry.getValue());
            }
        }
        LOGGER.info("Loaded configuration from environment variables");
    }
    
    /**
     * Reloads configurations that have changed since they were last loaded.
     */
    private void reloadChangedConfigurations() {
        boolean configChanged = false;
        
        for (String filePath : configFiles) {
            File file = new File(filePath);
            if (file.exists() && file.isFile()) {
                long lastModified = file.lastModified();
                Long recordedLastModified = fileLastModifiedTimes.get(filePath);
                
                if (recordedLastModified != null && lastModified > recordedLastModified) {
                    LOGGER.info("Configuration file changed, reloading: {}", filePath);
                    loadFileConfiguration(file);
                    configChanged = true;
                }
            }
        }
        
        if (configChanged) {
            // Reload environment configuration if config changes were detected
            String environment = getString("cstestforge.environment", "default");
            if (!environment.equals(currentEnvironment)) {
                currentEnvironment = environment;
                loadEnvironmentConfiguration(currentEnvironment);
            }
        }
    }
    
    /**
     * Gets a string property from configuration.
     * 
     * @param key The property key
     * @param defaultValue The default value if the property is not found
     * @return The property value, or the default value if not found
     */
    public String getString(String key, String defaultValue) {
        String value = configProperties.get(key);
        if (value == null) {
            return defaultValue;
        }
        
        // Check if the value is encrypted
        value = decryptIfNecessary(value);
        
        // Resolve any property references
        return resolvePropertyReferences(value);
    }
    
    /**
     * Gets a string property from configuration.
     * 
     * @param key The property key
     * @return The property value, or null if not found
     */
    public String getString(String key) {
        return getString(key, null);
    }
    
    /**
     * Gets a boolean property from configuration.
     * 
     * @param key The property key
     * @param defaultValue The default value if the property is not found
     * @return The property value, or the default value if not found
     */
    public boolean getBoolean(String key, boolean defaultValue) {
        String value = getString(key, null);
        if (value == null) {
            return defaultValue;
        }
        
        value = value.trim().toLowerCase();
        return "true".equals(value) || "yes".equals(value) || "1".equals(value) || "on".equals(value);
    }
    
    /**
     * Gets an integer property from configuration.
     * 
     * @param key The property key
     * @param defaultValue The default value if the property is not found
     * @return The property value, or the default value if not found
     */
    public int getInt(String key, int defaultValue) {
        String value = getString(key, null);
        if (value == null) {
            return defaultValue;
        }
        
        try {
            return Integer.parseInt(value.trim());
        } catch (NumberFormatException e) {
            LOGGER.warn("Invalid integer value for key {}: {}", key, value);
            return defaultValue;
        }
    }
    
    /**
     * Gets a long property from configuration.
     * 
     * @param key The property key
     * @param defaultValue The default value if the property is not found
     * @return The property value, or the default value if not found
     */
    public long getLong(String key, long defaultValue) {
        String value = getString(key, null);
        if (value == null) {
            return defaultValue;
        }
        
        try {
            return Long.parseLong(value.trim());
        } catch (NumberFormatException e) {
            LOGGER.warn("Invalid long value for key {}: {}", key, value);
            return defaultValue;
        }
    }
    
    /**
     * Gets a double property from configuration.
     * 
     * @param key The property key
     * @param defaultValue The default value if the property is not found
     * @return The property value, or the default value if not found
     */
    public double getDouble(String key, double defaultValue) {
        String value = getString(key, null);
        if (value == null) {
            return defaultValue;
        }
        
        try {
            return Double.parseDouble(value.trim());
        } catch (NumberFormatException e) {
            LOGGER.warn("Invalid double value for key {}: {}", key, value);
            return defaultValue;
        }
    }
    
    /**
     * Gets a list property from configuration.
     * The property value should be a comma-separated list.
     * 
     * @param key The property key
     * @return The list of values, or an empty list if not found
     */
    public List<String> getList(String key) {
        String value = getString(key, "");
        if (value.isEmpty()) {
            return Collections.emptyList();
        }
        
        List<String> result = new ArrayList<>();
        String[] items = value.split(",");
        for (String item : items) {
            String trimmed = item.trim();
            if (!trimmed.isEmpty()) {
                result.add(trimmed);
            }
        }
        
        return result;
    }
    
    /**
     * Gets a map property from configuration.
     * The property values should be in format key1=value1,key2=value2,...
     * 
     * @param key The property key
     * @return The map of values, or an empty map if not found
     */
    public Map<String, String> getMap(String key) {
        String value = getString(key, "");
        if (value.isEmpty()) {
            return Collections.emptyMap();
        }
        
        Map<String, String> result = new HashMap<>();
        String[] items = value.split(",");
        for (String item : items) {
            String trimmed = item.trim();
            if (!trimmed.isEmpty()) {
                String[] parts = trimmed.split("=", 2);
                if (parts.length == 2) {
                    result.put(parts[0].trim(), parts[1].trim());
                }
            }
        }
        
        return result;
    }
    
    /**
     * Gets all property keys with a specific prefix.
     * 
     * @param prefix The prefix
     * @return The set of keys with the prefix
     */
    public Set<String> getKeysWithPrefix(String prefix) {
        return configProperties.keySet().stream()
            .filter(key -> key.startsWith(prefix))
            .collect(Collectors.toSet());
    }
    
    /**
     * Sets a property value.
     * 
     * @param key The property key
     * @param value The property value
     */
    public void setProperty(String key, String value) {
        configProperties.put(key, value);
    }
    
    /**
     * Removes a property.
     * 
     * @param key The property key
     */
    public void removeProperty(String key) {
        configProperties.remove(key);
    }
    
    /**
     * Gets the current environment.
     * 
     * @return The current environment
     */
    public String getCurrentEnvironment() {
        return currentEnvironment;
    }
    
    /**
     * Sets the current environment and loads the environment-specific configuration.
     * 
     * @param environment The environment to set
     */
    public void setEnvironment(String environment) {
        if (environment != null && !environment.equals(currentEnvironment)) {
            currentEnvironment = environment;
            loadEnvironmentConfiguration(environment);
            LOGGER.info("Environment switched to: {}", environment);
        }
    }
    
    /**
     * Gets a copy of all configuration properties.
     * 
     * @return A copy of all configuration properties
     */
    public Map<String, String> getAllProperties() {
        return new HashMap<>(configProperties);
    }
    
    /**
     * Resolves property references in a string.
     * References are in the format ${property.name} and will be replaced with the value of the referenced property.
     * 
     * @param value The string containing property references
     * @return The string with property references resolved
     */
    private String resolvePropertyReferences(String value) {
        if (value == null || !value.contains("${")) {
            return value;
        }
        
        Pattern pattern = Pattern.compile("\\$\\{([^}]+)\\}");
        Matcher matcher = pattern.matcher(value);
        StringBuilder result = new StringBuilder();
        int lastEnd = 0;
        
        while (matcher.find()) {
            result.append(value, lastEnd, matcher.start());
            String propName = matcher.group(1);
            String propValue = getString(propName, "${" + propName + "}");
            result.append(propValue);
            lastEnd = matcher.end();
        }
        
        result.append(value.substring(lastEnd));
        return result.toString();
    }
    
    /**
     * Decrypts a value if it is encrypted.
     * Encrypted values are in the format ENC(encrypted-data).
     * 
     * @param value The value to decrypt
     * @return The decrypted value, or the original value if not encrypted
     */
    private String decryptIfNecessary(String value) {
        if (value == null || !value.startsWith(ENCRYPTION_PREFIX) || !value.endsWith(ENCRYPTION_SUFFIX)) {
            return value;
        }
        
        Matcher matcher = ENCRYPTED_PATTERN.matcher(value);
        if (matcher.matches()) {
            String encryptedData = matcher.group(1);
            try {
                return decrypt(encryptedData);
            } catch (Exception e) {
                LOGGER.error("Error decrypting value: {}", e.getMessage(), e);
                return value;
            }
        }
        
        return value;
    }
    
    /**
     * Decrypts an encrypted string.
     * 
     * @param encryptedData The encrypted data
     * @return The decrypted string
     * @throws Exception If decryption fails
     */
    private String decrypt(String encryptedData) throws Exception {
        String encryptionKey = System.getenv(ENCRYPTION_KEY_ENV);
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            encryptionKey = getString(ENCRYPTION_KEY_PROP, null);
            if (encryptionKey == null || encryptionKey.isEmpty()) {
                throw new IllegalStateException("Encryption key not found in environment variable or property");
            }
        }
        
        SecretKeySpec secretKey = new SecretKeySpec(encryptionKey.getBytes(), "AES");
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        
        byte[] decodedData = Base64.getDecoder().decode(encryptedData);
        byte[] decryptedData = cipher.doFinal(decodedData);
        
        return new String(decryptedData);
    }
    
    /**
     * Encrypts a string.
     * 
     * @param plainText The string to encrypt
     * @return The encrypted string in the format ENC(encrypted-data)
     * @throws Exception If encryption fails
     */
    public String encrypt(String plainText) throws Exception {
        String encryptionKey = System.getenv(ENCRYPTION_KEY_ENV);
        if (encryptionKey == null || encryptionKey.isEmpty()) {
            encryptionKey = getString(ENCRYPTION_KEY_PROP, null);
            if (encryptionKey == null || encryptionKey.isEmpty()) {
                throw new IllegalStateException("Encryption key not found in environment variable or property");
            }
        }
        
        SecretKeySpec secretKey = new SecretKeySpec(encryptionKey.getBytes(), "AES");
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        
        byte[] encryptedData = cipher.doFinal(plainText.getBytes());
        String encodedData = Base64.getEncoder().encodeToString(encryptedData);
        
        return ENCRYPTION_PREFIX + encodedData + ENCRYPTION_SUFFIX;
    }
    
    /**
     * Reloads all configurations.
     */
    public void reloadAll() {
        LOGGER.info("Reloading all configurations");
        configProperties.clear();
        environmentConfigs.clear();
        fileLastModifiedTimes.clear();
        configFiles.clear();
        
        loadDefaultConfiguration();
        currentEnvironment = getString("cstestforge.environment", "default");
        loadEnvironmentConfiguration(currentEnvironment);
        
        LOGGER.info("Configuration reload completed");
    }
}


CSLogger.java
--------------------------------------

package com.cstestforge.framework.core.utils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.slf4j.event.Level;

import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * Custom logger for the CSTestForge framework.
 * Provides advanced logging capabilities including context-aware logging,
 * correlation IDs, performance metrics, and customizable output formats.
 */
public class CSLogger {
    private final Logger logger;
    
    // Thread-local context data
    private static final ThreadLocal<Map<String, String>> CONTEXT = ThreadLocal.withInitial(HashMap::new);
    
    // Common MDC keys
    private static final String MDC_CORRELATION_ID = "correlationId";
    private static final String MDC_TEST_NAME = "testName";
    private static final String MDC_BROWSER = "browser";
    private static final String MDC_ENVIRONMENT = "environment";
    private static final String MDC_COMPONENT = "component";
    
    // Timing data for performance logging
    private static final Map<String, Long> TIMING_START = new ConcurrentHashMap<>();
    
    // Globally enable/disable debug logs
    private static boolean debugEnabled = false;
    
    // Globally enable/disable trace logs
    private static boolean traceEnabled = false;
    
    /**
     * Constructs a new CSLogger for the specified class.
     * 
     * @param clazz The class to create the logger for
     */
    public CSLogger(Class<?> clazz) {
        this.logger = LoggerFactory.getLogger(clazz);
    }
    
    /**
     * Constructs a new CSLogger with the specified name.
     * 
     * @param name The logger name
     */
    public CSLogger(String name) {
        this.logger = LoggerFactory.getLogger(name);
    }
    
    /**
     * Globally enables or disables debug logs.
     * 
     * @param enabled True to enable debug logs, false to disable
     */
    public static void setDebugEnabled(boolean enabled) {
        debugEnabled = enabled;
    }
    
    /**
     * Globally enables or disables trace logs.
     * 
     * @param enabled True to enable trace logs, false to disable
     */
    public static void setTraceEnabled(boolean enabled) {
        traceEnabled = enabled;
    }
    
    /**
     * Sets a context value for the current thread.
     * 
     * @param key The context key
     * @param value The context value
     */
    public static void setContext(String key, String value) {
        CONTEXT.get().put(key, value);
        MDC.put(key, value);
    }
    
    /**
     * Gets a context value for the current thread.
     * 
     * @param key The context key
     * @return The context value, or null if not set
     */
    public static String getContext(String key) {
        return CONTEXT.get().get(key);
    }
    
    /**
     * Removes a context value for the current thread.
     * 
     * @param key The context key
     */
    public static void removeContext(String key) {
        CONTEXT.get().remove(key);
        MDC.remove(key);
    }
    
    /**
     * Clears all context values for the current thread.
     */
    public static void clearContext() {
        CONTEXT.get().clear();
        MDC.clear();
    }
    
    /**
     * Sets the correlation ID for the current thread.
     * If no ID is provided, a new UUID is generated.
     * 
     * @param correlationId The correlation ID, or null to generate a new one
     * @return The correlation ID
     */
    public static String setCorrelationId(String correlationId) {
        if (correlationId == null || correlationId.isEmpty()) {
            correlationId = UUID.randomUUID().toString();
        }
        setContext(MDC_CORRELATION_ID, correlationId);
        return correlationId;
    }
    
    /**
     * Gets the correlation ID for the current thread.
     * 
     * @return The correlation ID, or null if not set
     */
    public static String getCorrelationId() {
        return getContext(MDC_CORRELATION_ID);
    }
    
    /**
     * Sets the test name for the current thread.
     * 
     * @param testName The test name
     */
    public static void setTestName(String testName) {
        setContext(MDC_TEST_NAME, testName);
    }
    
    /**
     * Sets the browser for the current thread.
     * 
     * @param browser The browser
     */
    public static void setBrowser(String browser) {
        setContext(MDC_BROWSER, browser);
    }
    
    /**
     * Sets the environment for the current thread.
     * 
     * @param environment The environment
     */
    public static void setEnvironment(String environment) {
        setContext(MDC_ENVIRONMENT, environment);
    }
    
    /**
     * Sets the component for the current thread.
     * 
     * @param component The component
     */
    public static void setComponent(String component) {
        setContext(MDC_COMPONENT, component);
    }
    
    /**
     * Starts timing an operation.
     * 
     * @param operationName The operation name
     */
    public static void startTiming(String operationName) {
        TIMING_START.put(operationName, System.currentTimeMillis());
    }
    
    /**
     * Stops timing an operation and logs the duration.
     * 
     * @param operationName The operation name
     * @param logger The logger to log with
     * @param level The log level
     * @param message The message format, use {} to include the duration
     */
    public static void stopTiming(String operationName, CSLogger logger, Level level, String message) {
        Long startTime = TIMING_START.remove(operationName);
        if (startTime != null) {
            long duration = System.currentTimeMillis() - startTime;
            String formattedMessage = message.replace("{}", String.valueOf(duration));
            
            switch (level) {
                case INFO:
                    logger.info(formattedMessage);
                    break;
                case DEBUG:
                    logger.debug(formattedMessage);
                    break;
                case WARN:
                    logger.warn(formattedMessage);
                    break;
                case ERROR:
                    logger.error(formattedMessage);
                    break;
                case TRACE:
                    logger.trace(formattedMessage);
                    break;
            }
        }
    }
    
    /**
     * Logs a message at the TRACE level.
     * 
     * @param message The message format
     * @param args The message arguments
     */
    public void trace(String message, Object... args) {
        if (traceEnabled || logger.isTraceEnabled()) {
            logger.trace(formatMessage(message), args);
        }
    }
    
    /**
     * Logs a message at the DEBUG level.
     * 
     * @param message The message format
     * @param args The message arguments
     */
    public void debug(String message, Object... args) {
        if (debugEnabled || logger.isDebugEnabled()) {
            logger.debug(formatMessage(message), args);
        }
    }
    
    /**
     * Logs a message at the INFO level.
     * 
     * @param message The message format
     * @param args The message arguments
     */
    public void info(String message, Object... args) {
        logger.info(formatMessage(message), args);
    }
    
    /**
     * Logs a message at the WARN level.
     * 
     * @param message The message format
     * @param args The message arguments
     */
    public void warn(String message, Object... args) {
        logger.warn(formatMessage(message), args);
    }
    
    /**
     * Logs a message at the ERROR level.
     * 
     * @param message The message format
     * @param args The message arguments
     */
    public void error(String message, Object... args) {
        logger.error(formatMessage(message), args);
    }
    
    /**
     * Logs a message at the ERROR level with an exception.
     * 
     * @param message The message format
     * @param throwable The exception
     * @param args The message arguments
     */
    public void error(String message, Throwable throwable, Object... args) {
        logger.error(formatMessage(message), args, throwable);
    }
    
    /**
     * Logs a message with the context of the current thread.
     * 
     * @param level The log level
     * @param message The message format
     * @param args The message arguments
     */
    public void logWithContext(Level level, String message, Object... args) {
        // Ensure context is in MDC
        CONTEXT.get().forEach(MDC::put);
        
        switch (level) {
            case INFO:
                info(message, args);
                break;
            case DEBUG:
                debug(message, args);
                break;
            case WARN:
                warn(message, args);
                break;
            case ERROR:
                error(message, args);
                break;
            case TRACE:
                trace(message, args);
                break;
        }
    }
    
    /**
     * Logs the entry to a method.
     * 
     * @param methodName The method name
     * @param params The method parameters
     */
    public void entry(String methodName, Object... params) {
        if (debugEnabled || logger.isDebugEnabled()) {
            StringBuilder message = new StringBuilder("ENTRY ");
            message.append(methodName).append("(");
            
            if (params != null && params.length > 0) {
                for (int i = 0; i < params.length; i++) {
                    if (i > 0) {
                        message.append(", ");
                    }
                    message.append(formatParam(params[i]));
                }
            }
            
            message.append(")");
            logger.debug(formatMessage(message.toString()));
            
            // Start timing for the method
            startTiming(methodName);
        }
    }
    
    /**
     * Logs the exit from a method.
     * 
     * @param methodName The method name
     */
    public void exit(String methodName) {
        if (debugEnabled || logger.isDebugEnabled()) {
            // Stop timing for the method
            stopTiming(methodName, this, Level.DEBUG, "EXIT " + methodName + " (duration: {} ms)");
        }
    }
    
    /**
     * Logs the exit from a method with a return value.
     * 
     * @param methodName The method name
     * @param returnValue The return value
     * @return The return value
     */
    public <T> T exitWithResult(String methodName, T returnValue) {
        if (debugEnabled || logger.isDebugEnabled()) {
            // Stop timing for the method
            Long startTime = TIMING_START.remove(methodName);
            if (startTime != null) {
                long duration = System.currentTimeMillis() - startTime;
                logger.debug(formatMessage("EXIT {} (duration: {} ms): {}"), methodName, duration, formatParam(returnValue));
            } else {
                logger.debug(formatMessage("EXIT {}: {}"), methodName, formatParam(returnValue));
            }
        }
        return returnValue;
    }
    
    /**
     * Logs the execution time of a code block.
     * 
     * @param operationName The operation name
     * @param operation The operation to time
     * @return The result of the operation
     */
    public <T> T time(String operationName, Supplier<T> operation) {
        startTiming(operationName);
        try {
            return operation.get();
        } finally {
            stopTiming(operationName, this, Level.INFO, operationName + " completed in {} ms");
        }
    }
    
    /**
     * Logs the execution time of a code block.
     * 
     * @param operationName The operation name
     * @param operation The operation to time
     */
    public void time(String operationName, Runnable operation) {
        startTiming(operationName);
        try {
            operation.run();
        } finally {
            stopTiming(operationName, this, Level.INFO, operationName + " completed in {} ms");
        }
    }
    
    /**
     * Formats a message with additional context information.
     * 
     * @param message The message to format
     * @return The formatted message
     */
    private String formatMessage(String message) {
        return message;
    }
    
    /**
     * Formats a parameter for logging.
     * 
     * @param param The parameter to format
     * @return The formatted parameter
     */
    private String formatParam(Object param) {
        if (param == null) {
            return "null";
        }
        
        if (param instanceof String) {
            return "\"" + param + "\"";
        }
        
        if (param instanceof byte[]) {
            byte[] bytes = (byte[]) param;
            return "byte[" + bytes.length + "]";
        }
        
        if (param instanceof char[]) {
            char[] chars = (char[]) param;
            return "char[" + chars.length + "]";
        }
        
        if (param.getClass().isArray()) {
            return param.getClass().getSimpleName() + "[...]";
        }
        
        return param.toString();
    }
    
    /**
     * Checks if the logger is enabled for the TRACE level.
     * 
     * @return True if TRACE is enabled, false otherwise
     */
    public boolean isTraceEnabled() {
        return traceEnabled || logger.isTraceEnabled();
    }
    
    /**
     * Checks if the logger is enabled for the DEBUG level.
     * 
     * @return True if DEBUG is enabled, false otherwise
     */
    public boolean isDebugEnabled() {
        return debugEnabled || logger.isDebugEnabled();
    }
    
    /**
     * Checks if the logger is enabled for the INFO level.
     * 
     * @return True if INFO is enabled, false otherwise
     */
    public boolean isInfoEnabled() {
        return logger.isInfoEnabled();
    }
    
    /**
     * Checks if the logger is enabled for the WARN level.
     * 
     * @return True if WARN is enabled, false otherwise
     */
    public boolean isWarnEnabled() {
        return logger.isWarnEnabled();
    }
    
    /**
     * Checks if the logger is enabled for the ERROR level.
     * 
     * @return True if ERROR is enabled, false otherwise
     */
    public boolean isErrorEnabled() {
        return logger.isErrorEnabled();
    }
    
    /**
     * Gets the current timestamp as a formatted string.
     * 
     * @return The formatted timestamp
     */
    public static String getCurrentTimestamp() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
        return sdf.format(new Date());
    }
    
    /**
     * Creates a new correlation ID for the current thread.
     * 
     * @return The new correlation ID
     */
    public static String createCorrelationId() {
        return setCorrelationId(null);
    }
}


CSElement.java
-------------------------

package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.ElementHandle;
import com.microsoft.playwright.Frame;
import com.microsoft.playwright.options.AriaRole;
import com.microsoft.playwright.options.WaitForSelectorOptions;
import com.microsoft.playwright.options.ElementState;
import com.microsoft.playwright.options.MouseButton;
import com.microsoft.playwright.options.BoundingBox;
import com.microsoft.playwright.options.FilePayload;

import java.awt.Rectangle;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Enhanced wrapper for Playwright's Locator class.
 * This class provides additional functionality beyond Playwright's native capabilities.
 */
public class CSElement {
    private static final CSLogger LOGGER = new CSLogger(CSElement.class);
    private final Page page;
    private final Frame frame;
    private final Locator locator;
    private final String selector;
    private final ConfigurationManager configManager;
    
    /**
     * Constructs a new CSElement with the specified page and selector.
     * 
     * @param page The Playwright page
     * @param selector The element selector
     */
    public CSElement(Page page, String selector) {
        this.page = page;
        this.frame = null;
        this.selector = selector;
        this.locator = page.locator(selector);
        this.configManager = ConfigurationManager.getInstance();
        LOGGER.debug("Created CSElement with selector: {}", selector);
    }
    
    /**
     * Constructs a new CSElement with the specified frame and selector.
     * 
     * @param frame The Playwright frame
     * @param selector The element selector
     */
    public CSElement(Frame frame, String selector) {
        this.page = null;
        this.frame = frame;
        this.selector = selector;
        this.locator = frame.locator(selector);
        this.configManager = ConfigurationManager.getInstance();
        LOGGER.debug("Created CSElement with selector: {} in frame", selector);
    }
    
    /**
     * Constructs a new CSElement with a pre-existing locator.
     * 
     * @param locator The Playwright locator
     * @param selector The original selector (for logging)
     */
    public CSElement(Locator locator, String selector) {
        this.page = null;
        this.frame = null;
        this.selector = selector;
        this.locator = locator;
        this.configManager = ConfigurationManager.getInstance();
        LOGGER.debug("Created CSElement with existing locator: {}", selector);
    }
    
    /**
     * Gets the underlying Playwright locator.
     * 
     * @return The Playwright locator
     */
    public Locator getLocator() {
        return locator;
    }
    
    /**
     * Gets the selector used to create this element.
     * 
     * @return The selector
     */
    public String getSelector() {
        return selector;
    }
    
    /**
     * Clicks the element.
     * 
     * @return This CSElement for chaining
     */
    public CSElement click() {
        try {
            LOGGER.info("Clicking element: {}", selector);
            locator.click(getClickOptions());
            return this;
        } catch (Exception e) {
            LOGGER.error("Error clicking element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Double-clicks the element.
     * 
     * @return This CSElement for chaining
     */
    public CSElement doubleClick() {
        try {
            LOGGER.info("Double-clicking element: {}", selector);
            locator.dblclick(getClickOptions());
            return this;
        } catch (Exception e) {
            LOGGER.error("Error double-clicking element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Right-clicks the element.
     * 
     * @return This CSElement for chaining
     */
    public CSElement rightClick() {
        try {
            LOGGER.info("Right-clicking element: {}", selector);
            locator.click(new Locator.ClickOptions().setButton(MouseButton.RIGHT));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error right-clicking element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Sends keystrokes to the element.
     * 
     * @param text The text to type
     * @return This CSElement for chaining
     */
    public CSElement sendKeys(String text) {
        try {
            LOGGER.info("Sending text to element: {}", selector);
            locator.fill(text);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error sending text to element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Types text character by character, simulating actual typing.
     * 
     * @param text The text to type
     * @param delay The delay between keystrokes in milliseconds
     * @return This CSElement for chaining
     */
    public CSElement type(String text, int delay) {
        try {
            LOGGER.info("Typing text to element: {}", selector);
            locator.type(text, new Locator.TypeOptions().setDelay(delay));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error typing text to element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Types text character by character with the default delay.
     * 
     * @param text The text to type
     * @return This CSElement for chaining
     */
    public CSElement type(String text) {
        return type(text, getTypeDelayFromConfig());
    }
    
    /**
     * Clears the element's text.
     * 
     * @return This CSElement for chaining
     */
    public CSElement clear() {
        try {
            LOGGER.info("Clearing element: {}", selector);
            locator.clear();
            return this;
        } catch (Exception e) {
            LOGGER.error("Error clearing element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Hovers over the element.
     * 
     * @return This CSElement for chaining
     */
    public CSElement hover() {
        try {
            LOGGER.info("Hovering over element: {}", selector);
            locator.hover(new Locator.HoverOptions()
                    .setForce(false)
                    .setPosition(null)
                    .setModifiers(null)
                    .setTimeout(getTimeoutFromConfig()));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error hovering over element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Focuses the element.
     * 
     * @return This CSElement for chaining
     */
    public CSElement focus() {
        try {
            LOGGER.info("Focusing element: {}", selector);
            locator.focus();
            return this;
        } catch (Exception e) {
            LOGGER.error("Error focusing element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Blurs (removes focus from) the element.
     * 
     * @return This CSElement for chaining
     */
    public CSElement blur() {
        try {
            LOGGER.info("Blurring element: {}", selector);
            locator.evaluate("el => el.blur()");
            return this;
        } catch (Exception e) {
            LOGGER.error("Error blurring element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks a checkbox or radio button.
     * 
     * @return This CSElement for chaining
     */
    public CSElement check() {
        try {
            LOGGER.info("Checking element: {}", selector);
            locator.check(new Locator.CheckOptions().setTimeout(getTimeoutFromConfig()));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error checking element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Unchecks a checkbox.
     * 
     * @return This CSElement for chaining
     */
    public CSElement uncheck() {
        try {
            LOGGER.info("Unchecking element: {}", selector);
            locator.uncheck(new Locator.UncheckOptions().setTimeout(getTimeoutFromConfig()));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error unchecking element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects an option from a dropdown by value.
     * 
     * @param value The option value
     * @return This CSElement for chaining
     */
    public CSElement selectByValue(String value) {
        try {
            LOGGER.info("Selecting option with value '{}' from element: {}", value, selector);
            locator.selectOption(value);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting option by value: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects an option from a dropdown by label.
     * 
     * @param label The option label
     * @return This CSElement for chaining
     */
    public CSElement selectByLabel(String label) {
        try {
            LOGGER.info("Selecting option with label '{}' from element: {}", label, selector);
            locator.selectOption(new Locator.SelectOptionOptions().setLabel(label));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting option by label: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects multiple options from a dropdown by values.
     * 
     * @param values The option values
     * @return This CSElement for chaining
     */
    public CSElement selectByValues(String[] values) {
        try {
            LOGGER.info("Selecting multiple options from element: {}", selector);
            locator.selectOption(values);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting multiple options: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects an option from a dropdown by index.
     * 
     * @param index The option index
     * @return This CSElement for chaining
     */
    public CSElement selectByIndex(int index) {
        try {
            LOGGER.info("Selecting option at index {} from element: {}", index, selector);
            locator.selectOption(new Locator.SelectOptionOptions().setIndex(index));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting option by index: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Uploads a file to a file input element.
     * 
     * @param filePath The path to the file
     * @return This CSElement for chaining
     */
    public CSElement uploadFile(String filePath) {
        try {
            LOGGER.info("Uploading file to element: {}", selector);
            Path path = Paths.get(filePath);
            locator.setInputFiles(path);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error uploading file: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Uploads multiple files to a file input element.
     * 
     * @param filePaths The paths to the files
     * @return This CSElement for chaining
     */
    public CSElement uploadFiles(String[] filePaths) {
        try {
            LOGGER.info("Uploading multiple files to element: {}", selector);
            Path[] paths = new Path[filePaths.length];
            for (int i = 0; i < filePaths.length; i++) {
                paths[i] = Paths.get(filePaths[i]);
            }
            locator.setInputFiles(paths);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error uploading multiple files: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Uploads a file created on-the-fly to a file input element.
     * 
     * @param name The file name
     * @param mimeType The MIME type of the file
     * @param content The file content as bytes
     * @return This CSElement for chaining
     */
    public CSElement uploadFileContent(String name, String mimeType, byte[] content) {
        try {
            LOGGER.info("Uploading file content to element: {}", selector);
            FilePayload filePayload = new FilePayload(name, mimeType, content);
            locator.setInputFiles(new FilePayload[]{filePayload});
            return this;
        } catch (Exception e) {
            LOGGER.error("Error uploading file content: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Presses a key or key combination.
     * 
     * @param key The key or key combination to press
     * @return This CSElement for chaining
     */
    public CSElement press(String key) {
        try {
            LOGGER.info("Pressing key '{}' on element: {}", key, selector);
            locator.press(key);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error pressing key: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Drags the element to the target element.
     * 
     * @param target The target element
     * @return This CSElement for chaining
     */
    public CSElement dragTo(CSElement target) {
        try {
            LOGGER.info("Dragging element {} to target {}", selector, target.getSelector());
            locator.dragTo(target.getLocator());
            return this;
        } catch (Exception e) {
            LOGGER.error("Error dragging element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Scrolls the element into view.
     * 
     * @return This CSElement for chaining
     */
    public CSElement scrollIntoView() {
        try {
            LOGGER.info("Scrolling element into view: {}", selector);
            locator.scrollIntoViewIfNeeded();
            return this;
        } catch (Exception e) {
            LOGGER.error("Error scrolling element into view: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Takes a screenshot of the element.
     * 
     * @param path The path to save the screenshot
     * @return This CSElement for chaining
     */
    public CSElement screenshot(String path) {
        try {
            LOGGER.info("Taking screenshot of element: {}", selector);
            locator.screenshot(new Locator.ScreenshotOptions().setPath(Paths.get(path)));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error taking screenshot: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Takes a screenshot of the element and returns the image as bytes.
     * 
     * @return The screenshot as bytes
     */
    public byte[] screenshotBytes() {
        try {
            LOGGER.info("Taking screenshot of element as bytes: {}", selector);
            return locator.screenshot();
        } catch (Exception e) {
            LOGGER.error("Error taking screenshot as bytes: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to be visible.
     * 
     * @return This CSElement for chaining
     */
    public CSElement waitUntilVisible() {
        try {
            LOGGER.info("Waiting for element to be visible: {}", selector);
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(ElementState.VISIBLE)
                    .setTimeout(getTimeoutFromConfig()));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error waiting for element to be visible: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to be hidden.
     * 
     * @return This CSElement for chaining
     */
    public CSElement waitUntilHidden() {
        try {
            LOGGER.info("Waiting for element to be hidden: {}", selector);
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(ElementState.HIDDEN)
                    .setTimeout(getTimeoutFromConfig()));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error waiting for element to be hidden: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to be enabled.
     * 
     * @return This CSElement for chaining
     */
    public CSElement waitUntilEnabled() {
        try {
            LOGGER.info("Waiting for element to be enabled: {}", selector);
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(ElementState.ENABLED)
                    .setTimeout(getTimeoutFromConfig()));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error waiting for element to be enabled: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to be disabled.
     * 
     * @return This CSElement for chaining
     */
    public CSElement waitUntilDisabled() {
        try {
            LOGGER.info("Waiting for element to be disabled: {}", selector);
            locator.waitFor(new Locator.WaitForOptions()
                    .setState(ElementState.DISABLED)
                    .setTimeout(getTimeoutFromConfig()));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error waiting for element to be disabled: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to have the specified text.
     * 
     * @param text The text to wait for
     * @return This CSElement for chaining
     */
    public CSElement waitForText(String text) {
        try {
            LOGGER.info("Waiting for element to have text '{}': {}", text, selector);
            locator.waitFor(new Locator.WaitForOptions().setTimeout(getTimeoutFromConfig()));
            
            long timeout = getTimeoutFromConfig();
            long startTime = System.currentTimeMillis();
            
            while (System.currentTimeMillis() - startTime < timeout) {
                if (text.equals(getText())) {
                    return this;
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for text", e);
                }
            }
            
            throw new RuntimeException("Timed out waiting for text: " + text);
        } catch (Exception e) {
            LOGGER.error("Error waiting for element to have text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to contain the specified text.
     * 
     * @param text The text to wait for
     * @return This CSElement for chaining
     */
    public CSElement waitForTextContaining(String text) {
        try {
            LOGGER.info("Waiting for element to contain text '{}': {}", text, selector);
            locator.waitFor(new Locator.WaitForOptions().setTimeout(getTimeoutFromConfig()));
            
            long timeout = getTimeoutFromConfig();
            long startTime = System.currentTimeMillis();
            
            while (System.currentTimeMillis() - startTime < timeout) {
                String currentText = getText();
                if (currentText != null && currentText.contains(text)) {
                    return this;
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for text containing", e);
                }
            }
            
            throw new RuntimeException("Timed out waiting for text containing: " + text);
        } catch (Exception e) {
            LOGGER.error("Error waiting for element to contain text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for the element to have the specified attribute value.
     * 
     * @param attribute The attribute name
     * @param value The attribute value
     * @return This CSElement for chaining
     */
    public CSElement waitForAttribute(String attribute, String value) {
        try {
            LOGGER.info("Waiting for element to have attribute '{}' with value '{}': {}", attribute, value, selector);
            
            long timeout = getTimeoutFromConfig();
            long startTime = System.currentTimeMillis();
            
            while (System.currentTimeMillis() - startTime < timeout) {
                String currentValue = getAttribute(attribute);
                if (value.equals(currentValue)) {
                    return this;
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for attribute", e);
                }
            }
            
            throw new RuntimeException("Timed out waiting for attribute '" + attribute + "' with value '" + value + "'");
        } catch (Exception e) {
            LOGGER.error("Error waiting for attribute '{}' with value '{}': {}", attribute, value, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for the specified condition to be met.
     * 
     * @param condition The condition to wait for
     * @param timeoutMs The timeout in milliseconds
     * @return This CSElement for chaining
     */
    public CSElement waitForCondition(Predicate<CSElement> condition, long timeoutMs) {
        try {
            LOGGER.info("Waiting for custom condition on element: {}", selector);
            
            long startTime = System.currentTimeMillis();
            
            while (System.currentTimeMillis() - startTime < timeoutMs) {
                if (condition.test(this)) {
                    return this;
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for condition", e);
                }
            }
            
            throw new RuntimeException("Timed out waiting for condition");
        } catch (Exception e) {
            LOGGER.error("Error waiting for condition: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the element's text content.
     * 
     * @return The text content
     */
    public String getText() {
        try {
            return locator.textContent();
        } catch (Exception e) {
            LOGGER.error("Error getting text content: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the element's inner text.
     * 
     * @return The inner text
     */
    public String getInnerText() {
        try {
            return locator.innerText();
        } catch (Exception e) {
            LOGGER.error("Error getting inner text: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the element's inner HTML.
     * 
     * @return The inner HTML
     */
    public String getInnerHTML() {
        try {
            return locator.innerHTML();
        } catch (Exception e) {
            LOGGER.error("Error getting inner HTML: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the element's attribute value.
     * 
     * @param name The attribute name
     * @return The attribute value
     */
    public String getAttribute(String name) {
        try {
            return locator.getAttribute(name);
        } catch (Exception e) {
            LOGGER.error("Error getting attribute '{}': {}", name, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the element's value.
     * 
     * @return The element's value
     */
    public String getValue() {
        try {
            return locator.inputValue();
        } catch (Exception e) {
            LOGGER.error("Error getting input value: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if the element is visible.
     * 
     * @return True if the element is visible, false otherwise
     */
    public boolean isVisible() {
        try {
            return locator.isVisible();
        } catch (Exception e) {
            LOGGER.error("Error checking if element is visible: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if the element is enabled.
     * 
     * @return True if the element is enabled, false otherwise
     */
    public boolean isEnabled() {
        try {
            return locator.isEnabled();
        } catch (Exception e) {
            LOGGER.error("Error checking if element is enabled: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if the element is checked.
     * 
     * @return True if the element is checked, false otherwise
     */
    public boolean isChecked() {
        try {
            return locator.isChecked();
        } catch (Exception e) {
            LOGGER.error("Error checking if element is checked: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the element's bounding box.
     * 
     * @return The bounding box
     */
    public BoundingBox getBoundingBox() {
        try {
            return locator.boundingBox();
        } catch (Exception e) {
            LOGGER.error("Error getting bounding box: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Evaluates JavaScript on the element.
     * 
     * @param script The JavaScript to evaluate
     * @return The result of the evaluation
     */
    public Object evaluate(String script) {
        try {
            return locator.evaluate(script);
        } catch (Exception e) {
            LOGGER.error("Error evaluating script: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Evaluates JavaScript on the element with arguments.
     * 
     * @param script The JavaScript to evaluate
     * @param arg The argument to pass to the script
     * @return The result of the evaluation
     */
    public Object evaluate(String script, Object arg) {
        try {
            return locator.evaluate(script, arg);
        } catch (Exception e) {
            LOGGER.error("Error evaluating script with arg: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Dispatches an event on the element.
     * 
     * @param type The event type
     * @return This CSElement for chaining
     */
    public CSElement dispatchEvent(String type) {
        try {
            locator.dispatchEvent(type);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error dispatching event '{}': {}", type, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Dispatches an event on the element with event data.
     * 
     * @param type The event type
     * @param eventData The event data
     * @return This CSElement for chaining
     */
    public CSElement dispatchEvent(String type, Object eventData) {
        try {
            locator.dispatchEvent(type, eventData);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error dispatching event '{}' with data: {}", type, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Finds a child element using the specified selector.
     * 
     * @param selector The selector
     * @return The child element
     */
    public CSElement findElement(String selector) {
        try {
            Locator childLocator = locator.locator(selector);
            return new CSElement(childLocator, this.selector + " >> " + selector);
        } catch (Exception e) {
            LOGGER.error("Error finding child element with selector '{}': {}", selector, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Finds all child elements using the specified selector.
     * 
     * @param selector The selector
     * @return The list of child elements
     */
    public CSElementList findElements(String selector) {
        try {
            Locator childLocator = locator.locator(selector);
            return new CSElementList(childLocator, this.selector + " >> " + selector);
        } catch (Exception e) {
            LOGGER.error("Error finding child elements with selector '{}': {}", selector, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the count of elements that match the selector.
     * 
     * @return The count of elements
     */
    public int count() {
        try {
            return locator.count();
        } catch (Exception e) {
            LOGGER.error("Error getting element count: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the parent element.
     * 
     * @return The parent element
     */
    public CSElement getParent() {
        return findElement("..");
    }
    
    /**
     * Gets the first element that matches the selector.
     * 
     * @return The first element
     */
    public CSElement first() {
        try {
            Locator firstLocator = locator.first();
            return new CSElement(firstLocator, this.selector + " >> first");
        } catch (Exception e) {
            LOGGER.error("Error getting first element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the last element that matches the selector.
     * 
     * @return The last element
     */
    public CSElement last() {
        try {
            Locator lastLocator = locator.last();
            return new CSElement(lastLocator, this.selector + " >> last");
        } catch (Exception e) {
            LOGGER.error("Error getting last element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the nth element that matches the selector.
     * 
     * @param index The index
     * @return The nth element
     */
    public CSElement nth(int index) {
        try {
            Locator nthLocator = locator.nth(index);
            return new CSElement(nthLocator, this.selector + " >> nth(" + index + ")");
        } catch (Exception e) {
            LOGGER.error("Error getting nth element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the click options from configuration.
     * 
     * @return The click options
     */
    private Locator.ClickOptions getClickOptions() {
        return new Locator.ClickOptions()
                .setButton(MouseButton.LEFT)
                .setClickCount(1)
                .setDelay(getClickDelayFromConfig())
                .setForce(false)
                .setModifiers(null)
                .setNoWaitAfter(false)
                .setPosition(null)
                .setTimeout(getTimeoutFromConfig())
                .setTrial(false);
    }
    
    /**
     * Gets the click delay from configuration.
     * 
     * @return The click delay in milliseconds
     */
    private int getClickDelayFromConfig() {
        try {
            return configManager.getInt("playwright.element.click.delay", 0);
        } catch (Exception e) {
            LOGGER.warn("Error getting click delay from config: {}", e.getMessage());
            return 0;
        }
    }
    
    /**
     * Gets the type delay from configuration.
     * 
     * @return The type delay in milliseconds
     */
    private int getTypeDelayFromConfig() {
        try {
            return configManager.getInt("playwright.element.type.delay", 50);
        } catch (Exception e) {
            LOGGER.warn("Error getting type delay from config: {}", e.getMessage());
            return 50;
        }
    }
    
    /**
     * Gets the timeout from configuration.
     * 
     * @return The timeout in milliseconds
     */
    private int getTimeoutFromConfig() {
        try {
            return configManager.getInt("playwright.element.timeout", 30000);
        } catch (Exception e) {
            LOGGER.warn("Error getting timeout from config: {}", e.getMessage());
            return 30000;
        }
    }
}


CSElementList.java
-------------------------------

package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.Locator;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Wrapper for a collection of Playwright elements.
 * Provides enhanced functionality for working with multiple elements.
 */
public class CSElementList {
    private static final CSLogger LOGGER = new CSLogger(CSElementList.class);
    private final Locator locator;
    private final String selector;
    
    /**
     * Constructs a new CSElementList with the specified locator and selector.
     * 
     * @param locator The Playwright locator
     * @param selector The selector used to create the locator
     */
    public CSElementList(Locator locator, String selector) {
        this.locator = locator;
        this.selector = selector;
        LOGGER.debug("Created CSElementList with selector: {}", selector);
    }
    
    /**
     * Gets the number of elements in the list.
     * 
     * @return The number of elements
     */
    public int count() {
        try {
            int count = locator.count();
            LOGGER.debug("Element count for '{}': {}", selector, count);
            return count;
        } catch (Exception e) {
            LOGGER.error("Error getting element count: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the element at the specified index.
     * 
     * @param index The index
     * @return The element at the index
     */
    public CSElement get(int index) {
        try {
            if (index < 0) {
                throw new IndexOutOfBoundsException("Index cannot be negative: " + index);
            }
            
            int count = count();
            if (index >= count) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index + ", Size: " + count);
            }
            
            Locator elementLocator = locator.nth(index);
            return new CSElement(elementLocator, selector + "[" + index + "]");
        } catch (Exception e) {
            LOGGER.error("Error getting element at index {}: {}", index, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the first element in the list.
     * 
     * @return The first element
     */
    public CSElement first() {
        try {
            if (count() == 0) {
                throw new IndexOutOfBoundsException("Element list is empty");
            }
            
            Locator firstLocator = locator.first();
            return new CSElement(firstLocator, selector + ":first");
        } catch (Exception e) {
            LOGGER.error("Error getting first element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the last element in the list.
     * 
     * @return The last element
     */
    public CSElement last() {
        try {
            int count = count();
            if (count == 0) {
                throw new IndexOutOfBoundsException("Element list is empty");
            }
            
            Locator lastLocator = locator.last();
            return new CSElement(lastLocator, selector + ":last");
        } catch (Exception e) {
            LOGGER.error("Error getting last element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all elements in the list as CSElement objects.
     * 
     * @return The list of CSElement objects
     */
    public List<CSElement> getAll() {
        try {
            int count = count();
            return IntStream.range(0, count)
                    .mapToObj(i -> {
                        Locator elementLocator = locator.nth(i);
                        return new CSElement(elementLocator, selector + "[" + i + "]");
                    })
                    .collect(Collectors.toList());
        } catch (Exception e) {
            LOGGER.error("Error getting all elements: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Filters elements based on a predicate.
     * 
     * @param predicate The predicate to filter elements
     * @return The filtered list of elements
     */
    public List<CSElement> filter(Predicate<CSElement> predicate) {
        try {
            return getAll().stream()
                    .filter(predicate)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            LOGGER.error("Error filtering elements: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Finds the first element that matches the predicate.
     * 
     * @param predicate The predicate to match
     * @return The first matching element, or null if none match
     */
    public CSElement find(Predicate<CSElement> predicate) {
        try {
            return getAll().stream()
                    .filter(predicate)
                    .findFirst()
                    .orElse(null);
        } catch (Exception e) {
            LOGGER.error("Error finding element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Maps elements using a function.
     * 
     * @param mapper The function to map elements
     * @param <R> The result type
     * @return The list of mapped results
     */
    public <R> List<R> map(Function<CSElement, R> mapper) {
        try {
            return getAll().stream()
                    .map(mapper)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            LOGGER.error("Error mapping elements: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the text content of all elements.
     * 
     * @return The list of text contents
     */
    public List<String> getAllTexts() {
        try {
            return map(CSElement::getText);
        } catch (Exception e) {
            LOGGER.error("Error getting all texts: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the specified attribute from all elements.
     * 
     * @param attributeName The attribute name
     * @return The list of attribute values
     */
    public List<String> getAllAttributes(String attributeName) {
        try {
            return map(element -> element.getAttribute(attributeName));
        } catch (Exception e) {
            LOGGER.error("Error getting all attributes '{}': {}", attributeName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the values of all input elements.
     * 
     * @return The list of input values
     */
    public List<String> getAllValues() {
        try {
            return map(CSElement::getValue);
        } catch (Exception e) {
            LOGGER.error("Error getting all input values: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Performs an action on each element.
     * 
     * @param action The action to perform
     * @return This CSElementList for chaining
     */
    public CSElementList forEach(Consumer<CSElement> action) {
        try {
            getAll().forEach(action);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error performing action on each element: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Clicks all elements in the list.
     * 
     * @return This CSElementList for chaining
     */
    public CSElementList clickAll() {
        return forEach(CSElement::click);
    }
    
    /**
     * Checks if any element is visible.
     * 
     * @return True if any element is visible, false otherwise
     */
    public boolean isAnyVisible() {
        try {
            return getAll().stream().anyMatch(CSElement::isVisible);
        } catch (Exception e) {
            LOGGER.error("Error checking if any element is visible: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if all elements are visible.
     * 
     * @return True if all elements are visible, false otherwise
     */
    public boolean areAllVisible() {
        try {
            List<CSElement> elements = getAll();
            return !elements.isEmpty() && elements.stream().allMatch(CSElement::isVisible);
        } catch (Exception e) {
            LOGGER.error("Error checking if all elements are visible: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if any element has the specified text.
     * 
     * @param text The text to check for
     * @return True if any element has the text, false otherwise
     */
    public boolean hasAnyText(String text) {
        try {
            return getAll().stream()
                    .map(CSElement::getText)
                    .anyMatch(t -> t != null && t.equals(text));
        } catch (Exception e) {
            LOGGER.error("Error checking if any element has text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if any element contains the specified text.
     * 
     * @param text The text to check for
     * @return True if any element contains the text, false otherwise
     */
    public boolean hasAnyTextContaining(String text) {
        try {
            return getAll().stream()
                    .map(CSElement::getText)
                    .anyMatch(t -> t != null && t.contains(text));
        } catch (Exception e) {
            LOGGER.error("Error checking if any element contains text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Finds all elements with the specified text.
     * 
     * @param text The text to search for
     * @return The list of elements with the text
     */
    public List<CSElement> findAllWithText(String text) {
        try {
            return filter(e -> {
                String t = e.getText();
                return t != null && t.equals(text);
            });
        } catch (Exception e) {
            LOGGER.error("Error finding all elements with text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Finds all elements containing the specified text.
     * 
     * @param text The text to search for
     * @return The list of elements containing the text
     */
    public List<CSElement> findAllWithTextContaining(String text) {
        try {
            return filter(e -> {
                String t = e.getText();
                return t != null && t.contains(text);
            });
        } catch (Exception e) {
            LOGGER.error("Error finding all elements containing text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Finds all elements with the specified attribute value.
     * 
     * @param attributeName The attribute name
     * @param attributeValue The attribute value
     * @return The list of elements with the attribute value
     */
    public List<CSElement> findAllWithAttribute(String attributeName, String attributeValue) {
        try {
            return filter(e -> {
                String value = e.getAttribute(attributeName);
                return value != null && value.equals(attributeValue);
            });
        } catch (Exception e) {
            LOGGER.error("Error finding all elements with attribute '{}' = '{}': {}", 
                    attributeName, attributeValue, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for at least one element to be visible.
     * 
     * @return This CSElementList for chaining
     */
    public CSElementList waitForAnyVisible() {
        try {
            LOGGER.info("Waiting for any element to be visible: {}", selector);
            locator.first().waitFor();
            return this;
        } catch (Exception e) {
            LOGGER.error("Error waiting for any element to be visible: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for at least the specified number of elements to be present.
     * 
     * @param count The minimum number of elements
     * @return This CSElementList for chaining
     */
    public CSElementList waitForCount(int count) {
        try {
            LOGGER.info("Waiting for at least {} elements: {}", count, selector);
            
            long startTime = System.currentTimeMillis();
            long timeout = 30000; // Default timeout
            
            while (System.currentTimeMillis() - startTime < timeout) {
                if (count() >= count) {
                    return this;
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for count", e);
                }
            }
            
            throw new RuntimeException("Timed out waiting for " + count + " elements");
        } catch (Exception e) {
            LOGGER.error("Error waiting for count: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if the list is empty.
     * 
     * @return True if the list is empty, false otherwise
     */
    public boolean isEmpty() {
        return count() == 0;
    }
    
    /**
     * Checks if the list is not empty.
     * 
     * @return True if the list is not empty, false otherwise
     */
    public boolean isNotEmpty() {
        return count() > 0;
    }
    
    /**
     * Gets the size of the list.
     * 
     * @return The size of the list
     */
    public int size() {
        return count();
    }
    
    /**
     * Gets the underlying Playwright locator.
     * 
     * @return The Playwright locator
     */
    public Locator getLocator() {
        return locator;
    }
    
    /**
     * Gets the selector used to create this element list.
     * 
     * @return The selector
     */
    public String getSelector() {
        return selector;
    }
    
    /**
     * Filters elements by visibility.
     * 
     * @param visible True to find visible elements, false to find hidden elements
     * @return The filtered list of elements
     */
    public List<CSElement> filterByVisibility(boolean visible) {
        try {
            return filter(e -> e.isVisible() == visible);
        } catch (Exception e) {
            LOGGER.error("Error filtering elements by visibility: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all visible elements.
     * 
     * @return The list of visible elements
     */
    public List<CSElement> getVisibleElements() {
        return filterByVisibility(true);
    }
    
    /**
     * Gets all hidden elements.
     * 
     * @return The list of hidden elements
     */
    public List<CSElement> getHiddenElements() {
        return filterByVisibility(false);
    }
    
    /**
     * Filters elements by enabled state.
     * 
     * @param enabled True to find enabled elements, false to find disabled elements
     * @return The filtered list of elements
     */
    public List<CSElement> filterByEnabled(boolean enabled) {
        try {
            return filter(e -> e.isEnabled() == enabled);
        } catch (Exception e) {
            LOGGER.error("Error filtering elements by enabled state: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all enabled elements.
     * 
     * @return The list of enabled elements
     */
    public List<CSElement> getEnabledElements() {
        return filterByEnabled(true);
    }
    
    /**
     * Gets all disabled elements.
     * 
     * @return The list of disabled elements
     */
    public List<CSElement> getDisabledElements() {
        return filterByEnabled(false);
    }
    
    /**
     * Gets a random element from the list.
     * 
     * @return A random element, or null if the list is empty
     */
    public CSElement getRandomElement() {
        try {
            int count = count();
            if (count == 0) {
                return null;
            }
            
            int randomIndex = (int) (Math.random() * count);
            return get(randomIndex);
        } catch (Exception e) {
            LOGGER.error("Error getting random element: {}", e.getMessage(), e);
            throw e;
        }
    }
}



CSConstants.java
------------------------------------

package com.cstestforge.framework.core.utils;

/**
 * Constants used throughout the CSTestForge framework.
 * This class provides centralized access to constant values.
 */
public final class CSConstants {
    
    // Framework version
    public static final String VERSION = "1.0.0";
    
    // Default timeouts (milliseconds)
    public static final int DEFAULT_TIMEOUT = 30000;
    public static final int DEFAULT_POLLING_INTERVAL = 500;
    public static final int DEFAULT_EXPLICIT_WAIT = 10000;
    public static final int DEFAULT_IMPLICIT_WAIT = 0;
    public static final int DEFAULT_PAGE_LOAD_TIMEOUT = 60000;
    public static final int DEFAULT_SCRIPT_TIMEOUT = 30000;
    
    // Browser constants
    public static final String BROWSER_CHROME = "chrome";
    public static final String BROWSER_FIREFOX = "firefox";
    public static final String BROWSER_EDGE = "edge";
    public static final String BROWSER_SAFARI = "safari";
    public static final String BROWSER_IE = "ie";
    public static final String BROWSER_CHROMIUM = "chromium";
    public static final String BROWSER_WEBKIT = "webkit";
    
    // Browser channels
    public static final String CHROME_CHANNEL_STABLE = "chrome";
    public static final String CHROME_CHANNEL_BETA = "chrome-beta";
    public static final String CHROME_CHANNEL_DEV = "chrome-dev";
    public static final String CHROME_CHANNEL_CANARY = "chrome-canary";
    public static final String MSEDGE_CHANNEL_STABLE = "msedge";
    public static final String MSEDGE_CHANNEL_BETA = "msedge-beta";
    public static final String MSEDGE_CHANNEL_DEV = "msedge-dev";
    public static final String MSEDGE_CHANNEL_CANARY = "msedge-canary";
    
    // Framework constants
    public static final String FRAMEWORK_SELENIUM = "selenium";
    public static final String FRAMEWORK_PLAYWRIGHT = "playwright";
    
    // Language constants
    public static final String LANGUAGE_JAVA = "java";
    public static final String LANGUAGE_TYPESCRIPT = "typescript";
    
    // Testing approach constants
    public static final String TESTING_APPROACH_TESTNG = "testng";
    public static final String TESTING_APPROACH_BDD = "bdd";
    
    // Environment constants
    public static final String ENV_PRODUCTION = "production";
    public static final String ENV_STAGING = "staging";
    public static final String ENV_QA = "qa";
    public static final String ENV_DEV = "dev";
    public static final String ENV_LOCAL = "local";
    
    // Wait conditions
    public static final String WAIT_VISIBILITY = "visibility";
    public static final String WAIT_INVISIBILITY = "invisibility";
    public static final String WAIT_CLICKABLE = "clickable";
    public static final String WAIT_PRESENCE = "presence";
    public static final String WAIT_TEXT = "text";
    public static final String WAIT_VALUE = "value";
    public static final String WAIT_ATTRIBUTE = "attribute";
    public static final String WAIT_SELECTED = "selected";
    public static final String WAIT_DESELECTED = "deselected";
    
    // Directory paths
    public static final String DIR_CONFIG = "config";
    public static final String DIR_LOGS = "logs";
    public static final String DIR_REPORTS = "reports";
    public static final String DIR_SCREENSHOTS = "screenshots";
    public static final String DIR_DOWNLOADS = "downloads";
    public static final String DIR_EXPORTS = "exports";
    public static final String DIR_TEMPLATES = "templates";
    public static final String DIR_TEST_DATA = "testdata";
    public static final String DIR_MODELS = "models";
    
    // File extensions
    public static final String EXT_PROPERTIES = ".properties";
    public static final String EXT_JSON = ".json";
    public static final String EXT_XML = ".xml";
    public static final String EXT_YAML = ".yaml";
    public static final String EXT_HTML = ".html";
    public static final String EXT_CSV = ".csv";
    public static final String EXT_EXCEL = ".xlsx";
    public static final String EXT_JAVA = ".java";
    public static final String EXT_TS = ".ts";
    public static final String EXT_JS = ".js";
    public static final String EXT_FEATURE = ".feature";
    public static final String EXT_LOG = ".log";
    public static final String EXT_PNG = ".png";
    public static final String EXT_JPG = ".jpg";
    public static final String EXT_PDF = ".pdf";
    
    // Configuration property keys
    public static final String CONFIG_BROWSER = "cstestforge.browser";
    public static final String CONFIG_HEADLESS = "cstestforge.browser.headless";
    public static final String CONFIG_TIMEOUT = "cstestforge.timeout";
    public static final String CONFIG_FRAMEWORK = "cstestforge.framework";
    public static final String CONFIG_LANGUAGE = "cstestforge.language";
    public static final String CONFIG_TESTING_APPROACH = "cstestforge.testing.approach";
    public static final String CONFIG_ENVIRONMENT = "cstestforge.environment";
    public static final String CONFIG_BASE_URL = "cstestforge.baseUrl";
    public static final String CONFIG_REMOTE_URL = "cstestforge.remoteUrl";
    public static final String CONFIG_REPORT_DIR = "cstestforge.report.dir";
    public static final String CONFIG_SCREENSHOT_DIR = "cstestforge.screenshot.dir";
    public static final String CONFIG_LOG_LEVEL = "cstestforge.log.level";
    public static final String CONFIG_PARALLEL_THREADS = "cstestforge.parallel.threads";
    public static final String CONFIG_RETRY_ATTEMPTS = "cstestforge.retry.attempts";
    public static final String CONFIG_DATA_PROVIDER_PARALLEL = "cstestforge.dataProvider.parallel";
    
    // Report constants
    public static final String REPORT_STATUS_PASS = "PASS";
    public static final String REPORT_STATUS_FAIL = "FAIL";
    public static final String REPORT_STATUS_SKIP = "SKIP";
    public static final String REPORT_STATUS_WARNING = "WARNING";
    public static final String REPORT_STATUS_INFO = "INFO";
    
    // Log levels
    public static final String LOG_LEVEL_TRACE = "TRACE";
    public static final String LOG_LEVEL_DEBUG = "DEBUG";
    public static final String LOG_LEVEL_INFO = "INFO";
    public static final String LOG_LEVEL_WARN = "WARN";
    public static final String LOG_LEVEL_ERROR = "ERROR";
    
    // HTTP methods
    public static final String HTTP_GET = "GET";
    public static final String HTTP_POST = "POST";
    public static final String HTTP_PUT = "PUT";
    public static final String HTTP_DELETE = "DELETE";
    public static final String HTTP_PATCH = "PATCH";
    public static final String HTTP_HEAD = "HEAD";
    public static final String HTTP_OPTIONS = "OPTIONS";
    
    // HTTP headers
    public static final String HEADER_CONTENT_TYPE = "Content-Type";
    public static final String HEADER_ACCEPT = "Accept";
    public static final String HEADER_AUTHORIZATION = "Authorization";
    public static final String HEADER_USER_AGENT = "User-Agent";
    public static final String HEADER_CONTENT_LENGTH = "Content-Length";
    
    // MIME types
    public static final String MIME_JSON = "application/json";
    public static final String MIME_XML = "application/xml";
    public static final String MIME_HTML = "text/html";
    public static final String MIME_TEXT = "text/plain";
    public static final String MIME_FORM = "application/x-www-form-urlencoded";
    public static final String MIME_MULTIPART = "multipart/form-data";
    
    // Character encodings
    public static final String ENCODING_UTF8 = "UTF-8";
    public static final String ENCODING_ISO_8859_1 = "ISO-8859-1";
    
    // Common error messages
    public static final String ERROR_ELEMENT_NOT_FOUND = "Element not found: ";
    public static final String ERROR_ELEMENT_NOT_CLICKABLE = "Element not clickable: ";
    public static final String ERROR_ELEMENT_NOT_VISIBLE = "Element not visible: ";
    public static final String ERROR_TIMEOUT = "Timeout waiting for ";
    public static final String ERROR_ASSERTION_FAILED = "Assertion failed: ";
    public static final String ERROR_CONFIG_NOT_FOUND = "Configuration property not found: ";
    public static final String ERROR_BROWSER_LAUNCH = "Failed to launch browser: ";
    public static final String ERROR_PAGE_LOAD = "Failed to load page: ";
    
    // File property keys
    public static final String FILE_PROPERTY_MIME_TYPE = "mimeType";
    public static final String FILE_PROPERTY_ENCODING = "encoding";
    public static final String FILE_PROPERTY_SIZE = "size";
    public static final String FILE_PROPERTY_LAST_MODIFIED = "lastModified";
    public static final String FILE_PROPERTY_NAME = "name";
    public static final String FILE_PROPERTY_PATH = "path";
    
    // Selenium-specific constants
    public static final String SELENIUM_DRIVER_CHROME = "webdriver.chrome.driver";
    public static final String SELENIUM_DRIVER_FIREFOX = "webdriver.gecko.driver";
    public static final String SELENIUM_DRIVER_EDGE = "webdriver.edge.driver";
    public static final String SELENIUM_DRIVER_IE = "webdriver.ie.driver";
    public static final String SELENIUM_DRIVER_SAFARI = "webdriver.safari.driver";
    
    // Locator strategies
    public static final String LOCATOR_ID = "id";
    public static final String LOCATOR_NAME = "name";
    public static final String LOCATOR_CLASS_NAME = "className";
    public static final String LOCATOR_TAG_NAME = "tagName";
    public static final String LOCATOR_LINK_TEXT = "linkText";
    public static final String LOCATOR_PARTIAL_LINK_TEXT = "partialLinkText";
    public static final String LOCATOR_CSS = "css";
    public static final String LOCATOR_XPATH = "xpath";
    
    // Playwright-specific constants
    public static final String PLAYWRIGHT_CHROMIUM = "chromium";
    public static final String PLAYWRIGHT_FIREFOX = "firefox";
    public static final String PLAYWRIGHT_WEBKIT = "webkit";
    
    // Element attributes
    public static final String ATTR_ID = "id";
    public static final String ATTR_CLASS = "class";
    public static final String ATTR_NAME = "name";
    public static final String ATTR_VALUE = "value";
    public static final String ATTR_TYPE = "type";
    public static final String ATTR_HREF = "href";
    public static final String ATTR_SRC = "src";
    public static final String ATTR_ALT = "alt";
    public static final String ATTR_TITLE = "title";
    public static final String ATTR_PLACEHOLDER = "placeholder";
    public static final String ATTR_DISABLED = "disabled";
    public static final String ATTR_CHECKED = "checked";
    public static final String ATTR_SELECTED = "selected";
    public static final String ATTR_READONLY = "readonly";
    public static final String ATTR_HIDDEN = "hidden";
    public static final String ATTR_REQUIRED = "required";
    public static final String ATTR_DATA_TEST_ID = "data-testid";
    public static final String ATTR_ARIA_LABEL = "aria-label";
    
    // Input types
    public static final String INPUT_TEXT = "text";
    public static final String INPUT_PASSWORD = "password";
    public static final String INPUT_EMAIL = "email";
    public static final String INPUT_NUMBER = "number";
    public static final String INPUT_CHECKBOX = "checkbox";
    public static final String INPUT_RADIO = "radio";
    public static final String INPUT_SUBMIT = "submit";
    public static final String INPUT_BUTTON = "button";
    public static final String INPUT_FILE = "file";
    public static final String INPUT_DATE = "date";
    public static final String INPUT_TIME = "time";
    public static final String INPUT_DATETIME = "datetime-local";
    public static final String INPUT_HIDDEN = "hidden";
    
    // Keys
    public static final String KEY_ENTER = "Enter";
    public static final String KEY_TAB = "Tab";
    public static final String KEY_ESCAPE = "Escape";
    public static final String KEY_BACKSPACE = "Backspace";
    public static final String KEY_DELETE = "Delete";
    public static final String KEY_ARROW_UP = "ArrowUp";
    public static final String KEY_ARROW_DOWN = "ArrowDown";
    public static final String KEY_ARROW_LEFT = "ArrowLeft";
    public static final String KEY_ARROW_RIGHT = "ArrowRight";
    public static final String KEY_PAGE_UP = "PageUp";
    public static final String KEY_PAGE_DOWN = "PageDown";
    public static final String KEY_HOME = "Home";
    public static final String KEY_END = "End";
    
    // HTML tags
    public static final String TAG_A = "a";
    public static final String TAG_BUTTON = "button";
    public static final String TAG_INPUT = "input";
    public static final String TAG_SELECT = "select";
    public static final String TAG_OPTION = "option";
    public static final String TAG_TEXTAREA = "textarea";
    public static final String TAG_FORM = "form";
    public static final String TAG_DIV = "div";
    public static final String TAG_SPAN = "span";
    public static final String TAG_P = "p";
    public static final String TAG_H1 = "h1";
    public static final String TAG_H2 = "h2";
    public static final String TAG_H3 = "h3";
    public static final String TAG_TABLE = "table";
    public static final String TAG_TR = "tr";
    public static final String TAG_TD = "td";
    public static final String TAG_TH = "th";
    public static final String TAG_UL = "ul";
    public static final String TAG_OL = "ol";
    public static final String TAG_LI = "li";
    public static final String TAG_IMG = "img";
    public static final String TAG_IFRAME = "iframe";
    
    // Date formats
    public static final String DATE_FORMAT_ISO = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX";
    public static final String DATE_FORMAT_DATE = "yyyy-MM-dd";
    public static final String DATE_FORMAT_TIME = "HH:mm:ss";
    public static final String DATE_FORMAT_DATETIME = "yyyy-MM-dd HH:mm:ss";
    public static final String DATE_FORMAT_TIMESTAMP = "yyyyMMddHHmmssSSS";
    public static final String DATE_FORMAT_LOG = "yyyy-MM-dd HH:mm:ss.SSS";
    
    // Private constructor to prevent instantiation
    private CSConstants() {
        throw new UnsupportedOperationException("This is a utility class and cannot be instantiated");
    }
}


CSFileUtils.java
-----------------------------------

package com.cstestforge.framework.core.utils;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

/**
 * Utility class for file operations.
 * Provides methods for file reading, writing, copying, and manipulation.
 */
public final class CSFileUtils {
    private static final CSLogger LOGGER = new CSLogger(CSFileUtils.class);
    
    // File locks for thread-safe file operations
    private static final Map<String, FileLock> FILE_LOCKS = new ConcurrentHashMap<>();
    private static final Map<String, FileChannel> FILE_CHANNELS = new ConcurrentHashMap<>();
    
    /**
     * Private constructor to prevent instantiation.
     */
    private CSFileUtils() {
        throw new UnsupportedOperationException("This is a utility class and cannot be instantiated");
    }
    
    /**
     * Reads a file as a string.
     * 
     * @param filePath The path to the file
     * @return The file content as a string
     * @throws IOException If an I/O error occurs
     */
    public static String readFileAsString(String filePath) throws IOException {
        return readFileAsString(filePath, StandardCharsets.UTF_8);
    }
    
    /**
     * Reads a file as a string with the specified charset.
     * 
     * @param filePath The path to the file
     * @param charset The charset to use
     * @return The file content as a string
     * @throws IOException If an I/O error occurs
     */
    public static String readFileAsString(String filePath, Charset charset) throws IOException {
        LOGGER.debug("Reading file as string: {}", filePath);
        Path path = Paths.get(filePath);
        return new String(Files.readAllBytes(path), charset);
    }
    
    /**
     * Reads a file as lines.
     * 
     * @param filePath The path to the file
     * @return The list of lines in the file
     * @throws IOException If an I/O error occurs
     */
    public static List<String> readFileAsLines(String filePath) throws IOException {
        return readFileAsLines(filePath, StandardCharsets.UTF_8);
    }
    
    /**
     * Reads a file as lines with the specified charset.
     * 
     * @param filePath The path to the file
     * @param charset The charset to use
     * @return The list of lines in the file
     * @throws IOException If an I/O error occurs
     */
    public static List<String> readFileAsLines(String filePath, Charset charset) throws IOException {
        LOGGER.debug("Reading file as lines: {}", filePath);
        Path path = Paths.get(filePath);
        return Files.readAllLines(path, charset);
    }
    
    /**
     * Writes a string to a file.
     * 
     * @param filePath The path to the file
     * @param content The content to write
     * @throws IOException If an I/O error occurs
     */
    public static void writeStringToFile(String filePath, String content) throws IOException {
        writeStringToFile(filePath, content, StandardCharsets.UTF_8);
    }
    
    /**
     * Writes a string to a file with the specified charset.
     * 
     * @param filePath The path to the file
     * @param content The content to write
     * @param charset The charset to use
     * @throws IOException If an I/O error occurs
     */
    public static void writeStringToFile(String filePath, String content, Charset charset) throws IOException {
        LOGGER.debug("Writing string to file: {}", filePath);
        Path path = Paths.get(filePath);
        
        // Create parent directories if they don't exist
        Path parent = path.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        
        // Acquire a file lock to ensure thread safety
        FileLock lock = acquireFileLock(filePath);
        try {
            // Write content to file with UTF-8 encoding
            try (BufferedWriter writer = new BufferedWriter(
                    new OutputStreamWriter(new FileOutputStream(filePath), charset))) {
                writer.write(content);
                writer.flush();
            }
        } finally {
            releaseFileLock(filePath, lock);
        }
    }
    
    /**
     * Writes lines to a file.
     * 
     * @param filePath The path to the file
     * @param lines The lines to write
     * @throws IOException If an I/O error occurs
     */
    public static void writeLinesToFile(String filePath, List<String> lines) throws IOException {
        writeLinesToFile(filePath, lines, StandardCharsets.UTF_8);
    }
    
    /**
     * Writes lines to a file with the specified charset.
     * 
     * @param filePath The path to the file
     * @param lines The lines to write
     * @param charset The charset to use
     * @throws IOException If an I/O error occurs
     */
    public static void writeLinesToFile(String filePath, List<String> lines, Charset charset) throws IOException {
        LOGGER.debug("Writing lines to file: {}", filePath);
        Path path = Paths.get(filePath);
        
        // Create parent directories if they don't exist
        Path parent = path.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        
        // Acquire a file lock to ensure thread safety
        FileLock lock = acquireFileLock(filePath);
        try {
            Files.write(path, lines, charset);
        } finally {
            releaseFileLock(filePath, lock);
        }
    }
    
    /**
     * Appends a string to a file.
     * 
     * @param filePath The path to the file
     * @param content The content to append
     * @throws IOException If an I/O error occurs
     */
    public static void appendStringToFile(String filePath, String content) throws IOException {
        appendStringToFile(filePath, content, StandardCharsets.UTF_8);
    }
    
    /**
     * Appends a string to a file with the specified charset.
     * 
     * @param filePath The path to the file
     * @param content The content to append
     * @param charset The charset to use
     * @throws IOException If an I/O error occurs
     */
    public static void appendStringToFile(String filePath, String content, Charset charset) throws IOException {
        LOGGER.debug("Appending string to file: {}", filePath);
        Path path = Paths.get(filePath);
        
        // Create parent directories and file if they don't exist
        Path parent = path.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        if (!Files.exists(path)) {
            Files.createFile(path);
        }
        
        // Acquire a file lock to ensure thread safety
        FileLock lock = acquireFileLock(filePath);
        try {
            // Append content to file
            try (BufferedWriter writer = new BufferedWriter(
                    new OutputStreamWriter(new FileOutputStream(filePath, true), charset))) {
                writer.write(content);
                writer.flush();
            }
        } finally {
            releaseFileLock(filePath, lock);
        }
    }
    
    /**
     * Appends lines to a file.
     * 
     * @param filePath The path to the file
     * @param lines The lines to append
     * @throws IOException If an I/O error occurs
     */
    public static void appendLinesToFile(String filePath, List<String> lines) throws IOException {
        appendLinesToFile(filePath, lines, StandardCharsets.UTF_8);
    }
    
    /**
     * Appends lines to a file with the specified charset.
     * 
     * @param filePath The path to the file
     * @param lines The lines to append
     * @param charset The charset to use
     * @throws IOException If an I/O error occurs
     */
    public static void appendLinesToFile(String filePath, List<String> lines, Charset charset) throws IOException {
        LOGGER.debug("Appending lines to file: {}", filePath);
        Path path = Paths.get(filePath);
        
        // Create parent directories and file if they don't exist
        Path parent = path.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        if (!Files.exists(path)) {
            Files.createFile(path);
        }
        
        // Acquire a file lock to ensure thread safety
        FileLock lock = acquireFileLock(filePath);
        try {
            Files.write(path, lines, charset, java.nio.file.StandardOpenOption.APPEND);
        } finally {
            releaseFileLock(filePath, lock);
        }
    }
    
    /**
     * Copies a file from source to destination.
     * 
     * @param sourcePath The source file path
     * @param destinationPath The destination file path
     * @throws IOException If an I/O error occurs
     */
    public static void copyFile(String sourcePath, String destinationPath) throws IOException {
        LOGGER.debug("Copying file from {} to {}", sourcePath, destinationPath);
        Path source = Paths.get(sourcePath);
        Path destination = Paths.get(destinationPath);
        
        // Create parent directories if they don't exist
        Path parent = destination.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        
        Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);
    }
    
    /**
     * Moves a file from source to destination.
     * 
     * @param sourcePath The source file path
     * @param destinationPath The destination file path
     * @throws IOException If an I/O error occurs
     */
    public static void moveFile(String sourcePath, String destinationPath) throws IOException {
        LOGGER.debug("Moving file from {} to {}", sourcePath, destinationPath);
        Path source = Paths.get(sourcePath);
        Path destination = Paths.get(destinationPath);
        
        // Create parent directories if they don't exist
        Path parent = destination.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        
        Files.move(source, destination, StandardCopyOption.REPLACE_EXISTING);
    }
    
    /**
     * Deletes a file.
     * 
     * @param filePath The path to the file
     * @return True if the file was deleted, false otherwise
     */
    public static boolean deleteFile(String filePath) {
        LOGGER.debug("Deleting file: {}", filePath);
        Path path = Paths.get(filePath);
        try {
            return Files.deleteIfExists(path);
        } catch (IOException e) {
            LOGGER.warn("Error deleting file {}: {}", filePath, e.getMessage());
            return false;
        }
    }
    
    /**
     * Creates a directory.
     * 
     * @param directoryPath The path to the directory
     * @return True if the directory was created, false otherwise
     */
    public static boolean createDirectory(String directoryPath) {
        LOGGER.debug("Creating directory: {}", directoryPath);
        Path path = Paths.get(directoryPath);
        try {
            Files.createDirectories(path);
            return true;
        } catch (IOException e) {
            LOGGER.warn("Error creating directory {}: {}", directoryPath, e.getMessage());
            return false;
        }
    }
    
    /**
     * Deletes a directory and all its contents.
     * 
     * @param directoryPath The path to the directory
     * @return True if the directory was deleted, false otherwise
     */
    public static boolean deleteDirectory(String directoryPath) {
        LOGGER.debug("Deleting directory: {}", directoryPath);
        Path path = Paths.get(directoryPath);
        
        if (!Files.exists(path) || !Files.isDirectory(path)) {
            return false;
        }
        
        try {
            Files.walk(path)
                .sorted((a, b) -> -a.compareTo(b)) // Sort in reverse order to delete files before directories
                .forEach(p -> {
                    try {
                        Files.delete(p);
                    } catch (IOException e) {
                        LOGGER.warn("Error deleting path {}: {}", p, e.getMessage());
                    }
                });
            return true;
        } catch (IOException e) {
            LOGGER.warn("Error walking directory {}: {}", directoryPath, e.getMessage());
            return false;
        }
    }
    
    /**
     * Checks if a file exists.
     * 
     * @param filePath The path to the file
     * @return True if the file exists, false otherwise
     */
    public static boolean fileExists(String filePath) {
        Path path = Paths.get(filePath);
        return Files.exists(path) && !Files.isDirectory(path);
    }
    
    /**
     * Checks if a directory exists.
     * 
     * @param directoryPath The path to the directory
     * @return True if the directory exists, false otherwise
     */
    public static boolean directoryExists(String directoryPath) {
        Path path = Paths.get(directoryPath);
        return Files.exists(path) && Files.isDirectory(path);
    }
    
    /**
     * Gets the file size in bytes.
     * 
     * @param filePath The path to the file
     * @return The file size in bytes, or -1 if the file does not exist
     */
    public static long getFileSize(String filePath) {
        Path path = Paths.get(filePath);
        try {
            return Files.size(path);
        } catch (IOException e) {
            LOGGER.warn("Error getting file size for {}: {}", filePath, e.getMessage());
            return -1;
        }
    }
    
    /**
     * Gets the file extension.
     * 
     * @param filePath The path to the file
     * @return The file extension, or an empty string if there is no extension
     */
    public static String getFileExtension(String filePath) {
        String fileName = Paths.get(filePath).getFileName().toString();
        int lastDotIndex = fileName.lastIndexOf('.');
        return lastDotIndex == -1 ? "" : fileName.substring(lastDotIndex);
    }
    
    /**
     * Gets the file name without extension.
     * 
     * @param filePath The path to the file
     * @return The file name without extension
     */
    public static String getFileNameWithoutExtension(String filePath) {
        String fileName = Paths.get(filePath).getFileName().toString();
        int lastDotIndex = fileName.lastIndexOf('.');
        return lastDotIndex == -1 ? fileName : fileName.substring(0, lastDotIndex);
    }
    
    /**
     * Gets the last modified time of a file.
     * 
     * @param filePath The path to the file
     * @return The last modified time in milliseconds since epoch, or -1 if the file does not exist
     */
    public static long getLastModifiedTime(String filePath) {
        Path path = Paths.get(filePath);
        try {
            return Files.getLastModifiedTime(path).toMillis();
        } catch (IOException e) {
            LOGGER.warn("Error getting last modified time for {}: {}", filePath, e.getMessage());
            return -1;
        }
    }
    
    /**
     * Lists all files in a directory.
     * 
     * @param directoryPath The path to the directory
     * @return The list of file paths, or an empty list if the directory does not exist
     */
    public static List<String> listFiles(String directoryPath) {
        return listFiles(directoryPath, null);
    }
    
    /**
     * Lists all files in a directory with the specified extension.
     * 
     * @param directoryPath The path to the directory
     * @param extension The file extension to filter by, or null to include all files
     * @return The list of file paths, or an empty list if the directory does not exist
     */
    public static List<String> listFiles(String directoryPath, String extension) {
        Path path = Paths.get(directoryPath);
        
        if (!Files.exists(path) || !Files.isDirectory(path)) {
            return Collections.emptyList();
        }
        
        try {
            List<String> files = new ArrayList<>();
            Files.list(path)
                .filter(Files::isRegularFile)
                .forEach(p -> {
                    String filePath = p.toString();
                    if (extension == null || filePath.endsWith(extension)) {
                        files.add(filePath);
                    }
                });
            return files;
        } catch (IOException e) {
            LOGGER.warn("Error listing files in directory {}: {}", directoryPath, e.getMessage());
            return Collections.emptyList();
        }
    }
    
    /**
     * Lists all directories in a directory.
     * 
     * @param directoryPath The path to the directory
     * @return The list of directory paths, or an empty list if the directory does not exist
     */
    public static List<String> listDirectories(String directoryPath) {
        Path path = Paths.get(directoryPath);
        
        if (!Files.exists(path) || !Files.isDirectory(path)) {
            return Collections.emptyList();
        }
        
        try {
            List<String> directories = new ArrayList<>();
            Files.list(path)
                .filter(Files::isDirectory)
                .forEach(p -> directories.add(p.toString()));
            return directories;
        } catch (IOException e) {
            LOGGER.warn("Error listing directories in directory {}: {}", directoryPath, e.getMessage());
            return Collections.emptyList();
        }
    }
    
    /**
     * Reads properties from a file.
     * 
     * @param filePath The path to the properties file
     * @return The properties, or an empty properties object if the file does not exist
     */
    public static Properties readProperties(String filePath) {
        LOGGER.debug("Reading properties from file: {}", filePath);
        Properties properties = new Properties();
        
        if (!fileExists(filePath)) {
            return properties;
        }
        
        try (InputStream inputStream = new FileInputStream(filePath)) {
            properties.load(inputStream);
        } catch (IOException e) {
            LOGGER.warn("Error reading properties from file {}: {}", filePath, e.getMessage());
        }
        
        return properties;
    }
    
    /**
     * Writes properties to a file.
     * 
     * @param filePath The path to the properties file
     * @param properties The properties to write
     * @param comments The comments to include at the top of the file, or null for no comments
     * @throws IOException If an I/O error occurs
     */
    public static void writeProperties(String filePath, Properties properties, String comments) throws IOException {
        LOGGER.debug("Writing properties to file: {}", filePath);
        Path path = Paths.get(filePath);
        
        // Create parent directories if they don't exist
        Path parent = path.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        
        // Acquire a file lock to ensure thread safety
        FileLock lock = acquireFileLock(filePath);
        try (OutputStream outputStream = new FileOutputStream(filePath)) {
            properties.store(outputStream, comments);
        } finally {
            releaseFileLock(filePath, lock);
        }
    }
    
    /**
     * Acquires a file lock for thread-safe file operations.
     * 
     * @param filePath The path to the file
     * @return The file lock
     * @throws IOException If an I/O error occurs
     */
    private static FileLock acquireFileLock(String filePath) throws IOException {
        FileChannel channel = getFileChannel(filePath);
        FileLock lock = null;
        
        // Try to acquire a lock with a timeout
        long startTime = System.currentTimeMillis();
        while (lock == null && System.currentTimeMillis() - startTime < 10000) { // 10-second timeout
            try {
                lock = channel.tryLock();
                if (lock == null) {
                    // Could not acquire lock, wait and try again
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        throw new IOException("Interrupted while waiting for file lock", e);
                    }
                }
            } catch (IOException e) {
                // Handle the case where the file is already locked
                LOGGER.debug("Could not acquire lock for {}, waiting and retrying: {}", filePath, e.getMessage());
                try {
                    Thread.sleep(100);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new IOException("Interrupted while waiting for file lock", ie);
                }
            }
        }
        
        if (lock == null) {
            throw new IOException("Could not acquire file lock for " + filePath + " after timeout");
        }
        
        // Store the lock for later release
        FILE_LOCKS.put(filePath, lock);
        return lock;
    }
    
    /**
     * Releases a file lock.
     * 
     * @param filePath The path to the file
     * @param lock The file lock to release
     */
    private static void releaseFileLock(String filePath, FileLock lock) {
        if (lock != null && lock.isValid()) {
            try {
                lock.release();
                FILE_LOCKS.remove(filePath);
            } catch (IOException e) {
                LOGGER.warn("Error releasing file lock for {}: {}", filePath, e.getMessage());
            }
        }
    }
    
    /**
     * Gets or creates a file channel for the specified file.
     * 
     * @param filePath The path to the file
     * @return The file channel
     * @throws IOException If an I/O error occurs
     */
    private static FileChannel getFileChannel(String filePath) throws IOException {
        FileChannel channel = FILE_CHANNELS.get(filePath);
        
        if (channel == null || !channel.isOpen()) {
            // Create parent directories if they don't exist
            Path path = Paths.get(filePath);
            Path parent = path.getParent();
            if (parent != null && !Files.exists(parent)) {
                Files.createDirectories(parent);
            }
            
            RandomAccessFile file = new RandomAccessFile(filePath, "rw");
            channel = file.getChannel();
            FILE_CHANNELS.put(filePath, channel);
        }
        
        return channel;
    }
    
    /**
     * Closes all open file channels.
     * This should be called during application shutdown.
     */
    public static void closeAllFileChannels() {
        for (Map.Entry<String, FileChannel> entry : FILE_CHANNELS.entrySet()) {
            try {
                entry.getValue().close();
            } catch (IOException e) {
                LOGGER.warn("Error closing file channel for {}: {}", entry.getKey(), e.getMessage());
            }
        }
        FILE_CHANNELS.clear();
    }
    
    /**
     * Reads a resource from the classpath as a string.
     * 
     * @param resourcePath The path to the resource
     * @return The resource content as a string, or null if the resource does not exist
     */
    public static String readResourceAsString(String resourcePath) {
        return readResourceAsString(resourcePath, StandardCharsets.UTF_8);
    }
    
    /**
     * Reads a resource from the classpath as a string with the specified charset.
     * 
     * @param resourcePath The path to the resource
     * @param charset The charset to use
     * @return The resource content as a string, or null if the resource does not exist
     */
    public static String readResourceAsString(String resourcePath, Charset charset) {
        LOGGER.debug("Reading resource as string: {}", resourcePath);
        
        try (InputStream inputStream = CSFileUtils.class.getResourceAsStream(resourcePath)) {
            if (inputStream == null) {
                LOGGER.warn("Resource not found: {}", resourcePath);
                return null;
            }
            
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))) {
                StringBuilder content = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    content.append(line).append("\n");
                }
                return content.toString();
            }
        } catch (IOException e) {
            LOGGER.warn("Error reading resource {}: {}", resourcePath, e.getMessage());
            return null;
        }
    }
    
    /**
     * Extracts files from a ZIP archive.
     * 
     * @param zipFilePath The path to the ZIP file
     * @param outputDirectory The directory to extract to
     * @throws IOException If an I/O error occurs
     */
    public static void extractZip(String zipFilePath, String outputDirectory) throws IOException {
        LOGGER.debug("Extracting ZIP file {} to {}", zipFilePath, outputDirectory);
        
        // Create output directory if it doesn't exist
        Path outputPath = Paths.get(outputDirectory);
        if (!Files.exists(outputPath)) {
            Files.createDirectories(outputPath);
        }
        
        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(zipFilePath))) {
            ZipEntry entry;
            byte[] buffer = new byte[8192];
            
            while ((entry = zipInputStream.getNextEntry()) != null) {
                Path entryPath = outputPath.resolve(entry.getName());
                
                // Create parent directories if they don't exist
                if (entry.isDirectory()) {
                    Files.createDirectories(entryPath);
                } else {
                    // Create parent directories for file
                    Path parent = entryPath.getParent();
                    if (parent != null && !Files.exists(parent)) {
                        Files.createDirectories(parent);
                    }
                    
                    // Extract file
                    try (FileOutputStream outputStream = new FileOutputStream(entryPath.toFile())) {
                        int length;
                        while ((length = zipInputStream.read(buffer)) > 0) {
                            outputStream.write(buffer, 0, length);
                        }
                    }
                }
                
                zipInputStream.closeEntry();
            }
        }
    }
    
    /**
     * Creates a ZIP archive from files in a directory.
     * 
     * @param directoryPath The path to the directory to zip
     * @param zipFilePath The path to the ZIP file to create
     * @throws IOException If an I/O error occurs
     */
    public static void createZip(String directoryPath, String zipFilePath) throws IOException {
        LOGGER.debug("Creating ZIP file {} from directory {}", zipFilePath, directoryPath);
        
        Path sourcePath = Paths.get(directoryPath);
        Path zipPath = Paths.get(zipFilePath);
        
        // Create parent directories if they don't exist
        Path parent = zipPath.getParent();
        if (parent != null && !Files.exists(parent)) {
            Files.createDirectories(parent);
        }
        
        try (ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(zipFilePath))) {
            Files.walk(sourcePath)
                .filter(path -> !Files.isDirectory(path))
                .forEach(path -> {
                    try {
                        // Create relative path for ZIP entry
                        String entryName = sourcePath.relativize(path).toString().replace('\\', '/');
                        ZipEntry zipEntry = new ZipEntry(entryName);
                        zipOutputStream.putNextEntry(zipEntry);
                        
                        // Write file content to ZIP
                        Files.copy(path, zipOutputStream);
                        zipOutputStream.closeEntry();
                    } catch (IOException e) {
                        LOGGER.warn("Error adding file {} to ZIP: {}", path, e.getMessage());
                    }
                });
        }
    }
    
    /**
     * Gets file attributes.
     * 
     * @param filePath The path to the file
     * @return The basic file attributes, or null if the file does not exist
     */
    public static BasicFileAttributes getFileAttributes(String filePath) {
        Path path = Paths.get(filePath);
        try {
            return Files.readAttributes(path, BasicFileAttributes.class);
        } catch (IOException e) {
            LOGGER.warn("Error reading file attributes for {}: {}", filePath, e.getMessage());
            return null;
        }
    }
    
    /**
     * Creates a temporary file.
     * 
     * @param prefix The prefix for the file name
     * @param suffix The suffix for the file name
     * @return The path to the temporary file
     * @throws IOException If an I/O error occurs
     */
    public static String createTempFile(String prefix, String suffix) throws IOException {
        LOGGER.debug("Creating temporary file with prefix {} and suffix {}", prefix, suffix);
        Path tempFile = Files.createTempFile(prefix, suffix);
        return tempFile.toString();
    }
    
    /**
     * Creates a temporary directory.
     * 
     * @param prefix The prefix for the directory name
     * @return The path to the temporary directory
     * @throws IOException If an I/O error occurs
     */
    public static String createTempDirectory(String prefix) throws IOException {
        LOGGER.debug("Creating temporary directory with prefix {}", prefix);
        Path tempDir = Files.createTempDirectory(prefix);
        return tempDir.toString();
    }
    
    /**
     * Generates a unique file name.
     * 
     * @param directoryPath The directory path
     * @param baseName The base file name
     * @param extension The file extension
     * @return The unique file name
     */
    public static String generateUniqueFileName(String directoryPath, String baseName, String extension) {
        String fileName = baseName + extension;
        Path filePath = Paths.get(directoryPath, fileName);
        
        // If the file already exists, add a timestamp and UUID
        if (Files.exists(filePath)) {
            String timestamp = String.valueOf(System.currentTimeMillis());
            String uuid = UUID.randomUUID().toString().substring(0, 8);
            fileName = baseName + "_" + timestamp + "_" + uuid + extension;
        }
        
        return fileName;
    }
    
    /**
     * Validates if a path is safe (no path traversal).
     * 
     * @param basePath The base path
     * @param relativePath The relative path
     * @return True if the path is safe, false otherwise
     */
    public static boolean isPathSafe(String basePath, String relativePath) {
        try {
            Path base = Paths.get(basePath).toAbsolutePath().normalize();
            Path resolved = base.resolve(relativePath).toAbsolutePath().normalize();
            
            // Check if the resolved path starts with the base path
            return resolved.startsWith(base);
        } catch (Exception e) {
            LOGGER.warn("Error validating path safety: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Compares two files for equality.
     * 
     * @param file1Path The path to the first file
     * @param file2Path The path to the second file
     * @return True if the files are equal, false otherwise
     */
    public static boolean areFilesEqual(String file1Path, String file2Path) {
        Path path1 = Paths.get(file1Path);
        Path path2 = Paths.get(file2Path);
        
        // Check if both files exist
        if (!Files.exists(path1) || !Files.exists(path2)) {
            return false;
        }
        
        try {
            // Check if file sizes are equal
            if (Files.size(path1) != Files.size(path2)) {
                return false;
            }
            
            // Compare file contents
            return Arrays.equals(Files.readAllBytes(path1), Files.readAllBytes(path2));
        } catch (IOException e) {
            LOGGER.warn("Error comparing files {} and {}: {}", file1Path, file2Path, e.getMessage());
            return false;
        }
    }
}



CSBaseTest.java
-------------------------------

package com.cstestforge.framework.playwright.java.base;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.utils.CSConstants;
import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSScreenshotManager;
import com.cstestforge.framework.core.utils.CSDateUtils;
import com.cstestforge.framework.playwright.java.browser.CSPlaywrightManager;
import com.cstestforge.framework.playwright.java.browser.CSBrowserContextManager;
import com.cstestforge.framework.playwright.java.browser.CSPageManager;
import com.microsoft.playwright.Browser;
import com.microsoft.playwright.BrowserContext;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Playwright;
import org.testng.ITestResult;
import org.testng.annotations.AfterClass;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeSuite;
import org.testng.annotations.Listeners;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Base test class for Playwright tests.
 * Provides common functionality for Playwright test classes.
 */
@Listeners({com.cstestforge.framework.playwright.java.listeners.CSPlaywrightTestListener.class})
public abstract class CSBaseTest {
    private static final CSLogger LOGGER = new CSLogger(CSBaseTest.class);
    
    protected Playwright playwright;
    protected Browser browser;
    protected BrowserContext context;
    protected Page page;
    
    protected CSPlaywrightManager playwrightManager;
    protected CSBrowserContextManager contextManager;
    protected CSPageManager pageManager;
    protected CSReporter reporter;
    
    protected ConfigurationManager configManager;
    protected CSScreenshotManager screenshotManager;
    
    private static final ThreadLocal<String> TEST_NAME = new ThreadLocal<>();
    private static final ThreadLocal<String> SESSION_ID = new ThreadLocal<>();
    
    protected String baseUrl;
    protected String testName;
    protected String sessionId;
    protected String screenshotDir;
    protected boolean headless;
    protected String browserType;
    
    /**
     * Setup method that runs before the test suite.
     * Initializes global resources.
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetup() {
        LOGGER.info("Setting up test suite");
        
        // Initialize configuration
        configManager = ConfigurationManager.getInstance();
        
        // Set up reporting directory
        String reportDir = configManager.getString(CSConstants.CONFIG_REPORT_DIR, "reports");
        CSFileUtils.createDirectory(reportDir);
        
        // Set up screenshot directory
        screenshotDir = configManager.getString(CSConstants.CONFIG_SCREENSHOT_DIR, reportDir + "/screenshots");
        CSFileUtils.createDirectory(screenshotDir);
        
        // Initialize reporter
        reporter = initializeReporter();
        
        // Set up global logging
        setupLogging();
        
        // Initialize managers
        playwrightManager = CSPlaywrightManager.getInstance();
        contextManager = new CSBrowserContextManager();
        pageManager = new CSPageManager();
        screenshotManager = new CSScreenshotManager(screenshotDir);
        
        // Load global configuration
        baseUrl = configManager.getString(CSConstants.CONFIG_BASE_URL, "http://localhost");
        headless = configManager.getBoolean(CSConstants.CONFIG_HEADLESS, true);
        browserType = configManager.getString(CSConstants.CONFIG_BROWSER, CSConstants.BROWSER_CHROMIUM);
        
        LOGGER.info("Test suite setup completed");
    }
    
    /**
     * Cleanup method that runs after the test suite.
     * Releases global resources.
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTearDown() {
        LOGGER.info("Tearing down test suite");
        
        // Close all browser instances
        if (playwrightManager != null) {
            playwrightManager.closeAll();
        }
        
        // Close all file channels
        CSFileUtils.closeAllFileChannels();
        
        // Generate final reports
        if (reporter != null) {
            reporter.generateSummaryReport();
        }
        
        LOGGER.info("Test suite teardown completed");
    }
    
    /**
     * Setup method that runs before each test class.
     * Initializes class-level resources.
     */
    @BeforeClass(alwaysRun = true)
    public void classSetup() {
        LOGGER.info("Setting up test class: {}", getClass().getSimpleName());
        
        // Generate a unique session ID for this test class
        sessionId = generateSessionId();
        SESSION_ID.set(sessionId);
        
        // Initialize Playwright and browser
        initializeBrowser();
        
        LOGGER.info("Test class setup completed");
    }
    
    /**
     * Cleanup method that runs after each test class.
     * Releases class-level resources.
     */
    @AfterClass(alwaysRun = true)
    public void classTearDown() {
        LOGGER.info("Tearing down test class: {}", getClass().getSimpleName());
        
        // Close the browser context and page
        if (contextManager != null && context != null) {
            contextManager.closeContext(sessionId);
            context = null;
        }
        
        // Close the browser instance
        if (playwrightManager != null && browser != null && playwright != null) {
            playwrightManager.closeBrowser(browser, sessionId);
            browser = null;
            playwright = null;
        }
        
        // Clear thread local variables
        SESSION_ID.remove();
        
        LOGGER.info("Test class teardown completed");
    }
    
    /**
     * Setup method that runs before each test method.
     * Initializes method-level resources.
     * 
     * @param method The test method
     */
    @BeforeMethod(alwaysRun = true)
    public void methodSetup(Method method) {
        // Set test name from method name
        testName = method.getName();
        TEST_NAME.set(testName);
        
        LOGGER.info("Setting up test method: {}", testName);
        
        // Set up context data for logging
        CSLogger.setTestName(testName);
        CSLogger.setBrowser(browserType);
        CSLogger.setEnvironment(configManager.getCurrentEnvironment());
        
        // Initialize browser context and page for this test method
        initializeContext();
        initializePage();
        
        // Start test in reporter
        if (reporter != null) {
            reporter.startTest(getClass().getName(), testName);
        }
        
        LOGGER.info("Test method setup completed");
    }
    
    /**
     * Cleanup method that runs after each test method.
     * Releases method-level resources and handles test results.
     * 
     * @param result The test result
     */
    @AfterMethod(alwaysRun = true)
    public void methodTearDown(ITestResult result) {
        LOGGER.info("Tearing down test method: {}", testName);
        
        // Handle test result
        handleTestResult(result);
        
        // Close the page
        if (pageManager != null && page != null) {
            pageManager.closePage(sessionId + "_" + testName);
            page = null;
        }
        
        // Clean up thread local variables
        TEST_NAME.remove();
        
        // Clear context data from logging
        CSLogger.clearContext();
        
        LOGGER.info("Test method teardown completed");
    }
    
    /**
     * Initializes the browser for testing.
     */
    protected void initializeBrowser() {
        LOGGER.info("Initializing browser: {}, headless: {}", browserType, headless);
        
        try {
            // Get Playwright instance
            playwright = playwrightManager.getPlaywright(sessionId);
            
            // Launch browser
            browser = playwrightManager.launchBrowser(browserType, headless, sessionId);
            
            LOGGER.info("Browser initialized successfully");
        } catch (Exception e) {
            LOGGER.error("Error initializing browser: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to initialize browser", e);
        }
    }
    
    /**
     * Initializes the browser context for testing.
     */
    protected void initializeContext() {
        LOGGER.info("Initializing browser context");
        
        try {
            if (context != null) {
                contextManager.closeContext(sessionId);
                context = null;
            }
            
            context = contextManager.createContext(browser, sessionId);
            
            // Configure the context
            setupContextDefaults(context);
            
            LOGGER.info("Browser context initialized successfully");
        } catch (Exception e) {
            LOGGER.error("Error initializing browser context: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to initialize browser context", e);
        }
    }
    
    /**
     * Initializes the page for testing.
     */
    protected void initializePage() {
        LOGGER.info("Initializing page");
        
        try {
            page = pageManager.createPage(context, sessionId, sessionId + "_" + testName);
            
            // Setup page event handlers
            setupPageEventHandlers();
            
            LOGGER.info("Page initialized successfully");
        } catch (Exception e) {
            LOGGER.error("Error initializing page: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to initialize page", e);
        }
    }
    
    /**
     * Sets up default settings for the browser context.
     * 
     * @param context The browser context to configure, overridable by child classes to customize context defaults
     */
    protected void setupContextDefaults(BrowserContext context) {
        // Override in subclasses to customize
    }
    
    /**
     * Sets up page event handlers.
     */
    protected void setupPageEventHandlers() {
        if (page != null) {
            // Handle page errors
            page.onPageError(error -> {
                LOGGER.error("Page error: {}", error);
                if (reporter != null) {
                    reporter.logError("Page JavaScript error: " + error);
                }
            });
            
            // Handle console messages
            page.onConsoleMessage(message -> {
                String msgType = message.type().toString().toLowerCase();
                String text = message.text();
                
                if ("error".equals(msgType)) {
                    LOGGER.error("Console error: {}", text);
                    if (reporter != null) {
                        reporter.logError("Console error: " + text);
                    }
                } else if ("warning".equals(msgType)) {
                    LOGGER.warn("Console warning: {}", text);
                    if (reporter != null) {
                        reporter.logWarning("Console warning: " + text);
                    }
                } else {
                    LOGGER.debug("Console {}: {}", msgType, text);
                }
            });
            
            // Handle dialogs (alerts, confirms, prompts)
            page.onDialog(dialog -> {
                String message = dialog.message();
                String type = dialog.type().toString().toLowerCase();
                
                LOGGER.info("Dialog {}: {}", type, message);
                if (reporter != null) {
                    reporter.logInfo("Dialog " + type + ": " + message);
                }
                
                // Auto-dismiss dialogs unless overridden in subclasses
                handleDialog(dialog);
            });
        }
    }
    
    /**
     * Handles browser dialogs.
     * Override this method to customize dialog handling.
     * 
     * @param dialog The dialog to handle
     */
    protected void handleDialog(Page.Dialog dialog) {
        // Default behavior is to dismiss dialogs
        dialog.dismiss();
    }
    
    /**
     * Handles test result.
     * 
     * @param result The test result
     */
    protected void handleTestResult(ITestResult result) {
        int status = result.getStatus();
        String statusName;
        
        switch (status) {
            case ITestResult.SUCCESS:
                statusName = "PASSED";
                if (reporter != null) {
                    reporter.logPass("Test passed");
                }
                break;
            case ITestResult.FAILURE:
                statusName = "FAILED";
                // Capture screenshot on failure
                String screenshotPath = captureScreenshot("failure");
                if (reporter != null) {
                    reporter.logFail("Test failed: " + result.getThrowable().getMessage(), screenshotPath);
                }
                break;
            case ITestResult.SKIP:
                statusName = "SKIPPED";
                if (reporter != null) {
                    reporter.logSkip("Test skipped: " + (result.getThrowable() != null ? result.getThrowable().getMessage() : ""));
                }
                break;
            default:
                statusName = "UNKNOWN";
                if (reporter != null) {
                    reporter.logWarning("Test status unknown: " + status);
                }
        }
        
        LOGGER.info("Test {} {}", testName, statusName);
        
        // End test in reporter
        if (reporter != null) {
            reporter.endTest();
        }
    }
    
    /**
     * Initializes the reporter.
     * 
     * @return The initialized reporter
     */
    protected CSReporter initializeReporter() {
        // Implementation depends on the specific reporter being used
        // This is a placeholder that should be overridden
        return null;
    }
    
    /**
     * Sets up logging for the tests.
     */
    protected void setupLogging() {
        // Set up logging level from configuration
        String logLevel = configManager.getString("cstestforge.log.level", "INFO");
        if ("DEBUG".equalsIgnoreCase(logLevel)) {
            CSLogger.setDebugEnabled(true);
        }
        if ("TRACE".equalsIgnoreCase(logLevel)) {
            CSLogger.setTraceEnabled(true);
            CSLogger.setDebugEnabled(true);
        }
    }
    
    /**
     * Navigates to a URL.
     * 
     * @param url The URL to navigate to
     */
    protected void navigateTo(String url) {
        LOGGER.info("Navigating to URL: {}", url);
        
        try {
            pageManager.navigateTo(page, url);
            
            if (reporter != null) {
                reporter.logInfo("Navigated to: " + url);
            }
        } catch (Exception e) {
            LOGGER.error("Error navigating to URL {}: {}", url, e.getMessage(), e);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("navigation_error");
                reporter.logFail("Navigation failed: " + e.getMessage(), screenshotPath);
            }
            
            throw e;
        }
    }
    
    /**
     * Navigates to the base URL.
     */
    protected void navigateToBaseUrl() {
        navigateTo(baseUrl);
    }
    
    /**
     * Captures a screenshot.
     * 
     * @param type The screenshot type (e.g., "failure", "step", etc.)
     * @return The path to the screenshot file
     */
    protected String captureScreenshot(String type) {
        if (page == null) {
            LOGGER.warn("Cannot capture screenshot: page is null");
            return null;
        }
        
        try {
            String fileName = generateScreenshotName(type);
            String filePath = screenshotDir + File.separator + fileName;
            
            LOGGER.debug("Capturing screenshot: {}", filePath);
            
            // Create the screenshot directory if it doesn't exist
            File directory = new File(screenshotDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }
            
            // Capture the screenshot
            page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get(filePath)));
            
            LOGGER.info("Screenshot captured: {}", filePath);
            return filePath;
        } catch (Exception e) {
            LOGGER.error("Error capturing screenshot: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Generates a name for a screenshot.
     * 
     * @param type The screenshot type
     * @return The generated screenshot name
     */
    protected String generateScreenshotName(String type) {
        String timestamp = CSDateUtils.getCurrentTimestampFormatted("yyyyMMdd_HHmmss");
        return String.format("%s_%s_%s.png", testName, type, timestamp);
    }
    
    /**
     * Generates a unique session ID.
     * 
     * @return The generated session ID
     */
    protected String generateSessionId() {
        return getClass().getSimpleName() + "_" + UUID.randomUUID().toString().substring(0, 8);
    }
    
    /**
     * Gets the current test name.
     * 
     * @return The current test name
     */
    public static String getCurrentTestName() {
        return TEST_NAME.get();
    }
    
    /**
     * Gets the current session ID.
     * 
     * @return The current session ID
     */
    public static String getCurrentSessionId() {
        return SESSION_ID.get();
    }
}


CSPlaywrightTestListener.java
---------------------------------------

package com.cstestforge.framework.playwright.java.listeners;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSScreenshotManager;
import com.cstestforge.framework.playwright.java.base.CSBaseTest;
import com.microsoft.playwright.Page;
import org.testng.ITestContext;
import org.testng.ITestListener;
import org.testng.ITestResult;
import org.testng.IConfigurationListener;
import org.testng.IInvokedMethod;
import org.testng.IInvokedMethodListener;
import org.testng.ISuite;
import org.testng.ISuiteListener;

import java.io.File;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * TestNG listener for Playwright tests.
 * Provides lifecycle hooks for test execution events.
 */
public class CSPlaywrightTestListener implements ITestListener, ISuiteListener, IConfigurationListener, IInvokedMethodListener {
    private static final CSLogger LOGGER = new CSLogger(CSPlaywrightTestListener.class);
    
    private final ConfigurationManager configManager;
    private CSReporter reporter;
    private CSScreenshotManager screenshotManager;
    
    private final Map<String, Long> testStartTimes = new HashMap<>();
    private boolean captureScreenshotOnFailure;
    private boolean captureTraceOnFailure;
    private boolean captureVideoOnFailure;
    private String screenshotDir;
    private String traceDir;
    private String videoDir;
    
    /**
     * Constructs a new CSPlaywrightTestListener.
     */
    public CSPlaywrightTestListener() {
        configManager = ConfigurationManager.getInstance();
        
        // Load configuration
        captureScreenshotOnFailure = configManager.getBoolean("cstestforge.screenshot.onFailure", true);
        captureTraceOnFailure = configManager.getBoolean("cstestforge.trace.onFailure", false);
        captureVideoOnFailure = configManager.getBoolean("cstestforge.video.onFailure", false);
        
        // Set up directories
        String reportDir = configManager.getString("cstestforge.report.dir", "reports");
        screenshotDir = configManager.getString("cstestforge.screenshot.dir", reportDir + "/screenshots");
        traceDir = configManager.getString("cstestforge.trace.dir", reportDir + "/traces");
        videoDir = configManager.getString("cstestforge.video.dir", reportDir + "/videos");
        
        // Create directories
        createDirectories();
        
        LOGGER.info("CSPlaywrightTestListener initialized");
    }
    
    /**
     * Creates the required directories for test artifacts.
     */
    private void createDirectories() {
        if (captureScreenshotOnFailure) {
            createDirectory(screenshotDir);
        }
        if (captureTraceOnFailure) {
            createDirectory(traceDir);
        }
        if (captureVideoOnFailure) {
            createDirectory(videoDir);
        }
    }
    
    /**
     * Creates a directory if it doesn't exist.
     * 
     * @param dirPath The directory path
     */
    private void createDirectory(String dirPath) {
        File dir = new File(dirPath);
        if (!dir.exists()) {
            boolean created = dir.mkdirs();
            if (!created) {
                LOGGER.warn("Failed to create directory: {}", dirPath);
            }
        }
    }
    
    /**
     * Called before a test suite starts.
     * 
     * @param suite The test suite
     */
    @Override
    public void onStart(ISuite suite) {
        LOGGER.info("Test suite started: {}", suite.getName());
        
        // Initialize reporter
        reporter = new CSReporter(suite.getName());
        
        // Initialize screenshot manager
        screenshotManager = new CSScreenshotManager(screenshotDir);
    }
    
    /**
     * Called after a test suite finishes.
     * 
     * @param suite The test suite
     */
    @Override
    public void onFinish(ISuite suite) {
        LOGGER.info("Test suite finished: {}", suite.getName());
        
        // Generate final reports
        if (reporter != null) {
            reporter.generateSummaryReport();
        }
    }
    
    /**
     * Called before a test context starts.
     * 
     * @param context The test context
     */
    @Override
    public void onStart(ITestContext context) {
        LOGGER.info("Test context started: {}", context.getName());
        
        // Set context attributes
        context.setAttribute("reporter", reporter);
        context.setAttribute("screenshotManager", screenshotManager);
    }
    
    /**
     * Called after a test context finishes.
     * 
     * @param context The test context
     */
    @Override
    public void onFinish(ITestContext context) {
        LOGGER.info("Test context finished: {}", context.getName());
        
        // Clean up context attributes
        context.removeAttribute("reporter");
        context.removeAttribute("screenshotManager");
    }
    
    /**
     * Called when a test method is about to start.
     * 
     * @param result The test result
     */
    @Override
    public void onTestStart(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        LOGGER.info("Test started: {}", testName);
        
        // Record test start time
        testStartTimes.put(testName, System.currentTimeMillis());
        
        // Start test in reporter
        if (reporter != null) {
            reporter.startTest(result.getTestClass().getName(), testName);
            
            // Log test parameters if present
            Object[] parameters = result.getParameters();
            if (parameters != null && parameters.length > 0) {
                String params = Arrays.stream(parameters)
                    .map(this::formatParameter)
                    .collect(Collectors.joining(", "));
                reporter.logInfo("Test parameters: " + params);
            }
        }
    }
    
    /**
     * Called when a test method succeeds.
     * 
     * @param result The test result
     */
    @Override
    public void onTestSuccess(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        long duration = getDuration(testName);
        
        LOGGER.info("Test passed: {} ({}ms)", testName, duration);
        
        // Log test success in reporter
        if (reporter != null) {
            reporter.logPass("Test passed");
            reporter.logInfo("Test duration: " + duration + "ms");
            reporter.endTest();
        }
    }
    
    /**
     * Called when a test method fails.
     * 
     * @param result The test result
     */
    @Override
    public void onTestFailure(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        long duration = getDuration(testName);
        
        LOGGER.error("Test failed: {} ({}ms)", testName, duration);
        LOGGER.error("Failure reason: {}", result.getThrowable().getMessage());
        
        // Capture failure artifacts
        String screenshotPath = null;
        String tracePath = null;
        
        if (captureScreenshotOnFailure) {
            screenshotPath = captureFailureScreenshot(result);
        }
        
        if (captureTraceOnFailure) {
            tracePath = captureFailureTrace(result);
        }
        
        // Log test failure in reporter
        if (reporter != null) {
            Throwable throwable = result.getThrowable();
            String errorMessage = throwable != null ? throwable.getMessage() : "Unknown error";
            
            reporter.logFail("Test failed: " + errorMessage, screenshotPath);
            reporter.logInfo("Test duration: " + duration + "ms");
            
            if (tracePath != null) {
                reporter.logInfo("Trace captured: " + tracePath);
            }
            
            reporter.endTest();
        }
    }
    
    /**
     * Called when a test method is skipped.
     * 
     * @param result The test result
     */
    @Override
    public void onTestSkipped(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        LOGGER.info("Test skipped: {}", testName);
        
        // Log test skip in reporter
        if (reporter != null) {
            Throwable throwable = result.getThrowable();
            String skipMessage = throwable != null ? throwable.getMessage() : "Test skipped";
            
            reporter.logSkip(skipMessage);
            reporter.endTest();
        }
    }
    
    /**
     * Called when a configuration method fails.
     * 
     * @param itr The test result
     */
    @Override
    public void onConfigurationFailure(ITestResult itr) {
        String methodName = itr.getMethod().getMethodName();
        LOGGER.error("Configuration failed: {}", methodName);
        LOGGER.error("Failure reason: {}", itr.getThrowable().getMessage());
        
        // Log configuration failure in reporter
        if (reporter != null) {
            Throwable throwable = itr.getThrowable();
            String errorMessage = throwable != null ? throwable.getMessage() : "Unknown error";
            
            reporter.logError("Configuration failed: " + methodName + " - " + errorMessage);
        }
    }
    
    /**
     * Called when a configuration method is skipped.
     * 
     * @param itr The test result
     */
    @Override
    public void onConfigurationSkip(ITestResult itr) {
        String methodName = itr.getMethod().getMethodName();
        LOGGER.info("Configuration skipped: {}", methodName);
        
        // Log configuration skip in reporter
        if (reporter != null) {
            reporter.logWarning("Configuration skipped: " + methodName);
        }
    }
    
    /**
     * Called when a configuration method succeeds.
     * 
     * @param itr The test result
     */
    @Override
    public void onConfigurationSuccess(ITestResult itr) {
        String methodName = itr.getMethod().getMethodName();
        LOGGER.debug("Configuration succeeded: {}", methodName);
    }
    
    /**
     * Called before a method is invoked.
     * 
     * @param method The invoked method
     * @param testResult The test result
     */
    @Override
    public void beforeInvocation(IInvokedMethod method, ITestResult testResult) {
        // No-op
    }
    
    /**
     * Called after a method is invoked.
     * 
     * @param method The invoked method
     * @param testResult The test result
     */
    @Override
    public void afterInvocation(IInvokedMethod method, ITestResult testResult) {
        // No-op
    }
    
    /**
     * Captures a screenshot when a test fails.
     * 
     * @param result The test result
     * @return The path to the screenshot file, or null if capture failed
     */
    private String captureFailureScreenshot(ITestResult result) {
        try {
            Object instance = result.getInstance();
            if (instance instanceof CSBaseTest) {
                CSBaseTest test = (CSBaseTest) instance;
                Page page = test.page;
                
                if (page != null) {
                    String testName = result.getMethod().getMethodName();
                    String fileName = testName + "_failure_" + System.currentTimeMillis() + ".png";
                    String filePath = screenshotDir + File.separator + fileName;
                    
                    // Create directory if it doesn't exist
                    createDirectory(screenshotDir);
                    
                    // Capture screenshot
                    page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get(filePath)).setFullPage(true));
                    
                    LOGGER.info("Failure screenshot captured: {}", filePath);
                    return filePath;
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error capturing failure screenshot: {}", e.getMessage(), e);
        }
        
        return null;
    }
    
    /**
     * Captures a trace when a test fails.
     * 
     * @param result The test result
     * @return The path to the trace file, or null if capture failed
     */
    private String captureFailureTrace(ITestResult result) {
        try {
            Object instance = result.getInstance();
            if (instance instanceof CSBaseTest) {
                CSBaseTest test = (CSBaseTest) instance;
                Page page = test.page;
                
                if (page != null && test.context != null) {
                    String testName = result.getMethod().getMethodName();
                    String fileName = testName + "_failure_" + System.currentTimeMillis() + ".zip";
                    String filePath = traceDir + File.separator + fileName;
                    
                    // Create directory if it doesn't exist
                    createDirectory(traceDir);
                    
                    // Stop tracing and save to file
                    test.context.tracing().stop(new BrowserContext.TracingStopOptions()
                        .setPath(Paths.get(filePath)));
                    
                    LOGGER.info("Failure trace captured: {}", filePath);
                    return filePath;
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error capturing failure trace: {}", e.getMessage(), e);
        }
        
        return null;
    }
    
    /**
     * Gets the duration of a test in milliseconds.
     * 
     * @param testName The test name
     * @return The test duration in milliseconds
     */
    private long getDuration(String testName) {
        Long startTime = testStartTimes.get(testName);
        if (startTime != null) {
            return System.currentTimeMillis() - startTime;
        }
        return 0;
    }
    
    /**
     * Formats a parameter value for logging.
     * 
     * @param param The parameter value
     * @return The formatted parameter value
     */
    private String formatParameter(Object param) {
        if (param == null) {
            return "null";
        }
        
        if (param instanceof String) {
            return "\"" + param + "\"";
        }
        
        if (param.getClass().isArray()) {
            Class<?> componentType = param.getClass().getComponentType();
            if (componentType.isPrimitive()) {
                if (componentType == byte.class) {
                    return "byte[" + ((byte[]) param).length + "]";
                } else if (componentType == char.class) {
                    return "char[" + ((char[]) param).length + "]";
                } else if (componentType == boolean.class) {
                    return "boolean[" + ((boolean[]) param).length + "]";
                } else if (componentType == short.class) {
                    return "short[" + ((short[]) param).length + "]";
                } else if (componentType == int.class) {
                    return "int[" + ((int[]) param).length + "]";
                } else if (componentType == long.class) {
                    return "long[" + ((long[]) param).length + "]";
                } else if (componentType == float.class) {
                    return "float[" + ((float[]) param).length + "]";
                } else if (componentType == double.class) {
                    return "double[" + ((double[]) param).length + "]";
                }
            }
            
            // Object array
            Object[] array = (Object[]) param;
            return Arrays.stream(array)
                .map(this::formatParameter)
                .collect(Collectors.joining(", ", "[", "]"));
        }
        
        return param.toString();
    }
}



CSBasePage.java
-----------------------
package com.cstestforge.framework.playwright.java.base;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.element.CSElement;
import com.cstestforge.framework.playwright.java.element.CSElementList;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.LoadState;
import com.microsoft.playwright.options.WaitUntilState;

import java.io.File;
import java.lang.reflect.Field;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.function.Supplier;

/**
 * Base page class for Playwright page objects.
 * Provides common functionality for page objects.
 */
public abstract class CSBasePage {
    private static final CSLogger LOGGER = new CSLogger(CSBasePage.class);
    
    protected Page page;
    protected String url;
    protected String pageTitle;
    protected CSReporter reporter;
    protected ConfigurationManager configManager;
    
    /**
     * Constructs a new CSBasePage.
     * 
     * @param page The Playwright page
     */
    public CSBasePage(Page page) {
        this.page = page;
        this.configManager = ConfigurationManager.getInstance();
        LOGGER.debug("Initialized {} page", getClass().getSimpleName());
    }
    
    /**
     * Constructs a new CSBasePage with a reporter.
     * 
     * @param page The Playwright page
     * @param reporter The reporter
     */
    public CSBasePage(Page page, CSReporter reporter) {
        this(page);
        this.reporter = reporter;
    }
    
    /**
     * Initializes page elements using @FindBy annotations.
     */
    public void initElements() {
        LOGGER.debug("Initializing page elements for {}", getClass().getSimpleName());
        
        // Implement page factory to initialize elements with @FindBy annotations
        // This will be replaced by CSPageFactory implementation
        CSPageFactory.initElements(this, page);
    }
    
    /**
     * Checks if the page is loaded.
     * 
     * @return True if the page is loaded, false otherwise
     */
    public boolean isLoaded() {
        LOGGER.debug("Checking if page is loaded: {}", getClass().getSimpleName());
        
        try {
            return isPageTitleCorrect() && areRequiredElementsPresent();
        } catch (Exception e) {
            LOGGER.warn("Error checking if page is loaded: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Checks if the page title is correct.
     * 
     * @return True if the page title is correct, false otherwise
     */
    protected boolean isPageTitleCorrect() {
        if (pageTitle == null || pageTitle.isEmpty()) {
            return true;
        }
        
        String actualTitle = page.title();
        boolean isCorrect = actualTitle.equals(pageTitle);
        
        if (!isCorrect) {
            LOGGER.warn("Page title mismatch. Expected: '{}', Actual: '{}'", pageTitle, actualTitle);
        }
        
        return isCorrect;
    }
    
    /**
     * Checks if required elements are present.
     * Override this method to check for page-specific elements.
     * 
     * @return True if required elements are present, false otherwise
     */
    protected boolean areRequiredElementsPresent() {
        // To be overridden by subclasses
        return true;
    }
    
    /**
     * Waits for the page to be loaded.
     * 
     * @return This page object for chaining
     */
    public CSBasePage waitForPageToLoad() {
        LOGGER.debug("Waiting for page to load: {}", getClass().getSimpleName());
        
        // Wait for the specified load state
        page.waitForLoadState(getLoadState());
        
        // Wait for required elements
        waitForRequiredElements();
        
        LOGGER.info("Page loaded: {}", getClass().getSimpleName());
        return this;
    }
    
    /**
     * Gets the load state to wait for.
     * Override this method to customize the load state.
     * 
     * @return The load state
     */
    protected LoadState getLoadState() {
        String loadState = configManager.getString("playwright.page.loadState", "load");
        switch (loadState.toLowerCase()) {
            case "domcontentloaded":
                return LoadState.DOMCONTENTLOADED;
            case "networkidle":
                return LoadState.NETWORKIDLE;
            case "load":
            default:
                return LoadState.LOAD;
        }
    }
    
    /**
     * Waits for required elements to be present.
     * Override this method to wait for page-specific elements.
     */
    protected void waitForRequiredElements() {
        // To be overridden by subclasses
    }
    
    /**
     * Navigates to the page URL.
     * 
     * @return This page object for chaining
     */
    public CSBasePage navigateTo() {
        if (url == null || url.isEmpty()) {
            throw new IllegalStateException("Page URL is not defined");
        }
        
        return navigateTo(url);
    }
    
    /**
     * Navigates to the specified URL.
     * 
     * @param url The URL to navigate to
     * @return This page object for chaining
     */
    public CSBasePage navigateTo(String url) {
        LOGGER.info("Navigating to URL: {}", url);
        
        try {
            page.navigate(url, 
                new Page.NavigateOptions()
                    .setWaitUntil(getWaitUntilState())
                    .setTimeout(getNavigationTimeout()));
            
            // Wait for the page to be loaded
            waitForPageToLoad();
            
            if (reporter != null) {
                reporter.logInfo("Navigated to: " + url);
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Error navigating to URL {}: {}", url, e.getMessage(), e);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("navigation_error");
                reporter.logFail("Navigation failed: " + e.getMessage(), screenshotPath);
            }
            
            throw new RuntimeException("Failed to navigate to URL: " + url, e);
        }
    }
    
    /**
     * Gets the wait until state for navigation.
     * Override this method to customize the wait until state.
     * 
     * @return The wait until state
     */
    protected WaitUntilState getWaitUntilState() {
        String waitUntil = configManager.getString("playwright.page.waitUntil", "load");
        switch (waitUntil.toLowerCase()) {
            case "domcontentloaded":
                return WaitUntilState.DOMCONTENTLOADED;
            case "networkidle":
                return WaitUntilState.NETWORKIDLE;
            case "commit":
                return WaitUntilState.COMMIT;
            case "load":
            default:
                return WaitUntilState.LOAD;
        }
    }
    
    /**
     * Gets the navigation timeout.
     * Override this method to customize the navigation timeout.
     * 
     * @return The navigation timeout in milliseconds
     */
    protected int getNavigationTimeout() {
        return configManager.getInt("playwright.page.navigationTimeout", 30000);
    }
    
    /**
     * Refreshes the page.
     * 
     * @return This page object for chaining
     */
    public CSBasePage refresh() {
        LOGGER.info("Refreshing page: {}", getClass().getSimpleName());
        
        try {
            page.reload(
                new Page.ReloadOptions()
                    .setWaitUntil(getWaitUntilState())
                    .setTimeout(getNavigationTimeout()));
            
            // Wait for the page to be loaded
            waitForPageToLoad();
            
            if (reporter != null) {
                reporter.logInfo("Page refreshed");
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Error refreshing page: {}", e.getMessage(), e);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("refresh_error");
                reporter.logFail("Page refresh failed: " + e.getMessage(), screenshotPath);
            }
            
            throw new RuntimeException("Failed to refresh page", e);
        }
    }
    
    /**
     * Goes back in browser history.
     * 
     * @return This page object for chaining
     */
    public CSBasePage goBack() {
        LOGGER.info("Navigating back: {}", getClass().getSimpleName());
        
        try {
            page.goBack(
                new Page.GoBackOptions()
                    .setWaitUntil(getWaitUntilState())
                    .setTimeout(getNavigationTimeout()));
            
            // Wait for the page to be loaded
            waitForPageToLoad();
            
            if (reporter != null) {
                reporter.logInfo("Navigated back");
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Error navigating back: {}", e.getMessage(), e);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("navigation_back_error");
                reporter.logFail("Navigation back failed: " + e.getMessage(), screenshotPath);
            }
            
            throw new RuntimeException("Failed to navigate back", e);
        }
    }
    
    /**
     * Goes forward in browser history.
     * 
     * @return This page object for chaining
     */
    public CSBasePage goForward() {
        LOGGER.info("Navigating forward: {}", getClass().getSimpleName());
        
        try {
            page.goForward(
                new Page.GoForwardOptions()
                    .setWaitUntil(getWaitUntilState())
                    .setTimeout(getNavigationTimeout()));
            
            // Wait for the page to be loaded
            waitForPageToLoad();
            
            if (reporter != null) {
                reporter.logInfo("Navigated forward");
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Error navigating forward: {}", e.getMessage(), e);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("navigation_forward_error");
                reporter.logFail("Navigation forward failed: " + e.getMessage(), screenshotPath);
            }
            
            throw new RuntimeException("Failed to navigate forward", e);
        }
    }
    
    /**
     * Gets the page title.
     * 
     * @return The page title
     */
    public String getTitle() {
        return page.title();
    }
    
    /**
     * Gets the page URL.
     * 
     * @return The current page URL
     */
    public String getCurrentUrl() {
        return page.url();
    }
    
    /**
     * Creates a CSElement for the specified selector.
     * 
     * @param selector The selector
     * @return The CSElement
     */
    protected CSElement $(String selector) {
        return new CSElement(page, selector);
    }
    
    /**
     * Creates a CSElementList for the specified selector.
     * 
     * @param selector The selector
     * @return The CSElementList
     */
    protected CSElementList $$(String selector) {
        return new CSElementList(page.locator(selector), selector);
    }
    
    /**
     * Waits for a condition to be met.
     * 
     * @param condition The condition supplier
     * @param timeoutMillis The timeout in milliseconds
     * @param message The timeout message
     * @return This page object for chaining
     */
    protected CSBasePage waitFor(Supplier<Boolean> condition, long timeoutMillis, String message) {
        LOGGER.debug("Waiting for condition: {}", message);
        
        long startTime = System.currentTimeMillis();
        long endTime = startTime + timeoutMillis;
        
        while (System.currentTimeMillis() < endTime) {
            if (condition.get()) {
                LOGGER.debug("Condition met: {}", message);
                return this;
            }
            
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("Interrupted while waiting for condition: " + message, e);
            }
        }
        
        String error = "Timeout waiting for condition: " + message;
        LOGGER.error(error);
        
        if (reporter != null) {
            String screenshotPath = captureScreenshot("timeout_error");
            reporter.logFail(error, screenshotPath);
        }
        
        throw new RuntimeException(error);
    }
    
    /**
     * Waits for an element to be visible.
     * 
     * @param selector The element selector
     * @param timeoutMillis The timeout in milliseconds, or 0 to use the default timeout
     * @return The visible element
     */
    protected CSElement waitForVisible(String selector, long timeoutMillis) {
        LOGGER.debug("Waiting for element to be visible: {}", selector);
        
        try {
            if (timeoutMillis <= 0) {
                timeoutMillis = getDefaultTimeout();
            }
            
            page.waitForSelector(selector, 
                new Page.WaitForSelectorOptions()
                    .setState("visible")
                    .setTimeout(timeoutMillis));
            
            return $(selector);
        } catch (Exception e) {
            String error = "Timeout waiting for element to be visible: " + selector;
            LOGGER.error(error);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("wait_visible_error");
                reporter.logFail(error, screenshotPath);
            }
            
            throw new RuntimeException(error, e);
        }
    }
    
    /**
     * Waits for an element to be visible with the default timeout.
     * 
     * @param selector The element selector
     * @return The visible element
     */
    protected CSElement waitForVisible(String selector) {
        return waitForVisible(selector, 0);
    }
    
    /**
     * Waits for an element to be hidden.
     * 
     * @param selector The element selector
     * @param timeoutMillis The timeout in milliseconds, or 0 to use the default timeout
     * @return This page object for chaining
     */
    protected CSBasePage waitForHidden(String selector, long timeoutMillis) {
        LOGGER.debug("Waiting for element to be hidden: {}", selector);
        
        try {
            if (timeoutMillis <= 0) {
                timeoutMillis = getDefaultTimeout();
            }
            
            page.waitForSelector(selector, 
                new Page.WaitForSelectorOptions()
                    .setState("hidden")
                    .setTimeout(timeoutMillis));
            
            return this;
        } catch (Exception e) {
            String error = "Timeout waiting for element to be hidden: " + selector;
            LOGGER.error(error);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("wait_hidden_error");
                reporter.logFail(error, screenshotPath);
            }
            
            throw new RuntimeException(error, e);
        }
    }
    
    /**
     * Waits for an element to be hidden with the default timeout.
     * 
     * @param selector The element selector
     * @return This page object for chaining
     */
    protected CSBasePage waitForHidden(String selector) {
        return waitForHidden(selector, 0);
    }
    
    /**
     * Executes JavaScript.
     * 
     * @param script The JavaScript to execute
     * @param args The arguments to pass to the script
     * @return The result of the script execution
     */
    protected Object executeScript(String script, Object... args) {
        LOGGER.debug("Executing JavaScript: {}", script);
        return page.evaluate(script, args);
    }
    
    /**
     * Captures a screenshot.
     * 
     * @param type The screenshot type (e.g., "error", "step", etc.)
     * @return The path to the screenshot file
     */
    protected String captureScreenshot(String type) {
        LOGGER.debug("Capturing screenshot: {}", type);
        
        try {
            String screenshotDir = configManager.getString("cstestforge.screenshot.dir", "reports/screenshots");
            String className = getClass().getSimpleName();
            String timestamp = String.valueOf(System.currentTimeMillis());
            String fileName = className + "_" + type + "_" + timestamp + ".png";
            String filePath = screenshotDir + File.separator + fileName;
            
            // Create screenshot directory if it doesn't exist
            File directory = new File(screenshotDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }
            
            // Capture the screenshot
            page.screenshot(
                new Page.ScreenshotOptions()
                    .setPath(Paths.get(filePath))
                    .setFullPage(true));
            
            LOGGER.info("Screenshot captured: {}", filePath);
            return filePath;
        } catch (Exception e) {
            LOGGER.error("Error capturing screenshot: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Gets the default timeout.
     * 
     * @return The default timeout in milliseconds
     */
    protected int getDefaultTimeout() {
        return configManager.getInt("playwright.page.timeout", 30000);
    }
    
    /**
     * Waits for a network request matching the specified URL pattern.
     * 
     * @param urlPattern The URL pattern to match
     * @param timeoutMillis The timeout in milliseconds, or 0 to use the default timeout
     * @return This page object for chaining
     */
    protected CSBasePage waitForRequest(String urlPattern, long timeoutMillis) {
        LOGGER.debug("Waiting for request matching pattern: {}", urlPattern);
        
        try {
            if (timeoutMillis <= 0) {
                timeoutMillis = getDefaultTimeout();
            }
            
            page.waitForRequest(urlPattern, 
                new Page.WaitForRequestOptions()
                    .setTimeout(timeoutMillis));
            
            return this;
        } catch (Exception e) {
            String error = "Timeout waiting for request matching pattern: " + urlPattern;
            LOGGER.error(error);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("wait_request_error");
                reporter.logFail(error, screenshotPath);
            }
            
            throw new RuntimeException(error, e);
        }
    }
    
    /**
     * Waits for a network request matching the specified URL pattern with the default timeout.
     * 
     * @param urlPattern The URL pattern to match
     * @return This page object for chaining
     */
    protected CSBasePage waitForRequest(String urlPattern) {
        return waitForRequest(urlPattern, 0);
    }
    
    /**
     * Waits for a network response matching the specified URL pattern.
     * 
     * @param urlPattern The URL pattern to match
     * @param timeoutMillis The timeout in milliseconds, or 0 to use the default timeout
     * @return This page object for chaining
     */
    protected CSBasePage waitForResponse(String urlPattern, long timeoutMillis) {
        LOGGER.debug("Waiting for response matching pattern: {}", urlPattern);
        
        try {
            if (timeoutMillis <= 0) {
                timeoutMillis = getDefaultTimeout();
            }
            
            page.waitForResponse(urlPattern, 
                new Page.WaitForResponseOptions()
                    .setTimeout(timeoutMillis));
            
            return this;
        } catch (Exception e) {
            String error = "Timeout waiting for response matching pattern: " + urlPattern;
            LOGGER.error(error);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("wait_response_error");
                reporter.logFail(error, screenshotPath);
            }
            
            throw new RuntimeException(error, e);
        }
    }
    
    /**
     * Waits for a network response matching the specified URL pattern with the default timeout.
     * 
     * @param urlPattern The URL pattern to match
     * @return This page object for chaining
     */
    protected CSBasePage waitForResponse(String urlPattern) {
        return waitForResponse(urlPattern, 0);
    }
    
    /**
     * Waits for a specified duration.
     * 
     * @param milliseconds The duration to wait in milliseconds
     * @return This page object for chaining
     */
    protected CSBasePage wait(long milliseconds) {
        LOGGER.debug("Waiting for {} milliseconds", milliseconds);
        
        try {
            Thread.sleep(milliseconds);
            return this;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Interrupted while waiting", e);
        }
    }
    
    /**
     * Closes the current page.
     */
    public void close() {
        LOGGER.info("Closing page: {}", getClass().getSimpleName());
        
        try {
            page.close();
        } catch (Exception e) {
            LOGGER.error("Error closing page: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Performs a sequence of actions and waits for each action to complete.
     * This is useful for performing a series of operations that must be done in order.
     * 
     * @param actions The actions to perform
     * @return This page object for chaining
     */
    @SafeVarargs
    protected final CSBasePage sequence(Supplier<CSBasePage>... actions) {
        for (Supplier<CSBasePage> action : actions) {
            action.get();
        }
        return this;
    }
    
    /**
     * Retries an action until it succeeds or a timeout is reached.
     * 
     * @param action The action to retry
     * @param retries The maximum number of retries
     * @param intervalMillis The interval between retries in milliseconds
     * @return The result of the action
     */
    protected <T> T retry(Supplier<T> action, int retries, long intervalMillis) {
        Exception lastException = null;
        
        for (int attempt = 1; attempt <= retries; attempt++) {
            try {
                return action.get();
            } catch (Exception e) {
                lastException = e;
                LOGGER.warn("Attempt {} failed: {}", attempt, e.getMessage());
                
                if (attempt < retries) {
                    try {
                        Thread.sleep(intervalMillis);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException("Interrupted while waiting for retry", ie);
                    }
                }
            }
        }
        
        throw new RuntimeException("Action failed after " + retries + " attempts", lastException);
    }
    
    /**
     * Performs an action with a timeout.
     * 
     * @param action The action to perform
     * @param timeoutMillis The timeout in milliseconds
     * @return The result of the action
     */
    protected <T> T withTimeout(Supplier<T> action, long timeoutMillis) {
        LOGGER.debug("Executing action with timeout: {} ms", timeoutMillis);
        
        long startTime = System.currentTimeMillis();
        Exception lastException = null;
        
        while (System.currentTimeMillis() - startTime < timeoutMillis) {
            try {
                return action.get();
            } catch (Exception e) {
                lastException = e;
                LOGGER.debug("Action failed, retrying: {}", e.getMessage());
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for action timeout", ie);
                }
            }
        }
        
        throw new RuntimeException("Action timed out after " + timeoutMillis + " ms", lastException);
    }
    
    /**
     * Sets the reporter.
     * 
     * @param reporter The reporter
     */
    public void setReporter(CSReporter reporter) {
        this.reporter = reporter;
    }
    
    /**
     * Gets the Playwright page.
     * 
     * @return The Playwright page
     */
    public Page getPage() {
        return page;
    }
    
    /**
     * Sets the page URL.
     * 
     * @param url The page URL
     */
    public void setUrl(String url) {
        this.url = url;
    }
    
    /**
     * Sets the expected page title.
     * 
     * @param pageTitle The expected page title
     */
    public void setPageTitle(String pageTitle) {
        this.pageTitle = pageTitle;
    }
}



CSPageFactory.java
-------------------------------

package com.cstestforge.framework.playwright.java.base;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.annotations.CSFindBy;
import com.cstestforge.framework.playwright.java.element.CSElement;
import com.cstestforge.framework.playwright.java.element.CSElementList;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Factory for creating and initializing page objects with element fields.
 * Supports the @CSFindBy annotation for locating elements.
 */
public class CSPageFactory {
    private static final CSLogger LOGGER = new CSLogger(CSPageFactory.class);
    
    // Cache of field decorators for better performance
    private static final ConcurrentMap<Class<?>, FieldDecorator> FIELD_DECORATORS = new ConcurrentHashMap<>();
    
    /**
     * Private constructor to prevent instantiation.
     */
    private CSPageFactory() {
        throw new UnsupportedOperationException("This is a utility class and cannot be instantiated");
    }
    
    /**
     * Initializes elements in a page object.
     * 
     * @param pageObject The page object to initialize
     * @param page The Playwright page
     */
    public static void initElements(Object pageObject, Page page) {
        LOGGER.debug("Initializing elements for {}", pageObject.getClass().getSimpleName());
        
        // Get or create field decorator for the class
        Class<?> pageObjectClass = pageObject.getClass();
        FieldDecorator decorator = FIELD_DECORATORS.computeIfAbsent(
            pageObjectClass,
            clazz -> new DefaultFieldDecorator(page)
        );
        
        // Initialize fields
        Field[] fields = pageObjectClass.getDeclaredFields();
        for (Field field : fields) {
            initializeField(pageObject, field, decorator);
        }
        
        // Initialize fields from superclasses
        Class<?> superClass = pageObjectClass.getSuperclass();
        while (superClass != null && !superClass.equals(Object.class)) {
            fields = superClass.getDeclaredFields();
            for (Field field : fields) {
                initializeField(pageObject, field, decorator);
            }
            superClass = superClass.getSuperclass();
        }
    }
    
    /**
     * Initializes a field in a page object.
     * 
     * @param pageObject The page object
     * @param field The field to initialize
     * @param decorator The field decorator
     */
    private static void initializeField(Object pageObject, Field field, FieldDecorator decorator) {
        // Check if the field has the @CSFindBy annotation
        CSFindBy findBy = field.getAnnotation(CSFindBy.class);
        if (findBy != null) {
            boolean accessible = field.canAccess(pageObject);
            try {
                if (!accessible) {
                    field.setAccessible(true);
                }
                
                // Decorate the field
                Object value = decorator.decorate(field, findBy);
                if (value != null) {
                    field.set(pageObject, value);
                    LOGGER.debug("Initialized field {} in {}", field.getName(), pageObject.getClass().getSimpleName());
                }
            } catch (IllegalAccessException e) {
                LOGGER.error("Could not access field {} in {}: {}", field.getName(), pageObject.getClass().getSimpleName(), e.getMessage(), e);
            } finally {
                if (!accessible) {
                    field.setAccessible(false);
                }
            }
        }
    }
    
    /**
     * Creates a page object of the specified class.
     * 
     * @param pageObjectClass The page object class
     * @param page The Playwright page
     * @param <T> The page object type
     * @return The initialized page object
     */
    public static <T> T createPage(Class<T> pageObjectClass, Page page) {
        LOGGER.debug("Creating page object of type {}", pageObjectClass.getSimpleName());
        
        try {
            // Create a new instance of the page object
            T pageObject = pageObjectClass.getDeclaredConstructor(Page.class).newInstance(page);
            
            // Initialize elements
            initElements(pageObject, page);
            
            return pageObject;
        } catch (Exception e) {
            LOGGER.error("Could not create page object of type {}: {}", pageObjectClass.getSimpleName(), e.getMessage(), e);
            throw new RuntimeException("Failed to create page object of type " + pageObjectClass.getSimpleName(), e);
        }
    }
    
    /**
     * Interface for field decorators.
     */
    private interface FieldDecorator {
        /**
         * Decorates a field.
         * 
         * @param field The field to decorate
         * @param findBy The @CSFindBy annotation
         * @return The decorated field value
         */
        Object decorate(Field field, CSFindBy findBy);
    }
    
    /**
     * Default implementation of FieldDecorator.
     */
    private static class DefaultFieldDecorator implements FieldDecorator {
        private final Page page;
        
        /**
         * Constructs a new DefaultFieldDecorator.
         * 
         * @param page The Playwright page
         */
        public DefaultFieldDecorator(Page page) {
            this.page = page;
        }
        
        /**
         * Decorates a field.
         * 
         * @param field The field to decorate
         * @param findBy The @CSFindBy annotation
         * @return The decorated field value
         */
        @Override
        public Object decorate(Field field, CSFindBy findBy) {
            Class<?> fieldType = field.getType();
            String selector = getSelector(findBy);
            
            if (selector.isEmpty()) {
                LOGGER.warn("Empty selector for field {} in {}", field.getName(), field.getDeclaringClass().getSimpleName());
                return null;
            }
            
            // Handle CSElement fields
            if (fieldType.equals(CSElement.class)) {
                return new CSElement(page, selector);
            }
            
            // Handle CSElementList fields
            if (fieldType.equals(CSElementList.class)) {
                return new CSElementList(page.locator(selector), selector);
            }
            
            // Handle List<CSElement> fields
            if (fieldType.equals(List.class)) {
                Type genericType = field.getGenericType();
                if (genericType instanceof ParameterizedType) {
                    Type[] typeArguments = ((ParameterizedType) genericType).getActualTypeArguments();
                    if (typeArguments.length == 1 && typeArguments[0].equals(CSElement.class)) {
                        return new CSElementList(page.locator(selector), selector);
                    }
                }
            }
            
            // Handle raw Playwright Locator fields
            if (fieldType.equals(Locator.class)) {
                return page.locator(selector);
            }
            
            LOGGER.warn("Unsupported field type {} for field {} in {}", fieldType.getSimpleName(), field.getName(), field.getDeclaringClass().getSimpleName());
            return null;
        }
        
        /**
         * Gets the selector from the @CSFindBy annotation.
         * 
         * @param findBy The @CSFindBy annotation
         * @return The selector
         */
        private String getSelector(CSFindBy findBy) {
            if (!findBy.css().isEmpty()) {
                return findBy.css();
            }
            
            if (!findBy.xpath().isEmpty()) {
                return findBy.xpath();
            }
            
            if (!findBy.id().isEmpty()) {
                return "#" + findBy.id();
            }
            
            if (!findBy.text().isEmpty()) {
                return "text=" + findBy.text();
            }
            
            if (!findBy.testId().isEmpty()) {
                return "data-testid=" + findBy.testId();
            }
            
            if (!findBy.ariaRole().isEmpty()) {
                String role = findBy.ariaRole();
                String name = findBy.ariaName();
                
                if (!name.isEmpty()) {
                    return "role=" + role + "[name=\"" + name + "\"]";
                } else {
                    return "role=" + role;
                }
            }
            
            return findBy.value();
        }
    }
}


CSFindBy.java
-------------------------

package com.cstestforge.framework.playwright.java.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation used to mark fields in page objects that should be initialized with elements.
 * Provides various selector strategies for finding elements.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface CSFindBy {
    /**
     * CSS selector.
     * 
     * @return The CSS selector
     */
    String css() default "";
    
    /**
     * XPath selector.
     * 
     * @return The XPath selector
     */
    String xpath() default "";
    
    /**
     * ID selector.
     * 
     * @return The ID selector
     */
    String id() default "";
    
    /**
     * Text selector.
     * 
     * @return The text selector
     */
    String text() default "";
    
    /**
     * Test ID selector (data-testid attribute).
     * 
     * @return The test ID selector
     */
    String testId() default "";
    
    /**
     * ARIA role selector.
     * 
     * @return The ARIA role selector
     */
    String ariaRole() default "";
    
    /**
     * ARIA name selector (used with ariaRole).
     * 
     * @return The ARIA name selector
     */
    String ariaName() default "";
    
    /**
     * Generic selector value.
     * Used if none of the specific selector types are provided.
     * 
     * @return The generic selector value
     */
    String value() default "";
    
    /**
     * Frame selector.
     * If provided, the element will be searched within this frame.
     * 
     * @return The frame selector
     */
    String frame() default "";
    
    /**
     * Timeout for finding the element.
     * 
     * @return The timeout in milliseconds
     */
    int timeout() default 0;
    
    /**
     * Whether to wait for the element to be visible.
     * 
     * @return True to wait for visibility, false otherwise
     */
    boolean waitForVisible() default false;
    
    /**
     * Whether to wait for the element to be enabled.
     * 
     * @return True to wait for enabled state, false otherwise
     */
    boolean waitForEnabled() default false;
    
    /**
     * Index for finding a specific element when multiple elements match the selector.
     * 
     * @return The element index (0-based)
     */
    int index() default -1;
    
    /**
     * Description of the element for logging and reporting.
     * 
     * @return The element description
     */
    String description() default "";
    
    /**
     * Whether the element is required.
     * If true and the element is not found, an exception will be thrown.
     * 
     * @return True if the element is required, false otherwise
     */
    boolean required() default true;
    
    /**
     * Whether the element is lazy-initialized.
     * If true, the element will be initialized only when accessed.
     * 
     * @return True if the element is lazy-initialized, false otherwise
     */
    boolean lazy() default false;
    
    /**
     * Whether to use shadow DOM penetration.
     * If true, the selector will penetrate shadow DOM boundaries.
     * 
     * @return True to penetrate shadow DOM, false otherwise
     */
    boolean shadow() default false;
    
    /**
     * Has text constraint for the selector.
     * If not empty, the element must have this text.
     * 
     * @return The text constraint
     */
    String hasText() default "";
    
    /**
     * Has attribute constraint for the selector.
     * If not empty, the element must have this attribute (format: name=value).
     * 
     * @return The attribute constraint
     */
    String hasAttribute() default "";
}


CSDateUtils.java
---------------------------


package com.cstestforge.framework.core.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.DayOfWeek;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalAdjusters;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Utility class for date and time operations.
 * Provides methods for date manipulation, formatting, and comparison.
 */
public final class CSDateUtils {
    private static final CSLogger LOGGER = new CSLogger(CSDateUtils.class);
    
    // Cache of date formatters for better performance
    private static final ConcurrentMap<String, DateTimeFormatter> FORMATTER_CACHE = new ConcurrentHashMap<>();
    
    // Common date formats
    public static final String ISO_DATE_FORMAT = "yyyy-MM-dd";
    public static final String ISO_TIME_FORMAT = "HH:mm:ss";
    public static final String ISO_DATETIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";
    public static final String ISO_DATETIME_MS_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSS";
    public static final String ISO_DATETIME_TZ_FORMAT = "yyyy-MM-dd'T'HH:mm:ssXXX";
    public static final String ISO_DATETIME_MS_TZ_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX";
    public static final String SIMPLE_DATE_FORMAT = "MM/dd/yyyy";
    public static final String SIMPLE_DATETIME_FORMAT = "MM/dd/yyyy HH:mm:ss";
    public static final String FILENAME_DATETIME_FORMAT = "yyyyMMdd_HHmmss";
    public static final String HUMAN_READABLE_DATETIME = "MMM d, yyyy h:mm a";
    
    /**
     * Private constructor to prevent instantiation.
     */
    private CSDateUtils() {
        throw new UnsupportedOperationException("This is a utility class and cannot be instantiated");
    }
    
    /**
     * Gets the current timestamp.
     * 
     * @return The current timestamp in milliseconds
     */
    public static long getCurrentTimestamp() {
        return System.currentTimeMillis();
    }
    
    /**
     * Gets the current date.
     * 
     * @return The current date
     */
    public static Date getCurrentDate() {
        return new Date();
    }
    
    /**
     * Gets the current local date.
     * 
     * @return The current local date
     */
    public static LocalDate getCurrentLocalDate() {
        return LocalDate.now();
    }
    
    /**
     * Gets the current local time.
     * 
     * @return The current local time
     */
    public static LocalTime getCurrentLocalTime() {
        return LocalTime.now();
    }
    
    /**
     * Gets the current local date and time.
     * 
     * @return The current local date and time
     */
    public static LocalDateTime getCurrentLocalDateTime() {
        return LocalDateTime.now();
    }
    
    /**
     * Gets the current zoned date and time in the system default time zone.
     * 
     * @return The current zoned date and time
     */
    public static ZonedDateTime getCurrentZonedDateTime() {
        return ZonedDateTime.now();
    }
    
    /**
     * Gets the current zoned date and time in the specified time zone.
     * 
     * @param zoneId The time zone ID
     * @return The current zoned date and time in the specified time zone
     */
    public static ZonedDateTime getCurrentZonedDateTime(String zoneId) {
        return ZonedDateTime.now(ZoneId.of(zoneId));
    }
    
    /**
     * Gets the current instant.
     * 
     * @return The current instant
     */
    public static Instant getCurrentInstant() {
        return Instant.now();
    }
    
    /**
     * Formats the current timestamp.
     * 
     * @param pattern The date format pattern
     * @return The formatted current timestamp
     */
    public static String getCurrentTimestampFormatted(String pattern) {
        DateTimeFormatter formatter = getFormatter(pattern);
        return LocalDateTime.now().format(formatter);
    }
    
    /**
     * Formats the current timestamp in ISO 8601 format.
     * 
     * @return The formatted current timestamp
     */
    public static String getCurrentTimestampIso() {
        return getCurrentTimestampFormatted(ISO_DATETIME_MS_TZ_FORMAT);
    }
    
    /**
     * Formats a date.
     * 
     * @param date The date to format
     * @param pattern The date format pattern
     * @return The formatted date
     */
    public static String formatDate(Date date, String pattern) {
        if (date == null) {
            return null;
        }
        
        return formatLocalDateTime(toLocalDateTime(date), pattern);
    }
    
    /**
     * Formats a local date.
     * 
     * @param localDate The local date to format
     * @param pattern The date format pattern
     * @return The formatted local date
     */
    public static String formatLocalDate(LocalDate localDate, String pattern) {
        if (localDate == null) {
            return null;
        }
        
        DateTimeFormatter formatter = getFormatter(pattern);
        return localDate.format(formatter);
    }
    
    /**
     * Formats a local time.
     * 
     * @param localTime The local time to format
     * @param pattern The time format pattern
     * @return The formatted local time
     */
    public static String formatLocalTime(LocalTime localTime, String pattern) {
        if (localTime == null) {
            return null;
        }
        
        DateTimeFormatter formatter = getFormatter(pattern);
        return localTime.format(formatter);
    }
    
    /**
     * Formats a local date and time.
     * 
     * @param localDateTime The local date and time to format
     * @param pattern The date and time format pattern
     * @return The formatted local date and time
     */
    public static String formatLocalDateTime(LocalDateTime localDateTime, String pattern) {
        if (localDateTime == null) {
            return null;
        }
        
        DateTimeFormatter formatter = getFormatter(pattern);
        return localDateTime.format(formatter);
    }
    
    /**
     * Formats a zoned date and time.
     * 
     * @param zonedDateTime The zoned date and time to format
     * @param pattern The date and time format pattern
     * @return The formatted zoned date and time
     */
    public static String formatZonedDateTime(ZonedDateTime zonedDateTime, String pattern) {
        if (zonedDateTime == null) {
            return null;
        }
        
        DateTimeFormatter formatter = getFormatter(pattern);
        return zonedDateTime.format(formatter);
    }
    
    /**
     * Parses a date string.
     * 
     * @param dateString The date string to parse
     * @param pattern The date format pattern
     * @return The parsed date
     */
    public static Date parseDate(String dateString, String pattern) {
        if (dateString == null || dateString.isEmpty()) {
            return null;
        }
        
        try {
            SimpleDateFormat sdf = new SimpleDateFormat(pattern);
            sdf.setLenient(false);
            return sdf.parse(dateString);
        } catch (ParseException e) {
            LOGGER.warn("Failed to parse date '{}' with pattern '{}': {}", dateString, pattern, e.getMessage());
            return null;
        }
    }
    
    /**
     * Parses a local date string.
     * 
     * @param dateString The date string to parse
     * @param pattern The date format pattern
     * @return The parsed local date
     */
    public static LocalDate parseLocalDate(String dateString, String pattern) {
        if (dateString == null || dateString.isEmpty()) {
            return null;
        }
        
        try {
            DateTimeFormatter formatter = getFormatter(pattern);
            return LocalDate.parse(dateString, formatter);
        } catch (DateTimeParseException e) {
            LOGGER.warn("Failed to parse local date '{}' with pattern '{}': {}", dateString, pattern, e.getMessage());
            return null;
        }
    }
    
    /**
     * Parses a local time string.
     * 
     * @param timeString The time string to parse
     * @param pattern The time format pattern
     * @return The parsed local time
     */
    public static LocalTime parseLocalTime(String timeString, String pattern) {
        if (timeString == null || timeString.isEmpty()) {
            return null;
        }
        
        try {
            DateTimeFormatter formatter = getFormatter(pattern);
            return LocalTime.parse(timeString, formatter);
        } catch (DateTimeParseException e) {
            LOGGER.warn("Failed to parse local time '{}' with pattern '{}': {}", timeString, pattern, e.getMessage());
            return null;
        }
    }
    
    /**
     * Parses a local date and time string.
     * 
     * @param dateTimeString The date and time string to parse
     * @param pattern The date and time format pattern
     * @return The parsed local date and time
     */
    public static LocalDateTime parseLocalDateTime(String dateTimeString, String pattern) {
        if (dateTimeString == null || dateTimeString.isEmpty()) {
            return null;
        }
        
        try {
            DateTimeFormatter formatter = getFormatter(pattern);
            return LocalDateTime.parse(dateTimeString, formatter);
        } catch (DateTimeParseException e) {
            LOGGER.warn("Failed to parse local date time '{}' with pattern '{}': {}", dateTimeString, pattern, e.getMessage());
            return null;
        }
    }
    
    /**
     * Parses a zoned date and time string.
     * 
     * @param dateTimeString The date and time string to parse
     * @param pattern The date and time format pattern
     * @return The parsed zoned date and time
     */
    public static ZonedDateTime parseZonedDateTime(String dateTimeString, String pattern) {
        if (dateTimeString == null || dateTimeString.isEmpty()) {
            return null;
        }
        
        try {
            DateTimeFormatter formatter = getFormatter(pattern);
            return ZonedDateTime.parse(dateTimeString, formatter);
        } catch (DateTimeParseException e) {
            LOGGER.warn("Failed to parse zoned date time '{}' with pattern '{}': {}", dateTimeString, pattern, e.getMessage());
            return null;
        }
    }
    
    /**
     * Adds days to a date.
     * 
     * @param date The date
     * @param days The number of days to add
     * @return The new date
     */
    public static Date addDays(Date date, int days) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.DAY_OF_MONTH, days);
        return calendar.getTime();
    }
    
    /**
     * Adds hours to a date.
     * 
     * @param date The date
     * @param hours The number of hours to add
     * @return The new date
     */
    public static Date addHours(Date date, int hours) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.HOUR_OF_DAY, hours);
        return calendar.getTime();
    }
    
    /**
     * Adds minutes to a date.
     * 
     * @param date The date
     * @param minutes The number of minutes to add
     * @return The new date
     */
    public static Date addMinutes(Date date, int minutes) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.MINUTE, minutes);
        return calendar.getTime();
    }
    
    /**
     * Adds seconds to a date.
     * 
     * @param date The date
     * @param seconds The number of seconds to add
     * @return The new date
     */
    public static Date addSeconds(Date date, int seconds) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.SECOND, seconds);
        return calendar.getTime();
    }
    
    /**
     * Adds days to a local date.
     * 
     * @param localDate The local date
     * @param days The number of days to add
     * @return The new local date
     */
    public static LocalDate addDays(LocalDate localDate, int days) {
        if (localDate == null) {
            return null;
        }
        
        return localDate.plusDays(days);
    }
    
    /**
     * Adds hours to a local time.
     * 
     * @param localTime The local time
     * @param hours The number of hours to add
     * @return The new local time
     */
    public static LocalTime addHours(LocalTime localTime, int hours) {
        if (localTime == null) {
            return null;
        }
        
        return localTime.plusHours(hours);
    }
    
    /**
     * Adds minutes to a local time.
     * 
     * @param localTime The local time
     * @param minutes The number of minutes to add
     * @return The new local time
     */
    public static LocalTime addMinutes(LocalTime localTime, int minutes) {
        if (localTime == null) {
            return null;
        }
        
        return localTime.plusMinutes(minutes);
    }
    
    /**
     * Adds seconds to a local time.
     * 
     * @param localTime The local time
     * @param seconds The number of seconds to add
     * @return The new local time
     */
    public static LocalTime addSeconds(LocalTime localTime, int seconds) {
        if (localTime == null) {
            return null;
        }
        
        return localTime.plusSeconds(seconds);
    }
    
    /**
     * Adds days to a local date and time.
     * 
     * @param localDateTime The local date and time
     * @param days The number of days to add
     * @return The new local date and time
     */
    public static LocalDateTime addDays(LocalDateTime localDateTime, int days) {
        if (localDateTime == null) {
            return null;
        }
        
        return localDateTime.plusDays(days);
    }
    
    /**
     * Adds hours to a local date and time.
     * 
     * @param localDateTime The local date and time
     * @param hours The number of hours to add
     * @return The new local date and time
     */
    public static LocalDateTime addHours(LocalDateTime localDateTime, int hours) {
        if (localDateTime == null) {
            return null;
        }
        
        return localDateTime.plusHours(hours);
    }
    
    /**
     * Adds minutes to a local date and time.
     * 
     * @param localDateTime The local date and time
     * @param minutes The number of minutes to add
     * @return The new local date and time
     */
    public static LocalDateTime addMinutes(LocalDateTime localDateTime, int minutes) {
        if (localDateTime == null) {
            return null;
        }
        
        return localDateTime.plusMinutes(minutes);
    }
    
    /**
     * Adds seconds to a local date and time.
     * 
     * @param localDateTime The local date and time
     * @param seconds The number of seconds to add
     * @return The new local date and time
     */
    public static LocalDateTime addSeconds(LocalDateTime localDateTime, int seconds) {
        if (localDateTime == null) {
            return null;
        }
        
        return localDateTime.plusSeconds(seconds);
    }
    
    /**
     * Gets the start of the day for a date.
     * 
     * @param date The date
     * @return The start of the day (00:00:00.000)
     */
    public static Date getStartOfDay(Date date) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        return calendar.getTime();
    }
    
    /**
     * Gets the end of the day for a date.
     * 
     * @param date The date
     * @return The end of the day (23:59:59.999)
     */
    public static Date getEndOfDay(Date date) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, 23);
        calendar.set(Calendar.MINUTE, 59);
        calendar.set(Calendar.SECOND, 59);
        calendar.set(Calendar.MILLISECOND, 999);
        return calendar.getTime();
    }
    
    /**
     * Gets the start of the day for a local date.
     * 
     * @param localDate The local date
     * @return The start of the day (00:00:00)
     */
    public static LocalDateTime getStartOfDay(LocalDate localDate) {
        if (localDate == null) {
            return null;
        }
        
        return localDate.atStartOfDay();
    }
    
    /**
     * Gets the end of the day for a local date.
     * 
     * @param localDate The local date
     * @return The end of the day (23:59:59.999999999)
     */
    public static LocalDateTime getEndOfDay(LocalDate localDate) {
        if (localDate == null) {
            return null;
        }
        
        return localDate.atTime(23, 59, 59, 999999999);
    }
    
    /**
     * Gets the start of the month for a date.
     * 
     * @param date The date
     * @return The start of the month (1st day, 00:00:00.000)
     */
    public static Date getStartOfMonth(Date date) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.DAY_OF_MONTH, 1);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        return calendar.getTime();
    }
    
    /**
     * Gets the end of the month for a date.
     * 
     * @param date The date
     * @return The end of the month (last day, 23:59:59.999)
     */
    public static Date getEndOfMonth(Date date) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DAY_OF_MONTH));
        calendar.set(Calendar.HOUR_OF_DAY, 23);
        calendar.set(Calendar.MINUTE, 59);
        calendar.set(Calendar.SECOND, 59);
        calendar.set(Calendar.MILLISECOND, 999);
        return calendar.getTime();
    }
    
    /**
     * Gets the start of the month for a local date.
     * 
     * @param localDate The local date
     * @return The start of the month (1st day)
     */
    public static LocalDate getStartOfMonth(LocalDate localDate) {
        if (localDate == null) {
            return null;
        }
        
        return localDate.withDayOfMonth(1);
    }
    
    /**
     * Gets the end of the month for a local date.
     * 
     * @param localDate The local date
     * @return The end of the month (last day)
     */
    public static LocalDate getEndOfMonth(LocalDate localDate) {
        if (localDate == null) {
            return null;
        }
        
        return localDate.withDayOfMonth(localDate.lengthOfMonth());
    }
    
    /**
     * Gets the day of the week for a date.
     * 
     * @param date The date
     * @return The day of the week (1 = Sunday, 2 = Monday, ..., 7 = Saturday)
     */
    public static int getDayOfWeek(Date date) {
        if (date == null) {
            return -1;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar.get(Calendar.DAY_OF_WEEK);
    }
    
    /**
     * Gets the day of the month for a date.
     * 
     * @param date The date
     * @return The day of the month
     */
    public static int getDayOfMonth(Date date) {
        if (date == null) {
            return -1;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar.get(Calendar.DAY_OF_MONTH);
    }
    
    /**
     * Gets the month for a date.
     * 
     * @param date The date
     * @return The month (0 = January, 1 = February, ..., 11 = December)
     */
    public static int getMonth(Date date) {
        if (date == null) {
            return -1;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar.get(Calendar.MONTH);
    }
    
    /**
     * Gets the year for a date.
     * 
     * @param date The date
     * @return The year
     */
    public static int getYear(Date date) {
        if (date == null) {
            return -1;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar.get(Calendar.YEAR);
    }
    
    /**
     * Gets the hour for a date.
     * 
     * @param date The date
     * @return The hour (0-23)
     */
    public static int getHour(Date date) {
        if (date == null) {
            return -1;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar.get(Calendar.HOUR_OF_DAY);
    }
    
    /**
     * Gets the minute for a date.
     * 
     * @param date The date
     * @return The minute (0-59)
     */
    public static int getMinute(Date date) {
        if (date == null) {
            return -1;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar.get(Calendar.MINUTE);
    }
    
    /**
     * Gets the second for a date.
     * 
     * @param date The date
     * @return The second (0-59)
     */
    public static int getSecond(Date date) {
        if (date == null) {
            return -1;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar.get(Calendar.SECOND);
    }
    
    /**
     * Converts a Date to LocalDateTime.
     * 
     * @param date The Date
     * @return The LocalDateTime
     */
    public static LocalDateTime toLocalDateTime(Date date) {
        if (date == null) {
            return null;
        }
        
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
    }
    
    /**
     * Converts a Date to LocalDate.
     * 
     * @param date The Date
     * @return The LocalDate
     */
    public static LocalDate toLocalDate(Date date) {
        if (date == null) {
            return null;
        }
        
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    }
    
    /**
     * Converts a Date to LocalTime.
     * 
     * @param date The Date
     * @return The LocalTime
     */
    public static LocalTime toLocalTime(Date date) {
        if (date == null) {
            return null;
        }
        
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();
    }
    
    /**
     * Converts a LocalDateTime to Date.
     * 
     * @param localDateTime The LocalDateTime
     * @return The Date
     */
    public static Date fromLocalDateTime(LocalDateTime localDateTime) {
        if (localDateTime == null) {
            return null;
        }
        
        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
    }
    
    /**
     * Converts a LocalDate to Date.
     * 
     * @param localDate The LocalDate
     * @return The Date
     */
    public static Date fromLocalDate(LocalDate localDate) {
        if (localDate == null) {
            return null;
        }
        
        return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
    }
    
    /**
     * Gets a DateTimeFormatter from the cache or creates a new one.
     * 
     * @param pattern The date format pattern
     * @return The DateTimeFormatter
     */
    private static DateTimeFormatter getFormatter(String pattern) {
        return FORMATTER_CACHE.computeIfAbsent(pattern, DateTimeFormatter::ofPattern);
    }
    
    /**
     * Calculates the difference in days between two dates.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return The difference in days
     */
    public static long daysBetween(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            return 0;
        }
        
        LocalDate localDate1 = toLocalDate(date1);
        LocalDate localDate2 = toLocalDate(date2);
        return ChronoUnit.DAYS.between(localDate1, localDate2);
    }
    
    /**
     * Calculates the difference in hours between two dates.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return The difference in hours
     */
    public static long hoursBetween(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            return 0;
        }
        
        LocalDateTime localDateTime1 = toLocalDateTime(date1);
        LocalDateTime localDateTime2 = toLocalDateTime(date2);
        return ChronoUnit.HOURS.between(localDateTime1, localDateTime2);
    }
    
    /**
     * Calculates the difference in minutes between two dates.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return The difference in minutes
     */
    public static long minutesBetween(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            return 0;
        }
        
        LocalDateTime localDateTime1 = toLocalDateTime(date1);
        LocalDateTime localDateTime2 = toLocalDateTime(date2);
        return ChronoUnit.MINUTES.between(localDateTime1, localDateTime2);
    }
    
    /**
     * Calculates the difference in seconds between two dates.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return The difference in seconds
     */
    public static long secondsBetween(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            return 0;
        }
        
        LocalDateTime localDateTime1 = toLocalDateTime(date1);
        LocalDateTime localDateTime2 = toLocalDateTime(date2);
        return ChronoUnit.SECONDS.between(localDateTime1, localDateTime2);
    }
    
    /**
     * Calculates the difference in milliseconds between two dates.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return The difference in milliseconds
     */
    public static long millisecondsBetween(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            return 0;
        }
        
        return date2.getTime() - date1.getTime();
    }
    
    /**
     * Calculates the difference in days between two local dates.
     * 
     * @param date1 The first local date
     * @param date2 The second local date
     * @return The difference in days
     */
    public static long daysBetween(LocalDate date1, LocalDate date2) {
        if (date1 == null || date2 == null) {
            return 0;
        }
        
        return ChronoUnit.DAYS.between(date1, date2);
    }
    
    /**
     * Calculates the difference in hours between two local date times.
     * 
     * @param dateTime1 The first local date time
     * @param dateTime2 The second local date time
     * @return The difference in hours
     */
    public static long hoursBetween(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime1 == null || dateTime2 == null) {
            return 0;
        }
        
        return ChronoUnit.HOURS.between(dateTime1, dateTime2);
    }
    
    /**
     * Calculates the difference in minutes between two local date times.
     * 
     * @param dateTime1 The first local date time
     * @param dateTime2 The second local date time
     * @return The difference in minutes
     */
    public static long minutesBetween(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime1 == null || dateTime2 == null) {
            return 0;
        }
        
        return ChronoUnit.MINUTES.between(dateTime1, dateTime2);
    }
    
    /**
     * Calculates the difference in seconds between two local date times.
     * 
     * @param dateTime1 The first local date time
     * @param dateTime2 The second local date time
     * @return The difference in seconds
     */
    public static long secondsBetween(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime1 == null || dateTime2 == null) {
            return 0;
        }
        
        return ChronoUnit.SECONDS.between(dateTime1, dateTime2);
    }
    
    /**
     * Calculates the difference in milliseconds between two local date times.
     * 
     * @param dateTime1 The first local date time
     * @param dateTime2 The second local date time
     * @return The difference in milliseconds
     */
    public static long millisecondsBetween(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime1 == null || dateTime2 == null) {
            return 0;
        }
        
        return ChronoUnit.MILLIS.between(dateTime1, dateTime2);
    }
    
    /**
     * Checks if two dates are on the same day.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return True if the dates are on the same day, false otherwise
     */
    public static boolean isSameDay(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            return false;
        }
        
        Calendar cal1 = Calendar.getInstance();
        cal1.setTime(date1);
        Calendar cal2 = Calendar.getInstance();
        cal2.setTime(date2);
        
        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && 
               cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR);
    }
    
    /**
     * Checks if two local dates are the same.
     * 
     * @param date1 The first local date
     * @param date2 The second local date
     * @return True if the local dates are the same, false otherwise
     */
    public static boolean isSameDay(LocalDate date1, LocalDate date2) {
        if (date1 == null || date2 == null) {
            return false;
        }
        
        return date1.equals(date2);
    }
    
    /**
     * Checks if two local date times are on the same day.
     * 
     * @param dateTime1 The first local date time
     * @param dateTime2 The second local date time
     * @return True if the local date times are on the same day, false otherwise
     */
    public static boolean isSameDay(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime1 == null || dateTime2 == null) {
            return false;
        }
        
        return dateTime1.toLocalDate().equals(dateTime2.toLocalDate());
    }
    
    /**
     * Gets the next day of the week from a date.
     * 
     * @param date The starting date
     * @param dayOfWeek The day of the week (1 = Sunday, 2 = Monday, ..., 7 = Saturday)
     * @return The next date falling on the specified day of the week
     */
    public static Date getNextDayOfWeek(Date date, int dayOfWeek) {
        if (date == null || dayOfWeek < Calendar.SUNDAY || dayOfWeek > Calendar.SATURDAY) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        
        int currentDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
        int daysToAdd = (dayOfWeek - currentDayOfWeek + 7) % 7;
        if (daysToAdd == 0) {
            daysToAdd = 7; // Next week if it's the same day
        }
        
        calendar.add(Calendar.DAY_OF_MONTH, daysToAdd);
        return calendar.getTime();
    }
    
    /**
     * Gets the next day of the week from a local date.
     * 
     * @param localDate The starting local date
     * @param dayOfWeek The day of the week
     * @return The next local date falling on the specified day of the week
     */
    public static LocalDate getNextDayOfWeek(LocalDate localDate, DayOfWeek dayOfWeek) {
        if (localDate == null || dayOfWeek == null) {
            return null;
        }
        
        return localDate.with(TemporalAdjusters.next(dayOfWeek));
    }
    
    /**
     * Gets the previous day of the week from a date.
     * 
     * @param date The starting date
     * @param dayOfWeek The day of the week (1 = Sunday, 2 = Monday, ..., 7 = Saturday)
     * @return The previous date falling on the specified day of the week
     */
    public static Date getPreviousDayOfWeek(Date date, int dayOfWeek) {
        if (date == null || dayOfWeek < Calendar.SUNDAY || dayOfWeek > Calendar.SATURDAY) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        
        int currentDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
        int daysToSubtract = (currentDayOfWeek - dayOfWeek + 7) % 7;
        if (daysToSubtract == 0) {
            daysToSubtract = 7; // Previous week if it's the same day
        }
        
        calendar.add(Calendar.DAY_OF_MONTH, -daysToSubtract);
        return calendar.getTime();
    }
    
    /**
     * Gets the previous day of the week from a local date.
     * 
     * @param localDate The starting local date
     * @param dayOfWeek The day of the week
     * @return The previous local date falling on the specified day of the week
     */
    public static LocalDate getPreviousDayOfWeek(LocalDate localDate, DayOfWeek dayOfWeek) {
        if (localDate == null || dayOfWeek == null) {
            return null;
        }
        
        return localDate.with(TemporalAdjusters.previous(dayOfWeek));
    }
    
    /**
     * Sets the time component of a date.
     * 
     * @param date The date
     * @param hour The hour (0-23)
     * @param minute The minute (0-59)
     * @param second The second (0-59)
     * @param millisecond The millisecond (0-999)
     * @return The date with the specified time
     */
    public static Date setTime(Date date, int hour, int minute, int second, int millisecond) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, minute);
        calendar.set(Calendar.SECOND, second);
        calendar.set(Calendar.MILLISECOND, millisecond);
        return calendar.getTime();
    }
    
    /**
     * Sets the date component of a local date time.
     * 
     * @param dateTime The local date time
     * @param year The year
     * @param month The month (1-12)
     * @param dayOfMonth The day of the month
     * @return The local date time with the specified date
     */
    public static LocalDateTime setDate(LocalDateTime dateTime, int year, int month, int dayOfMonth) {
        if (dateTime == null) {
            return null;
        }
        
        return dateTime.withYear(year).withMonth(month).withDayOfMonth(dayOfMonth);
    }
    
    /**
     * Sets the time component of a local date time.
     * 
     * @param dateTime The local date time
     * @param hour The hour (0-23)
     * @param minute The minute (0-59)
     * @param second The second (0-59)
     * @param nanoOfSecond The nano of second (0-999,999,999)
     * @return The local date time with the specified time
     */
    public static LocalDateTime setTime(LocalDateTime dateTime, int hour, int minute, int second, int nanoOfSecond) {
        if (dateTime == null) {
            return null;
        }
        
        return dateTime.withHour(hour).withMinute(minute).withSecond(second).withNano(nanoOfSecond);
    }
    
    /**
     * Gets a date in a specific time zone.
     * 
     * @param date The date
     * @param timeZoneId The time zone ID
     * @return The date in the specified time zone
     */
    public static Date getDateInTimeZone(Date date, String timeZoneId) {
        if (date == null || timeZoneId == null || timeZoneId.isEmpty()) {
            return date;
        }
        
        // Convert to local date time in system time zone
        LocalDateTime localDateTime = toLocalDateTime(date);
        
        // Convert to the specified time zone
        ZonedDateTime zonedDateTime = localDateTime.atZone(ZoneId.systemDefault()).withZoneSameInstant(ZoneId.of(timeZoneId));
        
        // Convert back to Date
        return Date.from(zonedDateTime.toInstant());
    }
    
    /**
     * Converts a local date time to a zoned date time in a specific time zone.
     * 
     * @param localDateTime The local date time
     * @param zoneId The time zone ID
     * @return The zoned date time in the specified time zone
     */
    public static ZonedDateTime toZonedDateTime(LocalDateTime localDateTime, String zoneId) {
        if (localDateTime == null || zoneId == null || zoneId.isEmpty()) {
            return null;
        }
        
        return localDateTime.atZone(ZoneId.of(zoneId));
    }
    
    /**
     * Converts a zoned date time to a local date time in the system default time zone.
     * 
     * @param zonedDateTime The zoned date time
     * @return The local date time in the system default time zone
     */
    public static LocalDateTime toLocalDateTime(ZonedDateTime zonedDateTime) {
        if (zonedDateTime == null) {
            return null;
        }
        
        return zonedDateTime.withZoneSameInstant(ZoneId.systemDefault()).toLocalDateTime();
    }
    
    /**
     * Formats a duration in a human-readable format.
     * 
     * @param durationMillis The duration in milliseconds
     * @return The formatted duration (e.g., "2 hours 30 minutes")
     */
    public static String formatDuration(long durationMillis) {
        if (durationMillis < 0) {
            return null;
        }
        
        Duration duration = Duration.ofMillis(durationMillis);
        
        long days = duration.toDays();
        duration = duration.minusDays(days);
        
        long hours = duration.toHours();
        duration = duration.minusHours(hours);
        
        long minutes = duration.toMinutes();
        duration = duration.minusMinutes(minutes);
        
        long seconds = duration.getSeconds();
        
        StringBuilder result = new StringBuilder();
        
        if (days > 0) {
            result.append(days).append(days == 1 ? " day " : " days ");
        }
        
        if (hours > 0) {
            result.append(hours).append(hours == 1 ? " hour " : " hours ");
        }
        
        if (minutes > 0) {
            result.append(minutes).append(minutes == 1 ? " minute " : " minutes ");
        }
        
        if (seconds > 0 || (days == 0 && hours == 0 && minutes == 0)) {
            result.append(seconds).append(seconds == 1 ? " second" : " seconds");
        }
        
        return result.toString().trim();
    }
    
    /**
     * Formats a duration between two dates in a human-readable format.
     * 
     * @param startDate The start date
     * @param endDate The end date
     * @return The formatted duration
     */
    public static String formatDuration(Date startDate, Date endDate) {
        if (startDate == null || endDate == null) {
            return null;
        }
        
        long durationMillis = endDate.getTime() - startDate.getTime();
        return formatDuration(durationMillis);
    }
    
    /**
     * Formats a duration between two local date times in a human-readable format.
     * 
     * @param startDateTime The start local date time
     * @param endDateTime The end local date time
     * @return The formatted duration
     */
    public static String formatDuration(LocalDateTime startDateTime, LocalDateTime endDateTime) {
        if (startDateTime == null || endDateTime == null) {
            return null;
        }
        
        long durationMillis = Duration.between(startDateTime, endDateTime).toMillis();
        return formatDuration(durationMillis);
    }
    
    /**
     * Gets a date from a timestamp.
     * 
     * @param timestamp The timestamp in milliseconds
     * @return The date
     */
    public static Date fromTimestamp(long timestamp) {
        return new Date(timestamp);
    }
    
    /**
     * Gets a local date time from a timestamp.
     * 
     * @param timestamp The timestamp in milliseconds
     * @return The local date time
     */
    public static LocalDateTime fromTimestampToLocalDateTime(long timestamp) {
        return LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());
    }
    
    /**
     * Gets a local date from a timestamp.
     * 
     * @param timestamp The timestamp in milliseconds
     * @return The local date
     */
    public static LocalDate fromTimestampToLocalDate(long timestamp) {
        return LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault()).toLocalDate();
    }
    
    /**
     * Gets a timestamp from a date.
     * 
     * @param date The date
     * @return The timestamp in milliseconds
     */
    public static long toTimestamp(Date date) {
        if (date == null) {
            return 0;
        }
        
        return date.getTime();
    }
    
    /**
     * Gets a timestamp from a local date time.
     * 
     * @param localDateTime The local date time
     * @return The timestamp in milliseconds
     */
    public static long toTimestamp(LocalDateTime localDateTime) {
        if (localDateTime == null) {
            return 0;
        }
        
        return localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
    }
    
    /**
     * Gets a timestamp from a local date.
     * 
     * @param localDate The local date
     * @return The timestamp in milliseconds
     */
    public static long toTimestamp(LocalDate localDate) {
        if (localDate == null) {
            return 0;
        }
        
        return localDate.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli();
    }
    
    /**
     * Creates a date.
     * 
     * @param year The year
     * @param month The month (1-12)
     * @param day The day of the month
     * @return The date
     */
    public static Date createDate(int year, int month, int day) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(year, month - 1, day, 0, 0, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        return calendar.getTime();
    }
    
    /**
     * Creates a date with time.
     * 
     * @param year The year
     * @param month The month (1-12)
     * @param day The day of the month
     * @param hour The hour (0-23)
     * @param minute The minute (0-59)
     * @param second The second (0-59)
     * @return The date
     */
    public static Date createDateTime(int year, int month, int day, int hour, int minute, int second) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(year, month - 1, day, hour, minute, second);
        calendar.set(Calendar.MILLISECOND, 0);
        return calendar.getTime();
    }
    
    /**
     * Creates a local date.
     * 
     * @param year The year
     * @param month The month (1-12)
     * @param day The day of the month
     * @return The local date
     */
    public static LocalDate createLocalDate(int year, int month, int day) {
        return LocalDate.of(year, month, day);
    }
    
    /**
     * Creates a local time.
     * 
     * @param hour The hour (0-23)
     * @param minute The minute (0-59)
     * @param second The second (0-59)
     * @return The local time
     */
    public static LocalTime createLocalTime(int hour, int minute, int second) {
        return LocalTime.of(hour, minute, second);
    }
    
    /**
     * Creates a local date time.
     * 
     * @param year The year
     * @param month The month (1-12)
     * @param day The day of the month
     * @param hour The hour (0-23)
     * @param minute The minute (0-59)
     * @param second The second (0-59)
     * @return The local date time
     */
    public static LocalDateTime createLocalDateTime(int year, int month, int day, int hour, int minute, int second) {
        return LocalDateTime.of(year, month, day, hour, minute, second);
    }
    
    /**
     * Checks if a date is before another date.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return True if the first date is before the second date, false otherwise
     */
    public static boolean isBefore(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            return false;
        }
        
        return date1.before(date2);
    }
    
    /**
     * Checks if a date is after another date.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return True if the first date is after the second date, false otherwise
     */
    public static boolean isAfter(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            return false;
        }
        
        return date1.after(date2);
    }
    
    /**
     * Checks if a date is between two other dates.
     * 
     * @param date The date to check
     * @param startDate The start date
     * @param endDate The end date
     * @param inclusive Whether the range is inclusive of the start and end dates
     * @return True if the date is between the start and end dates, false otherwise
     */
    public static boolean isBetween(Date date, Date startDate, Date endDate, boolean inclusive) {
        if (date == null || startDate == null || endDate == null) {
            return false;
        }
        
        if (inclusive) {
            return !(date.before(startDate) || date.after(endDate));
        } else {
            return date.after(startDate) && date.before(endDate);
        }
    }
    
    /**
     * Gets the earlier of two dates.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return The earlier date
     */
    public static Date min(Date date1, Date date2) {
        if (date1 == null) {
            return date2;
        }
        if (date2 == null) {
            return date1;
        }
        
        return date1.before(date2) ? date1 : date2;
    }
    
    /**
     * Gets the later of two dates.
     * 
     * @param date1 The first date
     * @param date2 The second date
     * @return The later date
     */
    public static Date max(Date date1, Date date2) {
        if (date1 == null) {
            return date2;
        }
        if (date2 == null) {
            return date1;
        }
        
        return date1.after(date2) ? date1 : date2;
    }
}


CSScreenshotManager.java
---------------------------------------

package com.cstestforge.framework.core.utils;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Consumer;

/**
 * Manager for capturing, storing, and manipulating screenshots.
 * Provides methods for screenshot operations in test automation.
 */
public class CSScreenshotManager {
    private static final CSLogger LOGGER = new CSLogger(CSScreenshotManager.class);
    
    private final String screenshotDir;
    private final Map<String, byte[]> screenshotCache = new HashMap<>();
    
    /**
     * Constructs a new CSScreenshotManager with the specified screenshot directory.
     * 
     * @param screenshotDir The directory to store screenshots
     */
    public CSScreenshotManager(String screenshotDir) {
        this.screenshotDir = screenshotDir;
        
        // Create the screenshot directory if it doesn't exist
        File directory = new File(screenshotDir);
        if (!directory.exists()) {
            boolean created = directory.mkdirs();
            if (!created) {
                LOGGER.warn("Failed to create screenshot directory: {}", screenshotDir);
            }
        }
        
        LOGGER.info("CSScreenshotManager initialized with directory: {}", screenshotDir);
    }
    
    /**
     * Saves a screenshot from bytes.
     * 
     * @param screenshotBytes The screenshot bytes
     * @param fileName The file name, or null to generate a unique file name
     * @return The path to the saved screenshot file
     */
    public String saveScreenshot(byte[] screenshotBytes, String fileName) {
        if (screenshotBytes == null || screenshotBytes.length == 0) {
            LOGGER.warn("Screenshot bytes are null or empty");
            return null;
        }
        
        try {
            // Generate a unique file name if not provided
            if (fileName == null || fileName.isEmpty()) {
                fileName = generateScreenshotFileName();
            }
            
            // Make sure the file name has a .png extension
            if (!fileName.toLowerCase().endsWith(".png")) {
                fileName = fileName + ".png";
            }
            
            // Create the full file path
            String filePath = screenshotDir + File.separator + fileName;
            
            // Save the screenshot to a file
            Path path = Paths.get(filePath);
            Files.write(path, screenshotBytes);
            
            LOGGER.debug("Screenshot saved to: {}", filePath);
            
            // Optionally cache the screenshot bytes for later use
            cacheScreenshot(fileName, screenshotBytes);
            
            return filePath;
        } catch (IOException e) {
            LOGGER.error("Error saving screenshot: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Saves a screenshot from a Base64 encoded string.
     * 
     * @param base64Image The Base64 encoded image
     * @param fileName The file name, or null to generate a unique file name
     * @return The path to the saved screenshot file
     */
    public String saveScreenshotFromBase64(String base64Image, String fileName) {
        if (base64Image == null || base64Image.isEmpty()) {
            LOGGER.warn("Base64 image is null or empty");
            return null;
        }
        
        try {
            // Remove data URL prefix if present
            if (base64Image.startsWith("data:image/png;base64,")) {
                base64Image = base64Image.substring("data:image/png;base64,".length());
            }
            
            // Decode the Base64 string
            byte[] imageBytes = Base64.getDecoder().decode(base64Image);
            
            // Save the screenshot
            return saveScreenshot(imageBytes, fileName);
        } catch (IllegalArgumentException e) {
            LOGGER.error("Error decoding Base64 image: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Saves a screenshot from a file.
     * 
     * @param sourceFilePath The source file path
     * @param fileName The file name, or null to generate a unique file name
     * @return The path to the saved screenshot file
     */
    public String saveScreenshotFromFile(String sourceFilePath, String fileName) {
        if (sourceFilePath == null || sourceFilePath.isEmpty()) {
            LOGGER.warn("Source file path is null or empty");
            return null;
        }
        
        try {
            // Read the source file
            byte[] imageBytes = Files.readAllBytes(Paths.get(sourceFilePath));
            
            // Save the screenshot
            return saveScreenshot(imageBytes, fileName);
        } catch (IOException e) {
            LOGGER.error("Error reading source file: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Gets a screenshot from the cache.
     * 
     * @param fileName The file name
     * @return The screenshot bytes, or null if not found in the cache
     */
    public byte[] getScreenshotFromCache(String fileName) {
        return screenshotCache.get(fileName);
    }
    
    /**
     * Caches a screenshot.
     * 
     * @param fileName The file name
     * @param screenshotBytes The screenshot bytes
     */
    public void cacheScreenshot(String fileName, byte[] screenshotBytes) {
        screenshotCache.put(fileName, screenshotBytes);
    }
    
    /**
     * Clears the screenshot cache.
     */
    public void clearCache() {
        screenshotCache.clear();
    }
    
    /**
     * Gets the screenshot directory.
     * 
     * @return The screenshot directory
     */
    public String getScreenshotDir() {
        return screenshotDir;
    }
    
    /**
     * Compares two screenshots for similarity.
     * 
     * @param screenshot1 The first screenshot bytes
     * @param screenshot2 The second screenshot bytes
     * @return The similarity percentage (0-100)
     */
    public double compareScreenshots(byte[] screenshot1, byte[] screenshot2) {
        if (screenshot1 == null || screenshot2 == null || screenshot1.length == 0 || screenshot2.length == 0) {
            return 0.0;
        }
        
        try {
            // Convert bytes to BufferedImage
            BufferedImage image1 = ImageIO.read(new ByteArrayInputStream(screenshot1));
            BufferedImage image2 = ImageIO.read(new ByteArrayInputStream(screenshot2));
            
            // Ensure images are the same size for comparison
            if (image1.getWidth() != image2.getWidth() || image1.getHeight() != image2.getHeight()) {
                // Resize second image to match first image
                image2 = resizeImage(image2, image1.getWidth(), image1.getHeight());
            }
            
            // Calculate similarity
            long diff = 0;
            int width = image1.getWidth();
            int height = image1.getHeight();
            
            for (int y = 0; y < height; y++) {
                for (int x = 0; x < width; x++) {
                    int rgb1 = image1.getRGB(x, y);
                    int rgb2 = image2.getRGB(x, y);
                    
                    // Compare RGB components
                    int r1 = (rgb1 >> 16) & 0xff;
                    int g1 = (rgb1 >> 8) & 0xff;
                    int b1 = rgb1 & 0xff;
                    
                    int r2 = (rgb2 >> 16) & 0xff;
                    int g2 = (rgb2 >> 8) & 0xff;
                    int b2 = rgb2 & 0xff;
                    
                    diff += Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
                }
            }
            
            double totalPixels = width * height * 3; // 3 channels (RGB)
            double similarityPercentage = 100.0 - (diff * 100.0 / (255.0 * totalPixels));
            
            return similarityPercentage;
        } catch (IOException e) {
            LOGGER.error("Error comparing screenshots: {}", e.getMessage(), e);
            return 0.0;
        }
    }
    
    /**
     * Compares two screenshot files for similarity.
     * 
     * @param filePath1 The first screenshot file path
     * @param filePath2 The second screenshot file path
     * @return The similarity percentage (0-100)
     */
    public double compareScreenshotFiles(String filePath1, String filePath2) {
        try {
            byte[] screenshot1 = Files.readAllBytes(Paths.get(filePath1));
            byte[] screenshot2 = Files.readAllBytes(Paths.get(filePath2));
            
            return compareScreenshots(screenshot1, screenshot2);
        } catch (IOException e) {
            LOGGER.error("Error reading screenshot files: {}", e.getMessage(), e);
            return 0.0;
        }
    }
    
    /**
     * Adds a highlight to a screenshot.
     * 
     * @param screenshotBytes The screenshot bytes
     * @param x The x-coordinate of the highlight
     * @param y The y-coordinate of the highlight
     * @param width The width of the highlight
     * @param height The height of the highlight
     * @param highlightColor The highlight color
     * @return The modified screenshot bytes
     */
    public byte[] addHighlight(byte[] screenshotBytes, int x, int y, int width, int height, Color highlightColor) {
        if (screenshotBytes == null || screenshotBytes.length == 0) {
            return screenshotBytes;
        }
        
        try {
            // Convert bytes to BufferedImage
            BufferedImage image = ImageIO.read(new ByteArrayInputStream(screenshotBytes));
            
            // Create a graphics context
            Graphics2D g = image.createGraphics();
            
            // Set the highlight color with some transparency
            g.setColor(new Color(highlightColor.getRed(), highlightColor.getGreen(), highlightColor.getBlue(), 128));
            
            // Draw the highlight rectangle
            g.fillRect(x, y, width, height);
            
            // Draw a border around the highlight
            g.setColor(highlightColor);
            g.setStroke(new BasicStroke(2));
            g.drawRect(x, y, width, height);
            
            // Dispose the graphics context
            g.dispose();
            
            // Convert the modified image back to bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            ImageIO.write(image, "png", outputStream);
            
            return outputStream.toByteArray();
        } catch (IOException e) {
            LOGGER.error("Error adding highlight to screenshot: {}", e.getMessage(), e);
            return screenshotBytes;
        }
    }
    
    /**
     * Adds text to a screenshot.
     * 
     * @param screenshotBytes The screenshot bytes
     * @param text The text to add
     * @param x The x-coordinate of the text
     * @param y The y-coordinate of the text
     * @param textColor The text color
     * @param fontSize The font size
     * @return The modified screenshot bytes
     */
    public byte[] addText(byte[] screenshotBytes, String text, int x, int y, Color textColor, int fontSize) {
        if (screenshotBytes == null || screenshotBytes.length == 0) {
            return screenshotBytes;
        }
        
        try {
            // Convert bytes to BufferedImage
            BufferedImage image = ImageIO.read(new ByteArrayInputStream(screenshotBytes));
            
            // Create a graphics context
            Graphics2D g = image.createGraphics();
            
            // Set the text properties
            g.setColor(textColor);
            g.setFont(new Font("Arial", Font.BOLD, fontSize));
            
            // Enable anti-aliasing for smoother text
            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            
            // Draw the text
            g.drawString(text, x, y);
            
            // Dispose the graphics context
            g.dispose();
            
            // Convert the modified image back to bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            ImageIO.write(image, "png", outputStream);
            
            return outputStream.toByteArray();
        } catch (IOException e) {
            LOGGER.error("Error adding text to screenshot: {}", e.getMessage(), e);
            return screenshotBytes;
        }
    }
    
    /**
     * Crops a screenshot.
     * 
     * @param screenshotBytes The screenshot bytes
     * @param x The x-coordinate of the crop area
     * @param y The y-coordinate of the crop area
     * @param width The width of the crop area
     * @param height The height of the crop area
     * @return The cropped screenshot bytes
     */
    public byte[] cropScreenshot(byte[] screenshotBytes, int x, int y, int width, int height) {
        if (screenshotBytes == null || screenshotBytes.length == 0) {
            return screenshotBytes;
        }
        
        try {
            // Convert bytes to BufferedImage
            BufferedImage image = ImageIO.read(new ByteArrayInputStream(screenshotBytes));
            
            // Ensure the crop area is within the image bounds
            x = Math.max(0, Math.min(x, image.getWidth() - 1));
            y = Math.max(0, Math.min(y, image.getHeight() - 1));
            width = Math.min(width, image.getWidth() - x);
            height = Math.min(height, image.getHeight() - y);
            
            // Crop the image
            BufferedImage croppedImage = image.getSubimage(x, y, width, height);
            
            // Convert the cropped image back to bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            ImageIO.write(croppedImage, "png", outputStream);
            
            return outputStream.toByteArray();
        } catch (IOException e) {
            LOGGER.error("Error cropping screenshot: {}", e.getMessage(), e);
            return screenshotBytes;
        }
    }
    
    /**
     * Resizes a screenshot.
     * 
     * @param screenshotBytes The screenshot bytes
     * @param width The new width
     * @param height The new height
     * @return The resized screenshot bytes
     */
    public byte[] resizeScreenshot(byte[] screenshotBytes, int width, int height) {
        if (screenshotBytes == null || screenshotBytes.length == 0) {
            return screenshotBytes;
        }
        
        try {
            // Convert bytes to BufferedImage
            BufferedImage image = ImageIO.read(new ByteArrayInputStream(screenshotBytes));
            
            // Resize the image
            BufferedImage resizedImage = resizeImage(image, width, height);
            
            // Convert the resized image back to bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            ImageIO.write(resizedImage, "png", outputStream);
            
            return outputStream.toByteArray();
        } catch (IOException e) {
            LOGGER.error("Error resizing screenshot: {}", e.getMessage(), e);
            return screenshotBytes;
        }
    }
    
    /**
     * Converts a screenshot from PNG to JPEG.
     * 
     * @param screenshotBytes The PNG screenshot bytes
     * @param quality The JPEG quality (0-100)
     * @return The JPEG screenshot bytes
     */
    public byte[] convertToJpeg(byte[] screenshotBytes, int quality) {
        if (screenshotBytes == null || screenshotBytes.length == 0) {
            return screenshotBytes;
        }
        
        try {
            // Convert bytes to BufferedImage
            BufferedImage image = ImageIO.read(new ByteArrayInputStream(screenshotBytes));
            
            // Create a new RGB image (JPEG doesn't support transparency)
            BufferedImage rgbImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);
            Graphics2D g = rgbImage.createGraphics();
            g.drawImage(image, 0, 0, null);
            g.dispose();
            
            // Convert the image to JPEG bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            
            // Set JPEG compression quality
            javax.imageio.ImageWriter writer = ImageIO.getImageWritersByFormatName("jpg").next();
            javax.imageio.ImageWriteParam param = writer.getDefaultWriteParam();
            param.setCompressionMode(javax.imageio.ImageWriteParam.MODE_EXPLICIT);
            param.setCompressionQuality(quality / 100.0f);
            
            // Write the image to the output stream
            javax.imageio.stream.ImageOutputStream imageOutputStream = ImageIO.createImageOutputStream(outputStream);
            writer.setOutput(imageOutputStream);
            writer.write(null, new javax.imageio.IIOImage(rgbImage, null, null), param);
            writer.dispose();
            imageOutputStream.close();
            
            return outputStream.toByteArray();
        } catch (IOException e) {
            LOGGER.error("Error converting screenshot to JPEG: {}", e.getMessage(), e);
            return screenshotBytes;
        }
    }
    
    /**
     * Applies a blur effect to an area of a screenshot.
     * 
     * @param screenshotBytes The screenshot bytes
     * @param x The x-coordinate of the blur area
     * @param y The y-coordinate of the blur area
     * @param width The width of the blur area
     * @param height The height of the blur area
     * @param blurRadius The blur radius
     * @return The modified screenshot bytes
     */
    public byte[] applyBlur(byte[] screenshotBytes, int x, int y, int width, int height, int blurRadius) {
        if (screenshotBytes == null || screenshotBytes.length == 0) {
            return screenshotBytes;
        }
        
        try {
            // Convert bytes to BufferedImage
            BufferedImage image = ImageIO.read(new ByteArrayInputStream(screenshotBytes));
            
            // Ensure the blur area is within the image bounds
            x = Math.max(0, Math.min(x, image.getWidth() - 1));
            y = Math.max(0, Math.min(y, image.getHeight() - 1));
            width = Math.min(width, image.getWidth() - x);
            height = Math.min(height, image.getHeight() - y);
            
            // Extract the area to blur
            BufferedImage areaToBlur = image.getSubimage(x, y, width, height);
            
            // Apply a box blur filter
            BufferedImage blurredArea = applyBoxBlur(areaToBlur, blurRadius);
            
            // Draw the blurred area back onto the original image
            Graphics2D g = image.createGraphics();
            g.drawImage(blurredArea, x, y, null);
            g.dispose();
            
            // Convert the modified image back to bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            ImageIO.write(image, "png", outputStream);
            
            return outputStream.toByteArray();
        } catch (IOException e) {
            LOGGER.error("Error applying blur to screenshot: {}", e.getMessage(), e);
            return screenshotBytes;
        }
    }
    
    /**
     * Gets a screenshot file as bytes.
     * 
     * @param filePath The file path
     * @return The screenshot bytes
     */
    public byte[] getScreenshotBytes(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            LOGGER.warn("File path is null or empty");
            return null;
        }
        
        try {
            return Files.readAllBytes(Paths.get(filePath));
        } catch (IOException e) {
            LOGGER.error("Error reading screenshot file: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Converts a screenshot to a Base64 encoded string.
     * 
     * @param screenshotBytes The screenshot bytes
     * @return The Base64 encoded string
     */
    public String toBase64(byte[] screenshotBytes) {
        if (screenshotBytes == null || screenshotBytes.length == 0) {
            return null;
        }
        
        return Base64.getEncoder().encodeToString(screenshotBytes);
    }
    
    /**
     * Converts a screenshot file to a Base64 encoded string.
     * 
     * @param filePath The file path
     * @return The Base64 encoded string
     */
    public String fileToBase64(String filePath) {
        byte[] screenshotBytes = getScreenshotBytes(filePath);
        if (screenshotBytes == null) {
            return null;
        }
        
        return toBase64(screenshotBytes);
    }
    
    /**
     * Generates a unique screenshot file name.
     * 
     * @return The generated file name
     */
    public String generateScreenshotFileName() {
        return "screenshot_" + CSDateUtils.getCurrentTimestampFormatted("yyyyMMdd_HHmmss") + "_" + UUID.randomUUID().toString().substring(0, 8) + ".png";
    }
    
    /**
     * Generates a timestamped screenshot file name with a description.
     * 
     * @param description The description to include in the file name
     * @return The generated file name
     */
    public String generateScreenshotFileName(String description) {
        if (description == null || description.isEmpty()) {
            return generateScreenshotFileName();
        }
        
        // Sanitize the description (remove any characters that are not allowed in file names)
        String sanitized = description.replaceAll("[^a-zA-Z0-9\\-_]", "_").replaceAll("_+", "_");
        
        return "screenshot_" + sanitized + "_" + CSDateUtils.getCurrentTimestampFormatted("yyyyMMdd_HHmmss") + ".png";
    }
    
    /**
     * Applies a box blur filter to an image.
     * 
     * @param image The image to blur
     * @param radius The blur radius
     * @return The blurred image
     */
    private BufferedImage applyBoxBlur(BufferedImage image, int radius) {
        int width = image.getWidth();
        int height = image.getHeight();
        
        BufferedImage blurredImage = new BufferedImage(width, height, image.getType());
        
        // Create a copy of the original image
        Graphics2D g = blurredImage.createGraphics();
        g.drawImage(image, 0, 0, null);
        g.dispose();
        
        // Apply a simple box blur
        for (int i = 0; i < radius; i++) {
            blurredImage = doBoxBlur(blurredImage);
        }
        
        return blurredImage;
    }
    
    /**
     * Performs one iteration of a box blur.
     * 
     * @param image The image to blur
     * @return The blurred image
     */
    private BufferedImage doBoxBlur(BufferedImage image) {
        int width = image.getWidth();
        int height = image.getHeight();
        
        BufferedImage blurredImage = new BufferedImage(width, height, image.getType());
        
        // Horizontal blur
        for (int y = 0; y < height; y++) {
            int[] pixels = new int[width];
            image.getRGB(0, y, width, 1, pixels, 0, width);
            
            for (int x = 1; x < width - 1; x++) {
                int leftPixel = pixels[x - 1];
                int centerPixel = pixels[x];
                int rightPixel = pixels[x + 1];
                
                int r = ((leftPixel >> 16) & 0xff) + ((centerPixel >> 16) & 0xff) + ((rightPixel >> 16) & 0xff);
                int g = ((leftPixel >> 8) & 0xff) + ((centerPixel >> 8) & 0xff) + ((rightPixel >> 8) & 0xff);
                int b = (leftPixel & 0xff) + (centerPixel & 0xff) + (rightPixel & 0xff);
                
                int avg = (0xff << 24) | ((r / 3) << 16) | ((g / 3) << 8) | (b / 3);
                pixels[x] = avg;
            }
            
            blurredImage.setRGB(0, y, width, 1, pixels, 0, width);
        }
        
        // Vertical blur
        for (int x = 0; x < width; x++) {
            int[] pixels = new int[height];
            
            for (int y = 0; y < height; y++) {
                pixels[y] = blurredImage.getRGB(x, y);
            }
            
            for (int y = 1; y < height - 1; y++) {
                int topPixel = pixels[y - 1];
                int centerPixel = pixels[y];
                int bottomPixel = pixels[y + 1];
                
                int r = ((topPixel >> 16) & 0xff) + ((centerPixel >> 16) & 0xff) + ((bottomPixel >> 16) & 0xff);
                int g = ((topPixel >> 8) & 0xff) + ((centerPixel >> 8) & 0xff) + ((bottomPixel >> 8) & 0xff);
                int b = (topPixel & 0xff) + (centerPixel & 0xff) + (bottomPixel & 0xff);
                
                int avg = (0xff << 24) | ((r / 3) << 16) | ((g / 3) << 8) | (b / 3);
                pixels[y] = avg;
            }
            
            for (int y = 0; y < height; y++) {
                blurredImage.setRGB(x, y, pixels[y]);
            }
        }
        
        return blurredImage;
    }
    
    /**
     * Resizes an image.
     * 
     * @param image The image to resize
     * @param width The new width
     * @param height The new height
     * @return The resized image
     */
    private BufferedImage resizeImage(BufferedImage image, int width, int height) {
        BufferedImage resizedImage = new BufferedImage(width, height, image.getType());
        Graphics2D g = resizedImage.createGraphics();
        
        // Enable better quality interpolation
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        g.drawImage(image, 0, 0, width, height, null);
        g.dispose();
        
        return resizedImage;
    }
}


CSSelect.java
------------------------------

package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Frame;
import com.microsoft.playwright.options.AriaRole;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Enhanced wrapper for Playwright's select element operations.
 * Provides advanced functionality for interacting with select/dropdown elements.
 */
public class CSSelect extends CSElement {
    private static final CSLogger LOGGER = new CSLogger(CSSelect.class);
    private final Locator optionsLocator;

    /**
     * Constructs a new CSSelect with the specified page and selector.
     * 
     * @param page The Playwright page
     * @param selector The selector for the select element
     */
    public CSSelect(Page page, String selector) {
        super(page, selector);
        this.optionsLocator = page.locator(selector + " > option, " + selector + " option");
        LOGGER.debug("Created CSSelect with selector: {}", selector);
    }
    
    /**
     * Constructs a new CSSelect with the specified frame and selector.
     * 
     * @param frame The Playwright frame
     * @param selector The selector for the select element
     */
    public CSSelect(Frame frame, String selector) {
        super(frame, selector);
        this.optionsLocator = frame.locator(selector + " > option, " + selector + " option");
        LOGGER.debug("Created CSSelect with selector: {} in frame", selector);
    }
    
    /**
     * Constructs a new CSSelect with a pre-existing locator.
     * 
     * @param locator The Playwright locator for the select element
     * @param selector The original selector (for logging)
     */
    public CSSelect(Locator locator, String selector) {
        super(locator, selector);
        this.optionsLocator = locator.locator("option");
        LOGGER.debug("Created CSSelect with existing locator: {}", selector);
    }
    
    /**
     * Selects an option by its value attribute.
     * 
     * @param value The value of the option to select
     * @return This CSSelect for chaining
     */
    public CSSelect selectByValue(String value) {
        try {
            LOGGER.info("Selecting option with value '{}' from select element: {}", value, getSelector());
            getLocator().selectOption(value);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting option by value '{}': {}", value, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects an option by its visible text (label).
     * 
     * @param text The text of the option to select
     * @return This CSSelect for chaining
     */
    public CSSelect selectByText(String text) {
        try {
            LOGGER.info("Selecting option with text '{}' from select element: {}", text, getSelector());
            getLocator().selectOption(new Locator.SelectOptionOptions().setLabel(text));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting option by text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects an option by its index (0-based).
     * 
     * @param index The index of the option to select
     * @return This CSSelect for chaining
     */
    public CSSelect selectByIndex(int index) {
        try {
            LOGGER.info("Selecting option at index {} from select element: {}", index, getSelector());
            getLocator().selectOption(new Locator.SelectOptionOptions().setIndex(index));
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting option by index {}: {}", index, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects multiple options by their values.
     * 
     * @param values The values of the options to select
     * @return This CSSelect for chaining
     */
    public CSSelect selectByValues(String... values) {
        try {
            LOGGER.info("Selecting multiple options with values {} from select element: {}", String.join(", ", values), getSelector());
            getLocator().selectOption(values);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting multiple options by values: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects multiple options by their visible texts (labels).
     * 
     * @param texts The texts of the options to select
     * @return This CSSelect for chaining
     */
    public CSSelect selectByTexts(String... texts) {
        try {
            LOGGER.info("Selecting multiple options with texts {} from select element: {}", String.join(", ", texts), getSelector());
            
            Locator.SelectOptionOptions[] options = new Locator.SelectOptionOptions[texts.length];
            for (int i = 0; i < texts.length; i++) {
                options[i] = new Locator.SelectOptionOptions().setLabel(texts[i]);
            }
            
            getLocator().selectOption(options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting multiple options by texts: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects multiple options by their indices (0-based).
     * 
     * @param indices The indices of the options to select
     * @return This CSSelect for chaining
     */
    public CSSelect selectByIndices(int... indices) {
        try {
            LOGGER.info("Selecting multiple options by indices from select element: {}", getSelector());
            
            Locator.SelectOptionOptions[] options = new Locator.SelectOptionOptions[indices.length];
            for (int i = 0; i < indices.length; i++) {
                options[i] = new Locator.SelectOptionOptions().setIndex(indices[i]);
            }
            
            getLocator().selectOption(options);
            return this;
        } catch (Exception e) {
            LOGGER.error("Error selecting multiple options by indices: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all option values from the select element.
     * 
     * @return The list of option values
     */
    public List<String> getOptionValues() {
        try {
            LOGGER.debug("Getting all option values from select element: {}", getSelector());
            
            int count = optionsLocator.count();
            List<String> values = new ArrayList<>();
            
            for (int i = 0; i < count; i++) {
                Locator option = optionsLocator.nth(i);
                String value = option.getAttribute("value");
                if (value != null) {
                    values.add(value);
                }
            }
            
            return values;
        } catch (Exception e) {
            LOGGER.error("Error getting option values: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all option texts (labels) from the select element.
     * 
     * @return The list of option texts
     */
    public List<String> getOptionTexts() {
        try {
            LOGGER.debug("Getting all option texts from select element: {}", getSelector());
            
            int count = optionsLocator.count();
            List<String> texts = new ArrayList<>();
            
            for (int i = 0; i < count; i++) {
                Locator option = optionsLocator.nth(i);
                String text = option.textContent();
                if (text != null) {
                    texts.add(text.trim());
                }
            }
            
            return texts;
        } catch (Exception e) {
            LOGGER.error("Error getting option texts: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all options from the select element as a map of value to text.
     * 
     * @return The map of option values to texts
     */
    public Map<String, String> getOptions() {
        try {
            LOGGER.debug("Getting all options from select element: {}", getSelector());
            
            int count = optionsLocator.count();
            Map<String, String> options = new HashMap<>();
            
            for (int i = 0; i < count; i++) {
                Locator option = optionsLocator.nth(i);
                String value = option.getAttribute("value");
                String text = option.textContent();
                
                if (value != null && text != null) {
                    options.put(value, text.trim());
                }
            }
            
            return options;
        } catch (Exception e) {
            LOGGER.error("Error getting options: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the selected option value.
     * 
     * @return The selected option value, or null if no option is selected
     */
    public String getSelectedValue() {
        try {
            LOGGER.debug("Getting selected value from select element: {}", getSelector());
            
            String script = "return Array.from(element.selectedOptions).map(o => o.value)[0] || ''";
            return (String) getLocator().evaluate(script);
        } catch (Exception e) {
            LOGGER.error("Error getting selected value: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the selected option text (label).
     * 
     * @return The selected option text, or null if no option is selected
     */
    public String getSelectedText() {
        try {
            LOGGER.debug("Getting selected text from select element: {}", getSelector());
            
            String script = "return Array.from(element.selectedOptions).map(o => o.text)[0] || ''";
            return (String) getLocator().evaluate(script);
        } catch (Exception e) {
            LOGGER.error("Error getting selected text: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all selected option values for a multi-select.
     * 
     * @return The list of selected option values
     */
    public List<String> getSelectedValues() {
        try {
            LOGGER.debug("Getting all selected values from select element: {}", getSelector());
            
            Object result = getLocator().evaluate("return Array.from(element.selectedOptions).map(o => o.value)");
            
            @SuppressWarnings("unchecked")
            List<String> values = (List<String>) result;
            return values;
        } catch (Exception e) {
            LOGGER.error("Error getting selected values: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all selected option texts (labels) for a multi-select.
     * 
     * @return The list of selected option texts
     */
    public List<String> getSelectedTexts() {
        try {
            LOGGER.debug("Getting all selected texts from select element: {}", getSelector());
            
            Object result = getLocator().evaluate("return Array.from(element.selectedOptions).map(o => o.text)");
            
            @SuppressWarnings("unchecked")
            List<String> texts = (List<String>) result;
            return texts;
        } catch (Exception e) {
            LOGGER.error("Error getting selected texts: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the number of options in the select element.
     * 
     * @return The number of options
     */
    public int getOptionCount() {
        try {
            LOGGER.debug("Getting option count from select element: {}", getSelector());
            return optionsLocator.count();
        } catch (Exception e) {
            LOGGER.error("Error getting option count: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if the select element has the specified option value.
     * 
     * @param value The option value to check
     * @return True if the option exists, false otherwise
     */
    public boolean hasOptionWithValue(String value) {
        try {
            LOGGER.debug("Checking if select element has option with value '{}': {}", value, getSelector());
            List<String> values = getOptionValues();
            return values.contains(value);
        } catch (Exception e) {
            LOGGER.error("Error checking if option with value '{}' exists: {}", value, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if the select element has the specified option text (label).
     * 
     * @param text The option text to check
     * @return True if the option exists, false otherwise
     */
    public boolean hasOptionWithText(String text) {
        try {
            LOGGER.debug("Checking if select element has option with text '{}': {}", text, getSelector());
            List<String> texts = getOptionTexts();
            return texts.contains(text);
        } catch (Exception e) {
            LOGGER.error("Error checking if option with text '{}' exists: {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if the select element is a multi-select.
     * 
     * @return True if the element is a multi-select, false otherwise
     */
    public boolean isMultiple() {
        try {
            LOGGER.debug("Checking if select element is multi-select: {}", getSelector());
            return Boolean.TRUE.equals(getLocator().evaluate("return element.multiple"));
        } catch (Exception e) {
            LOGGER.error("Error checking if select element is multi-select: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for an option with the specified value to be present.
     * 
     * @param value The option value to wait for
     * @param timeoutMillis The timeout in milliseconds, or 0 to use the default timeout
     * @return This CSSelect for chaining
     */
    public CSSelect waitForOptionWithValue(String value, long timeoutMillis) {
        try {
            LOGGER.info("Waiting for option with value '{}' in select element: {}", value, getSelector());
            
            if (timeoutMillis <= 0) {
                timeoutMillis = getTimeoutFromConfig();
            }
            
            long startTime = System.currentTimeMillis();
            long endTime = startTime + timeoutMillis;
            
            while (System.currentTimeMillis() < endTime) {
                if (hasOptionWithValue(value)) {
                    return this;
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for option with value", e);
                }
            }
            
            throw new RuntimeException("Timeout waiting for option with value: " + value);
        } catch (Exception e) {
            LOGGER.error("Error waiting for option with value '{}': {}", value, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for an option with the specified value to be present with the default timeout.
     * 
     * @param value The option value to wait for
     * @return This CSSelect for chaining
     */
    public CSSelect waitForOptionWithValue(String value) {
        return waitForOptionWithValue(value, 0);
    }
    
    /**
     * Waits for an option with the specified text (label) to be present.
     * 
     * @param text The option text to wait for
     * @param timeoutMillis The timeout in milliseconds, or 0 to use the default timeout
     * @return This CSSelect for chaining
     */
    public CSSelect waitForOptionWithText(String text, long timeoutMillis) {
        try {
            LOGGER.info("Waiting for option with text '{}' in select element: {}", text, getSelector());
            
            if (timeoutMillis <= 0) {
                timeoutMillis = getTimeoutFromConfig();
            }
            
            long startTime = System.currentTimeMillis();
            long endTime = startTime + timeoutMillis;
            
            while (System.currentTimeMillis() < endTime) {
                if (hasOptionWithText(text)) {
                    return this;
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for option with text", e);
                }
            }
            
            throw new RuntimeException("Timeout waiting for option with text: " + text);
        } catch (Exception e) {
            LOGGER.error("Error waiting for option with text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Waits for an option with the specified text (label) to be present with the default timeout.
     * 
     * @param text The option text to wait for
     * @return This CSSelect for chaining
     */
    public CSSelect waitForOptionWithText(String text) {
        return waitForOptionWithText(text, 0);
    }
    
    /**
     * Gets the timeout from configuration.
     * 
     * @return The timeout in milliseconds
     */
    private int getTimeoutFromConfig() {
        try {
            ConfigurationManager configManager = ConfigurationManager.getInstance();
            return configManager.getInt("playwright.element.timeout", 30000);
        } catch (Exception e) {
            LOGGER.warn("Error getting timeout from config: {}", e.getMessage());
            return 30000;
        }
    }
    
    /**
     * Gets an option element by its value.
     * 
     * @param value The option value
     * @return The option element, or null if not found
     */
    public CSElement getOptionByValue(String value) {
        try {
            LOGGER.debug("Getting option with value '{}' from select element: {}", value, getSelector());
            Locator optionLocator = optionsLocator.filter(new Locator.FilterOptions().setHas(
                    optionsLocator.getPage().locator("[value='" + value + "']")));
            
            if (optionLocator.count() > 0) {
                return new CSElement(optionLocator, getSelector() + " > option[value='" + value + "']");
            }
            return null;
        } catch (Exception e) {
            LOGGER.error("Error getting option by value '{}': {}", value, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets an option element by its text (label).
     * 
     * @param text The option text
     * @return The option element, or null if not found
     */
    public CSElement getOptionByText(String text) {
        try {
            LOGGER.debug("Getting option with text '{}' from select element: {}", text, getSelector());
            Locator optionLocator = optionsLocator.filter(new Locator.FilterOptions().setHasText(text));
            
            if (optionLocator.count() > 0) {
                return new CSElement(optionLocator, getSelector() + " > option:has-text('" + text + "')");
            }
            return null;
        } catch (Exception e) {
            LOGGER.error("Error getting option by text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets disabled options from the select element.
     * 
     * @return The list of disabled option values
     */
    public List<String> getDisabledOptions() {
        try {
            LOGGER.debug("Getting disabled options from select element: {}", getSelector());
            
            int count = optionsLocator.count();
            List<String> disabledOptions = new ArrayList<>();
            
            for (int i = 0; i < count; i++) {
                Locator option = optionsLocator.nth(i);
                if (Boolean.TRUE.equals(option.isDisabled())) {
                    String value = option.getAttribute("value");
                    if (value != null) {
                        disabledOptions.add(value);
                    }
                }
            }
            
            return disabledOptions;
        } catch (Exception e) {
            LOGGER.error("Error getting disabled options: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects the first option in the select element.
     * 
     * @return This CSSelect for chaining
     */
    public CSSelect selectFirstOption() {
        try {
            LOGGER.info("Selecting first option from select element: {}", getSelector());
            return selectByIndex(0);
        } catch (Exception e) {
            LOGGER.error("Error selecting first option: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Selects the last option in the select element.
     * 
     * @return This CSSelect for chaining
     */
    public CSSelect selectLastOption() {
        try {
            LOGGER.info("Selecting last option from select element: {}", getSelector());
            int count = getOptionCount();
            if (count > 0) {
                return selectByIndex(count - 1);
            }
            throw new RuntimeException("No options available to select");
        } catch (Exception e) {
            LOGGER.error("Error selecting last option: {}", e.getMessage(), e);
            throw e;
        }
    }
}


CSForm.java
-------------------------

package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Frame;
import com.microsoft.playwright.options.AriaRole;
import com.microsoft.playwright.options.WaitForSelectorOptions;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Enhanced wrapper for Playwright's form operations.
 * Provides advanced functionality for interacting with form elements.
 */
public class CSForm extends CSElement {
    private static final CSLogger LOGGER = new CSLogger(CSForm.class);
    
    /**
     * Constructs a new CSForm with the specified page and selector.
     * 
     * @param page The Playwright page
     * @param selector The selector for the form element
     */
    public CSForm(Page page, String selector) {
        super(page, selector);
        LOGGER.debug("Created CSForm with selector: {}", selector);
    }
    
    /**
     * Constructs a new CSForm with the specified frame and selector.
     * 
     * @param frame The Playwright frame
     * @param selector The selector for the form element
     */
    public CSForm(Frame frame, String selector) {
        super(frame, selector);
        LOGGER.debug("Created CSForm with selector: {} in frame", selector);
    }
    
    /**
     * Constructs a new CSForm with a pre-existing locator.
     * 
     * @param locator The Playwright locator for the form element
     * @param selector The original selector (for logging)
     */
    public CSForm(Locator locator, String selector) {
        super(locator, selector);
        LOGGER.debug("Created CSForm with existing locator: {}", selector);
    }
    
    /**
     * Submits the form.
     * 
     * @return This CSForm for chaining
     */
    public CSForm submit() {
        try {
            LOGGER.info("Submitting form: {}", getSelector());
            getLocator().evaluate("form => form.submit()");
            return this;
        } catch (Exception e) {
            LOGGER.error("Error submitting form: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Fills the form with the provided values.
     * 
     * @param formData The map of field names to values
     * @return This CSForm for chaining
     */
    public CSForm fill(Map<String, String> formData) {
        try {
            LOGGER.info("Filling form with data: {}", getSelector());
            
            for (Map.Entry<String, String> entry : formData.entrySet()) {
                String fieldName = entry.getKey();
                String value = entry.getValue();
                
                fillField(fieldName, value);
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Error filling form: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Fills a specific field in the form.
     * 
     * @param fieldName The field name or selector
     * @param value The value to fill
     * @return This CSForm for chaining
     */
    public CSForm fillField(String fieldName, String value) {
        try {
            LOGGER.info("Filling form field '{}' with value: {}", fieldName, getSelector());
            
            // Try to find the field by name
            Locator field = findField(fieldName);
            
            if (field == null || field.count() == 0) {
                throw new RuntimeException("Field not found: " + fieldName);
            }
            
            // Get the field type
            String type = field.getAttribute("type");
            if (type == null) {
                type = "";
            }
            
            // Handle different field types
            switch (type.toLowerCase()) {
                case "checkbox":
                    boolean check = "true".equalsIgnoreCase(value) || "yes".equalsIgnoreCase(value) 
                            || "on".equalsIgnoreCase(value) || "1".equals(value);
                    if (check) {
                        field.check();
                    } else {
                        field.uncheck();
                    }
                    break;
                case "radio":
                    field.check();
                    break;
                case "file":
                    if (value != null && !value.isEmpty()) {
                        field.setInputFiles(Paths.get(value));
                    }
                    break;
                case "select-one":
                case "select-multiple":
                    // Handle select element
                    CSSelect select = new CSSelect(field, fieldName);
                    select.selectByValue(value);
                    break;
                default:
                    // Default to fill for text inputs, textareas, etc.
                    field.fill(value);
                    break;
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Error filling field '{}': {}", fieldName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Fills multiple file input fields.
     * 
     * @param fieldName The field name or selector
     * @param filePaths The paths to the files to upload
     * @return This CSForm for chaining
     */
    public CSForm fillFileField(String fieldName, String... filePaths) {
        try {
            LOGGER.info("Filling file field '{}' with files: {}", fieldName, getSelector());
            
            if (filePaths == null || filePaths.length == 0) {
                return this;
            }
            
            // Try to find the field by name
            Locator field = findField(fieldName);
            
            if (field == null || field.count() == 0) {
                throw new RuntimeException("Field not found: " + fieldName);
            }
            
            // Convert file paths to Path objects
            Path[] paths = new Path[filePaths.length];
            for (int i = 0; i < filePaths.length; i++) {
                paths[i] = Paths.get(filePaths[i]);
            }
            
            // Set input files
            field.setInputFiles(paths);
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Error filling file field '{}': {}", fieldName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Clears a specific field in the form.
     * 
     * @param fieldName The field name or selector
     * @return This CSForm for chaining
     */
    public CSForm clearField(String fieldName) {
        try {
            LOGGER.info("Clearing form field '{}': {}", fieldName, getSelector());
            
            // Try to find the field by name
            Locator field = findField(fieldName);
            
            if (field == null || field.count() == 0) {
                throw new RuntimeException("Field not found: " + fieldName);
            }
            
            // Get the field type
            String type = field.getAttribute("type");
            if (type == null) {
                type = "";
            }
            
            // Handle different field types
            switch (type.toLowerCase()) {
                case "checkbox":
                case "radio":
                    // Uncheck for checkboxes
                    field.uncheck();
                    break;
                case "file":
                    // Clear file input by setting empty array
                    field.setInputFiles(new Path[0]);
                    break;
                case "select-one":
                case "select-multiple":
                    // For select, try to select the first option or clear all selections
                    try {
                        field.selectOption(new Locator.SelectOptionOptions().setIndex(0));
                    } catch (Exception ex) {
                        // If selecting first option fails, try to clear all selections
                        field.evaluate("select => { select.selectedIndex = -1; }");
                    }
                    break;
                default:
                    // Default to clear for text inputs, textareas, etc.
                    field.clear();
                    break;
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Error clearing field '{}': {}", fieldName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the value of a specific field in the form.
     * 
     * @param fieldName The field name or selector
     * @return The field value
     */
    public String getFieldValue(String fieldName) {
        try {
            LOGGER.debug("Getting value of form field '{}': {}", fieldName, getSelector());
            
            // Try to find the field by name
            Locator field = findField(fieldName);
            
            if (field == null || field.count() == 0) {
                throw new RuntimeException("Field not found: " + fieldName);
            }
            
            // Get the field type
            String type = field.getAttribute("type");
            if (type == null) {
                type = "";
            }
            
            String nodeName = (String) field.evaluate("el => el.nodeName.toLowerCase()");
            
            // Handle different field types
            switch (type.toLowerCase()) {
                case "checkbox":
                case "radio":
                    return Boolean.toString(field.isChecked());
                case "file":
                    // For file inputs, we can't get the actual file path for security reasons
                    // Return a placeholder or the file name if available
                    return (String) field.evaluate("input => input.files.length > 0 ? Array.from(input.files).map(f => f.name).join(', ') : ''");
                case "select-one":
                case "select-multiple":
                    // For select elements, get the selected value(s)
                    CSSelect select = new CSSelect(field, fieldName);
                    if (type.equalsIgnoreCase("select-multiple") || "select".equalsIgnoreCase(nodeName) && "true".equalsIgnoreCase(field.getAttribute("multiple"))) {
                        return String.join(", ", select.getSelectedValues());
                    } else {
                        return select.getSelectedValue();
                    }
                default:
                    // Default to value attribute for other inputs
                    return field.inputValue();
            }
        } catch (Exception e) {
            LOGGER.error("Error getting value of field '{}': {}", fieldName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all form field values.
     * 
     * @return The map of field names to values
     */
    public Map<String, String> getValues() {
        try {
            LOGGER.debug("Getting all form field values: {}", getSelector());
            
            // Get all form fields
            List<Locator> fields = findAllFields();
            Map<String, String> values = new HashMap<>();
            
            for (Locator field : fields) {
                String name = field.getAttribute("name");
                
                // Skip fields without a name
                if (name == null || name.isEmpty()) {
                    continue;
                }
                
                // Only add the field to the values map if it doesn't exist yet or is checked (for radio buttons)
                if (!values.containsKey(name) || field.isChecked()) {
                    String type = field.getAttribute("type");
                    if (type == null) {
                        type = "";
                    }
                    
                    // Handle different field types
                    switch (type.toLowerCase()) {
                        case "checkbox":
                        case "radio":
                            if (field.isChecked()) {
                                values.put(name, type.equalsIgnoreCase("checkbox") 
                                    ? "true" 
                                    : field.getAttribute("value"));
                            }
                            break;
                        case "file":
                            values.put(name, (String) field.evaluate("input => input.files.length > 0 ? Array.from(input.files).map(f => f.name).join(', ') : ''"));
                            break;
                        case "select-one":
                        case "select-multiple":
                            CSSelect select = new CSSelect(field, name);
                            values.put(name, type.equalsIgnoreCase("select-multiple") 
                                ? String.join(", ", select.getSelectedValues()) 
                                : select.getSelectedValue());
                            break;
                        default:
                            values.put(name, field.inputValue());
                            break;
                    }
                }
            }
            
            return values;
        } catch (Exception e) {
            LOGGER.error("Error getting form values: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Resets the form to its initial values.
     * 
     * @return This CSForm for chaining
     */
    public CSForm reset() {
        try {
            LOGGER.info("Resetting form: {}", getSelector());
            getLocator().evaluate("form => form.reset()");
            return this;
        } catch (Exception e) {
            LOGGER.error("Error resetting form: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Validates the form using HTML5 validation.
     * 
     * @return True if the form is valid, false otherwise
     */
    public boolean isValid() {
        try {
            LOGGER.debug("Validating form: {}", getSelector());
            return Boolean.TRUE.equals(getLocator().evaluate("form => form.checkValidity()"));
        } catch (Exception e) {
            LOGGER.error("Error validating form: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the validation messages for all form fields.
     * 
     * @return The map of field names to validation messages
     */
    public Map<String, String> getValidationMessages() {
        try {
            LOGGER.debug("Getting form validation messages: {}", getSelector());
            
            // Get all form fields
            List<Locator> fields = findAllFields();
            Map<String, String> messages = new HashMap<>();
            
            for (Locator field : fields) {
                String name = field.getAttribute("name");
                
                // Skip fields without a name
                if (name == null || name.isEmpty()) {
                    continue;
                }
                
                // Get the validation message
                String message = (String) field.evaluate("el => el.validationMessage");
                
                // Only add non-empty messages
                if (message != null && !message.isEmpty()) {
                    messages.put(name, message);
                }
            }
            
            return messages;
        } catch (Exception e) {
            LOGGER.error("Error getting form validation messages: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the field by name or selector.
     * 
     * @param fieldName The field name or selector
     * @return The field locator, or null if not found
     */
    private Locator findField(String fieldName) {
        try {
            // Try to find the field by name attribute
            Locator field = getLocator().locator("[name='" + fieldName + "']");
            
            // If not found, try by ID
            if (field.count() == 0) {
                field = getLocator().locator("#" + fieldName);
            }
            
            // If still not found, try by any other selector
            if (field.count() == 0) {
                field = getLocator().locator(fieldName);
            }
            
            return field;
        } catch (Exception e) {
            LOGGER.warn("Error finding field '{}': {}", fieldName, e.getMessage());
            return null;
        }
    }
    
    /**
     * Finds all form fields.
     * 
     * @return The list of field locators
     */
    private List<Locator> findAllFields() {
        List<Locator> fields = new ArrayList<>();
        
        try {
            // Find all input elements
            Locator inputs = getLocator().locator("input:not([type='button']):not([type='submit']):not([type='reset']):not([type='image']):not([type='hidden'])");
            for (int i = 0; i < inputs.count(); i++) {
                fields.add(inputs.nth(i));
            }
            
            // Find all textarea elements
            Locator textareas = getLocator().locator("textarea");
            for (int i = 0; i < textareas.count(); i++) {
                fields.add(textareas.nth(i));
            }
            
            // Find all select elements
            Locator selects = getLocator().locator("select");
            for (int i = 0; i < selects.count(); i++) {
                fields.add(selects.nth(i));
            }
        } catch (Exception e) {
            LOGGER.warn("Error finding form fields: {}", e.getMessage());
        }
        
        return fields;
    }
    
    /**
     * Clicks a button or input of type button/submit/reset in the form.
     * 
     * @param buttonText The button text or value
     * @return This CSForm for chaining
     */
    public CSForm clickButton(String buttonText) {
        try {
            LOGGER.info("Clicking button '{}' in form: {}", buttonText, getSelector());
            
            // Try to find the button by text
            Locator button = getLocator().locator("button:has-text('" + buttonText + "'), " +
                                               "input[type='submit'][value='" + buttonText + "'], " +
                                               "input[type='button'][value='" + buttonText + "'], " +
                                               "input[type='reset'][value='" + buttonText + "']");
            
            if (button.count() == 0) {
                // Try to find by inner HTML
                button = getLocator().locator("button:has-text('" + buttonText + "')");
            }
            
            if (button.count() == 0) {
                // Try to find by role
                button = getLocator().getPage().getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName(buttonText));
            }
            
            if (button.count() == 0) {
                throw new RuntimeException("Button not found: " + buttonText);
            }
            
            button.click();
            return this;
        } catch (Exception e) {
            LOGGER.error("Error clicking button '{}': {}", buttonText, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Clicks a submit button in the form.
     * 
     * @return This CSForm for chaining
     */
    public CSForm clickSubmit() {
        try {
            LOGGER.info("Clicking submit button in form: {}", getSelector());
            
            // Try to find the submit button
            Locator submitButton = getLocator().locator("button[type='submit'], input[type='submit']");
            
            if (submitButton.count() == 0) {
                // If no explicit submit button, try to submit the form
                return submit();
            }
            
            submitButton.click();
            return this;
        } catch (Exception e) {
            LOGGER.error("Error clicking submit button: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets a field element by name.
     * 
     * @param fieldName The field name
     * @return The CSElement for the field
     */
    public CSElement getField(String fieldName) {
        try {
            LOGGER.debug("Getting field '{}' from form: {}", fieldName, getSelector());
            
            Locator field = findField(fieldName);
            if (field == null || field.count() == 0) {
                throw new RuntimeException("Field not found: " + fieldName);
            }
            
            return new CSElement(field, getSelector() + " [name='" + fieldName + "']");
        } catch (Exception e) {
            LOGGER.error("Error getting field '{}': {}", fieldName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets a select field by name.
     * 
     * @param fieldName The field name
     * @return The CSSelect for the field
     */
    public CSSelect getSelectField(String fieldName) {
        try {
            LOGGER.debug("Getting select field '{}' from form: {}", fieldName, getSelector());
            
            Locator field = findField(fieldName);
            if (field == null || field.count() == 0) {
                throw new RuntimeException("Field not found: " + fieldName);
            }
            
            String nodeName = (String) field.evaluate("el => el.nodeName.toLowerCase()");
            if (!"select".equals(nodeName)) {
                throw new RuntimeException("Field is not a select element: " + fieldName);
            }
            
            return new CSSelect(field, getSelector() + " [name='" + fieldName + "']");
        } catch (Exception e) {
            LOGGER.error("Error getting select field '{}': {}", fieldName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if a field exists in the form.
     * 
     * @param fieldName The field name
     * @return True if the field exists, false otherwise
     */
    public boolean hasField(String fieldName) {
        try {
            LOGGER.debug("Checking if field '{}' exists in form: {}", fieldName, getSelector());
            
            Locator field = findField(fieldName);
            return field != null && field.count() > 0;
        } catch (Exception e) {
            LOGGER.warn("Error checking if field '{}' exists: {}", fieldName, e.getMessage());
            return false;
        }
    }
    
    /**
     * Gets the form action URL.
     * 
     * @return The form action URL
     */
    public String getAction() {
        try {
            LOGGER.debug("Getting form action: {}", getSelector());
            return getLocator().getAttribute("action");
        } catch (Exception e) {
            LOGGER.error("Error getting form action: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the form method (GET, POST, etc.).
     * 
     * @return The form method
     */
    public String getMethod() {
        try {
            LOGGER.debug("Getting form method: {}", getSelector());
            return getLocator().getAttribute("method");
        } catch (Exception e) {
            LOGGER.error("Error getting form method: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets field errors based on aria-invalid and error messages.
     * 
     * @return The map of field names to error messages
     */
    public Map<String, String> getFieldErrors() {
        try {
            LOGGER.debug("Getting form field errors: {}", getSelector());
            
            Map<String, String> errors = new HashMap<>();
            List<Locator> invalidFields = new ArrayList<>();
            
            // Find all fields with aria-invalid attribute
            Locator ariaInvalidFields = getLocator().locator("[aria-invalid='true']");
            for (int i = 0; i < ariaInvalidFields.count(); i++) {
                invalidFields.add(ariaInvalidFields.nth(i));
            }
            
            // Find all fields with HTML5 validation errors
            List<Locator> fields = findAllFields();
            for (Locator field : fields) {
                if (!invalidFields.contains(field)) {
                    boolean invalid = Boolean.FALSE.equals(field.evaluate("el => el.validity.valid"));
                    if (invalid) {
                        invalidFields.add(field);
                    }
                }
            }
            
            // Get error messages for invalid fields
            for (Locator field : invalidFields) {
                String name = field.getAttribute("name");
                if (name == null || name.isEmpty()) {
                    continue;
                }
                
                // Try to get the error message from different sources
                String errorMessage = null;
                
                // Try aria-errormessage first
                String ariaErrorMessage = field.getAttribute("aria-errormessage");
                if (ariaErrorMessage != null && !ariaErrorMessage.isEmpty()) {
                    // Check if it's an ID reference
                    if (ariaErrorMessage.startsWith("#")) {
                        Locator errorElement = getLocator().getPage().locator(ariaErrorMessage);
                        if (errorElement.count() > 0) {
                            errorMessage = errorElement.textContent();
                        }
                    } else {
                        errorMessage = ariaErrorMessage;
                    }
                }
                
                // If no aria-errormessage, try validation message
                if (errorMessage == null || errorMessage.isEmpty()) {
                    errorMessage = (String) field.evaluate("el => el.validationMessage");
                }
                
                // If still no message, try to find an error element nearby
                if (errorMessage == null || errorMessage.isEmpty()) {
                    // Try common error patterns (this varies greatly across websites)
                    Locator errorElement = field.locator("xpath=../following-sibling::*[contains(@class, 'error')][1]");
                    if (errorElement.count() > 0) {
                        errorMessage = errorElement.textContent();
                    } else {
                        errorElement = field.locator("xpath=../following-sibling::*[contains(@class, 'invalid')][1]");
                        if (errorElement.count() > 0) {
                            errorMessage = errorElement.textContent();
                        }
                    }
                }
                
                // Add error message if found
                if (errorMessage != null && !errorMessage.isEmpty()) {
                    errors.put(name, errorMessage.trim());
                } else {
                    // Use a default message if none found
                    errors.put(name, "Field is invalid");
                }
            }
            
            return errors;
        } catch (Exception e) {
            LOGGER.error("Error getting form field errors: {}", e.getMessage(), e);
            throw e;
        }
    }
}


CSTable.java
--------------------------

package com.cstestforge.framework.playwright.java.element;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Frame;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Enhanced wrapper for Playwright's table element operations.
 * Provides advanced functionality for interacting with HTML tables.
 */
public class CSTable extends CSElement {
    private static final CSLogger LOGGER = new CSLogger(CSTable.class);
    
    private final Locator headerRowLocator;
    private final Locator bodyRowsLocator;
    private final Locator footerRowLocator;
    private List<String> headerTexts;
    
    /**
     * Constructs a new CSTable with the specified page and selector.
     * 
     * @param page The Playwright page
     * @param selector The selector for the table element
     */
    public CSTable(Page page, String selector) {
        super(page, selector);
        this.headerRowLocator = page.locator(selector + " > thead > tr, " + selector + " > tr:first-child");
        this.bodyRowsLocator = page.locator(selector + " > tbody > tr, " + selector + " > tr:not(:first-child):not(:last-child)");
        this.footerRowLocator = page.locator(selector + " > tfoot > tr, " + selector + " > tr:last-child");
        LOGGER.debug("Created CSTable with selector: {}", selector);
    }
    
    /**
     * Constructs a new CSTable with the specified frame and selector.
     * 
     * @param frame The Playwright frame
     * @param selector The selector for the table element
     */
    public CSTable(Frame frame, String selector) {
        super(frame, selector);
        this.headerRowLocator = frame.locator(selector + " > thead > tr, " + selector + " > tr:first-child");
        this.bodyRowsLocator = frame.locator(selector + " > tbody > tr, " + selector + " > tr:not(:first-child):not(:last-child)");
        this.footerRowLocator = frame.locator(selector + " > tfoot > tr, " + selector + " > tr:last-child");
        LOGGER.debug("Created CSTable with selector: {} in frame", selector);
    }
    
    /**
     * Constructs a new CSTable with a pre-existing locator.
     * 
     * @param locator The Playwright locator for the table element
     * @param selector The original selector (for logging)
     */
    public CSTable(Locator locator, String selector) {
        super(locator, selector);
        this.headerRowLocator = locator.locator("thead > tr, tr:first-child");
        this.bodyRowsLocator = locator.locator("tbody > tr, tr:not(:first-child):not(:last-child)");
        this.footerRowLocator = locator.locator("tfoot > tr, tr:last-child");
        LOGGER.debug("Created CSTable with existing locator: {}", selector);
    }
    
    /**
     * Gets the number of rows in the table body.
     * 
     * @return The number of rows
     */
    public int getRowCount() {
        try {
            LOGGER.debug("Getting row count from table: {}", getSelector());
            return bodyRowsLocator.count();
        } catch (Exception e) {
            LOGGER.error("Error getting row count: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the number of columns in the table.
     * 
     * @return The number of columns
     */
    public int getColumnCount() {
        try {
            LOGGER.debug("Getting column count from table: {}", getSelector());
            
            // Try to get column count from header first
            if (headerRowLocator.count() > 0) {
                Locator headerCells = headerRowLocator.first().locator("th, td");
                int count = headerCells.count();
                if (count > 0) {
                    return count;
                }
            }
            
            // If no header or header has no cells, try to get from first body row
            if (bodyRowsLocator.count() > 0) {
                Locator firstRowCells = bodyRowsLocator.first().locator("td, th");
                return firstRowCells.count();
            }
            
            // If no rows at all, return 0
            return 0;
        } catch (Exception e) {
            LOGGER.error("Error getting column count: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the header texts from the table.
     * 
     * @return The list of header texts
     */
    public List<String> getHeaderTexts() {
        try {
            LOGGER.debug("Getting header texts from table: {}", getSelector());
            
            if (headerTexts != null) {
                return headerTexts;
            }
            
            if (headerRowLocator.count() == 0) {
                return Collections.emptyList();
            }
            
            Locator headerCells = headerRowLocator.first().locator("th, td");
            int count = headerCells.count();
            List<String> texts = new ArrayList<>();
            
            for (int i = 0; i < count; i++) {
                Locator cell = headerCells.nth(i);
                texts.add(cell.textContent().trim());
            }
            
            headerTexts = texts;
            return texts;
        } catch (Exception e) {
            LOGGER.error("Error getting header texts: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the cell text at the specified row and column.
     * 
     * @param rowIndex The row index (0-based)
     * @param colIndex The column index (0-based)
     * @return The cell text
     */
    public String getCellText(int rowIndex, int colIndex) {
        try {
            LOGGER.debug("Getting cell text at row {}, column {} from table: {}", rowIndex, colIndex, getSelector());
            
            if (rowIndex < 0 || colIndex < 0) {
                throw new IndexOutOfBoundsException("Row and column indices must be non-negative");
            }
            
            if (rowIndex >= getRowCount()) {
                throw new IndexOutOfBoundsException("Row index out of bounds: " + rowIndex);
            }
            
            Locator row = bodyRowsLocator.nth(rowIndex);
            Locator cells = row.locator("td, th");
            
            if (colIndex >= cells.count()) {
                throw new IndexOutOfBoundsException("Column index out of bounds: " + colIndex);
            }
            
            return cells.nth(colIndex).textContent().trim();
        } catch (Exception e) {
            LOGGER.error("Error getting cell text at row {}, column {}: {}", rowIndex, colIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the cell element at the specified row and column.
     * 
     * @param rowIndex The row index (0-based)
     * @param colIndex The column index (0-based)
     * @return The cell element
     */
    public CSElement getCell(int rowIndex, int colIndex) {
        try {
            LOGGER.debug("Getting cell at row {}, column {} from table: {}", rowIndex, colIndex, getSelector());
            
            if (rowIndex < 0 || colIndex < 0) {
                throw new IndexOutOfBoundsException("Row and column indices must be non-negative");
            }
            
            if (rowIndex >= getRowCount()) {
                throw new IndexOutOfBoundsException("Row index out of bounds: " + rowIndex);
            }
            
            Locator row = bodyRowsLocator.nth(rowIndex);
            Locator cells = row.locator("td, th");
            
            if (colIndex >= cells.count()) {
                throw new IndexOutOfBoundsException("Column index out of bounds: " + colIndex);
            }
            
            Locator cell = cells.nth(colIndex);
            return new CSElement(cell, getSelector() + " > tbody > tr:nth-child(" + (rowIndex + 1) + ") > td:nth-child(" + (colIndex + 1) + ")");
        } catch (Exception e) {
            LOGGER.error("Error getting cell at row {}, column {}: {}", rowIndex, colIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the cell text by column name and row index.
     * 
     * @param columnName The column name (header text)
     * @param rowIndex The row index (0-based)
     * @return The cell text
     */
    public String getCellTextByColumnName(String columnName, int rowIndex) {
        try {
            LOGGER.debug("Getting cell text by column name '{}', row {} from table: {}", columnName, rowIndex, getSelector());
            
            List<String> headers = getHeaderTexts();
            int colIndex = headers.indexOf(columnName);
            
            if (colIndex == -1) {
                throw new IllegalArgumentException("Column not found: " + columnName);
            }
            
            return getCellText(rowIndex, colIndex);
        } catch (Exception e) {
            LOGGER.error("Error getting cell text by column name '{}', row {}: {}", columnName, rowIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the cell element by column name and row index.
     * 
     * @param columnName The column name (header text)
     * @param rowIndex The row index (0-based)
     * @return The cell element
     */
    public CSElement getCellByColumnName(String columnName, int rowIndex) {
        try {
            LOGGER.debug("Getting cell by column name '{}', row {} from table: {}", columnName, rowIndex, getSelector());
            
            List<String> headers = getHeaderTexts();
            int colIndex = headers.indexOf(columnName);
            
            if (colIndex == -1) {
                throw new IllegalArgumentException("Column not found: " + columnName);
            }
            
            return getCell(rowIndex, colIndex);
        } catch (Exception e) {
            LOGGER.error("Error getting cell by column name '{}', row {}: {}", columnName, rowIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all row data as maps of column name to cell text.
     * 
     * @return The list of row data maps
     */
    public List<Map<String, String>> getRowsData() {
        try {
            LOGGER.debug("Getting all rows data from table: {}", getSelector());
            
            List<String> headers = getHeaderTexts();
            int rowCount = getRowCount();
            List<Map<String, String>> rowsData = new ArrayList<>();
            
            for (int i = 0; i < rowCount; i++) {
                Map<String, String> rowData = new HashMap<>();
                Locator row = bodyRowsLocator.nth(i);
                Locator cells = row.locator("td, th");
                
                for (int j = 0; j < Math.min(headers.size(), cells.count()); j++) {
                    String header = headers.get(j);
                    String cellText = cells.nth(j).textContent().trim();
                    rowData.put(header, cellText);
                }
                
                rowsData.add(rowData);
            }
            
            return rowsData;
        } catch (Exception e) {
            LOGGER.error("Error getting rows data: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets a specific row's data as a map of column name to cell text.
     * 
     * @param rowIndex The row index (0-based)
     * @return The row data map
     */
    public Map<String, String> getRowData(int rowIndex) {
        try {
            LOGGER.debug("Getting row data at index {} from table: {}", rowIndex, getSelector());
            
            if (rowIndex < 0 || rowIndex >= getRowCount()) {
                throw new IndexOutOfBoundsException("Row index out of bounds: " + rowIndex);
            }
            
            List<String> headers = getHeaderTexts();
            Map<String, String> rowData = new HashMap<>();
            Locator row = bodyRowsLocator.nth(rowIndex);
            Locator cells = row.locator("td, th");
            
            for (int j = 0; j < Math.min(headers.size(), cells.count()); j++) {
                String header = headers.get(j);
                String cellText = cells.nth(j).textContent().trim();
                rowData.put(header, cellText);
            }
            
            return rowData;
        } catch (Exception e) {
            LOGGER.error("Error getting row data at index {}: {}", rowIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets a column's data as a list of cell texts.
     * 
     * @param colIndex The column index (0-based)
     * @return The list of cell texts
     */
    public List<String> getColumnData(int colIndex) {
        try {
            LOGGER.debug("Getting column data at index {} from table: {}", colIndex, getSelector());
            
            if (colIndex < 0 || colIndex >= getColumnCount()) {
                throw new IndexOutOfBoundsException("Column index out of bounds: " + colIndex);
            }
            
            int rowCount = getRowCount();
            List<String> columnData = new ArrayList<>();
            
            for (int i = 0; i < rowCount; i++) {
                Locator row = bodyRowsLocator.nth(i);
                Locator cells = row.locator("td, th");
                
                if (colIndex < cells.count()) {
                    columnData.add(cells.nth(colIndex).textContent().trim());
                } else {
                    // Handle mismatched row lengths
                    columnData.add("");
                }
            }
            
            return columnData;
        } catch (Exception e) {
            LOGGER.error("Error getting column data at index {}: {}", colIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets a column's data by column name as a list of cell texts.
     * 
     * @param columnName The column name (header text)
     * @return The list of cell texts
     */
    public List<String> getColumnDataByName(String columnName) {
        try {
            LOGGER.debug("Getting column data by name '{}' from table: {}", columnName, getSelector());
            
            List<String> headers = getHeaderTexts();
            int colIndex = headers.indexOf(columnName);
            
            if (colIndex == -1) {
                throw new IllegalArgumentException("Column not found: " + columnName);
            }
            
            return getColumnData(colIndex);
        } catch (Exception e) {
            LOGGER.error("Error getting column data by name '{}': {}", columnName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets a column's cells as CSElements.
     * 
     * @param colIndex The column index (0-based)
     * @return The list of cell elements
     */
    public List<CSElement> getColumnCells(int colIndex) {
        try {
            LOGGER.debug("Getting column cells at index {} from table: {}", colIndex, getSelector());
            
            if (colIndex < 0 || colIndex >= getColumnCount()) {
                throw new IndexOutOfBoundsException("Column index out of bounds: " + colIndex);
            }
            
            int rowCount = getRowCount();
            List<CSElement> columnCells = new ArrayList<>();
            
            for (int i = 0; i < rowCount; i++) {
                Locator row = bodyRowsLocator.nth(i);
                Locator cells = row.locator("td, th");
                
                if (colIndex < cells.count()) {
                    Locator cell = cells.nth(colIndex);
                    columnCells.add(new CSElement(cell, getSelector() + " > tbody > tr:nth-child(" + (i + 1) + ") > td:nth-child(" + (colIndex + 1) + ")"));
                }
            }
            
            return columnCells;
        } catch (Exception e) {
            LOGGER.error("Error getting column cells at index {}: {}", colIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets a row as a list of cell texts.
     * 
     * @param rowIndex The row index (0-based)
     * @return The list of cell texts
     */
    public List<String> getRowTexts(int rowIndex) {
        try {
            LOGGER.debug("Getting row texts at index {} from table: {}", rowIndex, getSelector());
            
            if (rowIndex < 0 || rowIndex >= getRowCount()) {
                throw new IndexOutOfBoundsException("Row index out of bounds: " + rowIndex);
            }
            
            Locator row = bodyRowsLocator.nth(rowIndex);
            Locator cells = row.locator("td, th");
            int cellCount = cells.count();
            List<String> rowTexts = new ArrayList<>();
            
            for (int i = 0; i < cellCount; i++) {
                rowTexts.add(cells.nth(i).textContent().trim());
            }
            
            return rowTexts;
        } catch (Exception e) {
            LOGGER.error("Error getting row texts at index {}: {}", rowIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets a row as a list of cell elements.
     * 
     * @param rowIndex The row index (0-based)
     * @return The list of cell elements
     */
    public List<CSElement> getRowCells(int rowIndex) {
        try {
            LOGGER.debug("Getting row cells at index {} from table: {}", rowIndex, getSelector());
            
            if (rowIndex < 0 || rowIndex >= getRowCount()) {
                throw new IndexOutOfBoundsException("Row index out of bounds: " + rowIndex);
            }
            
            Locator row = bodyRowsLocator.nth(rowIndex);
            Locator cells = row.locator("td, th");
            int cellCount = cells.count();
            List<CSElement> rowCells = new ArrayList<>();
            
            for (int i = 0; i < cellCount; i++) {
                Locator cell = cells.nth(i);
                rowCells.add(new CSElement(cell, getSelector() + " > tbody > tr:nth-child(" + (rowIndex + 1) + ") > td:nth-child(" + (i + 1) + ")"));
            }
            
            return rowCells;
        } catch (Exception e) {
            LOGGER.error("Error getting row cells at index {}: {}", rowIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Finds the row index that contains the specified text.
     * 
     * @param text The text to search for
     * @return The row index, or -1 if not found
     */
    public int findRowWithText(String text) {
        try {
            LOGGER.debug("Finding row with text '{}' in table: {}", text, getSelector());
            
            int rowCount = getRowCount();
            
            for (int i = 0; i < rowCount; i++) {
                Locator row = bodyRowsLocator.nth(i);
                String rowText = row.textContent();
                
                if (rowText.contains(text)) {
                    return i;
                }
            }
            
            return -1;
        } catch (Exception e) {
            LOGGER.error("Error finding row with text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Finds row indices that match a given criterion.
     * 
     * @param columnName The column name
     * @param matcher The predicate to match cell texts against
     * @return The list of matching row indices
     */
    public List<Integer> findRows(String columnName, Predicate<String> matcher) {
        try {
            LOGGER.debug("Finding rows by column '{}' with matcher in table: {}", columnName, getSelector());
            
            List<String> headers = getHeaderTexts();
            int colIndex = headers.indexOf(columnName);
            
            if (colIndex == -1) {
                throw new IllegalArgumentException("Column not found: " + columnName);
            }
            
            List<Integer> matchingRows = new ArrayList<>();
            int rowCount = getRowCount();
            
            for (int i = 0; i < rowCount; i++) {
                String cellText = getCellText(i, colIndex);
                
                if (matcher.test(cellText)) {
                    matchingRows.add(i);
                }
            }
            
            return matchingRows;
        } catch (Exception e) {
            LOGGER.error("Error finding rows by column '{}' with matcher: {}", columnName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Finds row indices where the column value equals the given value.
     * 
     * @param columnName The column name
     * @param value The value to match
     * @return The list of matching row indices
     */
    public List<Integer> findRowsWhereEqual(String columnName, String value) {
        return findRows(columnName, cellText -> cellText.equals(value));
    }
    
    /**
     * Finds row indices where the column value contains the given value.
     * 
     * @param columnName The column name
     * @param value The value to search for
     * @return The list of matching row indices
     */
    public List<Integer> findRowsWhereContains(String columnName, String value) {
        return findRows(columnName, cellText -> cellText.contains(value));
    }
    
    /**
     * Clicks a cell at the specified row and column.
     * 
     * @param rowIndex The row index (0-based)
     * @param colIndex The column index (0-based)
     * @return This CSTable for chaining
     */
    public CSTable clickCell(int rowIndex, int colIndex) {
        try {
            LOGGER.info("Clicking cell at row {}, column {} in table: {}", rowIndex, colIndex, getSelector());
            getCell(rowIndex, colIndex).click();
            return this;
        } catch (Exception e) {
            LOGGER.error("Error clicking cell at row {}, column {}: {}", rowIndex, colIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Clicks a cell by column name and row index.
     * 
     * @param columnName The column name
     * @param rowIndex The row index (0-based)
     * @return This CSTable for chaining
     */
    public CSTable clickCellByColumnName(String columnName, int rowIndex) {
        try {
            LOGGER.info("Clicking cell by column name '{}', row {} in table: {}", columnName, rowIndex, getSelector());
            getCellByColumnName(columnName, rowIndex).click();
            return this;
        } catch (Exception e) {
            LOGGER.error("Error clicking cell by column name '{}', row {}: {}", columnName, rowIndex, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Sorts the table (in the browser) by clicking the specified column header.
     * This works only for tables that have client-side sorting implemented.
     * 
     * @param columnName The column name
     * @return This CSTable for chaining
     */
    public CSTable sortByColumn(String columnName) {
        try {
            LOGGER.info("Sorting table by column '{}': {}", columnName, getSelector());
            
            List<String> headers = getHeaderTexts();
            int colIndex = headers.indexOf(columnName);
            
            if (colIndex == -1) {
                throw new IllegalArgumentException("Column not found: " + columnName);
            }
            
            if (headerRowLocator.count() > 0) {
                Locator headerCells = headerRowLocator.first().locator("th, td");
                
                if (colIndex < headerCells.count()) {
                    headerCells.nth(colIndex).click();
                }
            }
            
            return this;
        } catch (Exception e) {
            LOGGER.error("Error sorting table by column '{}': {}", columnName, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the table data as a two-dimensional array of strings.
     * 
     * @return The table data
     */
    public String[][] getTableData() {
        try {
            LOGGER.debug("Getting table data as 2D array: {}", getSelector());
            
            int rowCount = getRowCount();
            int colCount = getColumnCount();
            String[][] data = new String[rowCount][colCount];
            
            for (int i = 0; i < rowCount; i++) {
                Locator row = bodyRowsLocator.nth(i);
                Locator cells = row.locator("td, th");
                
                for (int j = 0; j < Math.min(colCount, cells.count()); j++) {
                    data[i][j] = cells.nth(j).textContent().trim();
                }
            }
            
            return data;
        } catch (Exception e) {
            LOGGER.error("Error getting table data as 2D array: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the table headers as CSElements.
     * 
     * @return The list of header elements
     */
    public List<CSElement> getHeaderCells() {
        try {
            LOGGER.debug("Getting header cells from table: {}", getSelector());
            
            if (headerRowLocator.count() == 0) {
                return Collections.emptyList();
            }
            
            Locator headerCells = headerRowLocator.first().locator("th, td");
            int count = headerCells.count();
            List<CSElement> cells = new ArrayList<>();
            
            for (int i = 0; i < count; i++) {
                Locator cell = headerCells.nth(i);
                cells.add(new CSElement(cell, getSelector() + " > thead > tr:nth-child(1) > th:nth-child(" + (i + 1) + ")"));
            }
            
            return cells;
        } catch (Exception e) {
            LOGGER.error("Error getting header cells: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the footer texts from the table.
     * 
     * @return The list of footer texts
     */
    public List<String> getFooterTexts() {
        try {
            LOGGER.debug("Getting footer texts from table: {}", getSelector());
            
            if (footerRowLocator.count() == 0) {
                return Collections.emptyList();
            }
            
            Locator footerCells = footerRowLocator.first().locator("td, th");
            int count = footerCells.count();
            List<String> texts = new ArrayList<>();
            
            for (int i = 0; i < count; i++) {
                Locator cell = footerCells.nth(i);
                texts.add(cell.textContent().trim());
            }
            
            return texts;
        } catch (Exception e) {
            LOGGER.error("Error getting footer texts: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the table as a list of maps from column name to cell value.
     * 
     * @return The table as a list of maps
     */
    public List<Map<String, String>> toMapList() {
        try {
            LOGGER.debug("Converting table to map list: {}", getSelector());
            return getRowsData();
        } catch (Exception e) {
            LOGGER.error("Error converting table to map list: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if the table is empty (no body rows).
     * 
     * @return True if the table is empty, false otherwise
     */
    public boolean isEmpty() {
        try {
            LOGGER.debug("Checking if table is empty: {}", getSelector());
            return getRowCount() == 0;
        } catch (Exception e) {
            LOGGER.error("Error checking if table is empty: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Checks if the table contains a cell with the specified text.
     * 
     * @param text The text to search for
     * @return True if the table contains the text, false otherwise
     */
    public boolean containsText(String text) {
        try {
            LOGGER.debug("Checking if table contains text '{}': {}", text, getSelector());
            
            // First check in the headers
            for (String headerText : getHeaderTexts()) {
                if (headerText.contains(text)) {
                    return true;
                }
            }
            
            // Then check in the body
            int rowCount = getRowCount();
            int colCount = getColumnCount();
            
            for (int i = 0; i < rowCount; i++) {
                for (int j = 0; j < colCount; j++) {
                    if (getCellText(i, j).contains(text)) {
                        return true;
                    }
                }
            }
            
            return false;
        } catch (Exception e) {
            LOGGER.error("Error checking if table contains text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets all cells in the table as CSElements.
     * 
     * @return The list of all cell elements
     */
    public List<CSElement> getAllCells() {
        try {
            LOGGER.debug("Getting all cells from table: {}", getSelector());
            
            List<CSElement> cells = new ArrayList<>();
            int rowCount = getRowCount();
            
            for (int i = 0; i < rowCount; i++) {
                cells.addAll(getRowCells(i));
            }
            
            return cells;
        } catch (Exception e) {
            LOGGER.error("Error getting all cells: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the pagination controls for the table, if available.
     * This works for tables with standard pagination controls.
     * 
     * @return The CSElement representing the pagination controls, or null if not found
     */
    public CSElement getPagination() {
        try {
            LOGGER.debug("Getting pagination controls for table: {}", getSelector());
            
            // Try common selectors for pagination
            Locator pagination = getLocator().locator("xpath=following-sibling::div[contains(@class, 'pagination')]");
            
            if (pagination.count() > 0) {
                return new CSElement(pagination, getSelector() + " + div.pagination");
            }
            
            // Try another common pattern
            pagination = getLocator().locator("xpath=../following-sibling::div[contains(@class, 'pagination')]");
            
            if (pagination.count() > 0) {
                return new CSElement(pagination, getSelector() + " ~ div.pagination");
            }
            
            // Try navigation with ul li pattern
            pagination = getLocator().locator("xpath=following-sibling::nav//ul[contains(@class, 'pagination')]");
            
            if (pagination.count() > 0) {
                return new CSElement(pagination, getSelector() + " + nav ul.pagination");
            }
            
            return null;
        } catch (Exception e) {
            LOGGER.warn("Error getting pagination controls: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Clicks the "Next" button in the pagination controls, if available.
     * 
     * @return True if the next button was clicked, false otherwise
     */
    public boolean clickNextPage() {
        try {
            LOGGER.info("Clicking next page for table: {}", getSelector());
            
            CSElement pagination = getPagination();
            if (pagination == null) {
                return false;
            }
            
            // Try to find the "Next" button
            Locator nextButton = pagination.getLocator().locator("a:has-text('Next'), li:has-text('Next'), button:has-text('Next')");
            
            if (nextButton.count() > 0 && !nextButton.first().isDisabled()) {
                nextButton.first().click();
                return true;
            }
            
            // Try with '>'
            nextButton = pagination.getLocator().locator("a:has-text('>'), li:has-text('>'), button:has-text('>')");
            
            if (nextButton.count() > 0 && !nextButton.first().isDisabled()) {
                nextButton.first().click();
                return true;
            }
            
            return false;
        } catch (Exception e) {
            LOGGER.error("Error clicking next page: {}", e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Clicks the "Previous" button in the pagination controls, if available.
     * 
     * @return True if the previous button was clicked, false otherwise
     */
    public boolean clickPreviousPage() {
        try {
            LOGGER.info("Clicking previous page for table: {}", getSelector());
            
            CSElement pagination = getPagination();
            if (pagination == null) {
                return false;
            }
            
            // Try to find the "Previous" button
            Locator prevButton = pagination.getLocator().locator("a:has-text('Previous'), a:has-text('Prev'), li:has-text('Previous'), li:has-text('Prev'), button:has-text('Previous'), button:has-text('Prev')");
            
            if (prevButton.count() > 0 && !prevButton.first().isDisabled()) {
                prevButton.first().click();
                return true;
            }
            
            // Try with '<'
            prevButton = pagination.getLocator().locator("a:has-text('<'), li:has-text('<'), button:has-text('<')");
            
            if (prevButton.count() > 0 && !prevButton.first().isDisabled()) {
                prevButton.first().click();
                return true;
            }
            
            return false;
        } catch (Exception e) {
            LOGGER.error("Error clicking previous page: {}", e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Gets the current page number from the pagination controls, if available.
     * 
     * @return The current page number, or -1 if not found
     */
    public int getCurrentPageNumber() {
        try {
            LOGGER.debug("Getting current page number for table: {}", getSelector());
            
            CSElement pagination = getPagination();
            if (pagination == null) {
                return -1;
            }
            
            // Try to find the active page
            Locator activePage = pagination.getLocator().locator("li.active, a.active, button.active, .active");
            
            if (activePage.count() > 0) {
                String text = activePage.first().textContent().trim();
                try {
                    return Integer.parseInt(text);
                } catch (NumberFormatException e) {
                    // The active element might contain more than just the number
                    // Try to extract the number using regex
                    java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("\\d+");
                    java.util.regex.Matcher matcher = pattern.matcher(text);
                    if (matcher.find()) {
                        return Integer.parseInt(matcher.group());
                    }
                }
            }
            
            return -1;
        } catch (Exception e) {
            LOGGER.error("Error getting current page number: {}", e.getMessage(), e);
            return -1;
        }
    }
    
    /**
     * Wait for the table to have a specific number of rows.
     * 
     * @param expectedRowCount The expected number of rows
     * @param timeoutMillis The timeout in milliseconds
     * @return This CSTable for chaining
     */
    public CSTable waitForRowCount(int expectedRowCount, long timeoutMillis) {
        try {
            LOGGER.info("Waiting for table to have {} rows: {}", expectedRowCount, getSelector());
            
            long startTime = System.currentTimeMillis();
            long endTime = startTime + timeoutMillis;
            
            while (System.currentTimeMillis() < endTime) {
                if (getRowCount() == expectedRowCount) {
                    return this;
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for row count", e);
                }
            }
            
            throw new RuntimeException("Timeout waiting for table to have " + expectedRowCount + " rows");
        } catch (Exception e) {
            LOGGER.error("Error waiting for row count {}: {}", expectedRowCount, e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Wait for the table to contain a specific text.
     * 
     * @param text The text to wait for
     * @param timeoutMillis The timeout in milliseconds
     * @return This CSTable for chaining
     */
    public CSTable waitForText(String text, long timeoutMillis) {
        try {
            LOGGER.info("Waiting for table to contain text '{}': {}", text, getSelector());
            
            long startTime = System.currentTimeMillis();
            long endTime = startTime + timeoutMillis;
            
            while (System.currentTimeMillis() < endTime) {
                if (containsText(text)) {
                    return this;
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for text", e);
                }
            }
            
            throw new RuntimeException("Timeout waiting for table to contain text: " + text);
        } catch (Exception e) {
            LOGGER.error("Error waiting for text '{}': {}", text, e.getMessage(), e);
            throw e;
        }
    }
}


CSBaseStepDef.java
--------------------------


package com.cstestforge.framework.playwright.java.base;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.reporting.CSReporter;
import com.cstestforge.framework.core.utils.CSConstants;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSScreenshotManager;
import com.cstestforge.framework.playwright.java.browser.CSPlaywrightManager;
import com.cstestforge.framework.playwright.java.browser.CSBrowserContextManager;
import com.cstestforge.framework.playwright.java.browser.CSPageManager;
import com.microsoft.playwright.Browser;
import com.microsoft.playwright.BrowserContext;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Playwright;
import com.microsoft.playwright.options.LoadState;
import io.cucumber.java.After;
import io.cucumber.java.Before;
import io.cucumber.java.Scenario;
import io.cucumber.java.en.Given;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;

/**
 * Base step definition class for Playwright BDD tests.
 * Provides common functionality for step definitions.
 */
public class CSBaseStepDef {
    private static final CSLogger LOGGER = new CSLogger(CSBaseStepDef.class);
    
    protected Playwright playwright;
    protected Browser browser;
    protected BrowserContext context;
    protected Page page;
    protected Scenario scenario;
    
    protected CSPlaywrightManager playwrightManager;
    protected CSBrowserContextManager contextManager;
    protected CSPageManager pageManager;
    protected CSReporter reporter;
    
    protected ConfigurationManager configManager;
    protected CSScreenshotManager screenshotManager;
    
    protected String baseUrl;
    protected String sessionId;
    protected String screenshotDir;
    protected boolean headless;
    protected String browserType;
    
    /**
     * Constructs a new CSBaseStepDef.
     */
    public CSBaseStepDef() {
        configManager = ConfigurationManager.getInstance();
        
        // Load configuration
        baseUrl = configManager.getString(CSConstants.CONFIG_BASE_URL, "http://localhost");
        headless = configManager.getBoolean(CSConstants.CONFIG_HEADLESS, true);
        browserType = configManager.getString(CSConstants.CONFIG_BROWSER, CSConstants.BROWSER_CHROMIUM);
        screenshotDir = configManager.getString(CSConstants.CONFIG_SCREENSHOT_DIR, "reports/screenshots");
        
        // Initialize managers
        playwrightManager = CSPlaywrightManager.getInstance();
        contextManager = new CSBrowserContextManager();
        pageManager = new CSPageManager();
        screenshotManager = new CSScreenshotManager(screenshotDir);
        
        // Generate a session ID
        sessionId = generateSessionId();
        
        LOGGER.info("CSBaseStepDef initialized with sessionId: {}", sessionId);
    }
    
    /**
     * Setup method that runs before each scenario.
     * 
     * @param scenario The Cucumber scenario
     */
    @Before
    public void beforeScenario(Scenario scenario) {
        this.scenario = scenario;
        LOGGER.info("Starting scenario: {}", scenario.getName());
        
        // Set up scenario data for logging
        CSLogger.setTestName(scenario.getName());
        CSLogger.setBrowser(browserType);
        CSLogger.setEnvironment(configManager.getCurrentEnvironment());
        CSLogger.setCorrelationId(sessionId);
        
        // Initialize browser
        initializeBrowser();
        
        // Create a new context and page for the scenario
        initializeContext();
        initializePage();
        
        // Start scenario in reporter
        if (reporter != null) {
            reporter.startTest(scenario.getId(), scenario.getName());
            
            // Log scenario details
            reporter.logInfo("Scenario: " + scenario.getName());
            reporter.logInfo("Tags: " + String.join(", ", scenario.getSourceTagNames()));
        }
        
        LOGGER.info("Scenario setup completed: {}", scenario.getName());
    }
    
    /**
     * Cleanup method that runs after each scenario.
     * 
     * @param scenario The Cucumber scenario
     */
    @After
    public void afterScenario(Scenario scenario) {
        LOGGER.info("Finishing scenario: {}", scenario.getName());
        
        // Capture screenshot if scenario failed
        if (scenario.isFailed()) {
            captureScreenshot("failure");
            scenario.log("Screenshot captured: " + screenshotDir + File.separator + scenario.getName() + "_failure.png");
        }
        
        // Close the page
        if (pageManager != null && page != null) {
            pageManager.closePage(sessionId + "_" + scenario.getName());
            page = null;
        }
        
        // Close the context
        if (contextManager != null && context != null) {
            contextManager.closeContext(sessionId);
            context = null;
        }
        
        // End scenario in reporter
        if (reporter != null) {
            if (scenario.isFailed()) {
                Throwable error = getScenarioError(scenario);
                String errorMessage = error != null ? error.getMessage() : "Unknown error";
                reporter.logFail("Scenario failed: " + errorMessage);
            } else {
                reporter.logPass("Scenario passed");
            }
            
            reporter.endTest();
        }
        
        // Clear context data from logging
        CSLogger.clearContext();
        
        LOGGER.info("Scenario cleanup completed: {}", scenario.getName());
    }
    
    /**
     * Initializes the browser for testing.
     */
    protected void initializeBrowser() {
        LOGGER.info("Initializing browser: {}, headless: {}", browserType, headless);
        
        try {
            // Get Playwright instance
            playwright = playwrightManager.getPlaywright(sessionId);
            
            // Launch browser
            browser = playwrightManager.launchBrowser(browserType, headless, sessionId);
            
            LOGGER.info("Browser initialized successfully");
        } catch (Exception e) {
            LOGGER.error("Error initializing browser: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to initialize browser", e);
        }
    }
    
    /**
     * Initializes the browser context for testing.
     */
    protected void initializeContext() {
        LOGGER.info("Initializing browser context");
        
        try {
            if (context != null) {
                contextManager.closeContext(sessionId);
                context = null;
            }
            
            context = contextManager.createContext(browser, sessionId);
            
            // Configure the context
            setupContextDefaults(context);
            
            LOGGER.info("Browser context initialized successfully");
        } catch (Exception e) {
            LOGGER.error("Error initializing browser context: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to initialize browser context", e);
        }
    }
    
    /**
     * Initializes the page for testing.
     */
    protected void initializePage() {
        LOGGER.info("Initializing page");
        
        try {
            page = pageManager.createPage(context, sessionId, sessionId + "_" + scenario.getName());
            
            // Setup page event handlers
            setupPageEventHandlers();
            
            LOGGER.info("Page initialized successfully");
        } catch (Exception e) {
            LOGGER.error("Error initializing page: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to initialize page", e);
        }
    }
    
    /**
     * Sets up default settings for the browser context.
     * 
     * @param context The browser context to configure
     */
    protected void setupContextDefaults(BrowserContext context) {
        // Override in subclasses to customize
    }
    
    /**
     * Sets up page event handlers.
     */
    protected void setupPageEventHandlers() {
        if (page != null) {
            // Handle page errors
            page.onPageError(error -> {
                LOGGER.error("Page error: {}", error);
                if (reporter != null) {
                    reporter.logError("Page JavaScript error: " + error);
                }
                
                scenario.log("Page error: " + error);
            });
            
            // Handle console messages
            page.onConsoleMessage(message -> {
                String msgType = message.type().toString().toLowerCase();
                String text = message.text();
                
                if ("error".equals(msgType)) {
                    LOGGER.error("Console error: {}", text);
                    if (reporter != null) {
                        reporter.logError("Console error: " + text);
                    }
                    
                    scenario.log("Console error: " + text);
                } else if ("warning".equals(msgType)) {
                    LOGGER.warn("Console warning: {}", text);
                    if (reporter != null) {
                        reporter.logWarning("Console warning: " + text);
                    }
                } else {
                    LOGGER.debug("Console {}: {}", msgType, text);
                }
            });
            
            // Handle dialogs (alerts, confirms, prompts)
            page.onDialog(dialog -> {
                String message = dialog.message();
                String type = dialog.type().toString().toLowerCase();
                
                LOGGER.info("Dialog {}: {}", type, message);
                if (reporter != null) {
                    reporter.logInfo("Dialog " + type + ": " + message);
                }
                
                scenario.log("Dialog " + type + ": " + message);
                
                // Auto-dismiss dialogs unless overridden in subclasses
                handleDialog(dialog);
            });
        }
    }
    
    /**
     * Handles browser dialogs.
     * Override this method to customize dialog handling.
     * 
     * @param dialog The dialog to handle
     */
    protected void handleDialog(Page.Dialog dialog) {
        // Default behavior is to dismiss dialogs
        dialog.dismiss();
    }
    
    /**
     * Navigates to the specified URL.
     * 
     * @param url The URL to navigate to
     */
    protected void navigateTo(String url) {
        LOGGER.info("Navigating to URL: {}", url);
        
        try {
            pageManager.navigateTo(page, url);
            
            if (reporter != null) {
                reporter.logInfo("Navigated to: " + url);
            }
            
            scenario.log("Navigated to: " + url);
        } catch (Exception e) {
            LOGGER.error("Error navigating to URL {}: {}", url, e.getMessage(), e);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("navigation_error");
                reporter.logFail("Navigation failed: " + e.getMessage(), screenshotPath);
            }
            
            throw e;
        }
    }
    
    /**
     * Navigates to the base URL.
     */
    protected void navigateToBaseUrl() {
        navigateTo(baseUrl);
    }
    
    /**
     * Step definition for navigating to a URL.
     * 
     * @param url The URL to navigate to
     */
    @Given("I navigate to {string}")
    public void iNavigateTo(String url) {
        // Handle relative URLs
        if (!url.startsWith("http")) {
            url = baseUrl + (url.startsWith("/") ? url : "/" + url);
        }
        
        navigateTo(url);
    }
    
    /**
     * Step definition for navigating to the base URL.
     */
    @Given("I navigate to the base URL")
    public void iNavigateToTheBaseUrl() {
        navigateToBaseUrl();
    }
    
    /**
     * Captures a screenshot.
     * 
     * @param type The screenshot type (e.g., "failure", "step", etc.)
     * @return The path to the screenshot file
     */
    protected String captureScreenshot(String type) {
        if (page == null) {
            LOGGER.warn("Cannot capture screenshot: page is null");
            return null;
        }
        
        try {
            String fileName = scenario.getName().replaceAll("[^a-zA-Z0-9.-]", "_") + "_" + type + ".png";
            String filePath = screenshotDir + File.separator + fileName;
            
            LOGGER.debug("Capturing screenshot: {}", filePath);
            
            // Create the screenshot directory if it doesn't exist
            File directory = new File(screenshotDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }
            
            // Capture the screenshot
            page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get(filePath)).setFullPage(true));
            
            // Attach the screenshot to the scenario
            if (scenario != null) {
                try {
                    byte[] screenshotBytes = java.nio.file.Files.readAllBytes(Paths.get(filePath));
                    scenario.attach(screenshotBytes, "image/png", fileName);
                } catch (Exception e) {
                    LOGGER.warn("Failed to attach screenshot to scenario: {}", e.getMessage());
                }
            }
            
            // Add to reporter
            if (reporter != null) {
                reporter.logScreenshot(filePath);
            }
            
            LOGGER.info("Screenshot captured: {}", filePath);
            return filePath;
        } catch (Exception e) {
            LOGGER.error("Error capturing screenshot: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Generates a unique session ID.
     * 
     * @return The generated session ID
     */
    protected String generateSessionId() {
        return "cucumber_" + UUID.randomUUID().toString().substring(0, 8);
    }
    
    /**
     * Gets the error from a failed scenario.
     * 
     * @param scenario The Cucumber scenario
     * @return The error, or null if not found
     */
    private Throwable getScenarioError(Scenario scenario) {
        try {
            // This is a bit of a hack, as Cucumber doesn't provide direct access to the error
            // Try to use reflection to get the error from the scenario
            java.lang.reflect.Field field = scenario.getClass().getDeclaredField("delegate");
            field.setAccessible(true);
            Object delegate = field.get(scenario);
            
            field = delegate.getClass().getDeclaredField("error");
            field.setAccessible(true);
            return (Throwable) field.get(delegate);
        } catch (Exception e) {
            LOGGER.warn("Could not get scenario error: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Waits for the page to load completely.
     */
    protected void waitForPageToLoad() {
        LOGGER.debug("Waiting for page to load");
        
        try {
            // Wait for the specified load state
            page.waitForLoadState(getLoadState());
            
            LOGGER.debug("Page loaded");
        } catch (Exception e) {
            LOGGER.error("Error waiting for page to load: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Gets the load state to wait for.
     * Override this method to customize the load state.
     * 
     * @return The load state
     */
    protected LoadState getLoadState() {
        String loadState = configManager.getString("playwright.page.loadState", "load");
        switch (loadState.toLowerCase()) {
            case "domcontentloaded":
                return LoadState.DOMCONTENTLOADED;
            case "networkidle":
                return LoadState.NETWORKIDLE;
            case "load":
            default:
                return LoadState.LOAD;
        }
    }
    
    /**
     * Gets the page title.
     * 
     * @return The page title
     */
    protected String getPageTitle() {
        return page.title();
    }
    
    /**
     * Gets the current URL.
     * 
     * @return The current URL
     */
    protected String getCurrentUrl() {
        return page.url();
    }
    
    /**
     * Refreshes the page.
     */
    protected void refreshPage() {
        LOGGER.info("Refreshing page");
        
        try {
            page.reload();
            waitForPageToLoad();
            
            if (reporter != null) {
                reporter.logInfo("Page refreshed");
            }
            
            scenario.log("Page refreshed");
        } catch (Exception e) {
            LOGGER.error("Error refreshing page: {}", e.getMessage(), e);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("refresh_error");
                reporter.logFail("Page refresh failed: " + e.getMessage(), screenshotPath);
            }
            
            throw e;
        }
    }
    
    /**
     * Goes back in browser history.
     */
    protected void goBack() {
        LOGGER.info("Navigating back");
        
        try {
            page.goBack();
            waitForPageToLoad();
            
            if (reporter != null) {
                reporter.logInfo("Navigated back");
            }
            
            scenario.log("Navigated back");
        } catch (Exception e) {
            LOGGER.error("Error navigating back: {}", e.getMessage(), e);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("navigation_back_error");
                reporter.logFail("Navigation back failed: " + e.getMessage(), screenshotPath);
            }
            
            throw e;
        }
    }
    
    /**
     * Goes forward in browser history.
     */
    protected void goForward() {
        LOGGER.info("Navigating forward");
        
        try {
            page.goForward();
            waitForPageToLoad();
            
            if (reporter != null) {
                reporter.logInfo("Navigated forward");
            }
            
            scenario.log("Navigated forward");
        } catch (Exception e) {
            LOGGER.error("Error navigating forward: {}", e.getMessage(), e);
            
            if (reporter != null) {
                String screenshotPath = captureScreenshot("navigation_forward_error");
                reporter.logFail("Navigation forward failed: " + e.getMessage(), screenshotPath);
            }
            
            throw e;
        }
    }
    
    /**
     * Creates a page object of the specified class.
     * 
     * @param pageObjectClass The page object class
     * @param <T> The page object type
     * @return The initialized page object
     */
    protected <T extends CSBasePage> T createPage(Class<T> pageObjectClass) {
        LOGGER.debug("Creating page object of type {}", pageObjectClass.getSimpleName());
        
        try {
            // Create a new instance of the page object
            T pageObject = pageObjectClass.getDeclaredConstructor(Page.class).newInstance(page);
            
            // Initialize elements
            CSPageFactory.initElements(pageObject, page);
            
            // Set reporter
            if (reporter != null) {
                pageObject.setReporter(reporter);
            }
            
            return pageObject;
        } catch (Exception e) {
            LOGGER.error("Could not create page object of type {}: {}", pageObjectClass.getSimpleName(), e.getMessage(), e);
            throw new RuntimeException("Failed to create page object of type " + pageObjectClass.getSimpleName(), e);
        }
    }
}




CSTestStepDef.java
----------------------------

package com.cstestforge.framework.playwright.java.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.Documented;

/**
 * Annotation to mark test step definitions in the CSTestForge framework.
 * This annotation can be used to add metadata and behavior to step definitions.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
@Documented
public @interface CSTestStepDef {
    /**
     * The feature that this step definition is associated with.
     * 
     * @return The feature name
     */
    String feature() default "";
    
    /**
     * The group that this step definition belongs to.
     * 
     * @return The group name
     */
    String group() default "";
    
    /**
     * The description of this step definition.
     * 
     * @return The description
     */
    String description() default "";
    
    /**
     * The order in which this step definition should be executed.
     * Lower numbers execute first.
     * 
     * @return The order
     */
    int order() default 0;
    
    /**
     * Whether this step definition should always capture a screenshot after execution.
     * 
     * @return True if screenshots should be captured, false otherwise
     */
    boolean screenshot() default false;
    
    /**
     * Whether this step definition should be skipped in certain environments.
     * 
     * @return The environments in which this step should be skipped
     */
    String[] skipInEnvironments() default {};
    
    /**
     * Whether this step definition should only be executed in certain environments.
     * 
     * @return The environments in which this step should be executed
     */
    String[] onlyInEnvironments() default {};
    
    /**
     * The timeout for this step definition in milliseconds.
     * 
     * @return The timeout
     */
    long timeout() default 0;
    
    /**
     * Whether this step definition should be retried on failure.
     * 
     * @return True if the step should be retried, false otherwise
     */
    boolean retry() default false;
    
    /**
     * The number of times to retry this step definition on failure.
     * 
     * @return The number of retries
     */
    int retryCount() default 1;
    
    /**
     * The delay between retries in milliseconds.
     * 
     * @return The retry delay
     */
    long retryDelay() default 1000;
    
    /**
     * The exception types that should trigger a retry.
     * 
     * @return The exception types
     */
    Class<? extends Throwable>[] retryFor() default {};
    
    /**
     * Whether this step definition should be logged.
     * 
     * @return True if the step should be logged, false otherwise
     */
    boolean log() default true;
    
    /**
     * The level at which this step definition should be logged.
     * 
     * @return The log level (INFO, DEBUG, WARN, ERROR, etc.)
     */
    String logLevel() default "INFO";
    
    /**
     * Whether this step definition should be ignored.
     * 
     * @return True if the step should be ignored, false otherwise
     */
    boolean ignore() default false;
    
    /**
     * The reason for ignoring this step definition.
     * 
     * @return The reason
     */
    String ignoreReason() default "";
    
    /**
     * The expected result of this step definition.
     * 
     * @return The expected result
     */
    String expectedResult() default "";
    
    /**
     * Whether this step definition is critical.
     * 
     * @return True if the step is critical, false otherwise
     */
    boolean critical() default false;
    
    /**
     * The prerequisite step definitions for this step definition.
     * 
     * @return The prerequisite step definitions
     */
    String[] prerequisites() default {};
    
    /**
     * The tags associated with this step definition.
     * 
     * @return The tags
     */
    String[] tags() default {};
    
    /**
     * The author of this step definition.
     * 
     * @return The author
     */
    String author() default "";
    
    /**
     * The date this step definition was created.
     * 
     * @return The creation date
     */
    String creationDate() default "";
    
    /**
     * The date this step definition was last modified.
     * 
     * @return The last modified date
     */
    String lastModified() default "";
    
    /**
     * The version of this step definition.
     * 
     * @return The version
     */
    String version() default "1.0";
    
    /**
     * The browsers supported by this step definition.
     * 
     * @return The supported browsers
     */
    String[] supportedBrowsers() default {};
    
    /**
     * Whether this step definition should use self-healing.
     * 
     * @return True if self-healing should be used, false otherwise
     */
    boolean selfHealing() default true;
    
    /**
     * Whether this step definition should be logged in reports.
     * 
     * @return True if the step should be logged in reports, false otherwise
     */
    boolean reportable() default true;
    
    /**
     * The priority of this step definition.
     * 
     * @return The priority (HIGH, MEDIUM, LOW, etc.)
     */
    String priority() default "MEDIUM";
    
    /**
     * The estimated execution time of this step definition in milliseconds.
     * 
     * @return The estimated execution time
     */
    long estimatedTime() default 0;
    
    /**
     * Whether this step definition should be executed in parallel.
     * 
     * @return True if the step should be executed in parallel, false otherwise
     */
    boolean parallel() default false;
    
    /**
     * The data provider for this step definition.
     * 
     * @return The data provider name
     */
    String dataProvider() default "";
    
    /**
     * Whether this step definition should wait for a specific condition after execution.
     * 
     * @return The condition to wait for
     */
    String waitFor() default "";
    
    /**
     * The timeout for waiting for the condition in milliseconds.
     * 
     * @return The wait timeout
     */
    long waitTimeout() default 30000;
    
    /**
     * The polling interval for waiting for the condition in milliseconds.
     * 
     * @return The polling interval
     */
    long waitPollingInterval() default 500;
    
    /**
     * The custom properties for this step definition.
     * 
     * @return The custom properties
     */
    String[] customProperties() default {};
}




