AssertionConfig.tsx
------------------------------------

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Button } from '../../common/Button';
import { Select } from '../../common/Select';
import { Input } from '../../common/Input';
import { Toggle } from '../../common/Toggle';
import { Modal } from '../../common/Modal';
import { Tabs } from '../../common/Tabs';
import { Card } from '../../common/Card';
import { Tooltip } from '../../common/Tooltip';
import { useFramework } from '../../../hooks/useFramework';
import { useRecorder } from '../../../hooks/useRecorder';
import { ElementFinderConfig } from './ElementFinderConfig';

// Assertion types supported by the framework
enum AssertionType {
  ELEMENT_PRESENT = 'ELEMENT_PRESENT',
  ELEMENT_NOT_PRESENT = 'ELEMENT_NOT_PRESENT',
  ELEMENT_VISIBLE = 'ELEMENT_VISIBLE',
  ELEMENT_NOT_VISIBLE = 'ELEMENT_NOT_VISIBLE',
  ELEMENT_ENABLED = 'ELEMENT_ENABLED',
  ELEMENT_DISABLED = 'ELEMENT_DISABLED',
  ELEMENT_CONTAINS_TEXT = 'ELEMENT_CONTAINS_TEXT',
  ELEMENT_TEXT_EQUALS = 'ELEMENT_TEXT_EQUALS',
  ELEMENT_TEXT_MATCHES = 'ELEMENT_TEXT_MATCHES',
  ELEMENT_ATTRIBUTE_EQUALS = 'ELEMENT_ATTRIBUTE_EQUALS',
  ELEMENT_ATTRIBUTE_CONTAINS = 'ELEMENT_ATTRIBUTE_CONTAINS',
  ELEMENT_ATTRIBUTE_MATCHES = 'ELEMENT_ATTRIBUTE_MATCHES',
  ELEMENT_CSS_PROPERTY_EQUALS = 'ELEMENT_CSS_PROPERTY_EQUALS',
  ELEMENT_CSS_PROPERTY_CONTAINS = 'ELEMENT_CSS_PROPERTY_CONTAINS',
  ELEMENT_CSS_CLASS_CONTAINS = 'ELEMENT_CSS_CLASS_CONTAINS',
  ELEMENT_COUNT_EQUALS = 'ELEMENT_COUNT_EQUALS',
  ELEMENT_COUNT_GREATER_THAN = 'ELEMENT_COUNT_GREATER_THAN',
  ELEMENT_COUNT_LESS_THAN = 'ELEMENT_COUNT_LESS_THAN',
  URL_CONTAINS = 'URL_CONTAINS',
  URL_EQUALS = 'URL_EQUALS',
  URL_MATCHES = 'URL_MATCHES',
  TITLE_CONTAINS = 'TITLE_CONTAINS',
  TITLE_EQUALS = 'TITLE_EQUALS',
  TITLE_MATCHES = 'TITLE_MATCHES',
  PAGE_CONTAINS_TEXT = 'PAGE_CONTAINS_TEXT',
  JAVASCRIPT_RETURNS_TRUE = 'JAVASCRIPT_RETURNS_TRUE',
  CUSTOM_FUNCTION = 'CUSTOM_FUNCTION',
}

// Assertion categories for better organization
enum AssertionCategory {
  ELEMENT_STATE = 'Element State',
  ELEMENT_CONTENT = 'Element Content',
  ELEMENT_ATTRIBUTE = 'Element Attribute',
  ELEMENT_STYLE = 'Element Style',
  ELEMENT_COUNT = 'Element Count',
  PAGE_STATE = 'Page State',
  CUSTOM = 'Custom',
}

// Mapping of assertion types to categories
const assertionTypeToCategory: Record<AssertionType, AssertionCategory> = {
  [AssertionType.ELEMENT_PRESENT]: AssertionCategory.ELEMENT_STATE,
  [AssertionType.ELEMENT_NOT_PRESENT]: AssertionCategory.ELEMENT_STATE,
  [AssertionType.ELEMENT_VISIBLE]: AssertionCategory.ELEMENT_STATE,
  [AssertionType.ELEMENT_NOT_VISIBLE]: AssertionCategory.ELEMENT_STATE,
  [AssertionType.ELEMENT_ENABLED]: AssertionCategory.ELEMENT_STATE,
  [AssertionType.ELEMENT_DISABLED]: AssertionCategory.ELEMENT_STATE,
  [AssertionType.ELEMENT_CONTAINS_TEXT]: AssertionCategory.ELEMENT_CONTENT,
  [AssertionType.ELEMENT_TEXT_EQUALS]: AssertionCategory.ELEMENT_CONTENT,
  [AssertionType.ELEMENT_TEXT_MATCHES]: AssertionCategory.ELEMENT_CONTENT,
  [AssertionType.ELEMENT_ATTRIBUTE_EQUALS]: AssertionCategory.ELEMENT_ATTRIBUTE,
  [AssertionType.ELEMENT_ATTRIBUTE_CONTAINS]: AssertionCategory.ELEMENT_ATTRIBUTE,
  [AssertionType.ELEMENT_ATTRIBUTE_MATCHES]: AssertionCategory.ELEMENT_ATTRIBUTE,
  [AssertionType.ELEMENT_CSS_PROPERTY_EQUALS]: AssertionCategory.ELEMENT_STYLE,
  [AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS]: AssertionCategory.ELEMENT_STYLE,
  [AssertionType.ELEMENT_CSS_CLASS_CONTAINS]: AssertionCategory.ELEMENT_STYLE,
  [AssertionType.ELEMENT_COUNT_EQUALS]: AssertionCategory.ELEMENT_COUNT,
  [AssertionType.ELEMENT_COUNT_GREATER_THAN]: AssertionCategory.ELEMENT_COUNT,
  [AssertionType.ELEMENT_COUNT_LESS_THAN]: AssertionCategory.ELEMENT_COUNT,
  [AssertionType.URL_CONTAINS]: AssertionCategory.PAGE_STATE,
  [AssertionType.URL_EQUALS]: AssertionCategory.PAGE_STATE,
  [AssertionType.URL_MATCHES]: AssertionCategory.PAGE_STATE,
  [AssertionType.TITLE_CONTAINS]: AssertionCategory.PAGE_STATE,
  [AssertionType.TITLE_EQUALS]: AssertionCategory.PAGE_STATE,
  [AssertionType.TITLE_MATCHES]: AssertionCategory.PAGE_STATE,
  [AssertionType.PAGE_CONTAINS_TEXT]: AssertionCategory.PAGE_STATE,
  [AssertionType.JAVASCRIPT_RETURNS_TRUE]: AssertionCategory.CUSTOM,
  [AssertionType.CUSTOM_FUNCTION]: AssertionCategory.CUSTOM,
};

// Human-readable labels for assertion types
const assertionTypeLabels: Record<AssertionType, string> = {
  [AssertionType.ELEMENT_PRESENT]: 'Element is present',
  [AssertionType.ELEMENT_NOT_PRESENT]: 'Element is not present',
  [AssertionType.ELEMENT_VISIBLE]: 'Element is visible',
  [AssertionType.ELEMENT_NOT_VISIBLE]: 'Element is not visible',
  [AssertionType.ELEMENT_ENABLED]: 'Element is enabled',
  [AssertionType.ELEMENT_DISABLED]: 'Element is disabled',
  [AssertionType.ELEMENT_CONTAINS_TEXT]: 'Element contains text',
  [AssertionType.ELEMENT_TEXT_EQUALS]: 'Element text equals',
  [AssertionType.ELEMENT_TEXT_MATCHES]: 'Element text matches regex',
  [AssertionType.ELEMENT_ATTRIBUTE_EQUALS]: 'Element attribute equals',
  [AssertionType.ELEMENT_ATTRIBUTE_CONTAINS]: 'Element attribute contains',
  [AssertionType.ELEMENT_ATTRIBUTE_MATCHES]: 'Element attribute matches regex',
  [AssertionType.ELEMENT_CSS_PROPERTY_EQUALS]: 'CSS property equals',
  [AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS]: 'CSS property contains',
  [AssertionType.ELEMENT_CSS_CLASS_CONTAINS]: 'CSS class contains',
  [AssertionType.ELEMENT_COUNT_EQUALS]: 'Element count equals',
  [AssertionType.ELEMENT_COUNT_GREATER_THAN]: 'Element count greater than',
  [AssertionType.ELEMENT_COUNT_LESS_THAN]: 'Element count less than',
  [AssertionType.URL_CONTAINS]: 'URL contains',
  [AssertionType.URL_EQUALS]: 'URL equals',
  [AssertionType.URL_MATCHES]: 'URL matches regex',
  [AssertionType.TITLE_CONTAINS]: 'Title contains',
  [AssertionType.TITLE_EQUALS]: 'Title equals',
  [AssertionType.TITLE_MATCHES]: 'Title matches regex',
  [AssertionType.PAGE_CONTAINS_TEXT]: 'Page contains text',
  [AssertionType.JAVASCRIPT_RETURNS_TRUE]: 'JavaScript returns true',
  [AssertionType.CUSTOM_FUNCTION]: 'Custom function',
};

// Descriptions for each assertion type
const assertionTypeDescriptions: Record<AssertionType, string> = {
  [AssertionType.ELEMENT_PRESENT]: 'Asserts that the element exists in the DOM',
  [AssertionType.ELEMENT_NOT_PRESENT]: 'Asserts that the element does not exist in the DOM',
  [AssertionType.ELEMENT_VISIBLE]: 'Asserts that the element is visible to the user',
  [AssertionType.ELEMENT_NOT_VISIBLE]: 'Asserts that the element is not visible to the user',
  [AssertionType.ELEMENT_ENABLED]: 'Asserts that the element is enabled (not disabled)',
  [AssertionType.ELEMENT_DISABLED]: 'Asserts that the element is disabled',
  [AssertionType.ELEMENT_CONTAINS_TEXT]: 'Asserts that the element contains the specified text',
  [AssertionType.ELEMENT_TEXT_EQUALS]: 'Asserts that the element text exactly matches the specified text',
  [AssertionType.ELEMENT_TEXT_MATCHES]: 'Asserts that the element text matches the specified regular expression',
  [AssertionType.ELEMENT_ATTRIBUTE_EQUALS]: 'Asserts that the specified attribute equals the provided value',
  [AssertionType.ELEMENT_ATTRIBUTE_CONTAINS]: 'Asserts that the specified attribute contains the provided value',
  [AssertionType.ELEMENT_ATTRIBUTE_MATCHES]: 'Asserts that the specified attribute matches the provided regular expression',
  [AssertionType.ELEMENT_CSS_PROPERTY_EQUALS]: 'Asserts that the specified CSS property equals the provided value',
  [AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS]: 'Asserts that the specified CSS property contains the provided value',
  [AssertionType.ELEMENT_CSS_CLASS_CONTAINS]: 'Asserts that the element has the specified CSS class',
  [AssertionType.ELEMENT_COUNT_EQUALS]: 'Asserts that the number of matching elements equals the specified count',
  [AssertionType.ELEMENT_COUNT_GREATER_THAN]: 'Asserts that the number of matching elements is greater than the specified count',
  [AssertionType.ELEMENT_COUNT_LESS_THAN]: 'Asserts that the number of matching elements is less than the specified count',
  [AssertionType.URL_CONTAINS]: 'Asserts that the current URL contains the specified string',
  [AssertionType.URL_EQUALS]: 'Asserts that the current URL exactly matches the specified URL',
  [AssertionType.URL_MATCHES]: 'Asserts that the current URL matches the specified regular expression',
  [AssertionType.TITLE_CONTAINS]: 'Asserts that the page title contains the specified string',
  [AssertionType.TITLE_EQUALS]: 'Asserts that the page title exactly matches the specified string',
  [AssertionType.TITLE_MATCHES]: 'Asserts that the page title matches the specified regular expression',
  [AssertionType.PAGE_CONTAINS_TEXT]: 'Asserts that the page contains the specified text',
  [AssertionType.JAVASCRIPT_RETURNS_TRUE]: 'Asserts that the specified JavaScript expression evaluates to true',
  [AssertionType.CUSTOM_FUNCTION]: 'Asserts that the specified custom function returns true',
};

// Interface for the assertion configuration
interface AssertionConfig {
  id: string;
  type: AssertionType;
  elementSelector?: {
    value: string;
    type: 'css' | 'xpath' | 'id' | 'name' | 'className' | 'tagName' | 'linkText' | 'partialLinkText';
  };
  attribute?: string;
  cssProperty?: string;
  expectedValue?: string;
  timeout?: number;
  failTestOnFailure: boolean;
  description?: string;
  matchType?: 'equals' | 'contains' | 'matches' | 'greaterThan' | 'lessThan';
  javascriptCode?: string;
  customFunctionCode?: string;
  invertAssertion: boolean;
  screenshotOnFailure: boolean;
  retryInterval?: number;
  retryCount?: number;
}

// Default assertion configuration
const defaultAssertionConfig: AssertionConfig = {
  id: `assertion-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
  type: AssertionType.ELEMENT_VISIBLE,
  elementSelector: {
    value: '',
    type: 'css',
  },
  timeout: 10000, // 10 seconds
  failTestOnFailure: true,
  invertAssertion: false,
  screenshotOnFailure: true,
  retryInterval: 500, // 500 milliseconds
  retryCount: 3,
};

// Framework-specific code generation functions
interface FrameworkCodeGenerator {
  generateCode: (config: AssertionConfig) => string;
  validateConfig: (config: AssertionConfig) => string[];
}

const seleniumJavaCodeGenerator: FrameworkCodeGenerator = {
  generateCode: (config: AssertionConfig): string => {
    const {
      type,
      elementSelector,
      attribute,
      cssProperty,
      expectedValue,
      timeout,
      failTestOnFailure,
      matchType,
      javascriptCode,
      customFunctionCode,
      invertAssertion,
      screenshotOnFailure,
      retryInterval,
      retryCount,
    } = config;

    // Helper method to generate locator code
    const generateLocator = (): string => {
      if (!elementSelector) return '';
      
      switch (elementSelector.type) {
        case 'css':
          return `By.cssSelector("${elementSelector.value}")`;
        case 'xpath':
          return `By.xpath("${elementSelector.value}")`;
        case 'id':
          return `By.id("${elementSelector.value}")`;
        case 'name':
          return `By.name("${elementSelector.value}")`;
        case 'className':
          return `By.className("${elementSelector.value}")`;
        case 'tagName':
          return `By.tagName("${elementSelector.value}")`;
        case 'linkText':
          return `By.linkText("${elementSelector.value}")`;
        case 'partialLinkText':
          return `By.partialLinkText("${elementSelector.value}")`;
        default:
          return `By.cssSelector("${elementSelector.value}")`;
      }
    };

    // Common assertion settings
    const assertionSettings = [
      `        .withTimeout(${timeout})`,
      `        .failTestOnFailure(${failTestOnFailure})`,
      `        .invertAssertion(${invertAssertion})`,
      `        .screenshotOnFailure(${screenshotOnFailure})`,
      `        .withRetryInterval(${retryInterval})`,
      `        .withRetryCount(${retryCount})`,
    ].join('\n');

    // Generate code based on assertion type
    switch (type) {
      case AssertionType.ELEMENT_PRESENT:
        return `CSAssertion.elementPresent(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_NOT_PRESENT:
        return `CSAssertion.elementNotPresent(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_VISIBLE:
        return `CSAssertion.elementVisible(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_NOT_VISIBLE:
        return `CSAssertion.elementNotVisible(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_ENABLED:
        return `CSAssertion.elementEnabled(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_DISABLED:
        return `CSAssertion.elementDisabled(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_CONTAINS_TEXT:
        return `CSAssertion.elementContainsText(${generateLocator()}, "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_TEXT_EQUALS:
        return `CSAssertion.elementTextEquals(${generateLocator()}, "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_TEXT_MATCHES:
        return `CSAssertion.elementTextMatches(${generateLocator()}, "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_EQUALS:
        return `CSAssertion.elementAttributeEquals(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_CONTAINS:
        return `CSAssertion.elementAttributeContains(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_MATCHES:
        return `CSAssertion.elementAttributeMatches(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_CSS_PROPERTY_EQUALS:
        return `CSAssertion.elementCssPropertyEquals(${generateLocator()}, "${cssProperty}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS:
        return `CSAssertion.elementCssPropertyContains(${generateLocator()}, "${cssProperty}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_CSS_CLASS_CONTAINS:
        return `CSAssertion.elementCssClassContains(${generateLocator()}, "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_COUNT_EQUALS:
        return `CSAssertion.elementCountEquals(${generateLocator()}, ${expectedValue})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_COUNT_GREATER_THAN:
        return `CSAssertion.elementCountGreaterThan(${generateLocator()}, ${expectedValue})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_COUNT_LESS_THAN:
        return `CSAssertion.elementCountLessThan(${generateLocator()}, ${expectedValue})
${assertionSettings}
        .perform();`;

      case AssertionType.URL_CONTAINS:
        return `CSAssertion.urlContains("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.URL_EQUALS:
        return `CSAssertion.urlEquals("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.URL_MATCHES:
        return `CSAssertion.urlMatches("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.TITLE_CONTAINS:
        return `CSAssertion.titleContains("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.TITLE_EQUALS:
        return `CSAssertion.titleEquals("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.TITLE_MATCHES:
        return `CSAssertion.titleMatches("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.PAGE_CONTAINS_TEXT:
        return `CSAssertion.pageContainsText("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.JAVASCRIPT_RETURNS_TRUE:
        return `CSAssertion.javascriptReturnsTrue("${javascriptCode?.replace(/"/g, '\\"')}")
${assertionSettings}
        .perform();`;

      case AssertionType.CUSTOM_FUNCTION:
        return `CSAssertion.customFunction(
  (driver, element) -> {
    ${customFunctionCode?.replace(/\n/g, '\n    ')}
  }
)
${assertionSettings}
        .perform();`;

      default:
        return `// Assertion type ${type} not implemented yet`;
    }
  },

  validateConfig: (config: AssertionConfig): string[] => {
    const errors: string[] = [];
    const { type, elementSelector, attribute, cssProperty, expectedValue, javascriptCode, customFunctionCode } = config;

    // Check common requirements
    if ([
      AssertionType.ELEMENT_PRESENT,
      AssertionType.ELEMENT_NOT_PRESENT,
      AssertionType.ELEMENT_VISIBLE,
      AssertionType.ELEMENT_NOT_VISIBLE,
      AssertionType.ELEMENT_ENABLED,
      AssertionType.ELEMENT_DISABLED,
      AssertionType.ELEMENT_CONTAINS_TEXT,
      AssertionType.ELEMENT_TEXT_EQUALS,
      AssertionType.ELEMENT_TEXT_MATCHES,
      AssertionType.ELEMENT_ATTRIBUTE_EQUALS,
      AssertionType.ELEMENT_ATTRIBUTE_CONTAINS,
      AssertionType.ELEMENT_ATTRIBUTE_MATCHES,
      AssertionType.ELEMENT_CSS_PROPERTY_EQUALS,
      AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS,
      AssertionType.ELEMENT_CSS_CLASS_CONTAINS,
      AssertionType.ELEMENT_COUNT_EQUALS,
      AssertionType.ELEMENT_COUNT_GREATER_THAN,
      AssertionType.ELEMENT_COUNT_LESS_THAN,
    ].includes(type)) {
      if (!elementSelector || !elementSelector.value) {
        errors.push('Element selector is required');
      }
    }

    if ([
      AssertionType.ELEMENT_CONTAINS_TEXT,
      AssertionType.ELEMENT_TEXT_EQUALS,
      AssertionType.ELEMENT_TEXT_MATCHES,
      AssertionType.ELEMENT_ATTRIBUTE_EQUALS,
      AssertionType.ELEMENT_ATTRIBUTE_CONTAINS,
      AssertionType.ELEMENT_ATTRIBUTE_MATCHES,
      AssertionType.ELEMENT_CSS_PROPERTY_EQUALS,
      AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS,
      AssertionType.ELEMENT_CSS_CLASS_CONTAINS,
      AssertionType.URL_CONTAINS,
      AssertionType.URL_EQUALS,
      AssertionType.URL_MATCHES,
      AssertionType.TITLE_CONTAINS,
      AssertionType.TITLE_EQUALS,
      AssertionType.TITLE_MATCHES,
      AssertionType.PAGE_CONTAINS_TEXT,
    ].includes(type)) {
      if (!expectedValue) {
        errors.push('Expected value is required');
      }
    }

    if ([
      AssertionType.ELEMENT_ATTRIBUTE_EQUALS,
      AssertionType.ELEMENT_ATTRIBUTE_CONTAINS,
      AssertionType.ELEMENT_ATTRIBUTE_MATCHES,
    ].includes(type)) {
      if (!attribute) {
        errors.push('Attribute name is required');
      }
    }

    if ([
      AssertionType.ELEMENT_CSS_PROPERTY_EQUALS,
      AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS,
    ].includes(type)) {
      if (!cssProperty) {
        errors.push('CSS property name is required');
      }
    }

    if (type === AssertionType.JAVASCRIPT_RETURNS_TRUE) {
      if (!javascriptCode) {
        errors.push('JavaScript code is required');
      }
    }

    if (type === AssertionType.CUSTOM_FUNCTION) {
      if (!customFunctionCode) {
        errors.push('Custom function code is required');
      }
    }

    return errors;
  }
};

const seleniumTsCodeGenerator: FrameworkCodeGenerator = {
  generateCode: (config: AssertionConfig): string => {
    const {
      type,
      elementSelector,
      attribute,
      cssProperty,
      expectedValue,
      timeout,
      failTestOnFailure,
      matchType,
      javascriptCode,
      customFunctionCode,
      invertAssertion,
      screenshotOnFailure,
      retryInterval,
      retryCount,
    } = config;

    // Helper method to generate locator code
    const generateLocator = (): string => {
      if (!elementSelector) return '';
      
      switch (elementSelector.type) {
        case 'css':
          return `By.css("${elementSelector.value}")`;
        case 'xpath':
          return `By.xpath("${elementSelector.value}")`;
        case 'id':
          return `By.id("${elementSelector.value}")`;
        case 'name':
          return `By.name("${elementSelector.value}")`;
        case 'className':
          return `By.className("${elementSelector.value}")`;
        case 'tagName':
          return `By.tagName("${elementSelector.value}")`;
        case 'linkText':
          return `By.linkText("${elementSelector.value}")`;
        case 'partialLinkText':
          return `By.partialLinkText("${elementSelector.value}")`;
        default:
          return `By.css("${elementSelector.value}")`;
      }
    };

    // Common assertion settings
    const assertionSettings = [
      `    .withTimeout(${timeout})`,
      `    .failTestOnFailure(${failTestOnFailure})`,
      `    .invertAssertion(${invertAssertion})`,
      `    .screenshotOnFailure(${screenshotOnFailure})`,
      `    .withRetryInterval(${retryInterval})`,
      `    .withRetryCount(${retryCount})`,
    ].join('\n');

    // Generate code based on assertion type
    switch (type) {
      case AssertionType.ELEMENT_PRESENT:
        return `CSAssertion.elementPresent(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_NOT_PRESENT:
        return `CSAssertion.elementNotPresent(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_VISIBLE:
        return `CSAssertion.elementVisible(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_NOT_VISIBLE:
        return `CSAssertion.elementNotVisible(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_ENABLED:
        return `CSAssertion.elementEnabled(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_DISABLED:
        return `CSAssertion.elementDisabled(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_CONTAINS_TEXT:
        return `CSAssertion.elementContainsText(${generateLocator()}, "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_TEXT_EQUALS:
        return `CSAssertion.elementTextEquals(${generateLocator()}, "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_TEXT_MATCHES:
        return `CSAssertion.elementTextMatches(${generateLocator()}, "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_EQUALS:
        return `CSAssertion.elementAttributeEquals(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_CONTAINS:
        return `CSAssertion.elementAttributeContains(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_MATCHES:
        return `CSAssertion.elementAttributeMatches(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_CSS_PROPERTY_EQUALS:
        return `CSAssertion.elementCssPropertyEquals(${generateLocator()}, "${cssProperty}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS:
        return `CSAssertion.elementCssPropertyContains(${generateLocator()}, "${cssProperty}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_CSS_CLASS_CONTAINS:
        return `CSAssertion.elementCssClassContains(${generateLocator()}, "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_COUNT_EQUALS:
        return `CSAssertion.elementCountEquals(${generateLocator()}, ${expectedValue})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_COUNT_GREATER_THAN:
        return `CSAssertion.elementCountGreaterThan(${generateLocator()}, ${expectedValue})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_COUNT_LESS_THAN:
        return `CSAssertion.elementCountLessThan(${generateLocator()}, ${expectedValue})
${assertionSettings}
    .perform();`;

      case AssertionType.URL_CONTAINS:
        return `CSAssertion.urlContains("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.URL_EQUALS:
        return `CSAssertion.urlEquals("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.URL_MATCHES:
        return `CSAssertion.urlMatches("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.TITLE_CONTAINS:
        return `CSAssertion.titleContains("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.TITLE_EQUALS:
        return `CSAssertion.titleEquals("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.TITLE_MATCHES:
        return `CSAssertion.titleMatches("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.PAGE_CONTAINS_TEXT:
        return `CSAssertion.pageContainsText("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.JAVASCRIPT_RETURNS_TRUE:
        return `CSAssertion.javascriptReturnsTrue(\`${javascriptCode?.replace(/`/g, '\\`')}\`)
${assertionSettings}
    .perform();`;

      case AssertionType.CUSTOM_FUNCTION:
        return `CSAssertion.customFunction(
  (driver, element) => {
    ${customFunctionCode?.replace(/\n/g, '\n    ')}
  }
)
${assertionSettings}
    .perform();`;

      default:
        return `// Assertion type ${type} not implemented yet`;
    }
  },

  validateConfig: (config: AssertionConfig): string[] => {
    return seleniumJavaCodeGenerator.validateConfig(config);
  }
};

const playwrightJavaCodeGenerator: FrameworkCodeGenerator = {
  generateCode: (config: AssertionConfig): string => {
    const {
      type,
      elementSelector,
      attribute,
      cssProperty,
      expectedValue,
      timeout,
      failTestOnFailure,
      matchType,
      javascriptCode,
      customFunctionCode,
      invertAssertion,
      screenshotOnFailure,
      retryInterval,
      retryCount,
    } = config;

    // Helper method to generate locator code
    const generateLocator = (): string => {
      if (!elementSelector) return '';
      
      switch (elementSelector.type) {
        case 'css':
          return `CSLocator.css("${elementSelector.value}")`;
        case 'xpath':
          return `CSLocator.xpath("${elementSelector.value}")`;
        case 'id':
          return `CSLocator.css("#${elementSelector.value}")`;
        case 'name':
          return `CSLocator.css("[name='${elementSelector.value}']")`;
        case 'className':
          return `CSLocator.css(".${elementSelector.value}")`;
        case 'tagName':
          return `CSLocator.css("${elementSelector.value}")`;
        case 'linkText':
          return `CSLocator.text("${elementSelector.value}")`;
        case 'partialLinkText':
          return `CSLocator.text("${elementSelector.value}", true)`;
        default:
          return `CSLocator.css("${elementSelector.value}")`;
      }
    };

    // Common assertion settings
    const assertionSettings = [
      `        .withTimeout(${timeout})`,
      `        .failTestOnFailure(${failTestOnFailure})`,
      `        .invertAssertion(${invertAssertion})`,
      `        .screenshotOnFailure(${screenshotOnFailure})`,
      `        .withRetryInterval(${retryInterval})`,
      `        .withRetryCount(${retryCount})`,
    ].join('\n');

    // Generate code based on assertion type
    switch (type) {
      case AssertionType.ELEMENT_PRESENT:
        return `CSPlaywrightAssertion.elementPresent(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_NOT_PRESENT:
        return `CSPlaywrightAssertion.elementNotPresent(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_VISIBLE:
        return `CSPlaywrightAssertion.elementVisible(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_NOT_VISIBLE:
        return `CSPlaywrightAssertion.elementNotVisible(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_ENABLED:
        return `CSPlaywrightAssertion.elementEnabled(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_DISABLED:
        return `CSPlaywrightAssertion.elementDisabled(${generateLocator()})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_CONTAINS_TEXT:
        return `CSPlaywrightAssertion.elementContainsText(${generateLocator()}, "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_TEXT_EQUALS:
        return `CSPlaywrightAssertion.elementTextEquals(${generateLocator()}, "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_TEXT_MATCHES:
        return `CSPlaywrightAssertion.elementTextMatches(${generateLocator()}, "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_EQUALS:
        return `CSPlaywrightAssertion.elementAttributeEquals(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_CONTAINS:
        return `CSPlaywrightAssertion.elementAttributeContains(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_MATCHES:
        return `CSPlaywrightAssertion.elementAttributeMatches(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_CSS_PROPERTY_EQUALS:
        return `CSPlaywrightAssertion.elementCssPropertyEquals(${generateLocator()}, "${cssProperty}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS:
        return `CSPlaywrightAssertion.elementCssPropertyContains(${generateLocator()}, "${cssProperty}", "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_CSS_CLASS_CONTAINS:
        return `CSPlaywrightAssertion.elementCssClassContains(${generateLocator()}, "${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_COUNT_EQUALS:
        return `CSPlaywrightAssertion.elementCountEquals(${generateLocator()}, ${expectedValue})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_COUNT_GREATER_THAN:
        return `CSPlaywrightAssertion.elementCountGreaterThan(${generateLocator()}, ${expectedValue})
${assertionSettings}
        .perform();`;

      case AssertionType.ELEMENT_COUNT_LESS_THAN:
        return `CSPlaywrightAssertion.elementCountLessThan(${generateLocator()}, ${expectedValue})
${assertionSettings}
        .perform();`;

      case AssertionType.URL_CONTAINS:
        return `CSPlaywrightAssertion.urlContains("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.URL_EQUALS:
        return `CSPlaywrightAssertion.urlEquals("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.URL_MATCHES:
        return `CSPlaywrightAssertion.urlMatches("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.TITLE_CONTAINS:
        return `CSPlaywrightAssertion.titleContains("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.TITLE_EQUALS:
        return `CSPlaywrightAssertion.titleEquals("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.TITLE_MATCHES:
        return `CSPlaywrightAssertion.titleMatches("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.PAGE_CONTAINS_TEXT:
        return `CSPlaywrightAssertion.pageContainsText("${expectedValue}")
${assertionSettings}
        .perform();`;

      case AssertionType.JAVASCRIPT_RETURNS_TRUE:
        return `CSPlaywrightAssertion.javascriptReturnsTrue("${javascriptCode?.replace(/"/g, '\\"')}")
${assertionSettings}
        .perform();`;

      case AssertionType.CUSTOM_FUNCTION:
        return `CSPlaywrightAssertion.customFunction(
  (page, element) -> {
    ${customFunctionCode?.replace(/\n/g, '\n    ')}
  }
)
${assertionSettings}
        .perform();`;

      default:
        return `// Assertion type ${type} not implemented yet`;
    }
  },

  validateConfig: (config: AssertionConfig): string[] => {
    return seleniumJavaCodeGenerator.validateConfig(config);
  }
};

const playwrightTsCodeGenerator: FrameworkCodeGenerator = {
  generateCode: (config: AssertionConfig): string => {
    const {
      type,
      elementSelector,
      attribute,
      cssProperty,
      expectedValue,
      timeout,
      failTestOnFailure,
      matchType,
      javascriptCode,
      customFunctionCode,
      invertAssertion,
      screenshotOnFailure,
      retryInterval,
      retryCount,
    } = config;

    // Helper method to generate locator code
    const generateLocator = (): string => {
      if (!elementSelector) return '';
      
      switch (elementSelector.type) {
        case 'css':
          return `CSLocator.css("${elementSelector.value}")`;
        case 'xpath':
          return `CSLocator.xpath("${elementSelector.value}")`;
        case 'id':
          return `CSLocator.css("#${elementSelector.value}")`;
        case 'name':
          return `CSLocator.css("[name='${elementSelector.value}']")`;
        case 'className':
          return `CSLocator.css(".${elementSelector.value}")`;
        case 'tagName':
          return `CSLocator.css("${elementSelector.value}")`;
        case 'linkText':
          return `CSLocator.text("${elementSelector.value}")`;
        case 'partialLinkText':
          return `CSLocator.text("${elementSelector.value}", true)`;
        default:
          return `CSLocator.css("${elementSelector.value}")`;
      }
    };

    // Common assertion settings
    const assertionSettings = [
      `    .withTimeout(${timeout})`,
      `    .failTestOnFailure(${failTestOnFailure})`,
      `    .invertAssertion(${invertAssertion})`,
      `    .screenshotOnFailure(${screenshotOnFailure})`,
      `    .withRetryInterval(${retryInterval})`,
      `    .withRetryCount(${retryCount})`,
    ].join('\n');

    // Generate code based on assertion type
    switch (type) {
      case AssertionType.ELEMENT_PRESENT:
        return `CSPlaywrightAssertion.elementPresent(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_NOT_PRESENT:
        return `CSPlaywrightAssertion.elementNotPresent(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_VISIBLE:
        return `CSPlaywrightAssertion.elementVisible(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_NOT_VISIBLE:
        return `CSPlaywrightAssertion.elementNotVisible(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_ENABLED:
        return `CSPlaywrightAssertion.elementEnabled(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_DISABLED:
        return `CSPlaywrightAssertion.elementDisabled(${generateLocator()})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_CONTAINS_TEXT:
        return `CSPlaywrightAssertion.elementContainsText(${generateLocator()}, "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_TEXT_EQUALS:
        return `CSPlaywrightAssertion.elementTextEquals(${generateLocator()}, "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_TEXT_MATCHES:
        return `CSPlaywrightAssertion.elementTextMatches(${generateLocator()}, "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_EQUALS:
        return `CSPlaywrightAssertion.elementAttributeEquals(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_CONTAINS:
        return `CSPlaywrightAssertion.elementAttributeContains(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_ATTRIBUTE_MATCHES:
        return `CSPlaywrightAssertion.elementAttributeMatches(${generateLocator()}, "${attribute}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_CSS_PROPERTY_EQUALS:
        return `CSPlaywrightAssertion.elementCssPropertyEquals(${generateLocator()}, "${cssProperty}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS:
        return `CSPlaywrightAssertion.elementCssPropertyContains(${generateLocator()}, "${cssProperty}", "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_CSS_CLASS_CONTAINS:
        return `CSPlaywrightAssertion.elementCssClassContains(${generateLocator()}, "${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_COUNT_EQUALS:
        return `CSPlaywrightAssertion.elementCountEquals(${generateLocator()}, ${expectedValue})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_COUNT_GREATER_THAN:
        return `CSPlaywrightAssertion.elementCountGreaterThan(${generateLocator()}, ${expectedValue})
${assertionSettings}
    .perform();`;

      case AssertionType.ELEMENT_COUNT_LESS_THAN:
        return `CSPlaywrightAssertion.elementCountLessThan(${generateLocator()}, ${expectedValue})
${assertionSettings}
    .perform();`;

      case AssertionType.URL_CONTAINS:
        return `CSPlaywrightAssertion.urlContains("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.URL_EQUALS:
        return `CSPlaywrightAssertion.urlEquals("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.URL_MATCHES:
        return `CSPlaywrightAssertion.urlMatches("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.TITLE_CONTAINS:
        return `CSPlaywrightAssertion.titleContains("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.TITLE_EQUALS:
        return `CSPlaywrightAssertion.titleEquals("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.TITLE_MATCHES:
        return `CSPlaywrightAssertion.titleMatches("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.PAGE_CONTAINS_TEXT:
        return `CSPlaywrightAssertion.pageContainsText("${expectedValue}")
${assertionSettings}
    .perform();`;

      case AssertionType.JAVASCRIPT_RETURNS_TRUE:
        return `CSPlaywrightAssertion.javascriptReturnsTrue(\`${javascriptCode?.replace(/`/g, '\\`')}\`)
${assertionSettings}
    .perform();`;

      case AssertionType.CUSTOM_FUNCTION:
        return `CSPlaywrightAssertion.customFunction(
  (page, element) => {
    ${customFunctionCode?.replace(/\n/g, '\n    ')}
  }
)
${assertionSettings}
    .perform();`;

      default:
        return `// Assertion type ${type} not implemented yet`;
    }
  },

  validateConfig: (config: AssertionConfig): string[] => {
    return seleniumJavaCodeGenerator.validateConfig(config);
  }
};

// Create mapping of framework to code generator
const frameworkCodeGenerators: Record<string, FrameworkCodeGenerator> = {
  'selenium-java': seleniumJavaCodeGenerator,
  'selenium-typescript': seleniumTsCodeGenerator,
  'playwright-java': playwrightJavaCodeGenerator,
  'playwright-typescript': playwrightTsCodeGenerator,
};

// Interface for the component props
interface AssertionConfigProps {
  initialConfig?: Partial<AssertionConfig>;
  onSave: (config: AssertionConfig) => void;
  onCancel: () => void;
}

/**
 * AssertionConfig component for configuring assertions in the CSTestForge framework.
 * This component provides a UI for configuring various types of assertions for different test frameworks.
 */
const AssertionConfig: React.FC<AssertionConfigProps> = ({ initialConfig, onSave, onCancel }) => {
  // Get framework context
  const { framework, language } = useFramework();
  const { selectedElement } = useRecorder();
  
  // State for the current config
  const [config, setConfig] = useState<AssertionConfig>({
    ...defaultAssertionConfig,
    ...initialConfig,
  });
  
  // State for validation errors
  const [errors, setErrors] = useState<string[]>([]);
  
  // State for code preview
  const [codePreview, setCodePreview] = useState<string>('');
  
  // State for show element finder dialog
  const [showElementFinder, setShowElementFinder] = useState<boolean>(false);

  // State for active tab
  const [activeTab, setActiveTab] = useState<string>('basic');

  // Compute assertion categories and types for display
  const categories = useMemo(() => {
    const categorizedTypes: Record<AssertionCategory, AssertionType[]> = Object.values(AssertionCategory).reduce((acc, category) => {
      acc[category] = [];
      return acc;
    }, {} as Record<AssertionCategory, AssertionType[]>);

    Object.entries(assertionTypeToCategory).forEach(([type, category]) => {
      categorizedTypes[category].push(type as AssertionType);
    });

    return categorizedTypes;
  }, []);

  // Get the appropriate code generator
  const codeGenerator = useMemo(() => {
    const key = `${framework.toLowerCase()}-${language.toLowerCase()}`;
    return frameworkCodeGenerators[key] || seleniumJavaCodeGenerator;
  }, [framework, language]);

  // Update config when element changes
  useEffect(() => {
    if (selectedElement && !initialConfig?.elementSelector) {
      setConfig(prev => ({
        ...prev,
        elementSelector: {
          value: selectedElement.selector || '',
          type: selectedElement.selectorType as 'css' | 'xpath' | 'id' | 'name' | 'className' | 'tagName' | 'linkText' | 'partialLinkText' || 'css',
        },
      }));
    }
  }, [selectedElement, initialConfig]);

  // Generate code preview when config changes
  useEffect(() => {
    try {
      const code = codeGenerator.generateCode(config);
      setCodePreview(code);
    } catch (error) {
      setCodePreview(`// Error generating code: ${error instanceof Error ? error.message : String(error)}`);
    }
  }, [config, codeGenerator]);

  // Validate config when it changes
  useEffect(() => {
    const validationErrors = codeGenerator.validateConfig(config);
    setErrors(validationErrors);
  }, [config, codeGenerator]);

  // Handle category selection
  const handleCategorySelect = (category: AssertionCategory) => {
    if (categories[category].length > 0) {
      setConfig(prev => ({
        ...prev,
        type: categories[category][0],
      }));
    }
  };

  // Handle type change
  const handleTypeChange = (type: AssertionType) => {
    setConfig(prev => ({
      ...prev,
      type,
    }));
  };

  // Handle config changes
  const handleConfigChange = (key: keyof AssertionConfig, value: any) => {
    setConfig(prev => ({
      ...prev,
      [key]: value,
    }));
  };

  // Handle element selector changes
  const handleElementSelectorChange = (selector: { value: string; type: 'css' | 'xpath' | 'id' | 'name' | 'className' | 'tagName' | 'linkText' | 'partialLinkText' }) => {
    setConfig(prev => ({
      ...prev,
      elementSelector: selector,
    }));
  };

  // Handle element finder save
  const handleElementFinderSave = (selector: { value: string; type: string }) => {
    setConfig(prev => ({
      ...prev,
      elementSelector: {
        value: selector.value,
        type: selector.type as 'css' | 'xpath' | 'id' | 'name' | 'className' | 'tagName' | 'linkText' | 'partialLinkText',
      },
    }));
    setShowElementFinder(false);
  };

  // Handle save
  const handleSave = () => {
    const validationErrors = codeGenerator.validateConfig(config);
    if (validationErrors.length > 0) {
      setErrors(validationErrors);
      return;
    }
    
    onSave(config);
  };

  // Render element-specific fields
  const renderElementSpecificFields = () => {
    const requiresElement = [
      AssertionType.ELEMENT_PRESENT,
      AssertionType.ELEMENT_NOT_PRESENT,
      AssertionType.ELEMENT_VISIBLE,
      AssertionType.ELEMENT_NOT_VISIBLE,
      AssertionType.ELEMENT_ENABLED,
      AssertionType.ELEMENT_DISABLED,
      AssertionType.ELEMENT_CONTAINS_TEXT,
      AssertionType.ELEMENT_TEXT_EQUALS,
      AssertionType.ELEMENT_TEXT_MATCHES,
      AssertionType.ELEMENT_ATTRIBUTE_EQUALS,
      AssertionType.ELEMENT_ATTRIBUTE_CONTAINS,
      AssertionType.ELEMENT_ATTRIBUTE_MATCHES,
      AssertionType.ELEMENT_CSS_PROPERTY_EQUALS,
      AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS,
      AssertionType.ELEMENT_CSS_CLASS_CONTAINS,
      AssertionType.ELEMENT_COUNT_EQUALS,
      AssertionType.ELEMENT_COUNT_GREATER_THAN,
      AssertionType.ELEMENT_COUNT_LESS_THAN,
    ].includes(config.type);

    if (!requiresElement) {
      return null;
    }

    return (
      <div className="element-selector">
        <div className="flex justify-between items-center mb-2">
          <label className="text-sm font-medium">Element Selector</label>
          <Button variant="secondary" size="sm" onClick={() => setShowElementFinder(true)}>
            Find Element
          </Button>
        </div>
        <div className="flex gap-2 mb-4">
          <Select
            value={config.elementSelector?.type || 'css'}
            onChange={(e) => handleElementSelectorChange({ 
              value: config.elementSelector?.value || '', 
              type: e.target.value as 'css' | 'xpath' | 'id' | 'name' | 'className' | 'tagName' | 'linkText' | 'partialLinkText' 
            })}
            options={[
              { value: 'css', label: 'CSS' },
              { value: 'xpath', label: 'XPath' },
              { value: 'id', label: 'ID' },
              { value: 'name', label: 'Name' },
              { value: 'className', label: 'Class Name' },
              { value: 'tagName', label: 'Tag Name' },
              { value: 'linkText', label: 'Link Text' },
              { value: 'partialLinkText', label: 'Partial Link Text' },
            ]}
            className="w-1/3"
          />
          <Input
            value={config.elementSelector?.value || ''}
            onChange={(e) => handleElementSelectorChange({ 
              value: e.target.value, 
              type: config.elementSelector?.type || 'css'
            })}
            placeholder="Enter selector"
            className="w-2/3"
          />
        </div>
      </div>
    );
  };

  // Render attribute fields
  const renderAttributeFields = () => {
    const requiresAttribute = [
      AssertionType.ELEMENT_ATTRIBUTE_EQUALS,
      AssertionType.ELEMENT_ATTRIBUTE_CONTAINS,
      AssertionType.ELEMENT_ATTRIBUTE_MATCHES,
    ].includes(config.type);

    if (!requiresAttribute) {
      return null;
    }

    return (
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Attribute Name</label>
        <Input
          value={config.attribute || ''}
          onChange={(e) => handleConfigChange('attribute', e.target.value)}
          placeholder="Enter attribute name"
        />
      </div>
    );
  };

  // Render CSS property fields
  const renderCssPropertyFields = () => {
    const requiresCssProperty = [
      AssertionType.ELEMENT_CSS_PROPERTY_EQUALS,
      AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS,
    ].includes(config.type);

    if (!requiresCssProperty) {
      return null;
    }

    return (
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">CSS Property</label>
        <Input
          value={config.cssProperty || ''}
          onChange={(e) => handleConfigChange('cssProperty', e.target.value)}
          placeholder="Enter CSS property"
        />
      </div>
    );
  };

  // Render expected value fields
  const renderExpectedValueField = () => {
    const requiresExpectedValue = [
      AssertionType.ELEMENT_CONTAINS_TEXT,
      AssertionType.ELEMENT_TEXT_EQUALS,
      AssertionType.ELEMENT_TEXT_MATCHES,
      AssertionType.ELEMENT_ATTRIBUTE_EQUALS,
      AssertionType.ELEMENT_ATTRIBUTE_CONTAINS,
      AssertionType.ELEMENT_ATTRIBUTE_MATCHES,
      AssertionType.ELEMENT_CSS_PROPERTY_EQUALS,
      AssertionType.ELEMENT_CSS_PROPERTY_CONTAINS,
      AssertionType.ELEMENT_CSS_CLASS_CONTAINS,
      AssertionType.URL_CONTAINS,
      AssertionType.URL_EQUALS,
      AssertionType.URL_MATCHES,
      AssertionType.TITLE_CONTAINS,
      AssertionType.TITLE_EQUALS,
      AssertionType.TITLE_MATCHES,
      AssertionType.PAGE_CONTAINS_TEXT,
    ].includes(config.type);

    const requiresNumericValue = [
      AssertionType.ELEMENT_COUNT_EQUALS,
      AssertionType.ELEMENT_COUNT_GREATER_THAN,
      AssertionType.ELEMENT_COUNT_LESS_THAN,
    ].includes(config.type);

    if (!requiresExpectedValue && !requiresNumericValue) {
      return null;
    }

    return (
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Expected Value</label>
        <Input
          value={config.expectedValue || ''}
          onChange={(e) => handleConfigChange('expectedValue', e.target.value)}
          type={requiresNumericValue ? 'number' : 'text'}
          placeholder={requiresNumericValue ? 'Enter number' : 'Enter expected value'}
        />
      </div>
    );
  };

  // Render JavaScript code field
  const renderJavaScriptField = () => {
    if (config.type !== AssertionType.JAVASCRIPT_RETURNS_TRUE) {
      return null;
    }

    return (
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">JavaScript Code</label>
        <textarea
          value={config.javascriptCode || ''}
          onChange={(e) => handleConfigChange('javascriptCode', e.target.value)}
          placeholder="Enter JavaScript code that returns a boolean value"
          className="w-full min-h-[100px] p-2 border border-gray-300 rounded-md resize-vertical"
        />
      </div>
    );
  };

  // Render custom function field
  const renderCustomFunctionField = () => {
    if (config.type !== AssertionType.CUSTOM_FUNCTION) {
      return null;
    }

    return (
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Custom Function</label>
        <textarea
          value={config.customFunctionCode || ''}
          onChange={(e) => handleConfigChange('customFunctionCode', e.target.value)}
          placeholder={`Enter custom function code\nExample: return element.isVisible();`}
          className="w-full min-h-[100px] p-2 border border-gray-300 rounded-md resize-vertical"
        />
      </div>
    );
  };

  return (
    <div className="assertion-config p-4 max-w-4xl mx-auto">
      <h2 className="text-xl font-bold mb-4">Configure Assertion</h2>
      
      <Tabs
        tabs={[
          { id: 'basic', label: 'Basic' },
          { id: 'advanced', label: 'Advanced' },
          { id: 'code', label: 'Code Preview' },
        ]}
        activeTab={activeTab}
        onChange={setActiveTab}
      />

      <div className="mt-4">
        {activeTab === 'basic' && (
          <div>
            {/* Assertion Type Selection */}
            <div className="mb-4">
              <label className="block text-sm font-medium mb-1">Assertion Category</label>
              <Select
                value={assertionTypeToCategory[config.type]}
                onChange={(e) => handleCategorySelect(e.target.value as AssertionCategory)}
                options={Object.values(AssertionCategory).map(category => ({
                  value: category,
                  label: category,
                }))}
              />
            </div>

            <div className="mb-4">
              <label className="block text-sm font-medium mb-1">Assertion Type</label>
              <Select
                value={config.type}
                onChange={(e) => handleTypeChange(e.target.value as AssertionType)}
                options={categories[assertionTypeToCategory[config.type]].map(type => ({
                  value: type,
                  label: assertionTypeLabels[type],
                }))}
              />
              <p className="text{assertionTypeDescriptions[config.type] && (
                <p className="text-sm text-gray-600 mt-1">{assertionTypeDescriptions[config.type]}</p>
              )}
            </div>

            {/* Element-specific fields */}
            {renderElementSpecificFields()}

            {/* Attribute fields */}
            {renderAttributeFields()}

            {/* CSS property fields */}
            {renderCssPropertyFields()}

            {/* Expected value field */}
            {renderExpectedValueField()}

            {/* JavaScript code field */}
            {renderJavaScriptField()}

            {/* Custom function field */}
            {renderCustomFunctionField()}

            {/* Description */}
            <div className="mb-4">
              <label className="block text-sm font-medium mb-1">Description</label>
              <Input
                value={config.description || ''}
                onChange={(e) => handleConfigChange('description', e.target.value)}
                placeholder="Enter assertion description"
              />
            </div>

            {/* Error messages */}
            {errors.length > 0 && (
              <div className="mb-4 p-3 bg-red-100 border border-red-300 rounded-md">
                <p className="text-sm text-red-800 font-medium mb-1">Please fix the following errors:</p>
                <ul className="list-disc pl-5">
                  {errors.map((error, index) => (
                    <li key={index} className="text-sm text-red-800">{error}</li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        )}

        {activeTab === 'advanced' && (
          <div>
            {/* Timeout */}
            <div className="mb-4">
              <label className="block text-sm font-medium mb-1">Timeout (ms)</label>
              <Input
                type="number"
                value={config.timeout}
                onChange={(e) => handleConfigChange('timeout', parseInt(e.target.value, 10))}
                min={0}
                step={100}
              />
              <p className="text-sm text-gray-600 mt-1">Maximum time to wait for the assertion to pass</p>
            </div>

            {/* Retry settings */}
            <div className="mb-4 grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium mb-1">Retry Count</label>
                <Input
                  type="number"
                  value={config.retryCount}
                  onChange={(e) => handleConfigChange('retryCount', parseInt(e.target.value, 10))}
                  min={0}
                />
                <p className="text-sm text-gray-600 mt-1">Number of retry attempts</p>
              </div>
              <div>
                <label className="block text-sm font-medium mb-1">Retry Interval (ms)</label>
                <Input
                  type="number"
                  value={config.retryInterval}
                  onChange={(e) => handleConfigChange('retryInterval', parseInt(e.target.value, 10))}
                  min={0}
                  step={100}
                />
                <p className="text-sm text-gray-600 mt-1">Time between retry attempts</p>
              </div>
            </div>

            {/* Failure behavior */}
            <div className="mb-4">
              <div className="flex items-center mb-2">
                <Toggle
                  checked={config.failTestOnFailure}
                  onChange={(checked) => handleConfigChange('failTestOnFailure', checked)}
                  id="fail-test-toggle"
                />
                <label htmlFor="fail-test-toggle" className="ml-2 text-sm font-medium">
                  Fail Test on Assertion Failure
                </label>
              </div>
              <p className="text-sm text-gray-600 ml-10">If enabled, the test will fail when this assertion fails</p>
            </div>

            {/* Screenshot on failure */}
            <div className="mb-4">
              <div className="flex items-center mb-2">
                <Toggle
                  checked={config.screenshotOnFailure}
                  onChange={(checked) => handleConfigChange('screenshotOnFailure', checked)}
                  id="screenshot-toggle"
                />
                <label htmlFor="screenshot-toggle" className="ml-2 text-sm font-medium">
                  Take Screenshot on Failure
                </label>
              </div>
              <p className="text-sm text-gray-600 ml-10">If enabled, a screenshot will be taken when this assertion fails</p>
            </div>

            {/* Invert assertion */}
            <div className="mb-4">
              <div className="flex items-center mb-2">
                <Toggle
                  checked={config.invertAssertion}
                  onChange={(checked) => handleConfigChange('invertAssertion', checked)}
                  id="invert-toggle"
                />
                <label htmlFor="invert-toggle" className="ml-2 text-sm font-medium">
                  Invert Assertion
                </label>
              </div>
              <p className="text-sm text-gray-600 ml-10">If enabled, the assertion result will be inverted (pass becomes fail and vice versa)</p>
            </div>
          </div>
        )}

        {activeTab === 'code' && (
          <div>
            <Card className="mb-4">
              <pre className="overflow-auto p-4 bg-gray-100 rounded-md text-sm font-mono whitespace-pre-wrap">
                {codePreview}
              </pre>
            </Card>
            <p className="text-sm text-gray-600">
              This is the code that will be generated for this assertion. It will be executed during test playback.
            </p>
          </div>
        )}
      </div>

      {/* Action buttons */}
      <div className="flex justify-end gap-2 mt-6">
        <Button variant="secondary" onClick={onCancel}>
          Cancel
        </Button>
        <Button
          variant="primary"
          onClick={handleSave}
          disabled={errors.length > 0}
        >
          Save Assertion
        </Button>
      </div>

      {/* Element finder modal */}
      {showElementFinder && (
        <Modal
          isOpen={showElementFinder}
          onClose={() => setShowElementFinder(false)}
          title="Find Element"
          size="large"
        >
          <ElementFinderConfig
            onSave={handleElementFinderSave}
            onCancel={() => setShowElementFinder(false)}
            initialValue={config.elementSelector?.value}
            initialType={config.elementSelector?.type}
          />
        </Modal>
      )}
    </div>
  );
};

export default AssertionConfig;


ElementFinderConfig.tsx
--------------------------------------

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Button } from '../../common/Button';
import { Select } from '../../common/Select';
import { Input } from '../../common/Input';
import { Tabs } from '../../common/Tabs';
import { Card } from '../../common/Card';
import { Tooltip } from '../../common/Tooltip';
import { Spinner } from '../../common/Spinner';
import { Alert } from '../../common/Alert';
import { useFramework } from '../../../hooks/useFramework';
import { useRecorder } from '../../../hooks/useRecorder';

// Element selector types
enum SelectorType {
  CSS = 'css',
  XPATH = 'xpath',
  ID = 'id',
  NAME = 'name',
  CLASS_NAME = 'className',
  TAG_NAME = 'tagName',
  LINK_TEXT = 'linkText',
  PARTIAL_LINK_TEXT = 'partialLinkText',
}

// Element attribute types used for generating selectors
enum AttributeType {
  ID = 'id',
  NAME = 'name',
  CLASS = 'class',
  HREF = 'href',
  SRC = 'src',
  ALT = 'alt',
  TITLE = 'title',
  PLACEHOLDER = 'placeholder',
  VALUE = 'value',
  TYPE = 'type',
  ROLE = 'role',
  ARIA_LABEL = 'aria-label',
  DATA = 'data-*',
  CUSTOM = 'custom',
}

// Interface for element information
interface ElementInfo {
  tagName: string;
  attributes: {
    id?: string;
    name?: string;
    className?: string;
    href?: string;
    src?: string;
    alt?: string;
    title?: string;
    placeholder?: string;
    value?: string;
    type?: string;
    role?: string;
    'aria-label'?: string;
    [key: string]: string | undefined;
  };
  innerText?: string;
  xpath: string;
  css: string;
  index: number;
  children: number;
  siblings: number;
  isUnique: boolean;
}

// Interface for suggested selector
interface SuggestedSelector {
  type: SelectorType;
  value: string;
  isUnique: boolean;
  matchCount: number;
  quality: number; // 1-10 score
  description: string;
}

// Interface for component props
interface ElementFinderConfigProps {
  initialValue?: string;
  initialType?: string;
  onSave: (selector: { value: string; type: string }) => void;
  onCancel: () => void;
}

/**
 * ElementFinderConfig component for finding and configuring element selectors in the CSTestForge framework.
 * This component provides a UI for selecting elements from the page and generating high-quality selectors.
 */
const ElementFinderConfig: React.FC<ElementFinderConfigProps> = ({
  initialValue,
  initialType = SelectorType.CSS,
  onSave,
  onCancel,
}) => {
  // Get framework context
  const { framework, language } = useFramework();
  const { recordingFrame, selectedElement, selectElement, highlightElement, unhighlightElement } = useRecorder();
  
  // State for the current selector
  const [selectorType, setSelectorType] = useState<SelectorType>(initialType as SelectorType || SelectorType.CSS);
  const [selectorValue, setSelectorValue] = useState<string>(initialValue || '');
  
  // State for active tab
  const [activeTab, setActiveTab] = useState<string>('visual');
  
  // State for element selection mode
  const [isSelectionMode, setIsSelectionMode] = useState<boolean>(false);
  
  // State for selected element info
  const [selectedElementInfo, setSelectedElementInfo] = useState<ElementInfo | null>(null);
  
  // State for suggested selectors
  const [suggestedSelectors, setSuggestedSelectors] = useState<SuggestedSelector[]>([]);
  
  // State for testing selector
  const [isTesting, setIsTesting] = useState<boolean>(false);
  const [testResult, setTestResult] = useState<{ success: boolean; count: number; message: string } | null>(null);
  
  // Reference to the iframe for browsing
  const iframeRef = useRef<HTMLIFrameElement | null>(null);

  // Effect for initializing the iframe reference
  useEffect(() => {
    if (recordingFrame) {
      iframeRef.current = recordingFrame;
    }
  }, [recordingFrame]);

  // Effect for updating the selected element info
  useEffect(() => {
    if (selectedElement) {
      // Fetch detailed element info from the recorder
      const elementInfo: ElementInfo = {
        tagName: selectedElement.tagName || '',
        attributes: selectedElement.attributes || {},
        innerText: selectedElement.innerText || '',
        xpath: selectedElement.xpathSelector || '',
        css: selectedElement.cssSelector || '',
        index: selectedElement.index || 0,
        children: selectedElement.childCount || 0,
        siblings: selectedElement.siblingCount || 0,
        isUnique: selectedElement.isUnique || false,
      };
      
      setSelectedElementInfo(elementInfo);
      
      // Generate suggested selectors
      generateSuggestedSelectors(elementInfo);
      
      // Set the selected selector
      if (selectedElement.cssSelector) {
        setSelectorType(SelectorType.CSS);
        setSelectorValue(selectedElement.cssSelector);
      } else if (selectedElement.xpathSelector) {
        setSelectorType(SelectorType.XPATH);
        setSelectorValue(selectedElement.xpathSelector);
      }
    }
  }, [selectedElement]);

  // Function to start element selection mode
  const startElementSelection = useCallback(() => {
    setIsSelectionMode(true);
    
    // Add event listeners to the iframe to capture element interactions
    if (iframeRef.current) {
      const iframe = iframeRef.current;
      const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
      
      if (iframeDoc) {
        // Add mouseover event to highlight elements
        iframeDoc.addEventListener('mouseover', handleElementMouseOver);
        
        // Add click event to select elements
        iframeDoc.addEventListener('click', handleElementClick);
        
        // Add keydown event to cancel selection mode with Escape key
        iframeDoc.addEventListener('keydown', handleKeyDown);
        
        // Apply styles to indicate selection mode
        const styleElement = iframeDoc.createElement('style');
        styleElement.id = 'cstestforge-selector-style';
        styleElement.textContent = `
          * {
            cursor: crosshair !important;
          }
          .cstestforge-highlight {
            outline: 2px solid #C54B8C !important;
            background-color: rgba(197, 75, 140, 0.1) !important;
          }
        `;
        iframeDoc.head.appendChild(styleElement);
      }
    }
  }, [iframeRef]);

  // Function to stop element selection mode
  const stopElementSelection = useCallback(() => {
    setIsSelectionMode(false);
    
    // Remove event listeners from the iframe
    if (iframeRef.current) {
      const iframe = iframeRef.current;
      const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
      
      if (iframeDoc) {
        // Remove event listeners
        iframeDoc.removeEventListener('mouseover', handleElementMouseOver);
        iframeDoc.removeEventListener('click', handleElementClick);
        iframeDoc.removeEventListener('keydown', handleKeyDown);
        
        // Remove selection mode styles
        const styleElement = iframeDoc.getElementById('cstestforge-selector-style');
        if (styleElement) {
          styleElement.remove();
        }
        
        // Remove highlight class from all elements
        const highlightedElements = iframeDoc.querySelectorAll('.cstestforge-highlight');
        highlightedElements.forEach(element => {
          element.classList.remove('cstestforge-highlight');
        });
      }
    }
  }, [iframeRef]);

  // Function to handle mouse over events during element selection
  const handleElementMouseOver = useCallback((event: MouseEvent) => {
    if (!isSelectionMode) return;
    
    // Prevent default behavior
    event.preventDefault();
    event.stopPropagation();
    
    // Get the target element
    const element = event.target as HTMLElement;
    
    // Add highlight class
    element.classList.add('cstestforge-highlight');
    
    // Use the recorder's highlight function
    highlightElement(element);
  }, [isSelectionMode, highlightElement]);

  // Function to handle click events during element selection
  const handleElementClick = useCallback((event: MouseEvent) => {
    if (!isSelectionMode) return;
    
    // Prevent default behavior
    event.preventDefault();
    event.stopPropagation();
    
    // Get the target element
    const element = event.target as HTMLElement;
    
    // Use the recorder's select element function
    selectElement(element);
    
    // Stop selection mode
    stopElementSelection();
  }, [isSelectionMode, selectElement, stopElementSelection]);

  // Function to handle keydown events during element selection
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    if (event.key === 'Escape') {
      // Cancel selection mode
      stopElementSelection();
    }
  }, [stopElementSelection]);

  // Function to generate suggested selectors
  const generateSuggestedSelectors = useCallback((elementInfo: ElementInfo) => {
    const suggestedSelectors: SuggestedSelector[] = [];
    
    // ID selector
    if (elementInfo.attributes.id) {
      suggestedSelectors.push({
        type: SelectorType.ID,
        value: elementInfo.attributes.id,
        isUnique: true,
        matchCount: 1,
        quality: 10,
        description: 'ID selector - most reliable but could change with dynamic IDs',
      });
      
      suggestedSelectors.push({
        type: SelectorType.CSS,
        value: `#${elementInfo.attributes.id}`,
        isUnique: true,
        matchCount: 1,
        quality: 10,
        description: 'CSS ID selector - most reliable but could change with dynamic IDs',
      });
    }
    
    // Name selector
    if (elementInfo.attributes.name) {
      suggestedSelectors.push({
        type: SelectorType.NAME,
        value: elementInfo.attributes.name,
        isUnique: elementInfo.isUnique,
        matchCount: elementInfo.isUnique ? 1 : 2,
        quality: 9,
        description: 'Name selector - very reliable for form elements',
      });
      
      suggestedSelectors.push({
        type: SelectorType.CSS,
        value: `[name="${elementInfo.attributes.name}"]`,
        isUnique: elementInfo.isUnique,
        matchCount: elementInfo.isUnique ? 1 : 2,
        quality: 9,
        description: 'CSS name selector - very reliable for form elements',
      });
    }
    
    // Class selector
    if (elementInfo.attributes.className) {
      const classes = elementInfo.attributes.className.split(' ').filter(c => c.trim() !== '');
      
      if (classes.length > 0) {
        // Individual class selectors
        classes.forEach(className => {
          suggestedSelectors.push({
            type: SelectorType.CLASS_NAME,
            value: className,
            isUnique: false,
            matchCount: 2,
            quality: 6,
            description: 'Class selector - may match multiple elements',
          });
        });
        
        // Combined class selector
        suggestedSelectors.push({
          type: SelectorType.CSS,
          value: `.${classes.join('.')}`,
          isUnique: elementInfo.isUnique,
          matchCount: elementInfo.isUnique ? 1 : 2,
          quality: 8,
          description: 'CSS combined class selector - more specific than single classes',
        });
      }
    }
    
    // Tag name selector
    if (elementInfo.tagName) {
      suggestedSelectors.push({
        type: SelectorType.TAG_NAME,
        value: elementInfo.tagName,
        isUnique: false,
        matchCount: 5,
        quality: 3,
        description: 'Tag name selector - least specific, likely matches many elements',
      });
    }
    
    // Link text selector
    if (elementInfo.tagName.toLowerCase() === 'a' && elementInfo.innerText) {
      suggestedSelectors.push({
        type: SelectorType.LINK_TEXT,
        value: elementInfo.innerText,
        isUnique: elementInfo.isUnique,
        matchCount: elementInfo.isUnique ? 1 : 2,
        quality: 7,
        description: 'Link text selector - good for links but fragile if text changes',
      });
      
      suggestedSelectors.push({
        type: SelectorType.PARTIAL_LINK_TEXT,
        value: elementInfo.innerText.substring(0, Math.min(20, elementInfo.innerText.length)),
        isUnique: false,
        matchCount: 2,
        quality: 6,
        description: 'Partial link text selector - more flexible but less specific',
      });
    }
    
    // ARIA attributes
    if (elementInfo.attributes['aria-label']) {
      suggestedSelectors.push({
        type: SelectorType.CSS,
        value: `[aria-label="${elementInfo.attributes['aria-label']}"]`,
        isUnique: elementInfo.isUnique,
        matchCount: elementInfo.isUnique ? 1 : 2,
        quality: 8,
        description: 'ARIA label selector - good for accessibility and usually unique',
      });
    }
    
    // Role attribute
    if (elementInfo.attributes.role) {
      suggestedSelectors.push({
        type: SelectorType.CSS,
        value: `[role="${elementInfo.attributes.role}"]`,
        isUnique: false,
        matchCount: 3,
        quality: 5,
        description: 'Role selector - good for identifying element purpose but not unique',
      });
    }
    
    // Data attributes
    const dataAttributes = Object.keys(elementInfo.attributes).filter(key => key.startsWith('data-'));
    dataAttributes.forEach(attr => {
      const value = elementInfo.attributes[attr];
      if (value) {
        suggestedSelectors.push({
          type: SelectorType.CSS,
          value: `[${attr}="${value}"]`,
          isUnique: elementInfo.isUnique,
          matchCount: elementInfo.isUnique ? 1 : 2,
          quality: 9,
          description: 'Data attribute selector - often used for testing and typically reliable',
        });
      }
    });
    
    // XPath selector
    if (elementInfo.xpath) {
      suggestedSelectors.push({
        type: SelectorType.XPATH,
        value: elementInfo.xpath,
        isUnique: true,
        matchCount: 1,
        quality: 8,
        description: 'XPath selector - very specific but can be fragile to DOM changes',
      });
    }
    
    // CSS selector
    if (elementInfo.css) {
      suggestedSelectors.push({
        type: SelectorType.CSS,
        value: elementInfo.css,
        isUnique: true,
        matchCount: 1,
        quality: 8,
        description: 'Generated CSS selector - specific but could be complex',
      });
    }
    
    // Sort selectors by quality
    suggestedSelectors.sort((a, b) => b.quality - a.quality);
    
    // Ensure suggested selectors are unique by value
    const uniqueSelectors: SuggestedSelector[] = [];
    const selectorValues = new Set<string>();
    
    suggestedSelectors.forEach(selector => {
      const key = `${selector.type}:${selector.value}`;
      if (!selectorValues.has(key)) {
        selectorValues.add(key);
        uniqueSelectors.push(selector);
      }
    });
    
    setSuggestedSelectors(uniqueSelectors);
  }, []);

  // Function to test the current selector
  const testSelector = useCallback(async () => {
    if (!selectorValue.trim()) {
      setTestResult({
        success: false,
        count: 0,
        message: 'Please enter a selector value',
      });
      return;
    }
    
    setIsTesting(true);
    setTestResult(null);
    
    try {
      // Execute the selector test in the iframe
      if (iframeRef.current) {
        const iframe = iframeRef.current;
        const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
        
        if (iframeDoc) {
          let elements: NodeListOf<Element> | null = null;
          
          // Find elements using the appropriate selector type
          switch (selectorType) {
            case SelectorType.CSS:
              elements = iframeDoc.querySelectorAll(selectorValue);
              break;
            case SelectorType.XPATH:
              const xpathResult = iframeDoc.evaluate(
                selectorValue,
                iframeDoc,
                null,
                XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
                null
              );
              // Convert XPath result to array
              const xpathElements: Element[] = [];
              for (let i = 0; i < xpathResult.snapshotLength; i++) {
                const element = xpathResult.snapshotItem(i) as Element;
                if (element) {
                  xpathElements.push(element);
                }
              }
              // Simulate a NodeList
              elements = {
                length: xpathElements.length,
                item: (index: number) => xpathElements[index] || null,
                [Symbol.iterator]: function* () {
                  for (let i = 0; i < xpathElements.length; i++) {
                    yield xpathElements[i];
                  }
                },
              } as unknown as NodeListOf<Element>;
              break;
            case SelectorType.ID:
              const elementById = iframeDoc.getElementById(selectorValue);
              elements = elementById ? [elementById] as unknown as NodeListOf<Element> : null;
              break;
            case SelectorType.NAME:
              elements = iframeDoc.getElementsByName(selectorValue);
              break;
            case SelectorType.CLASS_NAME:
              elements = iframeDoc.getElementsByClassName(selectorValue);
              break;
            case SelectorType.TAG_NAME:
              elements = iframeDoc.getElementsByTagName(selectorValue);
              break;
            case SelectorType.LINK_TEXT:
            case SelectorType.PARTIAL_LINK_TEXT:
              // For link text, we need to find all 'a' elements and filter them
              const allLinks = iframeDoc.getElementsByTagName('a');
              const matchingLinks: Element[] = [];
              
              for (let i = 0; i < allLinks.length; i++) {
                const link = allLinks[i];
                const linkText = link.textContent || '';
                
                if (selectorType === SelectorType.LINK_TEXT && linkText === selectorValue) {
                  matchingLinks.push(link);
                } else if (selectorType === SelectorType.PARTIAL_LINK_TEXT && linkText.includes(selectorValue)) {
                  matchingLinks.push(link);
                }
              }
              
              // Simulate a NodeList
              elements = {
                length: matchingLinks.length,
                item: (index: number) => matchingLinks[index] || null,
                [Symbol.iterator]: function* () {
                  for (let i = 0; i < matchingLinks.length; i++) {
                    yield matchingLinks[i];
                  }
                },
              } as unknown as NodeListOf<Element>;
              break;
          }
          
          // Process the test results
          if (elements) {
            const count = elements.length;
            
            // Clear existing highlights
            const highlightedElements = iframeDoc.querySelectorAll('.cstestforge-test-highlight');
            highlightedElements.forEach(element => {
              element.classList.remove('cstestforge-test-highlight');
            });
            
            // Add highlight style if it doesn't exist
            if (!iframeDoc.getElementById('cstestforge-test-highlight-style')) {
              const style = iframeDoc.createElement('style');
              style.id = 'cstestforge-test-highlight-style';
              style.textContent = `
                .cstestforge-test-highlight {
                  outline: 2px dashed #C54B8C !important;
                  background-color: rgba(197, 75, 140, 0.2) !important;
                  transition: outline 0.3s, background-color 0.3s;
                }
              `;
              iframeDoc.head.appendChild(style);
            }
            
            // Highlight matching elements
            for (let i = 0; i < elements.length; i++) {
              const element = elements[i];
              element.classList.add('cstestforge-test-highlight');
              
              // Scroll to the first element
              if (i === 0) {
                element.scrollIntoView({
                  behavior: 'smooth',
                  block: 'center',
                });
              }
            }
            
            // Set test result
            if (count === 0) {
              setTestResult({
                success: false,
                count,
                message: 'No elements found with this selector',
              });
            } else if (count === 1) {
              setTestResult({
                success: true,
                count,
                message: 'Unique element found! This selector is ideal.',
              });
            } else {
              setTestResult({
                success: false,
                count,
                message: `Found ${count} elements. Selector should ideally match only one element.`,
              });
            }
          } else {
            setTestResult({
              success: false,
              count: 0,
              message: 'No elements found with this selector',
            });
          }
        }
      }
    } catch (error) {
      setTestResult({
        success: false,
        count: 0,
        message: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      });
    } finally {
      setIsTesting(false);
    }
  }, [selectorType, selectorValue, iframeRef]);

  // Function to handle selector selection
  const handleSelectorSelect = (selector: SuggestedSelector) => {
    setSelectorType(selector.type);
    setSelectorValue(selector.value);
  };

  // Function to render the elements tab content
  const renderElementsTabContent = () => {
    if (!selectedElementInfo) {
      return (
        <div className="p-4 text-center">
          <p>No element selected. Use the visual selector tab to select an element.</p>
          <Button
            variant="secondary"
            onClick={() => {
              setActiveTab('visual');
              startElementSelection();
            }}
            className="mt-4"
          >
            Go to Visual Selector
          </Button>
        </div>
      );
    }
    
    return (
      <div className="p-4">
        <h3 className="text-lg font-medium mb-2">Element Details</h3>
        
        <Card className="mb-4">
          <div className="p-4">
            <div className="mb-2">
              <span className="font-medium">Tag:</span> {selectedElementInfo.tagName}
            </div>
            
            {selectedElementInfo.innerText && (
              <div className="mb-2">
                <span className="font-medium">Text:</span> {selectedElementInfo.innerText.substring(0, 100)}{selectedElementInfo.innerText.length > 100 ? '...' : ''}
              </div>
            )}
            
            <div className="mb-2">
              <span className="font-medium">Attributes:</span>
              <div className="pl-4">
                {Object.entries(selectedElementInfo.attributes).map(([key, value]) => (
                  <div key={key} className="text-sm">
                    <span className="font-medium">{key}:</span> {String(value)}
                  </div>
                ))}
              </div>
            </div>
          </div>
        </Card>
        
        <h3 className="text-lg font-medium mb-2">Suggested Selectors</h3>
        <div className="space-y-2">
          {suggestedSelectors.map((selector, index) => (
            <Card 
              key={index}
              className={`cursor-pointer hover:border-primary transition-colors duration-150 ${selectorType === selector.type && selectorValue === selector.value ? 'border-primary bg-primary bg-opacity-5' : ''}`}
              onClick={() => handleSelectorSelect(selector)}
            >
              <div className="p-3">
                <div className="flex justify-between items-center">
                  <div className="font-medium">{selector.type}</div>
                  <div className={`text-sm px-2 py-1 rounded ${selector.isUnique ? 'bg-green-100 text-green-800' : 'bg-yellow-100 text-yellow-800'}`}>
                    {selector.isUnique ? 'Unique' : `Matches: ~${selector.matchCount}`}
                  </div>
                </div>
                <div className="font-mono text-sm py-1 px-2 bg-gray-100 rounded mt-1 overflow-x-auto">
                  {selector.value}
                </div>
                <div className="text-sm text-gray-600 mt-1">
                  {selector.description}
                </div>
              </div>
            </Card>
          ))}
          
          {suggestedSelectors.length === 0 && (
            <div className="text-center p-4 bg-gray-50 rounded">
              No suggested selectors available for this element.
            </div>
          )}
        </div>
      </div>
    );
  };

  // Function to render the visual selector tab content
  const renderVisualSelectorTabContent = () => {
    return (
      <div className="p-4">
        <div className="mb-4">
          <p className="mb-2">
            Click on the button below to activate element selection mode, then click on an element in the browser to select it.
          </p>
          <Button
            variant="primary"
            onClick={startElementSelection}
            disabled={isSelectionMode}
          >
            {isSelectionMode ? 'Selection Mode Active' : 'Start Element Selection'}
          </Button>
          
          {isSelectionMode && (
            <p className="mt-2 text-sm text-gray-600">
              Hover over elements to highlight them, then click to select. Press ESC to cancel.
            </p>
          )}
        </div>
        
        {selectedElementInfo && (
          <div className="mt-4">
            <h3 className="text-lg font-medium mb-2">Selected Element</h3>
            <Card className="mb-4">
              <div className="p-4">
                <div className="mb-2">
                  <span className="font-medium">Tag:</span> {selectedElementInfo.tagName}
                </div>
                
                {selectedElementInfo.innerText && (
                  <div className="mb-2">
                    <span className="font-medium">Text:</span> {selectedElementInfo.innerText.substring(0, 100)}{selectedElementInfo.innerText.length > 100 ? '...' : ''}
                  </div>
                )}
                
                {selectedElementInfo.attributes.id && (
                  <div className="mb-2">
                    <span className="font-medium">ID:</span> {selectedElementInfo.attributes.id}
                  </div>
                )}
                
                {selectedElementInfo.attributes.className && (
                  <div className="mb-2">
                    <span className="font-medium">Class:</span> {selectedElementInfo.attributes.className}
                  </div>
                )}
              </div>
            </Card>
            
            <Button
              variant="secondary"
              onClick={() => setActiveTab('elements')}
            >
              View Suggested Selectors
            </Button>
          </div>
        )}
      </div>
    );
  };

  // Function to render the manual entry tab content
  const renderManualEntryTabContent = () => {
    return (
      <div className="p-4">
        <div className="mb-4">
          <label className="block text-sm font-medium mb-1">Selector Type</label>
          <Select
            value={selectorType}
            onChange={(e) => setSelectorType(e.target.value as SelectorType)}
            options={Object.values(SelectorType).map(type => ({
              value: type,
              label: type.charAt(0).toUpperCase() + type.slice(1),
            }))}
          />
        </div>
        
        <div className="mb-4">
          <label className="block text-sm font-medium mb-1">Selector Value</label>
          <Input
            value={selectorValue}
            onChange={(e) => setSelectorValue(e.target.value)}
            placeholder={`Enter ${selectorType} selector`}
          />
        </div>
        
        <div className="mb-4">
          <Button
            variant="secondary"
            onClick={testSelector}
            disabled={isTesting || !selectorValue.trim()}
          >
            {isTesting ? <Spinner size="sm" /> : 'Test Selector'}
          </Button>
        </div>
        
        {testResult && (
          <Alert
            type={testResult.success ? 'success' : 'error'}
            message={testResult.message}
            className="mb-4"
          />
        )}
        
        <div className="mt-4 text-sm">
          <h4 className="font-medium mb-1">Tips for writing good selectors:</h4>
          <ul className="list-disc pl-5 space-y-1">
            <li>Use IDs when available for the most reliable selectors</li>
            <li>Prefer CSS selectors for readability and flexibility</li>
            <li>Avoid using text content that might change</li>
            <li>Target elements with data-test or data-cy attributes when possible</li>
            <li>Ensure your selector matches exactly one element</li>
          </ul>
        </div>
      </div>
    );
  };

  // Main render function
  return (
    <div className="element-finder-config max-w-3xl mx-auto">
      <Tabs
        tabs={[
          { id: 'visual', label: 'Visual Selector' },
          { id: 'elements', label: 'Element Details' },
          { id: 'manual', label: 'Manual Entry' },
        ]}
        activeTab={activeTab}
        onChange={setActiveTab}
      />
      
      <div className="mt-4 border rounded-md">
        {activeTab === 'visual' && renderVisualSelectorTabContent()}
        {activeTab === 'elements' && renderElementsTabContent()}
        {activeTab === 'manual' && renderManualEntryTabContent()}
      </div>
      
      <div className="mt-6 mb-2">
        <div className="flex justify-between items-center">
          <div>
            <label className="block text-sm font-medium mb-1">Selected Selector</label>
            <div className="flex items-center gap-2">
              <div className="text-xs bg-gray-200 px-2 py-1 rounded">
                {selectorType}
              </div>
              <div className="font-mono text-sm py-1 px-2 bg-gray-100 rounded truncate max-w-md">
                {selectorValue}
              </div>
            </div>
          </div>
          
          <div>
            <Button
              variant="primary"
              onClick={() => onSave({ value: selectorValue, type: selectorType })}
              disabled={!selectorValue.trim()}
            >
              Save Selector
            </Button>
          </div>
        </div>
      </div>
      
      <div className="flex justify-end gap-2 mt-6">
        <Button variant="secondary" onClick={onCancel}>
          Cancel
        </Button>
        <Button
          variant="primary"
          onClick={() => onSave({ value: selectorValue, type: selectorType })}
          disabled={!selectorValue.trim()}
        >
          Save Selector
        </Button>
      </div>
    </div>
  );
};

export default ElementFinderConfig;


src/components/recorder/actions/CustomActionConfig.tsx
-------------------------------------------------
import React, { useState, useEffect, useCallback } from 'react';
import { useFramework } from '../../../hooks/useFramework';
import { useRecorder } from '../../../hooks/useRecorder';
import Button from '../../common/Button';
import Input from '../../common/Input';
import Select from '../../common/Select';
import Tabs from '../../common/Tabs';
import Modal from '../../common/Modal';
import Tooltip from '../../common/Tooltip';
import CodeEditor from '../../common/CodeEditor';
import { ActionType } from '../../../types/recorder';

interface CustomActionConfigProps {
  actionId?: string;
  isEdit?: boolean;
  onSave: (actionConfig: CustomActionConfigModel) => void;
  onCancel: () => void;
  initialValues?: CustomActionConfigModel;
}

export interface CustomActionConfigModel {
  id: string;
  name: string;
  description: string;
  actionType: ActionType;
  scriptType: 'javascript' | 'executor';
  executionContext: 'browser' | 'node' | 'java';
  script: string;
  returnVariable?: string;
  timeout: number;
  failOnError: boolean;
  parameters: CustomActionParameter[];
}

export interface CustomActionParameter {
  id: string;
  name: string;
  type: 'string' | 'number' | 'boolean' | 'element' | 'array' | 'object';
  value: string;
}

const defaultConfig: CustomActionConfigModel = {
  id: '',
  name: 'Custom Action',
  description: '',
  actionType: ActionType.CUSTOM,
  scriptType: 'javascript',
  executionContext: 'browser',
  script: '',
  timeout: 10000,
  failOnError: true,
  parameters: []
};

// Predefined script templates based on context
const scriptTemplates = {
  browser: {
    javascript: `/**
 * Custom browser-side JavaScript function
 * @param {HTMLElement} element - Target element if available
 * @param {Object} params - Custom parameters passed to this script
 * @returns {any} Result that can be stored in a variable
 */
function execute(element, params) {
  // Access to document, window and browser APIs
  console.log('Executing custom browser script');
  
  // Example: Modify element properties
  if (element) {
    element.style.border = '2px solid red';
    return element.textContent;
  }
  
  // Example: Interact with the page
  return document.title;
}`,
  },
  node: {
    javascript: `/**
 * Custom Node.js execution script
 * @param {Object} params - Custom parameters passed to this script
 * @returns {any} Result that can be stored in a variable
 */
function execute(params) {
  // Access to Node.js APIs
  console.log('Executing custom Node.js script');
  
  // Example: Process data or perform calculations
  const result = params.value ? params.value * 2 : 0;
  return result;
}`,
  },
  java: {
    executor: `/**
 * Custom Java execution code
 * This will be executed in the Java runtime environment
 * @param params - Parameters passed to this script
 * @return Object that can be stored in a variable
 */
public Object execute(Map<String, Object> params) {
  System.out.println("Executing custom Java script");
  
  // Example: Process data or perform calculations
  Object value = params.get("value");
  if (value instanceof Number) {
    return ((Number) value).doubleValue() * 2;
  }
  
  return "Execution completed";
}`,
  },
};

// RegEx patterns for validation
const variableNamePattern = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;

const CustomActionConfig: React.FC<CustomActionConfigProps> = ({
  actionId,
  isEdit = false,
  onSave,
  onCancel,
  initialValues,
}) => {
  const { framework } = useFramework();
  const { getActionById, validateScript } = useRecorder();
  
  const [config, setConfig] = useState<CustomActionConfigModel>(
    initialValues || { ...defaultConfig, id: actionId || `custom_action_${Date.now()}` }
  );
  const [activeTab, setActiveTab] = useState<string>('script');
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [showTemplateModal, setShowTemplateModal] = useState<boolean>(false);
  const [validationResult, setValidationResult] = useState<{ isValid: boolean; message?: string }>({ 
    isValid: true 
  });
  const [isValidating, setIsValidating] = useState<boolean>(false);

  useEffect(() => {
    if (initialValues) {
      setConfig(initialValues);
    }
  }, [initialValues]);

  // Update script template when execution context or script type changes
  useEffect(() => {
    if (!isEdit && !initialValues && config.script === '') {
      const template = scriptTemplates[config.executionContext]?.[config.scriptType];
      if (template) {
        setConfig(prev => ({
          ...prev,
          script: template
        }));
      }
    }
  }, [config.executionContext, config.scriptType, isEdit, initialValues]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    
    setConfig(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Clear error when field is changed
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };

  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    
    setConfig(prev => ({
      ...prev,
      [name]: checked
    }));
  };

  const handleScriptChange = (value: string) => {
    setConfig(prev => ({
      ...prev,
      script: value
    }));
    
    // Clear script error when changed
    if (errors.script) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors.script;
        return newErrors;
      });
    }
  };

  const handleExecutionContextChange = (value: string) => {
    const newContext = value as 'browser' | 'node' | 'java';
    
    // Determine new script type based on context
    let newScriptType: 'javascript' | 'executor' = 'javascript';
    if (newContext === 'java') {
      newScriptType = 'executor';
    }
    
    setConfig(prev => ({
      ...prev,
      executionContext: newContext,
      scriptType: newScriptType
    }));
  };

  const addParameter = () => {
    const newParam: CustomActionParameter = {
      id: `param_${Date.now()}`,
      name: `param${config.parameters.length + 1}`,
      type: 'string',
      value: ''
    };
    
    setConfig(prev => ({
      ...prev,
      parameters: [...prev.parameters, newParam]
    }));
  };

  const updateParameter = (id: string, field: keyof CustomActionParameter, value: string) => {
    setConfig(prev => ({
      ...prev,
      parameters: prev.parameters.map(param => 
        param.id === id ? { ...param, [field]: value } : param
      )
    }));
  };

  const removeParameter = (id: string) => {
    setConfig(prev => ({
      ...prev,
      parameters: prev.parameters.filter(param => param.id !== id)
    }));
  };

  const applyTemplate = (template: string) => {
    setConfig(prev => ({
      ...prev,
      script: template
    }));
    setShowTemplateModal(false);
  };

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    // Validate name
    if (!config.name.trim()) {
      newErrors.name = 'Name is required';
    }
    
    // Validate script
    if (!config.script.trim()) {
      newErrors.script = 'Script content is required';
    }
    
    // Validate return variable if provided
    if (config.returnVariable && !variableNamePattern.test(config.returnVariable)) {
      newErrors.returnVariable = 'Invalid variable name format';
    }
    
    // Validate timeout
    if (config.timeout <= 0) {
      newErrors.timeout = 'Timeout must be greater than 0';
    }
    
    // Validate parameters - no duplicate names
    const paramNames = new Set<string>();
    config.parameters.forEach((param, index) => {
      if (!param.name.trim()) {
        newErrors[`param_${param.id}_name`] = 'Parameter name is required';
      } else if (paramNames.has(param.name)) {
        newErrors[`param_${param.id}_name`] = 'Duplicate parameter name';
      } else {
        paramNames.add(param.name);
      }
      
      if (param.type === 'number' && param.value && isNaN(Number(param.value))) {
        newErrors[`param_${param.id}_value`] = 'Must be a valid number';
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleValidateScript = async () => {
    if (!config.script.trim()) {
      setValidationResult({
        isValid: false,
        message: 'Script content is empty'
      });
      return;
    }
    
    setIsValidating(true);
    try {
      const result = await validateScript(
        config.script,
        config.scriptType,
        config.executionContext,
        config.parameters
      );
      
      setValidationResult(result);
    } catch (error) {
      setValidationResult({
        isValid: false,
        message: error instanceof Error ? error.message : 'Unknown error occurred during validation'
      });
    } finally {
      setIsValidating(false);
    }
  };

  const handleSave = () => {
    if (validateForm()) {
      onSave(config);
    }
  };

  const executionContextOptions = [
    { value: 'browser', label: 'Browser (Client-side JavaScript)' },
    { value: 'node', label: 'Node.js (Server-side JavaScript)' }
  ];
  
  // Add Java option only if using Java framework
  if (framework === 'selenium-java' || framework === 'playwright-java') {
    executionContextOptions.push({ value: 'java', label: 'Java (JVM Execution)' });
  }

  const scriptTypeOptions = 
    config.executionContext === 'java' 
      ? [{ value: 'executor', label: 'Java Executor' }]
      : [{ value: 'javascript', label: 'JavaScript' }];

  const parameterTypeOptions = [
    { value: 'string', label: 'String' },
    { value: 'number', label: 'Number' },
    { value: 'boolean', label: 'Boolean' },
    { value: 'element', label: 'Element' },
    { value: 'array', label: 'Array' },
    { value: 'object', label: 'Object' }
  ];

  return (
    <div className="custom-action-config">
      <h2>{isEdit ? 'Edit Custom Action' : 'Create Custom Action'}</h2>
      
      <div className="config-form">
        <div className="form-row">
          <Input
            label="Name"
            name="name"
            value={config.name}
            onChange={handleInputChange}
            error={errors.name}
            required
          />
        </div>
        
        <div className="form-row">
          <Input
            label="Description"
            name="description"
            value={config.description}
            onChange={handleInputChange}
          />
        </div>
        
        <div className="form-row">
          <Select
            label="Execution Context"
            name="executionContext"
            value={config.executionContext}
            options={executionContextOptions}
            onChange={(e) => handleExecutionContextChange(e.target.value)}
          />
          
          <Select
            label="Script Type"
            name="scriptType"
            value={config.scriptType}
            options={scriptTypeOptions}
            onChange={handleInputChange}
            disabled={config.executionContext === 'java'} // Only one option for Java
          />
        </div>
        
        <div className="form-row">
          <Input
            label="Return Variable (Optional)"
            name="returnVariable"
            value={config.returnVariable || ''}
            onChange={handleInputChange}
            placeholder="variableName"
            error={errors.returnVariable}
            tooltip="Variable name to store the script result"
          />
          
          <Input
            label="Timeout (ms)"
            name="timeout"
            type="number"
            value={config.timeout.toString()}
            onChange={handleInputChange}
            min="0"
            error={errors.timeout}
          />
        </div>
        
        <div className="form-row">
          <label className="checkbox-container">
            <input
              type="checkbox"
              name="failOnError"
              checked={config.failOnError}
              onChange={handleCheckboxChange}
            />
            <span>Fail test on error</span>
            <Tooltip content="If checked, test will fail when this script throws an error" />
          </label>
        </div>
        
        <Tabs
          tabs={[
            { id: 'script', label: 'Script' },
            { id: 'parameters', label: `Parameters (${config.parameters.length})` }
          ]}
          activeTab={activeTab}
          onChange={setActiveTab}
        />
        
        {activeTab === 'script' && (
          <div className="script-editor-container">
            <div className="editor-toolbar">
              <Button 
                onClick={() => setShowTemplateModal(true)}
                variant="outline"
                size="small"
              >
                Insert Template
              </Button>
              
              <Button
                onClick={handleValidateScript}
                variant="outline"
                size="small"
                disabled={isValidating || !config.script.trim()}
              >
                {isValidating ? 'Validating...' : 'Validate Script'}
              </Button>
            </div>
            
            {validationResult.message && (
              <div className={`validation-result ${validationResult.isValid ? 'valid' : 'invalid'}`}>
                {validationResult.message}
              </div>
            )}
            
            <CodeEditor
              value={config.script}
              onChange={handleScriptChange}
              language={config.scriptType === 'executor' ? 'java' : 'javascript'}
              height="300px"
              error={errors.script}
            />
          </div>
        )}
        
        {activeTab === 'parameters' && (
          <div className="parameters-container">
            {config.parameters.length === 0 ? (
              <div className="no-parameters">
                <p>No parameters defined. Add parameters to pass data to your custom script.</p>
              </div>
            ) : (
              <div className="parameters-list">
                <div className="parameter-header">
                  <div className="param-name">Name</div>
                  <div className="param-type">Type</div>
                  <div className="param-value">Default Value</div>
                  <div className="param-actions">Actions</div>
                </div>
                
                {config.parameters.map(param => (
                  <div key={param.id} className="parameter-row">
                    <div className="param-name">
                      <Input
                        value={param.name}
                        onChange={(e) => updateParameter(param.id, 'name', e.target.value)}
                        error={errors[`param_${param.id}_name`]}
                      />
                    </div>
                    
                    <div className="param-type">
                      <Select
                        value={param.type}
                        options={parameterTypeOptions}
                        onChange={(e) => updateParameter(param.id, 'type', e.target.value)}
                      />
                    </div>
                    
                    <div className="param-value">
                      {param.type === 'boolean' ? (
                        <Select
                          value={param.value}
                          options={[
                            { value: 'true', label: 'true' },
                            { value: 'false', label: 'false' }
                          ]}
                          onChange={(e) => updateParameter(param.id, 'value', e.target.value)}
                        />
                      ) : (
                        <Input
                          value={param.value}
                          onChange={(e) => updateParameter(param.id, 'value', e.target.value)}
                          error={errors[`param_${param.id}_value`]}
                        />
                      )}
                    </div>
                    
                    <div className="param-actions">
                      <Button
                        onClick={() => removeParameter(param.id)}
                        variant="danger"
                        size="small"
                        iconOnly
                        aria-label="Remove Parameter"
                      >
                        X
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            )}
            
            <div className="add-parameter">
              <Button onClick={addParameter} variant="secondary" size="small">
                Add Parameter
              </Button>
            </div>
          </div>
        )}
        
        <div className="form-actions">
          <Button onClick={onCancel} variant="outline">
            Cancel
          </Button>
          
          <Button onClick={handleSave} variant="primary">
            {isEdit ? 'Update' : 'Create'} Custom Action
          </Button>
        </div>
      </div>
      
      {/* Template Modal */}
      <Modal
        isOpen={showTemplateModal}
        title="Choose Script Template"
        onClose={() => setShowTemplateModal(false)}
        size="medium"
      >
        <div className="template-list">
          {config.executionContext === 'browser' && (
            <div className="template-item">
              <h4>Browser JavaScript Template</h4>
              <p>Standard browser-side script with element manipulation.</p>
              <Button 
                onClick={() => applyTemplate(scriptTemplates.browser.javascript)}
                variant="secondary"
                size="small"
              >
                Use Template
              </Button>
            </div>
          )}
          
          {config.executionContext === 'node' && (
            <div className="template-item">
              <h4>Node.js JavaScript Template</h4>
              <p>Server-side Node.js script for data processing.</p>
              <Button 
                onClick={() => applyTemplate(scriptTemplates.node.javascript)}
                variant="secondary"
                size="small"
              >
                Use Template
              </Button>
            </div>
          )}
          
          {config.executionContext === 'java' && (
            <div className="template-item">
              <h4>Java Executor Template</h4>
              <p>JVM-based Java script for integration with Java frameworks.</p>
              <Button 
                onClick={() => applyTemplate(scriptTemplates.java.executor)}
                variant="secondary"
                size="small"
              >
                Use Template
              </Button>
            </div>
          )}
          
          <div className="template-item">
            <h4>Empty Script</h4>
            <p>Start with a blank script.</p>
            <Button 
              onClick={() => applyTemplate('')}
              variant="secondary"
              size="small"
            >
              Use Empty Template
            </Button>
          </div>
        </div>
      </Modal>
    </div>
  );
};

export default CustomActionConfig;



src/components/recorder/actions/ElementFinderConfig.tsx
-------------------------------------------------------------------
import React, { useState, useEffect, useRef } from 'react';
import { useFramework } from '../../../hooks/useFramework';
import { useRecorder } from '../../../hooks/useRecorder';
import Button from '../../common/Button';
import Input from '../../common/Input';
import Select from '../../common/Select';
import Tooltip from '../../common/Tooltip';
import Modal from '../../common/Modal';
import { ActionType } from '../../../types/recorder';

interface ElementFinderConfigProps {
  actionId?: string;
  isEdit?: boolean;
  onSave: (actionConfig: ElementFinderConfigModel) => void;
  onCancel: () => void;
  initialValues?: ElementFinderConfigModel;
}

export interface ElementFinderConfigModel {
  id: string;
  name: string;
  description: string;
  actionType: ActionType;
  locatorStrategy: LocatorStrategy;
  locatorValue: string;
  frameLocator?: string;
  timeout: number;
  waitForVisible: boolean;
  waitForEnabled: boolean;
  storeElement: boolean;
  variableName?: string;
  framework: string;
  smartLocator: boolean;
  selfHealing: boolean;
  alternativeLocators: AlternativeLocator[];
}

export interface AlternativeLocator {
  id: string;
  strategy: LocatorStrategy;
  value: string;
  priority: number;
}

export enum LocatorStrategy {
  ID = 'id',
  CSS = 'css',
  XPATH = 'xpath',
  NAME = 'name',
  CLASS_NAME = 'className',
  TAG_NAME = 'tagName',
  LINK_TEXT = 'linkText',
  PARTIAL_LINK_TEXT = 'partialLinkText',
  ACCESSIBILITY_ID = 'accessibilityId',
  PLAYWRIGHT_TEXT = 'text',
  PLAYWRIGHT_ROLE = 'role',
  PLAYWRIGHT_TEST_ID = 'testId',
  SMART = 'smart',
}

const defaultConfig: ElementFinderConfigModel = {
  id: '',
  name: 'Find Element',
  description: '',
  actionType: ActionType.FIND_ELEMENT,
  locatorStrategy: LocatorStrategy.ID,
  locatorValue: '',
  timeout: 10000,
  waitForVisible: true,
  waitForEnabled: false,
  storeElement: true,
  variableName: 'element',
  framework: 'selenium',
  smartLocator: false,
  selfHealing: true,
  alternativeLocators: [],
};

const frameworkLocatorStrategies = {
  'selenium-java': [
    LocatorStrategy.ID,
    LocatorStrategy.CSS,
    LocatorStrategy.XPATH,
    LocatorStrategy.NAME,
    LocatorStrategy.CLASS_NAME,
    LocatorStrategy.TAG_NAME,
    LocatorStrategy.LINK_TEXT,
    LocatorStrategy.PARTIAL_LINK_TEXT,
    LocatorStrategy.SMART,
  ],
  'selenium-typescript': [
    LocatorStrategy.ID,
    LocatorStrategy.CSS,
    LocatorStrategy.XPATH,
    LocatorStrategy.NAME,
    LocatorStrategy.CLASS_NAME,
    LocatorStrategy.TAG_NAME,
    LocatorStrategy.LINK_TEXT,
    LocatorStrategy.PARTIAL_LINK_TEXT,
    LocatorStrategy.SMART,
  ],
  'playwright-java': [
    LocatorStrategy.CSS,
    LocatorStrategy.XPATH,
    LocatorStrategy.PLAYWRIGHT_TEXT,
    LocatorStrategy.PLAYWRIGHT_ROLE,
    LocatorStrategy.PLAYWRIGHT_TEST_ID,
    LocatorStrategy.SMART,
  ],
  'playwright-typescript': [
    LocatorStrategy.CSS,
    LocatorStrategy.XPATH,
    LocatorStrategy.PLAYWRIGHT_TEXT,
    LocatorStrategy.PLAYWRIGHT_ROLE,
    LocatorStrategy.PLAYWRIGHT_TEST_ID,
    LocatorStrategy.SMART,
  ],
};

// RegEx patterns for validation
const variableNamePattern = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;

const ElementFinderConfig: React.FC<ElementFinderConfigProps> = ({
  actionId,
  isEdit = false,
  onSave,
  onCancel,
  initialValues,
}) => {
  const { framework } = useFramework();
  const { 
    findElementInBrowser, 
    highlightElement, 
    getSmartLocator,
    testLocator,
    getSelfHealingAlternatives
  } = useRecorder();
  
  const [config, setConfig] = useState<ElementFinderConfigModel>(
    initialValues || { 
      ...defaultConfig, 
      id: actionId || `find_element_${Date.now()}`,
      framework: framework || 'selenium-java',
    }
  );
  
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isTesting, setIsTesting] = useState<boolean>(false);
  const [testResult, setTestResult] = useState<{ success: boolean; message: string } | null>(null);
  const [isGeneratingLocator, setIsGeneratingLocator] = useState<boolean>(false);
  const [isScanning, setIsScanning] = useState<boolean>(false);
  const [showElementPickerModal, setShowElementPickerModal] = useState<boolean>(false);
  const [showAdvancedOptions, setShowAdvancedOptions] = useState<boolean>(false);
  const [smartLocators, setSmartLocators] = useState<{ strategy: LocatorStrategy; value: string }[]>([]);
  
  const elementPickerRef = useRef<HTMLIFrameElement>(null);

  useEffect(() => {
    if (initialValues) {
      setConfig(initialValues);
    }
  }, [initialValues]);

  useEffect(() => {
    // Update available locator strategies when framework changes
    if (config.framework !== framework && framework) {
      const newConfig = { ...config, framework };
      
      // If current locator strategy isn't available in new framework, switch to a default
      const availableStrategies = frameworkLocatorStrategies[framework as keyof typeof frameworkLocatorStrategies] || [];
      if (!availableStrategies.includes(config.locatorStrategy)) {
        newConfig.locatorStrategy = availableStrategies[0];
      }
      
      setConfig(newConfig);
    }
  }, [framework, config]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    
    setConfig(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Clear error when field is changed
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }

    // Clear test results when locator changes
    if (name === 'locatorStrategy' || name === 'locatorValue') {
      setTestResult(null);
    }
  };

  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    
    if (name === 'smartLocator' && checked) {
      // When enabling smart locator, trigger smart locator generation
      handleGenerateSmartLocator();
    }
    
    setConfig(prev => ({
      ...prev,
      [name]: checked
    }));
  };

  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    
    setConfig(prev => ({
      ...prev,
      [name]: parseInt(value, 10)
    }));
  };

  const addAlternativeLocator = () => {
    const newLocator: AlternativeLocator = {
      id: `alt_locator_${Date.now()}`,
      strategy: config.locatorStrategy,
      value: '',
      priority: config.alternativeLocators.length + 1
    };
    
    setConfig(prev => ({
      ...prev,
      alternativeLocators: [...prev.alternativeLocators, newLocator]
    }));
  };

  const updateAlternativeLocator = (
    id: string, 
    field: keyof AlternativeLocator, 
    value: string | number
  ) => {
    setConfig(prev => ({
      ...prev,
      alternativeLocators: prev.alternativeLocators.map(locator => 
        locator.id === id ? { ...locator, [field]: value } : locator
      )
    }));
  };

  const removeAlternativeLocator = (id: string) => {
    setConfig(prev => ({
      ...prev,
      alternativeLocators: prev.alternativeLocators.filter(locator => locator.id !== id)
        // Reorder priorities after removal
        .map((locator, index) => ({
          ...locator,
          priority: index + 1
        }))
    }));
  };

  const handleGenerateSmartLocator = async () => {
    if (!config.locatorValue && config.locatorStrategy !== LocatorStrategy.SMART) {
      setErrors(prev => ({
        ...prev,
        locatorValue: 'Please provide a base locator value to generate smart alternatives'
      }));
      return;
    }
    
    setIsGeneratingLocator(true);
    setSmartLocators([]);
    
    try {
      const result = await getSmartLocator(config.locatorStrategy, config.locatorValue);
      setSmartLocators(result);
      
      // Set the first smart locator as main if not already using SMART strategy
      if (result.length > 0 && config.locatorStrategy !== LocatorStrategy.SMART) {
        setConfig(prev => ({
          ...prev,
          locatorStrategy: LocatorStrategy.SMART,
          locatorValue: result[0].value
        }));
      }
      
      // Add others as alternative locators if self-healing is enabled
      if (result.length > 1 && config.selfHealing) {
        const newAlternatives = result.slice(1).map((loc, index) => ({
          id: `alt_smart_${Date.now()}_${index}`,
          strategy: loc.strategy,
          value: loc.value,
          priority: config.alternativeLocators.length + index + 1
        }));
        
        setConfig(prev => ({
          ...prev,
          alternativeLocators: [...prev.alternativeLocators, ...newAlternatives]
        }));
      }
    } catch (error) {
      setErrors(prev => ({
        ...prev,
        smartLocator: error instanceof Error ? error.message : 'Failed to generate smart locator'
      }));
    } finally {
      setIsGeneratingLocator(false);
    }
  };

  const handleGenerateSelfHealingAlternatives = async () => {
    if (!config.locatorValue) {
      setErrors(prev => ({
        ...prev,
        locatorValue: 'Please provide a locator value first'
      }));
      return;
    }
    
    setIsScanning(true);
    
    try {
      const alternatives = await getSelfHealingAlternatives(
        config.locatorStrategy, 
        config.locatorValue
      );
      
      if (alternatives.length > 0) {
        const newAlternatives = alternatives.map((alt, index) => ({
          id: `alt_heal_${Date.now()}_${index}`,
          strategy: alt.strategy,
          value: alt.value,
          priority: config.alternativeLocators.length + index + 1
        }));
        
        setConfig(prev => ({
          ...prev,
          alternativeLocators: [...prev.alternativeLocators, ...newAlternatives],
          selfHealing: true
        }));
      } else {
        setTestResult({
          success: true,
          message: 'No additional robust alternatives found for this element'
        });
      }
    } catch (error) {
      setErrors(prev => ({
        ...prev,
        selfHealing: error instanceof Error ? error.message : 'Failed to generate alternative locators'
      }));
    } finally {
      setIsScanning(false);
    }
  };

  const handleTestLocator = async () => {
    if (!config.locatorValue) {
      setErrors(prev => ({
        ...prev,
        locatorValue: 'Please provide a locator value'
      }));
      return;
    }
    
    setIsTesting(true);
    setTestResult(null);
    
    try {
      const result = await testLocator(
        config.locatorStrategy, 
        config.locatorValue,
        config.frameLocator,
        config.timeout
      );
      
      setTestResult({
        success: result.found,
        message: result.found 
          ? `Element found! ${result.multiple ? '(Multiple elements matched)' : ''}`
          : result.error || 'Element not found'
      });
      
      if (result.found && !result.multiple) {
        // Highlight the element
        await highlightElement(result.elementId);
      }
    } catch (error) {
      setTestResult({
        success: false,
        message: error instanceof Error ? error.message : 'Error testing locator'
      });
    } finally {
      setIsTesting(false);
    }
  };

  const handleElementPicker = () => {
    setShowElementPickerModal(true);
  };

  const handleElementSelected = async (elementData: { 
    strategy: LocatorStrategy; 
    value: string;
    alternativeLocators?: Array<{ strategy: LocatorStrategy; value: string }>;
  }) => {
    // Update the main locator
    setConfig(prev => ({
      ...prev,
      locatorStrategy: elementData.strategy,
      locatorValue: elementData.value
    }));
    
    // Add alternative locators if available and self-healing is enabled
    if (elementData.alternativeLocators && elementData.alternativeLocators.length > 0 && config.selfHealing) {
      const newAlternatives = elementData.alternativeLocators.map((alt, index) => ({
        id: `alt_picked_${Date.now()}_${index}`,
        strategy: alt.strategy,
        value: alt.value,
        priority: config.alternativeLocators.length + index + 1
      }));
      
      setConfig(prev => ({
        ...prev,
        alternativeLocators: [...prev.alternativeLocators, ...newAlternatives]
      }));
    }
    
    setShowElementPickerModal(false);
    
    // Test the locator automatically
    setTimeout(handleTestLocator, 500);
  };

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    // Validate name
    if (!config.name.trim()) {
      newErrors.name = 'Name is required';
    }
    
    // Validate locator value
    if (!config.locatorValue.trim()) {
      newErrors.locatorValue = 'Locator value is required';
    }
    
    // Validate variable name if storing element
    if (config.storeElement && config.variableName) {
      if (!variableNamePattern.test(config.variableName)) {
        newErrors.variableName = 'Invalid variable name format';
      }
    }
    
    // Validate timeout
    if (config.timeout <= 0) {
      newErrors.timeout = 'Timeout must be greater than 0';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSave = () => {
    if (validateForm()) {
      onSave(config);
    }
  };

  const getLocatorStrategies = () => {
    const strategies = frameworkLocatorStrategies[config.framework as keyof typeof frameworkLocatorStrategies] || [];
    return strategies.map(strategy => ({
      value: strategy,
      label: strategyToLabel(strategy)
    }));
  };

  const strategyToLabel = (strategy: LocatorStrategy): string => {
    switch (strategy) {
      case LocatorStrategy.ID:
        return 'ID';
      case LocatorStrategy.CSS:
        return 'CSS Selector';
      case LocatorStrategy.XPATH:
        return 'XPath';
      case LocatorStrategy.NAME:
        return 'Name';
      case LocatorStrategy.CLASS_NAME:
        return 'Class Name';
      case LocatorStrategy.TAG_NAME:
        return 'Tag Name';
      case LocatorStrategy.LINK_TEXT:
        return 'Link Text';
      case LocatorStrategy.PARTIAL_LINK_TEXT:
        return 'Partial Link Text';
      case LocatorStrategy.ACCESSIBILITY_ID:
        return 'Accessibility ID';
      case LocatorStrategy.PLAYWRIGHT_TEXT:
        return 'Text Content';
      case LocatorStrategy.PLAYWRIGHT_ROLE:
        return 'ARIA Role';
      case LocatorStrategy.PLAYWRIGHT_TEST_ID:
        return 'Test ID';
      case LocatorStrategy.SMART:
        return 'Smart Locator (AI-Generated)';
      default:
        return strategy;
    }
  };

  const isPlaywright = config.framework.startsWith('playwright');

  return (
    <div className="element-finder-config">
      <h2>{isEdit ? 'Edit Element Finder' : 'Create Element Finder'}</h2>
      
      <div className="config-form">
        <div className="form-row">
          <Input
            label="Name"
            name="name"
            value={config.name}
            onChange={handleInputChange}
            error={errors.name}
            required
          />
        </div>
        
        <div className="form-row">
          <Input
            label="Description"
            name="description"
            value={config.description}
            onChange={handleInputChange}
          />
        </div>
        
        <div className="form-section">
          <h3>Locator Configuration</h3>
          
          <div className="form-row locator-row">
            <Select
              label="Locator Strategy"
              name="locatorStrategy"
              value={config.locatorStrategy}
              options={getLocatorStrategies()}
              onChange={handleInputChange}
              error={errors.locatorStrategy}
            />
            
            <Input
              label="Locator Value"
              name="locatorValue"
              value={config.locatorValue}
              onChange={handleInputChange}
              placeholder={getLocatorPlaceholder(config.locatorStrategy)}
              error={errors.locatorValue || errors.smartLocator}
              required
            />
          </div>
          
          <div className="locator-actions">
            <Button
              onClick={handleElementPicker}
              variant="secondary"
              size="small"
            >
              Element Picker
            </Button>
            
            <Button
              onClick={handleTestLocator}
              variant="outline"
              size="small"
              disabled={isTesting || !config.locatorValue}
            >
              {isTesting ? 'Testing...' : 'Test Locator'}
            </Button>
            
            <Button
              onClick={handleGenerateSmartLocator}
              variant="outline"
              size="small"
              disabled={isGeneratingLocator || (!config.locatorValue && config.locatorStrategy !== LocatorStrategy.SMART)}
            >
              {isGeneratingLocator ? 'Generating...' : 'Generate Smart Locator'}
            </Button>
          </div>
          
          {testResult && (
            <div className={`test-result ${testResult.success ? 'success' : 'error'}`}>
              <span className="result-icon">{testResult.success ? '' : ''}</span>
              <span className="result-message">{testResult.message}</span>
            </div>
          )}
          
          {isPlaywright && (
            <div className="form-row">
              <Input
                label="Frame Locator (Optional)"
                name="frameLocator"
                value={config.frameLocator || ''}
                onChange={handleInputChange}
                placeholder="CSS Selector to identify frame (if element is in an iframe)"
                tooltip="Leave empty if element is not inside an iframe"
              />
            </div>
          )}
          
          <div className="form-row">
            <Input
              label="Timeout (ms)"
              name="timeout"
              type="number"
              value={config.timeout.toString()}
              onChange={handleNumberChange}
              min="0"
              error={errors.timeout}
            />
          </div>
          
          <div className="form-row checkboxes">
            <label className="checkbox-container">
              <input
                type="checkbox"
                name="waitForVisible"
                checked={config.waitForVisible}
                onChange={handleCheckboxChange}
              />
              <span>Wait for visibility</span>
              <Tooltip content="Wait until element is visible in the page" />
            </label>
            
            <label className="checkbox-container">
              <input
                type="checkbox"
                name="waitForEnabled"
                checked={config.waitForEnabled}
                onChange={handleCheckboxChange}
              />
              <span>Wait for element to be enabled</span>
              <Tooltip content="Wait until element is enabled for interaction" />
            </label>
          </div>
        </div>
        
        <div className="form-section">
          <h3>Element Storage</h3>
          
          <div className="form-row checkboxes">
            <label className="checkbox-container">
              <input
                type="checkbox"
                name="storeElement"
                checked={config.storeElement}
                onChange={handleCheckboxChange}
              />
              <span>Store element in variable</span>
              <Tooltip content="Store found element in a variable for later use" />
            </label>
          </div>
          
          {config.storeElement && (
            <div className="form-row">
              <Input
                label="Variable Name"
                name="variableName"
                value={config.variableName || ''}
                onChange={handleInputChange}
                placeholder="elementVariable"
                error={errors.variableName}
                required
              />
            </div>
          )}
        </div>
        
        <div className="form-section">
          <div className="advanced-toggle" onClick={() => setShowAdvancedOptions(!showAdvancedOptions)}>
            <span className="toggle-icon">{showAdvancedOptions ? '' : ''}</span>
            <h3>Advanced Options</h3>
          </div>
          
          {showAdvancedOptions && (
            <>
              <div className="form-row checkboxes">
                <label className="checkbox-container">
                  <input
                    type="checkbox"
                    name="selfHealing"
                    checked={config.selfHealing}
                    onChange={handleCheckboxChange}
                  />
                  <span>Enable self-healing locators</span>
                  <Tooltip content="Automatically try alternative locators if primary locator fails" />
                </label>
              </div>
              
              {config.selfHealing && (
                <>
                  <div className="alternative-locators">
                    <div className="section-header">
                      <h4>Alternative Locators</h4>
                      <div className="section-actions">
                        <Button
                          onClick={handleGenerateSelfHealingAlternatives}
                          variant="outline"
                          size="small"
                          disabled={isScanning || !config.locatorValue}
                        >
                          {isScanning ? 'Scanning...' : 'Generate Alternatives'}
                        </Button>
                        
                        <Button
                          onClick={addAlternativeLocator}
                          variant="outline"
                          size="small"
                        >
                          Add Manually
                        </Button>
                      </div>
                    </div>
                    
                    {config.alternativeLocators.length === 0 ? (
                      <div className="no-alternatives">
                        <p>No alternative locators defined. Add alternatives to improve element detection reliability.</p>
                      </div>
                    ) : (
                      <div className="alternatives-list">
                        <div className="alternative-header">
                          <div className="alt-priority">Priority</div>
                          <div className="alt-strategy">Strategy</div>
                          <div className="alt-value">Value</div>
                          <div className="alt-actions">Actions</div>
                        </div>
                        
                        {config.alternativeLocators
                          .sort((a, b) => a.priority - b.priority)
                          .map(locator => (
                            <div key={locator.id} className="alternative-row">
                              <div className="alt-priority">
                                <Input
                                  type="number"
                                  min="1"
                                  value={locator.priority.toString()}
                                  onChange={(e) => updateAlternativeLocator(
                                    locator.id, 
                                    'priority', 
                                    parseInt(e.target.value, 10)
                                  )}
                                />
                              </div>
                              
                              <div className="alt-strategy">
                                <Select
                                  value={locator.strategy}
                                  options={getLocatorStrategies()}
                                  onChange={(e) => updateAlternativeLocator(
                                    locator.id, 
                                    'strategy', 
                                    e.target.value as LocatorStrategy
                                  )}
                                />
                              </div>
                              
                              <div className="alt-value">
                                <Input
                                  value={locator.value}
                                  onChange={(e) => updateAlternativeLocator(
                                    locator.id, 
                                    'value', 
                                    e.target.value
                                  )}
                                  placeholder={getLocatorPlaceholder(locator.strategy as LocatorStrategy)}
                                />
                              </div>
                              
                              <div className="alt-actions">
                                <Button
                                  onClick={() => removeAlternativeLocator(locator.id)}
                                  variant="danger"
                                  size="small"
                                  iconOnly
                                  aria-label="Remove Alternative Locator"
                                >
                                  X
                                </Button>
                              </div>
                            </div>
                          ))}
                      </div>
                    )}
                  </div>
                </>
              )}
            </>
          )}
        </div>
        
        <div className="form-actions">
          <Button onClick={onCancel} variant="outline">
            Cancel
          </Button>
          
          <Button onClick={handleSave} variant="primary">
            {isEdit ? 'Update' : 'Create'} Element Finder
          </Button>
        </div>
      </div>
      
      {/* Element Picker Modal */}
      <Modal
        isOpen={showElementPickerModal}
        title="Element Picker"
        onClose={() => setShowElementPickerModal(false)}
        size="large"
      >
        <div className="element-picker-container">
          <div className="picker-instructions">
            <p>Click on any element in the page to select it. The framework will generate the best locator strategy for the selected element.</p>
          </div>
          
          <div className="browser-frame-container">
            <iframe 
              ref={elementPickerRef}
              src="about:blank"
              className="element-picker-frame"
              title="Element Picker"
            />
          </div>
          
          <div className="picker-actions">
            <Button 
              onClick={() => setShowElementPickerModal(false)}
              variant="outline"
            >
              Cancel
            </Button>
          </div>
        </div>
      </Modal>
    </div>
  );
};

// Helper function to get placeholder text based on locator strategy
function getLocatorPlaceholder(strategy: LocatorStrategy): string {
  switch (strategy) {
    case LocatorStrategy.ID:
      return 'e.g., "loginButton"';
    case LocatorStrategy.CSS:
      return 'e.g., ".login-form input[type=submit]"';
    case LocatorStrategy.XPATH:
      return 'e.g., "//button[@id=\'submit\']"';
    case LocatorStrategy.NAME:
      return 'e.g., "username"';
    case LocatorStrategy.CLASS_NAME:
      return 'e.g., "btn-primary"';
    case LocatorStrategy.TAG_NAME:
      return 'e.g., "button"';
    case LocatorStrategy.LINK_TEXT:
      return 'e.g., "Click here"';
    case LocatorStrategy.PARTIAL_LINK_TEXT:
      return 'e.g., "Click"';
    case LocatorStrategy.ACCESSIBILITY_ID:
      return 'e.g., "login-button"';
    case LocatorStrategy.PLAYWRIGHT_TEXT:
      return 'e.g., "Login to your account"';
    case LocatorStrategy.PLAYWRIGHT_ROLE:
      return 'e.g., "button"';
    case LocatorStrategy.PLAYWRIGHT_TEST_ID:
      return 'e.g., "submit-button"';
    case LocatorStrategy.SMART:
      return 'AI-generated optimal locator';
    default:
      return '';
  }
}

export default ElementFinderConfig;


src/componetns/recorder/actions/AssertionConfig.tsx
-------------------------------------------------------------

import React, { useState, useEffect } from 'react';
import { useFramework } from '../../../hooks/useFramework';
import { useRecorder } from '../../../hooks/useRecorder';
import Button from '../../common/Button';
import Input from '../../common/Input';
import Select from '../../common/Select';
import Tabs from '../../common/Tabs';
import Tooltip from '../../common/Tooltip';
import { ActionType } from '../../../types/recorder';
import { LocatorStrategy } from './ElementFinderConfig';

interface AssertionConfigProps {
  actionId?: string;
  isEdit?: boolean;
  onSave: (actionConfig: AssertionConfigModel) => void;
  onCancel: () => void;
  initialValues?: AssertionConfigModel;
}

export interface AssertionConfigModel {
  id: string;
  name: string;
  description: string;
  actionType: ActionType;
  assertionType: AssertionType;
  // Element assertion fields
  elementLocatorStrategy?: LocatorStrategy;
  elementLocatorValue?: string;
  frameLocator?: string;
  // Page assertion fields
  // Value assertion fields
  assertionTarget?: AssertionTarget;
  assertionProperty?: string;
  assertionMethod: AssertionMethod;
  expectedValue?: string;
  customExpression?: string;
  isCaseSensitive?: boolean;
  isRegexMatch?: boolean;
  variableToAssert?: string;
  timeout: number;
  failOnAssertionError: boolean;
  softAssertion: boolean;
  waitForAssertion: boolean;
  framework: string;
}

export enum AssertionType {
  ELEMENT = 'element',
  PAGE = 'page',
  VARIABLE = 'variable',
  CUSTOM = 'custom',
}

export enum AssertionTarget {
  TEXT = 'text',
  ATTRIBUTE = 'attribute',
  PROPERTY = 'property',
  CSS = 'css',
  VISIBILITY = 'visibility',
  ENABLED = 'enabled',
  PRESENCE = 'presence',
  COUNT = 'count',
  URL = 'url',
  TITLE = 'title',
  URL_CONTAINS = 'urlContains',
  TITLE_CONTAINS = 'titleContains',
  CONSOLE_ERROR = 'consoleError',
  ALERT = 'alert',
  PAGE_SOURCE = 'pageSource',
  NETWORK_REQUEST = 'networkRequest',
  PERFORMANCE = 'performance',
  ACCESSIBILITY = 'accessibility',
  CUSTOM = 'custom',
}

export enum AssertionMethod {
  EQUALS = 'equals',
  NOT_EQUALS = 'notEquals',
  CONTAINS = 'contains',
  NOT_CONTAINS = 'notContains',
  STARTS_WITH = 'startsWith',
  ENDS_WITH = 'endsWith',
  MATCHES_REGEX = 'matchesRegex',
  GREATER_THAN = 'greaterThan',
  LESS_THAN = 'lessThan',
  GREATER_THAN_OR_EQUAL = 'greaterThanOrEqual',
  LESS_THAN_OR_EQUAL = 'lessThanOrEqual',
  IS_EMPTY = 'isEmpty',
  IS_NOT_EMPTY = 'isNotEmpty',
  IS_NULL = 'isNull',
  IS_NOT_NULL = 'isNotNull',
  IS_UNDEFINED = 'isUndefined',
  IS_DEFINED = 'isDefined',
  IS_TRUE = 'isTrue',
  IS_FALSE = 'isFalse',
  IS_VISIBLE = 'isVisible',
  IS_NOT_VISIBLE = 'isNotVisible',
  IS_ENABLED = 'isEnabled',
  IS_DISABLED = 'isDisabled',
  IS_PRESENT = 'isPresent',
  IS_NOT_PRESENT = 'isNotPresent',
  HAS_COUNT = 'hasCount',
  HAS_COUNT_GREATER_THAN = 'hasCountGreaterThan',
  HAS_COUNT_LESS_THAN = 'hasCountLessThan',
  IS_SELECTED = 'isSelected',
  IS_NOT_SELECTED = 'isNotSelected',
  IS_CHECKED = 'isChecked',
  IS_NOT_CHECKED = 'isNotChecked',
  IS_FOCUSED = 'isFocused',
  IS_NOT_FOCUSED = 'isNotFocused',
  CUSTOM = 'custom',
}

const defaultConfig: AssertionConfigModel = {
  id: '',
  name: 'Assertion',
  description: '',
  actionType: ActionType.ASSERTION,
  assertionType: AssertionType.ELEMENT,
  assertionTarget: AssertionTarget.TEXT,
  assertionMethod: AssertionMethod.EQUALS,
  elementLocatorStrategy: LocatorStrategy.ID,
  elementLocatorValue: '',
  expectedValue: '',
  timeout: 10000,
  failOnAssertionError: true,
  softAssertion: false,
  waitForAssertion: true,
  framework: 'selenium-java',
  isCaseSensitive: true,
  isRegexMatch: false,
};

// Helper to get available assertion targets based on assertion type
const getAvailableAssertionTargets = (
  assertionType: AssertionType,
  isPlaywright: boolean
): { value: string; label: string }[] => {
  switch (assertionType) {
    case AssertionType.ELEMENT:
      return [
        { value: AssertionTarget.TEXT, label: 'Text Content' },
        { value: AssertionTarget.ATTRIBUTE, label: 'Attribute Value' },
        { value: AssertionTarget.PROPERTY, label: 'Property Value' },
        { value: AssertionTarget.CSS, label: 'CSS Property' },
        { value: AssertionTarget.VISIBILITY, label: 'Visibility' },
        { value: AssertionTarget.ENABLED, label: 'Enabled State' },
        { value: AssertionTarget.PRESENCE, label: 'Presence in DOM' },
        { value: AssertionTarget.COUNT, label: 'Element Count' },
        ...(isPlaywright ? [{ value: AssertionTarget.ACCESSIBILITY, label: 'Accessibility' }] : []),
      ];
    case AssertionType.PAGE:
      return [
        { value: AssertionTarget.URL, label: 'URL' },
        { value: AssertionTarget.TITLE, label: 'Title' },
        { value: AssertionTarget.URL_CONTAINS, label: 'URL Contains' },
        { value: AssertionTarget.TITLE_CONTAINS, label: 'Title Contains' },
        { value: AssertionTarget.CONSOLE_ERROR, label: 'Console Errors' },
        { value: AssertionTarget.ALERT, label: 'Alert Present' },
        { value: AssertionTarget.PAGE_SOURCE, label: 'Page Source' },
        { value: AssertionTarget.NETWORK_REQUEST, label: 'Network Request' },
        { value: AssertionTarget.PERFORMANCE, label: 'Performance Metric' },
      ];
    case AssertionType.VARIABLE:
      return [{ value: AssertionTarget.CUSTOM, label: 'Variable Value' }];
    case AssertionType.CUSTOM:
      return [{ value: AssertionTarget.CUSTOM, label: 'Custom Expression' }];
    default:
      return [];
  }
};

// Helper to determine if expected value is required
const isExpectedValueRequired = (method: AssertionMethod): boolean => {
  const methodsWithoutValue = [
    AssertionMethod.IS_EMPTY,
    AssertionMethod.IS_NOT_EMPTY,
    AssertionMethod.IS_NULL,
    AssertionMethod.IS_NOT_NULL,
    AssertionMethod.IS_UNDEFINED,
    AssertionMethod.IS_DEFINED,
    AssertionMethod.IS_TRUE,
    AssertionMethod.IS_FALSE,
    AssertionMethod.IS_VISIBLE,
    AssertionMethod.IS_NOT_VISIBLE,
    AssertionMethod.IS_ENABLED,
    AssertionMethod.IS_DISABLED,
    AssertionMethod.IS_PRESENT,
    AssertionMethod.IS_NOT_PRESENT,
    AssertionMethod.IS_SELECTED,
    AssertionMethod.IS_NOT_SELECTED,
    AssertionMethod.IS_CHECKED,
    AssertionMethod.IS_NOT_CHECKED,
    AssertionMethod.IS_FOCUSED,
    AssertionMethod.IS_NOT_FOCUSED,
  ];
  return !methodsWithoutValue.includes(method);
};

// Helper to get available assertion methods based on target
const getAvailableAssertionMethods = (
  assertionTarget: AssertionTarget
): { value: string; label: string }[] => {
  switch (assertionTarget) {
    case AssertionTarget.TEXT:
    case AssertionTarget.ATTRIBUTE:
    case AssertionTarget.PROPERTY:
    case AssertionTarget.CSS:
    case AssertionTarget.URL:
    case AssertionTarget.TITLE:
    case AssertionTarget.PAGE_SOURCE:
      return [
        { value: AssertionMethod.EQUALS, label: 'Equals' },
        { value: AssertionMethod.NOT_EQUALS, label: 'Not Equals' },
        { value: AssertionMethod.CONTAINS, label: 'Contains' },
        { value: AssertionMethod.NOT_CONTAINS, label: 'Not Contains' },
        { value: AssertionMethod.STARTS_WITH, label: 'Starts With' },
        { value: AssertionMethod.ENDS_WITH, label: 'Ends With' },
        { value: AssertionMethod.MATCHES_REGEX, label: 'Matches Regex' },
        { value: AssertionMethod.IS_EMPTY, label: 'Is Empty' },
        { value: AssertionMethod.IS_NOT_EMPTY, label: 'Is Not Empty' },
      ];
    case AssertionTarget.COUNT:
    case AssertionTarget.PERFORMANCE:
      return [
        { value: AssertionMethod.EQUALS, label: 'Equals' },
        { value: AssertionMethod.NOT_EQUALS, label: 'Not Equals' },
        { value: AssertionMethod.GREATER_THAN, label: 'Greater Than' },
        { value: AssertionMethod.LESS_THAN, label: 'Less Than' },
        { value: AssertionMethod.GREATER_THAN_OR_EQUAL, label: 'Greater Than or Equal' },
        { value: AssertionMethod.LESS_THAN_OR_EQUAL, label: 'Less Than or Equal' },
      ];
    case AssertionTarget.VISIBILITY:
      return [
        { value: AssertionMethod.IS_VISIBLE, label: 'Is Visible' },
        { value: AssertionMethod.IS_NOT_VISIBLE, label: 'Is Not Visible' },
      ];
    case AssertionTarget.ENABLED:
      return [
        { value: AssertionMethod.IS_ENABLED, label: 'Is Enabled' },
        { value: AssertionMethod.IS_DISABLED, label: 'Is Disabled' },
      ];
    case AssertionTarget.PRESENCE:
      return [
        { value: AssertionMethod.IS_PRESENT, label: 'Is Present' },
        { value: AssertionMethod.IS_NOT_PRESENT, label: 'Is Not Present' },
      ];
    case AssertionTarget.CONSOLE_ERROR:
      return [
        { value: AssertionMethod.IS_PRESENT, label: 'Has Errors' },
        { value: AssertionMethod.IS_NOT_PRESENT, label: 'No Errors' },
        { value: AssertionMethod.CONTAINS, label: 'Contains Error Message' },
      ];
    case AssertionTarget.ALERT:
      return [
        { value: AssertionMethod.IS_PRESENT, label: 'Is Present' },
        { value: AssertionMethod.IS_NOT_PRESENT, label: 'Is Not Present' },
        { value: AssertionMethod.CONTAINS, label: 'Contains Text' },
      ];
    case AssertionTarget.CUSTOM:
      return [
        { value: AssertionMethod.EQUALS, label: 'Equals' },
        { value: AssertionMethod.NOT_EQUALS, label: 'Not Equals' },
        { value: AssertionMethod.CONTAINS, label: 'Contains' },
        { value: AssertionMethod.NOT_CONTAINS, label: 'Not Contains' },
        { value: AssertionMethod.GREATER_THAN, label: 'Greater Than' },
        { value: AssertionMethod.LESS_THAN, label: 'Less Than' },
        { value: AssertionMethod.IS_TRUE, label: 'Is True' },
        { value: AssertionMethod.IS_FALSE, label: 'Is False' },
        { value: AssertionMethod.IS_NULL, label: 'Is Null' },
        { value: AssertionMethod.IS_NOT_NULL, label: 'Is Not Null' },
        { value: AssertionMethod.IS_DEFINED, label: 'Is Defined' },
        { value: AssertionMethod.IS_UNDEFINED, label: 'Is Undefined' },
        { value: AssertionMethod.CUSTOM, label: 'Custom Validation' },
      ];
    default:
      return [];
  }
};

const AssertionConfig: React.FC<AssertionConfigProps> = ({
  actionId,
  isEdit = false,
  onSave,
  onCancel,
  initialValues,
}) => {
  const { currentFramework } = useFramework();
  const { variables } = useRecorder();
  
  const [config, setConfig] = useState<AssertionConfigModel>(
    initialValues || { ...defaultConfig, id: actionId || `assertion-${Date.now()}`, framework: currentFramework }
  );
  
  const isPlaywright = config.framework.includes('playwright');
  
  // Update when framework changes
  useEffect(() => {
    if (!isEdit) {
      setConfig((prevConfig) => ({
        ...prevConfig,
        framework: currentFramework,
      }));
    }
  }, [currentFramework, isEdit]);
  
  // Handle form field changes
  const handleChange = (field: keyof AssertionConfigModel, value: any) => {
    setConfig((prevConfig) => {
      const newConfig = { ...prevConfig, [field]: value };
      
      // Reset target if assertion type changes
      if (field === 'assertionType') {
        const targets = getAvailableAssertionTargets(value as AssertionType, isPlaywright);
        newConfig.assertionTarget = targets.length > 0 ? targets[0].value as AssertionTarget : undefined;
      }
      
      // Reset method if target changes
      if (field === 'assertionTarget') {
        const methods = getAvailableAssertionMethods(value as AssertionTarget);
        newConfig.assertionMethod = methods.length > 0 ? methods[0].value as AssertionMethod : AssertionMethod.EQUALS;
      }
      
      return newConfig;
    });
  };
  
  // Prepare dropdowns data
  const assertionTypes = [
    { value: AssertionType.ELEMENT, label: 'Element Assertion' },
    { value: AssertionType.PAGE, label: 'Page Assertion' },
    { value: AssertionType.VARIABLE, label: 'Variable Assertion' },
    { value: AssertionType.CUSTOM, label: 'Custom Assertion' },
  ];
  
  const assertionTargets = getAvailableAssertionTargets(config.assertionType, isPlaywright);
  const assertionMethods = config.assertionTarget 
    ? getAvailableAssertionMethods(config.assertionTarget) 
    : [];
  
  const handleSave = () => {
    onSave(config);
  };
  
  return (
    <div className="assertion-config">
      <div className="config-header">
        <h3>{isEdit ? 'Edit Assertion' : 'Add Assertion'}</h3>
        <Tooltip content="Configure assertion for test validation" position="top">
          <span className="info-icon"></span>
        </Tooltip>
      </div>
      
      <div className="config-body">
        <div className="form-group">
          <Input
            label="Assertion Name"
            value={config.name}
            onChange={(e) => handleChange('name', e.target.value)}
            placeholder="Enter assertion name"
          />
        </div>
        
        <div className="form-group">
          <Input
            label="Description"
            value={config.description}
            onChange={(e) => handleChange('description', e.target.value)}
            placeholder="Enter assertion description"
            multiline
          />
        </div>
        
        <div className="form-group">
          <Select
            label="Assertion Type"
            options={assertionTypes}
            value={config.assertionType}
            onChange={(value) => handleChange('assertionType', value)}
          />
        </div>
        
        {config.assertionType && (
          <div className="form-group">
            <Select
              label="Assertion Target"
              options={assertionTargets}
              value={config.assertionTarget}
              onChange={(value) => handleChange('assertionTarget', value)}
            />
          </div>
        )}
        
        {config.assertionType === AssertionType.ELEMENT && (
          <>
            <div className="form-group">
              <Select
                label="Locator Strategy"
                options={[
                  { value: LocatorStrategy.ID, label: 'ID' },
                  { value: LocatorStrategy.CSS, label: 'CSS Selector' },
                  { value: LocatorStrategy.XPATH, label: 'XPath' },
                  { value: LocatorStrategy.NAME, label: 'Name' },
                  { value: LocatorStrategy.CLASS, label: 'Class Name' },
                  { value: LocatorStrategy.TAG, label: 'Tag Name' },
                  { value: LocatorStrategy.LINK_TEXT, label: 'Link Text' },
                  { value: LocatorStrategy.PARTIAL_LINK_TEXT, label: 'Partial Link Text' },
                ]}
                value={config.elementLocatorStrategy}
                onChange={(value) => handleChange('elementLocatorStrategy', value)}
              />
            </div>
            
            <div className="form-group">
              <Input
                label="Locator Value"
                value={config.elementLocatorValue || ''}
                onChange={(e) => handleChange('elementLocatorValue', e.target.value)}
                placeholder="Enter locator value"
              />
            </div>
            
            <div className="form-group">
              <Input
                label="Frame Locator (optional)"
                value={config.frameLocator || ''}
                onChange={(e) => handleChange('frameLocator', e.target.value)}
                placeholder="Enter frame locator if element is in an iframe"
              />
            </div>
          </>
        )}
        
        {config.assertionTarget === AssertionTarget.ATTRIBUTE && (
          <div className="form-group">
            <Input
              label="Attribute Name"
              value={config.assertionProperty || ''}
              onChange={(e) => handleChange('assertionProperty', e.target.value)}
              placeholder="Enter attribute name (e.g., 'class', 'data-id')"
            />
          </div>
        )}
        
        {config.assertionTarget === AssertionTarget.PROPERTY && (
          <div className="form-group">
            <Input
              label="Property Name"
              value={config.assertionProperty || ''}
              onChange={(e) => handleChange('assertionProperty', e.target.value)}
              placeholder="Enter property name (e.g., 'value', 'checked')"
            />
          </div>
        )}
        
        {config.assertionTarget === AssertionTarget.CSS && (
          <div className="form-group">
            <Input
              label="CSS Property"
              value={config.assertionProperty || ''}
              onChange={(e) => handleChange('assertionProperty', e.target.value)}
              placeholder="Enter CSS property (e.g., 'color', 'display')"
            />
          </div>
        )}
        
        {config.assertionType === AssertionType.VARIABLE && (
          <div className="form-group">
            <Select
              label="Variable"
              options={variables.map(v => ({ value: v.name, label: v.name }))}
              value={config.variableToAssert || ''}
              onChange={(value) => handleChange('variableToAssert', value)}
              placeholder="Select variable to assert"
            />
          </div>
        )}
        
        {config.assertionTarget && (
          <div className="form-group">
            <Select
              label="Assertion Method"
              options={assertionMethods}
              value={config.assertionMethod}
              onChange={(value) => handleChange('assertionMethod', value)}
            />
          </div>
        )}
        
        {config.assertionMethod === AssertionMethod.CUSTOM && (
          <div className="form-group">
            <Input
              label="Custom Expression"
              value={config.customExpression || ''}
              onChange={(e) => handleChange('customExpression', e.target.value)}
              placeholder="Enter custom validation expression"
              multiline
            />
          </div>
        )}
        
        {isExpectedValueRequired(config.assertionMethod) && (
          <div className="form-group">
            <Input
              label="Expected Value"
              value={config.expectedValue || ''}
              onChange={(e) => handleChange('expectedValue', e.target.value)}
              placeholder="Enter expected value"
            />
          </div>
        )}
        
        <div className="form-group">
          <Input
            label="Timeout (ms)"
            type="number"
            value={config.timeout.toString()}
            onChange={(e) => handleChange('timeout', parseInt(e.target.value, 10))}
            placeholder="Enter timeout in milliseconds"
          />
        </div>
        
        <div className="form-group options">
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={config.isCaseSensitive}
              onChange={(e) => handleChange('isCaseSensitive', e.target.checked)}
            />
            Case Sensitive
          </label>
          
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={config.isRegexMatch}
              onChange={(e) => handleChange('isRegexMatch', e.target.checked)}
            />
            Use Regex
          </label>
          
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={config.failOnAssertionError}
              onChange={(e) => handleChange('failOnAssertionError', e.target.checked)}
            />
            Fail on Assertion Error
          </label>
          
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={config.softAssertion}
              onChange={(e) => handleChange('softAssertion', e.target.checked)}
            />
            Soft Assertion
          </label>
          
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={config.waitForAssertion}
              onChange={(e) => handleChange('waitForAssertion', e.target.checked)}
            />
            Wait for Assertion
          </label>
        </div>
      </div>
      
      <div className="config-footer">
        <Button variant="secondary" onClick={onCancel}>
          Cancel
        </Button>
        <Button variant="primary" onClick={handleSave}>
          {isEdit ? 'Update' : 'Add'} Assertion
        </Button>
      </div>
    </div>
  );
};

export default AssertionConfig;



src/components/recorder/actions/DocumentationConfig.tsx
----------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { useRecorder } from '../../../hooks/useRecorder';
import Button from '../../common/Button';
import Input from '../../common/Input';
import Select from '../../common/Select';
import Tooltip from '../../common/Tooltip';
import { ActionType } from '../../../types/recorder';

interface DocumentationConfigProps {
  actionId?: string;
  isEdit?: boolean;
  onSave: (actionConfig: DocumentationConfigModel) => void;
  onCancel: () => void;
  initialValues?: DocumentationConfigModel;
}

export interface DocumentationConfigModel {
  id: string;
  name: string;
  actionType: ActionType;
  documentationType: DocumentationType;
  content: string;
  tags: string[];
  level: DocumentationLevel;
  includeInReports: boolean;
  includeScreenshot: boolean;
  attachments: DocumentationAttachment[];
}

export interface DocumentationAttachment {
  id: string;
  name: string;
  type: 'image' | 'link' | 'file';
  content: string;
}

export enum DocumentationType {
  HEADER = 'header',
  SECTION = 'section',
  COMMENT = 'comment',
  NOTE = 'note',
  WARNING = 'warning',
  TODO = 'todo',
  BUG = 'bug',
  REQUIREMENT = 'requirement',
  EXPECTED_RESULT = 'expectedResult',
  ACTUAL_RESULT = 'actualResult',
  STEP = 'step',
}

export enum DocumentationLevel {
  INFO = 'info',
  DEBUG = 'debug',
  WARN = 'warn',
  ERROR = 'error',
  CRITICAL = 'critical',
}

const defaultConfig: DocumentationConfigModel = {
  id: '',
  name: 'Documentation',
  actionType: ActionType.DOCUMENTATION,
  documentationType: DocumentationType.COMMENT,
  content: '',
  tags: [],
  level: DocumentationLevel.INFO,
  includeInReports: true,
  includeScreenshot: false,
  attachments: [],
};

const documentationTypeOptions = [
  { value: DocumentationType.HEADER, label: 'Header' },
  { value: DocumentationType.SECTION, label: 'Section' },
  { value: DocumentationType.COMMENT, label: 'Comment' },
  { value: DocumentationType.NOTE, label: 'Note' },
  { value: DocumentationType.WARNING, label: 'Warning' },
  { value: DocumentationType.TODO, label: 'To-Do' },
  { value: DocumentationType.BUG, label: 'Bug Report' },
  { value: DocumentationType.REQUIREMENT, label: 'Requirement' },
  { value: DocumentationType.EXPECTED_RESULT, label: 'Expected Result' },
  { value: DocumentationType.ACTUAL_RESULT, label: 'Actual Result' },
  { value: DocumentationType.STEP, label: 'Test Step Description' },
];

const documentationLevelOptions = [
  { value: DocumentationLevel.INFO, label: 'Info' },
  { value: DocumentationLevel.DEBUG, label: 'Debug' },
  { value: DocumentationLevel.WARN, label: 'Warning' },
  { value: DocumentationLevel.ERROR, label: 'Error' },
  { value: DocumentationLevel.CRITICAL, label: 'Critical' },
];

const DocumentationConfig: React.FC<DocumentationConfigProps> = ({
  actionId,
  isEdit = false,
  onSave,
  onCancel,
  initialValues,
}) => {
  const { captureScreenshot } = useRecorder();
  
  const [config, setConfig] = useState<DocumentationConfigModel>(
    initialValues || { 
      ...defaultConfig, 
      id: actionId || `doc_${Date.now()}`,
    }
  );
  
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [newTag, setNewTag] = useState<string>('');
  const [isCapturingScreenshot, setIsCapturingScreenshot] = useState<boolean>(false);
  
  useEffect(() => {
    if (initialValues) {
      setConfig(initialValues);
    }
  }, [initialValues]);
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    
    setConfig(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Clear error when field is changed
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };
  
  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    
    setConfig(prev => ({
      ...prev,
      [name]: checked
    }));
  };
  
  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setConfig(prev => ({
      ...prev,
      content: e.target.value
    }));
    
    // Clear error when content is changed
    if (errors.content) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors.content;
        return newErrors;
      });
    }
  };
  
  const handleTagInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setNewTag(e.target.value);
  };
  
  const addTag = () => {
    if (newTag.trim() && !config.tags.includes(newTag.trim())) {
      setConfig(prev => ({
        ...prev,
        tags: [...prev.tags, newTag.trim()]
      }));
      setNewTag('');
    }
  };
  
  const handleTagKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      addTag();
    }
  };
  
  const removeTag = (tag: string) => {
    setConfig(prev => ({
      ...prev,
      tags: prev.tags.filter(t => t !== tag)
    }));
  };
  
  const addAttachment = () => {
    const newAttachment: DocumentationAttachment = {
      id: `attachment_${Date.now()}`,
      name: `Attachment ${config.attachments.length + 1}`,
      type: 'link',
      content: ''
    };
    
    setConfig(prev => ({
      ...prev,
      attachments: [...prev.attachments, newAttachment]
    }));
  };
  
  const updateAttachment = (
    id: string, 
    field: keyof DocumentationAttachment, 
    value: string
  ) => {
    setConfig(prev => ({
      ...prev,
      attachments: prev.attachments.map(attachment => 
        attachment.id === id ? { ...attachment, [field]: value } : attachment
      )
    }));
  };
  
  const removeAttachment = (id: string) => {
    setConfig(prev => ({
      ...prev,
      attachments: prev.attachments.filter(attachment => attachment.id !== id)
    }));
  };
  
  const handleCaptureScreenshot = async () => {
    setIsCapturingScreenshot(true);
    
    try {
      const screenshotBase64 = await captureScreenshot();
      
      const newAttachment: DocumentationAttachment = {
        id: `screenshot_${Date.now()}`,
        name: `Screenshot ${new Date().toLocaleTimeString()}`,
        type: 'image',
        content: screenshotBase64
      };
      
      setConfig(prev => ({
        ...prev,
        attachments: [...prev.attachments, newAttachment],
        includeScreenshot: true
      }));
    } catch (error) {
      setErrors(prev => ({
        ...prev,
        screenshot: error instanceof Error ? error.message : 'Failed to capture screenshot'
      }));
    } finally {
      setIsCapturingScreenshot(false);
    }
  };
  
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    // Validate name
    if (!config.name.trim()) {
      newErrors.name = 'Name is required';
    }
    
    // Validate content for certain documentation types
    if (config.documentationType !== DocumentationType.HEADER &&
        config.documentationType !== DocumentationType.SECTION &&
        !config.content.trim()) {
      newErrors.content = 'Content is required';
    }
    
    // Validate attachments
    config.attachments.forEach((attachment, index) => {
      if (!attachment.name.trim()) {
        newErrors[`attachment_${attachment.id}_name`] = 'Attachment name is required';
      }
      
      if (!attachment.content.trim()) {
        newErrors[`attachment_${attachment.id}_content`] = 'Attachment content is required';
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSave = () => {
    if (validateForm()) {
      onSave(config);
    }
  };
  
  return (
    <div className="documentation-config">
      <h2>{isEdit ? 'Edit Documentation' : 'Create Documentation'}</h2>
      
      <div className="config-form">
        <div className="form-row">
          <Input
            label="Name"
            name="name"
            value={config.name}
            onChange={handleInputChange}
            error={errors.name}
            required
          />
        </div>
        
        <div className="form-row">
          <Select
            label="Documentation Type"
            name="documentationType"
            value={config.documentationType}
            options={documentationTypeOptions}
            onChange={handleInputChange}
          />
          
          <Select
            label="Level"
            name="level"
            value={config.level}
            options={documentationLevelOptions}
            onChange={handleInputChange}
          />
        </div>
        
        <div className="form-row full-width">
          <label>
            Content
            {(config.documentationType !== DocumentationType.HEADER && 
              config.documentationType !== DocumentationType.SECTION) && (
              <span className="required-indicator">*</span>
            )}
          </label>
          <textarea
            name="content"
            value={config.content}
            onChange={handleContentChange}
            rows={5}
            placeholder={getContentPlaceholder(config.documentationType)}
            className={errors.content ? 'error' : ''}
          />
          {errors.content && <div className="error-message">{errors.content}</div>}
        </div>
        
        <div className="form-section">
          <h3>Tags</h3>
          
          <div className="tags-input-container">
            <Input
              placeholder="Add tag and press Enter"
              value={newTag}
              onChange={handleTagInputChange}
              onKeyDown={handleTagKeyDown}
            />
            
            <Button
              onClick={addTag}
              variant="outline"
              size="small"
              disabled={!newTag.trim()}
            >
              Add Tag
            </Button>
          </div>
          
          <div className="tags-list">
            {config.tags.length === 0 ? (
              <div className="no-tags">
                <p>No tags added yet. Tags help organize and filter documentation.</p>
              </div>
            ) : (
              <div className="tags-container">
                {config.tags.map(tag => (
                  <div key={tag} className="tag">
                    <span className="tag-text">{tag}</span>
                    <button
                      type="button"
                      className="remove-tag"
                      onClick={() => removeTag(tag)}
                      aria-label={`Remove tag ${tag}`}
                    >
                      
                    </button>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
        
        <div className="form-section">
          <h3>Attachments</h3>
          
          <div className="attachments-actions">
            <Button
              onClick={addAttachment}
              variant="outline"
              size="small"
            >
              Add Attachment
            </Button>
            
            <Button
              onClick={handleCaptureScreenshot}
              variant="outline"
              size="small"
              disabled={isCapturingScreenshot}
            >
              {isCapturingScreenshot ? 'Capturing...' : 'Capture Screenshot'}
            </Button>
          </div>
          
          {errors.screenshot && <div className="error-message">{errors.screenshot}</div>}
          
          <div className="attachments-list">
            {config.attachments.length === 0 ? (
              <div className="no-attachments">
                <p>No attachments added yet. Attachments can be links, images, or file references.</p>
              </div>
            ) : (
              <div className="attachments-container">
                {config.attachments.map(attachment => (
                  <div key={attachment.id} className="attachment-item">
                    <div className="attachment-row">
                      <Input
                        label="Name"
                        value={attachment.name}
                        onChange={(e) => updateAttachment(attachment.id, 'name', e.target.value)}
                        error={errors[`attachment_${attachment.id}_name`]}
                      />
                      
                      <Select
                        label="Type"
                        value={attachment.type}
                        options={[
                          { value: 'link', label: 'Link' },
                          { value: 'image', label: 'Image' },
                          { value: 'file', label: 'File' }
                        ]}
                        onChange={(e) => updateAttachment(attachment.id, 'type', e.target.value)}
                      />
                      
                      <div className="attachment-actions">
                        <Button
                          onClick={() => removeAttachment(attachment.id)}
                          variant="danger"
                          size="small"
                          iconOnly
                          aria-label="Remove Attachment"
                        >
                          X
                        </Button>
                      </div>
                    </div>
                    
                    <div className="attachment-content">
                      {attachment.type === 'image' ? (
                        <>
                          <label>Image</label>
                          {attachment.content ? (
                            <div className="image-preview-container">
                              <img
                                src={attachment.content.startsWith('data:') ? attachment.content : `data:image/png;base64,${attachment.content}`}
                                alt={attachment.name}
                                className="image-preview"
                              />
                            </div>
                          ) : (
                            <Input
                              placeholder="Paste base64 image data or image URL"
                              value={attachment.content}
                              onChange={(e) => updateAttachment(attachment.id, 'content', e.target.value)}
                              error={errors[`attachment_${attachment.id}_content`]}
                            />
                          )}
                        </>
                      ) : (
                        <Input
                          label={attachment.type === 'link' ? 'URL' : 'File Path'}
                          value={attachment.content}
                          onChange={(e) => updateAttachment(attachment.id, 'content', e.target.value)}
                          placeholder={attachment.type === 'link' ? 'https://example.com' : '/path/to/file.txt'}
                          error={errors[`attachment_${attachment.id}_content`]}
                        />
                      )}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
        
        <div className="form-section">
          <h3>Report Options</h3>
          
          <div className="form-row checkboxes">
            <label className="checkbox-container">
              <input
                type="checkbox"
                name="includeInReports"
                checked={config.includeInReports}
                onChange={handleCheckboxChange}
              />
              <span>Include in reports</span>
              <Tooltip content="Include this documentation in generated test reports" />
            </label>
            
            <label className="checkbox-container">
              <input
                type="checkbox"
                name="includeScreenshot"
                checked={config.includeScreenshot}
                onChange={handleCheckboxChange}
              />
              <span>Include screenshot in reports</span>
              <Tooltip content="Automatically capture and include a screenshot with this documentation in reports" />
            </label>
          </div>
        </div>
        
        <div className="form-actions">
          <Button onClick={onCancel} variant="outline">
            Cancel
          </Button>
          
          <Button onClick={handleSave} variant="primary">
            {isEdit ? 'Update' : 'Create'} Documentation
          </Button>
        </div>
      </div>
    </div>
  );
};

// Helper function to get content placeholder based on documentation type
function getContentPlaceholder(type: DocumentationType): string {
  switch (type) {
    case DocumentationType.HEADER:
      return 'Test suite or major section header text';
    case DocumentationType.SECTION:
      return 'Section header text';
    case DocumentationType.COMMENT:
      return 'Add explanatory comment about the test...';
    case DocumentationType.NOTE:
      return 'Add note for test execution or maintenance...';
    case DocumentationType.WARNING:
      return 'Add warning about potential issues or prerequisites...';
    case DocumentationType.TODO:
      return 'Add to-do item for future test improvements...';
    case DocumentationType.BUG:
      return 'Describe bug found during test execution...';
    case DocumentationType.REQUIREMENT:
      return 'Document requirement being tested...';
    case DocumentationType.EXPECTED_RESULT:
      return 'Document expected result of test or step...';
    case DocumentationType.ACTUAL_RESULT:
      return 'Document actual result observed...';
    case DocumentationType.STEP:
      return 'Describe this test step in detail...';
    default:
      return 'Add documentation content...';
  }
}

export default DocumentationConfig;


src/components/results/ResultsViewer.tsx
----------------------------------------------------------

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { useResults } from '../../hooks/useResults';
import { useFramework } from '../../hooks/useFramework';
import Button from '../common/Button';
import Select from '../common/Select';
import Input from '../common/Input';
import Tabs from '../common/Tabs';
import Card from '../common/Card';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';
import TestResultDetails from './TestResultDetails';
import MetricsDisplay from './MetricsDisplay';
import { CSTestResult, CSTestStatus } from '../../types/reporting';

interface ResultsViewerProps {
  projectId?: string;
  testRunId?: string;
  onSelectResult?: (resultId: string) => void;
}

const ResultsViewer: React.FC<ResultsViewerProps> = ({
  projectId,
  testRunId,
  onSelectResult,
}) => {
  const { 
    fetchTestRuns, 
    fetchTestResults, 
    fetchTestSuites, 
    fetchProjectMetrics,
    getLatestTestRunForProject
  } = useResults();
  const { framework } = useFramework();
  
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [testRuns, setTestRuns] = useState<Array<{ id: string; name: string; date: Date }>>([]);
  const [testResults, setTestResults] = useState<CSTestResult[]>([]);
  const [testSuites, setTestSuites] = useState<Array<{ id: string; name: string }>>([]);
  const [metrics, setMetrics] = useState<any>(null);
  
  const [selectedRunId, setSelectedRunId] = useState<string | undefined>(testRunId);
  const [selectedSuiteId, setSelectedSuiteId] = useState<string | undefined>(undefined);
  const [selectedResultId, setSelectedResultId] = useState<string | undefined>(undefined);
  const [selectedResult, setSelectedResult] = useState<CSTestResult | null>(null);
  
  const [activeView, setActiveView] = useState<'summary' | 'details' | 'metrics'>('summary');
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [statusFilter, setStatusFilter] = useState<CSTestStatus | 'ALL'>('ALL');
  const [sortBy, setSortBy] = useState<'name' | 'status' | 'duration' | 'date'>('date');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
  const [showOnlyFailures, setShowOnlyFailures] = useState<boolean>(false);
  
  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Fetch test runs for project
      let runId = selectedRunId;
      
      if (projectId) {
        const runs = await fetchTestRuns(projectId);
        setTestRuns(runs);
        
        // If no specific run ID is provided, get the latest run
        if (!runId && runs.length > 0) {
          const latestRun = await getLatestTestRunForProject(projectId);
          runId = latestRun.id;
          setSelectedRunId(runId);
        }
      }
      
      // Fetch test suites for the selected run
      if (runId) {
        const suites = await fetchTestSuites(runId);
        setTestSuites(suites);
        
        // Fetch test results for the selected run
        const results = await fetchTestResults(runId, selectedSuiteId);
        setTestResults(results);
        
        // Fetch metrics for the selected run
        const runMetrics = await fetchProjectMetrics(runId);
        setMetrics(runMetrics);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Error fetching test results');
      console.error('Error fetching test results:', err);
    } finally {
      setLoading(false);
    }
  }, [projectId, selectedRunId, selectedSuiteId, fetchTestRuns, fetchTestResults, fetchTestSuites, fetchProjectMetrics, getLatestTestRunForProject]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  useEffect(() => {
    // When a specific test run ID is provided externally
    if (testRunId && testRunId !== selectedRunId) {
      setSelectedRunId(testRunId);
    }
  }, [testRunId, selectedRunId]);
  
  useEffect(() => {
    // Find and set the selected result object
    if (selectedResultId) {
      const result = testResults.find(res => res.id === selectedResultId);
      setSelectedResult(result || null);
      
      if (result && onSelectResult) {
        onSelectResult(selectedResultId);
      }
    } else {
      setSelectedResult(null);
    }
  }, [selectedResultId, testResults, onSelectResult]);
  
  // Apply filters and sorting to test results
  const filteredResults = useMemo(() => {
    return testResults.filter(result => {
      // Apply status filter
      if (statusFilter !== 'ALL' && result.status !== statusFilter) {
        return false;
      }
      
      // Apply failures filter
      if (showOnlyFailures && result.status !== CSTestStatus.FAILED) {
        return false;
      }
      
      // Apply search term
      if (searchTerm.trim()) {
        const searchLower = searchTerm.toLowerCase();
        return (
          result.name.toLowerCase().includes(searchLower) ||
          result.testClass?.toLowerCase().includes(searchLower) ||
          result.description?.toLowerCase().includes(searchLower) ||
          result.tags?.some(tag => tag.toLowerCase().includes(searchLower))
        );
      }
      
      return true;
    }).sort((a, b) => {
      // Apply sorting
      let comparison = 0;
      
      switch (sortBy) {
        case 'name':
          comparison = a.name.localeCompare(b.name);
          break;
        case 'status':
          comparison = a.status.localeCompare(b.status);
          break;
        case 'duration':
          comparison = (a.duration || 0) - (b.duration || 0);
          break;
        case 'date':
          comparison = new Date(a.endTime || 0).getTime() - new Date(b.endTime || 0).getTime();
          break;
      }
      
      return sortDirection === 'asc' ? comparison : -comparison;
    });
  }, [testResults, statusFilter, showOnlyFailures, searchTerm, sortBy, sortDirection]);
  
  const handleRunChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const runId = e.target.value;
    setSelectedRunId(runId);
    setSelectedSuiteId(undefined);
    setSelectedResultId(undefined);
    setSelectedResult(null);
  };
  
  const handleSuiteChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const suiteId = e.target.value === 'all' ? undefined : e.target.value;
    setSelectedSuiteId(suiteId);
    setSelectedResultId(undefined);
    setSelectedResult(null);
  };
  
  const handleResultClick = (resultId: string) => {
    setSelectedResultId(resultId);
    setActiveView('details');
  };
  
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value);
  };
  
  const handleStatusFilterChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setStatusFilter(e.target.value as CSTestStatus | 'ALL');
  };
  
  const handleSortChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSortBy(e.target.value as 'name' | 'status' | 'duration' | 'date');
  };
  
  const toggleSortDirection = () => {
    setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
  };
  
  const toggleShowOnlyFailures = () => {
    setShowOnlyFailures(prev => !prev);
  };
  
  const handleRefresh = () => {
    fetchData();
  };
  
  const handleBackToList = () => {
    setSelectedResultId(undefined);
    setSelectedResult(null);
    setActiveView('summary');
  };
  
  const getStatusColor = (status: CSTestStatus): string => {
    switch (status) {
      case CSTestStatus.PASSED:
        return 'success';
      case CSTestStatus.FAILED:
        return 'danger';
      case CSTestStatus.SKIPPED:
        return 'warning';
      case CSTestStatus.RUNNING:
        return 'info';
      default:
        return 'default';
    }
  };
  
  const getStatusIcon = (status: CSTestStatus): string => {
    switch (status) {
      case CSTestStatus.PASSED:
        return '';
      case CSTestStatus.FAILED:
        return '';
      case CSTestStatus.SKIPPED:
        return '';
      case CSTestStatus.RUNNING:
        return '';
      default:
        return '?';
    }
  };
  
  const formatDuration = (durationMs?: number): string => {
    if (!durationMs) return '--';
    
    const seconds = Math.floor(durationMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  };
  
  const getSummaryStats = () => {
    if (!testResults.length) return { total: 0, passed: 0, failed: 0, skipped: 0, running: 0 };
    
    return testResults.reduce((stats, result) => {
      stats.total++;
      
      switch (result.status) {
        case CSTestStatus.PASSED:
          stats.passed++;
          break;
        case CSTestStatus.FAILED:
          stats.failed++;
          break;
        case CSTestStatus.SKIPPED:
          stats.skipped++;
          break;
        case CSTestStatus.RUNNING:
          stats.running++;
          break;
      }
      
      return stats;
    }, { total: 0, passed: 0, failed: 0, skipped: 0, running: 0 });
  };
  
  const summaryStats = getSummaryStats();
  
  // Render different views based on state
  const renderContent = () => {
    if (loading) {
      return (
        <div className="loading-container">
          <Spinner size="large" />
          <p>Loading test results...</p>
        </div>
      );
    }
    
    if (error) {
      return (
        <Alert type="error" title="Error Loading Results" onClose={() => setError(null)}>
          {error}
        </Alert>
      );
    }
    
    if (selectedResult && activeView === 'details') {
      return (
        <div className="result-details-container">
          <Button onClick={handleBackToList} variant="outline" size="small">
             Back to Results
          </Button>
          <TestResultDetails result={selectedResult} />
        </div>
      );
    }
    
    if (activeView === 'metrics') {
      return (
        <div className="metrics-container">
          <MetricsDisplay metrics={metrics} testRunId={selectedRunId} />
        </div>
      );
    }
    
    return (
      <div className="results-summary-container">
        {/* Run selection and filtering options */}
        <div className="results-controls">
          <div className="run-selection">
            <Select
              label="Test Run"
              value={selectedRunId || ''}
              onChange={handleRunChange}
              options={[
                ...testRuns.map(run => ({
                  value: run.id,
                  label: `${run.name} (${new Date(run.date).toLocaleString()})`
                }))
              ]}
              disabled={testRuns.length === 0}
            />
            
            <Select
              label="Test Suite"
              value={selectedSuiteId || 'all'}
              onChange={handleSuiteChange}
              options={[
                { value: 'all', label: 'All Suites' },
                ...testSuites.map(suite => ({
                  value: suite.id,
                  label: suite.name
                }))
              ]}
              disabled={testSuites.length === 0}
            />
            
            <Button onClick={handleRefresh} variant="outline" size="small">
              Refresh
            </Button>
          </div>
          
          <div className="filters">
            <Input
              label="Search"
              placeholder="Search by name, class, or tag"
              value={searchTerm}
              onChange={handleSearchChange}
            />
            
            <Select
              label="Status"
              value={statusFilter}
              onChange={handleStatusFilterChange}
              options={[
                { value: 'ALL', label: 'All Statuses' },
                { value: CSTestStatus.PASSED, label: 'Passed' },
                { value: CSTestStatus.FAILED, label: 'Failed' },
                { value: CSTestStatus.SKIPPED, label: 'Skipped' },
                { value: CSTestStatus.RUNNING, label: 'Running' }
              ]}
            />
            
            <div className="checkbox-container">
              <label>
                <input
                  type="checkbox"
                  checked={showOnlyFailures}
                  onChange={toggleShowOnlyFailures}
                />
                Show Only Failures
              </label>
            </div>
          </div>
          
          <div className="sorting">
            <Select
              label="Sort By"
              value={sortBy}
              onChange={handleSortChange}
              options={[
                { value: 'date', label: 'Execution Date' },
                { value: 'name', label: 'Test Name' },
                { value: 'status', label: 'Status' },
                { value: 'duration', label: 'Duration' }
              ]}
            />
            
            <Button onClick={toggleSortDirection} variant="outline" size="small">
              {sortDirection === 'asc' ? ' Ascending' : ' Descending'}
            </Button>
          </div>
        </div>
        
        {/* Test Results summary */}
        <div className="summary-stats">
          <div className="stat-item total">
            <span className="stat-value">{summaryStats.total}</span>
            <span className="stat-label">Total</span>
          </div>
          <div className="stat-item passed">
            <span className="stat-value">{summaryStats.passed}</span>
            <span className="stat-label">Passed</span>
          </div>
          <div className="stat-item failed">
            <span className="stat-value">{summaryStats.failed}</span>
            <span className="stat-label">Failed</span>
          </div>
          <div className="stat-item skipped">
            <span className="stat-value">{summaryStats.skipped}</span>
            <span className="stat-label">Skipped</span>
          </div>
          {summaryStats.running > 0 && (
            <div className="stat-item running">
              <span className="stat-value">{summaryStats.running}</span>
              <span className="stat-label">Running</span>
            </div>
          )}
        </div>
        
        {/* Results list */}
        <div className="results-list">
          {filteredResults.length === 0 ? (
            <div className="no-results">
              <p>No test results found matching the current filters.</p>
            </div>
          ) : (
            <>
              <div className="results-header">
                <div className="result-status">Status</div>
                <div className="result-name">Test Name</div>
                <div className="result-class">Test Class</div>
                <div className="result-duration">Duration</div>
                <div className="result-date">Date</div>
              </div>
              {filteredResults.map(result => (
                <div
                  key={result.id}
                  className={`result-item ${result.status.toLowerCase()}`}
                  onClick={() => handleResultClick(result.id)}
                >
                  <div className="result-status">
                    <span className={`status-indicator ${getStatusColor(result.status)}`}>
                      {getStatusIcon(result.status)}
                    </span>
                  </div>
                  <div className="result-name">{result.name}</div>
                  <div className="result-class">{result.testClass || '--'}</div>
                  <div className="result-duration">{formatDuration(result.duration)}</div>
                  <div className="result-date">
                    {result.endTime ? new Date(result.endTime).toLocaleString() : '--'}
                  </div>
                </div>
              ))}
            </>
          )}
        </div>
        
        {/* Pagination */}
        {/* Pagination would be added here if the results are paginated */}
      </div>
    );
  };
  
  return (
    <div className="results-viewer">
      <div className="results-header">
        <h1>Test Results</h1>
        <div className="view-tabs">
          <Tabs
            tabs={[
              { id: 'summary', label: 'Summary' },
              { id: 'metrics', label: 'Metrics' }
            ]}
            activeTab={activeView}
            onChange={(tabId) => {
              if (tabId === 'summary' && activeView === 'details') {
                // Keep details view if we're showing a specific result
                return;
              }
              setActiveView(tabId as 'summary' | 'details' | 'metrics');
            }}
          />
        </div>
      </div>
      
      <div className="results-content">
        {renderContent()}
      </div>
    </div>
  );
};

export default ResultsViewer;



src/componetns/results/TestResultDetails.tsx
--------------------------------------------------------

import React, { useState, useEffect } from 'react';
import { useResults } from '../../hooks/useResults';
import Button from '../common/Button';
import Card from '../common/Card';
import Tabs from '../common/Tabs';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';
import TestStepDetails from './TestStepDetails';
import ScreenshotViewer from './ScreenshotViewer';
import VideoPlayer from './VideoPlayer';
import { CSTestResult, CSTestStep, CSTestStatus, CSScreenshot } from '../../types/reporting';

interface TestResultDetailsProps {
  result: CSTestResult;
  onBack?: () => void;
}

const TestResultDetails: React.FC<TestResultDetailsProps> = ({
  result,
  onBack
}) => {
  const { fetchTestSteps, fetchTestStepDetails, fetchTestLogs, fetchTestStepScreenshots } = useResults();
  
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [steps, setSteps] = useState<CSTestStep[]>([]);
  const [logs, setLogs] = useState<string[]>([]);
  const [screenshots, setScreenshots] = useState<CSScreenshot[]>([]);
  const [testVideo, setTestVideo] = useState<string | null>(null);
  
  const [activeTab, setActiveTab] = useState<'steps' | 'logs' | 'screenshots' | 'video'>('steps');
  const [selectedStepId, setSelectedStepId] = useState<string | null>(null);
  const [selectedScreenshotId, setSelectedScreenshotId] = useState<string | null>(null);
  const [viewingStepDetails, setViewingStepDetails] = useState<boolean>(false);
  const [selectedStep, setSelectedStep] = useState<CSTestStep | null>(null);
  
  useEffect(() => {
    const fetchDetails = async () => {
      setLoading(true);
      setError(null);
      try {
        // Fetch all necessary data
        const [fetchedSteps, fetchedLogs, fetchedScreenshots, fetchedVideo] = await Promise.all([
          fetchTestSteps(result.id),
          fetchTestLogs(result.id),
          fetchTestStepScreenshots(result.id),
          result.hasVideo ? fetchTestVideo(result.id) : Promise.resolve(null)
        ]);
        
        setSteps(fetchedSteps);
        setLogs(fetchedLogs);
        setScreenshots(fetchedScreenshots);
        setTestVideo(fetchedVideo);
        
        // Reset selections
        setSelectedStepId(null);
        setSelectedScreenshotId(null);
        setViewingStepDetails(false);
        setSelectedStep(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error fetching test result details');
        console.error('Error fetching test result details:', err);
      } finally {
        setLoading(false);
      }
    };
    
    const fetchTestVideo = async (testId: string): Promise<string | null> => {
      try {
        // This would be implemented in the useResults hook
        // For now, just return a placeholder
        return null;
      } catch (err) {
        console.error('Error fetching test video:', err);
        return null;
      }
    };
    
    fetchDetails();
  }, [result.id, result.hasVideo, fetchTestSteps, fetchTestLogs, fetchTestStepScreenshots]);
  
  const handleViewStepDetails = async (stepId: string) => {
    setSelectedStepId(stepId);
    setViewingStepDetails(true);
    
    try {
      setLoading(true);
      // Fetch detailed information about the specific step
      const stepDetails = await fetchTestStepDetails(result.id, stepId);
      setSelectedStep(stepDetails);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Error fetching step details');
      console.error('Error fetching step details:', err);
    } finally {
      setLoading(false);
    }
  };
  
  const handleViewScreenshot = (screenshotId: string) => {
    setSelectedScreenshotId(screenshotId);
    setActiveTab('screenshots');
  };
  
  const handleBackToSteps = () => {
    setViewingStepDetails(false);
    setSelectedStepId(null);
    setSelectedStep(null);
  };
  
  const getStatusColor = (status: CSTestStatus): string => {
    switch (status) {
      case CSTestStatus.PASSED:
        return 'success';
      case CSTestStatus.FAILED:
        return 'danger';
      case CSTestStatus.SKIPPED:
        return 'warning';
      case CSTestStatus.RUNNING:
        return 'info';
      default:
        return 'default';
    }
  };
  
  const formatDuration = (durationMs?: number): string => {
    if (!durationMs) return '--';
    
    const seconds = Math.floor(durationMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  };
  
  const renderStepIcon = (step: CSTestStep): React.ReactNode => {
    if (!step.status) return '?';
    
    switch (step.status) {
      case CSTestStatus.PASSED:
        return <span className="step-icon passed"></span>;
      case CSTestStatus.FAILED:
        return <span className="step-icon failed"></span>;
      case CSTestStatus.SKIPPED:
        return <span className="step-icon skipped"></span>;
      case CSTestStatus.RUNNING:
        return <span className="step-icon running"></span>;
      default:
        return <span className="step-icon">?</span>;
    }
  };
  
  if (loading && !viewingStepDetails) {
    return (
      <div className="loading-container">
        <Spinner size="medium" />
        <p>Loading test result details...</p>
      </div>
    );
  }
  
  if (error && !viewingStepDetails) {
    return (
      <Alert type="error" title="Error Loading Details" onClose={() => setError(null)}>
        {error}
      </Alert>
    );
  }
  
  if (viewingStepDetails && selectedStep) {
    return (
      <div className="step-details-view">
        <Button onClick={handleBackToSteps} variant="outline" size="small">
           Back to Steps
        </Button>
        <TestStepDetails 
          step={selectedStep} 
          onViewScreenshot={handleViewScreenshot} 
        />
      </div>
    );
  }
  
  return (
    <div className="test-result-details">
      {/* Header and summary */}
      <div className="result-header">
        <div className="result-title">
          <h2>{result.name}</h2>
          <span className={`status-badge ${getStatusColor(result.status)}`}>
            {result.status}
          </span>
        </div>
        
        {onBack && (
          <Button onClick={onBack} variant="outline" size="small">
             Back to Results
          </Button>
        )}
      </div>
      
      <Card className="result-info">
        <div className="info-grid">
          <div className="info-item">
            <label>Test Class</label>
            <span>{result.testClass || '-'}</span>
          </div>
          
          <div className="info-item">
            <label>Duration</label>
            <span>{formatDuration(result.duration)}</span>
          </div>
          
          <div className="info-item">
            <label>Started</label>
            <span>{result.startTime ? new Date(result.startTime).toLocaleString() : '-'}</span>
          </div>
          
          <div className="info-item">
            <label>Finished</label>
            <span>{result.endTime ? new Date(result.endTime).toLocaleString() : '-'}</span>
          </div>
        </div>
        
        {result.description && (
          <div className="result-description">
            <label>Description</label>
            <p>{result.description}</p>
          </div>
        )}
        
        {result.tags && result.tags.length > 0 && (
          <div className="result-tags">
            <label>Tags</label>
            <div className="tags-container">
              {result.tags.map(tag => (
                <span key={tag} className="tag">{tag}</span>
              ))}
            </div>
          </div>
        )}
        
        {result.errorMessage && (
          <div className="result-error">
            <label>Error</label>
            <div className="error-message">{result.errorMessage}</div>
            {result.stackTrace && (
              <details>
                <summary>Stack Trace</summary>
                <pre className="stack-trace">{result.stackTrace}</pre>
              </details>
            )}
          </div>
        )}
      </Card>
      
      {/* Tabs for different sections */}
      <div className="result-details-tabs">
        <Tabs
          tabs={[
            { id: 'steps', label: `Steps (${steps.length})` },
            { id: 'logs', label: 'Logs' },
            { id: 'screenshots', label: `Screenshots (${screenshots.length})` },
            ...(testVideo ? [{ id: 'video', label: 'Video' }] : [])
          ]}
          activeTab={activeTab}
          onChange={(tabId) => setActiveTab(tabId as 'steps' | 'logs' | 'screenshots' | 'video')}
        />
      </div>
      
      {/* Content based on active tab */}
      <div className="result-details-content">
        {activeTab === 'steps' && (
          <div className="steps-container">
            {steps.length === 0 ? (
              <div className="no-steps">
                <p>No steps recorded for this test.</p>
              </div>
            ) : (
              <div className="steps-list">
                {steps.map((step, index) => (
                  <div
                    key={step.id}
                    className={`step-item ${step.status?.toLowerCase() || ''} ${
                      selectedStepId === step.id ? 'selected' : ''
                    }`}
                    onClick={() => handleViewStepDetails(step.id)}
                  >
                    <div className="step-number">{index + 1}</div>
                    <div className="step-icon">{renderStepIcon(step)}</div>
                    <div className="step-name">{step.name}</div>
                    <div className="step-duration">{formatDuration(step.duration)}</div>
                    <div className="step-details-button">
                      <Button variant="text" size="small">
                        Details
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
        
        {activeTab === 'logs' && (
          <div className="logs-container">
            {logs.length === 0 ? (
              <div className="no-logs">
                <p>No logs available for this test run.</p>
              </div>
            ) : (
              <div className="log-content">
                <pre className="log-text">{logs.join('\n')}</pre>
                <Button
                  variant="outline"
                  size="small"
                  onClick={() => {
                    // Download logs as text file
                    const blob = new Blob([logs.join('\n')], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `test_logs_${result.id}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                  }}
                >
                  Download Logs
                </Button>
              </div>
            )}
          </div>
        )}
        
        {activeTab === 'screenshots' && (
          <div className="screenshots-container">
            {screenshots.length === 0 ? (
              <div className="no-screenshots">
                <p>No screenshots available for this test run.</p>
              </div>
            ) : (
              <ScreenshotViewer 
                screenshots={screenshots} 
                selectedId={selectedScreenshotId} 
                onSelect={setSelectedScreenshotId} 
              />
            )}
          </div>
        )}
        
        {activeTab === 'video' && testVideo && (
          <div className="video-container">
            <VideoPlayer videoUrl={testVideo} />
          </div>
        )}
      </div>
    </div>
  );
};

export default TestResultDetails;


src/components/results/TestStepDetails.tsx
---------------------------------------------------------

import React, { useState } from 'react';
import Card from '../common/Card';
import Button from '../common/Button';
import Tabs from '../common/Tabs';
import { CSTestStep, CSTestStatus, CSScreenshot } from '../../types/reporting';

interface TestStepDetailsProps {
  step: CSTestStep;
  onViewScreenshot?: (screenshotId: string) => void;
}

const TestStepDetails: React.FC<TestStepDetailsProps> = ({ 
  step,
  onViewScreenshot
}) => {
  const [activeTab, setActiveTab] = useState<'details' | 'params' | 'screenshots' | 'logs'>('details');
  
  const getStatusColor = (status: CSTestStatus): string => {
    switch (status) {
      case CSTestStatus.PASSED:
        return 'success';
      case CSTestStatus.FAILED:
        return 'danger';
      case CSTestStatus.SKIPPED:
        return 'warning';
      case CSTestStatus.RUNNING:
        return 'info';
      default:
        return 'default';
    }
  };
  
  const formatDuration = (durationMs?: number): string => {
    if (!durationMs) return '--';
    
    const seconds = Math.floor(durationMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else if (seconds > 0) {
      return `${seconds}s`;
    } else {
      return `${durationMs}ms`;
    }
  };
  
  const formatActionType = (actionType: string): string => {
    // Convert camelCase or UPPERCASE_WITH_UNDERSCORES to Human Readable Format
    let formatted = actionType
      .replace(/([A-Z])/g, ' $1') // Add space before capital letters
      .replace(/_/g, ' ') // Replace underscores with spaces
      .toLowerCase()
      .trim();
    
    // Capitalize first letter
    return formatted.charAt(0).toUpperCase() + formatted.slice(1);
  };
  
  const hasParams = step.params && Object.keys(step.params).length > 0;
  const hasScreenshots = step.screenshots && step.screenshots.length > 0;
  const hasLogs = step.logs && step.logs.length > 0;
  
  return (
    <div className="test-step-details">
      <div className="step-header">
        <h2>{step.name}</h2>
        <span className={`status-badge ${getStatusColor(step.status || CSTestStatus.UNKNOWN)}`}>
          {step.status || 'Unknown Status'}
        </span>
      </div>
      
      <Card className="step-info">
        <div className="info-grid">
          <div className="info-item">
            <label>Action Type</label>
            <span>{formatActionType(step.actionType || 'Unknown Action')}</span>
          </div>
          
          <div className="info-item">
            <label>Duration</label>
            <span>{formatDuration(step.duration)}</span>
          </div>
          
          <div className="info-item">
            <label>Started</label>
            <span>{step.startTime ? new Date(step.startTime).toLocaleString() : '-'}</span>
          </div>
          
          <div className="info-item">
            <label>Element Locator</label>
            <span>{step.locator || '-'}</span>
          </div>
        </div>
        
        {step.description && (
          <div className="step-description">
            <label>Description</label>
            <p>{step.description}</p>
          </div>
        )}
        
        {step.errorMessage && (
          <div className="step-error">
            <label>Error</label>
            <div className="error-message">{step.errorMessage}</div>
            {step.stackTrace && (
              <details>
                <summary>Stack Trace</summary>
                <pre className="stack-trace">{step.stackTrace}</pre>
              </details>
            )}
          </div>
        )}
      </Card>
      
      <div className="step-details-tabs">
        <Tabs
          tabs={[
            { id: 'details', label: 'Details' },
            ...(hasParams ? [{ id: 'params', label: 'Parameters' }] : []),
            ...(hasScreenshots ? [{ id: 'screenshots', label: `Screenshots (${step.screenshots?.length || 0})` }] : []),
            ...(hasLogs ? [{ id: 'logs', label: 'Logs' }] : [])
          ]}
          activeTab={activeTab}
          onChange={(tabId) => setActiveTab(tabId as 'details' | 'params' | 'screenshots' | 'logs')}
        />
      </div>
      
      <div className="step-details-content">
        {activeTab === 'details' && (
          <div className="details-container">
            <Card>
              <h3>Step Execution Details</h3>
              
              {step.beforeState && (
                <div className="state-section">
                  <h4>Before Execution</h4>
                  <pre className="state-data">{JSON.stringify(step.beforeState, null, 2)}</pre>
                </div>
              )}
              
              {step.afterState && (
                <div className="state-section">
                  <h4>After Execution</h4>
                  <pre className="state-data">{JSON.stringify(step.afterState, null, 2)}</pre>
                </div>
              )}
              
              {step.htmlSource && (
                <div className="html-section">
                  <h4>HTML Source</h4>
                  <details>
                    <summary>View HTML Source</summary>
                    <pre className="html-code">{step.htmlSource}</pre>
                  </details>
                </div>
              )}
              
              {step.console && step.console.length > 0 && (
                <div className="console-section">
                  <h4>Console Output</h4>
                  <pre className="console-output">{step.console.join('\n')}</pre>
                </div>
              )}
              
              {step.customData && Object.keys(step.customData).length > 0 && (
                <div className="custom-data-section">
                  <h4>Custom Data</h4>
                  <div className="custom-data-grid">
                    {Object.entries(step.customData).map(([key, value]) => (
                      <div key={key} className="custom-data-item">
                        <label>{key}</label>
                        <span>{typeof value === 'object' ? JSON.stringify(value) : String(value)}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </Card>
          </div>
        )}
        
        {activeTab === 'params' && hasParams && (
          <div className="params-container">
            <Card>
              <h3>Step Parameters</h3>
              <div className="params-grid">
                {Object.entries(step.params || {}).map(([key, value]) => (
                  <div key={key} className="param-item">
                    <label>{key}</label>
                    <span>{typeof value === 'object' ? JSON.stringify(value) : String(value)}</span>
                  </div>
                ))}
              </div>
            </Card>
          </div>
        )}
        
        {activeTab === 'screenshots' && hasScreenshots && (
          <div className="screenshots-container">
            <div className="screenshots-grid">
              {step.screenshots?.map((screenshot: CSScreenshot) => (
                <div key={screenshot.id} className="screenshot-item">
                  <div className="screenshot-info">
                    <span className="screenshot-timestamp">
                      {screenshot.timestamp ? new Date(screenshot.timestamp).toLocaleString() : 'Unknown time'}
                    </span>
                  </div>
                  <div className="screenshot-preview">
                    <img 
                      src={screenshot.base64Data ? `data:image/png;base64,${screenshot.base64Data}` : screenshot.url}
                      alt={screenshot.label || "Screenshot"} 
                      onClick={() => onViewScreenshot && onViewScreenshot(screenshot.id)}
                    />
                  </div>
                  <div className="screenshot-actions">
                    <Button 
                      variant="text" 
                      size="small"
                      onClick={() => onViewScreenshot && onViewScreenshot(screenshot.id)}
                    >
                      View Full Size
                    </Button>
                    <Button
                      variant="text"
                      size="small"
                      onClick={() => {
                        // Download screenshot
                        const link = document.createElement('a');
                        link.href = screenshot.base64Data 
                          ? `data:image/png;base64,${screenshot.base64Data}` 
                          : screenshot.url || '';
                        link.download = `screenshot_${screenshot.id}.png`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                      }}
                    >
                      Download
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
        
        {activeTab === 'logs' && hasLogs && (
          <div className="logs-container">
            <Card>
              <h3>Step Logs</h3>
              <pre className="step-logs">{step.logs?.join('\n')}</pre>
              <Button
                variant="outline"
                size="small"
                onClick={() => {
                  // Download logs as text file
                  const blob = new Blob([step.logs?.join('\n') || ''], { type: 'text/plain' });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url;
                  a.download = `step_logs_${step.id}.txt`;
                  document.body.appendChild(a);
                  a.click();
                  document.body.removeChild(a);
                  URL.revokeObjectURL(url);
                }}
              >
                Download Logs
              </Button>
            </Card>
          </div>
        )}
      </div>
    </div>
  );
};

export default TestStepDetails;


src/components/results/ScreenshotViewer.tsx
------------------------------------------------

import React, { useState, useEffect, useRef } from 'react';
import Button from '../common/Button';
import { CSScreenshot } from '../../types/reporting';

interface ScreenshotViewerProps {
  screenshots: CSScreenshot[];
  selectedId?: string | null;
  onSelect?: (id: string) => void;
}

const ScreenshotViewer: React.FC<ScreenshotViewerProps> = ({
  screenshots,
  selectedId,
  onSelect,
}) => {
  const [currentIndex, setCurrentIndex] = useState<number>(0);
  const [isFullscreen, setIsFullscreen] = useState<boolean>(false);
  const [zoomLevel, setZoomLevel] = useState<number>(1);
  const [showControls, setShowControls] = useState<boolean>(true);
  const [dragPosition, setDragPosition] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState<boolean>(false);
  const [dragStart, setDragStart] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
  
  const containerRef = useRef<HTMLDivElement>(null);
  const imageRef = useRef<HTMLImageElement>(null);
  
  // Set current index based on selectedId
  useEffect(() => {
    if (selectedId) {
      const index = screenshots.findIndex(screenshot => screenshot.id === selectedId);
      if (index !== -1) {
        setCurrentIndex(index);
      }
    }
  }, [selectedId, screenshots]);
  
  // Reset zoom and position when changing images
  useEffect(() => {
    setZoomLevel(1);
    setDragPosition({ x: 0, y: 0 });
  }, [currentIndex]);
  
  const handlePrevious = () => {
    if (currentIndex > 0) {
      const newIndex = currentIndex - 1;
      setCurrentIndex(newIndex);
      if (onSelect) {
        onSelect(screenshots[newIndex].id);
      }
    }
  };
  
  const handleNext = () => {
    if (currentIndex < screenshots.length - 1) {
      const newIndex = currentIndex + 1;
      setCurrentIndex(newIndex);
      if (onSelect) {
        onSelect(screenshots[newIndex].id);
      }
    }
  };
  
  const toggleFullscreen = () => {
    setIsFullscreen(!isFullscreen);
    setShowControls(true);
    
    // Reset zoom and position when entering/exiting fullscreen
    setZoomLevel(1);
    setDragPosition({ x: 0, y: 0 });
  };
  
  const downloadScreenshot = () => {
    const screenshot = screenshots[currentIndex];
    const link = document.createElement('a');
    link.href = screenshot.base64Data 
      ? `data:image/png;base64,${screenshot.base64Data}` 
      : screenshot.url || '';
    
    link.download = `screenshot_${screenshot.id}.png`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };
  
  const handleZoomIn = () => {
    setZoomLevel(prevZoom => Math.min(prevZoom + 0.25, 3));
  };
  
  const handleZoomOut = () => {
    setZoomLevel(prevZoom => Math.max(prevZoom - 0.25, 0.5));
  };
  
  const handleZoomReset = () => {
    setZoomLevel(1);
    setDragPosition({ x: 0, y: 0 });
  };
  
  const handleToggleControls = () => {
    setShowControls(!showControls);
  };
  
  const handleMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {
    if (zoomLevel > 1) {
      setIsDragging(true);
      setDragStart({
        x: e.clientX - dragPosition.x,
        y: e.clientY - dragPosition.y
      });
    }
  };
  
  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (isDragging && zoomLevel > 1) {
      const newX = e.clientX - dragStart.x;
      const newY = e.clientY - dragStart.y;
      
      // Calculate bounds to prevent dragging outside image
      let boundedX = newX;
      let boundedY = newY;
      
      if (imageRef.current && containerRef.current) {
        const containerWidth = containerRef.current.offsetWidth;
        const containerHeight = containerRef.current.offsetHeight;
        const imageWidth = imageRef.current.offsetWidth * zoomLevel;
        const imageHeight = imageRef.current.offsetHeight * zoomLevel;
        
        const maxX = Math.max(0, (imageWidth - containerWidth) / 2);
        const maxY = Math.max(0, (imageHeight - containerHeight) / 2);
        
        boundedX = Math.max(-maxX, Math.min(maxX, newX));
        boundedY = Math.max(-maxY, Math.min(maxY, newY));
      }
      
      setDragPosition({
        x: boundedX,
        y: boundedY
      });
    }
  };
  
  const handleMouseUp = () => {
    setIsDragging(false);
  };
  
  const handleMouseLeave = () => {
    setIsDragging(false);
  };
  
  const handleWheel = (e: React.WheelEvent<HTMLDivElement>) => {
    e.preventDefault();
    
    // Zoom with ctrl + wheel
    if (e.ctrlKey) {
      if (e.deltaY < 0) {
        // Zoom in
        setZoomLevel(prevZoom => Math.min(prevZoom + 0.1, 3));
      } else {
        // Zoom out
        setZoomLevel(prevZoom => Math.max(prevZoom - 0.1, 0.5));
      }
    } else {
      // Pan with wheel
      if (zoomLevel > 1) {
        setDragPosition(prevPosition => ({
          x: prevPosition.x - e.deltaX,
          y: prevPosition.y - e.deltaY
        }));
      }
    }
  };
  
  // Handle keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (isFullscreen) {
        switch (e.key) {
          case 'ArrowLeft':
            handlePrevious();
            break;
          case 'ArrowRight':
            handleNext();
            break;
          case 'Escape':
            setIsFullscreen(false);
            break;
          case '+':
            handleZoomIn();
            break;
          case '-':
            handleZoomOut();
            break;
          case '0':
            handleZoomReset();
            break;
          case 'h':
            handleToggleControls();
            break;
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isFullscreen, currentIndex, screenshots.length]);
  
  const screenshot = screenshots[currentIndex];
  const imageUrl = screenshot?.base64Data 
    ? `data:image/png;base64,${screenshot.base64Data}` 
    : screenshot?.url || '';
  
  return (
    <div className={`screenshot-viewer ${isFullscreen ? 'fullscreen' : ''}`}>
      {!isFullscreen && (
        <div className="thumbnail-strip">
          {screenshots.map((screenshot, index) => (
            <div 
              key={screenshot.id} 
              className={`thumbnail ${index === currentIndex ? 'active' : ''}`}
              onClick={() => {
                setCurrentIndex(index);
                if (onSelect) {
                  onSelect(screenshot.id);
                }
              }}
            >
              <img 
                src={screenshot.base64Data 
                  ? `data:image/png;base64,${screenshot.base64Data}` 
                  : screenshot.url || ''}
                alt={screenshot.label || `Screenshot ${index + 1}`}
              />
              <div className="thumbnail-overlay">
                <span>{index + 1}</span>
              </div>
            </div>
          ))}
        </div>
      )}
      
      <div 
        className="screenshot-container"
        ref={containerRef}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseLeave}
        onWheel={handleWheel}
      >
        <img 
          ref={imageRef}
          className="screenshot-image"
          src={imageUrl}
          alt={screenshot?.label || `Screenshot ${currentIndex + 1}`}
          style={{
            transform: `scale(${zoomLevel}) translate(${dragPosition.x / zoomLevel}px, ${dragPosition.y / zoomLevel}px)`,
            cursor: zoomLevel > 1 ? (isDragging ? 'grabbing' : 'grab') : 'default'
          }}
        />
        
        {(!isFullscreen || showControls) && (
          <div className="screenshot-controls">
            <div className="screenshot-navigation">
              <Button 
                onClick={handlePrevious} 
                disabled={currentIndex === 0} 
                variant="primary"
                size="small"
              >
                 Previous
              </Button>
              <span className="screenshot-counter">
                {currentIndex + 1} / {screenshots.length}
              </span>
              <Button 
                onClick={handleNext} 
                disabled={currentIndex === screenshots.length - 1} 
                variant="primary"
                size="small"
              >
                Next 
              </Button>
            </div>
            
            <div className="screenshot-zoom-controls">
              <Button onClick={handleZoomOut} variant="outline" size="small">
                -
              </Button>
              <span className="zoom-level">{Math.round(zoomLevel * 100)}%</span>
              <Button onClick={handleZoomIn} variant="outline" size="small">
                +
              </Button>
              <Button onClick={handleZoomReset} variant="outline" size="small">
                Reset
              </Button>
            </div>
            
            <div className="screenshot-actions">
              <Button onClick={toggleFullscreen} variant="outline" size="small">
                {isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}
              </Button>
              <Button onClick={downloadScreenshot} variant="outline" size="small">
                Download
              </Button>
              {isFullscreen && (
                <Button onClick={handleToggleControls} variant="outline" size="small">
                  {showControls ? 'Hide Controls' : 'Show Controls'}
                </Button>
              )}
            </div>
          </div>
        )}
        
        {isFullscreen && !showControls && (
          <Button 
            className="show-controls-button"
            onClick={handleToggleControls} 
            variant="outline" 
            size="small"
          >
            Show Controls
          </Button>
        )}
      </div>
      
      <div className="screenshot-info">
        <div className="screenshot-metadata">
          {screenshot?.label && (
            <div className="screenshot-label">
              <strong>Label:</strong> {screenshot.label}
            </div>
          )}
          {screenshot?.timestamp && (
            <div className="screenshot-timestamp">
              <strong>Time:</strong> {new Date(screenshot.timestamp).toLocaleString()}
            </div>
          )}
          {screenshot?.testStep && (
            <div className="screenshot-step">
              <strong>Test Step:</strong> {screenshot.testStep}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default ScreenshotViewer;

src/components/results/VideoPlayer.tsx
-----------------------------------------------------------

import React, { useState, useRef, useEffect } from 'react';
import Button from '../common/Button';
import Slider from '../common/Slider';

interface VideoPlayerProps {
  videoUrl: string;
  autoPlay?: boolean;
  poster?: string;
}

const VideoPlayer: React.FC<VideoPlayerProps> = ({
  videoUrl,
  autoPlay = false,
  poster,
}) => {
  const [isPlaying, setIsPlaying] = useState<boolean>(autoPlay);
  const [isFullscreen, setIsFullscreen] = useState<boolean>(false);
  const [currentTime, setCurrentTime] = useState<number>(0);
  const [duration, setDuration] = useState<number>(0);
  const [volume, setVolume] = useState<number>(1);
  const [isMuted, setIsMuted] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [playbackRate, setPlaybackRate] = useState<number>(1);
  const [showControls, setShowControls] = useState<boolean>(true);
  const [bufferedPercentage, setBufferedPercentage] = useState<number>(0);
  
  const videoRef = useRef<HTMLVideoElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const controlsTimerRef = useRef<number | null>(null);
  
  // Cleanup timer on unmount
  useEffect(() => {
    return () => {
      if (controlsTimerRef.current) {
        window.clearTimeout(controlsTimerRef.current);
      }
    };
  }, []);
  
  // Handle video events
  useEffect(() => {
    const videoElement = videoRef.current;
    if (!videoElement) return;
    
    const handleTimeUpdate = () => {
      setCurrentTime(videoElement.currentTime);
    };
    
    const handleDurationChange = () => {
      setDuration(videoElement.duration);
    };
    
    const handleVolumeChange = () => {
      setVolume(videoElement.volume);
      setIsMuted(videoElement.muted);
    };
    
    const handleProgress = () => {
      if (videoElement.buffered.length > 0) {
        const bufferedEnd = videoElement.buffered.end(videoElement.buffered.length - 1);
        const buffered = (bufferedEnd / videoElement.duration) * 100;
        setBufferedPercentage(buffered);
      }
    };
    
    const handleLoadStart = () => {
      setIsLoading(true);
    };
    
    const handleLoadedData = () => {
      setIsLoading(false);
    };
    
    const handlePlaying = () => {
      setIsPlaying(true);
      setIsLoading(false);
    };
    
    const handlePause = () => {
      setIsPlaying(false);
    };
    
    const handleEnded = () => {
      setIsPlaying(false);
      setCurrentTime(0);
      if (videoElement) {
        videoElement.currentTime = 0;
      }
    };
    
    const handleError = () => {
      setError('Error loading video');
      setIsLoading(false);
    };
    
    videoElement.addEventListener('timeupdate', handleTimeUpdate);
    videoElement.addEventListener('durationchange', handleDurationChange);
    videoElement.addEventListener('volumechange', handleVolumeChange);
    videoElement.addEventListener('progress', handleProgress);
    videoElement.addEventListener('loadstart', handleLoadStart);
    videoElement.addEventListener('loadeddata', handleLoadedData);
    videoElement.addEventListener('playing', handlePlaying);
    videoElement.addEventListener('pause', handlePause);
    videoElement.addEventListener('ended', handleEnded);
    videoElement.addEventListener('error', handleError);
    
    // Set initial states
    setDuration(videoElement.duration || 0);
    setVolume(videoElement.volume);
    setIsMuted(videoElement.muted);
    
    return () => {
      videoElement.removeEventListener('timeupdate', handleTimeUpdate);
      videoElement.removeEventListener('durationchange', handleDurationChange);
      videoElement.removeEventListener('volumechange', handleVolumeChange);
      videoElement.removeEventListener('progress', handleProgress);
      videoElement.removeEventListener('loadstart', handleLoadStart);
      videoElement.removeEventListener('loadeddata', handleLoadedData);
      videoElement.removeEventListener('playing', handlePlaying);
      videoElement.removeEventListener('pause', handlePause);
      videoElement.removeEventListener('ended', handleEnded);
      videoElement.removeEventListener('error', handleError);
    };
  }, []);
  
  // Playback control functions
  const togglePlay = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play().catch(error => {
          console.error('Error playing video:', error);
          setError('Error playing video. Video playback might be disabled by the browser.');
        });
      }
      setIsPlaying(!isPlaying);
    }
  };
  
  const handleTimeChange = (value: number) => {
    setCurrentTime(value);
    if (videoRef.current) {
      videoRef.current.currentTime = value;
    }
  };
  
  const handleVolumeChange = (value: number) => {
    setVolume(value);
    if (videoRef.current) {
      videoRef.current.volume = value;
      
      // If volume is set to 0, mute the video, otherwise unmute
      videoRef.current.muted = value === 0;
      setIsMuted(value === 0);
    }
  };
  
  const toggleMute = () => {
    if (videoRef.current) {
      const newMuted = !isMuted;
      videoRef.current.muted = newMuted;
      setIsMuted(newMuted);
    }
  };
  
  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      if (containerRef.current?.requestFullscreen) {
        containerRef.current.requestFullscreen().catch(err => {
          console.error('Error attempting to enable fullscreen mode:', err);
        });
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  };
  
  // Listen for fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    
    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
    };
  }, []);
  
  const handlePlaybackRateChange = (rate: number) => {
    setPlaybackRate(rate);
    if (videoRef.current) {
      videoRef.current.playbackRate = rate;
    }
  };
  
  // Auto-hide controls
  const resetControlsTimer = () => {
    if (controlsTimerRef.current) {
      window.clearTimeout(controlsTimerRef.current);
    }
    
    setShowControls(true);
    
    if (isPlaying && isFullscreen) {
      controlsTimerRef.current = window.setTimeout(() => {
        setShowControls(false);
      }, 3000);
    }
  };
  
  const handleMouseMove = () => {
    resetControlsTimer();
  };
  
  // Format time as MM:SS
  const formatTime = (seconds: number): string => {
    if (isNaN(seconds)) return '00:00';
    
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  };
  
  // Handle keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!containerRef.current?.contains(document.activeElement)) return;
      
      switch (e.key) {
        case ' ':
        case 'k':
          e.preventDefault();
          togglePlay();
          break;
        case 'f':
          e.preventDefault();
          toggleFullscreen();
          break;
        case 'm':
          e.preventDefault();
          toggleMute();
          break;
        case 'ArrowLeft':
          e.preventDefault();
          if (videoRef.current) {
            videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 5);
          }
          break;
        case 'ArrowRight':
          e.preventDefault();
          if (videoRef.current) {
            videoRef.current.currentTime = Math.min(
              videoRef.current.duration, 
              videoRef.current.currentTime + 5
            );
          }
          break;
        case 'ArrowUp':
          e.preventDefault();
          if (videoRef.current) {
            const newVolume = Math.min(1, videoRef.current.volume + 0.1);
            videoRef.current.volume = newVolume;
            setVolume(newVolume);
            if (isMuted) {
              videoRef.current.muted = false;
              setIsMuted(false);
            }
          }
          break;
        case 'ArrowDown':
          e.preventDefault();
          if (videoRef.current) {
            const newVolume = Math.max(0, videoRef.current.volume - 0.1);
            videoRef.current.volume = newVolume;
            setVolume(newVolume);
          }
          break;
        case '0':
        case 'Home':
          e.preventDefault();
          if (videoRef.current) {
            videoRef.current.currentTime = 0;
          }
          break;
        case 'End':
          e.preventDefault();
          if (videoRef.current) {
            videoRef.current.currentTime = videoRef.current.duration;
          }
          break;
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isPlaying, isMuted]);
  
  return (
    <div 
      className={`video-player ${isFullscreen ? 'fullscreen' : ''}`}
      ref={containerRef}
      onMouseMove={handleMouseMove}
    >
      <div 
        className="video-container"
        onClick={togglePlay}
      >
        <video
          ref={videoRef}
          src={videoUrl}
          poster={poster}
          playsInline
          onClick={e => e.stopPropagation()}
        />
        
        {isLoading && (
          <div className="video-loading">
            <div className="loading-spinner"></div>
            <p>Loading video...</p>
          </div>
        )}
        
        {error && (
          <div className="video-error">
            <p>{error}</p>
          </div>
        )}
        
        {!isPlaying && !isLoading && !error && (
          <div className="video-play-overlay" onClick={togglePlay}>
            <button className="play-button">
              <svg viewBox="0 0 24 24" width="48" height="48">
                <path d="M8 5v14l11-7z" fill="currentColor" />
              </svg>
            </button>
          </div>
        )}
      </div>
      
      {(showControls || !isPlaying) && (
        <div className="video-controls">
          <div className="progress-bar-container">
            <div 
              className="buffered-progress"
              style={{ width: `${bufferedPercentage}%` }}
            ></div>
            <Slider
              min={0}
              max={duration || 100}
              value={currentTime}
              onChange={handleTimeChange}
              className="progress-slider"
            />
          </div>
          
          <div className="controls-row">
            <div className="left-controls">
              <Button onClick={togglePlay} variant="icon" size="small">
                {isPlaying ? (
                  <svg viewBox="0 0 24 24" width="24" height="24">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" fill="currentColor" />
                  </svg>
                ) : (
                  <svg viewBox="0 0 24 24" width="24" height="24">
                    <path d="M8 5v14l11-7z" fill="currentColor" />
                  </svg>
                )}
              </Button>
              
              <div className="volume-control">
                <Button onClick={toggleMute} variant="icon" size="small">
                  {isMuted || volume === 0 ? (
                    <svg viewBox="0 0 24 24" width="24" height="24">
                      <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z" fill="currentColor" />
                    </svg>
                  ) : volume < 0.5 ? (
                    <svg viewBox="0 0 24 24" width="24" height="24">
                      <path d="M7 9v6h4l5 5V4l-5 5H7z" fill="currentColor" />
                    </svg>
                  ) : (
                    <svg viewBox="0 0 24 24" width="24" height="24">
                      <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" fill="currentColor" />
                    </svg>
                  )}
                </Button>
                
                <Slider
                  min={0}
                  max={1}
                  step={0.01}
                  value={isMuted ? 0 : volume}
                  onChange={handleVolumeChange}
                  className="volume-slider"
                />
              </div>
              
              <div className="time-display">
                <span>{formatTime(currentTime)}</span>
                <span> / </span>
                <span>{formatTime(duration)}</span>
              </div>
            </div>
            
            <div className="right-controls">
              <div className="playback-rate-control">
                <select
                  value={playbackRate}
                  onChange={(e) => handlePlaybackRateChange(parseFloat(e.target.value))}
                  className="playback-rate-select"
                >
                  <option value="0.25">0.25x</option>
                  <option value="0.5">0.5x</option>
                  <option value="0.75">0.75x</option>
                  <option value="1">1x</option>
                  <option value="1.25">1.25x</option>
                  <option value="1.5">1.5x</option>
                  <option value="1.75">1.75x</option>
                  <option value="2">2x</option>
                </select>
              </div>
              
              <Button
                onClick={toggleFullscreen}
                variant="icon"
                size="small"
              >
                {isFullscreen ? (
                  <svg viewBox="0 0 24 24" width="24" height="24">
                    <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z" fill="currentColor" />
                  </svg>
                ) : (
                  <svg viewBox="0 0 24 24" width="24" height="24">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" fill="currentColor" />
                  </svg>
                )}
              </Button>
              
              <Button
                onClick={() => {
                  // Download video
                  const link = document.createElement('a');
                  link.href = videoUrl;
                  link.download = videoUrl.split('/').pop() || 'test_video.mp4';
                  document.body.appendChild(link);
                  link.click();
                  document.body.removeChild(link);
                }}
                variant="icon"
                size="small"
              >
                <svg viewBox="0 0 24 24" width="24" height="24">
                  <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" fill="currentColor" />
                </svg>
              </Button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default VideoPlayer;


src/components/results/MetricsDisplay.tsx
-----------------------------------------------------

import React, { useState, useEffect, useRef } from 'react';
import Card from '../common/Card';
import Select from '../common/Select';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';
import Button from '../common/Button';
import { useResults } from '../../hooks/useResults';

interface MetricsDisplayProps {
  metrics?: any;
  testRunId?: string;
}

interface ChartConfig {
  id: string;
  title: string;
  type: 'bar' | 'line' | 'pie' | 'area' | 'scatter';
  dataKey: string;
  categories?: string[];
  series?: string[];
  stacked?: boolean;
  showPercentage?: boolean;
}

const MetricsDisplay: React.FC<MetricsDisplayProps> = ({
  metrics: initialMetrics,
  testRunId,
}) => {
  const { fetchProjectMetrics } = useResults();
  
  const [metrics, setMetrics] = useState<any>(initialMetrics || {});
  const [loading, setLoading] = useState<boolean>(!initialMetrics);
  const [error, setError] = useState<string | null>(null);
  const [activeChart, setActiveChart] = useState<string>('testStatus');
  const [chartType, setChartType] = useState<{ [key: string]: string }>({
    testStatus: 'pie',
    duration: 'bar',
    performance: 'line',
    trends: 'line',
  });
  
  const chartContainerRefs = useRef<{ [key: string]: HTMLDivElement | null }>({});
  const charts = useRef<{ [key: string]: any }>({});
  
  // Chart configurations
  const chartConfigs: ChartConfig[] = [
    {
      id: 'testStatus',
      title: 'Test Status Distribution',
      type: 'pie',
      dataKey: 'testStatusData',
      showPercentage: true,
    },
    {
      id: 'duration',
      title: 'Test Duration',
      type: 'bar',
      dataKey: 'durationData',
      categories: ['testNames'],
      series: ['duration']
    },
    {
      id: 'performance',
      title: 'Page Performance',
      type: 'line',
      dataKey: 'performanceData',
      categories: ['pages'],
      series: ['loadTime', 'renderTime', 'interactiveTime']
    },
    {
      id: 'trends',
      title: 'Historical Trends',
      type: 'line',
      dataKey: 'trendsData',
      categories: ['dates'],
      series: ['passed', 'failed', 'skipped']
    }
  ];
  
  // Load metrics if they weren't provided
  useEffect(() => {
    if (!initialMetrics && testRunId) {
      setLoading(true);
      setError(null);
      
      fetchProjectMetrics(testRunId)
        .then(data => {
          setMetrics(data);
          setLoading(false);
        })
        .catch(err => {
          setError(err instanceof Error ? err.message : 'Error fetching metrics');
          console.error('Error fetching metrics:', err);
          setLoading(false);
        });
    }
  }, [initialMetrics, testRunId, fetchProjectMetrics]);
  
  // Initialize and update charts when metrics change
  useEffect(() => {
    if (!metrics || loading || error) return;
    
    // Import the chart library dynamically
    // For this example, we'll use the 'recharts' library that was mentioned in the project framework
    import('recharts').then(({ 
      ResponsiveContainer, BarChart, LineChart, PieChart, AreaChart, ScatterChart,
      Bar, Line, Pie, Area, Scatter, XAxis, YAxis, CartesianGrid, Tooltip, Legend,
      Cell
    }) => {
      // Clean up existing charts
      Object.values(charts.current).forEach(chart => {
        if (chart && chart.destroy) {
          chart.destroy();
        }
      });
      
      // Clear the charts object
      charts.current = {};
      
      // Brand color palette - derived from primary brand color #C54B8C
      const COLORS = [
        '#C54B8C', // Primary brand color
        '#6E1B4D', // Darker shade
        '#E17AAF', // Lighter shade
        '#8A3363', // Medium shade
        '#F1A8C9', // Lightest shade
        '#4B1D36', // Desaturated dark
        '#A0386F', // Medium-dark
        '#DC94BA', // Medium-light
      ];
      
      const STATUS_COLORS = {
        'PASSED': '#28a745',  // Green for passed
        'FAILED': '#dc3545',  // Red for failed
        'SKIPPED': '#ffc107', // Yellow for skipped
        'RUNNING': '#17a2b8'  // Blue for running
      };
      
      // Format data for different chart types
      chartConfigs.forEach(config => {
        const containerRef = chartContainerRefs.current[config.id];
        if (!containerRef) return;
        
        // Get the raw data from metrics
        const rawData = metrics[config.dataKey];
        if (!rawData) return;
        
        // Create the appropriate chart based on the type
        switch (chartType[config.id] || config.type) {
          case 'bar':
            {
              const BarChartComponent = (
                <ResponsiveContainer width="100%" height={400}>
                  <BarChart data={rawData} margin={{ top: 20, right: 30, left: 20, bottom: 50 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis 
                      dataKey={config.categories?.[0]} 
                      angle={-45} 
                      textAnchor="end" 
                      height={80} 
                    />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    {config.series?.map((series, index) => (
                      <Bar 
                        key={series} 
                        dataKey={series} 
                        fill={COLORS[index % COLORS.length]} 
                        stackId={config.stacked ? "stack" : undefined}
                      />
                    ))}
                  </BarChart>
                </ResponsiveContainer>
              );
              
              charts.current[config.id] = { component: BarChartComponent };
            }
            break;
            
          case 'line':
            {
              const LineChartComponent = (
                <ResponsiveContainer width="100%" height={400}>
                  <LineChart data={rawData} margin={{ top: 20, right: 30, left: 20, bottom: 50 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis 
                      dataKey={config.categories?.[0]}
                      angle={-45} 
                      textAnchor="end" 
                      height={80}
                    />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    {config.series?.map((series, index) => (
                      <Line 
                        key={series} 
                        type="monotone" 
                        dataKey={series} 
                        stroke={COLORS[index % COLORS.length]} 
                        activeDot={{ r: 8 }}
                      />
                    ))}
                  </LineChart>
                </ResponsiveContainer>
              );
              
              charts.current[config.id] = { component: LineChartComponent };
            }
            break;
            
          case 'pie':
            {
              // Special handling for test status distribution
              if (config.id === 'testStatus') {
                const formattedData = Object.entries(rawData).map(([name, value]) => ({
                  name,
                  value: value as number
                }));
                
                const PieChartComponent = (
                  <ResponsiveContainer width="100%" height={400}>
                    <PieChart margin={{ top: 20, right: 30, left: 20, bottom: 20 }}>
                      <Pie
                        data={formattedData}
                        dataKey="value"
                        nameKey="name"
                        cx="50%"
                        cy="50%"
                        outerRadius={150}
                        fill="#8884d8"
                        label={({ name, percent }) => config.showPercentage 
                          ? `${name}: ${(percent * 100).toFixed(0)}%` 
                          : name
                        }
                      >
                        {formattedData.map((entry, index) => (
                          <Cell 
                            key={`cell-${index}`} 
                            fill={STATUS_COLORS[entry.name as keyof typeof STATUS_COLORS] || COLORS[index % COLORS.length]} 
                          />
                        ))}
                      </Pie>
                      <Tooltip />
                      <Legend />
                    </PieChart>
                  </ResponsiveContainer>
                );
                
                charts.current[config.id] = { component: PieChartComponent };
              } else {
                // Generic pie chart
                const PieChartComponent = (
                  <ResponsiveContainer width="100%" height={400}>
                    <PieChart margin={{ top: 20, right: 30, left: 20, bottom: 20 }}>
                      <Pie
                        data={rawData}
                        dataKey="value"
                        nameKey="name"
                        cx="50%"
                        cy="50%"
                        outerRadius={150}
                        fill="#8884d8"
                        label={({ name, percent }) => config.showPercentage 
                          ? `${name}: ${(percent * 100).toFixed(0)}%` 
                          : name
                        }
                      >
                        {rawData.map((entry: any, index: number) => (
                          <Cell 
                            key={`cell-${index}`} 
                            fill={COLORS[index % COLORS.length]} 
                          />
                        ))}
                      </Pie>
                      <Tooltip />
                      <Legend />
                    </PieChart>
                  </ResponsiveContainer>
                );
                
                charts.current[config.id] = { component: PieChartComponent };
              }
            }
            break;
            
          case 'area':
            {
              const AreaChartComponent = (
                <ResponsiveContainer width="100%" height={400}>
                  <AreaChart data={rawData} margin={{ top: 20, right: 30, left: 20, bottom: 50 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis 
                      dataKey={config.categories?.[0]}
                      angle={-45} 
                      textAnchor="end" 
                      height={80}
                    />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    {config.series?.map((series, index) => (
                      <Area 
                        key={series} 
                        type="monotone" 
                        dataKey={series} 
                        stackId={config.stacked ? "1" : undefined}
                        fill={COLORS[index % COLORS.length]} 
                        stroke={COLORS[index % COLORS.length]}
                        fillOpacity={0.6}
                      />
                    ))}
                  </AreaChart>
                </ResponsiveContainer>
              );
              
              charts.current[config.id] = { component: AreaChartComponent };
            }
            break;
            
          case 'scatter':
            {
              const ScatterChartComponent = (
                <ResponsiveContainer width="100%" height={400}>
                  <ScatterChart margin={{ top: 20, right: 30, left: 20, bottom: 50 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis 
                      type="number" 
                      dataKey="x" 
                      name={config.categories?.[0]} 
                    />
                    <YAxis 
                      type="number" 
                      dataKey="y" 
                      name={config.categories?.[1]} 
                    />
                    <Tooltip cursor={{ strokeDasharray: '3 3' }} />
                    <Legend />
                    {config.series?.map((series, index) => (
                      <Scatter 
                        key={series} 
                        name={series} 
                        data={rawData[series]} 
                        fill={COLORS[index % COLORS.length]} 
                      />
                    ))}
                  </ScatterChart>
                </ResponsiveContainer>
              );
              
              charts.current[config.id] = { component: ScatterChartComponent };
            }
            break;
          
          default:
            break;
        }
      });
      
      // Force a re-render
      setMetrics({ ...metrics });
    }).catch(err => {
      console.error('Error loading recharts library:', err);
    });
    
  }, [metrics, loading, error, chartType]);
  
  // Handle chart type change
  const handleChartTypeChange = (chartId: string, type: string) => {
    setChartType(prev => ({ ...prev, [chartId]: type }));
  };
  
  if (loading) {
    return (
      <div className="loading-container">
        <Spinner size="medium" />
        <p>Loading metrics...</p>
      </div>
    );
  }
  
  if (error) {
    return (
      <Alert type="error" title="Error Loading Metrics" onClose={() => setError(null)}>
        {error}
      </Alert>
    );
  }
  
  if (!metrics || Object.keys(metrics).length === 0) {
    return (
      <div className="no-metrics">
        <p>No metrics available for this test run.</p>
      </div>
    );
  }
  
  // Get configuration for active chart
  const activeConfig = chartConfigs.find(config => config.id === activeChart);
  
  return (
    <div className="metrics-display">
      <div className="metrics-header">
        <h2>Test Metrics</h2>
        
        <div className="chart-selector">
          <Select
            label="Chart"
            value={activeChart}
            onChange={(e) => setActiveChart(e.target.value)}
            options={chartConfigs.map(config => ({
              value: config.id,
              label: config.title
            }))}
          />
          
          <Select
            label="Chart Type"
            value={chartType[activeChart] || (activeConfig?.type || 'bar')}
            onChange={(e) => handleChartTypeChange(activeChart, e.target.value)}
            options={[
              { value: 'bar', label: 'Bar Chart' },
              { value: 'line', label: 'Line Chart' },
              { value: 'pie', label: 'Pie Chart' },
              { value: 'area', label: 'Area Chart' },
              { value: 'scatter', label: 'Scatter Plot' }
            ]}
          />
        </div>
      </div>
      
      <div className="metrics-content">
        <div className="metrics-summary">
          <Card className="summary-card">
            <h3>Test Summary</h3>
            <div className="summary-stats">
              <div className="stat-item">
                <div className="stat-value">{metrics.totalTests || 0}</div>
                <div className="stat-label">Total Tests</div>
              </div>
              <div className="stat-item passed">
                <div className="stat-value">{metrics.passedTests || 0}</div>
                <div className="stat-label">Passed</div>
              </div>
              <div className="stat-item failed">
                <div className="stat-value">{metrics.failedTests || 0}</div>
                <div className="stat-label">Failed</div>
              </div>
              <div className="stat-item skipped">
                <div className="stat-value">{metrics.skippedTests || 0}</div>
                <div className="stat-label">Skipped</div>
              </div>
            </div>
            <div className="summary-kpis">
              <div className="kpi-item">
                <div className="kpi-label">Pass Rate</div>
                <div className="kpi-value">
                  {metrics.passRate ? `${(metrics.passRate * 100).toFixed(1)}%` : 'N/A'}
                </div>
              </div>
              <div className="kpi-item">
                <div className="kpi-label">Avg. Duration</div>
                <div className="kpi-value">
                  {metrics.avgDuration ? `${(metrics.avgDuration / 1000).toFixed(1)}s` : 'N/A'}
                </div>
                <div className="kpi-item">
                <div className="kpi-label">Avg. Duration</div>
                <div className="kpi-value">
                  {metrics.avgDuration ? `${(metrics.avgDuration / 1000).toFixed(1)}s` : 'N/A'}
                </div>
              </div>
              <div className="kpi-item">
                <div className="kpi-label">Slowest Test</div>
                <div className="kpi-value">
                  {metrics.slowestTest ? `${(metrics.slowestTest.duration / 1000).toFixed(1)}s` : 'N/A'}
                </div>
              </div>
              <div className="kpi-item">
                <div className="kpi-label">Flakiness Rate</div>
                <div className="kpi-value">
                  {metrics.flakinessRate ? `${(metrics.flakinessRate * 100).toFixed(1)}%` : 'N/A'}
                </div>
              </div>
            </div>
          </Card>
          
          <Card className="summary-card">
            <h3>Performance Summary</h3>
            <div className="performance-stats">
              <div className="stat-item">
                <div className="stat-value">
                  {metrics.avgPageLoadTime ? `${(metrics.avgPageLoadTime / 1000).toFixed(2)}s` : 'N/A'}
                </div>
                <div className="stat-label">Avg. Page Load</div>
              </div>
              <div className="stat-item">
                <div className="stat-value">
                  {metrics.avgNetworkRequests || 'N/A'}
                </div>
                <div className="stat-label">Avg. Network Requests</div>
              </div>
              <div className="stat-item">
                <div className="stat-value">
                  {metrics.avgDomSize ? `${metrics.avgDomSize.toLocaleString()} nodes` : 'N/A'}
                </div>
                <div className="stat-label">Avg. DOM Size</div>
              </div>
            </div>
            
            <div className="browser-distribution">
              <h4>Browser Distribution</h4>
              {metrics.browserDistribution && (
                <div className="browser-bars">
                  {Object.entries(metrics.browserDistribution).map(([browser, percentage]: [string, number]) => (
                    <div className="browser-bar-container" key={browser}>
                      <div className="browser-label">{browser}</div>
                      <div className="browser-bar-background">
                        <div 
                          className="browser-bar" 
                          style={{ width: `${percentage * 100}%` }}
                        ></div>
                      </div>
                      <div className="browser-percentage">{`${(percentage * 100).toFixed(1)}%`}</div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </Card>
        </div>
        
        <div className="chart-container">
          <Card>
            <div className="chart-header">
              <h3>{activeConfig?.title || 'Chart'}</h3>
              
              <div className="chart-actions">
                <Button
                  onClick={() => {
                    // Export chart as image
                    const chartContainer = chartContainerRefs.current[activeChart];
                    if (chartContainer) {
                      // Using html2canvas, which should be added to the project dependencies
                      import('html2canvas').then(({ default: html2canvas }) => {
                        html2canvas(chartContainer).then(canvas => {
                          const link = document.createElement('a');
                          link.download = `${activeConfig?.title.replace(/\s+/g, '_').toLowerCase() || 'chart'}_${new Date().toISOString().split('T')[0]}.png`;
                          link.href = canvas.toDataURL('image/png');
                          link.click();
                        });
                      }).catch(err => {
                        console.error('Error exporting chart:', err);
                      });
                    }
                  }}
                  variant="outline"
                  size="small"
                >
                  Export Chart
                </Button>
                
                <Button
                  onClick={() => {
                    // Export data as CSV
                    const rawData = metrics[activeConfig?.dataKey || ''];
                    if (rawData) {
                      let csvContent = '';
                      
                      // Special handling for test status distribution
                      if (activeChart === 'testStatus') {
                        csvContent = 'Status,Count\n';
                        Object.entries(rawData).forEach(([status, count]) => {
                          csvContent += `${status},${count}\n`;
                        });
                      } else if (Array.isArray(rawData)) {
                        // Get all unique keys from all objects
                        const keys = Array.from(new Set(
                          rawData.flatMap(item => Object.keys(item))
                        ));
                        
                        // Create header row
                        csvContent = keys.join(',') + '\n';
                        
                        // Create data rows
                        rawData.forEach(item => {
                          const row = keys.map(key => item[key] !== undefined ? item[key] : '').join(',');
                          csvContent += row + '\n';
                        });
                      }
                      
                      // Create and download the CSV file
                      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                      const url = URL.createObjectURL(blob);
                      const link = document.createElement('a');
                      link.setAttribute('href', url);
                      link.setAttribute('download', `${activeConfig?.title.replace(/\s+/g, '_').toLowerCase() || 'chart_data'}_${new Date().toISOString().split('T')[0]}.csv`);
                      link.style.visibility = 'hidden';
                      document.body.appendChild(link);
                      link.click();
                      document.body.removeChild(link);
                    }
                  }}
                  variant="outline"
                  size="small"
                >
                  Export Data
                </Button>
              </div>
            </div>
            
            <div 
              className="chart-content"
              ref={el => chartContainerRefs.current[activeChart] = el}
            >
              {charts.current[activeChart]?.component || (
                <div className="no-chart-data">
                  <p>No data available for this chart.</p>
                </div>
              )}
            </div>
          </Card>
        </div>
      </div>
      
      <div className="metrics-details">
        <Card>
          <h3>Test Failures Analysis</h3>
          
          {metrics.failureAnalysis && metrics.failureAnalysis.length > 0 ? (
            <div className="failures-table">
              <div className="failures-header">
                <div className="failure-type">Failure Type</div>
                <div className="failure-count">Count</div>
                <div className="failure-percentage">Percentage</div>
                <div className="failure-details">Details</div>
              </div>
              
              {metrics.failureAnalysis.map((failure: any, index: number) => (
                <div className="failure-row" key={index}>
                  <div className="failure-type">{failure.type}</div>
                  <div className="failure-count">{failure.count}</div>
                  <div className="failure-percentage">{`${(failure.percentage * 100).toFixed(1)}%`}</div>
                  <div className="failure-details">{failure.details || 'No additional details'}</div>
                </div>
              ))}
            </div>
          ) : (
            <div className="no-failures">
              <p>No failures to analyze.</p>
            </div>
          )}
        </Card>
        
        <Card>
          <h3>Top Flaky Tests</h3>
          
          {metrics.flakyTests && metrics.flakyTests.length > 0 ? (
            <div className="flaky-tests-table">
              <div className="flaky-tests-header">
                <div className="test-name">Test Name</div>
                <div className="flakiness-rate">Flakiness Rate</div>
                <div className="failed-runs">Failed Runs</div>
                <div className="total-runs">Total Runs</div>
              </div>
              
              {metrics.flakyTests.map((test: any, index: number) => (
                <div className="flaky-test-row" key={index}>
                  <div className="test-name">{test.name}</div>
                  <div className="flakiness-rate">{`${(test.flakinessRate * 100).toFixed(1)}%`}</div>
                  <div className="failed-runs">{test.failedRuns}</div>
                  <div className="total-runs">{test.totalRuns}</div>
                </div>
              ))}
            </div>
          ) : (
            <div className="no-flaky-tests">
              <p>No flaky tests detected.</p>
            </div>
          )}
        </Card>
      </div>
    </div>
  );
};

export default MetricsDisplay;



src/components/results/DashboardViewer.tsx
------------------------------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useResults } from '../../hooks/useResults';
import Button from '../common/Button';
import Select from '../common/Select';
import Input from '../common/Input';
import Card from '../common/Card';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';
import DatePicker from '../common/DatePicker';
import { useFramework } from '../../hooks/useFramework';

interface DashboardViewerProps {
  projectId?: string;
  dashboardId?: string;
  timeRange?: 'day' | 'week' | 'month' | 'quarter' | 'year' | 'custom';
  startDate?: Date;
  endDate?: Date;
  refreshInterval?: number; // in seconds
}

interface Dashboard {
  id: string;
  name: string;
  description?: string;
  charts: DashboardChart[];
  filters: DashboardFilter[];
  layout: DashboardLayout;
  lastUpdated?: Date;
}

interface DashboardChart {
  id: string;
  title: string;
  type: 'bar' | 'line' | 'pie' | 'table' | 'statCard' | 'gauge' | 'trend';
  dataSource: string;
  dataQuery: string;
  parameters?: Record<string, any>;
  size: 'small' | 'medium' | 'large' | 'full';
  position: { x: number; y: number; width: number; height: number };
}

interface DashboardFilter {
  id: string;
  type: 'select' | 'multiSelect' | 'date' | 'dateRange' | 'text' | 'number';
  label: string;
  key: string;
  options?: { value: string; label: string }[];
  defaultValue?: any;
}

interface DashboardLayout {
  columns: number;
  padding: number;
  rowHeight: number;
}

const DashboardViewer: React.FC<DashboardViewerProps> = ({
  projectId,
  dashboardId,
  timeRange = 'month',
  startDate,
  endDate,
  refreshInterval,
}) => {
  const { 
    fetchDashboards, 
    fetchDashboard, 
    fetchDashboardData, 
    fetchDashboardChartData,
    generateDashboardPDF
  } = useResults();
  const { framework } = useFramework();
  
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [dashboards, setDashboards] = useState<{ id: string; name: string }[]>([]);
  const [dashboard, setDashboard] = useState<Dashboard | null>(null);
  const [selectedDashboardId, setSelectedDashboardId] = useState<string | undefined>(dashboardId);
  const [selectedTimeRange, setSelectedTimeRange] = useState<string>(timeRange);
  const [customStartDate, setCustomStartDate] = useState<Date | undefined>(startDate);
  const [customEndDate, setCustomEndDate] = useState<Date | undefined>(endDate);
  const [isFullscreen, setIsFullscreen] = useState<boolean>(false);
  const [activeFilters, setActiveFilters] = useState<Record<string, any>>({});
  const [chartData, setChartData] = useState<Record<string, any>>({});
  const [isAutoRefreshing, setIsAutoRefreshing] = useState<boolean>(!!refreshInterval);
  const [refreshRate, setRefreshRate] = useState<number>(refreshInterval || 60);
  
  const dashboardRef = useRef<HTMLDivElement>(null);
  const refreshTimerRef = useRef<NodeJS.Timeout | null>(null);
  const chartRefs = useRef<Record<string, HTMLDivElement | null>>({});
  const chartsRendered = useRef<Record<string, any>>({});
  
  // Fetch dashboards for the project
  useEffect(() => {
    if (projectId) {
      setLoading(true);
      setError(null);
      
      fetchDashboards(projectId)
        .then(data => {
          setDashboards(data);
          
          // If no dashboard is selected, select the first one
          if (!selectedDashboardId && data.length > 0) {
            setSelectedDashboardId(data[0].id);
          }
          
          setLoading(false);
        })
        .catch(err => {
          setError(err instanceof Error ? err.message : 'Error fetching dashboards');
          console.error('Error fetching dashboards:', err);
          setLoading(false);
        });
    }
  }, [projectId, fetchDashboards]);
  
  // Fetch selected dashboard
  useEffect(() => {
    if (selectedDashboardId) {
      setLoading(true);
      setError(null);
      
      fetchDashboard(selectedDashboardId)
        .then(data => {
          setDashboard(data);
          
          // Initialize active filters with default values
          const initialFilters: Record<string, any> = {};
          data.filters.forEach(filter => {
            if (filter.defaultValue !== undefined) {
              initialFilters[filter.key] = filter.defaultValue;
            }
          });
          setActiveFilters(initialFilters);
          
          setLoading(false);
        })
        .catch(err => {
          setError(err instanceof Error ? err.message : 'Error fetching dashboard');
          console.error('Error fetching dashboard:', err);
          setLoading(false);
        });
    }
  }, [selectedDashboardId, fetchDashboard]);
  
  // Convert time range to dates
  const getDateRangeFromTimeRange = useCallback((): { start: Date; end: Date } => {
    const now = new Date();
    let startDate = new Date();
    
    switch (selectedTimeRange) {
      case 'day':
        startDate.setDate(now.getDate() - 1);
        break;
      case 'week':
        startDate.setDate(now.getDate() - 7);
        break;
      case 'month':
        startDate.setMonth(now.getMonth() - 1);
        break;
      case 'quarter':
        startDate.setMonth(now.getMonth() - 3);
        break;
      case 'year':
        startDate.setFullYear(now.getFullYear() - 1);
        break;
      case 'custom':
        return {
          start: customStartDate || new Date(now.getFullYear(), now.getMonth() - 1, now.getDate()),
          end: customEndDate || now
        };
      default:
        startDate.setMonth(now.getMonth() - 1); // Default to 'month'
    }
    
    return { start: startDate, end: now };
  }, [selectedTimeRange, customStartDate, customEndDate]);
  
  // Fetch dashboard data
  const fetchData = useCallback(async () => {
    if (!dashboard) return;
    
    setLoading(true);
    
    try {
      // Get date range based on selected time range
      const { start, end } = getDateRangeFromTimeRange();
      
      // Fetch dashboard data
      const dashboardData = await fetchDashboardData(
        dashboard.id, 
        start, 
        end, 
        activeFilters
      );
      
      // Fetch individual chart data
      const chartDataPromises = dashboard.charts.map(chart => 
        fetchDashboardChartData(
          dashboard.id, 
          chart.id, 
          start, 
          end, 
          activeFilters
        )
        .then(data => ({ chartId: chart.id, data }))
      );
      
      const chartDataResults = await Promise.all(chartDataPromises);
      
      // Build chart data object
      const newChartData: Record<string, any> = {};
      chartDataResults.forEach(result => {
        newChartData[result.chartId] = result.data;
      });
      
      setChartData(newChartData);
      setLoading(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Error fetching dashboard data');
      console.error('Error fetching dashboard data:', err);
      setLoading(false);
    }
  }, [dashboard, getDateRangeFromTimeRange, activeFilters, fetchDashboardData, fetchDashboardChartData]);
  
  // Fetch data when dashboard, time range, or active filters change
  useEffect(() => {
    if (dashboard) {
      fetchData();
    }
  }, [dashboard, fetchData]);
  
  // Handle auto-refresh
  useEffect(() => {
    // Clear any existing timer
    if (refreshTimerRef.current) {
      clearInterval(refreshTimerRef.current);
      refreshTimerRef.current = null;
    }
    
    // Set up auto-refresh if enabled
    if (isAutoRefreshing && dashboard) {
      refreshTimerRef.current = setInterval(() => {
        fetchData();
      }, refreshRate * 1000);
    }
    
    // Clean up on unmount
    return () => {
      if (refreshTimerRef.current) {
        clearInterval(refreshTimerRef.current);
      }
    };
  }, [isAutoRefreshing, refreshRate, dashboard, fetchData]);
  
  // Render charts
  useEffect(() => {
    if (!dashboard || loading || Object.keys(chartData).length === 0) return;
    
    // Import recharts library
    import('recharts').then(({
      ResponsiveContainer, BarChart, LineChart, PieChart, AreaChart,
      Bar, Line, Pie, Area, XAxis, YAxis, CartesianGrid, Tooltip, Legend,
      Cell, RadialBarChart, RadialBar
    }) => {
      // Brand color palette - derived from primary brand color #C54B8C
      const COLORS = [
        '#C54B8C', // Primary brand color
        '#6E1B4D', // Darker shade
        '#E17AAF', // Lighter shade
        '#8A3363', // Medium shade
        '#F1A8C9', // Lightest shade
        '#4B1D36', // Desaturated dark
        '#A0386F', // Medium-dark
        '#DC94BA', // Medium-light
      ];
      
      // Clean up existing charts
      Object.values(chartsRendered.current).forEach(chart => {
        if (chart && typeof chart.destroy === 'function') {
          chart.destroy();
        }
      });
      
      // Clear charts object
      chartsRendered.current = {};
      
      // Render each chart
      dashboard.charts.forEach(chart => {
        const chartContainer = chartRefs.current[chart.id];
        if (!chartContainer) return;
        
        const data = chartData[chart.id];
        if (!data) return;
        
        // Render based on chart type
        switch (chart.type) {
          case 'bar':
            {
              const BarChartComponent = (
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={data} margin={{ top: 20, right: 30, left: 20, bottom: 50 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis 
                      dataKey={chart.parameters?.xAxis || 'category'} 
                      angle={-45} 
                      textAnchor="end" 
                      height={80} 
                    />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    {chart.parameters?.series?.map((series: string, index: number) => (
                      <Bar 
                        key={series} 
                        dataKey={series} 
                        fill={COLORS[index % COLORS.length]} 
                        stackId={chart.parameters?.stacked ? "stack" : undefined}
                      />
                    ))}
                  </BarChart>
                </ResponsiveContainer>
              );
              
              chartsRendered.current[chart.id] = { component: BarChartComponent };
            }
            break;
            
          case 'line':
            {
              const LineChartComponent = (
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={data} margin={{ top: 20, right: 30, left: 20, bottom: 50 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis 
                      dataKey={chart.parameters?.xAxis || 'category'} 
                      angle={-45} 
                      textAnchor="end" 
                      height={80}
                    />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    {chart.parameters?.series?.map((series: string, index: number) => (
                      <Line 
                        key={series} 
                        type="monotone" 
                        dataKey={series} 
                        stroke={COLORS[index % COLORS.length]} 
                        activeDot={{ r: 8 }}
                      />
                    ))}
                  </LineChart>
                </ResponsiveContainer>
              );
              
              chartsRendered.current[chart.id] = { component: LineChartComponent };
            }
            break;
            
          case 'pie':
            {
              const PieChartComponent = (
                <ResponsiveContainer width="100%" height="100%">
                  <PieChart margin={{ top: 20, right: 30, left: 20, bottom: 20 }}>
                    <Pie
                      data={data}
                      dataKey={chart.parameters?.value || 'value'}
                      nameKey={chart.parameters?.name || 'name'}
                      cx="50%"
                      cy="50%"
                      outerRadius="80%"
                      fill={COLORS[0]}
                      label={({ name, percent }) => chart.parameters?.showPercentage !== false
                        ? `${name}: ${(percent * 100).toFixed(0)}%`
                        : name
                      }
                    >
                      {data.map((_: any, index: number) => (
                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                      ))}
                    </Pie>
                    <Tooltip />
                    <Legend />
                  </PieChart>
                </ResponsiveContainer>
              );
              
              chartsRendered.current[chart.id] = { component: PieChartComponent };
            }
            break;
            
          case 'gauge':
            {
              // Convert data to format expected by RadialBarChart
              const value = typeof data === 'number' ? data : data.value || 0;
              const gaugeData = [{ name: 'value', value: Math.min(100, Math.max(0, value)) }];
              
              const GaugeChartComponent = (
                <ResponsiveContainer width="100%" height="100%">
                  <RadialBarChart
                    innerRadius="80%"
                    outerRadius="100%"
                    data={gaugeData}
                    startAngle={180}
                    endAngle={0}
                    cx="50%"
                    cy="100%"
                  >
                    <RadialBar
                      minAngle={15}
                      background
                      clockWise
                      dataKey="value"
                      cornerRadius={10}
                      fill="#C54B8C"
                    />
                    <text
                      x="50%"
                      y="90%"
                      textAnchor="middle"
                      dominantBaseline="middle"
                      className="chart-label"
                      fontSize="24"
                    >
                      {value.toFixed(chart.parameters?.decimals || 0)}
                      {chart.parameters?.unit && ` ${chart.parameters.unit}`}
                    </text>
                  </RadialBarChart>
                </ResponsiveContainer>
              );
              
              chartsRendered.current[chart.id] = { component: GaugeChartComponent };
            }
            break;
            
          case 'statCard':
            {
              // Stat cards are rendered directly in the component
              // We don't need to create a chart instance
            }
            break;
            
          case 'trend':
            {
              // For trend indicators, we show a small sparkline
              // and an arrow indicator
              const trend = data.trend || 0;
              const trendData = data.history || Array(10).fill(0).map((_, i) => ({ value: Math.random() * 100 }));
              
              const TrendComponent = (
                <div className="trend-container">
                  <div className="trend-value">
                    <span>{data.value !== undefined ? data.value.toFixed(chart.parameters?.decimals || 0) : 'N/A'}</span>
                    {data.unit && <span className="trend-unit">{data.unit}</span>}
                  </div>
                  
                  <div className="trend-indicator">
                    <div className={`trend-arrow ${trend > 0 ? 'up' : trend < 0 ? 'down' : 'neutral'}`}>
                      {trend > 0 ? '' : trend < 0 ? '' : ''}
                    </div>
                    <div className="trend-percentage">
                      {Math.abs(trend).toFixed(1)}%
                    </div>
                  </div>
                  
                  <div className="trend-sparkline">
                    <ResponsiveContainer width="100%" height="100%">
                      <LineChart data={trendData}>
                        <Line
                          type="monotone"
                          dataKey="value"
                          stroke={trend > 0 ? '#28a745' : trend < 0 ? '#dc3545' : '#6c757d'}
                          dot={false}
                          strokeWidth={2}
                        />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                </div>
              );
              
              chartsRendered.current[chart.id] = { component: TrendComponent };
            }
            break;
            
          case 'table':
            {
              const TableComponent = (
                <div className="table-container">
                  <table className="dashboard-table">
                    <thead>
                      <tr>
                        {chart.parameters?.columns?.map((column: { key: string; label: string }) => (
                          <th key={column.key}>{column.label}</th>
                        ))}
                      </tr>
                    </thead>
                    <tbody>
                      {data.map((row: any, rowIndex: number) => (
                        <tr key={rowIndex}>
                          {chart.parameters?.columns?.map((column: { key: string; format?: string }) => (
                            <td key={column.key}>
                              {formatTableCell(row[column.key], column.format)}
                            </td>
                          ))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              );
              
              chartsRendered.current[chart.id] = { component: TableComponent };
            }
            break;
            
          default:
            break;
        }
      });
      
      // Force a re-render
      setChartData({ ...chartData });
    }).catch(err => {
      console.error('Error loading chart library:', err);
    });
  }, [dashboard, chartData, loading]);
  
  // Format table cell based on format string
  const formatTableCell = (value: any, format?: string): string => {
    if (value === undefined || value === null) return '-';
    
    if (!format) return String(value);
    
    switch (format) {
      case 'number':
        return Number(value).toLocaleString();
      case 'percent':
        return `${(Number(value) * 100).toFixed(1)}%`;
      case 'date':
        return new Date(value).toLocaleDateString();
      case 'datetime':
        return new Date(value).toLocaleString();
      case 'duration':
        return formatDuration(Number(value));
      case 'currency':
        return `$${Number(value).toFixed(2)}`;
      default:
        if (format.startsWith('decimal:')) {
          const decimals = parseInt(format.split(':')[1], 10);
          return Number(value).toFixed(decimals);
        }
        return String(value);
    }
  };
  
  // Format duration in milliseconds to a readable string
  const formatDuration = (durationMs: number): string => {
    if (isNaN(durationMs)) return '--';
    
    const seconds = Math.floor(durationMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else if (seconds > 0) {
      return `${seconds}s`;
    } else {
      return `${durationMs}ms`;
    }
  };
  
  // Handle dashboard change
  const handleDashboardChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedDashboardId(e.target.value);
  };
  
  // Handle time range change
  const handleTimeRangeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedTimeRange(e.target.value);
  };
  
  // Handle filter change
  const handleFilterChange = (key: string, value: any) => {
    setActiveFilters(prev => ({
      ...prev,
      [key]: value
    }));
  };
  
  // Toggle fullscreen mode
  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      if (dashboardRef.current?.requestFullscreen) {
        dashboardRef.current.requestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  };
  
  // Listen for fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    
    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
    };
  }, []);
  
  // Export dashboard as PDF
  const handleExportPDF = async () => {
    if (!dashboard) return;
    
    try {
      const { start, end } = getDateRangeFromTimeRange();
      const pdfUrl = await generateDashboardPDF(dashboard.id, start, end, activeFilters);
      
      // Open the PDF in a new tab or download it
      window.open(pdfUrl, '_blank');
    } catch (err) {
      console.error('Error exporting dashboard as PDF:', err);
      setError('Failed to export dashboard as PDF. Please try again.');
    }
  };
  
  // Toggle auto-refresh
  const handleToggleAutoRefresh = () => {
    setIsAutoRefreshing(prev => !prev);
  };
  
  // Handle refresh rate change
  const handleRefreshRateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value, 10);
    if (!isNaN(value) && value > 0) {
      setRefreshRate(value);
    }
  };
  
  // Manual refresh
  const handleManualRefresh = () => {
    fetchData();
  };
  
  if (loading && !dashboard) {
    return (
      <div className="loading-container">
        <Spinner size="medium" />
        <p>Loading dashboard...</p>
      </div>
    );
  }
  
  if (error && !dashboard) {
    return (
      <Alert type="error" title="Error Loading Dashboard" onClose={() => setError(null)}>
        {error}
      </Alert>
    );
  }
  
  if (!dashboard) {
    return (
      <div className="no-dashboard">
        <p>No dashboard available.</p>
      </div>
    );
  }
  
  return (
    <div 
      className={`dashboard-viewer ${isFullscreen ? 'fullscreen' : ''}`}
      ref={dashboardRef}
    >
      <div className="dashboard-header">
        <div className="dashboard-title">
          <h2>{dashboard.name}</h2>
          {dashboard.description && <p className="dashboard-description">{dashboard.description}</p>}
        </div>
        
        <div className="dashboard-controls">
          {dashboards.length > 1 && (
            <Select
              label="Dashboard"
              value={selectedDashboardId || ''}
              onChange={handleDashboardChange}
              options={dashboards.map(d => ({
                value: d.id,
                label: d.name
              }))}
            />
          )}
          
          <Select
            label="Time Range"
            value={selectedTimeRange}
            onChange={handleTimeRangeChange}
            options={[
              { value: 'day', label: 'Last 24 Hours' },
              { value: 'week', label: 'Last 7 Days' },
              { value: 'month', label: 'Last 30 Days' },
              { value: 'quarter', label: 'Last 90 Days' },
              { value: 'year', label: 'Last 365 Days' },
              { value: 'custom', label: 'Custom Range' }
            ]}
          />
          
          {selectedTimeRange === 'custom' && (
            <div className="date-range-pickers">
              <DatePicker
                label="Start Date"
                value={customStartDate}
                onChange={setCustomStartDate}
              />
              <DatePicker
                label="End Date"
                value={customEndDate}
                onChange={setCustomEndDate}
                minDate={customStartDate}
              />
            </div>
          )}
          
          <div className="dashboard-actions">
            <div className="auto-refresh-controls">
              <label className="checkbox-container">
                <input
                  type="checkbox"
                  checked={isAutoRefreshing}
                  onChange={handleToggleAutoRefresh}
                />
                Auto-refresh
              </label>
              
              {isAutoRefreshing && (
                <Input
                  label="Interval (seconds)"
                  type="number"
                  min="5"
                  value={refreshRate.toString()}
                  onChange={handleRefreshRateChange}
                />
              )}
            </div>
            
            <Button onClick={handleManualRefresh} variant="outline" size="small">
              Refresh
            </Button>
            
            <Button onClick={toggleFullscreen} variant="outline" size="small">
              {isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}
            </Button>
            
            <Button onClick={handleExportPDF} variant="outline" size="small">
              Export PDF
            </Button>
          </div>
        </div>
      </div>
      
      {dashboard.filters.length > 0 && (
        <div className="dashboard-filters">
          {dashboard.filters.map(filter => (
            <div className="filter-item" key={filter.id}>
              {filter.type === 'select' && (
                <Select
                  label={filter.label}
                  value={activeFilters[filter.key] || ''}
                  onChange={(e) => handleFilterChange(filter.key, e.target.value)}
                  options={filter.options || []}
                />
              )}
              
              {filter.type === 'multiSelect' && (
                <Select
                  label={filter.label}
                  value={activeFilters[filter.key] || []}
                  onChange={(e) => handleFilterChange(filter.key, 
                    Array.from(e.target.selectedOptions, option => option.value)
                  )}
                  options={filter.options || []}
                  multiple
                />
              )}
              
              {filter.type === 'text' && (
                <Input
                  label={filter.label}
                  value={activeFilters[filter.key] || ''}
                  onChange={(e) => handleFilterChange(filter.key, e.target.value)}
                />
              )}
              
              {filter.type === 'number' && (
                <Input
                  label={filter.label}
                  type="number"
                  value={activeFilters[filter.key] || ''}
                  onChange={(e) => handleFilterChange(filter.key, e.target.value)}
                />
              )}
              
              {filter.type === 'date' && (
                <DatePicker
                  label={filter.label}
                  value={activeFilters[filter.key] ? new Date(activeFilters[filter.key]) : undefined}
                  onChange={(date) => handleFilterChange(filter.key, date)}
                />
              )}
              
              {filter.type === 'dateRange' && (
                <div className="date-range-filter">
                  <DatePicker
                    label={`${filter.label} (From)`}
                    value={activeFilters[`${filter.key}From`] ? new Date(activeFilters[`${filter.key}From`]) : undefined}
                    onChange={(date) => handleFilterChange(`${filter.key}From`, date)}
                  />
                  <DatePicker
                    label={`${filter.label} (To)`}
                    value={activeFilters[`${filter.key}To`] ? new Date(activeFilters[`${filter.key}To`]) : undefined}
                    onChange={(date) => handleFilterChange(`${filter.key}To`, date)}
                    minDate={activeFilters[`${filter.key}From`] ? new Date(activeFilters[`${filter.key}From`]) : undefined}
                  />
                </div>
              )}
            </div>
          ))}
        </div>
      )}
      
      {loading && (
        <div className="overlay-loading">
          <Spinner size="medium" />
          <p>Loading data...</p>
        </div>
      )}
      
      <div 
        className="dashboard-grid"
        style={{
          gridTemplateColumns: `repeat(${dashboard.layout.columns}, 1fr)`,
          gap: `${dashboard.layout.padding}px`,
        }}
      >
        {dashboard.charts.map(chart => {
          // Calculate grid position
          const gridStyle = {
            gridColumn: `span ${
              chart.size === 'small' ? 1 : 
              chart.size === 'medium' ? 2 : 
              chart.size === 'large' ? 3 : 
              dashboard.layout.columns
            }`,
            gridRow: `span ${
              chart.type === 'statCard' ? 1 :
              chart.type === 'trend' ? 1 :
              chart.size === 'small' ? 1 :
              chart.size === 'medium' ? 2 :
              chart.size === 'large' ? 3 : 4
            }`,
            minHeight: chart.type === 'statCard' || chart.type === 'trend' 
              ? 'auto'
              : `${dashboard.layout.rowHeight}px`,
          };
          
          return (
            <Card 
              key={chart.id} 
              className={`dashboard-chart ${chart.type} ${chart.size}`}
              style={gridStyle}
            >
              <div className="chart-header">
                <h3>{chart.title}</h3>
                
                {chart.type !== 'statCard' && chart.type !== 'trend' && (
                  <div className="chart-actions">
                    <Button 
                      onClick={() => {
                        // Export chart as image
                        const chartContainer = chartRefs.current[chart.id];
                        if (chartContainer) {
                          // Using html2canvas
                          import('html2canvas').then(({ default: html2canvas }) => {
                            html2canvas(chartContainer).then(canvas => {
                              const link = document.createElement('a');
                              link.download = `${chart.title.replace(/\s+/g, '_').toLowerCase()}_${new Date().toISOString().split('T')[0]}.png`;
                              link.href = canvas.toDataURL('image/png');
                              link.click();
                            });
                          }).catch(err => {
                            console.error('Error exporting chart:', err);
                          });
                        }
                      }}
                      variant="icon"
                      size="small"
                      title="Export as image"
                    >
                      <svg viewBox="0 0 24 24" width="16" height="16">
                        <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" fill="currentColor" />
                      </svg>
                    </Button>
                  </div>
                )}
              </div>
              
              <div 
                className="chart-content"
                ref={el => chartRefs.current[chart.id] = el}
              >
                {chartData[chart.id] ? (
                  chart.type === 'statCard' ? (
                    // Render stat card
                    <div className="stat-card">
                      <div className="stat-value">
                        {formatTableCell(
                          chartData[chart.id].value, 
                          chart.parameters?.format || 'number'
                        )}
                      </div>
                      {chartData[chart.id].label && (
                        <div className="stat-label">{chartData[chart.id].label}</div>
                      )}
                      {chartData[chart.id].change !== undefined && (
                        <div className={`stat-change ${
                          chartData[chart.id].change > 0 ? 'positive' :
                          chartData[chart.id].change < 0 ? 'negative' : 'neutral'
                        }`}>
                          {chartData[chart.id].change > 0 ? '' : 
                           chartData[chart.id].change < 0 ? '' : ''}
                          {Math.abs(chartData[chart.id].change).toFixed(1)}%
                        </div>
                      )}
                    </div>
                  ) : (
                    // Render other chart types
                    chartsRendered.current[chart.id]?.component || (
                      <div className="no-chart-data">
                        <p>Chart rendering...</p>
                      </div>
                    )
                  )
                ) : (
                  <div className="no-chart-data">
                    <p>No data available</p>
                  </div>
                )}
              </div>
            </Card>
          );
        })}
      </div>
      
      {dashboard.lastUpdated && (
        <div className="dashboard-footer">
          <p>Last updated: {new Date(dashboard.lastUpdated).toLocaleString()}</p>
        </div>
      )}
    </div>
  );
};

export default DashboardViewer;



src/components/export/ExportWizard.tsx
-------------------------------------------------------------

import React, { useState, useEffect, useCallback } from 'react';
import { useFramework } from '../../hooks/useFramework';
import Button from '../common/Button';
import Select from '../common/Select';
import Input from '../common/Input';
import Tabs from '../common/Tabs';
import Card from '../common/Card';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';
import Checkbox from '../common/Checkbox';
import TemplateEditor from './TemplateEditor';
import PipelineGenerator from './PipelineGenerator';
import ProjectStructurePreview from './ProjectStructurePreview';

interface ExportWizardProps {
  projectId?: string;
  onExportComplete?: (exportData: any) => void;
  initialValues?: ExportConfig;
}

export interface ExportConfig {
  framework: 'selenium-java' | 'selenium-typescript' | 'playwright-java' | 'playwright-typescript';
  approachType: 'testng' | 'bdd';
  outputFormat: 'maven' | 'gradle' | 'npm';
  language: 'java' | 'typescript';
  includeCI: boolean;
  ciPlatform?: 'azure' | 'jenkins' | 'github' | 'gitlab' | 'circle';
  options: {
    includeDockerfile: boolean;
    includeReadme: boolean;
    includeExamples: boolean;
    includeDependencies: boolean;
    configureReporting: boolean;
    selfContained: boolean;
    includeDataProviders: boolean;
    includeAI: boolean;
  };
  customOptions: Record<string, any>;
  outputPath?: string;
  packageName?: string;
  customTemplates?: Record<string, string>;
}

const defaultConfig: ExportConfig = {
  framework: 'selenium-java',
  approachType: 'testng',
  outputFormat: 'maven',
  language: 'java',
  includeCI: false,
  options: {
    includeDockerfile: true,
    includeReadme: true,
    includeExamples: true,
    includeDependencies: true,
    configureReporting: true,
    selfContained: true,
    includeDataProviders: false,
    includeAI: false
  },
  customOptions: {},
};

const ExportWizard: React.FC<ExportWizardProps> = ({
  projectId,
  onExportComplete,
  initialValues,
}) => {
  const { framework: currentFramework, setFramework } = useFramework();
  
  // Wizard state
  const [currentStep, setCurrentStep] = useState<number>(0);
  const [config, setConfig] = useState<ExportConfig>(initialValues || { ...defaultConfig });
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [previewAvailable, setPreviewAvailable] = useState<boolean>(false);
  const [exportResult, setExportResult] = useState<any>(null);
  const [previewData, setPreviewData] = useState<any>(null);
  
  // Tabs state
  const [activeTab, setActiveTab] = useState<'general' | 'options' | 'templates' | 'preview'>('general');
  
  // API hooks for export functionality
  const exportProject = async (exportConfig: ExportConfig): Promise<any> => {
    // This would be implemented using a real API call to the backend
    // For now, simulate the export process
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          const result = {
            success: true,
            exportPath: exportConfig.outputPath || '/exports/project',
            files: generateMockFileList(exportConfig),
            downloadUrl: '#',
            config: exportConfig
          };
          resolve(result);
        } catch (error) {
          reject(new Error('Failed to export project'));
        }
      }, 2000);
    });
  };
  
  const generateProjectPreview = async (exportConfig: ExportConfig): Promise<any> => {
    // This would be implemented using a real API call to the backend
    // For now, simulate the preview generation
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          const preview = {
            structure: generateMockFileStructure(exportConfig),
            templatePreview: {
              main: generateMockTemplatePreview(exportConfig, 'main'),
              readme: generateMockTemplatePreview(exportConfig, 'readme'),
              pipeline: generateMockTemplatePreview(exportConfig, 'pipeline')
            }
          };
          resolve(preview);
        } catch (error) {
          reject(new Error('Failed to generate project preview'));
        }
      }, 1000);
    });
  };
  
  // Mock data generators - would be replaced with real data from the API
  const generateMockFileList = (config: ExportConfig): string[] => {
    const files: string[] = [];
    
    // Base project structure
    if (config.language === 'java') {
      if (config.outputFormat === 'maven') {
        files.push('pom.xml');
      } else if (config.outputFormat === 'gradle') {
        files.push('build.gradle');
        files.push('settings.gradle');
      }
      
      files.push('src/main/java/com/example/package-info.java');
      files.push('src/test/java/com/example/BaseTest.java');
      
      if (config.approachType === 'testng') {
        files.push('src/test/java/com/example/LoginTest.java');
        files.push('src/test/resources/testng.xml');
      } else if (config.approachType === 'bdd') {
        files.push('src/test/java/com/example/stepdefs/LoginSteps.java');
        files.push('src/test/resources/features/login.feature');
      }
    } else if (config.language === 'typescript') {
      files.push('package.json');
      files.push('tsconfig.json');
      
      if (config.approachType === 'testng') {
        files.push('src/tests/LoginTest.ts');
      } else if (config.approachType === 'bdd') {
        files.push('src/steps/LoginSteps.ts');
        files.push('features/login.feature');
      }
    }
    
    // Common files
    files.push('README.md');
    files.push('.gitignore');
    
    // Optional files
    if (config.options.includeDockerfile) {
      files.push('Dockerfile');
      files.push('docker-compose.yml');
    }
    
    if (config.includeCI) {
      switch (config.ciPlatform) {
        case 'azure':
          files.push('azure-pipelines.yml');
          break;
        case 'jenkins':
          files.push('Jenkinsfile');
          break;
        case 'github':
          files.push('.github/workflows/test.yml');
          break;
        case 'gitlab':
          files.push('.gitlab-ci.yml');
          break;
        case 'circle':
          files.push('.circleci/config.yml');
          break;
      }
    }
    
    return files;
  };
  
  const generateMockFileStructure = (config: ExportConfig): any => {
    // Generate a hierarchical file structure
    const structure: any = {
      id: 'root',
      name: 'Project Root',
      children: []
    };
    
    const mockFileList = generateMockFileList(config);
    
    mockFileList.forEach(filePath => {
      const pathParts = filePath.split('/');
      let currentLevel = structure.children;
      
      pathParts.forEach((part, index) => {
        const isFile = index === pathParts.length - 1;
        const existingNode = currentLevel.find((node: any) => node.name === part);
        
        if (existingNode) {
          if (!isFile) {
            currentLevel = existingNode.children;
          }
        } else {
          const newNode = {
            id: `${pathParts.slice(0, index + 1).join('_')}`,
            name: part,
            ...(isFile ? { type: 'file' } : { type: 'directory', children: [] })
          };
          
          currentLevel.push(newNode);
          
          if (!isFile) {
            currentLevel = newNode.children;
          }
        }
      });
    });
    
    return structure;
  };
  
  const generateMockTemplatePreview = (config: ExportConfig, templateType: string): string => {
    switch (templateType) {
      case 'main':
        if (config.language === 'java') {
          return `package com.example;

import org.testng.annotations.Test;
import static org.testng.Assert.assertEquals;

public class LoginTest extends BaseTest {
    @Test
    public void testLogin() {
        // Test implementation
        driver.get("https://example.com/login");
        driver.findElement(By.id("username")).sendKeys("user");
        driver.findElement(By.id("password")).sendKeys("pass");
        driver.findElement(By.id("loginButton")).click();
        
        assertEquals(driver.getTitle(), "Dashboard");
    }
}`;
        } else {
          return `import { test } from '@testng/core';
import { expect } from '@testng/expect';

test('Login should work with valid credentials', async () => {
  await page.goto('https://example.com/login');
  await page.fill('#username', 'user');
  await page.fill('#password', 'pass');
  await page.click('#loginButton');
  
  expect(await page.title()).toBe('Dashboard');
});`;
        }
      
      case 'readme':
        return `# Test Automation Project

## Overview
This project contains automated tests for the application.

## Prerequisites
* ${config.language === 'java' ? 'Java 17' : 'Node.js 16+'}
* ${config.language === 'java' ? (config.outputFormat === 'maven' ? 'Maven 3.8+' : 'Gradle 7.0+') : 'npm 7+'}
* Chrome browser

## Setup
\`\`\`bash
${config.language === 'java' 
  ? (config.outputFormat === 'maven' ? 'mvn clean install' : './gradlew build') 
  : 'npm install'}
\`\`\`

## Running Tests
\`\`\`bash
${config.language === 'java'
  ? (config.outputFormat === 'maven' 
    ? (config.approachType === 'testng' ? 'mvn test' : 'mvn test -Dcucumber.filter.tags="@smoke"')
    : (config.approachType === 'testng' ? './gradlew test' : './gradlew cucumber'))
  : (config.approachType === 'testng' ? 'npm test' : 'npm run cucumber')}
\`\`\`
`;
      
      case 'pipeline':
        if (config.ciPlatform === 'github') {
          return `name: Test Automation

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    ${config.language === 'java' 
      ? '- uses: actions/setup-java@v3\n      with:\n        java-version: \'17\'\n        distribution: \'temurin\'' 
      : '- uses: actions/setup-node@v3\n      with:\n        node-version: 16'}
    - name: Install dependencies
      run: ${config.language === 'java' 
        ? (config.outputFormat === 'maven' ? 'mvn clean install -DskipTests' : './gradlew dependencies') 
        : 'npm ci'}
    - name: Run tests
      run: ${config.language === 'java'
        ? (config.outputFormat === 'maven' ? 'mvn test' : './gradlew test') 
        : 'npm test'}`;
        } else {
          return `# ${config.ciPlatform} pipeline configuration would be shown here`;
        }
      
      default:
        return '';
    }
  };
  
  // Effects to sync framework with context
  useEffect(() => {
    if (currentFramework) {
      // Parse the current framework setting to our export config format
      const [frameworkName, languageName] = currentFramework.split('-');
      
      setConfig(prev => ({
        ...prev,
        framework: currentFramework as ExportConfig['framework'],
        language: languageName as 'java' | 'typescript',
        outputFormat: languageName === 'java' ? 'maven' : 'npm'
      }));
    }
  }, [currentFramework]);
  
  // Generate preview when config changes
  useEffect(() => {
    const updatePreview = async () => {
      try {
        const preview = await generateProjectPreview(config);
        setPreviewData(preview);
        setPreviewAvailable(true);
      } catch (error) {
        console.error('Failed to generate preview:', error);
        setPreviewAvailable(false);
      }
    };
    
    updatePreview();
  }, [config]);
  
  // Framework-specific validations and options
  useEffect(() => {
    // Update output format based on language
    if (config.language === 'java') {
      setConfig(prev => ({
        ...prev,
        outputFormat: prev.outputFormat === 'npm' ? 'maven' : prev.outputFormat
      }));
    } else if (config.language === 'typescript') {
      setConfig(prev => ({
        ...prev,
        outputFormat: 'npm'
      }));
    }
  }, [config.language]);
  
  // Handlers for configuration changes
  const handleFrameworkChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const value = e.target.value as ExportConfig['framework'];
    const [frameworkName, languageName] = value.split('-');
    
    setConfig(prev => ({
      ...prev,
      framework: value,
      language: languageName as 'java' | 'typescript',
      outputFormat: languageName === 'java' ? 'maven' : 'npm'
    }));
    
    // Also update the global framework context
    setFramework(value);
  };
  
  const handleApproachTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setConfig(prev => ({
      ...prev,
      approachType: e.target.value as 'testng' | 'bdd'
    }));
  };
  
  const handleOutputFormatChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setConfig(prev => ({
      ...prev,
      outputFormat: e.target.value as 'maven' | 'gradle' | 'npm'
    }));
  };
  
  const handlePackageNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setConfig(prev => ({
      ...prev,
      packageName: e.target.value
    }));
  };
  
  const handleOutputPathChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setConfig(prev => ({
      ...prev,
      outputPath: e.target.value
    }));
  };
  
  const handleCIToggle = (checked: boolean) => {
    setConfig(prev => ({
      ...prev,
      includeCI: checked,
      ciPlatform: checked ? prev.ciPlatform || 'github' : undefined
    }));
  };
  
  const handleCIPlatformChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setConfig(prev => ({
      ...prev,
      ciPlatform: e.target.value as 'azure' | 'jenkins' | 'github' | 'gitlab' | 'circle'
    }));
  };
  
  const handleOptionChange = (option: keyof ExportConfig['options'], checked: boolean) => {
    setConfig(prev => ({
      ...prev,
      options: {
        ...prev.options,
        [option]: checked
      }
    }));
  };
  
  const handleCustomTemplateChange = (templateKey: string, content: string) => {
    setConfig(prev => ({
      ...prev,
      customTemplates: {
        ...prev.customTemplates,
        [templateKey]: content
      }
    }));
  };
  
  // Export process handler
  const handleExport = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await exportProject(config);
      setExportResult(result);
      
      if (onExportComplete) {
        onExportComplete(result);
      }
      
      setLoading(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error occurred during export');
      setLoading(false);
    }
  };
  
  // Navigation handlers
  const handleNext = () => {
    setCurrentStep(prev => Math.min(prev + 1, 3));
    
    // Update active tab based on step
    switch (currentStep + 1) {
      case 1:
        setActiveTab('options');
        break;
      case 2:
        setActiveTab('templates');
        break;
      case 3:
        setActiveTab('preview');
        break;
    }
  };
  
  const handleBack = () => {
    setCurrentStep(prev => Math.max(prev - 1, 0));
    
    // Update active tab based on step
    switch (currentStep - 1) {
      case 0:
        setActiveTab('general');
        break;
      case 1:
        setActiveTab('options');
        break;
      case 2:
        setActiveTab('templates');
        break;
    }
  };
  
  const handleTabChange = (tab: string) => {
    setActiveTab(tab as 'general' | 'options' | 'templates' | 'preview');
    
    // Update current step based on tab
    switch (tab) {
      case 'general':
        setCurrentStep(0);
        break;
      case 'options':
        setCurrentStep(1);
        break;
      case 'templates':
        setCurrentStep(2);
        break;
      case 'preview':
        setCurrentStep(3);
        break;
    }
  };
  
  // Render content for each tab
  const renderGeneralTab = () => (
    <div className="export-general">
      <Card>
        <h3>Basic Settings</h3>
        
        <div className="form-row">
          <Select
            label="Framework"
            value={config.framework}
            onChange={handleFrameworkChange}
            options={[
              { value: 'selenium-java', label: 'Selenium (Java)' },
              { value: 'selenium-typescript', label: 'Selenium (TypeScript)' },
              { value: 'playwright-java', label: 'Playwright (Java)' },
              { value: 'playwright-typescript', label: 'Playwright (TypeScript)' }
            ]}
          />
        </div>
        
        <div className="form-row">
          <Select
            label="Testing Approach"
            value={config.approachType}
            onChange={handleApproachTypeChange}
            options={[
              { value: 'testng', label: 'TestNG (Traditional)' },
              { value: 'bdd', label: 'BDD (Cucumber)' }
            ]}
          />
        </div>
        
        <div className="form-row">
          <Select
            label="Build System"
            value={config.outputFormat}
            onChange={handleOutputFormatChange}
            options={
              config.language === 'java' 
                ? [
                    { value: 'maven', label: 'Maven' },
                    { value: 'gradle', label: 'Gradle' }
                  ]
                : [
                    { value: 'npm', label: 'npm' }
                  ]
            }
            disabled={config.language === 'typescript'}
          />
        </div>
        
        <div className="form-row">
          <Input
            label={`Package Name ${config.language === 'java' ? '(Java)' : '(npm package)'}`}
            value={config.packageName || ''}
            onChange={handlePackageNameChange}
            placeholder={config.language === 'java' ? 'com.example.tests' : 'test-project'}
          />
        </div>
        
        <div className="form-row">
          <Input
            label="Output Path"
            value={config.outputPath || ''}
            onChange={handleOutputPathChange}
            placeholder="/path/to/export/directory"
          />
        </div>
      </Card>
      
      <Card>
        <h3>CI/CD Integration</h3>
        
        <div className="form-row">
          <Checkbox
            label="Include CI/CD Configuration"
            checked={config.includeCI}
            onChange={handleCIToggle}
          />
        </div>
        
        {config.includeCI && (
          <div className="form-row">
            <Select
              label="CI/CD Platform"
              value={config.ciPlatform || 'github'}
              onChange={handleCIPlatformChange}
              options={[
                { value: 'azure', label: 'Azure DevOps' },
                { value: 'jenkins', label: 'Jenkins' },
                { value: 'github', label: 'GitHub Actions' },
                { value: 'gitlab', label: 'GitLab CI' },
                { value: 'circle', label: 'CircleCI' }
              ]}
            />
          </div>
        )}
      </Card>
    </div>
  );
  
  const renderOptionsTab = () => (
    <div className="export-options">
      <Card>
        <h3>Project Options</h3>
        
        <div className="options-grid">
          <Checkbox
            label="Include Dockerfile"
            checked={config.options.includeDockerfile}
            onChange={(checked) => handleOptionChange('includeDockerfile', checked)}
            tooltip="Generate Dockerfile and docker-compose.yml for containerized execution"
          />
          
          <Checkbox
            label="Include README"
            checked={config.options.includeReadme}
            onChange={(checked) => handleOptionChange('includeReadme', checked)}
            tooltip="Generate a comprehensive README with setup and usage instructions"
          />
          
          <Checkbox
            label="Include Example Tests"
            checked={config.options.includeExamples}
            onChange={(checked) => handleOptionChange('includeExamples', checked)}
            tooltip="Include sample test implementations"
          />
          
          <Checkbox
            label="Include Dependencies"
            checked={config.options.includeDependencies}
            onChange={(checked) => handleOptionChange('includeDependencies', checked)}
            tooltip="Include all required libraries in the export (offline mode)"
          />
        </div>
      </Card>
      
      <Card>
        <h3>Framework Features</h3>
        
        <div className="options-grid">
          <Checkbox
            label="Configure Reporting"
            checked={config.options.configureReporting}
            onChange={(checked) => handleOptionChange('configureReporting', checked)}
            tooltip="Include custom HTML reporting configuration"
          />
          
          <Checkbox
            label="Self-Contained Project"
            checked={config.options.selfContained}
            onChange={(checked) => handleOptionChange('selfContained', checked)}
            tooltip="Include all CSTestForge libraries locally (no external dependencies)"
          />
          
          <Checkbox
            label="Include Data Providers"
            checked={config.options.includeDataProviders}
            onChange={(checked) => handleOptionChange('includeDataProviders', checked)}
            tooltip="Include data-driven testing capabilities"
          />
          
          <Checkbox
            label="Include AI Features"
            checked={config.options.includeAI}
            onChange={(checked) => handleOptionChange('includeAI', checked)}
            tooltip="Include Smart Locator and Self-Healing capabilities"
          />
        </div>
      </Card>
      
      {/* Advanced options would go here */}
    </div>
  );
  
  const renderTemplatesTab = () => (
    <div className="export-templates">
      <TemplateEditor
        framework={config.framework}
        approachType={config.approachType}
        outputFormat={config.outputFormat}
        templates={config.customTemplates || {}}
        onChange={handleCustomTemplateChange}
      />
    </div>
  );
  
  const renderPreviewTab = () => (
    <div className="export-preview">
      {previewAvailable ? (
        <ProjectStructurePreview
          structure={previewData.structure}
          templates={previewData.templatePreview}
          config={config}
        />
      ) : (
        <div className="loading-preview">
          <Spinner size="medium" />
          <p>Generating preview...</p>
        </div>
      )}
    </div>
  );
  
  // If export is complete, show result
  if (exportResult) {
    return (
      <div className="export-complete">
        <Card>
          <div className="export-success">
            <h2>Export Complete!</h2>
            <p>Your project has been successfully exported to:</p>
            <div className="export-path">{exportResult.exportPath}</div>
            
            <div className="export-actions">
              <Button variant="primary" onClick={() => window.open(exportResult.downloadUrl, '_blank')}>
                Download ZIP
              </Button>
              
              <Button variant="outline" onClick={() => setExportResult(null)}>
                Start New Export
              </Button>
            </div>
          </div>
        </Card>
        
        <Card>
          <h3>Exported Files ({exportResult.files.length})</h3>
          <div className="exported-files">
            {exportResult.files.map((file: string, index: number) => (
              <div key={index} className="exported-file">
                {file}
              </div>
            ))}
          </div>
        </Card>
      </div>
    );
  }
  
  return (
    <div className="export-wizard">
      <div className="wizard-header">
        <h2>Export Project</h2>
        
        <div className="wizard-progress">
          <div className={`progress-step ${currentStep >= 0 ? 'active' : ''} ${currentStep > 0 ? 'completed' : ''}`}>
            <div className="step-indicator">1</div>
            <div className="step-label">Project Settings</div>
          </div>
          <div className={`progress-step ${currentStep >= 1 ? 'active' : ''} ${currentStep > 1 ? 'completed' : ''}`}>
            <div className="step-indicator">2</div>
            <div className="step-label">Options</div>
          </div>
          <div className={`progress-step ${currentStep >= 2 ? 'active' : ''} ${currentStep > 2 ? 'completed' : ''}`}>
            <div className="step-indicator">3</div>
            <div className="step-label">Templates</div>
          </div>
          <div className={`progress-step ${currentStep >= 3 ? 'active' : ''}`}>
            <div className="step-indicator">4</div>
            <div className="step-label">Preview & Export</div>
          </div>
        </div>
      </div>
      
      {error && (
        <Alert type="error" title="Export Error" onClose={() => setError(null)}>
          {error}
        </Alert>
      )}
      
      <div className="wizard-content">
        <Tabs
          tabs={[
            { id: 'general', label: 'Project Settings' },
            { id: 'options', label: 'Options' },
            { id: 'templates', label: 'Templates' },
            { id: 'preview', label: 'Preview' }
          ]}
          activeTab={activeTab}
          onChange={handleTabChange}
        />
        
        <div className="tab-content">
          {activeTab === 'general' && renderGeneralTab()}
          {activeTab === 'options' && renderOptionsTab()}
          {activeTab === 'templates' && renderTemplatesTab()}
          {activeTab === 'preview' && renderPreviewTab()}
        </div>
      </div>
      
      <div className="wizard-actions">
        <Button
          onClick={handleBack}
          variant="outline"
          disabled={currentStep === 0}
        >
          Back
        </Button>
        
        {currentStep < 3 ? (
          <Button
            onClick={handleNext}
            variant="primary"
          >
            Next
          </Button>
        ) : (
          <Button
            onClick={handleExport}
            variant="primary"
            disabled={loading}
          >
            {loading ? 'Processing...' : 'Export Project'}
          </Button>
        )}
      </div>
      
      {loading && (
        <div className="export-loading-overlay">
          <Spinner size="large" />
          <p>Generating project files...</p>
        </div>
      )}
    </div>
  );
};

export default ExportWizard;


src/components/export/TemplateEditor.tsx
------------------------------------------------------

import React, { useState, useEffect, useCallback } from 'react';
import Button from '../common/Button';
import Select from '../common/Select';
import Card from '../common/Card';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';
import CodeEditor from '../common/CodeEditor';

interface TemplateEditorProps {
  framework: string;
  approachType: 'testng' | 'bdd';
  outputFormat: 'maven' | 'gradle' | 'npm';
  templates: Record<string, string>;
  onChange: (templateKey: string, content: string) => void;
}

interface TemplateDefinition {
  id: string;
  name: string;
  description: string;
  language: string;
  path: string;
  defaultContent: string;
  group: 'core' | 'config' | 'test' | 'docs' | 'ci';
}

interface TemplateGroup {
  id: string;
  name: string;
  templates: TemplateDefinition[];
}

const TemplateEditor: React.FC<TemplateEditorProps> = ({
  framework,
  approachType,
  outputFormat,
  templates,
  onChange,
}) => {
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [availableTemplates, setAvailableTemplates] = useState<TemplateDefinition[]>([]);
  const [templateGroups, setTemplateGroups] = useState<TemplateGroup[]>([]);
  const [selectedTemplateId, setSelectedTemplateId] = useState<string>('');
  const [selectedTemplate, setSelectedTemplate] = useState<TemplateDefinition | null>(null);
  const [editorContent, setEditorContent] = useState<string>('');
  const [unsavedChanges, setUnsavedChanges] = useState<boolean>(false);
  const [resetCounter, setResetCounter] = useState<number>(0);
  
  // Load available templates based on framework, approach, and output format
  useEffect(() => {
    const loadTemplates = async () => {
      setLoading(true);
      setError(null);
      
      try {
        // This would be a real API call to backend to get templates
        // Simulating API call with a timeout for demonstration
        const frameworkTemplates = await fetchTemplatesForFramework(framework, approachType, outputFormat);
        setAvailableTemplates(frameworkTemplates);
        
        // Group templates by category
        const groups = organizeTemplatesByGroup(frameworkTemplates);
        setTemplateGroups(groups);
        
        // Select first template by default
        if (frameworkTemplates.length > 0 && !selectedTemplateId) {
          setSelectedTemplateId(frameworkTemplates[0].id);
        }
        
        setLoading(false);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load templates');
        setLoading(false);
      }
    };
    
    loadTemplates();
  }, [framework, approachType, outputFormat]);
  
  // Update selected template when ID changes
  useEffect(() => {
    if (!selectedTemplateId || availableTemplates.length === 0) return;
    
    const template = availableTemplates.find(t => t.id === selectedTemplateId);
    if (template) {
      setSelectedTemplate(template);
      
      // Load content from custom templates if available, otherwise use default
      const content = templates[template.id] || template.defaultContent;
      setEditorContent(content);
      setUnsavedChanges(false);
    }
  }, [selectedTemplateId, availableTemplates, templates, resetCounter]);
  
  // Fetch templates from server
  const fetchTemplatesForFramework = async (
    framework: string,
    approachType: 'testng' | 'bdd',
    outputFormat: 'maven' | 'gradle' | 'npm'
  ): Promise<TemplateDefinition[]> => {
    // This would be a real API call to get templates from server
    // For demonstration, we're creating an array of template definitions
    
    // Extract framework and language from combined framework string
    const [frameworkName, language] = framework.split('-');
    
    // Base path for template files
    const basePath = `templates/projects/${frameworkName}/${language}/${approachType}/`;
    
    // Generate template definitions based on framework/language/approach
    const templates: TemplateDefinition[] = [];
    
    // Core files
    if (language === 'java') {
      if (outputFormat === 'maven') {
        templates.push({
          id: 'pom',
          name: 'Maven POM',
          description: 'Maven project configuration file',
          language: 'xml',
          path: `${basePath}pom.xml.template`,
          defaultContent: generateDefaultPomXml(frameworkName, approachType),
          group: 'config'
        });
      } else if (outputFormat === 'gradle') {
        templates.push({
          id: 'gradle',
          name: 'Gradle Build',
          description: 'Gradle build configuration file',
          language: 'groovy',
          path: `${basePath}build.gradle.template`,
          defaultContent: generateDefaultGradleBuild(frameworkName, approachType),
          group: 'config'
        });
      }
      
      templates.push({
        id: 'baseTest',
        name: 'Base Test Class',
        description: 'Base test class that all tests will extend',
        language: 'java',
        path: `${basePath}src/test/java/BaseTest.java.template`,
        defaultContent: generateBaseTestJava(frameworkName, approachType),
        group: 'core'
      });
      
      templates.push({
        id: 'basePage',
        name: 'Base Page Object',
        description: 'Base page object class for the Page Object Model',
        language: 'java',
        path: `${basePath}src/test/java/pages/BasePage.java.template`,
        defaultContent: generateBasePageJava(frameworkName),
        group: 'core'
      });
      
      if (approachType === 'testng') {
        templates.push({
          id: 'sampleTest',
          name: 'Sample Test',
          description: 'Sample test class',
          language: 'java',
          path: `${basePath}src/test/java/SampleTest.java.template`,
          defaultContent: generateSampleTestJava(frameworkName),
          group: 'test'
        });
        
        templates.push({
          id: 'testng-xml',
          name: 'TestNG Configuration',
          description: 'TestNG suite configuration file',
          language: 'xml',
          path: `${basePath}src/test/resources/testng.xml.template`,
          defaultContent: generateTestNGConfig(),
          group: 'config'
        });
      } else if (approachType === 'bdd') {
        templates.push({
          id: 'stepDef',
          name: 'Step Definitions',
          description: 'Base step definition class',
          language: 'java',
          path: `${basePath}src/test/java/stepdefs/BaseStepDef.java.template`,
          defaultContent: generateBaseStepDefJava(frameworkName),
          group: 'core'
        });
        
        templates.push({
          id: 'feature',
          name: 'Sample Feature',
          description: 'Sample Cucumber feature file',
          language: 'gherkin',
          path: `${basePath}src/test/resources/features/sample.feature.template`,
          defaultContent: generateSampleFeature(),
          group: 'test'
        });
      }
    } else { // TypeScript
      templates.push({
        id: 'package-json',
        name: 'Package JSON',
        description: 'NPM package configuration',
        language: 'json',
        path: `${basePath}package.json.template`,
        defaultContent: generatePackageJson(frameworkName, approachType),
        group: 'config'
      });
      
      templates.push({
        id: 'tsconfig',
        name: 'TypeScript Config',
        description: 'TypeScript configuration file',
        language: 'json',
        path: `${basePath}tsconfig.json.template`,
        defaultContent: generateTsConfig(),
        group: 'config'
      });
      
      templates.push({
        id: 'baseTest',
        name: 'Base Test Class',
        description: 'Base test setup file',
        language: 'typescript',
        path: `${basePath}src/tests/baseTest.ts.template`,
        defaultContent: generateBaseTestTs(frameworkName, approachType),
        group: 'core'
      });
      
      templates.push({
        id: 'basePage',
        name: 'Base Page Object',
        description: 'Base page object class for the Page Object Model',
        language: 'typescript',
        path: `${basePath}src/pages/BasePage.ts.template`,
        defaultContent: generateBasePageTs(frameworkName),
        group: 'core'
      });
      
      if (approachType === 'testng') {
        templates.push({
          id: 'sampleTest',
          name: 'Sample Test',
          description: 'Sample test file',
          language: 'typescript',
          path: `${basePath}src/tests/sampleTest.ts.template`,
          defaultContent: generateSampleTestTs(frameworkName),
          group: 'test'
        });
      } else if (approachType === 'bdd') {
        templates.push({
          id: 'stepDef',
          name: 'Step Definitions',
          description: 'Base step definition file',
          language: 'typescript',
          path: `${basePath}src/steps/baseSteps.ts.template`,
          defaultContent: generateBaseStepDefTs(frameworkName),
          group: 'test'
        });
        
        templates.push({
          id: 'feature',
          name: 'Sample Feature',
          description: 'Sample Cucumber feature file',
          language: 'gherkin',
          path: `${basePath}features/sample.feature.template`,
          defaultContent: generateSampleFeature(),
          group: 'test'
        });
      }
    }
    
    // Common templates for all frameworks
    templates.push({
      id: 'readme',
      name: 'README.md',
      description: 'Project documentation',
      language: 'markdown',
      path: `${basePath}README.md.template`,
      defaultContent: generateReadme(frameworkName, language, outputFormat, approachType),
      group: 'docs'
    });
    
    templates.push({
      id: 'gitignore',
      name: '.gitignore',
      description: 'Git ignore configuration',
      language: 'text',
      path: `${basePath}.gitignore.template`,
      defaultContent: generateGitignore(language),
      group: 'config'
    });
    
    templates.push({
      id: 'dockerfile',
      name: 'Dockerfile',
      description: 'Docker container configuration',
      language: 'dockerfile',
      path: `${basePath}Dockerfile.template`,
      defaultContent: generateDockerfile(frameworkName, language, outputFormat),
      group: 'config'
    });
    
    // CI Templates
    templates.push({
      id: 'github-actions',
      name: 'GitHub Actions',
      description: 'GitHub Actions workflow configuration',
      language: 'yaml',
      path: `${basePath}.github/workflows/test.yml.template`,
      defaultContent: generateGitHubActionsConfig(frameworkName, language, outputFormat, approachType),
      group: 'ci'
    });
    
    templates.push({
      id: 'azure-pipelines',
      name: 'Azure Pipelines',
      description: 'Azure DevOps pipeline configuration',
      language: 'yaml',
      path: `${basePath}azure-pipelines.yml.template`,
      defaultContent: generateAzurePipelinesConfig(frameworkName, language, outputFormat, approachType),
      group: 'ci'
    });
    
    // Simulate network latency
    await new Promise(resolve => setTimeout(resolve, 500));
    
    return templates;
  };
  
  // Organize templates into groups
  const organizeTemplatesByGroup = (templates: TemplateDefinition[]): TemplateGroup[] => {
    const groups: Record<string, TemplateGroup> = {
      'core': { id: 'core', name: 'Core Framework', templates: [] },
      'config': { id: 'config', name: 'Configuration', templates: [] },
      'test': { id: 'test', name: 'Test Examples', templates: [] },
      'docs': { id: 'docs', name: 'Documentation', templates: [] },
      'ci': { id: 'ci', name: 'CI/CD', templates: [] },
    };
    
    // Sort templates into groups
    templates.forEach(template => {
      if (groups[template.group]) {
        groups[template.group].templates.push(template);
      } else {
        groups.core.templates.push(template);
      }
    });
    
    // Filter out empty groups and convert to array
    return Object.values(groups).filter(group => group.templates.length > 0);
  };
  
  // Handle saving the edited template
  const handleSaveTemplate = () => {
    if (!selectedTemplate) return;
    
    onChange(selectedTemplate.id, editorContent);
    setUnsavedChanges(false);
  };
  
  // Handle resetting the template to default
  const handleResetTemplate = () => {
    if (!selectedTemplate) return;
    
    setEditorContent(selectedTemplate.defaultContent);
    onChange(selectedTemplate.id, selectedTemplate.defaultContent);
    setUnsavedChanges(false);
    setResetCounter(prev => prev + 1); // Force re-render
  };
  
  // Handle editor content changes
  const handleEditorChange = (content: string) => {
    setEditorContent(content);
    setUnsavedChanges(true);
  };
  
  // Handle template selection
  const handleTemplateChange = (templateId: string) => {
    // Confirm if there are unsaved changes
    if (unsavedChanges) {
      if (window.confirm('You have unsaved changes. Do you want to discard them?')) {
        setSelectedTemplateId(templateId);
      }
    } else {
      setSelectedTemplateId(templateId);
    }
  };
  
  // Render loading state
  if (loading) {
    return (
      <div className="template-editor-loading">
        <Spinner size="medium" />
        <p>Loading templates...</p>
      </div>
    );
  }
  
  // Render error state
  if (error) {
    return (
      <div className="template-editor-error">
        <Alert type="error" title="Error Loading Templates" onClose={() => setError(null)}>
          {error}
        </Alert>
      </div>
    );
  }
  
  return (
    <div className="template-editor">
      <div className="template-selector">
        <Card>
          <h3>Templates</h3>
          
          {templateGroups.map(group => (
            <div key={group.id} className="template-group">
              <div className="group-header">
                <h4>{group.name}</h4>
              </div>
              
              <div className="group-templates">
                {group.templates.map(template => (
                  <div 
                    key={template.id}
                    className={`template-item ${selectedTemplateId === template.id ? 'selected' : ''}`}
                    onClick={() => handleTemplateChange(template.id)}
                  >
                    <div className="template-name">{template.name}</div>
                    <div className="template-description">{template.description}</div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </Card>
      </div>
      
      <div className="template-content">
        {selectedTemplate && (
          <Card>
            <div className="template-editor-header">
              <div className="template-info">
                <h3>{selectedTemplate.name}</h3>
                <div className="template-path">{selectedTemplate.path}</div>
              </div>
              
              <div className="template-actions">
                <Button
                  onClick={handleResetTemplate}
                  variant="outline"
                  size="small"
                  disabled={!unsavedChanges && editorContent === selectedTemplate.defaultContent}
                >
                  Reset to Default
                </Button>
                
                <Button
                  onClick={handleSaveTemplate}
                  variant="primary"
                  size="small"
                  disabled={!unsavedChanges}
                >
                  Save Template
                </Button>
              </div>
            </div>
            
            <div className="template-editor-container">
              <CodeEditor
                value={editorContent}
                onChange={handleEditorChange}
                language={selectedTemplate.language}
                height="500px"
              />
            </div>
          </Card>
        )}
      </div>
    </div>
  );
};

// Template content generation functions - these would ideally be moved to a separate utility file

function generateDefaultPomXml(framework: string, approachType: string): string {
  return `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>test-automation</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <${framework}.version>${framework === 'selenium' ? '4.15.0' : '1.41.0'}</${framework}.version>
        <testng.version>7.8.0</testng.version>
        ${approachType === 'bdd' ? '<cucumber.version>7.15.0</cucumber.version>' : ''}
    </properties>

    <dependencies>
        <!-- ${framework.charAt(0).toUpperCase() + framework.slice(1)} Dependencies -->
        <dependency>
            <groupId>${framework === 'selenium' ? 'org.seleniumhq.selenium' : 'com.microsoft.playwright'}</groupId>
            <artifactId>${framework === 'selenium' ? 'selenium-java' : 'playwright'}</artifactId>
            <version>\${${framework}.version}</version>
        </dependency>

        <!-- Testing Framework -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>\${testng.version}</version>
            <scope>test</scope>
        </dependency>

        ${approachType === 'bdd' ? `
        <!-- Cucumber Dependencies -->
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-java</artifactId>
            <version>\${cucumber.version}</version>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-testng</artifactId>
            <version>\${cucumber.version}</version>
        </dependency>` : ''}
        
        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.9</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.4.14</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>\${maven.compiler.source}</source>
                    <target>\${maven.compiler.target}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.2.3</version>
                <configuration>
                    <suiteXmlFiles>
                        <suiteXmlFile>src/test/resources/testng.xml</suiteXmlFile>
                    </suiteXmlFiles>
                </configuration>
            </plugin>
            ${framework === 'playwright' ? `
            <plugin>
                <groupId>com.microsoft.playwright</groupId>
                <artifactId>playwright-maven-plugin</artifactId>
                <version>\${playwright.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>install</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>` : ''}
        </plugins>
    </build>
</project>`;
}

function generateDefaultGradleBuild(framework: string, approachType: string): string {
  return `plugins {
    id 'java'
    id 'org.gradle.test-retry' version '1.5.5'
}

group = 'com.example'
version = '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

ext {
    ${framework}Version = '${framework === 'selenium' ? '4.15.0' : '1.41.0'}'
    testngVersion = '7.8.0'
    ${approachType === 'bdd' ? 'cucumberVersion = \'7.15.0\'' : ''}
}

dependencies {
    // ${framework.charAt(0).toUpperCase() + framework.slice(1)} Dependencies
    implementation 'org.${framework === 'selenium' ? 'seleniumhq.selenium:selenium-java' : 'playwright:playwright-java'}:${framework === 'selenium' ? '${seleniumVersion}' : '${playwrightVersion}'}'
    
    // Testing Framework
    testImplementation "org.testng:testng:${testngVersion}"
    
    ${approachType === 'bdd' ? `
    // Cucumber Dependencies
    implementation "io.cucumber:cucumber-java:\${cucumberVersion}"
    implementation "io.cucumber:cucumber-testng:\${cucumberVersion}"` : ''}
    
    // Logging
    implementation 'org.slf4j:slf4j-api:2.0.9'
    implementation 'ch.qos.logback:logback-classic:1.4.14'
}

test {
    useTestNG() {
        suites 'src/test/resources/testng.xml'
    }
    
    retry {
        maxRetries = 2
        maxFailures = 10
    }
    
    testLogging {
        events "passed", "skipped", "failed"
    }
}

${framework === 'playwright' ? `
task installBrowsers(type: Exec) {
    commandLine 'npx', 'playwright', 'install'
}

test.dependsOn installBrowsers` : ''}
`;
}

function generateBaseTestJava(framework: string, approachType: string): string {
  if (framework === 'selenium') {
    return `package com.example;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;

import java.time.Duration;

public class BaseTest {
    protected WebDriver driver;
    
    @BeforeMethod
    public void setUp() {
        ChromeOptions options = new ChromeOptions();
        options.addArguments("--headless=new");
        options.addArguments("--no-sandbox");
        options.addArguments("--disable-dev-shm-usage");
        
        driver = new ChromeDriver(options);
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        driver.manage().window().maximize();
    }
    
    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
}`;
  } else { // Playwright
    return `package com.example;

import com.microsoft.playwright.Browser;
import com.microsoft.playwright.BrowserContext;
import com.microsoft.playwright.BrowserType;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Playwright;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;

public class BaseTest {
    protected Playwright playwright;
    protected Browser browser;
    protected BrowserContext context;
    protected Page page;
    
    @BeforeMethod
    public void setUp() {
        playwright = Playwright.create();
        browser = playwright.chromium().launch(new BrowserType.LaunchOptions()
                .setHeadless(true));
        context = browser.newContext();
        page = context.newPage();
    }
    
    @AfterMethod
    public void tearDown() {
        if (page != null) {
            page.close();
        }
        if (context != null) {
            context.close();
        }
        if (browser != null) {
            browser.close();
        }
        if (playwright != null) {
            playwright.close();
        }
    }
}`;
  }
}

function generateBasePageJava(framework: string): string {
  if (framework === 'selenium') {
    return `package com.example.pages;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;

public class BasePage {
    protected WebDriver driver;
    protected WebDriverWait wait;
    
    public BasePage(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }
    
    protected WebElement waitForElement(By locator) {
        return wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
    }
    
    protected WebElement waitForElementToBeClickable(By locator) {
        return wait.until(ExpectedConditions.elementToBeClickable(locator));
    }
    
    protected void click(By locator) {
        waitForElementToBeClickable(locator).click();
    }
    
    protected void type(By locator, String text) {
        WebElement element = waitForElement(locator);
        element.clear();
        element.sendKeys(text);
    }
    
    protected String getText(By locator) {
        return waitForElement(locator).getText();
    }
    
    protected boolean isElementDisplayed(By locator) {
        try {
            return waitForElement(locator).isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
}`;
  } else { // Playwright
    return `package com.example.pages;

import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.WaitForSelectorState;

public class BasePage {
    protected Page page;
    
    public BasePage(Page page) {
        this.page = page;
    }
    
    protected Locator getElement(String selector) {
        return page.locator(selector);
    }
    
    protected void click(String selector) {
        getElement(selector).click();
    }
    
    protected void type(String selector, String text) {
        getElement(selector).fill(text);
    }
    
    protected String getText(String selector) {
        return getElement(selector).textContent();
    }
    
    protected void waitForElement(String selector) {
        page.waitForSelector(selector, new Page.WaitForSelectorOptions()
                .setState(WaitForSelectorState.VISIBLE));
    }
    
    protected boolean isElementVisible(String selector) {
        return getElement(selector).isVisible();
    }
}`;
  }
}

function generateSampleTestJava(framework: string): string {
  if (framework === 'selenium') {
    return `package com.example;

import com.example.pages.LoginPage;
import org.testng.annotations.Test;
import static org.testng.Assert.assertTrue;

public class LoginTest extends BaseTest {
    
    @Test
    public void testSuccessfulLogin() {
        LoginPage loginPage = new LoginPage(driver);
        loginPage.open();
        loginPage.login("testuser", "password");
        
        assertTrue(loginPage.isLoginSuccessful(), "Login was not successful");
    }
    
    @Test
    public void testFailedLogin() {
        LoginPage loginPage = new LoginPage(driver);
        loginPage.open();
        loginPage.login("testuser", "wrongpassword");
        
        assertTrue(loginPage.isErrorMessageDisplayed(), "Error message not displayed");
    }
}`;
  } else { // Playwright
    return `package com.example;

import com.example.pages.LoginPage;
import org.testng.annotations.Test;
import static org.testng.Assert.assertTrue;

public class LoginTest extends BaseTest {
    
    @Test
    public void testSuccessfulLogin() {
        LoginPage loginPage = new LoginPage(page);
        loginPage.open();
        loginPage.login("testuser", "password");
        
        assertTrue(loginPage.isLoginSuccessful(), "Login was not successful");
    }
    
    @Test
    public void testFailedLogin() {
        LoginPage loginPage = new LoginPage(page);
        loginPage.open();
        loginPage.login("testuser", "wrongpassword");
        
        assertTrue(loginPage.isErrorMessageDisplayed(), "Error message not displayed");
    }
}`;
  }
}

function generateBaseStepDefJava(framework: string): string {
  if (framework === 'selenium') {
    return `package com.example.stepdefs;

import io.cucumber.java.After;
import io.cucumber.java.Before;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

import java.time.Duration;

public class BaseStepDef {
    protected WebDriver driver;
    
    @Before
    public void setUp() {
        ChromeOptions options = new ChromeOptions();
        options.addArguments("--headless=new");
        options.addArguments("--no-sandbox");
        options.addArguments("--disable-dev-shm-usage");
        
        driver = new ChromeDriver(options);
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
        driver.manage().window().maximize();
    }
    
    @After
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }
    
    @Given("I open the login page")
    public void iOpenTheLoginPage() {
        driver.get("https://example.com/login");
    }
    
    @When("I enter username {string} and password {string}")
    public void iEnterUsernameAndPassword(String username, String password) {
        // Implementation will go here
    }
    
    @When("I click the login button")
    public void iClickTheLoginButton() {
        // Implementation will go here
    }
    
    @Then("I should be logged in successfully")
    public void iShouldBeLoggedInSuccessfully() {
        // Implementation will go here
    }
    
    @Then("I should see an error message")
    public void iShouldSeeAnErrorMessage() {
        // Implementation will go here
    }
}`;
  } else { // Playwright
    return `package com.example.stepdefs;

import com.microsoft.playwright.Browser;
import com.microsoft.playwright.BrowserContext;
import com.microsoft.playwright.BrowserType;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Playwright;
import io.cucumber.java.After;
import io.cucumber.java.Before;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;

public class BaseStepDef {
    protected Playwright playwright;
    protected Browser browser;
    protected BrowserContext context;
    protected Page page;
    
    @Before
    public void setUp() {
        playwright = Playwright.create();
        browser = playwright.chromium().launch(new BrowserType.LaunchOptions()
                .setHeadless(true));
        context = browser.newContext();
        page = context.newPage();
    }
    
    @After
    public void tearDown() {
        if (page != null) {
            page.close();
        }
        if (context != null) {
            context.close();
        }
        if (browser != null) {
            browser.close();
        }
        if (playwright != null) {
            playwright.close();
        }
    }
    
    @Given("I open the login page")
    public void iOpenTheLoginPage() {
        page.navigate("https://example.com/login");
    }
    
    @When("I enter username {string} and password {string}")
    public void iEnterUsernameAndPassword(String username, String password) {
        page.fill("#username", username);
        page.fill("#password", password);
    }
    
    @When("I click the login button")
    public void iClickTheLoginButton() {
        page.click("#loginButton");
    }
    
    @Then("I should be logged in successfully")
    public void iShouldBeLoggedInSuccessfully() {
        // Implementation will go here
    }
    
    @Then("I should see an error message")
    public void iShouldSeeAnErrorMessage() {
        // Implementation will go here
    }
}`;
  }
}

function generateBaseTestTs(framework: string, approachType: string): string {
  if (framework === 'selenium') {
    return `import { Builder, WebDriver } from 'selenium-webdriver';
import { Options } from 'selenium-webdriver/chrome';

export class BaseTest {
  protected driver: WebDriver;

  async setUp(): Promise<void> {
    const options = new Options()
      .headless()
      .addArguments('--no-sandbox')
      .addArguments('--disable-dev-shm-usage');

    this.driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();

    await this.driver.manage().window().maximize();
    await this.driver.manage().setTimeouts({ implicit: 10000 });
  }

  async tearDown(): Promise<void> {
    if (this.driver) {
      await this.driver.quit();
    }
  }
}`;
  } else { // Playwright
    return `import { Browser, BrowserContext, chromium, Page } from 'playwright';

export class BaseTest {
  protected browser: Browser;
  protected context: BrowserContext;
  protected page: Page;

  async setUp(): Promise<void> {
    this.browser = await chromium.launch({
      headless: true
    });
    this.context = await this.browser.newContext();
    this.page = await this.context.newPage();
  }

  async tearDown(): Promise<void> {
    await this.page?.close();
    await this.context?.close();
    await this.browser?.close();
  }
}`;
  }
}

function generateBasePageTs(framework: string): string {
  if (framework === 'selenium') {
    return `import { WebDriver, By, WebElement, until } from 'selenium-webdriver';

export class BasePage {
  protected driver: WebDriver;

  constructor(driver: WebDriver) {
    this.driver = driver;
  }

  protected async waitForElement(locator: By): Promise<WebElement> {
    return await this.driver.wait(until.elementLocated(locator), 10000);
  }

  protected async waitForElementToBeClickable(locator: By): Promise<WebElement> {
    return await this.driver.wait(until.elementIsVisible(await this.driver.findElement(locator)), 10000);
  }

  protected async click(locator: By): Promise<void> {
    const element = await this.waitForElementToBeClickable(locator);
    await element.click();
  }

  protected async type(locator: By, text: string): Promise<void> {
    const element = await this.waitForElement(locator);
    await element.clear();
    await element.sendKeys(text);
  }

  protected async getText(locator: By): Promise<string> {
    const element = await this.waitForElement(locator);
    return await element.getText();
  }

  protected async isElementDisplayed(locator: By): Promise<boolean> {
    try {
      const element = await this.waitForElement(locator);
      return await element.isDisplayed();
    } catch (e) {
      return false;
    }
  }
}`;
  } else { // Playwright
    return `import { Page, Locator } from 'playwright';

export class BasePage {
  protected page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  protected getElement(selector: string): Locator {
    return this.page.locator(selector);
  }

  protected async click(selector: string): Promise<void> {
    await this.getElement(selector).click();
  }

  protected async type(selector: string, text: string): Promise<void> {
    await this.getElement(selector).fill(text);
  }

  protected async getText(selector: string): Promise<string> {
    return await this.getElement(selector).textContent() || '';
  }

  protected async waitForElement(selector: string): Promise<void> {
    await this.page.waitForSelector(selector, { state: 'visible' });
  }

  protected async isElementVisible(selector: string): Promise<boolean> {
    return await this.getElement(selector).isVisible();
  }
}`;
  }
}

function generateSampleTestTs(framework: string): string {
  if (framework === 'selenium') {
    return `import { describe, it, beforeEach, afterEach } from 'mocha';
import { expect } from 'chai';
import { By } from 'selenium-webdriver';
import { BaseTest } from './baseTest';

class LoginTest extends BaseTest {
  async open(): Promise<void> {
    await this.driver.get('https://example.com/login');
  }

  async login(username: string, password: string): Promise<void> {
    await this.driver.findElement(By.id('username')).sendKeys(username);
    await this.driver.findElement(By.id('password')).sendKeys(password);
    await this.driver.findElement(By.id('loginButton')).click();
  }

  async isLoginSuccessful(): Promise<boolean> {
    try {
      await this.driver.wait(
        until.elementLocated(By.css('.dashboard')),
        5000
      );
      return true;
    } catch (e) {
      return false;
    }
  }

  async isErrorMessageDisplayed(): Promise<boolean> {
    try {
      await this.driver.wait(
        until.elementLocated(By.css('.error-message')),
        5000
      );
      return true;
    } catch (e) {
      return false;
    }
  }
}

describe('Login Tests', () => {
  let loginTest: LoginTest;

  beforeEach(async () => {
    loginTest = new LoginTest();
    await loginTest.setUp();
  });

  afterEach(async () => {
    await loginTest.tearDown();
  });

  it('should login successfully with valid credentials', async () => {
    await loginTest.open();
    await loginTest.login('testuser', 'password');
    const isSuccess = await loginTest.isLoginSuccessful();
    expect(isSuccess).to.be.true;
  });

  it('should show error message with invalid credentials', async () => {
    await loginTest.open();
    await loginTest.login('testuser', 'wrongpassword');
    const hasError = await loginTest.isErrorMessageDisplayed();
    expect(hasError).to.be.true;
  });
});`;
  } else { // Playwright
    return `import { test, expect } from '@playwright/test';
import { BaseTest } from './baseTest';

class LoginTest extends BaseTest {
  async open(): Promise<void> {
    await this.page.goto('https://example.com/login');
  }

  async login(username: string, password: string): Promise<void> {
    await this.page.fill('#username', username);
    await this.page.fill('#password', password);
    await this.page.click('#loginButton');
  }

  async isLoginSuccessful(): Promise<boolean> {
    try {
      await this.page.waitForSelector('.dashboard', { state: 'visible', timeout: 5000 });
      return true;
    } catch (e) {
      return false;
    }
  }

  async isErrorMessageDisplayed(): Promise<boolean> {
    try {
      await this.page.waitForSelector('.error-message', { state: 'visible', timeout: 5000 });
      return true;
    } catch (e) {
      return false;
    }
  }
}

test.describe('Login Tests', () => {
  let loginTest: LoginTest;

  test.beforeEach(async ({ page }) => {
    loginTest = new LoginTest();
    await loginTest.setUp();
  });

  test.afterEach(async () => {
    await loginTest.tearDown();
  });

  test('should login successfully with valid credentials', async () => {
    await loginTest.open();
    await loginTest.login('testuser', 'password');
    const isSuccess = await loginTest.isLoginSuccessful();
    expect(isSuccess).toBeTruthy();
  });

  test('should show error message with invalid credentials', async () => {
    await loginTest.open();
    await loginTest.login('testuser', 'wrongpassword');
    const hasError = await loginTest.isErrorMessageDisplayed();
    expect(hasError).toBeTruthy();
  });
});`;
  }
}

function generateBaseStepDefTs(framework: string): string {
  if (framework === 'selenium') {
    return `import { Given, When, Then, Before, After } from '@cucumber/cucumber';
import { Builder, By, WebDriver } from 'selenium-webdriver';
import { Options } from 'selenium-webdriver/chrome';
import { expect } from 'chai';

let driver: WebDriver;

Before(async function() {
  const options = new Options()
    .headless()
    .addArguments('--no-sandbox')
    .addArguments('--disable-dev-shm-usage');

  driver = await new Builder()
    .forBrowser('chrome')
    .setChromeOptions(options)
    .build();

  await driver.manage().window().maximize();
  await driver.manage().setTimeouts({ implicit: 10000 });
});

After(async function() {
  if (driver) {
    await driver.quit();
  }
});

Given('I open the login page', async function() {
  await driver.get('https://example.com/login');
});

When('I enter username {string} and password {string}', async function(username, password) {
  await driver.findElement(By.id('username')).sendKeys(username);
  await driver.findElement(By.id('password')).sendKeys(password);
});

When('I click the login button', async function() {
  await driver.findElement(By.id('loginButton')).click();
});

Then('I should be logged in successfully', async function() {
  try {
    await driver.wait(
      until.elementLocated(By.css('.dashboard')),
      5000
    );
    expect(true).to.be.true;
  } catch (e) {
    expect.fail('Login was not successful');
  }
});

Then('I should see an error message', async function() {
  try {
    await driver.wait(
      until.elementLocated(By.css('.error-message')),
      5000
    );
    expect(true).to.be.true;
  } catch (e) {
    expect.fail('Error message was not displayed');
  }
});`;
  } else { // Playwright
    return `import { Given, When, Then, Before, After } from '@cucumber/cucumber';
import { Browser, BrowserContext, chromium, Page, expect } from '@playwright/test';

let browser: Browser;
let context: BrowserContext;
let page: Page;

Before(async function() {
  browser = await chromium.launch({ headless: true });
  context = await browser.newContext();
  page = await context.newPage();
});

After(async function() {
  await page?.close();
  await context?.close();
  await browser?.close();
});

Given('I open the login page', async function() {
  await page.goto('https://example.com/login');
});

When('I enter username {string} and password {string}', async function(username, password) {
  await page.fill('#username', username);
  await page.fill('#password', password);
});

When('I click the login button', async function() {
  await page.click('#loginButton');
});

Then('I should be logged in successfully', async function() {
  try {
    await page.waitForSelector('.dashboard', { state: 'visible', timeout: 5000 });
  } catch (e) {
    throw new Error('Login was not successful');
  }
});

Then('I should see an error message', async function() {
  try {
    await page.waitForSelector('.error-message', { state: 'visible', timeout: 5000 });
  } catch (e) {
    throw new Error('Error message was not displayed');
  }
});`;
  }
}

function generateSampleFeature(): string {
  return `Feature: User Login
  As a user
  I want to log in to the application
  So that I can access my account

  Scenario: Successful login with valid credentials
    Given I open the login page
    When I enter username "testuser" and password "password"
    And I click the login button
    Then I should be logged in successfully

  Scenario: Failed login with invalid credentials
    Given I open the login page
    When I enter username "testuser" and password "wrongpassword"
    And I click the login button
    Then I should see an error message`;
}

function generatePackageJson(framework: string, approachType: string): string {
  return `{
  "name": "test-automation",
  "version": "1.0.0",
  "description": "Test automation project using ${framework} and ${approachType === 'testng' ? 'Mocha/Chai' : 'Cucumber'}",
  "main": "index.js",
  "scripts": {
    "test": "${approachType === 'testng' ? 'mocha --require ts-node/register "src/tests/**/*.ts"' : 'cucumber-js --require "src/steps/**/*.ts"'}",
    "build": "tsc",
    "lint": "eslint . --ext .ts"
  },
  "keywords": [
    "${framework}",
    "testing",
    "automation",
    "${approachType}"
  ],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/chai": "^4.3.9",
    "@types/mocha": "^10.0.4",
    "@types/node": "^20.9.4",
    ${framework === 'selenium' ? '"@types/selenium-webdriver": "^4.1.19",' : ''}
    "@typescript-eslint/eslint-plugin": "^6.12.0",
    "@typescript-eslint/parser": "^6.12.0",
    "chai": "^4.3.10",
    ${approachType === 'bdd' ? '"@cucumber/cucumber": "^10.0.1",' : ''}
    "eslint": "^8.54.0",
    "mocha": "^10.2.0",
    "ts-node": "^10.9.1",
    "typescript": "^5.3.2"
  },
  "dependencies": {
    ${framework === 'selenium' ? 
    '"selenium-webdriver": "^4.15.0"' : 
    '"@playwright/test": "^1.41.0"'}
  }
}`;
}

function generateTsConfig(): string {
  return `{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules"
  ]
}`;
}

function generateTestNGConfig(): string {
  return `<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
<suite name="Test Suite" verbose="1">
  <test name="Regression Tests">
    <packages>
      <package name="com.example.*" />
    </packages>
  </test>
</suite>`;
}

function generateReadme(framework: string, language: string, outputFormat: string, approachType: string): string {
  return `# Test Automation Project

## Overview
This project contains automated tests for the application, using ${framework.charAt(0).toUpperCase() + framework.slice(1)} with ${approachType === 'testng' ? 'TestNG' : 'Cucumber'} in ${language.charAt(0).toUpperCase() + language.slice(1)}.

## Prerequisites
* ${language === 'java' ? 'Java 17' : 'Node.js 16+'}
* ${language === 'java' ? (outputFormat === 'maven' ? 'Maven 3.8+' : 'Gradle 7.0+') : 'npm 7+'}
* Chrome browser

## Setup
\`\`\`bash
${language === 'java' 
  ? (outputFormat === 'maven' ? 'mvn clean install' : './gradlew build') 
  : 'npm install'}
\`\`\`

## Running Tests
\`\`\`bash
${language === 'java'
  ? (outputFormat === 'maven' 
    ? (approachType === 'testng' ? 'mvn test' : 'mvn test -Dcucumber.filter.tags="@smoke"')
    : (approachType === 'testng' ? './gradlew test' : './gradlew cucumber'))
  : (approachType === 'testng' ? 'npm test' : 'npm run cucumber')}
\`\`\`

## Project Structure
\`\`\`
${language === 'java'
  ? `src/
   main/java/
      com/example/
   test/
       java/
          com/example/
              ${approachType === 'testng' ? 'BaseTest.java' : 'stepdefs/'}
              pages/
       resources/
          ${approachType === 'testng' ? ' testng.xml' : ' features/'}`
  : `src/
   pages/
      BasePage.ts
   ${approachType === 'testng' ? 'tests/' : 'steps/'}
      ${approachType === 'testng' ? 'baseTest.ts' : 'baseSteps.ts'}
  ${approachType === 'bdd' ? ' features/' : ''}`}
\`\`\`

## Configuration
${language === 'java'
  ? (outputFormat === 'maven' 
    ? 'Configuration is managed in the pom.xml file.' 
    : 'Configuration is managed in the build.gradle file.')
  : 'Configuration is managed in the package.json and tsconfig.json files.'
}

## Additional Information
* Tests are run in headless mode by default
* Screenshots are captured on test failures
* HTML reports are generated after test execution
`;
}

function generateGitignore(language: string): string {
  return `# IDE files
.idea/
*.iml
.vscode/
.project
.classpath
.settings/

# Build outputs
${language === 'java' ? 'target/\nbuild/\n.gradle/\nbin/' : 'node_modules/\ndist/\npackage-lock.json\nyarn.lock'}

# Test outputs
test-output/
reports/
.allure/
allure-results/
screenshots/
videos/

# Logs
logs/
*.log
npm-debug.log*

# OS-specific
.DS_Store
Thumbs.db
`;
}

function generateDockerfile(framework: string, language: string, outputFormat: string): string {
  if (language === 'java') {
    return `FROM eclipse-temurin:17-jdk

WORKDIR /app

# Install Chrome
RUN apt-get update && apt-get install -y wget gnupg2 unzip
RUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -
RUN echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google.list
RUN apt-get update && apt-get install -y google-chrome-stable

# Install ChromeDriver
RUN CHROME_VERSION=$(google-chrome --version | grep -oE "[0-9]+\\.[0-9]+\\.[0-9]+" | awk -F\\. '{print $1}') && \\
    CHROMEDRIVER_VERSION=$(curl -s "https://chromedriver.storage.googleapis.com/LATEST_RELEASE_$CHROME_VERSION") && \\
    wget -q "https://chromedriver.storage.googleapis.com/$CHROMEDRIVER_VERSION/chromedriver_linux64.zip" && \\
    unzip chromedriver_linux64.zip && \\
    mv chromedriver /usr/bin/chromedriver && \\
    chmod +x /usr/bin/chromedriver && \\
    rm chromedriver_linux64.zip

${framework === 'playwright' ? '# Install Playwright browsers\nRUN apt-get install -y libglib2.0-0 libnss3 libnspr4 libatk1.0-0 libatk-bridge2.0-0 libcups2 libdrm2 libdbus-1-3 libxkbcommon0 libxcomposite1 libxdamage1 libxfixes3 libxrandr2 libgbm1 libasound2 libatspi2.0-0 libxshmfence1' : ''}

# Copy project files
COPY . .

# Build the project
${outputFormat === 'maven' 
  ? 'RUN ./mvnw clean package -DskipTests' 
  : 'RUN ./gradlew build -x test'}

# Set entry point
ENTRYPOINT ["${outputFormat === 'maven' ? 'mvn' : './gradlew'}", "test"]
`;
  } else { // TypeScript
    return `FROM node:18-slim

WORKDIR /app

# Install Chrome
RUN apt-get update && apt-get install -y wget gnupg2
RUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -
RUN echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google.list
RUN apt-get update && apt-get install -y google-chrome-stable

${framework === 'playwright' ? '# Install Playwright dependencies\nRUN apt-get install -y libglib2.0-0 libnss3 libnspr4 libatk1.0-0 libatk-bridge2.0-0 libcups2 libdrm2 libdbus-1-3 libxkbcommon0 libxcomposite1 libxdamage1 libxfixes3 libxrandr2 libgbm1 libasound2 libatspi2.0-0 libxshmfence1' : ''}

# Copy package files
COPY package.json .
COPY package-lock.json* .
COPY tsconfig.json .

# Install dependencies
RUN npm ci

# Copy source files
COPY src/ ./src/
${framework === 'playwright' ? 'RUN npx playwright install chromium --with-deps' : ''}

# Set entry point
ENTRYPOINT ["npm", "test"]
`;
  }
}

function generateGitHubActionsConfig(framework: string, language: string, outputFormat: string, approachType: string): string {
  return `name: Test Automation

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    ${language === 'java' 
      ? '- name: Set up JDK 17\n      uses: actions/setup-java@v3\n      with:\n        java-version: \'17\'\n        distribution: \'temurin\'' 
      : '- name: Set up Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18\n        cache: \'npm\''}
    
    - name: Set up Chrome
      uses: browser-actions/setup-chrome@v1
    
    ${framework === 'playwright' && language === 'typescript'
      ? '- name: Install Playwright browsers\n      run: npx playwright install --with-deps chromium'
      : ''}
    
    - name: Install dependencies
      run: ${language === 'java' 
        ? (outputFormat === 'maven' ? './mvnw clean install -DskipTests' : './gradlew dependencies') 
        : 'npm ci'}
    
    - name: Run tests
      run: ${language === 'java'
        ? (outputFormat === 'maven' 
          ? (approachType === 'testng' ? './mvnw test' : './mvnw test -Dcucumber.filter.tags="@smoke"') 
          : (approachType === 'testng' ? './gradlew test' : './gradlew cucumber'))
        : 'npm test'}
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: test-reports
        path: ${language === 'java'
          ? (outputFormat === 'maven' ? 'target/surefire-reports' : 'build/reports/tests')
          : 'reports'}
`;
}

function generateAzurePipelinesConfig(framework: string, language: string, outputFormat: string, approachType: string): string {
  return `trigger:
  - main

pool:
  vmImage: ubuntu-latest

steps:
- task: ${language === 'java' ? 'JavaToolInstaller@0' : 'NodeTool@0'}
  inputs:
    ${language === 'java'
      ? 'versionSpec: \'17\'\n    jdkArchitectureOption: \'x64\'\n    jdkSourceOption: \'PreInstalled\''
      : 'versionSpec: \'18.x\''}
  displayName: 'Set up ${language === 'java' ? 'JDK' : 'Node.js'}'

- script: |
    wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
    echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" | sudo tee /etc/apt/sources.list.d/google.list
    sudo apt-get update
    sudo apt-get install -y google-chrome-stable
  displayName: 'Install Chrome'

${framework === 'playwright' && language === 'typescript'
  ? '- script: |\n    npx playwright install --with-deps chromium\n  displayName: \'Install Playwright browsers\'\n'
  : ''}

- script: |
    ${language === 'java'
      ? (outputFormat === 'maven' ? './mvnw clean install -DskipTests' : './gradlew dependencies')
      : 'npm ci'}
  displayName: 'Install dependencies'

- script: |
    ${language === 'java'
      ? (outputFormat === 'maven' 
        ? (approachType === 'testng' ? './mvnw test' : './mvnw test -Dcucumber.filter.tags="@smoke"')
        : (approachType === 'testng' ? './gradlew test' : './gradlew cucumber'))
      : 'npm test'}
  displayName: 'Run tests'

- task: PublishTestResults@2
  inputs:
    testResultsFormat: ${language === 'java' ? 'JUnit' : 'JUnit'}
    testResultsFiles: ${language === 'java'
      ? (outputFormat === 'maven' ? '**/target/surefire-reports/TEST-*.xml' : '**/build/test-results/test/TEST-*.xml')
      : '**/junit-*.xml'}
    mergeTestResults: true
    testRunTitle: 'Test Results'
  condition: succeededOrFailed()
  displayName: 'Publish test results'

- task: PublishBuildArtifacts@1
  inputs:
    pathtoPublish: ${language === 'java'
      ? (outputFormat === 'maven' ? 'target/surefire-reports' : 'build/reports/tests')
      : 'reports'}
    artifactName: 'test-reports'
  condition: succeededOrFailed()
  displayName: 'Publish test artifacts'
`;
}

export default TemplateEditor;



src/components/export/ProjectStructurePreview.tsx
--------------------------------------------------------------

import React, { useState, useEffect } from 'react';
import Card from '../common/Card';
import Tabs from '../common/Tabs';
import CodeEditor from '../common/CodeEditor';
import { ExportConfig } from './ExportWizard';

interface ProjectStructurePreviewProps {
  structure: any;
  templates: Record<string, string>;
  config: ExportConfig;
}

interface FileNode {
  id: string;
  name: string;
  type: 'file' | 'directory';
  children?: FileNode[];
}

const ProjectStructurePreview: React.FC<ProjectStructurePreviewProps> = ({
  structure,
  templates,
  config,
}) => {
  const [selectedFile, setSelectedFile] = useState<string | null>(null);
  const [expandedFolders, setExpandedFolders] = useState<Record<string, boolean>>({
    'root': true,
  });
  const [activeTab, setActiveTab] = useState<'structure' | 'preview'>('structure');
  const [selectedTemplateKey, setSelectedTemplateKey] = useState<string | null>(null);
  
  // Initialize to show the first available template
  useEffect(() => {
    if (templates && Object.keys(templates).length > 0) {
      setSelectedTemplateKey(Object.keys(templates)[0]);
    }
  }, [templates]);
  
  // Toggle folder expansion
  const toggleFolder = (folderId: string) => {
    setExpandedFolders(prev => ({
      ...prev,
      [folderId]: !prev[folderId]
    }));
  };
  
  // Set selected file
  const selectFile = (fileId: string) => {
    setSelectedFile(fileId);
  };
  
  // Render file tree recursively
  const renderFileTree = (node: FileNode, level: number = 0) => {
    const isDirectory = node.type === 'directory';
    const isExpanded = expandedFolders[node.id] || false;
    
    return (
      <div key={node.id} className="file-tree-item" style={{ paddingLeft: `${level * 20}px` }}>
        <div 
          className={`file-tree-node ${isDirectory ? 'directory' : 'file'} ${isDirectory && isExpanded ? 'expanded' : ''} ${selectedFile === node.id ? 'selected' : ''}`}
          onClick={() => isDirectory ? toggleFolder(node.id) : selectFile(node.id)}
        >
          {isDirectory ? (
            <span className="folder-icon">{isExpanded ? '' : ''}</span>
          ) : (
            <span className="file-icon"></span>
          )}
          <span className="node-name">{node.name}</span>
        </div>
        
        {isDirectory && isExpanded && node.children && (
          <div className="folder-children">
            {node.children.map(child => renderFileTree(child, level + 1))}
          </div>
        )}
      </div>
    );
  };
  
  // Get content for a selected file
  const getFileContent = (fileId: string): { content: string; language: string } => {
    // In a real implementation, this would fetch the real content
    // For this example, we'll just use the template content if available
    
    const fileName = fileId.split('_').pop() || '';
    let templateKey = null;
    let language = 'text';
    
    // Map file names to template keys and languages
    if (fileName === 'pom.xml' || fileName.endsWith('pom.xml')) {
      templateKey = 'pom';
      language = 'xml';
    } else if (fileName === 'build.gradle') {
      templateKey = 'gradle';
      language = 'groovy';
    } else if (fileName.endsWith('BaseTest.java')) {
      templateKey = 'baseTest';
      language = 'java';
    } else if (fileName.endsWith('BasePage.java')) {
      templateKey = 'basePage';
      language = 'java';
    } else if (fileName.includes('SampleTest.java')) {
      templateKey = 'sampleTest';
      language = 'java';
    } else if (fileName.includes('BaseStepDef.java')) {
      templateKey = 'stepDef';
      language = 'java';
    } else if (fileName.includes('sample.feature')) {
      templateKey = 'feature';
      language = 'gherkin';
    } else if (fileName === 'package.json') {
      templateKey = 'package-json';
      language = 'json';
    } else if (fileName === 'tsconfig.json') {
      templateKey = 'tsconfig';
      language = 'json';
    } else if (fileName.endsWith('baseTest.ts')) {
      templateKey = 'baseTest';
      language = 'typescript';
    } else if (fileName.endsWith('BasePage.ts')) {
      templateKey = 'basePage';
      language = 'typescript';
    } else if (fileName.includes('sampleTest.ts')) {
      templateKey = 'sampleTest';
      language = 'typescript';
    } else if (fileName.includes('baseSteps.ts')) {
      templateKey = 'stepDef';
      language = 'typescript';
    } else if (fileName === 'README.md') {
      templateKey = 'readme';
      language = 'markdown';
    } else if (fileName === '.gitignore') {
      templateKey = 'gitignore';
      language = 'text';
    } else if (fileName === 'Dockerfile') {
      templateKey = 'dockerfile';
      language = 'dockerfile';
    } else if (fileName === 'test.yml') {
      templateKey = 'github-actions';
      language = 'yaml';
    } else if (fileName === 'azure-pipelines.yml') {
      templateKey = 'azure-pipelines';
      language = 'yaml';
    } else if (fileName === 'testng.xml') {
      templateKey = 'testng-xml';
      language = 'xml';
    }
    
    const content = templateKey && templates[templateKey] ? templates[templateKey] : `// Content for ${fileName} will be generated at export time`;
    
    return { content, language };
  };
  
  // Determine language based on template key
  const getLanguageForTemplate = (key: string): string => {
    const templateKeyToLanguage: Record<string, string> = {
      'pom': 'xml',
      'gradle': 'groovy',
      'baseTest': config.language === 'java' ? 'java' : 'typescript',
      'basePage': config.language === 'java' ? 'java' : 'typescript',
      'sampleTest': config.language === 'java' ? 'java' : 'typescript',
      'stepDef': config.language === 'java' ? 'java' : 'typescript',
      'feature': 'gherkin',
      'package-json': 'json',
      'tsconfig': 'json',
      'readme': 'markdown',
      'gitignore': 'text',
      'dockerfile': 'dockerfile',
      'github-actions': 'yaml',
      'azure-pipelines': 'yaml',
      'testng-xml': 'xml',
      'main': config.language === 'java' ? 'java' : 'typescript',
      'pipeline': 'yaml',
    };
    
    return templateKeyToLanguage[key] || 'text';
  };
  
  // Get display name for template keys
  const getDisplayNameForTemplate = (key: string): string => {
    const templateKeyToName: Record<string, string> = {
      'pom': 'Maven POM (pom.xml)',
      'gradle': 'Gradle Build (build.gradle)',
      'baseTest': 'Base Test Class',
      'basePage': 'Base Page Object',
      'sampleTest': 'Sample Test Class',
      'stepDef': 'Step Definitions',
      'feature': 'Sample Feature',
      'package-json': 'Package JSON',
      'tsconfig': 'TypeScript Config',
      'readme': 'README.md',
      'gitignore': '.gitignore',
      'dockerfile': 'Dockerfile',
      'github-actions': 'GitHub Actions Workflow',
      'azure-pipelines': 'Azure Pipelines',
      'testng-xml': 'TestNG Configuration',
      'main': 'Main Class',
      'pipeline': 'CI Pipeline',
    };
    
    return templateKeyToName[key] || key;
  };
  
  // Get file path for template
  const getFilePathForTemplate = (key: string): string => {
    const [frameworkName, language] = config.framework.split('-');
    const basePath = `templates/projects/${frameworkName}/${language}/${config.approachType}/`;
    
    const templateKeyToPath: Record<string, string> = {
      'pom': `${basePath}pom.xml`,
      'gradle': `${basePath}build.gradle`,
      'baseTest': language === 'java' 
        ? `${basePath}src/test/java/BaseTest.java` 
        : `${basePath}src/tests/baseTest.ts`,
      'basePage': language === 'java'
        ? `${basePath}src/test/java/pages/BasePage.java`
        : `${basePath}src/pages/BasePage.ts`,
      'sampleTest': language === 'java'
        ? `${basePath}src/test/java/SampleTest.java`
        : `${basePath}src/tests/sampleTest.ts`,
      'stepDef': language === 'java'
        ? `${basePath}src/test/java/stepdefs/BaseStepDef.java`
        : `${basePath}src/steps/baseSteps.ts`,
      'feature': language === 'java'
        ? `${basePath}src/test/resources/features/sample.feature`
        : `${basePath}features/sample.feature`,
      'package-json': `${basePath}package.json`,
      'tsconfig': `${basePath}tsconfig.json`,
      'readme': `${basePath}README.md`,
      'gitignore': `${basePath}.gitignore`,
      'dockerfile': `${basePath}Dockerfile`,
      'github-actions': `${basePath}.github/workflows/test.yml`,
      'azure-pipelines': `${basePath}azure-pipelines.yml`,
      'testng-xml': `${basePath}src/test/resources/testng.xml`,
    };
    
    return templateKeyToPath[key] || key;
  };
  
  const selectedFileContent = selectedFile 
    ? getFileContent(selectedFile) 
    : { content: '', language: 'text' };
  
  const selectedTemplateContent = selectedTemplateKey && templates[selectedTemplateKey]
    ? templates[selectedTemplateKey]
    : '';
  
  const selectedTemplateLanguage = selectedTemplateKey
    ? getLanguageForTemplate(selectedTemplateKey)
    : 'text';
  
  return (
    <div className="project-structure-preview">
      <div className="preview-header">
        <h3>Project Preview</h3>
        
        <Tabs
          tabs={[
            { id: 'structure', label: 'Project Structure' },
            { id: 'preview', label: 'Template Preview' }
          ]}
          activeTab={activeTab}
          onChange={(tabId) => setActiveTab(tabId as 'structure' | 'preview')}
        />
      </div>
      
      {activeTab === 'structure' ? (
        <div className="structure-view">
          <div className="file-explorer">
            <Card>
              <div className="file-tree">
                <h4>Project Files</h4>
                {renderFileTree(structure)}
              </div>
            </Card>
          </div>
          
          <div className="file-preview">
            <Card>
              {selectedFile ? (
                <>
                  <div className="file-preview-header">
                    <h4>{selectedFile.split('_').pop()}</h4>
                  </div>
                  
                  <div className="file-preview-content">
                    <CodeEditor
                      value={selectedFileContent.content}
                      onChange={() => {}} // Read-only
                      language={selectedFileContent.language}
                      readOnly={true}
                      height="500px"
                    />
                  </div>
                </>
              ) : (
                <div className="no-file-selected">
                  <p>Select a file from the project structure to preview its content.</p>
                </div>
              )}
            </Card>
          </div>
        </div>
      ) : (
        <div className="template-preview">
          <div className="template-selector">
            <Card>
              <h4>Available Templates</h4>
              <div className="template-list">
                {Object.keys(templates).map(key => (
                  <div
                    key={key}
                    className={`template-item ${selectedTemplateKey === key ? 'selected' : ''}`}
                    onClick={() => setSelectedTemplateKey(key)}
                  >
                    <div className="template-name">{getDisplayNameForTemplate(key)}</div>
                    <div className="template-path">{getFilePathForTemplate(key)}</div>
                  </div>
                ))}
              </div>
            </Card>
          </div>
          
          <div className="template-content">
            <Card>
              {selectedTemplateKey ? (
                <>
                  <div className="template-preview-header">
                    <h4>{getDisplayNameForTemplate(selectedTemplateKey)}</h4>
                    <div className="template-path">{getFilePathForTemplate(selectedTemplateKey)}</div>
                  </div>
                  
                  <div className="template-preview-content">
                    <CodeEditor
                      value={selectedTemplateContent}
                      onChange={() => {}} // Read-only
                      language={selectedTemplateLanguage}
                      readOnly={true}
                      height="500px"
                    />
                  </div>
                </>
              ) : (
                <div className="no-template-selected">
                  <p>Select a template from the list to preview its content.</p>
                </div>
              )}
            </Card>
          </div>
        </div>
      )}
    </div>
  );
};

export default ProjectStructurePreview;


src/components/export/PipelineGenerator.tsx
-----------------------------------------------------------

import React, { useState, useEffect, useCallback } from 'react';
import { useFramework } from '../../hooks/useFramework';
import { useExport } from '../../hooks/useExport';
import Button from '../common/Button';
import Select from '../common/Select';
import Input from '../common/Input';
import CodeEditor from '../common/CodeEditor';
import Tabs from '../common/Tabs';
import Modal from '../common/Modal';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';
import { 
  FrameworkType, 
  LanguageType, 
  TestType, 
  PipelineType, 
  PipelineConfiguration,
  PipelineVariable
} from '../../types/framework';

// Constants for CI/CD providers
const CI_PROVIDERS = [
  { id: 'azure', label: 'Azure DevOps' },
  { id: 'github', label: 'GitHub Actions' },
  { id: 'jenkins', label: 'Jenkins' },
  { id: 'gitlab', label: 'GitLab CI/CD' },
  { id: 'circle', label: 'CircleCI' }
];

// Azure DevOps pipeline stages
const AZURE_STAGES = [
  { id: 'checkout', label: 'Checkout', required: true },
  { id: 'setup', label: 'Setup Environment', required: true },
  { id: 'build', label: 'Build Project', required: true },
  { id: 'test', label: 'Run Tests', required: true },
  { id: 'report', label: 'Publish Reports', required: false },
  { id: 'cleanup', label: 'Cleanup', required: false }
];

// GitHub Actions workflow events
const GITHUB_EVENTS = [
  { id: 'push', label: 'Push', default: true },
  { id: 'pull_request', label: 'Pull Request', default: true },
  { id: 'schedule', label: 'Schedule', default: false },
  { id: 'workflow_dispatch', label: 'Manual Trigger', default: true }
];

// Default branch names
const DEFAULT_BRANCHES = ['main', 'master', 'develop'];

// Pipeline template file mapping by framework, language, and test type
const PIPELINE_TEMPLATE_MAPPING: Record<FrameworkType, Record<LanguageType, Record<TestType, Record<string, string>>>> = {
  selenium: {
    java: {
      testng: {
        azure: 'java_selenium_testng.yml',
        github: 'github_java_selenium_testng.yml',
        jenkins: 'jenkins_java_selenium_testng.Jenkinsfile',
        gitlab: 'gitlab_java_selenium_testng.yml',
        circle: 'circle_java_selenium_testng.yml'
      },
      bdd: {
        azure: 'java_selenium_bdd.yml',
        github: 'github_java_selenium_bdd.yml',
        jenkins: 'jenkins_java_selenium_bdd.Jenkinsfile',
        gitlab: 'gitlab_java_selenium_bdd.yml',
        circle: 'circle_java_selenium_bdd.yml'
      }
    },
    typescript: {
      testng: {
        azure: 'typescript_selenium_testng.yml',
        github: 'github_typescript_selenium_testng.yml',
        jenkins: 'jenkins_typescript_selenium_testng.Jenkinsfile',
        gitlab: 'gitlab_typescript_selenium_testng.yml',
        circle: 'circle_typescript_selenium_testng.yml'
      },
      bdd: {
        azure: 'typescript_selenium_bdd.yml',
        github: 'github_typescript_selenium_bdd.yml',
        jenkins: 'jenkins_typescript_selenium_bdd.Jenkinsfile',
        gitlab: 'gitlab_typescript_selenium_bdd.yml',
        circle: 'circle_typescript_selenium_bdd.yml'
      }
    }
  },
  playwright: {
    java: {
      testng: {
        azure: 'java_playwright_testng.yml',
        github: 'github_java_playwright_testng.yml',
        jenkins: 'jenkins_java_playwright_testng.Jenkinsfile',
        gitlab: 'gitlab_java_playwright_testng.yml',
        circle: 'circle_java_playwright_testng.yml'
      },
      bdd: {
        azure: 'java_playwright_bdd.yml',
        github: 'github_java_playwright_bdd.yml',
        jenkins: 'jenkins_java_playwright_bdd.Jenkinsfile',
        gitlab: 'gitlab_java_playwright_bdd.yml',
        circle: 'circle_java_playwright_bdd.yml'
      }
    },
    typescript: {
      testng: {
        azure: 'typescript_playwright_testng.yml',
        github: 'github_typescript_playwright_testng.yml',
        jenkins: 'jenkins_typescript_playwright_testng.Jenkinsfile',
        gitlab: 'gitlab_typescript_playwright_testng.yml',
        circle: 'circle_typescript_playwright_testng.yml'
      },
      bdd: {
        azure: 'typescript_playwright_bdd.yml',
        github: 'github_typescript_playwright_bdd.yml',
        jenkins: 'jenkins_typescript_playwright_bdd.Jenkinsfile',
        gitlab: 'gitlab_typescript_playwright_bdd.yml',
        circle: 'circle_typescript_playwright_bdd.yml'
      }
    }
  }
};

// Environment variable types
const ENVIRONMENT_VARIABLE_TYPES = [
  { id: 'string', label: 'String' },
  { id: 'number', label: 'Number' },
  { id: 'boolean', label: 'Boolean' },
  { id: 'secret', label: 'Secret' }
];

// Browser options
const BROWSER_OPTIONS = [
  { id: 'chrome', label: 'Chrome' },
  { id: 'firefox', label: 'Firefox' },
  { id: 'edge', label: 'Edge' },
  { id: 'safari', label: 'Safari' }
];

// Test execution modes
const TEST_EXECUTION_MODES = [
  { id: 'sequential', label: 'Sequential' },
  { id: 'parallel', label: 'Parallel' }
];

interface PipelineGeneratorProps {
  projectName?: string;
  onPipelineGenerated?: (pipelineConfig: PipelineConfiguration, pipelineContent: string) => void;
}

const PipelineGenerator: React.FC<PipelineGeneratorProps> = ({
  projectName = 'CSTestForge Project',
  onPipelineGenerated
}) => {
  const { selectedFramework, selectedLanguage, selectedTestType } = useFramework();
  const { loadTemplate, generatePipeline } = useExport();
  
  // State for CI provider selection
  const [selectedProvider, setSelectedProvider] = useState<string>('azure');
  
  // State for pipeline configuration
  const [pipelineConfig, setPipelineConfig] = useState<PipelineConfiguration>({
    name: `${projectName} CI/CD Pipeline`,
    provider: 'azure',
    framework: selectedFramework,
    language: selectedLanguage,
    testType: selectedTestType,
    branches: ['main'],
    environments: ['QA', 'Staging', 'Production'],
    browsers: ['chrome'],
    executionMode: 'parallel',
    reportingEnabled: true,
    notificationsEnabled: false,
    variables: [],
    schedules: [],
    timeout: 60,
    tags: [],
    customSettings: {}
  });
  
  // State for pipeline file content
  const [pipelineContent, setPipelineContent] = useState<string>('');
  
  // State for template loading
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  
  // State for tabs
  const [activeTab, setActiveTab] = useState<string>('config');
  
  // State for modal
  const [isModalOpen, setIsModalOpen] = useState<boolean>(false);
  const [currentVariable, setCurrentVariable] = useState<PipelineVariable>({
    name: '',
    value: '',
    type: 'string',
    isSecret: false,
    description: ''
  });
  
  // State for scheduling
  const [schedule, setSchedule] = useState({
    cron: '0 0 * * *',
    timezone: 'UTC',
    enabled: true,
    description: 'Daily midnight run'
  });
  
  // Load template based on selected provider, framework, language, and test type
  useEffect(() => {
    loadPipelineTemplate();
  }, [selectedProvider, selectedFramework, selectedLanguage, selectedTestType]);
  
  // Update pipeline config when framework settings change
  useEffect(() => {
    setPipelineConfig(prev => ({
      ...prev,
      framework: selectedFramework,
      language: selectedLanguage,
      testType: selectedTestType
    }));
  }, [selectedFramework, selectedLanguage, selectedTestType]);
  
  // Load pipeline template
  const loadPipelineTemplate = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // Get template filename based on current selections
      const templateFileName = 
        PIPELINE_TEMPLATE_MAPPING[selectedFramework]?.[selectedLanguage]?.[selectedTestType]?.[selectedProvider];
      
      if (!templateFileName) {
        throw new Error(`No template found for the selected configuration`);
      }
      
      // Load template content
      const templateContent = await loadTemplate(`pipeline/${templateFileName}`);
      
      // Set pipeline content
      setPipelineContent(templateContent);
      
      // Update provider in config
      setPipelineConfig(prev => ({
        ...prev,
        provider: selectedProvider
      }));
      
      setIsLoading(false);
    } catch (err) {
      console.error('Failed to load pipeline template:', err);
      setError(`Failed to load pipeline template: ${err instanceof Error ? err.message : String(err)}`);
      setIsLoading(false);
    }
  };
  
  // Generate pipeline from configuration
  const handleGeneratePipeline = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      // Generate pipeline content based on configuration
      const generatedContent = await generatePipeline(pipelineConfig);
      
      // Update pipeline content
      setPipelineContent(generatedContent);
      
      // Call callback if provided
      if (onPipelineGenerated) {
        onPipelineGenerated(pipelineConfig, generatedContent);
      }
      
      setIsLoading(false);
    } catch (err) {
      console.error('Failed to generate pipeline:', err);
      setError(`Failed to generate pipeline: ${err instanceof Error ? err.message : String(err)}`);
      setIsLoading(false);
    }
  };
  
  // Handle provider selection change
  const handleProviderChange = (provider: string) => {
    setSelectedProvider(provider);
  };
  
  // Handle pipeline name change
  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setPipelineConfig(prev => ({
      ...prev,
      name: event.target.value
    }));
  };
  
  // Handle branch selection change
  const handleBranchChange = (branches: string[]) => {
    setPipelineConfig(prev => ({
      ...prev,
      branches
    }));
  };
  
  // Handle environment selection change
  const handleEnvironmentChange = (environments: string[]) => {
    setPipelineConfig(prev => ({
      ...prev,
      environments
    }));
  };
  
  // Handle browser selection change
  const handleBrowserChange = (browsers: string[]) => {
    setPipelineConfig(prev => ({
      ...prev,
      browsers
    }));
  };
  
  // Handle execution mode change
  const handleExecutionModeChange = (mode: string) => {
    setPipelineConfig(prev => ({
      ...prev,
      executionMode: mode
    }));
  };
  
  // Handle reporting toggle
  const handleReportingToggle = (enabled: boolean) => {
    setPipelineConfig(prev => ({
      ...prev,
      reportingEnabled: enabled
    }));
  };
  
  // Handle notifications toggle
  const handleNotificationsToggle = (enabled: boolean) => {
    setPipelineConfig(prev => ({
      ...prev,
      notificationsEnabled: enabled
    }));
  };
  
  // Handle timeout change
  const handleTimeoutChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const timeout = parseInt(event.target.value, 10);
    if (!isNaN(timeout) && timeout > 0) {
      setPipelineConfig(prev => ({
        ...prev,
        timeout
      }));
    }
  };
  
  // Handle tags change
  const handleTagsChange = (tags: string[]) => {
    setPipelineConfig(prev => ({
      ...prev,
      tags
    }));
  };
  
  // Handle variable modal open
  const handleOpenVariableModal = (variable?: PipelineVariable) => {
    if (variable) {
      setCurrentVariable(variable);
    } else {
      setCurrentVariable({
        name: '',
        value: '',
        type: 'string',
        isSecret: false,
        description: ''
      });
    }
    setIsModalOpen(true);
  };
  
  // Handle variable modal close
  const handleCloseVariableModal = () => {
    setIsModalOpen(false);
  };
  
  // Handle variable save
  const handleSaveVariable = () => {
    // Validate variable
    if (!currentVariable.name) {
      setError('Variable name is required');
      return;
    }
    
    setPipelineConfig(prev => {
      // Check if variable already exists
      const existingIndex = prev.variables.findIndex(v => v.name === currentVariable.name);
      
      if (existingIndex >= 0) {
        // Update existing variable
        const updatedVariables = [...prev.variables];
        updatedVariables[existingIndex] = currentVariable;
        return {
          ...prev,
          variables: updatedVariables
        };
      } else {
        // Add new variable
        return {
          ...prev,
          variables: [...prev.variables, currentVariable]
        };
      }
    });
    
    setIsModalOpen(false);
  };
  
  // Handle variable deletion
  const handleDeleteVariable = (name: string) => {
    setPipelineConfig(prev => ({
      ...prev,
      variables: prev.variables.filter(v => v.name !== name)
    }));
  };
  
  // Handle schedule save
  const handleSaveSchedule = () => {
    // Validate cron expression
    const cronRegex = /^(\*|([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|\*\/([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])) (\*|([0-9]|1[0-9]|2[0-3])|\*\/([0-9]|1[0-9]|2[0-3])) (\*|([1-9]|1[0-9]|2[0-9]|3[0-1])|\*\/([1-9]|1[0-9]|2[0-9]|3[0-1])) (\*|([1-9]|1[0-2])|\*\/([1-9]|1[0-2])) (\*|([0-6])|\*\/([0-6]))$/;
    if (!cronRegex.test(schedule.cron)) {
      setError('Invalid cron expression');
      return;
    }
    
    setPipelineConfig(prev => ({
      ...prev,
      schedules: [...prev.schedules, schedule]
    }));
    
    // Reset schedule form
    setSchedule({
      cron: '0 0 * * *',
      timezone: 'UTC',
      enabled: true,
      description: 'Daily midnight run'
    });
  };
  
  // Handle schedule deletion
  const handleDeleteSchedule = (index: number) => {
    setPipelineConfig(prev => ({
      ...prev,
      schedules: prev.schedules.filter((_, i) => i !== index)
    }));
  };
  
  // Handle pipeline content change
  const handlePipelineContentChange = (content: string) => {
    setPipelineContent(content);
  };
  
  // Download pipeline configuration
  const handleDownloadConfig = () => {
    const configJson = JSON.stringify(pipelineConfig, null, 2);
    const blob = new Blob([configJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${pipelineConfig.name.replace(/\s+/g, '_').toLowerCase()}_config.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  
  // Download pipeline file
  const handleDownloadPipeline = () => {
    const extension = selectedProvider === 'jenkins' ? 'Jenkinsfile' : 'yml';
    const filename = `${pipelineConfig.name.replace(/\s+/g, '_').toLowerCase()}.${extension}`;
    
    const blob = new Blob([pipelineContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  
  // Copy pipeline content to clipboard
  const handleCopyToClipboard = () => {
    navigator.clipboard.writeText(pipelineContent)
      .then(() => {
        // Show success notification
        // In a real implementation, you'd want to show a Toast notification here
        console.log('Pipeline content copied to clipboard');
      })
      .catch(err => {
        console.error('Failed to copy pipeline content:', err);
        setError('Failed to copy pipeline content to clipboard');
      });
  };
  
  // Load pipeline configuration from file
  const handleLoadConfig = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const config = JSON.parse(e.target?.result as string) as PipelineConfiguration;
        setPipelineConfig(config);
        // Also update selected provider to match the loaded config
        setSelectedProvider(config.provider);
      } catch (err) {
        console.error('Failed to parse pipeline configuration:', err);
        setError('Failed to parse pipeline configuration file');
      }
    };
    reader.readAsText(file);
  };
  
  // Render CI provider selection
  const renderProviderSelection = () => {
    return (
      <div className="mb-6">
        <h3 className="text-lg font-semibold mb-3">CI/CD Provider</h3>
        <div className="grid grid-cols-5 gap-4">
          {CI_PROVIDERS.map(provider => (
            <div 
              key={provider.id}
              className={`cursor-pointer border rounded-lg p-4 text-center transition-colors ${
                selectedProvider === provider.id 
                  ? 'border-[#C54B8C] bg-[#C54B8C]/10 text-[#C54B8C]' 
                  : 'border-gray-200 hover:border-[#C54B8C] hover:bg-[#C54B8C]/5'
              }`}
              onClick={() => handleProviderChange(provider.id)}
            >
              <div className="text-xl mb-2">
                {provider.id === 'azure' && <i className="fas fa-cloud"></i>}
                {provider.id === 'github' && <i className="fab fa-github"></i>}
                {provider.id === 'jenkins' && <i className="fas fa-server"></i>}
                {provider.id === 'gitlab' && <i className="fab fa-gitlab"></i>}
                {provider.id === 'circle' && <i className="fas fa-circle-notch"></i>}
              </div>
              <div>{provider.label}</div>
            </div>
          ))}
        </div>
      </div>
    );
  };
  
  // Render basic pipeline configuration
  const renderBasicConfig = () => {
    return (
      <div className="mb-6">
        <h3 className="text-lg font-semibold mb-3">Basic Configuration</h3>
        <div className="grid grid-cols-2 gap-x-4 gap-y-4">
          <div className="col-span-2">
            <Input
              id="pipeline-name"
              label="Pipeline Name"
              value={pipelineConfig.name}
              onChange={handleNameChange}
              placeholder="Enter pipeline name"
              required
            />
          </div>
          
          <div>
            <Select
              id="branches"
              label="Target Branches"
              options={[...DEFAULT_BRANCHES, 'feature/*', 'release/*', 'hotfix/*'].map(b => ({ id: b, label: b }))}
              value={pipelineConfig.branches}
              onChange={handleBranchChange}
              placeholder="Select target branches"
              isMulti
              isCreatable
            />
          </div>
          
          <div>
            <Select
              id="environments"
              label="Deployment Environments"
              options={['Development', 'QA', 'Staging', 'Production'].map(e => ({ id: e, label: e }))}
              value={pipelineConfig.environments}
              onChange={handleEnvironmentChange}
              placeholder="Select environments"
              isMulti
              isCreatable
            />
          </div>
          
          <div>
            <Select
              id="browsers"
              label="Test Browsers"
              options={BROWSER_OPTIONS}
              value={pipelineConfig.browsers}
              onChange={handleBrowserChange}
              placeholder="Select browsers"
              isMulti
            />
          </div>
          
          <div>
            <Select
              id="execution-mode"
              label="Test Execution Mode"
              options={TEST_EXECUTION_MODES}
              value={pipelineConfig.executionMode}
              onChange={handleExecutionModeChange}
              placeholder="Select execution mode"
            />
          </div>
          
          <div>
            <Input
              id="timeout"
              label="Pipeline Timeout (minutes)"
              type="number"
              min={1}
              max={720}
              value={pipelineConfig.timeout.toString()}
              onChange={handleTimeoutChange}
              placeholder="Enter timeout in minutes"
            />
          </div>
          
          <div>
            <Select
              id="tags"
              label="Pipeline Tags"
              options={[]}
              value={pipelineConfig.tags}
              onChange={handleTagsChange}
              placeholder="Enter tags"
              isMulti
              isCreatable
            />
          </div>
          
          <div className="flex items-center space-x-6">
            <div className="flex items-center">
              <input
                id="reporting-enabled"
                type="checkbox"
                checked={pipelineConfig.reportingEnabled}
                onChange={(e) => handleReportingToggle(e.target.checked)}
                className="mr-2"
              />
              <label htmlFor="reporting-enabled">Enable Reporting</label>
            </div>
            
            <div className="flex items-center">
              <input
                id="notifications-enabled"
                type="checkbox"
                checked={pipelineConfig.notificationsEnabled}
                onChange={(e) => handleNotificationsToggle(e.target.checked)}
                className="mr-2"
              />
              <label htmlFor="notifications-enabled">Enable Notifications</label>
            </div>
          </div>
        </div>
      </div>
    );
  };
  
  // Render environment variables
  const renderEnvironmentVariables = () => {
    return (
      <div className="mb-6">
        <div className="flex justify-between items-center mb-3">
          <h3 className="text-lg font-semibold">Environment Variables</h3>
          <Button
            variant="secondary"
            size="small"
            icon="plus"
            onClick={() => handleOpenVariableModal()}
          >
            Add Variable
          </Button>
        </div>
        
        {pipelineConfig.variables.length > 0 ? (
          <div className="border rounded overflow-hidden">
            <table className="w-full">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-4 py-2 text-left">Name</th>
                  <th className="px-4 py-2 text-left">Value</th>
                  <th className="px-4 py-2 text-left">Type</th>
                  <th className="px-4 py-2 text-left">Secret</th>
                  <th className="px-4 py-2 text-left">Description</th>
                  <th className="px-4 py-2 text-left">Actions</th>
                </tr>
              </thead>
              <tbody>
                {pipelineConfig.variables.map((variable, index) => (
                  <tr key={index} className="border-t">
                    <td className="px-4 py-2">{variable.name}</td>
                    <td className="px-4 py-2">
                      {variable.isSecret ? '' : variable.value}
                    </td>
                    <td className="px-4 py-2">{variable.type}</td>
                    <td className="px-4 py-2">{variable.isSecret ? 'Yes' : 'No'}</td>
                    <td className="px-4 py-2">{variable.description}</td>
                    <td className="px-4 py-2">
                      <div className="flex space-x-2">
                        <button
                          onClick={() => handleOpenVariableModal(variable)}
                          className="text-blue-600 hover:text-blue-800"
                        >
                          Edit
                        </button>
                        <button
                          onClick={() => handleDeleteVariable(variable.name)}
                          className="text-red-600 hover:text-red-800"
                        >
                          Delete
                        </button>
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ) : (
          <div className="text-center py-6 border rounded bg-gray-50">
            <p className="text-gray-500">No environment variables defined</p>
            <Button
              variant="text"
              size="small"
              onClick={() => handleOpenVariableModal()}
              className="mt-2"
            >
              Add your first variable
            </Button>
          </div>
        )}
      </div>
    );
  };
  
  // Render schedules
  const renderSchedules = () => {
    return (
      <div className="mb-6">
        <h3 className="text-lg font-semibold mb-3">Scheduled Runs</h3>
        
        <div className="grid grid-cols-4 gap-4 mb-4">
          <div>
            <Input
              id="cron"
              label="Cron Expression"
              value={schedule.cron}
              onChange={(e) => setSchedule(prev => ({ ...prev, cron: e.target.value }))}
              placeholder="0 0 * * *"
              help="e.g., 0 0 * * * for daily at midnight"
            />
          </div>
          
          <div>
            <Select
              id="timezone"
              label="Timezone"
              options={[
                { id: 'UTC', label: 'UTC' },
                { id: 'America/New_York', label: 'Eastern Time (ET)' },
                { id: 'America/Chicago', label: 'Central Time (CT)' },
                { id: 'America/Denver', label: 'Mountain Time (MT)' },
                { id: 'America/Los_Angeles', label: 'Pacific Time (PT)' },
                { id: 'Asia/Tokyo', label: 'Japan Standard Time (JST)' },
                { id: 'Asia/Shanghai', label: 'China Standard Time (CST)' },
                { id: 'Europe/London', label: 'Greenwich Mean Time (GMT)' },
                { id: 'Europe/Paris', label: 'Central European Time (CET)' }
              ]}
              value={schedule.timezone}
              onChange={(timezone) => setSchedule(prev => ({ ...prev, timezone: timezone as string }))}
              placeholder="Select timezone"
            />
          </div>
          
          <div>
            <Input
              id="description"
              label="Description"
              value={schedule.description}
              onChange={(e) => setSchedule(prev => ({ ...prev, description: e.target.value }))}
              placeholder="Enter schedule description"
            />
          </div>
          
          <div className="flex items-end">
            <Button
              variant="primary"
              size="medium"
              onClick={handleSaveSchedule}
              className="mb-1 w-full"
            >
              Add Schedule
            </Button>
          </div>
        </div>
        
        {pipelineConfig.schedules.length > 0 ? (
          <div className="border rounded overflow-hidden">
            <table className="w-full">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-4 py-2 text-left">Cron</th>
                  <th className="px-4 py-2 text-left">Timezone</th>
                  <th className="px-4 py-2 text-left">Description</th>
                  <th className="px-4 py-2 text-left">Enabled</th>
                  <th className="px-4 py-2 text-left">Actions</th>
                </tr>
              </thead>
              <tbody>
                {pipelineConfig.schedules.map((schedule, index) => (
                  <tr key={index} className="border-t">
                    <td className="px-4 py-2 font-mono">{schedule.cron}</td>
                    <td className="px-4 py-2">{schedule.timezone}</td>
                    <td className="px-4 py-2">{schedule.description}</td>
                    <td className="px-4 py-2">{schedule.enabled ? 'Yes' : 'No'}</td>
                    <td className="px-4 py-2">
                      <button
                        onClick={() => handleDeleteSchedule(index)}
                        className="text-red-600 hover:text-red-800"
                      >
                        Delete
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ) : (
          <div className="text-center py-6 border rounded bg-gray-50">
            <p className="text-gray-500">No schedules defined</p>
          </div>
        )}
      </div>
    );
  };
  
  // Render Azure DevOps specific settings
  const renderAzureSettings = () => {
    if (selectedProvider !== 'azure') return null;
    
    return (
      <div className="mb-6">
        <h3 className="text-lg font-semibold mb-3">Azure DevOps Settings</h3>
        
        <div className="border rounded p-4">
          <h4 className="font-medium mb-2">Pipeline Stages</h4>
          
          {AZURE_STAGES.map((stage) => (
            <div key={stage.id} className="flex items-center mb-2">
              <input
                type="checkbox"
                id={`stage-${stage.id}`}
                checked={stage.required || pipelineConfig.customSettings?.azureStages?.includes(stage.id)}
                onChange={(e) => {
                  if (stage.required) return; // Required stages cannot be unchecked
                  
                  setPipelineConfig(prev => {
                    const currentStages = prev.customSettings?.azureStages || [];
                    const updatedStages = e.target.checked
                      ? [...currentStages, stage.id]
                      : currentStages.filter(s => s !== stage.id);
                    
                    return {
                      ...prev,
                      customSettings: {
                        ...prev.customSettings,
                        azureStages: updatedStages
                      }
                    };
                  });
                }}
                disabled={stage.required}
                className="mr-2"
              />
              <label htmlFor={`stage-${stage.id}`} className="flex items-center">
                {stage.label}
                {stage.required && (
                  <span className="ml-2 text-xs bg-gray-200 text-gray-600 px-2 py-0.5 rounded">
                    Required
                  </span>
                )}
              </label>
            </div>
          ))}
        </div>
      </div>
    );
  };
  
  // Render GitHub Actions specific settings
  const renderGitHubSettings = () => {
    if (selectedProvider !== 'github') return null;
    
    return (
      <div className="mb-6">
        <h3 className="text-lg font-semibold mb-3">GitHub Actions Settings</h3>
        
        <div className="border rounded p-4">
          <h4 className="font-medium mb-2">Trigger Events</h4>
          
          {GITHUB_EVENTS.map((event) => (
            <div key={event.id} className="flex items-center mb-2">
              <input
                type="checkbox"
                id={`event-${event.id}`}
                checked={
                  pipelineConfig.customSettings?.githubEvents?.includes(event.id) ||
                  (pipelineConfig.customSettings?.githubEvents === undefined && event.default)
                }
                onChange={(e) => {
                  setPipelineConfig(prev => {
                    const currentEvents = prev.customSettings?.githubEvents || 
                      GITHUB_EVENTS.filter(e => e.default).map(e => e.id);
                    
                    const updatedEvents = e.target.checked
                      ? [...currentEvents, event.id]
                      : currentEvents.filter(e => e !== event.id);
                    
                    return {
                      ...prev,
                      customSettings: {
                        ...prev.customSettings,
                        githubEvents: updatedEvents
                      }
                    };
                  });
                }}
                className="mr-2"
              />
              <label htmlFor={`event-${event.id}`}>{event.label}</label>
            </div>
          ))}
          
          {/* Conditional UI for cron schedule if schedule event is selected */}
          {(pipelineConfig.customSettings?.githubEvents?.includes('schedule') ||
            (pipelineConfig.customSettings?.githubEvents === undefined && 
             GITHUB_EVENTS.find(e => e.id === 'schedule')?.default)) && (
            <div className="mt-4 pl-6">
              <Input
                id="github-cron"
                label="Cron Schedule"
                value={pipelineConfig.customSettings?.githubCron || '0 0 * * *'}
                onChange={(e) => {
                  setPipelineConfig(prev => ({
                    ...prev,
                    customSettings: {
                      ...prev.customSettings,
                      githubCron: e.target.value
                    }
                  }));
                }}
                placeholder="0 0 * * *"
                help="Schedule format in cron syntax (GitHub Actions uses UTC timezone)"
              />
            </div>
          )}
        </div>
      </div>
    );
  };
  
  // Render Jenkins specific settings
  const renderJenkinsSettings = () => {
    if (selectedProvider !== 'jenkins') return null;
    
    return (
      <div className="mb-6">
        <h3 className="text-lg font-semibold mb-3">Jenkins Settings</h3>
        
        <div className="grid grid-cols-2 gap-4">
          <Input
            id="jenkins-agent"
            label="Jenkins Agent"
            value={pipelineConfig.customSettings?.jenkinsAgent || 'any'}
            onChange={(e) => {
              setPipelineConfig(prev => ({
                ...prev,
                customSettings: {
                  ...prev.customSettings,
                  jenkinsAgent: e.target.value
                }
              }));
            }}
            placeholder="e.g., 'any', 'docker', or specific agent name"
          />
          
          <Input
            id="jenkins-tools"
            label="Jenkins Tools"
            value={pipelineConfig.customSettings?.jenkinsTools || 'maven jdk'}
            onChange={(e) => {
              setPipelineConfig(prev => ({
                ...prev,
                customSettings: {
                  ...prev.customSettings,
                  jenkinsTools: e.target.value
                }
              }));
            }}
            placeholder="Space-separated tool names"
            help="e.g., 'maven jdk node'"
          />
          
          <div className="col-span-2">
            <div className="flex items-center mb-4">
              <input
                type="checkbox"
                id="jenkins-shared-library"
                checked={pipelineConfig.customSettings?.jenkinsSharedLibrary || false}
                onChange={(e) => {
                  setPipelineConfig(prev => ({
                    ...prev,
                    customSettings: {
                      ...prev.customSettings,
                      jenkinsSharedLibrary: e.target.checked
                    }
                  }));
                }}
                className="mr-2"
              />
              <label htmlFor="jenkins-shared-library">Use Shared Library</label>
            </div>
            
            {pipelineConfig.customSettings?.jenkinsSharedLibrary && (
              <div className="grid grid-cols-2 gap-4">
                <Input
                  id="jenkins-library-name"
                  label="Library Name"
                  value={pipelineConfig.customSettings?.jenkinsLibraryName || 'cstestforge-lib'}
                  onChange={(e) => {
                    setPipelineConfig(prev => ({
                      ...prev,
                      customSettings: {
                        ...prev.customSettings,
                        jenkinsLibraryName: e.target.value
                      }
                    }));
                  }}
                  placeholder="Enter shared library name"
                />
                
                <Input
                  id="jenkins-library-version"
                  label="Library Version"
                  value={pipelineConfig.customSettings?.jenkinsLibraryVersion || 'main'}
                  onChange={(e) => {
                    setPipelineConfig(prev => ({
                      ...prev,
                      customSettings: {
                        ...prev.customSettings,
                        jenkinsLibraryVersion: e.target.value
                      }
                    }));
                  }}
                  placeholder="Enter version or branch"
                />
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };
  
  // Render GitLab CI/CD specific settings
  const renderGitLabSettings = () => {
    if (selectedProvider !== 'gitlab') return null;
    
    return (
      <div className="mb-6">
        <h3 className="text-lg font-semibold mb-3">GitLab CI/CD Settings</h3>
        
        <div className="grid grid-cols-2 gap-4">
          <Select
            id="gitlab-image"
            label="Docker Image"
            options={[
              { id: 'maven:3.8-openjdk-17', label: 'Maven 3.8 with OpenJDK 17' },
              { id: 'node:18', label: 'Node.js 18' },
              { id: 'node:20', label: 'Node.js 20' },
              { id: 'custom', label: 'Custom image' }
            ]}
            value={pipelineConfig.customSettings?.gitlabImage || 'maven:3.8-openjdk-17'}
            onChange={(value) => {
              setPipelineConfig(prev => ({
                ...prev,
                customSettings: {
                  ...prev.customSettings,
                  gitlabImage: value as string,
                  gitlabCustomImage: value === 'custom' 
                    ? (prev.customSettings?.gitlabCustomImage || '') 
                    : undefined
                }
              }));
            }}
            placeholder="Select Docker image"
          />
          
          {pipelineConfig.customSettings?.gitlabImage === 'custom' && (
            <Input
              id="gitlab-custom-image"
              label="Custom Docker Image"
              value={pipelineConfig.customSettings?.gitlabCustomImage || ''}
              onChange={(e) => {
                setPipelineConfig(prev => ({
                  ...prev,
                  customSettings: {
                    ...prev.customSettings,
                    gitlabCustomImage: e.target.value
                  }
                }));
              }}
              placeholder="e.g., registry.gitlab.com/myorg/myimage:latest"
            />
          )}
          
          <div className="col-span-2">
            <div className="flex items-center mb-4">
              <input
                type="checkbox"
                id="gitlab-cache"
                checked={pipelineConfig.customSettings?.gitlabCache !== false}
                onChange={(e) => {
                  setPipelineConfig(prev => ({
                    ...prev,
                    customSettings: {
                      ...prev.customSettings,
                      gitlabCache: e.target.checked
                    }
                  }));
                }}
                className="mr-2"
              />
              <label htmlFor="gitlab-cache">Enable Caching</label>
            </div>
          </div>
          
          <div>
            <Input
              id="gitlab-artifact-paths"
              label="Artifact Paths"
              value={pipelineConfig.customSettings?.gitlabArtifactPaths || 'target/surefire-reports/'}
              onChange={(e) => {
                setPipelineConfig(prev => ({
                  ...prev,
                  customSettings: {
                    ...prev.customSettings,
                    gitlabArtifactPaths: e.target.value
                  }
                }));
              }}
              placeholder="Comma-separated paths"
              help="Paths to files/directories to be archived"
            />
          </div>
          
          <div>
            <Input
              id="gitlab-artifact-expire"
              label="Artifact Expiration"
              value={pipelineConfig.customSettings?.gitlabArtifactExpire || '1 week'}
              onChange={(e) => {
                setPipelineConfig(prev => ({
                  ...prev,
                  customSettings: {
                    ...prev.customSettings,
                    gitlabArtifactExpire: e.target.value
                  }
                }));
              }}
              placeholder="e.g., 1 week, 1 day, 30 mins"
            />
          </div>
        </div>
      </div>
    );
  };
  
  // Render CircleCI specific settings
  const renderCircleCISettings = () => {
    if (selectedProvider !== 'circle') return null;
    
    return (
      <div className="mb-6">
        <h3 className="text-lg font-semibold mb-3">CircleCI Settings</h3>
        
        <div className="grid grid-cols-2 gap-4">
          <Select
            id="circle-executor"
            label="Executor Type"
            options={[
              { id: 'docker', label: 'Docker' },
              { id: 'machine', label: 'Machine' },
              { id: 'macos', label: 'macOS' },
              { id: 'windows', label: 'Windows' }
            ]}
            value={pipelineConfig.customSettings?.circleExecutor || 'docker'}
            onChange={(value) => {
              setPipelineConfig(prev => ({
                ...prev,
                customSettings: {
                  ...prev.customSettings,
                  circleExecutor: value as string
                }
              }));
            }}
            placeholder="Select executor type"
          />
          
          {pipelineConfig.customSettings?.circleExecutor === 'docker' && (
            <Input
              id="circle-docker-image"
              label="Docker Image"
              value={pipelineConfig.customSettings?.circleDockerImage || 'cimg/openjdk:17.0'}
              onChange={(e) => {
                setPipelineConfig(prev => ({
                  ...prev,
                  customSettings: {
                    ...prev.customSettings,
                    circleDockerImage: e.target.value
                  }
                }));
              }}
              placeholder="Enter Docker image"
            />
          )}
          
          {pipelineConfig.customSettings?.circleExecutor === 'machine' && (
            <Input
              id="circle-machine-image"
              label="Machine Image"
              value={pipelineConfig.customSettings?.circleMachineImage || 'ubuntu-2204:current'}
              onChange={(e) => {
                setPipelineConfig(prev => ({
                  ...prev,
                  customSettings: {
                    ...prev.customSettings,
                    circleMachineImage: e.target.value
                  }
                }));
              }}
              placeholder="Enter machine image"
            />
          )}
          
          <div className="col-span-2">
            <Input
              id="circle-resource-class"
              label="Resource Class"
              value={pipelineConfig.customSettings?.circleResourceClass || 'medium'}
              onChange={(e) => {
                setPipelineConfig(prev => ({
                  ...prev,
                  customSettings: {
                    ...prev.customSettings,
                    circleResourceClass: e.target.value
                  }
                }));
              }}
              placeholder="e.g., small, medium, large"
              help="Resource class defines CPU/RAM allocation"
            />
          </div>
          
          <div className="col-span-2">
            <div className="flex items-center mb-4">
              <input
                type="checkbox"
                id="circle-workflow"
                checked={pipelineConfig.customSettings?.circleWorkflow !== false}
                onChange={(e) => {
                  setPipelineConfig(prev => ({
                    ...prev,
                    customSettings: {
                      ...prev.customSettings,
                      circleWorkflow: e.target.checked
                    }
                  }));
                }}
                className="mr-2"
              />
              <label htmlFor="circle-workflow">Use Workflow</label>
            </div>
            
            {pipelineConfig.customSettings?.circleWorkflow !== false && (
              <div className="border rounded p-4">
                <h4 className="font-medium mb-2">Workflow Jobs</h4>
                
                {['build', 'test', 'report'].map((job) => (
                  <div key={job} className="flex items-center mb-2">
                    <input
                      type="checkbox"
                      id={`circle-job-${job}`}
                      checked={
                        pipelineConfig.customSettings?.circleJobs?.includes(job) ||
                        (pipelineConfig.customSettings?.circleJobs === undefined)
                      }
                      onChange={(e) => {
                        setPipelineConfig(prev => {
                          const currentJobs = prev.customSettings?.circleJobs || ['build', 'test', 'report'];
                          const updatedJobs = e.target.checked
                            ? [...currentJobs, job]
                            : currentJobs.filter(j => j !== job);
                          
                          return {
                            ...prev,
                            customSettings: {
                              ...prev.customSettings,
                              circleJobs: updatedJobs
                            }
                          };
                        });
                      }}
                      className="mr-2"
                    />
                    <label htmlFor={`circle-job-${job}`}>
                      {job.charAt(0).toUpperCase() + job.slice(1)}
                    </label>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };
  
  // Render pipeline content editor
  const renderPipelineContent = () => {
    return (
      <div className="mb-6">
        <div className="flex justify-between items-center mb-3">
          <h3 className="text-lg font-semibold">Pipeline Definition</h3>
          <div className="space-x-2">
            <Button
              variant="text"
              size="small"
              onClick={handleCopyToClipboard}
              icon="copy"
            >
              Copy
            </Button>
            <Button
              variant="text"
              size="small"
              onClick={handleDownloadPipeline}
              icon="download"
            >
              Download
            </Button>
          </div>
        </div>
        
        <CodeEditor
          value={pipelineContent}
          onChange={handlePipelineContentChange}
          language={selectedProvider === 'jenkins' ? 'groovy' : 'yaml'}
          height="400px"
          theme="vs-dark"
          options={{
            minimap: { enabled: true },
            scrollBeyondLastLine: false,
            readOnly: false,
            lineNumbers: 'on'
          }}
        />
      </div>
    );
  };
  
  // Render variable modal
  const renderVariableModal = () => {
    return (
      <Modal
        isOpen={isModalOpen}
        onClose={handleCloseVariableModal}
        title={currentVariable.name ? 'Edit Variable' : 'Add Variable'}
        size="medium"
      >
        <div className="p-4">
          <div className="grid grid-cols-2 gap-4">
            <Input
              id="variable-name"
              label="Variable Name"
              value={currentVariable.name}
              onChange={(e) => setCurrentVariable(prev => ({ ...prev, name: e.target.value }))}
              placeholder="Enter variable name"
              required
            />
            
            <Select
              id="variable-type"
              label="Variable Type"
              options={ENVIRONMENT_VARIABLE_TYPES}
              value={currentVariable.type}
              onChange={(type) => setCurrentVariable(prev => ({ ...prev, type: type as string }))}
              placeholder="Select variable type"
            />
            
            <div className="col-span-2">
              <Input
                id="variable-value"
                label="Variable Value"
                type={currentVariable.isSecret ? 'password' : 'text'}
                value={currentVariable.value}
                onChange={(e) => setCurrentVariable(prev => ({ ...prev, value: e.target.value }))}
                placeholder="Enter variable value"
              />
            </div>
            
            <div className="col-span-2">
              <Input
                id="variable-description"
                label="Description"
                value={currentVariable.description}
                onChange={(e) => setCurrentVariable(prev => ({ ...prev, description: e.target.value }))}
                placeholder="Enter variable description"
              />
            </div>
            
            <div className="col-span-2">
              <div className="flex items-center">
                <input
                  id="variable-secret"
                  type="checkbox"
                  checked={currentVariable.isSecret}
                  onChange={(e) => setCurrentVariable(prev => ({ ...prev, isSecret: e.target.checked }))}
                  className="mr-2"
                />
                <label htmlFor="variable-secret">Treat as secret</label>
              </div>
            </div>
          </div>
          
          <div className="flex justify-end space-x-3 mt-6">
            <Button
              variant="text"
              onClick={handleCloseVariableModal}
            >
              Cancel
            </Button>
            <Button
              variant="primary"
              onClick={handleSaveVariable}
            >
              Save
            </Button>
          </div>
        </div>
      </Modal>
    );
  };
  
  // Render buttons for actions
  const renderActions = () => {
    return (
      <div className="flex justify-between items-center mb-6">
        <div>
          <input
            type="file"
            id="config-upload"
            accept=".json"
            onChange={handleLoadConfig}
            className="hidden"
          />
          <Button
            variant="outline"
            size="medium"
            onClick={() => document.getElementById('config-upload')?.click()}
            icon="upload"
          >
            Load Configuration
          </Button>
        </div>
        
        <div className="flex space-x-3">
          <Button
            variant="outline"
            size="medium"
            onClick={handleDownloadConfig}
            icon="download"
          >
            Export Configuration
          </Button>
          
          <Button
            variant="primary"
            size="medium"
            onClick={handleGeneratePipeline}
            disabled={isLoading}
            icon={isLoading ? undefined : 'play'}
          >
            {isLoading ? <Spinner size="small" /> : 'Generate Pipeline'}
          </Button>
        </div>
      </div>
    );
  };
  
  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h2 className="text-2xl font-bold text-[#C54B8C] mb-6">Pipeline Generator</h2>
      
      {renderProviderSelection()}
      
      {error && (
        <Alert
          type="error"
          title="Error"
          message={error}
          className="mb-6"
          onClose={() => setError(null)}
        />
      )}
      
      <Tabs
        tabs={[
          { id: 'config', label: 'Configuration' },
          { id: 'variables', label: 'Variables' },
          { id: 'schedules', label: 'Schedules' },
          { id: 'provider', label: 'Provider Settings' },
          { id: 'preview', label: 'Pipeline Preview' }
        ]}
        activeTab={activeTab}
        onChange={setActiveTab}
      >
        {activeTab === 'config' && (
          <div className="py-4">
            {renderBasicConfig()}
            {renderActions()}
          </div>
        )}
        
        {activeTab === 'variables' && (
          <div className="py-4">
            {renderEnvironmentVariables()}
            {renderActions()}
          </div>
        )}
        
        {activeTab === 'schedules' && (
          <div className="py-4">
            {renderSchedules()}
            {renderActions()}
          </div>
        )}
        
        {activeTab === 'provider' && (
          <div className="py-4">
            {selectedProvider === 'azure' && renderAzureSettings()}
            {selectedProvider === 'github' && renderGitHubSettings()}
            {selectedProvider === 'jenkins' && renderJenkinsSettings()}
            {selectedProvider === 'gitlab' && renderGitLabSettings()}
            {selectedProvider === 'circle' && renderCircleCISettings()}
            {renderActions()}
          </div>
        )}
        
        {activeTab === 'preview' && (
          <div className="py-4">
            {renderPipelineContent()}
            {renderActions()}
          </div>
        )}
      </Tabs>
      
      {renderVariableModal()}
    </div>
  );
};

export default PipelineGenerator;



