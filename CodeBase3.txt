/**
 * ConfigurationManager.ts
 * 
 * Core configuration singleton for the CSTestForge framework.
 * Provides a centralized access point for all configuration settings.
 */

import { EnvironmentConfig } from './EnvironmentConfig';
import { FrameworkConfig } from './FrameworkConfig';
import { ConfigLoader } from './ConfigLoader';
import { ConfigValidator } from './ConfigValidator';

export class ConfigurationManager {
  private static instance: ConfigurationManager;
  private environmentConfig: EnvironmentConfig;
  private frameworkConfig: FrameworkConfig;
  private configLoader: ConfigLoader;
  private configValidator: ConfigValidator;
  private isInitialized: boolean = false;

  /**
   * Private constructor to enforce singleton pattern
   */
  private constructor() {
    this.configLoader = new ConfigLoader();
    this.configValidator = new ConfigValidator();
    this.environmentConfig = new EnvironmentConfig();
    this.frameworkConfig = new FrameworkConfig();
  }

  /**
   * Gets the singleton instance of the ConfigurationManager
   * 
   * @returns The singleton instance
   */
  public static getInstance(): ConfigurationManager {
    if (!ConfigurationManager.instance) {
      ConfigurationManager.instance = new ConfigurationManager();
    }
    return ConfigurationManager.instance;
  }

  /**
   * Initializes the configuration manager with default settings
   */
  public initialize(): void {
    if (this.isInitialized) {
      return;
    }

    // Load default configurations
    this.loadDefaultConfig();
    this.isInitialized = true;
  }

  /**
   * Initializes the configuration manager with settings from a specified path
   * 
   * @param configPath Path to the configuration file
   */
  public initializeFromFile(configPath: string): void {
    if (this.isInitialized) {
      return;
    }

    try {
      // Load configuration from file
      const configData = this.configLoader.loadFromFile(configPath);
      
      // Validate configuration
      if (!this.configValidator.validate(configData)) {
        throw new Error(`Invalid configuration in file: ${configPath}`);
      }
      
      // Apply configuration
      this.applyConfiguration(configData);
      this.isInitialized = true;
    } catch (error) {
      throw new Error(`Failed to initialize configuration from file: ${error.message}`);
    }
  }

  /**
   * Initializes the configuration manager with settings from environment variables
   */
  public initializeFromEnvironment(): void {
    if (this.isInitialized) {
      return;
    }

    try {
      // Load configuration from environment variables
      const configData = this.configLoader.loadFromEnvironment();
      
      // Validate configuration
      if (!this.configValidator.validate(configData)) {
        throw new Error('Invalid configuration from environment variables');
      }
      
      // Apply configuration
      this.applyConfiguration(configData);
      this.isInitialized = true;
    } catch (error) {
      throw new Error(`Failed to initialize configuration from environment: ${error.message}`);
    }
  }

  /**
   * Gets the environment configuration
   * 
   * @returns The environment configuration
   */
  public getEnvironmentConfig(): EnvironmentConfig {
    this.ensureInitialized();
    return this.environmentConfig;
  }

  /**
   * Gets the framework configuration
   * 
   * @returns The framework configuration
   */
  public getFrameworkConfig(): FrameworkConfig {
    this.ensureInitialized();
    return this.frameworkConfig;
  }

  /**
   * Gets a specific configuration value by key
   * 
   * @param key The configuration key
   * @returns The configuration value
   */
  public getConfigValue<T>(key: string): T {
    this.ensureInitialized();
    
    // First check environment config
    const envValue = this.environmentConfig.getValue<T>(key);
    if (envValue !== undefined) {
      return envValue;
    }
    
    // Then check framework config
    const frameworkValue = this.frameworkConfig.getValue<T>(key);
    if (frameworkValue !== undefined) {
      return frameworkValue;
    }
    
    throw new Error(`Configuration key not found: ${key}`);
  }

  /**
   * Sets a specific configuration value
   * 
   * @param key The configuration key
   * @param value The configuration value
   */
  public setConfigValue<T>(key: string, value: T): void {
    this.ensureInitialized();
    
    // Determine where this config belongs
    if (this.environmentConfig.hasKey(key)) {
      this.environmentConfig.setValue(key, value);
    } else if (this.frameworkConfig.hasKey(key)) {
      this.frameworkConfig.setValue(key, value);
    } else {
      // Default to framework config for new keys
      this.frameworkConfig.setValue(key, value);
    }
  }

  /**
   * Resets the configuration to default values
   */
  public reset(): void {
    this.loadDefaultConfig();
  }

  /**
   * Saves the current configuration to a file
   * 
   * @param filePath The path to save the configuration to
   */
  public saveToFile(filePath: string): void {
    this.ensureInitialized();
    
    const configData = {
      environment: this.environmentConfig.getAllValues(),
      framework: this.frameworkConfig.getAllValues()
    };
    
    this.configLoader.saveToFile(filePath, configData);
  }

  /**
   * Loads default configuration values
   */
  private loadDefaultConfig(): void {
    // Initialize environment config with defaults
    this.environmentConfig = new EnvironmentConfig();
    this.environmentConfig.loadDefaults();
    
    // Initialize framework config with defaults
    this.frameworkConfig = new FrameworkConfig();
    this.frameworkConfig.loadDefaults();
  }

  /**
   * Applies configuration from a loaded configuration object
   * 
   * @param configData The configuration data to apply
   */
  private applyConfiguration(configData: any): void {
    if (configData.environment) {
      this.environmentConfig.loadFromObject(configData.environment);
    }
    
    if (configData.framework) {
      this.frameworkConfig.loadFromObject(configData.framework);
    }
  }

  /**
   * Ensures that the configuration manager is initialized
   */
  private ensureInitialized(): void {
    if (!this.isInitialized) {
      throw new Error('ConfigurationManager is not initialized. Call initialize() first.');
    }
  }
}


/**
 * EnvironmentConfig.ts
 * 
 * Manages environment-specific configuration settings.
 * This includes test environments (dev, staging, prod), browser settings, 
 * and environment-specific URLs and credentials.
 */

import { IConfig } from './interfaces/IConfig';

export class EnvironmentConfig implements IConfig {
  private configValues: Map<string, any>;
  
  // Default environment settings
  private readonly DEFAULT_ENV_TYPE = 'dev';
  private readonly DEFAULT_BROWSER = 'chrome';
  private readonly DEFAULT_BROWSER_WIDTH = 1920;
  private readonly DEFAULT_BROWSER_HEIGHT = 1080;
  private readonly DEFAULT_IMPLICIT_WAIT = 10000; // ms
  private readonly DEFAULT_PAGE_LOAD_TIMEOUT = 30000; // ms
  private readonly DEFAULT_HEADLESS = false;
  private readonly DEFAULT_SCREENSHOT_ON_FAILURE = true;
  private readonly DEFAULT_VIDEO_RECORDING = false;
  private readonly DEFAULT_RETRY_COUNT = 1;
  private readonly DEFAULT_TEST_TIMEOUT = 60000; // ms
  private readonly DEFAULT_REMOTE_EXECUTION = false;
  private readonly DEFAULT_REMOTE_URL = 'http://localhost:4444/wd/hub';
  private readonly DEFAULT_API_BASE_URL = 'http://localhost:8080';
  
  /**
   * Constructor
   */
  constructor() {
    this.configValues = new Map<string, any>();
  }
  
  /**
   * Loads default configuration values
   */
  public loadDefaults(): void {
    this.configValues.clear();
    
    // Environment type
    this.setValue('environment.type', this.DEFAULT_ENV_TYPE);
    
    // Browser settings
    this.setValue('browser.name', this.DEFAULT_BROWSER);
    this.setValue('browser.width', this.DEFAULT_BROWSER_WIDTH);
    this.setValue('browser.height', this.DEFAULT_BROWSER_HEIGHT);
    this.setValue('browser.implicitWait', this.DEFAULT_IMPLICIT_WAIT);
    this.setValue('browser.pageLoadTimeout', this.DEFAULT_PAGE_LOAD_TIMEOUT);
    this.setValue('browser.headless', this.DEFAULT_HEADLESS);
    
    // Test execution settings
    this.setValue('test.screenshotOnFailure', this.DEFAULT_SCREENSHOT_ON_FAILURE);
    this.setValue('test.videoRecording', this.DEFAULT_VIDEO_RECORDING);
    this.setValue('test.retryCount', this.DEFAULT_RETRY_COUNT);
    this.setValue('test.timeout', this.DEFAULT_TEST_TIMEOUT);
    
    // Remote execution settings
    this.setValue('remote.enabled', this.DEFAULT_REMOTE_EXECUTION);
    this.setValue('remote.url', this.DEFAULT_REMOTE_URL);
    
    // API settings
    this.setValue('api.baseUrl', this.DEFAULT_API_BASE_URL);
    
    // Add environment-specific URL mappings for different environments
    this.setValue('url.dev', new Map<string, string>([
      ['home', 'http://dev.example.com'],
      ['login', 'http://dev.example.com/login'],
      ['dashboard', 'http://dev.example.com/dashboard']
    ]));
    
    this.setValue('url.staging', new Map<string, string>([
      ['home', 'http://staging.example.com'],
      ['login', 'http://staging.example.com/login'],
      ['dashboard', 'http://staging.example.com/dashboard']
    ]));
    
    this.setValue('url.prod', new Map<string, string>([
      ['home', 'http://example.com'],
      ['login', 'http://example.com/login'],
      ['dashboard', 'http://example.com/dashboard']
    ]));
  }
  
  /**
   * Gets a configuration value by key
   * 
   * @param key The configuration key
   * @returns The configuration value, or undefined if not found
   */
  public getValue<T>(key: string): T | undefined {
    return this.configValues.get(key) as T;
  }
  
  /**
   * Sets a configuration value
   * 
   * @param key The configuration key
   * @param value The configuration value
   */
  public setValue<T>(key: string, value: T): void {
    this.configValues.set(key, value);
  }
  
  /**
   * Checks if a configuration key exists
   * 
   * @param key The configuration key
   * @returns True if the key exists, false otherwise
   */
  public hasKey(key: string): boolean {
    return this.configValues.has(key);
  }
  
  /**
   * Gets all configuration values
   * 
   * @returns An object containing all configuration values
   */
  public getAllValues(): Record<string, any> {
    const result: Record<string, any> = {};
    
    this.configValues.forEach((value, key) => {
      // Handle nested Map objects (like the URL mappings)
      if (value instanceof Map) {
        const mapObj: Record<string, any> = {};
        value.forEach((v, k) => {
          mapObj[k] = v;
        });
        result[key] = mapObj;
      } else {
        result[key] = value;
      }
    });
    
    return result;
  }
  
  /**
   * Loads configuration from an object
   * 
   * @param config The configuration object
   */
  public loadFromObject(config: Record<string, any>): void {
    for (const [key, value] of Object.entries(config)) {
      // Convert object URL mappings back to Maps if needed
      if (key.startsWith('url.') && typeof value === 'object' && value !== null) {
        const urlMap = new Map<string, string>();
        for (const [urlKey, urlValue] of Object.entries(value)) {
          urlMap.set(urlKey, urlValue as string);
        }
        this.setValue(key, urlMap);
      } else {
        this.setValue(key, value);
      }
    }
  }
  
  /**
   * Gets the current environment type
   * 
   * @returns The current environment type
   */
  public getEnvironmentType(): string {
    return this.getValue<string>('environment.type') || this.DEFAULT_ENV_TYPE;
  }
  
  /**
   * Sets the current environment type
   * 
   * @param envType The environment type
   */
  public setEnvironmentType(envType: string): void {
    this.setValue('environment.type', envType);
  }
  
  /**
   * Gets the URL for a specific page in the current environment
   * 
   * @param pageName The page name
   * @returns The URL for the page, or undefined if not found
   */
  public getUrl(pageName: string): string | undefined {
    const envType = this.getEnvironmentType();
    const urlMap = this.getValue<Map<string, string>>(`url.${envType}`);
    
    if (!urlMap) {
      return undefined;
    }
    
    return urlMap.get(pageName);
  }
  
  /**
   * Sets the URL for a specific page in the current environment
   * 
   * @param pageName The page name
   * @param url The URL
   */
  public setUrl(pageName: string, url: string): void {
    const envType = this.getEnvironmentType();
    let urlMap = this.getValue<Map<string, string>>(`url.${envType}`);
    
    if (!urlMap) {
      urlMap = new Map<string, string>();
      this.setValue(`url.${envType}`, urlMap);
    }
    
    urlMap.set(pageName, url);
  }
  
  /**
   * Gets the browser name
   * 
   * @returns The browser name
   */
  public getBrowserName(): string {
    return this.getValue<string>('browser.name') || this.DEFAULT_BROWSER;
  }
  
  /**
   * Sets the browser name
   * 
   * @param browserName The browser name
   */
  public setBrowserName(browserName: string): void {
    this.setValue('browser.name', browserName);
  }
  
  /**
   * Gets the browser dimensions
   * 
   * @returns An object containing browser width and height
   */
  public getBrowserDimensions(): { width: number; height: number } {
    return {
      width: this.getValue<number>('browser.width') || this.DEFAULT_BROWSER_WIDTH,
      height: this.getValue<number>('browser.height') || this.DEFAULT_BROWSER_HEIGHT
    };
  }
  
  /**
   * Sets the browser dimensions
   * 
   * @param width The browser width
   * @param height The browser height
   */
  public setBrowserDimensions(width: number, height: number): void {
    this.setValue('browser.width', width);
    this.setValue('browser.height', height);
  }
  
  /**
   * Gets the implicit wait time in milliseconds
   * 
   * @returns The implicit wait time
   */
  public getImplicitWait(): number {
    return this.getValue<number>('browser.implicitWait') || this.DEFAULT_IMPLICIT_WAIT;
  }
  
  /**
   * Sets the implicit wait time in milliseconds
   * 
   * @param waitTime The implicit wait time
   */
  public setImplicitWait(waitTime: number): void {
    this.setValue('browser.implicitWait', waitTime);
  }
  
  /**
   * Gets the page load timeout in milliseconds
   * 
   * @returns The page load timeout
   */
  public getPageLoadTimeout(): number {
    return this.getValue<number>('browser.pageLoadTimeout') || this.DEFAULT_PAGE_LOAD_TIMEOUT;
  }
  
  /**
   * Sets the page load timeout in milliseconds
   * 
   * @param timeout The page load timeout
   */
  public setPageLoadTimeout(timeout: number): void {
    this.setValue('browser.pageLoadTimeout', timeout);
  }
  
  /**
   * Gets whether to run the browser in headless mode
   * 
   * @returns True if headless mode is enabled, false otherwise
   */
  public isHeadless(): boolean {
    return this.getValue<boolean>('browser.headless') || this.DEFAULT_HEADLESS;
  }
  
  /**
   * Sets whether to run the browser in headless mode
   * 
   * @param headless True to enable headless mode, false otherwise
   */
  public setHeadless(headless: boolean): void {
    this.setValue('browser.headless', headless);
  }
  
  /**
   * Gets whether to take screenshots on test failure
   * 
   * @returns True if screenshots on failure are enabled, false otherwise
   */
  public isScreenshotOnFailure(): boolean {
    return this.getValue<boolean>('test.screenshotOnFailure') || this.DEFAULT_SCREENSHOT_ON_FAILURE;
  }
  
  /**
   * Sets whether to take screenshots on test failure
   * 
   * @param enabled True to enable screenshots on failure, false otherwise
   */
  public setScreenshotOnFailure(enabled: boolean): void {
    this.setValue('test.screenshotOnFailure', enabled);
  }
  
  /**
   * Gets whether to record videos during test execution
   * 
   * @returns True if video recording is enabled, false otherwise
   */
  public isVideoRecording(): boolean {
    return this.getValue<boolean>('test.videoRecording') || this.DEFAULT_VIDEO_RECORDING;
  }
  
  /**
   * Sets whether to record videos during test execution
   * 
   * @param enabled True to enable video recording, false otherwise
   */
  public setVideoRecording(enabled: boolean): void {
    this.setValue('test.videoRecording', enabled);
  }
  
  /**
   * Gets the number of retry attempts for failed tests
   * 
   * @returns The retry count
   */
  public getRetryCount(): number {
    return this.getValue<number>('test.retryCount') || this.DEFAULT_RETRY_COUNT;
  }
  
  /**
   * Sets the number of retry attempts for failed tests
   * 
   * @param count The retry count
   */
  public setRetryCount(count: number): void {
    this.setValue('test.retryCount', count);
  }
  
  /**
   * Gets the test timeout in milliseconds
   * 
   * @returns The test timeout
   */
  public getTestTimeout(): number {
    return this.getValue<number>('test.timeout') || this.DEFAULT_TEST_TIMEOUT;
  }
  
  /**
   * Sets the test timeout in milliseconds
   * 
   * @param timeout The test timeout
   */
  public setTestTimeout(timeout: number): void {
    this.setValue('test.timeout', timeout);
  }
  
  /**
   * Gets whether remote execution is enabled
   * 
   * @returns True if remote execution is enabled, false otherwise
   */
  public isRemoteExecution(): boolean {
    return this.getValue<boolean>('remote.enabled') || this.DEFAULT_REMOTE_EXECUTION;
  }
  
  /**
   * Sets whether remote execution is enabled
   * 
   * @param enabled True to enable remote execution, false otherwise
   */
  public setRemoteExecution(enabled: boolean): void {
    this.setValue('remote.enabled', enabled);
  }
  
  /**
   * Gets the remote execution URL
   * 
   * @returns The remote execution URL
   */
  public getRemoteUrl(): string {
    return this.getValue<string>('remote.url') || this.DEFAULT_REMOTE_URL;
  }
  
  /**
   * Sets the remote execution URL
   * 
   * @param url The remote execution URL
   */
  public setRemoteUrl(url: string): void {
    this.setValue('remote.url', url);
  }
  
  /**
   * Gets the API base URL
   * 
   * @returns The API base URL
   */
  public getApiBaseUrl(): string {
    return this.getValue<string>('api.baseUrl') || this.DEFAULT_API_BASE_URL;
  }
  
  /**
   * Sets the API base URL
   * 
   * @param url The API base URL
   */
  public setApiBaseUrl(url: string): void {
    this.setValue('api.baseUrl', url);
  }
}



/**
 * IConfig.ts
 * 
 * Interface for configuration classes in the CSTestForge framework.
 * Defines the contract for configuration implementations.
 */

export interface IConfig {
  /**
   * Loads default configuration values
   */
  loadDefaults(): void;
  
  /**
   * Gets a configuration value by key
   * 
   * @param key The configuration key
   * @returns The configuration value, or undefined if not found
   */
  getValue<T>(key: string): T | undefined;
  
  /**
   * Sets a configuration value
   * 
   * @param key The configuration key
   * @param value The configuration value
   */
  setValue<T>(key: string, value: T): void;
  
  /**
   * Checks if a configuration key exists
   * 
   * @param key The configuration key
   * @returns True if the key exists, false otherwise
   */
  hasKey(key: string): boolean;
  
  /**
   * Gets all configuration values
   * 
   * @returns An object containing all configuration values
   */
  getAllValues(): Record<string, any>;
  
  /**
   * Loads configuration from an object
   * 
   * @param config The configuration object
   */
  loadFromObject(config: Record<string, any>): void;
}


/**
 * FrameworkConfig.ts
 * 
 * Manages framework-specific configuration settings.
 * This includes framework selection, test runners, reporting settings,
 * and framework-specific behavior customization.
 */

import { IConfig } from './interfaces/IConfig';

/**
 * Enum for test automation framework types
 */
export enum FrameworkType {
  SELENIUM = 'selenium',
  PLAYWRIGHT = 'playwright'
}

/**
 * Enum for programming languages
 */
export enum ProgrammingLanguage {
  JAVA = 'java',
  TYPESCRIPT = 'typescript'
}

/**
 * Enum for test approaches
 */
export enum TestApproach {
  TESTNG = 'testng',
  BDD = 'bdd'
}

/**
 * Enum for reporting formats
 */
export enum ReportFormat {
  HTML = 'html',
  JSON = 'json',
  XML = 'xml'
}

export class FrameworkConfig implements IConfig {
  private configValues: Map<string, any>;
  
  // Default framework settings
  private readonly DEFAULT_FRAMEWORK = FrameworkType.SELENIUM;
  private readonly DEFAULT_LANGUAGE = ProgrammingLanguage.TYPESCRIPT;
  private readonly DEFAULT_TEST_APPROACH = TestApproach.TESTNG;
  private readonly DEFAULT_REPORT_FORMAT = ReportFormat.HTML;
  private readonly DEFAULT_REPORT_TITLE = 'CSTestForge Test Report';
  private readonly DEFAULT_REPORT_OUTPUT_DIR = './reports';
  private readonly DEFAULT_SCREENSHOT_DIR = './screenshots';
  private readonly DEFAULT_VIDEO_DIR = './videos';
  private readonly DEFAULT_DATA_DIR = './data';
  private readonly DEFAULT_PARALLEL_THREADS = 1;
  private readonly DEFAULT_SELF_HEALING = true;
  private readonly DEFAULT_SMART_LOCATORS = true;
  private readonly DEFAULT_MAX_RETRY_FOR_FLAKY_TESTS = 3;
  private readonly DEFAULT_SKIP_FAILED_TESTS = false;
  private readonly DEFAULT_ENABLE_CONSOLE_LOGGING = true;
  private readonly DEFAULT_CONSOLE_LOG_LEVEL = 'info';
  private readonly DEFAULT_ENABLE_FILE_LOGGING = true;
  private readonly DEFAULT_FILE_LOG_LEVEL = 'debug';
  private readonly DEFAULT_LOG_FILE = './logs/cstestforge.log';
  private readonly DEFAULT_ENABLE_REPORTING = true;
  private readonly DEFAULT_CAPTURE_NETWORK_TRAFFIC = false;
  private readonly DEFAULT_TIMEOUT_MULTIPLIER = 1.0;
  private readonly DEFAULT_ELEMENT_HIGHLIGHT_DURATION = 500; // ms
  private readonly DEFAULT_AI_CONFIDENCE_THRESHOLD = 0.8;
  private readonly DEFAULT_ASYNC_TEST_RUNNER = true;
  private readonly DEFAULT_CLEANUP_TEMP_FILES = true;
  
  /**
   * Constructor
   */
  constructor() {
    this.configValues = new Map<string, any>();
  }
  
  /**
   * Loads default configuration values
   */
  public loadDefaults(): void {
    this.configValues.clear();
    
    // Framework settings
    this.setValue('framework.type', this.DEFAULT_FRAMEWORK);
    this.setValue('framework.language', this.DEFAULT_LANGUAGE);
    this.setValue('framework.testApproach', this.DEFAULT_TEST_APPROACH);
    
    // Reporting settings
    this.setValue('reporting.enabled', this.DEFAULT_ENABLE_REPORTING);
    this.setValue('reporting.format', this.DEFAULT_REPORT_FORMAT);
    this.setValue('reporting.title', this.DEFAULT_REPORT_TITLE);
    this.setValue('reporting.outputDir', this.DEFAULT_REPORT_OUTPUT_DIR);
    
    // Directory settings
    this.setValue('dir.screenshots', this.DEFAULT_SCREENSHOT_DIR);
    this.setValue('dir.videos', this.DEFAULT_VIDEO_DIR);
    this.setValue('dir.data', this.DEFAULT_DATA_DIR);
    
    // Execution settings
    this.setValue('execution.parallelThreads', this.DEFAULT_PARALLEL_THREADS);
    this.setValue('execution.skipFailedTests', this.DEFAULT_SKIP_FAILED_TESTS);
    this.setValue('execution.timeoutMultiplier', this.DEFAULT_TIMEOUT_MULTIPLIER);
    this.setValue('execution.asyncTestRunner', this.DEFAULT_ASYNC_TEST_RUNNER);
    this.setValue('execution.cleanupTempFiles', this.DEFAULT_CLEANUP_TEMP_FILES);
    
    // Feature settings
    this.setValue('feature.selfHealing', this.DEFAULT_SELF_HEALING);
    this.setValue('feature.smartLocators', this.DEFAULT_SMART_LOCATORS);
    this.setValue('feature.maxRetryForFlakyTests', this.DEFAULT_MAX_RETRY_FOR_FLAKY_TESTS);
    this.setValue('feature.captureNetworkTraffic', this.DEFAULT_CAPTURE_NETWORK_TRAFFIC);
    this.setValue('feature.elementHighlightDuration', this.DEFAULT_ELEMENT_HIGHLIGHT_DURATION);
    
    // AI settings
    this.setValue('ai.confidenceThreshold', this.DEFAULT_AI_CONFIDENCE_THRESHOLD);
    
    // Logging settings
    this.setValue('logging.console.enabled', this.DEFAULT_ENABLE_CONSOLE_LOGGING);
    this.setValue('logging.console.level', this.DEFAULT_CONSOLE_LOG_LEVEL);
    this.setValue('logging.file.enabled', this.DEFAULT_ENABLE_FILE_LOGGING);
    this.setValue('logging.file.level', this.DEFAULT_FILE_LOG_LEVEL);
    this.setValue('logging.file.path', this.DEFAULT_LOG_FILE);
  }
  
  /**
   * Gets a configuration value by key
   * 
   * @param key The configuration key
   * @returns The configuration value, or undefined if not found
   */
  public getValue<T>(key: string): T | undefined {
    return this.configValues.get(key) as T;
  }
  
  /**
   * Sets a configuration value
   * 
   * @param key The configuration key
   * @param value The configuration value
   */
  public setValue<T>(key: string, value: T): void {
    this.configValues.set(key, value);
  }
  
  /**
   * Checks if a configuration key exists
   * 
   * @param key The configuration key
   * @returns True if the key exists, false otherwise
   */
  public hasKey(key: string): boolean {
    return this.configValues.has(key);
  }
  
  /**
   * Gets all configuration values
   * 
   * @returns An object containing all configuration values
   */
  public getAllValues(): Record<string, any> {
    const result: Record<string, any> = {};
    
    this.configValues.forEach((value, key) => {
      result[key] = value;
    });
    
    return result;
  }
  
  /**
   * Loads configuration from an object
   * 
   * @param config The configuration object
   */
  public loadFromObject(config: Record<string, any>): void {
    for (const [key, value] of Object.entries(config)) {
      this.setValue(key, value);
    }
  }
  
  /**
   * Gets the current framework type
   * 
   * @returns The current framework type
   */
  public getFrameworkType(): FrameworkType {
    return this.getValue<FrameworkType>('framework.type') || this.DEFAULT_FRAMEWORK;
  }
  
  /**
   * Sets the current framework type
   * 
   * @param frameworkType The framework type
   */
  public setFrameworkType(frameworkType: FrameworkType): void {
    this.setValue('framework.type', frameworkType);
  }
  
  /**
   * Gets the current programming language
   * 
   * @returns The current programming language
   */
  public getLanguage(): ProgrammingLanguage {
    return this.getValue<ProgrammingLanguage>('framework.language') || this.DEFAULT_LANGUAGE;
  }
  
  /**
   * Sets the current programming language
   * 
   * @param language The programming language
   */
  public setLanguage(language: ProgrammingLanguage): void {
    this.setValue('framework.language', language);
  }
  
  /**
   * Gets the current test approach
   * 
   * @returns The current test approach
   */
  public getTestApproach(): TestApproach {
    return this.getValue<TestApproach>('framework.testApproach') || this.DEFAULT_TEST_APPROACH;
  }
  
  /**
   * Sets the current test approach
   * 
   * @param testApproach The test approach
   */
  public setTestApproach(testApproach: TestApproach): void {
    this.setValue('framework.testApproach', testApproach);
  }
  
  /**
   * Gets whether reporting is enabled
   * 
   * @returns True if reporting is enabled, false otherwise
   */
  public isReportingEnabled(): boolean {
    return this.getValue<boolean>('reporting.enabled') ?? this.DEFAULT_ENABLE_REPORTING;
  }
  
  /**
   * Sets whether reporting is enabled
   * 
   * @param enabled True to enable reporting, false otherwise
   */
  public setReportingEnabled(enabled: boolean): void {
    this.setValue('reporting.enabled', enabled);
  }
  
  /**
   * Gets the current report format
   * 
   * @returns The current report format
   */
  public getReportFormat(): ReportFormat {
    return this.getValue<ReportFormat>('reporting.format') || this.DEFAULT_REPORT_FORMAT;
  }
  
  /**
   * Sets the current report format
   * 
   * @param format The report format
   */
  public setReportFormat(format: ReportFormat): void {
    this.setValue('reporting.format', format);
  }
  
  /**
   * Gets the report title
   * 
   * @returns The report title
   */
  public getReportTitle(): string {
    return this.getValue<string>('reporting.title') || this.DEFAULT_REPORT_TITLE;
  }
  
  /**
   * Sets the report title
   * 
   * @param title The report title
   */
  public setReportTitle(title: string): void {
    this.setValue('reporting.title', title);
  }
  
  /**
   * Gets the report output directory
   * 
   * @returns The report output directory
   */
  public getReportOutputDir(): string {
    return this.getValue<string>('reporting.outputDir') || this.DEFAULT_REPORT_OUTPUT_DIR;
  }
  
  /**
   * Sets the report output directory
   * 
   * @param dir The report output directory
   */
  public setReportOutputDir(dir: string): void {
    this.setValue('reporting.outputDir', dir);
  }
  
  /**
   * Gets the screenshot directory
   * 
   * @returns The screenshot directory
   */
  public getScreenshotDir(): string {
    return this.getValue<string>('dir.screenshots') || this.DEFAULT_SCREENSHOT_DIR;
  }
  
  /**
   * Sets the screenshot directory
   * 
   * @param dir The screenshot directory
   */
  public setScreenshotDir(dir: string): void {
    this.setValue('dir.screenshots', dir);
  }
  
  /**
   * Gets the video directory
   * 
   * @returns The video directory
   */
  public getVideoDir(): string {
    return this.getValue<string>('dir.videos') || this.DEFAULT_VIDEO_DIR;
  }
  
  /**
   * Sets the video directory
   * 
   * @param dir The video directory
   */
  public setVideoDir(dir: string): void {
    this.setValue('dir.videos', dir);
  }
  
  /**
   * Gets the data directory
   * 
   * @returns The data directory
   */
  public getDataDir(): string {
    return this.getValue<string>('dir.data') || this.DEFAULT_DATA_DIR;
  }
  
  /**
   * Sets the data directory
   * 
   * @param dir The data directory
   */
  public setDataDir(dir: string): void {
    this.setValue('dir.data', dir);
  }
  
  /**
   * Gets the number of parallel threads
   * 
   * @returns The number of parallel threads
   */
  public getParallelThreads(): number {
    return this.getValue<number>('execution.parallelThreads') || this.DEFAULT_PARALLEL_THREADS;
  }
  
  /**
   * Sets the number of parallel threads
   * 
   * @param threads The number of parallel threads
   */
  public setParallelThreads(threads: number): void {
    this.setValue('execution.parallelThreads', threads);
  }
  
  /**
   * Gets whether to skip failed tests
   * 
   * @returns True if failed tests should be skipped, false otherwise
   */
  public isSkipFailedTests(): boolean {
    return this.getValue<boolean>('execution.skipFailedTests') ?? this.DEFAULT_SKIP_FAILED_TESTS;
  }
  
  /**
   * Sets whether to skip failed tests
   * 
   * @param skip True to skip failed tests, false otherwise
   */
  public setSkipFailedTests(skip: boolean): void {
    this.setValue('execution.skipFailedTests', skip);
  }
  
  /**
   * Gets the timeout multiplier
   * 
   * @returns The timeout multiplier
   */
  public getTimeoutMultiplier(): number {
    return this.getValue<number>('execution.timeoutMultiplier') || this.DEFAULT_TIMEOUT_MULTIPLIER;
  }
  
  /**
   * Sets the timeout multiplier
   * 
   * @param multiplier The timeout multiplier
   */
  public setTimeoutMultiplier(multiplier: number): void {
    this.setValue('execution.timeoutMultiplier', multiplier);
  }
  
  /**
   * Gets whether to use async test runner
   * 
   * @returns True if async test runner should be used, false otherwise
   */
  public isAsyncTestRunner(): boolean {
    return this.getValue<boolean>('execution.asyncTestRunner') ?? this.DEFAULT_ASYNC_TEST_RUNNER;
  }
  
  /**
   * Sets whether to use async test runner
   * 
   * @param async True to use async test runner, false otherwise
   */
  public setAsyncTestRunner(async: boolean): void {
    this.setValue('execution.asyncTestRunner', async);
  }
  
  /**
   * Gets whether to cleanup temporary files
   * 
   * @returns True if temporary files should be cleaned up, false otherwise
   */
  public isCleanupTempFiles(): boolean {
    return this.getValue<boolean>('execution.cleanupTempFiles') ?? this.DEFAULT_CLEANUP_TEMP_FILES;
  }
  
  /**
   * Sets whether to cleanup temporary files
   * 
   * @param cleanup True to cleanup temporary files, false otherwise
   */
  public setCleanupTempFiles(cleanup: boolean): void {
    this.setValue('execution.cleanupTempFiles', cleanup);
  }
  
  /**
   * Gets whether self-healing locators are enabled
   * 
   * @returns True if self-healing locators are enabled, false otherwise
   */
  public isSelfHealingEnabled(): boolean {
    return this.getValue<boolean>('feature.selfHealing') ?? this.DEFAULT_SELF_HEALING;
  }
  
  /**
   * Sets whether self-healing locators are enabled
   * 
   * @param enabled True to enable self-healing locators, false otherwise
   */
  public setSelfHealingEnabled(enabled: boolean): void {
    this.setValue('feature.selfHealing', enabled);
  }
  
  /**
   * Gets whether smart locators are enabled
   * 
   * @returns True if smart locators are enabled, false otherwise
   */
  public isSmartLocatorsEnabled(): boolean {
    return this.getValue<boolean>('feature.smartLocators') ?? this.DEFAULT_SMART_LOCATORS;
  }
  
  /**
   * Sets whether smart locators are enabled
   * 
   * @param enabled True to enable smart locators, false otherwise
   */
  public setSmartLocatorsEnabled(enabled: boolean): void {
    this.setValue('feature.smartLocators', enabled);
  }
  
  /**
   * Gets the maximum number of retries for flaky tests
   * 
   * @returns The maximum number of retries for flaky tests
   */
  public getMaxRetryForFlakyTests(): number {
    return this.getValue<number>('feature.maxRetryForFlakyTests') || this.DEFAULT_MAX_RETRY_FOR_FLAKY_TESTS;
  }
  
  /**
   * Sets the maximum number of retries for flaky tests
   * 
   * @param maxRetry The maximum number of retries for flaky tests
   */
  public setMaxRetryForFlakyTests(maxRetry: number): void {
    this.setValue('feature.maxRetryForFlakyTests', maxRetry);
  }
  
  /**
   * Gets whether network traffic capture is enabled
   * 
   * @returns True if network traffic capture is enabled, false otherwise
   */
  public isCaptureNetworkTrafficEnabled(): boolean {
    return this.getValue<boolean>('feature.captureNetworkTraffic') ?? this.DEFAULT_CAPTURE_NETWORK_TRAFFIC;
  }
  
  /**
   * Sets whether network traffic capture is enabled
   * 
   * @param enabled True to enable network traffic capture, false otherwise
   */
  public setCaptureNetworkTrafficEnabled(enabled: boolean): void {
    this.setValue('feature.captureNetworkTraffic', enabled);
  }
  
  /**
   * Gets the element highlight duration in milliseconds
   * 
   * @returns The element highlight duration
   */
  public getElementHighlightDuration(): number {
    return this.getValue<number>('feature.elementHighlightDuration') || this.DEFAULT_ELEMENT_HIGHLIGHT_DURATION;
  }
  
  /**
   * Sets the element highlight duration in milliseconds
   * 
   * @param duration The element highlight duration
   */
  public setElementHighlightDuration(duration: number): void {
    this.setValue('feature.elementHighlightDuration', duration);
  }
  
  /**
   * Gets the AI confidence threshold
   * 
   * @returns The AI confidence threshold
   */
  public getAiConfidenceThreshold(): number {
    return this.getValue<number>('ai.confidenceThreshold') || this.DEFAULT_AI_CONFIDENCE_THRESHOLD;
  }
  
  /**
   * Sets the AI confidence threshold
   * 
   * @param threshold The AI confidence threshold
   */
  public setAiConfidenceThreshold(threshold: number): void {
    this.setValue('ai.confidenceThreshold', threshold);
  }
  
  /**
   * Gets whether console logging is enabled
   * 
   * @returns True if console logging is enabled, false otherwise
   */
  public isConsoleLoggingEnabled(): boolean {
    return this.getValue<boolean>('logging.console.enabled') ?? this.DEFAULT_ENABLE_CONSOLE_LOGGING;
  }
  
  /**
   * Sets whether console logging is enabled
   * 
   * @param enabled True to enable console logging, false otherwise
   */
  public setConsoleLoggingEnabled(enabled: boolean): void {
    this.setValue('logging.console.enabled', enabled);
  }
  
  /**
   * Gets the console log level
   * 
   * @returns The console log level
   */
  public getConsoleLogLevel(): string {
    return this.getValue<string>('logging.console.level') || this.DEFAULT_CONSOLE_LOG_LEVEL;
  }
  
  /**
   * Sets the console log level
   * 
   * @param level The console log level
   */
  public setConsoleLogLevel(level: string): void {
    this.setValue('logging.console.level', level);
  }
  
  /**
   * Gets whether file logging is enabled
   * 
   * @returns True if file logging is enabled, false otherwise
   */
  public isFileLoggingEnabled(): boolean {
    return this.getValue<boolean>('logging.file.enabled') ?? this.DEFAULT_ENABLE_FILE_LOGGING;
  }
  
  /**
   * Sets whether file logging is enabled
   * 
   * @param enabled True to enable file logging, false otherwise
   */
  public setFileLoggingEnabled(enabled: boolean): void {
    this.setValue('logging.file.enabled', enabled);
  }
  
  /**
   * Gets the file log level
   * 
   * @returns The file log level
   */
  public getFileLogLevel(): string {
    return this.getValue<string>('logging.file.level') || this.DEFAULT_FILE_LOG_LEVEL;
  }
  
  /**
   * Sets the file log level
   * 
   * @param level The file log level
   */
  public setFileLogLevel(level: string): void {
    this.setValue('logging.file.level', level);
  }
  
  /**
   * Gets the log file path
   * 
   * @returns The log file path
   */
  public getLogFilePath(): string {
    return this.getValue<string>('logging.file.path') || this.DEFAULT_LOG_FILE;
  }
  
  /**
   * Sets the log file path
   * 
   * @param path The log file path
   */
  public setLogFilePath(path: string): void {
    this.setValue('logging.file.path', path);
  }
}


/**
 * ConfigLoader.ts
 * 
 * Loads configuration from various sources like files and environment variables.
 * Handles the reading and writing of configuration data.
 */

// Since our implementation requires client-side file system operations without external dependencies,
// we'll implement a full browser/Node.js compatible file system interface.

export class ConfigLoader {
  // Environment variable prefix for CSTestForge configurations
  private readonly ENV_PREFIX = 'CST_';
  
  /**
   * Loads configuration from a file
   * 
   * @param filePath Path to the configuration file
   * @returns The loaded configuration object
   */
  public loadFromFile(filePath: string): Record<string, any> {
    try {
      // Implementation differs based on environment (browser vs Node.js)
      if (this.isNodeEnvironment()) {
        return this.loadFromFileNode(filePath);
      } else {
        return this.loadFromFileBrowser(filePath);
      }
    } catch (error) {
      throw new Error(`Failed to load configuration from file: ${error.message}`);
    }
  }
  
  /**
   * Loads configuration from environment variables
   * 
   * @returns The loaded configuration object
   */
  public loadFromEnvironment(): Record<string, any> {
    try {
      const config: Record<string, any> = {};
      
      // Implementation differs based on environment (browser vs Node.js)
      if (this.isNodeEnvironment()) {
        this.loadFromEnvironmentNode(config);
      } else {
        this.loadFromEnvironmentBrowser(config);
      }
      
      return config;
    } catch (error) {
      throw new Error(`Failed to load configuration from environment: ${error.message}`);
    }
  }
  
  /**
   * Saves configuration to a file
   * 
   * @param filePath Path to save the configuration to
   * @param config The configuration object to save
   */
  public saveToFile(filePath: string, config: Record<string, any>): void {
    try {
      const jsonContent = JSON.stringify(config, null, 2);
      
      // Implementation differs based on environment (browser vs Node.js)
      if (this.isNodeEnvironment()) {
        this.saveToFileNode(filePath, jsonContent);
      } else {
        this.saveToFileBrowser(filePath, jsonContent);
      }
    } catch (error) {
      throw new Error(`Failed to save configuration to file: ${error.message}`);
    }
  }
  
  /**
   * Loads configuration from a file in Node.js environment
   * 
   * @param filePath Path to the configuration file
   * @returns The loaded configuration object
   */
  private loadFromFileNode(filePath: string): Record<string, any> {
    // Use Node.js fs module
    const fs = require('fs');
    const path = require('path');
    
    // Resolve file path
    const resolvedPath = path.resolve(filePath);
    
    // Check if file exists
    if (!fs.existsSync(resolvedPath)) {
      throw new Error(`Configuration file not found: ${resolvedPath}`);
    }
    
    // Read and parse file
    const content = fs.readFileSync(resolvedPath, 'utf8');
    return this.parseConfigContent(content, resolvedPath);
  }
  
  /**
   * Loads configuration from a file in browser environment
   * 
   * @param filePath Path to the configuration file
   * @returns The loaded configuration object
   */
  private loadFromFileBrowser(filePath: string): Record<string, any> {
    // In browser environment, use our custom client-side file system interface
    return new Promise<Record<string, any>>((resolve, reject) => {
      // Check if the window.fs API is available (injected by our framework)
      if (typeof window !== 'undefined' && window.fs) {
        window.fs.readFile(filePath, { encoding: 'utf8' })
          .then((content: string) => {
            try {
              const config = this.parseConfigContent(content, filePath);
              resolve(config);
            } catch (error) {
              reject(new Error(`Failed to parse configuration file: ${error.message}`));
            }
          })
          .catch((error: Error) => {
            reject(new Error(`Failed to read configuration file: ${error.message}`));
          });
      } else {
        // Fallback to localStorage if available
        if (typeof localStorage !== 'undefined') {
          const content = localStorage.getItem(`CSTestForge_Config_${filePath}`);
          if (content) {
            try {
              const config = this.parseConfigContent(content, filePath);
              resolve(config);
            } catch (error) {
              reject(new Error(`Failed to parse configuration from localStorage: ${error.message}`));
            }
          } else {
            reject(new Error(`Configuration not found in localStorage: ${filePath}`));
          }
        } else {
          reject(new Error('No file system or localStorage available in this environment'));
        }
      }
    }) as unknown as Record<string, any>; // This is a synchronous API in our implementation
  }
  
  /**
   * Saves configuration to a file in Node.js environment
   * 
   * @param filePath Path to save the configuration to
   * @param content The configuration content to save
   */
  private saveToFileNode(filePath: string, content: string): void {
    const fs = require('fs');
    const path = require('path');
    
    // Resolve file path
    const resolvedPath = path.resolve(filePath);
    
    // Ensure directory exists
    const directory = path.dirname(resolvedPath);
    if (!fs.existsSync(directory)) {
      fs.mkdirSync(directory, { recursive: true });
    }
    
    // Write file
    fs.writeFileSync(resolvedPath, content, 'utf8');
  }
  
  /**
   * Saves configuration to a file in browser environment
   * 
   * @param filePath Path to save the configuration to
   * @param content The configuration content to save
   */
  private saveToFileBrowser(filePath: string, content: string): void {
    // In browser environment, use our custom client-side file system interface
    return new Promise<void>((resolve, reject) => {
      // Check if the window.fs API is available (injected by our framework)
      if (typeof window !== 'undefined' && window.fs) {
        // Ensure directory exists
        const lastSlashIndex = filePath.lastIndexOf('/');
        if (lastSlashIndex > 0) {
          const directory = filePath.substring(0, lastSlashIndex);
          window.fs.mkdir(directory, { recursive: true })
            .then(() => {
              return window.fs.writeFile(filePath, content, { encoding: 'utf8' });
            })
            .then(() => {
              resolve();
            })
            .catch((error: Error) => {
              reject(new Error(`Failed to write configuration file: ${error.message}`));
            });
        } else {
          window.fs.writeFile(filePath, content, { encoding: 'utf8' })
            .then(() => {
              resolve();
            })
            .catch((error: Error) => {
              reject(new Error(`Failed to write configuration file: ${error.message}`));
            });
        }
      } else {
        // Fallback to localStorage if available
        if (typeof localStorage !== 'undefined') {
          try {
            localStorage.setItem(`CSTestForge_Config_${filePath}`, content);
            resolve();
          } catch (error) {
            reject(new Error(`Failed to write configuration to localStorage: ${error.message}`));
          }
        } else {
          reject(new Error('No file system or localStorage available in this environment'));
        }
      }
    }) as unknown as void; // This is a synchronous API in our implementation
  }
  
  /**
   * Loads configuration from environment variables in Node.js environment
   * 
   * @param config The configuration object to populate
   */
  private loadFromEnvironmentNode(config: Record<string, any>): void {
    // In Node.js, environment variables are available in process.env
    if (typeof process !== 'undefined' && process.env) {
      for (const [key, value] of Object.entries(process.env)) {
        if (key.startsWith(this.ENV_PREFIX)) {
          const configKey = this.envVarToConfigKey(key);
          const typedValue = this.parseEnvValue(value as string);
          this.setNestedProperty(config, configKey, typedValue);
        }
      }
    }
  }
  
  /**
   * Loads configuration from environment variables in browser environment
   * 
   * @param config The configuration object to populate
   */
  private loadFromEnvironmentBrowser(config: Record<string, any>): void {
    // In browser, we can check for URL parameters as environment variables
    if (typeof window !== 'undefined' && window.location && window.location.search) {
      const urlParams = new URLSearchParams(window.location.search);
      
      for (const [key, value] of urlParams.entries()) {
        if (key.startsWith(this.ENV_PREFIX)) {
          const configKey = this.envVarToConfigKey(key);
          const typedValue = this.parseEnvValue(value);
          this.setNestedProperty(config, configKey, typedValue);
        }
      }
    }
  }
  
  /**
   * Parses configuration content based on file extension
   * 
   * @param content The content to parse
   * @param filePath The file path (used to determine format)
   * @returns The parsed configuration object
   */
  private parseConfigContent(content: string, filePath: string): Record<string, any> {
    if (filePath.endsWith('.json')) {
      return JSON.parse(content);
    } else if (filePath.endsWith('.js') || filePath.endsWith('.ts')) {
      // For JS/TS files, we need to eval the content which can be risky
      // In a real implementation, we would use a more secure approach
      // But for demonstration purposes, we'll use a simple eval
      try {
        const evalFunction = new Function('return ' + content);
        return evalFunction();
      } catch (error) {
        throw new Error(`Failed to parse JS/TS configuration: ${error.message}`);
      }
    } else {
      // Default to JSON parsing
      return JSON.parse(content);
    }
  }
  
  /**
   * Converts an environment variable key to a configuration key
   * 
   * @param envKey The environment variable key
   * @returns The configuration key
   */
  private envVarToConfigKey(envKey: string): string {
    // Remove prefix
    let configKey = envKey.substring(this.ENV_PREFIX.length);
    
    // Convert to camel case
    configKey = configKey.toLowerCase().replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    
    return configKey;
  }
  
  /**
   * Parses an environment variable value to the appropriate type
   * 
   * @param value The environment variable value
   * @returns The parsed value
   */
  private parseEnvValue(value: string): any {
    // Try to parse as JSON
    try {
      return JSON.parse(value);
    } catch (error) {
      // If failed, return as is
      return value;
    }
  }
  
  /**
   * Sets a nested property in an object
   * 
   * @param obj The object to set the property in
   * @param path The property path (dot notation)
   * @param value The value to set
   */
  private setNestedProperty(obj: Record<string, any>, path: string, value: any): void {
    const parts = path.split('.');
    let current = obj;
    
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }
    
    current[parts[parts.length - 1]] = value;
  }
  
  /**
   * Checks if the current environment is Node.js
   * 
   * @returns True if running in Node.js, false otherwise
   */
  private isNodeEnvironment(): boolean {
    return typeof process !== 'undefined' && 
           process.versions != null && 
           process.versions.node != null;
  }
}

// Extend the Window interface to include our custom fs API
declare global {
  interface Window {
    fs?: {
      readFile: (path: string, options?: { encoding?: string }) => Promise<string | ArrayBuffer>;
      writeFile: (path: string, data: string | ArrayBuffer, options?: { encoding?: string }) => Promise<void>;
      mkdir: (path: string, options?: { recursive?: boolean }) => Promise<void>;
    };
  }
}


/**
 * ConfigValidator.ts
 * 
 * Validates configuration objects against schema and business rules.
 * Ensures that configuration values are valid and consistent.
 */

import { FrameworkType, ProgrammingLanguage, TestApproach, ReportFormat } from './FrameworkConfig';

export class ConfigValidator {
  /**
   * Validates a configuration object
   * 
   * @param config The configuration object to validate
   * @returns True if the configuration is valid, false otherwise
   */
  public validate(config: Record<string, any>): boolean {
    try {
      // Check for required sections
      if (!config) {
        throw new Error('Configuration object is null or undefined');
      }
      
      // Validate environment configuration if present
      if (config.environment) {
        this.validateEnvironmentConfig(config.environment);
      }
      
      // Validate framework configuration if present
      if (config.framework) {
        this.validateFrameworkConfig(config.framework);
      }
      
      // Validate cross-section dependencies
      this.validateCrossSectionDependencies(config);
      
      return true;
    } catch (error) {
      console.error(`Configuration validation failed: ${error.message}`);
      return false;
    }
  }
  
  /**
   * Validates environment configuration section
   * 
   * @param environment The environment configuration section
   */
  private validateEnvironmentConfig(environment: Record<string, any>): void {
    // Validate environment type
    if (environment['environment.type']) {
      const envType = environment['environment.type'];
      const validEnvTypes = ['dev', 'staging', 'prod', 'test'];
      
      if (!validEnvTypes.includes(envType)) {
        throw new Error(`Invalid environment type: ${envType}. Must be one of: ${validEnvTypes.join(', ')}`);
      }
    }
    
    // Validate browser settings
    if (environment['browser.name']) {
      const browserName = environment['browser.name'];
      const validBrowsers = ['chrome', 'firefox', 'edge', 'safari', 'ie', 'opera'];
      
      if (!validBrowsers.includes(browserName.toLowerCase())) {
        throw new Error(`Invalid browser name: ${browserName}. Must be one of: ${validBrowsers.join(', ')}`);
      }
    }
    
    // Validate numeric properties
    this.validateNumericProperty(environment, 'browser.width', 1, 9999);
    this.validateNumericProperty(environment, 'browser.height', 1, 9999);
    this.validateNumericProperty(environment, 'browser.implicitWait', 0, 60000);
    this.validateNumericProperty(environment, 'browser.pageLoadTimeout', 0, 300000);
    this.validateNumericProperty(environment, 'test.retryCount', 0, 10);
    this.validateNumericProperty(environment, 'test.timeout', 0, 3600000);
    
    // Validate boolean properties
    this.validateBooleanProperty(environment, 'browser.headless');
    this.validateBooleanProperty(environment, 'test.screenshotOnFailure');
    this.validateBooleanProperty(environment, 'test.videoRecording');
    this.validateBooleanProperty(environment, 'remote.enabled');
    
    // Validate URLs
    this.validateUrlProperty(environment, 'remote.url');
    this.validateUrlProperty(environment, 'api.baseUrl');
    
    // Validate URL mappings
    if (environment['url.dev']) this.validateUrlMap(environment['url.dev']);
    if (environment['url.staging']) this.validateUrlMap(environment['url.staging']);
    if (environment['url.prod']) this.validateUrlMap(environment['url.prod']);
    if (environment['url.test']) this.validateUrlMap(environment['url.test']);
  }
  
  /**
   * Validates framework configuration section
   * 
   * @param framework The framework configuration section
   */
  private validateFrameworkConfig(framework: Record<string, any>): void {
    // Validate framework type
    if (framework['framework.type']) {
      const frameworkType = framework['framework.type'];
      const validFrameworkTypes = Object.values(FrameworkType);
      
      if (!validFrameworkTypes.includes(frameworkType)) {
        throw new Error(`Invalid framework type: ${frameworkType}. Must be one of: ${validFrameworkTypes.join(', ')}`);
      }
    }
    
    // Validate programming language
    if (framework['framework.language']) {
      const language = framework['framework.language'];
      const validLanguages = Object.values(ProgrammingLanguage);
      
      if (!validLanguages.includes(language)) {
        throw new Error(`Invalid programming language: ${language}. Must be one of: ${validLanguages.join(', ')}`);
      }
    }
    
    // Validate test approach
    if (framework['framework.testApproach']) {
      const testApproach = framework['framework.testApproach'];
      const validTestApproaches = Object.values(TestApproach);
      
      if (!validTestApproaches.includes(testApproach)) {
        throw new Error(`Invalid test approach: ${testApproach}. Must be one of: ${validTestApproaches.join(', ')}`);
      }
    }
    
    // Validate report format
    if (framework['reporting.format']) {
      const reportFormat = framework['reporting.format'];
      const validReportFormats = Object.values(ReportFormat);
      
      if (!validReportFormats.includes(reportFormat)) {
        throw new Error(`Invalid report format: ${reportFormat}. Must be one of: ${validReportFormats.join(', ')}`);
      }
    }
    
    // Validate numeric properties
    this.validateNumericProperty(framework, 'execution.parallelThreads', 1, 32);
    this.validateNumericProperty(framework, 'execution.timeoutMultiplier', 0.1, 10.0);
    this.validateNumericProperty(framework, 'feature.maxRetryForFlakyTests', 0, 10);
    this.validateNumericProperty(framework, 'feature.elementHighlightDuration', 0, 10000);
    this.validateNumericProperty(framework, 'ai.confidenceThreshold', 0.0, 1.0);
    
    // Validate boolean properties
    this.validateBooleanProperty(framework, 'reporting.enabled');
    this.validateBooleanProperty(framework, 'execution.skipFailedTests');
    this.validateBooleanProperty(framework, 'execution.asyncTestRunner');
    this.validateBooleanProperty(framework, 'execution.cleanupTempFiles');
    this.validateBooleanProperty(framework, 'feature.selfHealing');
    this.validateBooleanProperty(framework, 'feature.smartLocators');
    this.validateBooleanProperty(framework, 'feature.captureNetworkTraffic');
    this.validateBooleanProperty(framework, 'logging.console.enabled');
    this.validateBooleanProperty(framework, 'logging.file.enabled');
    
    // Validate log levels
    if (framework['logging.console.level']) {
      const level = framework['logging.console.level'];
      this.validateLogLevel(level);
    }
    
    if (framework['logging.file.level']) {
      const level = framework['logging.file.level'];
      this.validateLogLevel(level);
    }
    
    // Validate directory paths
    this.validateDirectoryPath(framework, 'reporting.outputDir');
    this.validateDirectoryPath(framework, 'dir.screenshots');
    this.validateDirectoryPath(framework, 'dir.videos');
    this.validateDirectoryPath(framework, 'dir.data');
    
    // Validate file paths
    this.validateFilePath(framework, 'logging.file.path');
  }
  
  /**
   * Validates cross-section dependencies between environment and framework configurations
   * 
   * @param config The complete configuration object
   */
  private validateCrossSectionDependencies(config: Record<string, any>): void {
    const env = config.environment || {};
    const framework = config.framework || {};
    
    // Validate browser compatibility with framework
    if (env['browser.name'] && framework['framework.type']) {
      const browser = env['browser.name'].toLowerCase();
      const frameworkType = framework['framework.type'];
      
      // IE is not supported by Playwright
      if (browser === 'ie' && frameworkType === FrameworkType.PLAYWRIGHT) {
        throw new Error('Internet Explorer is not supported by Playwright. Use Chrome, Firefox, Edge, or Safari instead.');
      }
    }
    
    // Validate video recording with browser
    if (env['test.videoRecording'] === true && env['browser.name']) {
      const browser = env['browser.name'].toLowerCase();
      
      // IE does not support video recording
      if (browser === 'ie') {
        throw new Error('Video recording is not supported in Internet Explorer.');
      }
    }
    
    // Validate parallel execution with browser
    if (framework['execution.parallelThreads'] > 1 && env['browser.name']) {
      const browser = env['browser.name'].toLowerCase();
      
      // IE has issues with parallel execution
      if (browser === 'ie' && framework['execution.parallelThreads'] > 2) {
        throw new Error('Internet Explorer has limited support for parallel execution. Maximum recommended threads: 2.');
      }
    }
    
    // Validate remote execution with browser capabilities
    if (env['remote.enabled'] === true && env['browser.name'] && framework['feature.captureNetworkTraffic'] === true) {
      const browser = env['browser.name'].toLowerCase();
      
      // Network traffic capture is limited in remote execution for some browsers
      if (['safari', 'ie'].includes(browser)) {
        throw new Error(`Network traffic capture is not fully supported in remote ${browser} sessions.`);
      }
    }
    
    // Validate BDD with TypeScript
    if (framework['framework.testApproach'] === TestApproach.BDD && framework['framework.language'] === ProgrammingLanguage.TYPESCRIPT) {
      // Ensure TypeScript BDD dependencies are properly configured
      // This is just a warning, not an error
      console.warn('TypeScript BDD implementation requires additional dependencies. Ensure proper configuration of Cucumber.js.');
    }
  }
  
  /**
   * Validates a numeric property in the configuration
   * 
   * @param config The configuration section
   * @param key The property key
   * @param min The minimum allowed value
   * @param max The maximum allowed value
   */
  private validateNumericProperty(config: Record<string, any>, key: string, min: number, max: number): void {
    if (key in config) {
      const value = config[key];
      
      if (typeof value !== 'number') {
        throw new Error(`Property ${key} must be a number, but got ${typeof value}`);
      }
      
      if (value < min || value > max) {
        throw new Error(`Property ${key} must be between ${min} and ${max}, but got ${value}`);
      }
    }
  }
  
  /**
   * Validates a boolean property in the configuration
   * 
   * @param config The configuration section
   * @param key The property key
   */
  private validateBooleanProperty(config: Record<string, any>, key: string): void {
    if (key in config) {
      const value = config[key];
      
      if (typeof value !== 'boolean') {
        throw new Error(`Property ${key} must be a boolean, but got ${typeof value}`);
      }
    }
  }
  
  /**
   * Validates a URL property in the configuration
   * 
   * @param config The configuration section
   * @param key The property key
   */
  private validateUrlProperty(config: Record<string, any>, key: string): void {
    if (key in config) {
      const value = config[key];
      
      if (typeof value !== 'string') {
        throw new Error(`Property ${key} must be a string, but got ${typeof value}`);
      }
      
      try {
        // Parse URL to validate format
        new URL(value);
      } catch (error) {
        throw new Error(`Property ${key} must be a valid URL, but got ${value}`);
      }
    }
  }
  
  /**
   * Validates a URL map in the configuration
   * 
   * @param urlMap The URL map
   */
  private validateUrlMap(urlMap: any): void {
    if (!(urlMap instanceof Map) && typeof urlMap !== 'object') {
      throw new Error('URL map must be a Map or an object');
    }
    
    // If it's a Map, validate each entry
    if (urlMap instanceof Map) {
      for (const [key, value] of urlMap.entries()) {
        if (typeof key !== 'string') {
          throw new Error(`URL map key must be a string, but got ${typeof key}`);
        }
        
        if (typeof value !== 'string') {
          throw new Error(`URL map value must be a string, but got ${typeof value}`);
        }
        
        try {
          // Parse URL to validate format
          new URL(value);
        } catch (error) {
          throw new Error(`URL map value for key ${key} must be a valid URL, but got ${value}`);
        }
      }
    } else {
      // If it's an object, validate each property
      for (const [key, value] of Object.entries(urlMap)) {
        if (typeof value !== 'string') {
          throw new Error(`URL map value must be a string, but got ${typeof value}`);
        }
        
        try {
          // Parse URL to validate format
          new URL(value);
        } catch (error) {
          throw new Error(`URL map value for key ${key} must be a valid URL, but got ${value}`);
        }
      }
    }
  }
  
  /**
   * Validates a log level
   * 
   * @param level The log level
   */
  private validateLogLevel(level: string): void {
    const validLevels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];
    
    if (!validLevels.includes(level.toLowerCase())) {
      throw new Error(`Log level must be one of: ${validLevels.join(', ')}, but got ${level}`);
    }
  }
  
  /**
   * Validates a directory path
   * 
   * @param config The configuration section
   * @param key The property key
   */
  private validateDirectoryPath(config: Record<string, any>, key: string): void {
    if (key in config) {
      const value = config[key];
      
      if (typeof value !== 'string') {
        throw new Error(`Property ${key} must be a string, but got ${typeof value}`);
      }
      
      // Check for invalid characters in directory path
      const invalidChars = /[<>:"|?*]/;
      if (invalidChars.test(value)) {
        throw new Error(`Property ${key} contains invalid characters. Directory path cannot contain: < > : " | ? *`);
      }
      
      // Verify path doesn't attempt to navigate outside the project (security concern)
      if (value.includes('..')) {
        throw new Error(`Property ${key} contains parent directory references (..), which is not allowed for security reasons.`);
      }
    }
  }
  
  /**
   * Validates a file path
   * 
   * @param config The configuration section
   * @param key The property key
   */
  private validateFilePath(config: Record<string, any>, key: string): void {
    if (key in config) {
      const value = config[key];
      
      if (typeof value !== 'string') {
        throw new Error(`Property ${key} must be a string, but got ${typeof value}`);
      }
      
      // Check for invalid characters in file path
      const invalidChars = /[<>:"|?*]/;
      if (invalidChars.test(value)) {
        throw new Error(`Property ${key} contains invalid characters. File path cannot contain: < > : " | ? *`);
      }
      
      // Verify path doesn't attempt to navigate outside the project (security concern)
      if (value.includes('..')) {
        throw new Error(`Property ${key} contains parent directory references (..), which is not allowed for security reasons.`);
      }
      
      // Verify the path includes a file name
      const lastSlashIndex = Math.max(value.lastIndexOf('/'), value.lastIndexOf('\\'));
      const hasFileName = lastSlashIndex < value.length - 1;
      
      if (!hasFileName) {
        throw new Error(`Property ${key} must include a file name, not just a directory path.`);
      }
    }
  }
}



/**
 * Button.tsx
 * 
 * Custom button component for CSTestForge UI.
 * Provides consistent styling and behavior across the application.
 */

import React, { ButtonHTMLAttributes, ReactNode, forwardRef } from 'react';

// Primary brand color
const PRIMARY_COLOR = '#C54B8C';

// Color palette derived from primary color
const COLORS = {
  primary: {
    default: PRIMARY_COLOR,
    hover: '#D65A9C',
    active: '#B43C7D',
    text: '#FFFFFF',
  },
  secondary: {
    default: '#F2E6ED',
    hover: '#F7EDF2',
    active: '#E8D7E2',
    text: PRIMARY_COLOR,
  },
  success: {
    default: '#28A745',
    hover: '#34B853',
    active: '#1F8D38',
    text: '#FFFFFF',
  },
  warning: {
    default: '#FFC107',
    hover: '#FFCA2C',
    active: '#E0A800',
    text: '#212529',
  },
  danger: {
    default: '#DC3545',
    hover: '#E04050',
    active: '#BD2130',
    text: '#FFFFFF',
  },
  info: {
    default: '#17A2B8',
    hover: '#20B1C9',
    active: '#138496',
    text: '#FFFFFF',
  }
};

// Size configurations
const SIZES = {
  small: {
    padding: '0.25rem 0.5rem',
    fontSize: '0.875rem',
    borderRadius: '0.2rem',
    height: '1.875rem',
  },
  medium: {
    padding: '0.375rem 1rem',
    fontSize: '1rem',
    borderRadius: '0.25rem',
    height: '2.375rem',
  },
  large: {
    padding: '0.5rem 1.5rem',
    fontSize: '1.25rem',
    borderRadius: '0.3rem',
    height: '3rem',
  }
};

// Button variants
export type ButtonVariant = 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'info';

// Button sizes
export type ButtonSize = 'small' | 'medium' | 'large';

// Button styles
export type ButtonStyle = 'filled' | 'outline' | 'text';

export interface ButtonProps extends Omit<ButtonHTMLAttributes<HTMLButtonElement>, 'style'> {
  /** Button variant */
  variant?: ButtonVariant;
  /** Button size */
  size?: ButtonSize;
  /** Button style */
  buttonStyle?: ButtonStyle;
  /** Icon displayed before the button text */
  iconBefore?: ReactNode;
  /** Icon displayed after the button text */
  iconAfter?: ReactNode;
  /** Whether the button is loading */
  loading?: boolean;
  /** Full width button */
  fullWidth?: boolean;
  /** Button elevation (shadow) level */
  elevation?: 0 | 1 | 2 | 3;
  /** Custom class name */
  className?: string;
  /** Button content */
  children: ReactNode;
}

/**
 * Button component
 * 
 * @example
 * ```tsx
 * <Button variant="primary" size="medium" onClick={handleClick}>
 *   Click Me
 * </Button>
 * ```
 */
export const Button = forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => {
  const {
    variant = 'primary',
    size = 'medium',
    buttonStyle = 'filled',
    iconBefore,
    iconAfter,
    loading = false,
    fullWidth = false,
    elevation = 1,
    className = '',
    disabled = false,
    children,
    ...restProps
  } = props;
  
  // Get color configuration for the current variant
  const colorConfig = COLORS[variant];
  
  // Get size configuration for the current size
  const sizeConfig = SIZES[size];
  
  // Generate button styles based on props
  const buttonStyles: React.CSSProperties = {
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
    padding: sizeConfig.padding,
    fontSize: sizeConfig.fontSize,
    fontWeight: 500,
    lineHeight: 1.5,
    textAlign: 'center',
    textDecoration: 'none',
    verticalAlign: 'middle',
    cursor: disabled || loading ? 'not-allowed' : 'pointer',
    userSelect: 'none',
    border: 'none',
    borderRadius: sizeConfig.borderRadius,
    transition: 'all 0.15s ease-in-out',
    height: sizeConfig.height,
    width: fullWidth ? '100%' : 'auto',
    opacity: disabled ? 0.65 : 1,
  };
  
  // Apply style-specific styles
  if (buttonStyle === 'filled') {
    buttonStyles.backgroundColor = colorConfig.default;
    buttonStyles.color = colorConfig.text;
    buttonStyles.boxShadow = elevation > 0 ? `0 ${elevation * 2}px ${elevation * 3}px rgba(0, 0, 0, 0.1)` : 'none';
  } else if (buttonStyle === 'outline') {
    buttonStyles.backgroundColor = 'transparent';
    buttonStyles.color = colorConfig.default;
    buttonStyles.border = `1px solid ${colorConfig.default}`;
  } else if (buttonStyle === 'text') {
    buttonStyles.backgroundColor = 'transparent';
    buttonStyles.color = colorConfig.default;
    buttonStyles.padding = '0.25rem 0.5rem';
  }
  
  // Spinner for loading state
  const Spinner = () => (
    <div
      style={{
        display: 'inline-block',
        width: '1em',
        height: '1em',
        borderRadius: '50%',
        border: `2px solid ${buttonStyle === 'filled' ? colorConfig.text : colorConfig.default}`,
        borderTopColor: 'transparent',
        animation: 'button-spinner 0.6s linear infinite',
        marginRight: children ? '0.5rem' : 0,
      }}
    />
  );
  
  // Create keyframes for spinner animation
  const spinnerStyle = document.createElement('style');
  spinnerStyle.innerHTML = `
    @keyframes button-spinner {
      to { transform: rotate(360deg); }
    }
  `;
  document.head.appendChild(spinnerStyle);
  
  return (
    <button
      ref={ref}
      style={buttonStyles}
      className={className}
      disabled={disabled || loading}
      {...restProps}
    >
      {loading && <Spinner />}
      {!loading && iconBefore && <span style={{ marginRight: '0.5rem' }}>{iconBefore}</span>}
      {children}
      {!loading && iconAfter && <span style={{ marginLeft: '0.5rem' }}>{iconAfter}</span>}
    </button>
  );
});

Button.displayName = 'Button';

export default Button;



/**
 * Input.tsx
 * 
 * Custom input component for CSTestForge UI.
 * Provides consistent styling and behavior across the application.
 */

import React, { 
  InputHTMLAttributes, 
  ReactNode, 
  forwardRef, 
  useState, 
  useEffect, 
  useRef, 
  ChangeEvent 
} from 'react';

// Primary brand color
const PRIMARY_COLOR = '#C54B8C';

// Derived colors
const COLORS = {
  border: {
    default: '#ced4da',
    focus: PRIMARY_COLOR,
    error: '#dc3545',
    disabled: '#e9ecef',
  },
  text: {
    default: '#212529',
    placeholder: '#6c757d',
    disabled: '#6c757d',
    error: '#dc3545',
  },
  background: {
    default: '#ffffff',
    disabled: '#e9ecef',
    readonly: '#f8f9fa',
  }
};

export type InputSize = 'small' | 'medium' | 'large';
export type InputType = 'text' | 'password' | 'email' | 'number' | 'tel' | 'url' | 'search';

export interface InputProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'size'> {
  /** Input label */
  label?: string;
  /** Helper text displayed below the input */
  helperText?: string;
  /** Error message displayed below the input */
  error?: string;
  /** Input size */
  size?: InputSize;
  /** Input type */
  type?: InputType;
  /** Whether the input is required */
  required?: boolean;
  /** Icon displayed before the input */
  iconBefore?: ReactNode;
  /** Icon displayed after the input */
  iconAfter?: ReactNode;
  /** Whether to show clear button for search input */
  showClear?: boolean;
  /** Whether the input has error */
  hasError?: boolean;
  /** Input full width */
  fullWidth?: boolean;
  /** Custom class name */
  className?: string;
  /** Callback when clear button is clicked */
  onClear?: () => void;
  /** Callback when input value changes */
  onChange?: (e: ChangeEvent<HTMLInputElement>) => void;
  /** Callback when input value changes with debounce */
  onChangeDebounced?: (value: string) => void;
  /** Debounce delay in milliseconds */
  debounceDelay?: number;
}

/**
 * Input component
 * 
 * @example
 * ```tsx
 * <Input
 *   label="Username"
 *   placeholder="Enter username"
 *   helperText="Your unique username"
 *   required
 * />
 * ```
 */
export const Input = forwardRef<HTMLInputElement, InputProps>((props, ref) => {
  const {
    label,
    helperText,
    error,
    size = 'medium',
    type = 'text',
    required = false,
    iconBefore,
    iconAfter,
    showClear = type === 'search',
    hasError = !!error,
    fullWidth = false,
    className = '',
    disabled = false,
    readOnly = false,
    placeholder,
    value,
    defaultValue,
    onClear,
    onChange,
    onChangeDebounced,
    debounceDelay = 300,
    ...restProps
  } = props;
  
  // State for internal value management (for controlled input)
  const [inputValue, setInputValue] = useState<string>(
    value !== undefined ? String(value) : defaultValue !== undefined ? String(defaultValue) : ''
  );
  
  // State for password visibility
  const [showPassword, setShowPassword] = useState(false);
  
  // Reference for debounce timer
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  // Update internal value when controlled value changes
  useEffect(() => {
    if (value !== undefined) {
      setInputValue(String(value));
    }
  }, [value]);
  
  // Handle input change
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    
    // Update internal value
    if (value === undefined) {
      setInputValue(newValue);
    }
    
    // Call original onChange handler
    if (onChange) {
      onChange(e);
    }
    
    // Handle debounced change
    if (onChangeDebounced) {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
      
      debounceTimerRef.current = setTimeout(() => {
        onChangeDebounced(newValue);
      }, debounceDelay);
    }
  };
  
  // Handle clear button click
  const handleClear = () => {
    // Update internal value
    if (value === undefined) {
      setInputValue('');
    }
    
    // Create a synthetic event
    const syntheticEvent = {
      target: { value: '' }
    } as ChangeEvent<HTMLInputElement>;
    
    // Call original onChange handler
    if (onChange) {
      onChange(syntheticEvent as ChangeEvent<HTMLInputElement>);
    }
    
    // Call onClear handler
    if (onClear) {
      onClear();
    }
    
    // Call debounced change handler
    if (onChangeDebounced) {
      onChangeDebounced('');
    }
  };
  
  // Toggle password visibility
  const togglePasswordVisibility = () => {
    setShowPassword(!showPassword);
  };
  
  // Generate input sizes
  const sizeStyles = {
    small: {
      height: '30px',
      fontSize: '0.875rem',
      padding: '0.25rem 0.5rem',
      borderRadius: '0.2rem',
    },
    medium: {
      height: '38px',
      fontSize: '1rem',
      padding: '0.375rem 0.75rem',
      borderRadius: '0.25rem',
    },
    large: {
      height: '48px',
      fontSize: '1.25rem',
      padding: '0.5rem 1rem',
      borderRadius: '0.3rem',
    },
  };
  
  // Selected size styles
  const currentSizeStyles = sizeStyles[size];
  
  // Container styles
  const containerStyles: React.CSSProperties = {
    display: 'inline-flex',
    flexDirection: 'column',
    width: fullWidth ? '100%' : 'auto',
    margin: '0 0 1rem 0',
  };
  
  // Label styles
  const labelStyles: React.CSSProperties = {
    display: 'block',
    marginBottom: '0.5rem',
    fontSize: size === 'small' ? '0.875rem' : size === 'large' ? '1.1rem' : '1rem',
    fontWeight: 500,
    color: hasError ? COLORS.text.error : COLORS.text.default,
  };
  
  // Input wrapper styles
  const inputWrapperStyles: React.CSSProperties = {
    position: 'relative',
    display: 'flex',
    alignItems: 'center',
    width: '100%',
  };
  
  // Input styles
  const inputStyles: React.CSSProperties = {
    height: currentSizeStyles.height,
    padding: currentSizeStyles.padding,
    paddingLeft: iconBefore ? `calc(${currentSizeStyles.padding} * 2 + 1rem)` : currentSizeStyles.padding,
    paddingRight: (iconAfter || (type === 'password') || (showClear && inputValue)) 
      ? `calc(${currentSizeStyles.padding} * 2 + 1rem)` 
      : currentSizeStyles.padding,
    fontSize: currentSizeStyles.fontSize,
    lineHeight: '1.5',
    color: disabled ? COLORS.text.disabled : COLORS.text.default,
    backgroundColor: disabled 
      ? COLORS.background.disabled 
      : readOnly 
        ? COLORS.background.readonly 
        : COLORS.background.default,
    backgroundClip: 'padding-box',
    border: `1px solid ${
      hasError 
        ? COLORS.border.error 
        : disabled 
          ? COLORS.border.disabled 
          : COLORS.border.default
    }`,
    borderRadius: currentSizeStyles.borderRadius,
    boxShadow: 'none',
    transition: 'border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out',
    appearance: 'none',
    width: '100%',
    minWidth: 0,
  };
  
  // Helper text styles
  const helperTextStyles: React.CSSProperties = {
    display: 'block',
    marginTop: '0.25rem',
    fontSize: '0.875rem',
    color: hasError ? COLORS.text.error : COLORS.text.placeholder,
  };
  
  // Icon styles (common)
  const iconStyles: React.CSSProperties = {
    position: 'absolute',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    height: '100%',
    width: '2rem',
    color: hasError ? COLORS.text.error : COLORS.text.placeholder,
    pointerEvents: 'none',
  };
  
  // Icon before styles
  const iconBeforeStyles: React.CSSProperties = {
    ...iconStyles,
    left: 0,
  };
  
  // Icon after styles
  const iconAfterStyles: React.CSSProperties = {
    ...iconStyles,
    right: 0,
  };
  
  // Action button styles
  const actionButtonStyles: React.CSSProperties = {
    position: 'absolute',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    height: '100%',
    width: '2rem',
    right: 0,
    border: 'none',
    background: 'none',
    cursor: 'pointer',
    color: COLORS.text.placeholder,
    transition: 'color 0.15s ease-in-out',
    padding: 0,
    zIndex: 1,
  };
  
  // Clear button icon
  const ClearIcon = () => (
    <svg 
      width="16" 
      height="16" 
      viewBox="0 0 16 16" 
      fill="none" 
      xmlns="http://www.w3.org/2000/svg"
    >
      <path 
        d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0-1A6 6 0 1 0 8 2a6 6 0 0 0 0 12zm2.828-8.414L9.414 7l1.414 1.414a.5.5 0 1 1-.707.707L8.707 7.707l-1.414 1.414a.5.5 0 1 1-.707-.707L7.993 7 6.58 5.586a.5.5 0 1 1 .707-.707l1.414 1.414 1.414-1.414a.5.5 0 0 1 .707.707z" 
        fill="currentColor"
      />
    </svg>
  );
  
  // Show password icon
  const ShowPasswordIcon = () => (
    <svg 
      width="16" 
      height="16" 
      viewBox="0 0 16 16" 
      fill="none" 
      xmlns="http://www.w3.org/2000/svg"
    >
      <path 
        d={showPassword 
          ? "M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"
          : "M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"
        }
        fill="currentColor"
      />
      <path 
        d={showPassword 
          ? "M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"
          : "M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8zm8 3.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"
        }
        fill="currentColor"
      />
      {showPassword && (
        <path 
          d="M14.354 1.646a.5.5 0 0 1 0 .708l-12 12a.5.5 0 0 1-.708-.708l12-12a.5.5 0 0 1 .708 0z"
          fill="currentColor"
        />
      )}
    </svg>
  );
  
  return (
    <div style={containerStyles} className={className}>
      {label && (
        <label style={labelStyles}>
          {label}
          {required && <span style={{ color: COLORS.text.error, marginLeft: '0.25rem' }}>*</span>}
        </label>
      )}
      
      <div style={inputWrapperStyles}>
        {iconBefore && <div style={iconBeforeStyles}>{iconBefore}</div>}
        
        <input
          ref={ref}
          type={type === 'password' ? (showPassword ? 'text' : 'password') : type}
          style={inputStyles}
          disabled={disabled}
          readOnly={readOnly}
          placeholder={placeholder}
          value={value !== undefined ? String(value) : undefined}
          defaultValue={defaultValue !== undefined ? String(defaultValue) : undefined}
          onChange={handleChange}
          required={required}
          {...restProps}
        />
        
        {/* Show clear button for search inputs or when explicitly requested */}
        {showClear && inputValue && !disabled && !readOnly && (
          <button 
            type="button" 
            style={actionButtonStyles} 
            onClick={handleClear}
            title="Clear"
            aria-label="Clear input"
          >
            <ClearIcon />
          </button>
        )}
        
        {/* Show password toggle for password inputs */}
        {type === 'password' && !disabled && !iconAfter && (
          <button 
            type="button" 
            style={actionButtonStyles} 
            onClick={togglePasswordVisibility}
            title={showPassword ? 'Hide password' : 'Show password'}
            aria-label={showPassword ? 'Hide password' : 'Show password'}
          >
            <ShowPasswordIcon />
          </button>
        )}
        
        {iconAfter && !showClear && type !== 'password' && (
          <div style={iconAfterStyles}>{iconAfter}</div>
        )}
      </div>
      
      {(helperText || error) && (
        <span style={helperTextStyles}>
          {error || helperText}
        </span>
      )}
    </div>
  );
});

Input.displayName = 'Input';

export default Input;


/**
 * Select.tsx
 * 
 * Custom select component for CSTestForge UI.
 * Provides consistent styling and behavior across the application.
 */

import React, { 
  ReactNode, 
  forwardRef, 
  useState, 
  useEffect, 
  useRef, 
  KeyboardEvent,
  FocusEvent,
  useMemo,
  MouseEvent
} from 'react';

// Primary brand color
const PRIMARY_COLOR = '#C54B8C';

// Derived colors
const COLORS = {
  border: {
    default: '#ced4da',
    focus: PRIMARY_COLOR,
    error: '#dc3545',
    disabled: '#e9ecef',
  },
  text: {
    default: '#212529',
    placeholder: '#6c757d',
    disabled: '#6c757d',
    error: '#dc3545',
  },
  background: {
    default: '#ffffff',
    hover: '#f8f9fa',
    selected: '#f2e6ed',
    disabled: '#e9ecef',
  },
  icon: {
    default: '#6c757d',
    active: PRIMARY_COLOR,
  }
};

export type SelectSize = 'small' | 'medium' | 'large';

export interface SelectOption {
  /** Option value */
  value: string;
  /** Option label */
  label: string;
  /** Whether the option is disabled */
  disabled?: boolean;
  /** Option group */
  group?: string;
  /** Option icon */
  icon?: ReactNode;
}

export interface SelectProps {
  /** Select options */
  options: SelectOption[];
  /** Selected value(s) */
  value?: string | string[];
  /** Default selected value(s) */
  defaultValue?: string | string[];
  /** Select label */
  label?: string;
  /** Helper text displayed below the select */
  helperText?: string;
  /** Error message displayed below the select */
  error?: string;
  /** Select size */
  size?: SelectSize;
  /** Whether the select is disabled */
  disabled?: boolean;
  /** Whether the select is required */
  required?: boolean;
  /** Whether the select allows multiple selection */
  multiple?: boolean;
  /** Whether the select is searchable */
  searchable?: boolean;
  /** Placeholder text */
  placeholder?: string;
  /** Maximum height of dropdown in pixels */
  maxDropdownHeight?: number;
  /** Whether the select has error */
  hasError?: boolean;
  /** Select full width */
  fullWidth?: boolean;
  /** Custom class name */
  className?: string;
  /** Custom dropdown class name */
  dropdownClassName?: string;
  /** Custom option class name */
  optionClassName?: string;
  /** Callback when selection changes */
  onChange?: (value: string | string[]) => void;
  /** Callback when select is focused */
  onFocus?: (event: FocusEvent<HTMLDivElement>) => void;
  /** Callback when select is blurred */
  onBlur?: (event: FocusEvent<HTMLDivElement>) => void;
}

/**
 * Select component
 * 
 * @example
 * ```tsx
 * <Select
 *   label="Country"
 *   options={[
 *     { value: 'us', label: 'United States' },
 *     { value: 'ca', label: 'Canada' },
 *     { value: 'mx', label: 'Mexico' }
 *   ]}
 *   placeholder="Select a country"
 * />
 * ```
 */
export const Select = forwardRef<HTMLDivElement, SelectProps>((props, ref) => {
  const {
    options,
    value,
    defaultValue,
    label,
    helperText,
    error,
    size = 'medium',
    disabled = false,
    required = false,
    multiple = false,
    searchable = false,
    placeholder = 'Select...',
    maxDropdownHeight = 300,
    hasError = !!error,
    fullWidth = false,
    className = '',
    dropdownClassName = '',
    optionClassName = '',
    onChange,
    onFocus,
    onBlur,
  } = props;
  
  // State for internal value management
  const [selectedValues, setSelectedValues] = useState<string[]>(() => {
    if (value !== undefined) {
      return Array.isArray(value) ? value : value ? [value] : [];
    }
    if (defaultValue !== undefined) {
      return Array.isArray(defaultValue) ? defaultValue : defaultValue ? [defaultValue] : [];
    }
    return [];
  });
  
  // State for dropdown visibility
  const [isOpen, setIsOpen] = useState(false);
  
  // State for search input
  const [searchText, setSearchText] = useState('');
  
  // References for DOM elements
  const containerRef = useRef<HTMLDivElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  
  // Update internal value when controlled value changes
  useEffect(() => {
    if (value !== undefined) {
      setSelectedValues(Array.isArray(value) ? value : value ? [value] : []);
    }
  }, [value]);
  
  // Focus search input when dropdown opens and searchable is true
  useEffect(() => {
    if (isOpen && searchable && searchInputRef.current) {
      searchInputRef.current.focus();
    }
  }, [isOpen, searchable]);
  
  // Close dropdown when clicking outside
  useEffect(() => {
    const handleOutsideClick = (event: MouseEvent) => {
      if (
        containerRef.current && 
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
        setSearchText('');
      }
    };
    
    if (isOpen) {
      document.addEventListener('mousedown', handleOutsideClick as any);
    }
    
    return () => {
      document.removeEventListener('mousedown', handleOutsideClick as any);
    };
  }, [isOpen]);
  
  // Generate options groups
  const optionsGroups = useMemo(() => {
    const groups: Record<string, SelectOption[]> = {};
    const ungroupedKey = '__ungrouped__';
    
    options.forEach(option => {
      const groupKey = option.group || ungroupedKey;
      if (!groups[groupKey]) {
        groups[groupKey] = [];
      }
      groups[groupKey].push(option);
    });
    
    return groups;
  }, [options]);
  
  // Filter options based on search text
  const filteredOptions = useMemo(() => {
    if (!searchText) return options;
    
    return options.filter(option => 
      option.label.toLowerCase().includes(searchText.toLowerCase()) ||
      option.value.toLowerCase().includes(searchText.toLowerCase())
    );
  }, [options, searchText]);
  
  // Generate filtered options groups
  const filteredOptionsGroups = useMemo(() => {
    const groups: Record<string, SelectOption[]> = {};
    const ungroupedKey = '__ungrouped__';
    
    filteredOptions.forEach(option => {
      const groupKey = option.group || ungroupedKey;
      if (!groups[groupKey]) {
        groups[groupKey] = [];
      }
      groups[groupKey].push(option);
    });
    
    return groups;
  }, [filteredOptions]);
  
  // Find option by value
  const findOption = (value: string) => {
    return options.find(option => option.value === value);
  };
  
  // Handle option selection
  const handleOptionSelect = (option: SelectOption) => {
    if (option.disabled) return;
    
    let newValues: string[];
    
    if (multiple) {
      // For multiple selection, toggle the selected option
      if (selectedValues.includes(option.value)) {
        newValues = selectedValues.filter(v => v !== option.value);
      } else {
        newValues = [...selectedValues, option.value];
      }
    } else {
      // For single selection, select the option and close the dropdown
      newValues = [option.value];
      setIsOpen(false);
      setSearchText('');
    }
    
    // Update internal state
    if (value === undefined) {
      setSelectedValues(newValues);
    }
    
    // Call onChange handler
    if (onChange) {
      onChange(multiple ? newValues : newValues[0] || '');
    }
  };
  
  // Handle select click
  const handleSelectClick = () => {
    if (disabled) return;
    
    setIsOpen(!isOpen);
    
    // Reset search text when closing
    if (isOpen) {
      setSearchText('');
    }
  };
  
  // Handle search input change
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchText(e.target.value);
  };
  
  // Handle key down events
  const handleKeyDown = (e: KeyboardEvent<HTMLDivElement>) => {
    if (disabled) return;
    
    switch (e.key) {
      case 'Enter':
      case ' ':
        if (!isOpen) {
          setIsOpen(true);
          e.preventDefault();
        }
        break;
      case 'Escape':
        if (isOpen) {
          setIsOpen(false);
          setSearchText('');
          e.preventDefault();
        }
        break;
      case 'ArrowDown':
        if (!isOpen) {
          setIsOpen(true);
          e.preventDefault();
        }
        break;
      case 'Tab':
        if (isOpen) {
          setIsOpen(false);
          setSearchText('');
        }
        break;
    }
  };
  
  // Handle focus event
  const handleFocus = (e: FocusEvent<HTMLDivElement>) => {
    if (onFocus) {
      onFocus(e);
    }
  };
  
  // Handle blur event
  const handleBlur = (e: FocusEvent<HTMLDivElement>) => {
    if (onBlur) {
      onBlur(e);
    }
  };
  
  // Remove a selected item (for multiple select with chips)
  const handleRemoveItem = (value: string, e: React.MouseEvent) => {
    e.stopPropagation();
    
    const newValues = selectedValues.filter(v => v !== value);
    
    // Update internal state
    if (props.value === undefined) {
      setSelectedValues(newValues);
    }
    
    // Call onChange handler
    if (onChange) {
      onChange(multiple ? newValues : newValues[0] || '');
    }
  };
  
  // Generate select sizes
  const sizeStyles = {
    small: {
      height: '30px',
      fontSize: '0.875rem',
      padding: '0.25rem 0.5rem',
      borderRadius: '0.2rem',
      chipHeight: '20px',
      chipFontSize: '0.75rem',
    },
    medium: {
      height: '38px',
      fontSize: '1rem',
      padding: '0.375rem 0.75rem',
      borderRadius: '0.25rem',
      chipHeight: '24px',
      chipFontSize: '0.875rem',
    },
    large: {
      height: '48px',
      fontSize: '1.25rem',
      padding: '0.5rem 1rem',
      borderRadius: '0.3rem',
      chipHeight: '30px',
      chipFontSize: '1rem',
    },
  };
  
  // Selected size styles
  const currentSizeStyles = sizeStyles[size];
  
  // Container styles
  const containerStyles: React.CSSProperties = {
    display: 'inline-flex',
    flexDirection: 'column',
    position: 'relative',
    width: fullWidth ? '100%' : '250px',
    margin: '0 0 1rem 0',
  };
  
  // Label styles
  const labelStyles: React.CSSProperties = {
    display: 'block',
    marginBottom: '0.5rem',
    fontSize: size === 'small' ? '0.875rem' : size === 'large' ? '1.1rem' : '1rem',
    fontWeight: 500,
    color: hasError ? COLORS.text.error : COLORS.text.default,
  };
  
  // Select wrapper styles
  const selectWrapperStyles: React.CSSProperties = {
    position: 'relative',
    display: 'flex',
    alignItems: 'center',
    width: '100%',
    cursor: disabled ? 'not-allowed' : 'pointer',
  };
  
  // Select styles
  const selectStyles: React.CSSProperties = {
    display: 'flex',
    flexWrap: 'wrap',
    alignItems: 'center',
    minHeight: currentSizeStyles.height,
    padding: multiple && selectedValues.length ? '0.25rem' : currentSizeStyles.padding,
    paddingRight: '2rem',
    fontSize: currentSizeStyles.fontSize,
    lineHeight: '1.5',
    color: disabled ? COLORS.text.disabled : COLORS.text.default,
    backgroundColor: disabled ? COLORS.background.disabled : COLORS.background.default,
    backgroundClip: 'padding-box',
    border: `1px solid ${
      hasError 
        ? COLORS.border.error 
        : disabled 
          ? COLORS.border.disabled 
          : isOpen 
            ? COLORS.border.focus 
            : COLORS.border.default
    }`,
    borderRadius: currentSizeStyles.borderRadius,
    boxShadow: isOpen ? `0 0 0 0.2rem rgba(${parseInt(PRIMARY_COLOR.slice(1, 3), 16)}, ${parseInt(PRIMARY_COLOR.slice(3, 5), 16)}, ${parseInt(PRIMARY_COLOR.slice(5, 7), 16)}, 0.25)` : 'none',
    transition: 'border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out',
    appearance: 'none',
    width: '100%',
    minWidth: 0,
    outline: 'none',
  };
  
  // Dropdown styles
  const dropdownStyles: React.CSSProperties = {
    position: 'absolute',
    top: '100%',
    left: 0,
    zIndex: 1000,
    display: isOpen ? 'block' : 'none',
    width: '100%',
    padding: '0.5rem 0',
    marginTop: '0.25rem',
    fontSize: currentSizeStyles.fontSize,
    color: COLORS.text.default,
    backgroundColor: COLORS.background.default,
    backgroundClip: 'padding-box',
    border: `1px solid ${COLORS.border.default}`,
    borderRadius: currentSizeStyles.borderRadius,
    boxShadow: '0 0.5rem 1rem rgba(0, 0, 0, 0.175)',
    maxHeight: maxDropdownHeight,
    overflowY: 'auto',
  };
  
  // Search input styles
  const searchInputStyles: React.CSSProperties = {
    width: '100%',
    padding: '0.375rem 0.75rem',
    fontSize: currentSizeStyles.fontSize,
    lineHeight: '1.5',
    color: COLORS.text.default,
    backgroundColor: COLORS.background.default,
    backgroundClip: 'padding-box',
    border: `1px solid ${COLORS.border.default}`,
    borderRadius: currentSizeStyles.borderRadius,
    margin: '0 0.5rem 0.5rem 0.5rem',
    boxSizing: 'border-box',
    width: 'calc(100% - 1rem)',
  };
  
  // Option group styles
  const optionGroupStyles: React.CSSProperties = {
    padding: '0',
    margin: '0',
  };
  
  // Option group label styles
  const optionGroupLabelStyles: React.CSSProperties = {
    display: 'block',
    padding: '0.25rem 1rem',
    fontSize: '0.75rem',
    fontWeight: 600,
    color: COLORS.text.placeholder,
    textTransform: 'uppercase',
    letterSpacing: '0.05em',
  };
  
  // Option styles
  const getOptionStyles = (option: SelectOption): React.CSSProperties => {
    const isSelected = selectedValues.includes(option.value);
    
    return {
      display: 'flex',
      alignItems: 'center',
      padding: '0.5rem 1rem',
      fontSize: currentSizeStyles.fontSize,
      fontWeight: isSelected ? 500 : 400,
      color: option.disabled ? COLORS.text.disabled : COLORS.text.default,
      backgroundColor: isSelected ? COLORS.background.selected : 'transparent',
      cursor: option.disabled ? 'not-allowed' : 'pointer',
      opacity: option.disabled ? 0.65 : 1,
      transition: 'background-color 0.15s ease-in-out',
      position: 'relative',
    };
  };
  
  // Placeholder styles
  const placeholderStyles: React.CSSProperties = {
    color: COLORS.text.placeholder,
  };
  
  // Arrow icon styles
  const arrowIconStyles: React.CSSProperties = {
    position: 'absolute',
    right: '0.75rem',
    top: '50%',
    transform: isOpen ? 'translateY(-50%) rotate(180deg)' : 'translateY(-50%)',
    color: isOpen ? COLORS.icon.active : COLORS.icon.default,
    transition: 'transform 0.15s ease-in-out',
    pointerEvents: 'none',
  };
  
  // Chip styles
  const chipStyles: React.CSSProperties = {
    display: 'inline-flex',
    alignItems: 'center',
    height: currentSizeStyles.chipHeight,
    padding: '0 0.25rem 0 0.5rem',
    margin: '0.125rem',
    fontSize: currentSizeStyles.chipFontSize,
    fontWeight: 400,
    lineHeight: 1,
    color: PRIMARY_COLOR,
    backgroundColor: COLORS.background.selected,
    borderRadius: '1rem',
    userSelect: 'none',
  };
  
  // Chip remove button styles
  const chipRemoveStyles: React.CSSProperties = {
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: '16px',
    height: '16px',
    marginLeft: '0.25rem',
    fontSize: '0.75rem',
    fontWeight: 700,
    lineHeight: 1,
    color: PRIMARY_COLOR,
    backgroundColor: 'transparent',
    border: 'none',
    borderRadius: '50%',
    cursor: 'pointer',
    transition: 'background-color 0.15s ease-in-out',
  };
  
  // Helper text styles
  const helperTextStyles: React.CSSProperties = {
    display: 'block',
    marginTop: '0.25rem',
    fontSize: '0.875rem',
    color: hasError ? COLORS.text.error : COLORS.text.placeholder,
  };
  
  // Arrow icon component
  const ArrowIcon = () => (
    <svg 
      width="10" 
      height="6" 
      viewBox="0 0 10 6" 
      fill="none" 
      xmlns="http://www.w3.org/2000/svg"
      style={arrowIconStyles}
    >
      <path 
        d="M1 1L5 5L9 1" 
        stroke="currentColor" 
        strokeWidth="2" 
        strokeLinecap="round" 
        strokeLinejoin="round"
      />
    </svg>
  );
  
  // Checkmark icon component
  const CheckmarkIcon = () => (
    <svg 
      width="12" 
      height="9" 
      viewBox="0 0 12 9" 
      fill="none" 
      xmlns="http://www.w3.org/2000/svg"
      style={{ marginRight: '0.5rem', flexShrink: 0 }}
    >
      <path 
        d="M4.5 8.5L1 5L2 4L4.5 6.5L10 1L11 2L4.5 8.5Z" 
        fill="currentColor" 
        stroke="currentColor" 
        strokeWidth="0.5" 
        strokeLinecap="round" 
        strokeLinejoin="round"
      />
    </svg>
  );
  
  // No results component
  const NoResults = () => (
    <div style={{ padding: '0.5rem 1rem', color: COLORS.text.placeholder }}>
      No results found
    </div>
  );
  
  // Render the selected value(s)
  const renderSelectedValue = () => {
    if (selectedValues.length === 0) {
      return (
        <span style={placeholderStyles}>{placeholder}</span>
      );
    }
    
    if (multiple) {
      return selectedValues.map(value => {
        const option = findOption(value);
        if (!option) return null;
        
        return (
          <div key={value} style={chipStyles}>
            {option.icon && (
              <span style={{ marginRight: '0.25rem' }}>{option.icon}</span>
            )}
            <span>{option.label}</span>
            <button
              type="button"
              style={chipRemoveStyles}
              onClick={(e) => handleRemoveItem(value, e)}
              aria-label={`Remove ${option.label}`}
            >
              &times;
            </button>
          </div>
        );
      });
    }
    
    const option = findOption(selectedValues[0]);
    if (!option) return null;
    
    return (
      <div style={{ display: 'flex', alignItems: 'center' }}>
        {option.icon && (
          <span style={{ marginRight: '0.5rem' }}>{option.icon}</span>
        )}
        <span>{option.label}</span>
      </div>
    );
  };
  
  // Render option groups
  const renderOptionGroups = () => {
    const groups = filteredOptionsGroups;
    const ungroupedKey = '__ungrouped__';
    
    // Handle no results
    if (Object.keys(groups).length === 0 || 
        (Object.keys(groups).length === 1 && 
        groups[ungroupedKey]?.length === 0)) {
      return <NoResults />;
    }
    
    return Object.entries(groups).map(([groupKey, groupOptions]) => {
      if (groupOptions.length === 0) return null;
      
      return (
        <div key={groupKey} style={optionGroupStyles} role="group">
          {groupKey !== ungroupedKey && (
            <div style={optionGroupLabelStyles}>{groupKey}</div>
          )}
          {groupOptions.map(option => (
            <div
              key={option.value}
              style={getOptionStyles(option)}
              className={optionClassName}
              onClick={() => handleOptionSelect(option)}
              onMouseDown={(e) => e.preventDefault()} // Prevent focus loss
              role="option"
              aria-selected={selectedValues.includes(option.value)}
              title={option.label}
            >
              {multiple && (
                selectedValues.includes(option.value) ? <CheckmarkIcon /> : <div style={{ width: 12, marginRight: '0.5rem' }} />
              )}
              {option.icon && (
                <span style={{ marginRight: '0.5rem' }}>{option.icon}</span>
              )}
              <span>{option.label}</span>
            </div>
          ))}
        </div>
      );
    });
  };
  
  return (
    <div 
      ref={containerRef}
      style={containerStyles} 
      className={className}
      tabIndex={disabled ? undefined : 0}
      onKeyDown={handleKeyDown}
      onFocus={handleFocus}
      onBlur={handleBlur}
    >
      {label && (
        <label style={labelStyles}>
          {label}
          {required && <span style={{ color: COLORS.text.error, marginLeft: '0.25rem' }}>*</span>}
        </label>
      )}
      
      <div 
        ref={ref}
        style={selectWrapperStyles} 
        onClick={handleSelectClick}
        role="combobox"
        aria-expanded={isOpen}
        aria-haspopup="listbox"
        aria-disabled={disabled}
        aria-required={required}
        aria-invalid={hasError}
      >
        <div style={selectStyles}>
          {renderSelectedValue()}
          <ArrowIcon />
        </div>
        
        <div 
          ref={dropdownRef}
          style={dropdownStyles} 
          className={dropdownClassName}
          role="listbox"
          aria-multiselectable={multiple}
        >
          {searchable && (
            <input
              ref={searchInputRef}
              type="text"
              style={searchInputStyles}
              value={searchText}
              onChange={handleSearchChange}
              placeholder="Search..."
              onClick={(e) => e.stopPropagation()}
              onKeyDown={(e) => e.stopPropagation()}
              autoComplete="off"
              aria-autocomplete="list"
            />
          )}
          
          {renderOptionGroups()}
        </div>
      </div>
      
      {(helperText || error) && (
        <span style={helperTextStyles}>
          {error || helperText}
        </span>
      )}
    </div>
  );
});

// Display name for debugging
Select.displayName = 'Select';

export default Select;


/**
 * Modal.tsx
 * 
 * Custom modal component for CSTestForge UI.
 * Provides consistent styling and behavior across the application.
 */

import React, { ReactNode, useEffect, useRef, useState } from 'react';
import { createPortal } from 'react-dom';

// Primary brand color
const PRIMARY_COLOR = '#C54B8C';

// Derived colors
const COLORS = {
  overlay: 'rgba(0, 0, 0, 0.5)',
  background: '#ffffff',
  text: {
    title: '#212529',
    content: '#212529',
  },
  border: '#dee2e6',
  closeButton: '#adb5bd',
  closeButtonHover: '#6c757d',
};

export type ModalSize = 'small' | 'medium' | 'large' | 'fullscreen';

export interface ModalProps {
  /** Whether the modal is open */
  isOpen: boolean;
  /** Modal title */
  title?: ReactNode;
  /** Modal content */
  children: ReactNode;
  /** Modal size */
  size?: ModalSize;
  /** Whether the modal can be closed by clicking outside */
  closeOnOverlayClick?: boolean;
  /** Whether the modal can be closed by pressing the escape key */
  closeOnEscape?: boolean;
  /** Whether the modal is draggable */
  draggable?: boolean;
  /** Whether to show the close button */
  showCloseButton?: boolean;
  /** Whether to center the modal vertically */
  centerVertically?: boolean;
  /** Custom z-index for the modal */
  zIndex?: number;
  /** Custom class name for the modal */
  className?: string;
  /** Custom class name for the overlay */
  overlayClassName?: string;
  /** Custom class name for the modal content */
  contentClassName?: string;
  /** Modal footer */
  footer?: ReactNode;
  /** Modal animation duration in milliseconds */
  animationDuration?: number;
  /** Callback when the modal is closed */
  onClose: () => void;
  /** Callback when the modal is fully opened (animation complete) */
  onAfterOpen?: () => void;
  /** Callback when the modal is fully closed (animation complete) */
  onAfterClose?: () => void;
}

/**
 * Modal component
 * 
 * @example
 * ```tsx
 * <Modal
 *   isOpen={isModalOpen}
 *   title="Confirmation"
 *   onClose={() => setIsModalOpen(false)}
 * >
 *   <p>Are you sure you want to continue?</p>
 *   <div>
 *     <Button onClick={() => setIsModalOpen(false)}>Cancel</Button>
 *     <Button variant="primary" onClick={handleConfirm}>Confirm</Button>
 *   </div>
 * </Modal>
 * ```
 */
export const Modal: React.FC<ModalProps> = ({
  isOpen,
  title,
  children,
  size = 'medium',
  closeOnOverlayClick = true,
  closeOnEscape = true,
  draggable = false,
  showCloseButton = true,
  centerVertically = true,
  zIndex = 1050,
  className = '',
  overlayClassName = '',
  contentClassName = '',
  footer,
  animationDuration = 300,
  onClose,
  onAfterOpen,
  onAfterClose,
}) => {
  // State for animation
  const [isAnimating, setIsAnimating] = useState(false);
  const [isVisible, setIsVisible] = useState(false);
  
  // State for tracking previous body overflow style
  const [previousBodyOverflow, setPreviousBodyOverflow] = useState<string>('');
  
  // State for dragging
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  // References for DOM elements
  const modalRef = useRef<HTMLDivElement>(null);
  const modalContentRef = useRef<HTMLDivElement>(null);
  const portalRef = useRef<HTMLDivElement | null>(null);
  
  // Create portal element if it doesn't exist
  useEffect(() => {
    if (!portalRef.current) {
      portalRef.current = document.createElement('div');
      document.body.appendChild(portalRef.current);
    }
    
    return () => {
      if (portalRef.current) {
        document.body.removeChild(portalRef.current);
        portalRef.current = null;
      }
    };
  }, []);
  
  // Handle escape key press
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (isOpen && e.key === 'Escape' && closeOnEscape) {
        onClose();
      }
    };
    
    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
    }
    
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen, closeOnEscape, onClose]);
  
  // Manage body scroll when modal opens and closes
  useEffect(() => {
    if (isOpen) {
      // Save current body overflow style
      setPreviousBodyOverflow(document.body.style.overflow);
      
      // Prevent body from scrolling
      document.body.style.overflow = 'hidden';
      
      // Start opening animation
      setIsAnimating(true);
      setIsVisible(true);
      
      // Call onAfterOpen when animation completes
      const timeout = setTimeout(() => {
        setIsAnimating(false);
        if (onAfterOpen) {
          onAfterOpen();
        }
      }, animationDuration);
      
      return () => {
        clearTimeout(timeout);
      };
    } else {
      // Only animate if previously visible
      if (isVisible) {
        // Start closing animation
        setIsAnimating(true);
        
        // Hide after animation completes
        const timeout = setTimeout(() => {
          setIsVisible(false);
          setIsAnimating(false);
          
          // Restore body overflow
          document.body.style.overflow = previousBodyOverflow;
          
          // Call onAfterClose when animation completes
          if (onAfterClose) {
            onAfterClose();
          }
          
          // Reset position if draggable
          if (draggable) {
            setPosition({ x: 0, y: 0 });
          }
        }, animationDuration);
        
        return () => {
          clearTimeout(timeout);
        };
      }
    }
  }, [isOpen, animationDuration, onAfterOpen, onAfterClose, previousBodyOverflow, isVisible, draggable]);
  
  // Handle mouse down for dragging
  const handleMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!draggable || !modalRef.current) return;
    
    // Only allow dragging from header
    const headerEl = modalRef.current.querySelector('[data-modal-header]');
    const target = e.target as HTMLElement;
    const isHeader = headerEl?.contains(target) || target === headerEl;
    
    if (!isHeader) return;
    
    e.preventDefault();
    
    const modalRect = modalRef.current.getBoundingClientRect();
    setIsDragging(true);
    setDragOffset({
      x: e.clientX - modalRect.left,
      y: e.clientY - modalRect.top,
    });
  };
  
  // Handle mouse move for dragging
  const handleMouseMove = (e: MouseEvent) => {
    if (!isDragging || !modalRef.current) return;
    
    e.preventDefault();
    
    const modalRect = modalRef.current.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Calculate new position with boundaries
    const newX = Math.max(0, Math.min(e.clientX - dragOffset.x, viewportWidth - modalRect.width));
    const newY = Math.max(0, Math.min(e.clientY - dragOffset.y, viewportHeight - modalRect.height));
    
    setPosition({ x: newX, y: newY });
  };
  
  // Handle mouse up for dragging
  const handleMouseUp = () => {
    if (isDragging) {
      setIsDragging(false);
    }
  };
  
  // Add mouse move and mouse up event listeners for dragging
  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    } else {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    }
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging]);
  
  // Focus trap navigation
  useEffect(() => {
    if (!isOpen || !modalContentRef.current) return;
    
    const modalContent = modalContentRef.current;
    
    // Find all focusable elements
    const focusableElements = modalContent.querySelectorAll(
      'a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
    );
    
    const firstElement = focusableElements[0] as HTMLElement;
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
    
    // Set focus to first element
    if (firstElement) {
      // setTimeout to avoid issues with animation
      setTimeout(() => {
        firstElement.focus();
      }, 0);
    }
    
    // Handle tab navigation
    const handleTabKey = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') return;
      
      if (e.shiftKey) {
        // Shift + Tab
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement?.focus();
        }
      } else {
        // Tab
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement?.focus();
        }
      }
    };
    
    document.addEventListener('keydown', handleTabKey);
    
    return () => {
      document.removeEventListener('keydown', handleTabKey);
    };
  }, [isOpen]);
  
  // If not visible, don't render
  if (!isVisible && !isOpen) {
    return null;
  }
  
  // Size styles
  const sizeStyles = {
    small: {
      width: '300px',
      maxWidth: '90%',
    },
    medium: {
      width: '500px',
      maxWidth: '90%',
    },
    large: {
      width: '800px',
      maxWidth: '90%',
    },
    fullscreen: {
      width: '100%',
      height: '100%',
      maxWidth: '100%',
      maxHeight: '100%',
      margin: 0,
      borderRadius: 0,
    },
  };
  
  // Selected size style
  const currentSizeStyle = sizeStyles[size];
  
  // Animation styles
  const getAnimationStyles = () => {
    if (!isAnimating) return {};
    
    if (isOpen) {
      return {
        animation: `modalFadeIn ${animationDuration}ms ease-out forwards`,
      };
    } else {
      return {
        animation: `modalFadeOut ${animationDuration}ms ease-in forwards`,
      };
    }
  };
  
  // Create animation keyframes
  const animationKeyframes = `
    @keyframes modalFadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, ${centerVertically ? '-50%' : '0'}) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translate(-50%, ${centerVertically ? '-50%' : '0'}) scale(1);
      }
    }
    
    @keyframes modalFadeOut {
      from {
        opacity: 1;
        transform: translate(-50%, ${centerVertically ? '-50%' : '0'}) scale(1);
      }
      to {
        opacity: 0;
        transform: translate(-50%, ${centerVertically ? '-50%' : '0'}) scale(0.95);
      }
    }
    
    @keyframes overlayFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes overlayFadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
  `;
  
  // Overlay styles
  const overlayStyles: React.CSSProperties = {
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: COLORS.overlay,
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex,
    animation: isAnimating
      ? isOpen
        ? `overlayFadeIn ${animationDuration}ms ease-out forwards`
        : `overlayFadeOut ${animationDuration}ms ease-in forwards`
      : undefined,
  };
  
  // Modal styles
  const modalStyles: React.CSSProperties = {
    position: 'fixed',
    left: draggable ? position.x : '50%',
    top: draggable 
      ? position.y 
      : centerVertically ? '50%' : '10%',
    transform: draggable 
      ? 'none' 
      : `translate(-50%, ${centerVertically ? '-50%' : '0'})`,
    backgroundColor: COLORS.background,
    borderRadius: size === 'fullscreen' ? 0 : '0.3rem',
    boxShadow: '0 0.5rem 1rem rgba(0, 0, 0, 0.15)',
    display: 'flex',
    flexDirection: 'column',
    maxHeight: size === 'fullscreen' ? '100%' : '90vh',
    ...currentSizeStyle,
    ...getAnimationStyles(),
    cursor: isDragging ? 'grabbing' : draggable ? 'grab' : 'default',
  };
  
  // Modal header styles
  const headerStyles: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: '1rem',
    borderBottom: `1px solid ${COLORS.border}`,
    userSelect: 'none',
  };
  
  // Title styles
  const titleStyles: React.CSSProperties = {
    margin: 0,
    fontSize: '1.25rem',
    fontWeight: 500,
    color: COLORS.text.title,
  };
  
  // Close button styles
  const closeButtonStyles: React.CSSProperties = {
    background: 'transparent',
    border: 'none',
    padding: '0.25rem',
    cursor: 'pointer',
    fontSize: '1.5rem',
    fontWeight: 700,
    color: COLORS.closeButton,
    opacity: 0.5,
    transition: 'opacity 0.15s ease-in-out',
    marginLeft: '1rem',
  };
  
  // Content styles
  const contentStyles: React.CSSProperties = {
    padding: '1rem',
    overflowY: 'auto',
    flex: 1,
    color: COLORS.text.content,
  };
  
  // Footer styles
  const footerStyles: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'flex-end',
    padding: '1rem',
    borderTop: `1px solid ${COLORS.border}`,
    gap: '0.5rem',
  };
  
  // Close icon component
  const CloseIcon = () => (
    <svg 
      width="16" 
      height="16" 
      viewBox="0 0 16 16" 
      fill="none" 
      xmlns="http://www.w3.org/2000/svg"
    >
      <path 
        d="M2 2L14 14M2 14L14 2" 
        stroke="currentColor" 
        strokeWidth="2" 
        strokeLinecap="round" 
        strokeLinejoin="round"
      />
    </svg>
  );
  
  // Modal content
  const modalContent = (
    <>
      <style>{animationKeyframes}</style>
      <div 
        style={overlayStyles} 
        className={overlayClassName}
        onClick={closeOnOverlayClick ? onClose : undefined}
        role="presentation"
      >
        <div
          ref={modalRef}
          style={modalStyles}
          className={className}
          onClick={(e) => e.stopPropagation()}
          onMouseDown={handleMouseDown}
          role="dialog"
          aria-modal="true"
          aria-labelledby={title ? 'modal-title' : undefined}
        >
          {title && (
            <div style={headerStyles} data-modal-header>
              <h2 id="modal-title" style={titleStyles}>
                {title}
              </h2>
              {showCloseButton && (
                <button
                  type="button"
                  style={closeButtonStyles}
                  onClick={onClose}
                  aria-label="Close"
                >
                  <CloseIcon />
                </button>
              )}
            </div>
          )}
          
          <div 
            ref={modalContentRef}
            style={contentStyles} 
            className={contentClassName}
          >
            {children}
          </div>
          
          {footer && (
            <div style={footerStyles}>
              {footer}
            </div>
          )}
        </div>
      </div>
    </>
  );
  
  // Render using portal
  return portalRef.current ? createPortal(modalContent, portalRef.current) : null;
};

export default Modal;


/**
 * Tabs.tsx
 * 
 * Custom tabs component for CSTestForge UI.
 * Provides consistent styling and behavior across the application.
 */

import React, { ReactNode, useState, useEffect, useRef, createContext, useContext, useMemo, useCallback } from 'react';

// Primary brand color
const PRIMARY_COLOR = '#C54B8C';

// Derived colors
const COLORS = {
  tab: {
    default: '#f8f9fa',
    active: '#ffffff',
    hover: '#e9ecef',
    disabled: '#e9ecef',
  },
  text: {
    default: '#6c757d',
    active: PRIMARY_COLOR,
    hover: '#495057',
    disabled: '#adb5bd',
  },
  border: {
    default: '#dee2e6',
    active: PRIMARY_COLOR,
  },
  background: {
    content: '#ffffff',
  }
};

export type TabsOrientation = 'horizontal' | 'vertical';
export type TabsVariant = 'default' | 'pills' | 'underlined';
export type TabsSize = 'small' | 'medium' | 'large';

export interface TabProps {
  /** Tab label */
  label: ReactNode;
  /** Tab content */
  children: ReactNode;
  /** Tab id */
  id?: string;
  /** Whether the tab is disabled */
  disabled?: boolean;
  /** Custom icon for the tab */
  icon?: ReactNode;
  /** Badge content for the tab */
  badge?: ReactNode;
  /** Custom class name for the tab */
  className?: string;
}

export interface TabsProps {
  /** Tab components */
  children: React.ReactElement<TabProps> | React.ReactElement<TabProps>[];
  /** Default active tab index */
  defaultActiveTab?: number;
  /** Active tab index (controlled) */
  activeTab?: number;
  /** Tabs orientation */
  orientation?: TabsOrientation;
  /** Tabs variant */
  variant?: TabsVariant;
  /** Tabs size */
  size?: TabsSize;
  /** Whether to fill the container width */
  fullWidth?: boolean;
  /** Whether to render tabs justified (equal width) */
  justified?: boolean;
  /** Custom class name for tabs container */
  className?: string;
  /** Custom class name for tab list */
  tabListClassName?: string;
  /** Custom class name for tab panels */
  tabPanelClassName?: string;
  /** Callback when tab changes */
  onTabChange?: (index: number) => void;
}

// Tabs context
interface TabsContextProps {
  activeTabIndex: number;
  setActiveTabIndex: (index: number) => void;
  orientation: TabsOrientation;
  variant: TabsVariant;
  size: TabsSize;
  registerTab: (id: string) => void;
  unregisterTab: (id: string) => void;
  getTabProps: (id: string, index: number, disabled?: boolean) => any;
  getTabPanelProps: (id: string, index: number) => any;
}

const TabsContext = createContext<TabsContextProps | undefined>(undefined);

// Custom hook to use tabs context
const useTabsContext = () => {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error('useTabsContext must be used within a TabsProvider');
  }
  return context;
};

/**
 * Tab component
 * 
 * @example
 * ```tsx
 * <Tab label="Profile">
 *   <p>Profile content</p>
 * </Tab>
 * ```
 */
export const Tab: React.FC<TabProps> = ({ children }) => {
  return <>{children}</>;
};

/**
 * Tabs component
 * 
 * @example
 * ```tsx
 * <Tabs>
 *   <Tab label="Profile">
 *     <p>Profile content</p>
 *   </Tab>
 *   <Tab label="Settings">
 *     <p>Settings content</p>
 *   </Tab>
 * </Tabs>
 * ```
 */
export const Tabs: React.FC<TabsProps> = ({
  children,
  defaultActiveTab = 0,
  activeTab,
  orientation = 'horizontal',
  variant = 'default',
  size = 'medium',
  fullWidth = false,
  justified = false,
  className = '',
  tabListClassName = '',
  tabPanelClassName = '',
  onTabChange,
}) => {
  // State for active tab index
  const [activeTabIndex, setInternalActiveTabIndex] = useState(defaultActiveTab);
  
  // Use controlled or uncontrolled value
  const currentActiveTabIndex = activeTab !== undefined ? activeTab : activeTabIndex;
  
  // Registry for tab IDs
  const [tabIds, setTabIds] = useState<string[]>([]);
  
  // Reference for tab list element
  const tabListRef = useRef<HTMLDivElement>(null);
  
  // Set active tab index with callback
  const setActiveTabIndex = (index: number) => {
    if (activeTab === undefined) {
      setInternalActiveTabIndex(index);
    }
    
    if (onTabChange) {
      onTabChange(index);
    }
  };
  
  // Register a tab ID
  const registerTab = useCallback((id: string) => {
    setTabIds(prev => [...prev, id]);
  }, []);
  
  // Unregister a tab ID
  const unregisterTab = useCallback((id: string) => {
    setTabIds(prev => prev.filter(tabId => tabId !== id));
  }, []);
  
  // Get tab props
  const getTabProps = useCallback((id: string, index: number, disabled = false) => {
    return {
      role: 'tab',
      'aria-selected': currentActiveTabIndex === index,
      'aria-disabled': disabled,
      'aria-controls': `${id}-panel`,
      id: `${id}-tab`,
      tabIndex: currentActiveTabIndex === index ? 0 : -1,
      onClick: () => {
        if (!disabled) {
          setActiveTabIndex(index);
        }
      },
      onKeyDown: (e: React.KeyboardEvent) => {
        if (disabled) return;
        
        if (e.key === 'Enter' || e.key === ' ') {
          setActiveTabIndex(index);
          e.preventDefault();
        }
      },
    };
  }, [currentActiveTabIndex, setActiveTabIndex]);
  
  // Get tab panel props
  const getTabPanelProps = useCallback((id: string, index: number) => {
    return {
      role: 'tabpanel',
      'aria-labelledby': `${id}-tab`,
      id: `${id}-panel`,
      hidden: currentActiveTabIndex !== index,
    };
  }, [currentActiveTabIndex]);
  
  // Generate unique IDs for tabs if not provided
  const childrenWithIds = useMemo(() => {
    const tabElements = React.Children.toArray(children) as React.ReactElement<TabProps>[];
    
    return tabElements.map((child, index) => {
      const id = child.props.id || `tab-${index}-${Math.random().toString(36).substr(2, 9)}`;
      return React.cloneElement(child, { id });
    });
  }, [children]);
  
  // Handle keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!tabListRef.current) return;
      
      // Only handle navigation when tab list is focused
      if (!tabListRef.current.contains(document.activeElement)) return;
      
      const tabElements = Array.from(tabListRef.current.querySelectorAll('[role="tab"]:not([aria-disabled="true"])'));
      const currentIndex = tabElements.indexOf(document.activeElement as Element);
      
      if (currentIndex === -1) return;
      
      let nextIndex;
      
      // Horizontal orientation
      if (orientation === 'horizontal') {
        if (e.key === 'ArrowRight') {
          nextIndex = (currentIndex + 1) % tabElements.length;
          e.preventDefault();
        } else if (e.key === 'ArrowLeft') {
          nextIndex = (currentIndex - 1 + tabElements.length) % tabElements.length;
          e.preventDefault();
        } else if (e.key === 'Home') {
          nextIndex = 0;
          e.preventDefault();
        } else if (e.key === 'End') {
          nextIndex = tabElements.length - 1;
          e.preventDefault();
        }
      }
      // Vertical orientation
      else {
        if (e.key === 'ArrowDown') {
          nextIndex = (currentIndex + 1) % tabElements.length;
          e.preventDefault();
        } else if (e.key === 'ArrowUp') {
          nextIndex = (currentIndex - 1 + tabElements.length) % tabElements.length;
          e.preventDefault();
        } else if (e.key === 'Home') {
          nextIndex = 0;
          e.preventDefault();
        } else if (e.key === 'End') {
          nextIndex = tabElements.length - 1;
          e.preventDefault();
        }
      }
      
      if (nextIndex !== undefined) {
        (tabElements[nextIndex] as HTMLElement).focus();
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [orientation]);
  
  // Size styles
  const sizeStyles = {
    small: {
      fontSize: '0.875rem',
      padding: variant === 'pills' ? '0.25rem 0.5rem' : '0.25rem 0.75rem',
      height: variant === 'underlined' ? '2rem' : 'auto',
    },
    medium: {
      fontSize: '1rem',
      padding: variant === 'pills' ? '0.375rem 0.75rem' : '0.5rem 1rem',
      height: variant === 'underlined' ? '2.5rem' : 'auto',
    },
    large: {
      fontSize: '1.25rem',
      padding: variant === 'pills' ? '0.5rem 1rem' : '0.75rem 1.5rem',
      height: variant === 'underlined' ? '3rem' : 'auto',
    },
  };
  
  // Current size style
  const currentSizeStyle = sizeStyles[size];
  
  // Container styles
  const containerStyles: React.CSSProperties = {
    display: 'flex',
    flexDirection: orientation === 'vertical' ? 'row' : 'column',
    width: fullWidth ? '100%' : 'auto',
  };
  
  // Tab list styles
  const tabListStyles: React.CSSProperties = {
    display: 'flex',
    flexDirection: orientation === 'vertical' ? 'column' : 'row',
    padding: 0,
    margin: 0,
    listStyle: 'none',
    flexShrink: 0,
    borderBottom: 
      orientation === 'horizontal' && variant === 'default' 
        ? `1px solid ${COLORS.border.default}` 
        : undefined,
    borderRight:
      orientation === 'vertical' && variant === 'default'
        ? `1px solid ${COLORS.border.default}`
        : undefined,
    width: orientation === 'vertical' 
      ? 'auto' 
      : fullWidth 
        ? '100%' 
        : 'auto',
  };
  
  // Tab panel container styles
  const tabPanelContainerStyles: React.CSSProperties = {
    flex: 1,
    marginTop: orientation === 'horizontal' && variant === 'default' ? 0 : undefined,
    marginLeft: orientation === 'vertical' && variant === 'default' ? '1rem' : undefined,
    padding: variant === 'default' ? '1rem' : '0',
  };
  
  // Tabs context value
  const tabsContextValue = useMemo(() => ({
    activeTabIndex: currentActiveTabIndex,
    setActiveTabIndex,
    orientation,
    variant,
    size,
    registerTab,
    unregisterTab,
    getTabProps,
    getTabPanelProps,
  }), [
    currentActiveTabIndex, 
    setActiveTabIndex,
    orientation,
    variant,
    size,
    registerTab,
    unregisterTab,
    getTabProps,
    getTabPanelProps,
  ]);
  
  // Render tabs
  return (
    <TabsContext.Provider value={tabsContextValue}>
      <div style={containerStyles} className={className}>
        <div 
          ref={tabListRef}
          style={tabListStyles} 
          className={tabListClassName}
          role="tablist"
          aria-orientation={orientation}
        >
          {React.Children.map(childrenWithIds, (child, index) => {
            if (!React.isValidElement<TabProps>(child)) return null;
            
            const { 
              id = '',
              label, 
              disabled = false, 
              icon, 
              badge,
              className: tabClassName = '',
            } = child.props;
            
            const isActive = currentActiveTabIndex === index;
            
            // Tab styles based on variant
            let tabStyles: React.CSSProperties = {
              ...currentSizeStyle,
              display: 'flex',
              alignItems: 'center',
              justifyContent: justified ? 'center' : 'flex-start',
              cursor: disabled ? 'not-allowed' : 'pointer',
              fontSize: currentSizeStyle.fontSize,
              fontWeight: isActive ? 500 : 400,
              userSelect: 'none',
              transition: 'all 0.15s ease-in-out',
              outline: 'none',
              whiteSpace: 'nowrap',
              flex: justified ? 1 : undefined,
              width: orientation === 'vertical' ? '100%' : undefined,
              opacity: disabled ? 0.65 : 1,
            };
            
            if (variant === 'default') {
              tabStyles = {
                ...tabStyles,
                color: disabled 
                  ? COLORS.text.disabled 
                  : isActive 
                    ? COLORS.text.active 
                    : COLORS.text.default,
                backgroundColor: disabled 
                  ? COLORS.tab.disabled 
                  : isActive 
                    ? COLORS.tab.active 
                    : COLORS.tab.default,
                borderTop: `1px solid ${isActive ? COLORS.border.default : 'transparent'}`,
                borderLeft: `1px solid ${isActive ? COLORS.border.default : 'transparent'}`,
                borderRight: `1px solid ${isActive ? COLORS.border.default : 'transparent'}`,
                borderBottom: `${isActive ? '1px solid ' + COLORS.tab.active : 'none'}`,
                marginBottom: orientation === 'horizontal' ? (isActive ? '-1px' : 0) : 0,
                marginRight: orientation === 'vertical' ? (isActive ? '-1px' : 0) : 0,
                borderTopLeftRadius: '0.25rem',
                borderTopRightRadius: '0.25rem',
                borderBottomLeftRadius: orientation === 'vertical' ? '0.25rem' : 0,
                borderBottomRightRadius: orientation === 'vertical' ? '0.25rem' : 0,
                position: 'relative',
                zIndex: isActive ? 1 : 0,
              };
            } else if (variant === 'pills') {
              tabStyles = {
                ...tabStyles,
                color: disabled 
                  ? COLORS.text.disabled 
                  : isActive 
                    ? '#fff' 
                    : COLORS.text.default,
                backgroundColor: disabled 
                  ? COLORS.tab.disabled 
                  : isActive 
                    ? PRIMARY_COLOR
                    : 'transparent',
                borderRadius: '0.25rem',
                margin: '0.25rem',
              };
            } else if (variant === 'underlined') {
              tabStyles = {
                ...tabStyles,
                color: disabled 
                  ? COLORS.text.disabled 
                  : isActive 
                    ? COLORS.text.active 
                    : COLORS.text.default,
                backgroundColor: 'transparent',
                borderBottom: isActive 
                  ? `2px solid ${COLORS.border.active}` 
                  : `2px solid transparent`,
                padding: `${currentSizeStyle.padding} 0`,
                margin: `0 ${orientation === 'horizontal' ? '1rem' : '0'} ${orientation === 'horizontal' ? '0' : '1rem'} 0`,
              };
            }
            
            return (
              <div
                style={tabStyles}
                className={tabClassName}
                {...getTabProps(id, index, disabled)}
              >
                {icon && (
                  <span style={{ 
                    marginRight: label ? '0.5rem' : 0,
                    display: 'flex',
                    alignItems: 'center',
                  }}>
                    {icon}
                  </span>
                )}
                <span>{label}</span>
                {badge && (
                  <span style={{ 
                    marginLeft: '0.5rem',
                    display: 'flex',
                    alignItems: 'center',
                  }}>
                    {badge}
                  </span>
                )}
              </div>
            );
          })}
        </div>
        
        <div style={tabPanelContainerStyles}>
          {React.Children.map(childrenWithIds, (child, index) => {
            if (!React.isValidElement<TabProps>(child)) return null;
            
            const { id = '', children: panelContent } = child.props;
            
            return (
              <div
                className={tabPanelClassName}
                {...getTabPanelProps(id, index)}
              >
                {panelContent}
              </div>
            );
          })}
        </div>
      </div>
    </TabsContext.Provider>
  );
};

export default Tabs;


/**
 * Tooltip.tsx
 * 
 * Custom tooltip component for CSTestForge UI.
 * Provides consistent styling and behavior across the application.
 */

import React, { ReactNode, useState, useRef, useEffect, useCallback } from 'react';
import { createPortal } from 'react-dom';

// Primary brand color
const PRIMARY_COLOR = '#C54B8C';

// Derived colors
const COLORS = {
  background: '#212529',
  text: '#ffffff',
  border: '#495057',
  arrow: '#212529',
};

export type TooltipPlacement = 'top' | 'right' | 'bottom' | 'left';
export type TooltipTrigger = 'hover' | 'click' | 'focus' | 'manual';
export type TooltipSize = 'small' | 'medium' | 'large';

export interface TooltipProps {
  /** Tooltip content */
  content: ReactNode;
  /** Children element to trigger the tooltip */
  children: ReactNode;
  /** Tooltip placement */
  placement?: TooltipPlacement;
  /** Tooltip trigger */
  trigger?: TooltipTrigger | TooltipTrigger[];
  /** Tooltip size */
  size?: TooltipSize;
  /** Whether the tooltip is open (controlled) */
  isOpen?: boolean;
  /** Default open state (uncontrolled) */
  defaultOpen?: boolean;
  /** Whether to show the arrow */
  showArrow?: boolean;
  /** Tooltip max width */
  maxWidth?: number;
  /** Delay before showing tooltip (ms) */
  showDelay?: number;
  /** Delay before hiding tooltip (ms) */
  hideDelay?: number;
  /** Offset from trigger element (px) */
  offset?: number;
  /** Whether to enable auto placement */
  autoPlacement?: boolean;
  /** Z-index for the tooltip */
  zIndex?: number;
  /** Custom class for the tooltip */
  className?: string;
  /** Callback when tooltip is shown */
  onShow?: () => void;
  /** Callback when tooltip is hidden */
  onHide?: () => void;
  /** Whether to disable the tooltip */
  disabled?: boolean;
  /** Custom ID for the tooltip */
  id?: string;
}

/**
 * Tooltip component
 * 
 * @example
 * ```tsx
 * <Tooltip content="This is a tooltip">
 *   <Button>Hover me</Button>
 * </Tooltip>
 * ```
 */
export const Tooltip: React.FC<TooltipProps> = ({
  content,
  children,
  placement = 'top',
  trigger = 'hover',
  size = 'medium',
  isOpen,
  defaultOpen = false,
  showArrow = true,
  maxWidth = 200,
  showDelay = 200,
  hideDelay = 200,
  offset = 8,
  autoPlacement = true,
  zIndex = 1070,
  className = '',
  onShow,
  onHide,
  disabled = false,
  id,
}) => {
  // State for tooltip visibility
  const [isVisible, setIsVisible] = useState(defaultOpen);
  
  // Use controlled or uncontrolled visibility
  const visible = isOpen !== undefined ? isOpen : isVisible;
  
  // References
  const triggerRef = useRef<HTMLDivElement>(null);
  const tooltipRef = useRef<HTMLDivElement>(null);
  const portalRef = useRef<HTMLDivElement | null>(null);
  const showTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const hideTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // State for tooltip position
  const [position, setPosition] = useState({
    top: 0,
    left: 0,
    actualPlacement: placement,
  });
  
  // Generate unique ID for tooltip
  const tooltipId = id || `tooltip-${Math.random().toString(36).substr(2, 9)}`;
  
  // Cleanup timeouts on unmount
  useEffect(() => {
    return () => {
      if (showTimeoutRef.current) {
        clearTimeout(showTimeoutRef.current);
      }
      
      if (hideTimeoutRef.current) {
        clearTimeout(hideTimeoutRef.current);
      }
    };
  }, []);
  
  // Create portal element if it doesn't exist
  useEffect(() => {
    if (!portalRef.current) {
      portalRef.current = document.createElement('div');
      document.body.appendChild(portalRef.current);
    }
    
    return () => {
      if (portalRef.current) {
        document.body.removeChild(portalRef.current);
        portalRef.current = null;
      }
    };
  }, []);
  
  // Calculate tooltip position
  const calculatePosition = useCallback(() => {
    if (!triggerRef.current || !tooltipRef.current) return;
    
    const triggerRect = triggerRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    const scrollTop = window.scrollY || document.documentElement.scrollTop;
    const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
    
    // Check if tooltip fits in the specified placement
    let actualPlacement = placement;
    
    if (autoPlacement) {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Check if tooltip fits in the specified placement
      if (placement === 'top' && triggerRect.top < tooltipRect.height + offset) {
        actualPlacement = 'bottom';
      } else if (placement === 'bottom' && triggerRect.bottom + tooltipRect.height + offset > viewportHeight) {
        actualPlacement = 'top';
      } else if (placement === 'left' && triggerRect.left < tooltipRect.width + offset) {
        actualPlacement = 'right';
      } else if (placement === 'right' && triggerRect.right + tooltipRect.width + offset > viewportWidth) {
        actualPlacement = 'left';
      }
    }
    
    // Calculate position based on placement
    let top = 0;
    let left = 0;
    
    switch (actualPlacement) {
      case 'top':
        top = triggerRect.top - tooltipRect.height - offset + scrollTop;
        left = triggerRect.left + (triggerRect.width / 2) - (tooltipRect.width / 2) + scrollLeft;
        break;
      case 'bottom':
        top = triggerRect.bottom + offset + scrollTop;
        left = triggerRect.left + (triggerRect.width / 2) - (tooltipRect.width / 2) + scrollLeft;
        break;
      case 'left':
        top = triggerRect.top + (triggerRect.height / 2) - (tooltipRect.height / 2) + scrollTop;
        left = triggerRect.left - tooltipRect.width - offset + scrollLeft;
        break;
      case 'right':
        top = triggerRect.top + (triggerRect.height / 2) - (tooltipRect.height / 2) + scrollTop;
        left = triggerRect.right + offset + scrollLeft;
        break;
    }
    
    // Ensure the tooltip stays within the viewport
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Adjust if tooltip goes beyond right edge
    if (left + tooltipRect.width > viewportWidth) {
      left = viewportWidth - tooltipRect.width - 10;
    }
    
    // Adjust if tooltip goes beyond left edge
    if (left < 10) {
      left = 10;
    }
    
    // Adjust if tooltip goes beyond bottom edge
    if (top + tooltipRect.height > viewportHeight + scrollTop) {
      top = viewportHeight + scrollTop - tooltipRect.height - 10;
    }
    
    // Adjust if tooltip goes beyond top edge
    if (top < scrollTop + 10) {
      top = scrollTop + 10;
    }
    
    setPosition({
      top,
      left,
      actualPlacement,
    });
  }, [placement, offset, autoPlacement]);
  
  // Show tooltip
  const showTooltip = useCallback(() => {
    if (disabled) return;
    
    if (hideTimeoutRef.current) {
      clearTimeout(hideTimeoutRef.current);
      hideTimeoutRef.current = null;
    }
    
    if (!visible) {
      showTimeoutRef.current = setTimeout(() => {
        if (isOpen === undefined) {
          setIsVisible(true);
        }
        
        if (onShow) {
          onShow();
        }
        
        // Calculate position after the tooltip is visible
        setTimeout(calculatePosition, 0);
      }, showDelay);
    }
  }, [visible, isOpen, showDelay, disabled, onShow, calculatePosition]);
  
  // Hide tooltip
  const hideTooltip = useCallback(() => {
    if (showTimeoutRef.current) {
      clearTimeout(showTimeoutRef.current);
      showTimeoutRef.current = null;
    }
    
    if (visible) {
      hideTimeoutRef.current = setTimeout(() => {
        if (isOpen === undefined) {
          setIsVisible(false);
        }
        
        if (onHide) {
          onHide();
        }
      }, hideDelay);
    }
  }, [visible, isOpen, hideDelay, onHide]);
  
  // Handle window resize
  useEffect(() => {
    const handleResize = () => {
      if (visible) {
        calculatePosition();
      }
    };
    
    window.addEventListener('resize', handleResize);
    window.addEventListener('scroll', handleResize, true);
    
    return () => {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('scroll', handleResize, true);
    };
  }, [visible, calculatePosition]);
  
  // Update position when tooltip becomes visible
  useEffect(() => {
    if (visible) {
      calculatePosition();
    }
  }, [visible, calculatePosition]);
  
  // Create trigger event handlers
  const getTriggerEvents = () => {
    const triggers = Array.isArray(trigger) ? trigger : [trigger];
    const events: any = {};
    
    if (disabled || trigger === 'manual') {
      return events;
    }
    
    if (triggers.includes('hover')) {
      events.onMouseEnter = showTooltip;
      events.onMouseLeave = hideTooltip;
    }
    
    if (triggers.includes('click')) {
      events.onClick = () => {
        if (visible) {
          hideTooltip();
        } else {
          showTooltip();
        }
      };
    }
    
    if (triggers.includes('focus')) {
      events.onFocus = showTooltip;
      events.onBlur = hideTooltip;
    }
    
    return events;
  };
  
  // Size styles
  const sizeStyles = {
    small: {
      padding: '0.25rem 0.5rem',
      fontSize: '0.75rem',
      borderRadius: '0.2rem',
      arrowSize: 6,
    },
    medium: {
      padding: '0.5rem 0.75rem',
      fontSize: '0.875rem',
      borderRadius: '0.25rem',
      arrowSize: 8,
    },
    large: {
      padding: '0.75rem 1rem',
      fontSize: '1rem',
      borderRadius: '0.3rem',
      arrowSize: 10,
    },
  };
  
  // Current size style
  const currentSizeStyle = sizeStyles[size];
  
  // Tooltip styles
  const tooltipStyles: React.CSSProperties = {
    position: 'absolute',
    top: `${position.top}px`,
    left: `${position.left}px`,
    backgroundColor: COLORS.background,
    color: COLORS.text,
    padding: currentSizeStyle.padding,
    borderRadius: currentSizeStyle.borderRadius,
    fontSize: currentSizeStyle.fontSize,
    maxWidth: `${maxWidth}px`,
    boxShadow: '0 0.25rem 0.5rem rgba(0, 0, 0, 0.15)',
    zIndex,
    whiteSpace: 'normal',
    wordWrap: 'break-word',
    pointerEvents: 'none',
    opacity: 0.95,
  };
  
  // Arrow styles
  const getArrowStyles = (): React.CSSProperties => {
    const arrowSize = currentSizeStyle.arrowSize;
    const arrowPosition = position.actualPlacement;
    
    const baseStyles: React.CSSProperties = {
      position: 'absolute',
      width: 0,
      height: 0,
      borderStyle: 'solid',
    };
    
    switch (arrowPosition) {
      case 'top':
        return {
          ...baseStyles,
          bottom: `-${arrowSize}px`,
          left: '50%',
          transform: 'translateX(-50%)',
          borderWidth: `${arrowSize}px ${arrowSize}px 0`,
          borderColor: `${COLORS.arrow} transparent transparent`,
        };
      case 'bottom':
        return {
          ...baseStyles,
          top: `-${arrowSize}px`,
          left: '50%',
          transform: 'translateX(-50%)',
          borderWidth: `0 ${arrowSize}px ${arrowSize}px`,
          borderColor: `transparent transparent ${COLORS.arrow}`,
        };
      case 'left':
        return {
          ...baseStyles,
          right: `-${arrowSize}px`,
          top: '50%',
          transform: 'translateY(-50%)',
          borderWidth: `${arrowSize}px 0 ${arrowSize}px ${arrowSize}px`,
          borderColor: `transparent transparent transparent ${COLORS.arrow}`,
        };
      case 'right':
        return {
          ...baseStyles,
          left: `-${arrowSize}px`,
          top: '50%',
          transform: 'translateY(-50%)',
          borderWidth: `${arrowSize}px ${arrowSize}px ${arrowSize}px 0`,
          borderColor: `transparent ${COLORS.arrow} transparent transparent`,
        };
      default:
        return baseStyles;
    }
  };
  
  // Trigger wrapper styles
  const triggerStyles: React.CSSProperties = {
    display: 'inline-block',
  };
  
  // Render tooltip content
  const renderTooltip = () => {
    if (!visible) return null;
    
    return portalRef.current ? createPortal(
      <div
        ref={tooltipRef}
        id={tooltipId}
        style={tooltipStyles}
        className={className}
        role="tooltip"
        aria-hidden={!visible}
      >
        {content}
        {showArrow && <div style={getArrowStyles()} />}
      </div>,
      portalRef.current
    ) : null;
  };
  
  // Render tooltip trigger
  return (
    <>
      <div
        ref={triggerRef}
        style={triggerStyles}
        aria-describedby={visible ? tooltipId : undefined}
        {...getTriggerEvents()}
      >
        {children}
      </div>
      {renderTooltip()}
    </>
  );
};

export default Tooltip;


/**
 * Checkbox.tsx
 * 
 * Custom checkbox component for CSTestForge UI.
 * Provides consistent styling and behavior across the application.
 */

import React, { InputHTMLAttributes, ReactNode, forwardRef, useState, useEffect } from 'react';

// Primary brand color
const PRIMARY_COLOR = '#C54B8C';

// Derived colors
const COLORS = {
  border: {
    default: '#ced4da',
    focus: PRIMARY_COLOR,
    checked: PRIMARY_COLOR,
    disabled: '#e9ecef',
  },
  background: {
    default: '#ffffff',
    hover: '#f8f9fa',
    checked: PRIMARY_COLOR,
    disabled: '#e9ecef',
  },
  checkmark: '#ffffff',
  text: {
    default: '#212529',
    disabled: '#6c757d',
    error: '#dc3545',
  },
};

export type CheckboxSize = 'small' | 'medium' | 'large';

export interface CheckboxProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'size'> {
  /** Checkbox label */
  label?: ReactNode;
  /** Checkbox size */
  size?: CheckboxSize;
  /** Helper text displayed below the checkbox */
  helperText?: string;
  /** Error message displayed below the checkbox */
  error?: string;
  /** Whether the checkbox has error */
  hasError?: boolean;
  /** Whether to use indeterminate state */
  indeterminate?: boolean;
  /** Custom class name */
  className?: string;
  /** Label position */
  labelPosition?: 'left' | 'right';
}

/**
 * Checkbox component
 * 
 * @example
 * ```tsx
 * <Checkbox 
 *   label="Remember me" 
 *   checked={rememberMe}
 *   onChange={(e) => setRememberMe(e.target.checked)}
 * />
 * ```
 */
export const Checkbox = forwardRef<HTMLInputElement, CheckboxProps>((props, ref) => {
  const {
    label,
    size = 'medium',
    helperText,
    error,
    hasError = !!error,
    indeterminate = false,
    className = '',
    labelPosition = 'right',
    checked,
    defaultChecked,
    disabled = false,
    onChange,
    ...restProps
  } = props;
  
  // State for internal checked state (for controlled checkbox)
  const [isChecked, setIsChecked] = useState<boolean>(
    checked !== undefined ? checked : defaultChecked || false
  );
  
  // Ref for the checkbox input element
  const checkboxRef = React.useRef<HTMLInputElement | null>(null);
  
  // Update internal checked state when controlled value changes
  useEffect(() => {
    if (checked !== undefined) {
      setIsChecked(checked);
    }
  }, [checked]);
  
  // Set indeterminate state
  useEffect(() => {
    if (checkboxRef.current) {
      checkboxRef.current.indeterminate = indeterminate;
    }
  }, [indeterminate]);
  
  // Merge refs
  const setRefs = (element: HTMLInputElement | null) => {
    checkboxRef.current = element;
    
    if (typeof ref === 'function') {
      ref(element);
    } else if (ref) {
      ref.current = element;
    }
  };
  
  // Handle checkbox change
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newChecked = e.target.checked;
    
    // Update internal state if uncontrolled
    if (checked === undefined) {
      setIsChecked(newChecked);
    }
    
    // Call original onChange handler
    if (onChange) {
      onChange(e);
    }
  };
  
  // Size styles
  const sizeStyles = {
    small: {
      checkboxSize: 16,
      labelFontSize: '0.875rem',
      labelPadding: '0 0.5rem',
      helperTextFontSize: '0.75rem',
      borderRadius: 3,
    },
    medium: {
      checkboxSize: 20,
      labelFontSize: '1rem',
      labelPadding: '0 0.75rem',
      helperTextFontSize: '0.875rem',
      borderRadius: 4,
    },
    large: {
      checkboxSize: 24,
      labelFontSize: '1.25rem',
      labelPadding: '0 1rem',
      helperTextFontSize: '1rem',
      borderRadius: 5,
    },
  };
  
  // Current size style
  const currentSizeStyle = sizeStyles[size];
  
  // Container styles
  const containerStyles: React.CSSProperties = {
    display: 'inline-flex',
    alignItems: 'flex-start',
    position: 'relative',
    marginBottom: '0.5rem',
    cursor: disabled ? 'not-allowed' : 'pointer',
  };
  
  // Input styles (visually hidden but accessible)
  const inputStyles: React.CSSProperties = {
    position: 'absolute',
    opacity: 0,
    width: `${currentSizeStyle.checkboxSize}px`,
    height: `${currentSizeStyle.checkboxSize}px`,
    margin: 0,
    cursor: disabled ? 'not-allowed' : 'pointer',
  };
  
  // Custom checkbox styles
  const customCheckboxStyles: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: `${currentSizeStyle.checkboxSize}px`,
    height: `${currentSizeStyle.checkboxSize}px`,
    flexShrink: 0,
    border: `1px solid ${hasError 
      ? COLORS.text.error 
      : disabled 
        ? COLORS.border.disabled 
        : isChecked || indeterminate 
          ? COLORS.border.checked 
          : COLORS.border.default}`,
    borderRadius: `${currentSizeStyle.borderRadius}px`,
    backgroundColor: disabled 
      ? COLORS.background.disabled 
      : isChecked || indeterminate 
        ? COLORS.background.checked 
        : COLORS.background.default,
    transition: 'all 0.15s ease-in-out',
    marginTop: '0.2rem',
    order: labelPosition === 'right' ? 0 : 1,
  };
  
  // Label styles
  const labelStyles: React.CSSProperties = {
    fontSize: currentSizeStyle.labelFontSize,
    lineHeight: 1.5,
    padding: labelPosition === 'right' 
      ? `0 0 0 ${currentSizeStyle.labelPadding.split(' ')[1]}`
      : `0 ${currentSizeStyle.labelPadding.split(' ')[1]} 0 0`,
    color: disabled ? COLORS.text.disabled : COLORS.text.default,
    cursor: disabled ? 'not-allowed' : 'pointer',
    userSelect: 'none',
    order: labelPosition === 'right' ? 1 : 0,
  };
  
  // Helper text styles
  const helperTextStyles: React.CSSProperties = {
    display: 'block',
    marginTop: '0.25rem',
    fontSize: currentSizeStyle.helperTextFontSize,
    color: hasError ? COLORS.text.error : COLORS.text.disabled,
    marginLeft: currentSizeStyle.checkboxSize + (labelPosition === 'right' ? 8 : 0),
  };
  
  // Checkmark styles
  const checkmarkStyles: React.CSSProperties = {
    display: isChecked && !indeterminate ? 'block' : 'none',
    width: '70%',
    height: '70%',
    border: 'solid 2px transparent',
    borderLeft: `solid 2px ${COLORS.checkmark}`,
    borderBottom: `solid 2px ${COLORS.checkmark}`,
    transform: 'rotate(-45deg)',
    transformOrigin: 'center center',
    marginTop: '-2px',
  };
  
  // Indeterminate mark styles
  const indeterminateMarkStyles: React.CSSProperties = {
    display: indeterminate ? 'block' : 'none',
    width: '70%',
    height: '2px',
    backgroundColor: COLORS.checkmark,
  };
  
  return (
    <div className={className}>
      <label style={containerStyles}>
        <input
          type="checkbox"
          ref={setRefs}
          style={inputStyles}
          checked={isChecked}
          disabled={disabled}
          onChange={handleChange}
          {...restProps}
        />
        <div style={customCheckboxStyles}>
          <div style={checkmarkStyles} />
          <div style={indeterminateMarkStyles} />
        </div>
        {label && <span style={labelStyles}>{label}</span>}
      </label>
      
      {(helperText || error) && (
        <div style={helperTextStyles}>
          {error || helperText}
        </div>
      )}
    </div>
  );
});

Checkbox.displayName = 'Checkbox';

export default Checkbox;


/**
 * Radio.tsx
 * 
 * Custom radio button component for CSTestForge UI.
 * Provides consistent styling and behavior across the application.
 */

import React, { InputHTMLAttributes, ReactNode, forwardRef, useState, useEffect } from 'react';

// Primary brand color
const PRIMARY_COLOR = '#C54B8C';

// Derived colors
const COLORS = {
  border: {
    default: '#ced4da',
    focus: PRIMARY_COLOR,
    checked: PRIMARY_COLOR,
    disabled: '#e9ecef',
  },
  background: {
    default: '#ffffff',
    hover: '#f8f9fa',
    checked: PRIMARY_COLOR,
    disabled: '#e9ecef',
  },
  dot: '#ffffff',
  text: {
    default: '#212529',
    disabled: '#6c757d',
    error: '#dc3545',
  },
};

export type RadioSize = 'small' | 'medium' | 'large';

export interface RadioProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'size'> {
  /** Radio label */
  label?: ReactNode;
  /** Radio size */
  size?: RadioSize;
  /** Helper text displayed below the radio */
  helperText?: string;
  /** Error message displayed below the radio */
  error?: string;
  /** Whether the radio has error */
  hasError?: boolean;
  /** Custom class name */
  className?: string;
  /** Label position */
  labelPosition?: 'left' | 'right';
}

/**
 * Radio component
 * 
 * @example
 * ```tsx
 * <Radio 
 *   label="Option 1" 
 *   name="options" 
 *   value="option1"
 *   checked={selectedOption === 'option1'}
 *   onChange={(e) => setSelectedOption(e.target.value)}
 * />
 * ```
 */
export const Radio = forwardRef<HTMLInputElement, RadioProps>((props, ref) => {
  const {
    label,
    size = 'medium',
    helperText,
    error,
    hasError = !!error,
    className = '',
    labelPosition = 'right',
    checked,
    defaultChecked,
    disabled = false,
    onChange,
    ...restProps
  } = props;
  
  // State for internal checked state (for controlled radio)
  const [isChecked, setIsChecked] = useState<boolean>(
    checked !== undefined ? checked : defaultChecked || false
  );
  
  // Update internal checked state when controlled value changes
  useEffect(() => {
    if (checked !== undefined) {
      setIsChecked(checked);
    }
  }, [checked]);
  
  // Handle radio change
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newChecked = e.target.checked;
    
    // Update internal state if uncontrolled
    if (checked === undefined) {
      setIsChecked(newChecked);
    }
    
    // Call original onChange handler
    if (onChange) {
      onChange(e);
    }
  };
  
  // Size styles
  const sizeStyles = {
    small: {
      radioSize: 16,
      dotSize: 6,
      labelFontSize: '0.875rem',
      labelPadding: '0 0.5rem',
      helperTextFontSize: '0.75rem',
    },
    medium: {
      radioSize: 20,
      dotSize: 8,
      labelFontSize: '1rem',
      labelPadding: '0 0.75rem',
      helperTextFontSize: '0.875rem',
    },
    large: {
      radioSize: 24,
      dotSize: 10,
      labelFontSize: '1.25rem',
      labelPadding: '0 1rem',
      helperTextFontSize: '1rem',
    },
  };
  
  // Current size style
  const currentSizeStyle = sizeStyles[size];
  
  // Container styles
  const containerStyles: React.CSSProperties = {
    display: 'inline-flex',
    alignItems: 'flex-start',
    position: 'relative',
    marginBottom: '0.5rem',
    cursor: disabled ? 'not-allowed' : 'pointer',
  };
  
  // Input styles (visually hidden but accessible)
  const inputStyles: React.CSSProperties = {
    position: 'absolute',
    opacity: 0,
    width: `${currentSizeStyle.radioSize}px`,
    height: `${currentSizeStyle.radioSize}px`,
    margin: 0,
    cursor: disabled ? 'not-allowed' : 'pointer',
  };
  
  // Custom radio styles
  const customRadioStyles: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: `${currentSizeStyle.radioSize}px`,
    height: `${currentSizeStyle.radioSize}px`,
    flexShrink: 0,
    border: `1px solid ${hasError 
      ? COLORS.text.error 
      : disabled 
        ? COLORS.border.disabled 
        : isChecked 
          ? COLORS.border.checked 
          : COLORS.border.default}`,
    borderRadius: '50%',
    backgroundColor: disabled 
      ? COLORS.background.disabled 
      : isChecked 
        ? COLORS.background.checked 
        : COLORS.background.default,
    transition: 'all 0.15s ease-in-out',
    marginTop: '0.2rem',
    order: labelPosition === 'right' ? 0 : 1,
  };
  
  // Label styles
  const labelStyles: React.CSSProperties = {
    fontSize: currentSizeStyle.labelFontSize,
    lineHeight: 1.5,
    padding: labelPosition === 'right' 
      ? `0 0 0 ${currentSizeStyle.labelPadding.split(' ')[1]}`
      : `0 ${currentSizeStyle.labelPadding.split(' ')[1]} 0 0`,
    color: disabled ? COLORS.text.disabled : COLORS.text.default,
    cursor: disabled ? 'not-allowed' : 'pointer',
    userSelect: 'none',
    order: labelPosition === 'right' ? 1 : 0,
  };
  
  // Helper text styles
  const helperTextStyles: React.CSSProperties = {
    display: 'block',
    marginTop: '0.25rem',
    fontSize: currentSizeStyle.helperTextFontSize,
    color: hasError ? COLORS.text.error : COLORS.text.disabled,
    marginLeft: currentSizeStyle.radioSize + (labelPosition === 'right' ? 8 : 0),
  };
  
  // Dot styles
  const dotStyles: React.CSSProperties = {
    width: `${currentSizeStyle.dotSize}px`,
    height: `${currentSizeStyle.dotSize}px`,
    borderRadius: '50%',
    backgroundColor: COLORS.dot,
    opacity: isChecked ? 1 : 0,
    transform: isChecked ? 'scale(1)' : 'scale(0)',
    transition: 'all 0.15s ease-in-out',
  };
  
  return (
    <div className={className}>
      <label style={containerStyles}>
        <input
          type="radio"
          ref={ref}
          style={inputStyles}
          checked={isChecked}
          disabled={disabled}
          onChange={handleChange}
          {...restProps}
        />
        <div style={customRadioStyles}>
          <div style={dotStyles} />
        </div>
        {label && <span style={labelStyles}>{label}</span>}
      </label>
      
      {(helperText || error) && (
        <div style={helperTextStyles}>
          {error || helperText}
        </div>
      )}
    </div>
  );
});

Radio.displayName = 'Radio';

export default Radio;


/**
 * Toggle.tsx
 * 
 * Custom toggle/switch component for CSTestForge UI.
 * Provides consistent styling and behavior across the application.
 */

import React, { InputHTMLAttributes, ReactNode, forwardRef, useState, useEffect } from 'react';

// Primary brand color
const PRIMARY_COLOR = '#C54B8C';

// Derived colors
const COLORS = {
  border: {
    default: '#ced4da',
    focus: PRIMARY_COLOR,
    disabled: '#e9ecef',
  },
  background: {
    on: PRIMARY_COLOR,
    off: '#ced4da',
    disabled: '#e9ecef',
  },
  handle: {
    on: '#ffffff',
    off: '#ffffff',
    disabled: '#adb5bd',
  },
  text: {
    default: '#212529',
    disabled: '#6c757d',
    error: '#dc3545',
  },
};

export type ToggleSize = 'small' | 'medium' | 'large';

export interface ToggleProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'size'> {
  /** Toggle label */
  label?: ReactNode;
  /** Toggle size */
  size?: ToggleSize;
  /** Helper text displayed below the toggle */
  helperText?: string;
  /** Error message displayed below the toggle */
  error?: string;
  /** Whether the toggle has error */
  hasError?: boolean;
  /** Custom class name */
  className?: string;
  /** Label position */
  labelPosition?: 'left' | 'right';
  /** On text label */
  onText?: string;
  /** Off text label */
  offText?: string;
  /** Show on/off text */
  showText?: boolean;
  /** Whether the toggle is checked */
  checked?: boolean;
  /** Default checked state */
  defaultChecked?: boolean;
  /** Whether the toggle is disabled */
  disabled?: boolean;
  /** Callback when toggle changes */
  onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;
}

/**
 * Toggle (Switch) component
 * 
 * @example
 * ```tsx
 * <Toggle 
 *   label="Enable notifications" 
 *   checked={notificationsEnabled}
 *   onChange={(e) => setNotificationsEnabled(e.target.checked)}
 * />
 * ```
 */
export const Toggle = forwardRef<HTMLInputElement, ToggleProps>((props, ref) => {
  const {
    label,
    size = 'medium',
    helperText,
    error,
    hasError = !!error,
    className = '',
    labelPosition = 'right',
    onText = 'On',
    offText = 'Off',
    showText = false,
    checked,
    defaultChecked = false,
    disabled = false,
    onChange,
    ...restProps
  } = props;
  
  // State for internal checked state (for controlled toggle)
  const [isChecked, setIsChecked] = useState<boolean>(
    checked !== undefined ? checked : defaultChecked
  );
  
  // Update internal checked state when controlled value changes
  useEffect(() => {
    if (checked !== undefined) {
      setIsChecked(checked);
    }
  }, [checked]);
  
  // Handle toggle change
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newChecked = e.target.checked;
    
    // Update internal state if uncontrolled
    if (checked === undefined) {
      setIsChecked(newChecked);
    }
    
    // Call original onChange handler
    if (onChange) {
      onChange(e);
    }
  };
  
  // Size styles
  const sizeStyles = {
    small: {
      width: 32,
      height: 16,
      handleSize: 12,
      handleOffset: 2,
      labelFontSize: '0.875rem',
      labelPadding: '0 0.5rem',
      helperTextFontSize: '0.75rem',
      textFontSize: '0.65rem',
    },
    medium: {
      width: 44,
      height: 22,
      handleSize: 18,
      handleOffset: 2,
      labelFontSize: '1rem',
      labelPadding: '0 0.75rem',
      helperTextFontSize: '0.875rem',
      textFontSize: '0.75rem',
    },
    large: {
      width: 56,
      height: 28,
      handleSize: 24,
      handleOffset: 2,
      labelFontSize: '1.25rem',
      labelPadding: '0 1rem',
      helperTextFontSize: '1rem',
      textFontSize: '0.825rem',
    },
  };
  
  // Current size style
  const currentSizeStyle = sizeStyles[size];
  
  // Container styles
  const containerStyles: React.CSSProperties = {
    display: 'inline-flex',
    alignItems: 'center',
    position: 'relative',
    marginBottom: '0.5rem',
  };
  
  // Input styles (visually hidden but accessible)
  const inputStyles: React.CSSProperties = {
    position: 'absolute',
    opacity: 0,
    width: '100%',
    height: '100%',
    margin: 0,
    cursor: disabled ? 'not-allowed' : 'pointer',
    zIndex: 1,
  };
  
  // Toggle track styles
  const trackStyles: React.CSSProperties = {
    position: 'relative',
    width: `${currentSizeStyle.width}px`,
    height: `${currentSizeStyle.height}px`,
    backgroundColor: disabled 
      ? COLORS.background.disabled 
      : isChecked 
        ? COLORS.background.on 
        : COLORS.background.off,
    borderRadius: `${currentSizeStyle.height}px`,
    transition: 'all 0.15s ease-in-out',
    cursor: disabled ? 'not-allowed' : 'pointer',
    flexShrink: 0,
    order: labelPosition === 'right' ? 0 : 1,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: `0 ${currentSizeStyle.handleSize / 3}px`,
    boxSizing: 'border-box',
    border: hasError 
      ? `1px solid ${COLORS.text.error}` 
      : 'none',
  };
  
  // Toggle handle styles
  const handleStyles: React.CSSProperties = {
    position: 'absolute',
    top: `${currentSizeStyle.handleOffset}px`,
    left: isChecked 
      ? `${currentSizeStyle.width - currentSizeStyle.handleSize - currentSizeStyle.handleOffset}px` 
      : `${currentSizeStyle.handleOffset}px`,
    width: `${currentSizeStyle.handleSize}px`,
    height: `${currentSizeStyle.handleSize}px`,
    backgroundColor: disabled 
      ? COLORS.handle.disabled 
      : isChecked 
        ? COLORS.handle.on 
        : COLORS.handle.off,
    borderRadius: '50%',
    transition: 'all 0.15s ease-in-out',
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
  };
  
  // Label styles
  const labelStyles: React.CSSProperties = {
    fontSize: currentSizeStyle.labelFontSize,
    lineHeight: 1.5,
    padding: labelPosition === 'right' 
      ? `0 0 0 ${currentSizeStyle.labelPadding.split(' ')[1]}`
      : `0 ${currentSizeStyle.labelPadding.split(' ')[1]} 0 0`,
    color: disabled ? COLORS.text.disabled : COLORS.text.default,
    cursor: disabled ? 'not-allowed' : 'pointer',
    userSelect: 'none',
    order: labelPosition === 'right' ? 1 : 0,
  };
  
  // Helper text styles
  const helperTextStyles: React.CSSProperties = {
    display: 'block',
    marginTop: '0.25rem',
    fontSize: currentSizeStyle.helperTextFontSize,
    color: hasError ? COLORS.text.error : COLORS.text.disabled,
    marginLeft: labelPosition === 'right' ? `${currentSizeStyle.width + 8}px` : 0,
  };
  
  // Text styles (On/Off text)
  const baseTextStyles: React.CSSProperties = {
    fontSize: currentSizeStyle.textFontSize,
    fontWeight: 'bold',
    color: '#ffffff',
    userSelect: 'none',
    lineHeight: 1,
  };
  
  // On text styles
  const onTextStyles: React.CSSProperties = {
    ...baseTextStyles,
    marginRight: `${currentSizeStyle.handleSize / 2}px`,
    opacity: isChecked ? 1 : 0,
  };
  
  // Off text styles
  const offTextStyles: React.CSSProperties = {
    ...baseTextStyles,
    marginLeft: `${currentSizeStyle.handleSize / 2}px`,
    opacity: isChecked ? 0 : 1,
  };
  
  return (
    <div className={className}>
      <div style={containerStyles}>
        <label style={{ display: 'flex', alignItems: 'center', cursor: disabled ? 'not-allowed' : 'pointer' }}>
          <input
            type="checkbox"
            ref={ref}
            style={inputStyles}
            checked={isChecked}
            disabled={disabled}
            onChange={handleChange}
            {...restProps}
          />
          <div style={trackStyles}>
            {showText && isChecked && <span style={onTextStyles}>{onText}</span>}
            <div style={handleStyles} />
            {showText && !isChecked && <span style={offTextStyles}>{offText}</span>}
          </div>
          {label && <span style={labelStyles}>{label}</span>}
        </label>
      </div>
      
      {(helperText || error) && (
        <div style={helperTextStyles}>
          {error || helperText}
        </div>
      )}
    </div>
  );
});

Toggle.displayName = 'Toggle';

export default Toggle;



/**
 * CSDateUtils.ts
 * 
 * Utility class for date and time operations.
 * Provides methods for common date manipulations, formatting, and validations.
 */

export class CSDateUtils {
  /**
   * Formats a date into a string according to the specified format.
   * 
   * Format specifiers:
   * - YYYY: 4-digit year (e.g., 2025)
   * - YY: 2-digit year (e.g., 25)
   * - MM: 2-digit month (01-12)
   * - MMM: 3-letter month abbreviation (e.g., Jan)
   * - MMMM: Full month name (e.g., January)
   * - DD: 2-digit day of month (01-31)
   * - HH: 2-digit hour in 24-hour format (00-23)
   * - hh: 2-digit hour in 12-hour format (01-12)
   * - mm: 2-digit minute (00-59)
   * - ss: 2-digit second (00-59)
   * - SSS: 3-digit millisecond (000-999)
   * - A: AM/PM
   * - a: am/pm
   * - ddd: 3-letter day of week (e.g., Mon)
   * - dddd: Full day of week (e.g., Monday)
   * 
   * @param date The date to format
   * @param format The format string (e.g., "YYYY-MM-DD HH:mm:ss")
   * @returns The formatted date string
   */
  public static format(date: Date, format: string): string {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    // Month names and day names
    const monthNames = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    
    const monthAbbreviations = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    
    const dayNames = [
      'Sunday', 'Monday', 'Tuesday', 'Wednesday',
      'Thursday', 'Friday', 'Saturday'
    ];
    
    const dayAbbreviations = [
      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
    ];
    
    // Format tokens
    const tokens: Record<string, () => string> = {
      'YYYY': () => date.getFullYear().toString(),
      'YY': () => (date.getFullYear() % 100).toString().padStart(2, '0'),
      'MM': () => (date.getMonth() + 1).toString().padStart(2, '0'),
      'MMM': () => monthAbbreviations[date.getMonth()],
      'MMMM': () => monthNames[date.getMonth()],
      'DD': () => date.getDate().toString().padStart(2, '0'),
      'HH': () => date.getHours().toString().padStart(2, '0'),
      'hh': () => {
        const hours = date.getHours();
        return (hours % 12 || 12).toString().padStart(2, '0');
      },
      'mm': () => date.getMinutes().toString().padStart(2, '0'),
      'ss': () => date.getSeconds().toString().padStart(2, '0'),
      'SSS': () => date.getMilliseconds().toString().padStart(3, '0'),
      'A': () => date.getHours() < 12 ? 'AM' : 'PM',
      'a': () => date.getHours() < 12 ? 'am' : 'pm',
      'ddd': () => dayAbbreviations[date.getDay()],
      'dddd': () => dayNames[date.getDay()]
    };
    
    // Replace tokens with actual values
    let result = format;
    
    // Sort tokens by length (descending) to avoid shorter tokens overriding longer ones
    const sortedTokens = Object.keys(tokens).sort((a, b) => b.length - a.length);
    
    for (const token of sortedTokens) {
      result = result.replace(new RegExp(token, 'g'), tokens[token]());
    }
    
    return result;
  }
  
  /**
   * Parses a date string according to the specified format.
   * 
   * @param dateString The date string to parse
   * @param format The format string (e.g., "YYYY-MM-DD HH:mm:ss")
   * @returns A Date object
   */
  public static parse(dateString: string, format: string): Date {
    if (!dateString || !format) {
      throw new Error('Date string and format are required');
    }
    
    const monthNames = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ];
    
    const monthAbbreviations = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    
    // Create maps for token extraction
    const tokenRegexMap: Record<string, [RegExp, (match: string) => number]> = {
      'YYYY': [/(\d{4})/, match => parseInt(match, 10)],
      'YY': [/(\d{2})/, match => {
        const year = parseInt(match, 10);
        return year + (year < 50 ? 2000 : 1900);
      }],
      'MM': [/(\d{2})/, match => parseInt(match, 10) - 1],
      'MMM': [/([A-Za-z]{3})/, match => {
        const index = monthAbbreviations.findIndex(m => 
          m.toLowerCase() === match.toLowerCase());
        return index !== -1 ? index : 0;
      }],
      'MMMM': [/([A-Za-z]+)/, match => {
        const index = monthNames.findIndex(m => 
          m.toLowerCase() === match.toLowerCase());
        return index !== -1 ? index : 0;
      }],
      'DD': [/(\d{2})/, match => parseInt(match, 10)],
      'HH': [/(\d{2})/, match => parseInt(match, 10)],
      'hh': [/(\d{2})/, match => parseInt(match, 10)],
      'mm': [/(\d{2})/, match => parseInt(match, 10)],
      'ss': [/(\d{2})/, match => parseInt(match, 10)],
      'SSS': [/(\d{3})/, match => parseInt(match, 10)],
      'A': [/(AM|PM)/, match => match === 'PM' ? 12 : 0],
      'a': [/(am|pm)/, match => match === 'pm' ? 12 : 0]
    };
    
    // Initialize date components
    let year = new Date().getFullYear();
    let month = 0;
    let day = 1;
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    let milliseconds = 0;
    let meridiem = 0;
    
    // Sort tokens by length (descending) to avoid shorter tokens overriding longer ones
    const sortedTokens = Object.keys(tokenRegexMap).sort((a, b) => b.length - a.length);
    
    // Replace each token with a capture group
    let regexPattern = format;
    for (const token of sortedTokens) {
      regexPattern = regexPattern.replace(new RegExp(token, 'g'), 
        (_, index) => `__CAPTURE_${index}_${token}__`);
    }
    
    // Escape special regex characters
    regexPattern = regexPattern.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1');
    
    // Replace capture placeholders with capture groups
    for (const token of sortedTokens) {
      regexPattern = regexPattern.replace(
        new RegExp(`__CAPTURE_\\d+_${token}__`, 'g'),
        `(${tokenRegexMap[token][0].source})`
      );
    }
    
    // Create and execute the regex
    const regex = new RegExp(`^${regexPattern}$`);
    const matches = regex.exec(dateString);
    
    if (!matches) {
      throw new Error(`Date string "${dateString}" does not match format "${format}"`);
    }
    
    // Extract matched groups
    let match = 1;
    let formatCopy = format;
    
    for (const token of sortedTokens) {
      const tokenIndex = formatCopy.indexOf(token);
      if (tokenIndex !== -1) {
        // Extract the value using the provided function
        const value = tokenRegexMap[token][1](matches[match]);
        
        // Update the appropriate date component
        switch (token) {
          case 'YYYY':
          case 'YY':
            year = value;
            break;
          case 'MM':
          case 'MMM':
          case 'MMMM':
            month = value;
            break;
          case 'DD':
            day = value;
            break;
          case 'HH':
            hours = value;
            break;
          case 'hh':
            hours = value % 12; // Will be adjusted by meridiem later
            break;
          case 'mm':
            minutes = value;
            break;
          case 'ss':
            seconds = value;
            break;
          case 'SSS':
            milliseconds = value;
            break;
          case 'A':
          case 'a':
            meridiem = value;
            break;
        }
        
        formatCopy = formatCopy.replace(token, ''); // Remove processed token
        match++;
      }
    }
    
    // Adjust hours for 12-hour format with meridiem
    if (formatCopy.includes('hh')) {
      hours = (hours % 12) + meridiem;
    }
    
    return new Date(year, month, day, hours, minutes, seconds, milliseconds);
  }
  
  /**
   * Creates a new date by adding the specified amount to the given date.
   * 
   * @param date The date to add to
   * @param amount The amount to add
   * @param unit The unit to add (years, months, days, hours, minutes, seconds, milliseconds)
   * @returns A new Date with the amount added
   */
  public static add(date: Date, amount: number, unit: 'years' | 'months' | 'days' | 'hours' | 'minutes' | 'seconds' | 'milliseconds'): Date {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    const result = new Date(date);
    
    switch (unit) {
      case 'years':
        result.setFullYear(result.getFullYear() + amount);
        break;
      case 'months':
        result.setMonth(result.getMonth() + amount);
        break;
      case 'days':
        result.setDate(result.getDate() + amount);
        break;
      case 'hours':
        result.setHours(result.getHours() + amount);
        break;
      case 'minutes':
        result.setMinutes(result.getMinutes() + amount);
        break;
      case 'seconds':
        result.setSeconds(result.getSeconds() + amount);
        break;
      case 'milliseconds':
        result.setMilliseconds(result.getMilliseconds() + amount);
        break;
      default:
        throw new Error(`Invalid unit: ${unit}`);
    }
    
    return result;
  }
  
  /**
   * Creates a new date by subtracting the specified amount from the given date.
   * 
   * @param date The date to subtract from
   * @param amount The amount to subtract
   * @param unit The unit to subtract (years, months, days, hours, minutes, seconds, milliseconds)
   * @returns A new Date with the amount subtracted
   */
  public static subtract(date: Date, amount: number, unit: 'years' | 'months' | 'days' | 'hours' | 'minutes' | 'seconds' | 'milliseconds'): Date {
    return this.add(date, -amount, unit);
  }
  
  /**
   * Gets the difference between two dates in the specified unit.
   * 
   * @param date1 The first date
   * @param date2 The second date
   * @param unit The unit to get the difference in
   * @returns The difference between the two dates
   */
  public static diff(date1: Date, date2: Date, unit: 'years' | 'months' | 'days' | 'hours' | 'minutes' | 'seconds' | 'milliseconds'): number {
    if (!date1 || !(date1 instanceof Date) || isNaN(date1.getTime())) {
      throw new Error('Invalid date1');
    }
    
    if (!date2 || !(date2 instanceof Date) || isNaN(date2.getTime())) {
      throw new Error('Invalid date2');
    }
    
    const millisecondsDiff = date2.getTime() - date1.getTime();
    
    switch (unit) {
      case 'years': {
        // Calculate exact years difference accounting for leap years
        const years1 = date1.getFullYear();
        const years2 = date2.getFullYear();
        const month1 = date1.getMonth();
        const month2 = date2.getMonth();
        const day1 = date1.getDate();
        const day2 = date2.getDate();
        
        let yearsDiff = years2 - years1;
        
        // Adjust for months and days
        if (month2 < month1 || (month2 === month1 && day2 < day1)) {
          yearsDiff--;
        }
        
        return yearsDiff;
      }
      case 'months': {
        // Calculate exact months difference
        const years1 = date1.getFullYear();
        const years2 = date2.getFullYear();
        const month1 = date1.getMonth();
        const month2 = date2.getMonth();
        const day1 = date1.getDate();
        const day2 = date2.getDate();
        
        let monthsDiff = (years2 - years1) * 12 + (month2 - month1);
        
        // Adjust for days
        if (day2 < day1) {
          monthsDiff--;
        }
        
        return monthsDiff;
      }
      case 'days':
        return Math.floor(millisecondsDiff / (1000 * 60 * 60 * 24));
      case 'hours':
        return Math.floor(millisecondsDiff / (1000 * 60 * 60));
      case 'minutes':
        return Math.floor(millisecondsDiff / (1000 * 60));
      case 'seconds':
        return Math.floor(millisecondsDiff / 1000);
      case 'milliseconds':
        return millisecondsDiff;
      default:
        throw new Error(`Invalid unit: ${unit}`);
    }
  }
  
  /**
   * Gets the start of the specified unit for the given date.
   * 
   * @param date The date to get the start of
   * @param unit The unit (year, month, week, day, hour, minute, second)
   * @returns A new Date representing the start of the specified unit
   */
  public static startOf(date: Date, unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second'): Date {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    const result = new Date(date);
    
    switch (unit) {
      case 'year':
        result.setMonth(0, 1);
        result.setHours(0, 0, 0, 0);
        break;
      case 'month':
        result.setDate(1);
        result.setHours(0, 0, 0, 0);
        break;
      case 'week': {
        // Get the day of the week (0 = Sunday, 1 = Monday, etc.)
        const day = result.getDay();
        // Subtract the day of the week to get to Sunday
        result.setDate(result.getDate() - day);
        result.setHours(0, 0, 0, 0);
        break;
      }
      case 'day':
        result.setHours(0, 0, 0, 0);
        break;
      case 'hour':
        result.setMinutes(0, 0, 0);
        break;
      case 'minute':
        result.setSeconds(0, 0);
        break;
      case 'second':
        result.setMilliseconds(0);
        break;
      default:
        throw new Error(`Invalid unit: ${unit}`);
    }
    
    return result;
  }
  
  /**
   * Gets the end of the specified unit for the given date.
   * 
   * @param date The date to get the end of
   * @param unit The unit (year, month, week, day, hour, minute, second)
   * @returns A new Date representing the end of the specified unit
   */
  public static endOf(date: Date, unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second'): Date {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    const result = new Date(date);
    
    switch (unit) {
      case 'year':
        result.setMonth(11, 31);
        result.setHours(23, 59, 59, 999);
        break;
      case 'month': {
        // Set to the first day of the next month, then subtract 1 millisecond
        result.setMonth(result.getMonth() + 1, 0);
        result.setHours(23, 59, 59, 999);
        break;
      }
      case 'week': {
        // Get the day of the week (0 = Sunday, 1 = Monday, etc.)
        const day = result.getDay();
        // Add days to get to Saturday
        result.setDate(result.getDate() + (6 - day));
        result.setHours(23, 59, 59, 999);
        break;
      }
      case 'day':
        result.setHours(23, 59, 59, 999);
        break;
      case 'hour':
        result.setMinutes(59, 59, 999);
        break;
      case 'minute':
        result.setSeconds(59, 999);
        break;
      case 'second':
        result.setMilliseconds(999);
        break;
      default:
        throw new Error(`Invalid unit: ${unit}`);
    }
    
    return result;
  }
  
  /**
   * Checks if the date is between the start and end dates.
   * 
   * @param date The date to check
   * @param startDate The start date
   * @param endDate The end date
   * @param inclusivity The inclusivity of the comparison ('()' = exclusive, '[]' = inclusive, '[)' = start inclusive, end exclusive, '(]' = start exclusive, end inclusive)
   * @returns True if the date is between the start and end dates
   */
  public static isBetween(date: Date, startDate: Date, endDate: Date, inclusivity: '()' | '[]' | '[)' | '(]' = '[]'): boolean {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    if (!startDate || !(startDate instanceof Date) || isNaN(startDate.getTime())) {
      throw new Error('Invalid startDate');
    }
    
    if (!endDate || !(endDate instanceof Date) || isNaN(endDate.getTime())) {
      throw new Error('Invalid endDate');
    }
    
    const time = date.getTime();
    const startTime = startDate.getTime();
    const endTime = endDate.getTime();
    
    switch (inclusivity) {
      case '()':
        return time > startTime && time < endTime;
      case '[]':
        return time >= startTime && time <= endTime;
      case '[)':
        return time >= startTime && time < endTime;
      case '(]':
        return time > startTime && time <= endTime;
      default:
        throw new Error(`Invalid inclusivity: ${inclusivity}`);
    }
  }
  
  /**
   * Checks if two dates are the same in the specified unit.
   * 
   * @param date1 The first date
   * @param date2 The second date
   * @param unit The unit to compare (year, month, week, day, hour, minute, second, millisecond)
   * @returns True if the dates are the same in the specified unit
   */
  public static isSame(date1: Date, date2: Date, unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond'): boolean {
    if (!date1 || !(date1 instanceof Date) || isNaN(date1.getTime())) {
      throw new Error('Invalid date1');
    }
    
    if (!date2 || !(date2 instanceof Date) || isNaN(date2.getTime())) {
      throw new Error('Invalid date2');
    }
    
    switch (unit) {
      case 'year':
        return date1.getFullYear() === date2.getFullYear();
      case 'month':
        return date1.getFullYear() === date2.getFullYear() &&
               date1.getMonth() === date2.getMonth();
      case 'week': {
        // Get the start of the week for both dates and compare
        const startOfWeek1 = this.startOf(date1, 'week');
        const startOfWeek2 = this.startOf(date2, 'week');
        return startOfWeek1.getTime() === startOfWeek2.getTime();
      }
      case 'day':
        return date1.getFullYear() === date2.getFullYear() &&
               date1.getMonth() === date2.getMonth() &&
               date1.getDate() === date2.getDate();
      case 'hour':
        return date1.getFullYear() === date2.getFullYear() &&
               date1.getMonth() === date2.getMonth() &&
               date1.getDate() === date2.getDate() &&
               date1.getHours() === date2.getHours();
      case 'minute':
        return date1.getFullYear() === date2.getFullYear() &&
               date1.getMonth() === date2.getMonth() &&
               date1.getDate() === date2.getDate() &&
               date1.getHours() === date2.getHours() &&
               date1.getMinutes() === date2.getMinutes();
      case 'second':
        return date1.getFullYear() === date2.getFullYear() &&
               date1.getMonth() === date2.getMonth() &&
               date1.getDate() === date2.getDate() &&
               date1.getHours() === date2.getHours() &&
               date1.getMinutes() === date2.getMinutes() &&
               date1.getSeconds() === date2.getSeconds();
      case 'millisecond':
        return date1.getTime() === date2.getTime();
      default:
        throw new Error(`Invalid unit: ${unit}`);
    }
  }
  
  /**
   * Checks if date1 is before date2.
   * 
   * @param date1 The first date
   * @param date2 The second date
   * @param unit Optional unit to compare (year, month, week, day, hour, minute, second, millisecond)
   * @returns True if date1 is before date2
   */
  public static isBefore(date1: Date, date2: Date, unit?: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond'): boolean {
    if (!date1 || !(date1 instanceof Date) || isNaN(date1.getTime())) {
      throw new Error('Invalid date1');
    }
    
    if (!date2 || !(date2 instanceof Date) || isNaN(date2.getTime())) {
      throw new Error('Invalid date2');
    }
    
    if (!unit) {
      return date1.getTime() < date2.getTime();
    }
    
    // If comparing by unit, check if not same in unit and date1 is before date2
    return !this.isSame(date1, date2, unit) && date1.getTime() < date2.getTime();
  }
  
  /**
   * Checks if date1 is after date2.
   * 
   * @param date1 The first date
   * @param date2 The second date
   * @param unit Optional unit to compare (year, month, week, day, hour, minute, second, millisecond)
   * @returns True if date1 is after date2
   */
  public static isAfter(date1: Date, date2: Date, unit?: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond'): boolean {
    if (!date1 || !(date1 instanceof Date) || isNaN(date1.getTime())) {
      throw new Error('Invalid date1');
    }
    
    if (!date2 || !(date2 instanceof Date) || isNaN(date2.getTime())) {
      throw new Error('Invalid date2');
    }
    
    if (!unit) {
      return date1.getTime() > date2.getTime();
    }
    
    // If comparing by unit, check if not same in unit and date1 is after date2
    return !this.isSame(date1, date2, unit) && date1.getTime() > date2.getTime();
  }
  
  /**
   * Checks if the date is a valid date.
   * 
   * @param date The date to check
   * @returns True if the date is valid
   */
  public static isValid(date: Date | string | number): boolean {
    if (date instanceof Date) {
      return !isNaN(date.getTime());
    }
    
    // If string or number, try to create a Date
    return !isNaN(new Date(date).getTime());
  }
  
  /**
   * Checks if the year is a leap year.
   * 
   * @param year The year to check or a date
   * @returns True if the year is a leap year
   */
  public static isLeapYear(year: number | Date): boolean {
    // If Date, extract the year
    if (year instanceof Date) {
      if (!this.isValid(year)) {
        throw new Error('Invalid date');
      }
      year = year.getFullYear();
    }
    
    // Check if it's a leap year
    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
  }
  
  /**
   * Gets the number of days in the month.
   * 
   * @param date The date
   * @returns The number of days in the month
   */
  public static daysInMonth(date: Date): number {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    // Get the last day of the month by setting the date to the 0th day of the next month
    const year = date.getFullYear();
    const month = date.getMonth();
    
    return new Date(year, month + 1, 0).getDate();
  }
  
  /**
   * Gets a new date with the specified components.
   * 
   * @param year The year
   * @param month The month (0-11)
   * @param day The day (1-31)
   * @param hour The hour (0-23)
   * @param minute The minute (0-59)
   * @param second The second (0-59)
   * @param millisecond The millisecond (0-999)
   * @returns A new Date
   */
  public static create(
    year: number,
    month: number,
    day: number = 1,
    hour: number = 0,
    minute: number = 0,
    second: number = 0,
    millisecond: number = 0
  ): Date {
    const date = new Date(year, month, day, hour, minute, second, millisecond);
    
    if (isNaN(date.getTime())) {
      throw new Error('Invalid date components');
    }
    
    return date;
  }
  
  /**
   * Gets the week number of the year.
   * 
   * @param date The date
   * @param firstDayOfWeek The first day of the week (0 = Sunday, 1 = Monday, etc.), defaults to 0 (Sunday)
   * @returns The week number (1-53)
   */
  public static getWeekNumber(date: Date, firstDayOfWeek: number = 0): number {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    if (firstDayOfWeek < 0 || firstDayOfWeek > 6) {
      throw new Error('First day of week must be between 0 (Sunday) and 6 (Saturday)');
    }
    
    // Clone the date to avoid modifying the original
    const targetDate = new Date(date);
    
    // Get the first day of the year
    const firstDayOfYear = new Date(targetDate.getFullYear(), 0, 1);
    
    // Adjust first day of year to the specified first day of week
    const dayOfWeek = firstDayOfYear.getDay();
    const daysToAdd = (dayOfWeek < firstDayOfWeek) 
      ? (7 - firstDayOfWeek + dayOfWeek) 
      : (dayOfWeek - firstDayOfWeek);
    
    firstDayOfYear.setDate(firstDayOfYear.getDate() + daysToAdd);
    
    // If the date is before the first week, it's the last week of the previous year
    if (targetDate < firstDayOfYear) {
      // Get the last day of the previous year and calculate its week number
      const lastDayOfPrevYear = new Date(targetDate.getFullYear() - 1, 11, 31);
      return this.getWeekNumber(lastDayOfPrevYear, firstDayOfWeek);
    }
    
    // Calculate the week number
    const diffInTime = targetDate.getTime() - firstDayOfYear.getTime();
    const diffInDays = Math.floor(diffInTime / (1000 * 60 * 60 * 24));
    const weekNumber = Math.floor(diffInDays / 7) + 1;
    
    return weekNumber;
  }
  
  /**
   * Gets the quarter of the year.
   * 
   * @param date The date
   * @returns The quarter (1-4)
   */
  public static getQuarter(date: Date): number {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    const month = date.getMonth();
    return Math.floor(month / 3) + 1;
  }
  
  /**
   * Sets a specific component of the date.
   * 
   * @param date The date to modify
   * @param unit The unit to set
   * @param value The value to set
   * @returns A new Date with the specified component set
   */
  public static set(
    date: Date,
    unit: 'year' | 'month' | 'date' | 'hours' | 'minutes' | 'seconds' | 'milliseconds',
    value: number
  ): Date {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    const result = new Date(date);
    
    switch (unit) {
      case 'year':
        result.setFullYear(value);
        break;
      case 'month':
        result.setMonth(value);
        break;
      case 'date':
        result.setDate(value);
        break;
      case 'hours':
        result.setHours(value);
        break;
      case 'minutes':
        result.setMinutes(value);
        break;
      case 'seconds':
        result.setSeconds(value);
        break;
      case 'milliseconds':
        result.setMilliseconds(value);
        break;
      default:
        throw new Error(`Invalid unit: ${unit}`);
    }
    
    return result;
  }
  
  /**
   * Returns a string representing the specified date according to the browser's locale.
   * 
   * @param date The date to format
   * @param options The Intl.DateTimeFormat options
   * @param locale The locale to use, defaults to the browser's locale
   * @returns A localized string representing the date
   */
  public static toLocaleString(
    date: Date,
    options?: Intl.DateTimeFormatOptions,
    locale?: string | string[]
  ): string {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    return date.toLocaleString(locale, options);
  }
  
  /**
   * Returns the time zone offset in hours (e.g., -7 for PDT).
   * 
   * @param date The date
   * @returns The time zone offset in hours
   */
  public static getTimezoneOffset(date: Date): number {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    // getTimezoneOffset returns minutes, convert to hours
    return -date.getTimezoneOffset() / 60;
  }
  
  /**
   * Parses an ISO date string.
   * 
   * @param isoString The ISO date string
   * @returns A Date object
   */
  public static parseISOString(isoString: string): Date {
    if (!isoString) {
      throw new Error('ISO string is required');
    }
    
    const date = new Date(isoString);
    
    if (isNaN(date.getTime())) {
      throw new Error(`Invalid ISO date string: ${isoString}`);
    }
    
    return date;
  }
  
  /**
   * Converts a date to an ISO string.
   * 
   * @param date The date
   * @returns An ISO string
   */
  public static toISOString(date: Date): string {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    return date.toISOString();
  }
  
  /**
   * Gets the Unix timestamp (seconds since January 1, 1970).
   * 
   * @param date The date
   * @returns The Unix timestamp
   */
  public static toUnixTimestamp(date: Date): number {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    return Math.floor(date.getTime() / 1000);
  }
  
  /**
   * Creates a Date from a Unix timestamp.
   * 
   * @param timestamp The Unix timestamp (seconds since January 1, 1970)
   * @returns A Date object
   */
  public static fromUnixTimestamp(timestamp: number): Date {
    if (isNaN(timestamp)) {
      throw new Error('Invalid timestamp');
    }
    
    // Convert seconds to milliseconds
    return new Date(timestamp * 1000);
  }
  
  /**
   * Gets the day of the year (1-366).
   * 
   * @param date The date
   * @returns The day of the year
   */
  public static getDayOfYear(date: Date): number {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    const startOfYear = new Date(date.getFullYear(), 0, 0);
    const diff = date.getTime() - startOfYear.getTime();
    return Math.floor(diff / (1000 * 60 * 60 * 24));
  }
  
  /**
   * Gets the week day in month (e.g., 1st Monday, 2nd Tuesday).
   * 
   * @param date The date
   * @returns The week day in month (1-5)
   */
  public static getWeekDayInMonth(date: Date): number {
    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Invalid date');
    }
    
    const day = date.getDate();
    return Math.ceil(day / 7);
  }
}

export default CSDateUtils;


/**
 * CSConstants.ts
 * 
 * Framework-wide constants used across the CSTestForge framework.
 * This class contains all the constant values used throughout the framework.
 */

export class CSConstants {
  // Framework metadata
  public static readonly FRAMEWORK_NAME = 'CSTestForge';
  public static readonly FRAMEWORK_VERSION = '1.0.0';
  public static readonly FRAMEWORK_AUTHOR = 'CSTestForge Team';
  public static readonly FRAMEWORK_COPYRIGHT = 'Copyright © 2025 CSTestForge';
  public static readonly FRAMEWORK_LICENSE = 'Proprietary';
  
  // Framework brand colors
  public static readonly BRAND_COLOR_PRIMARY = '#C54B8C';
  public static readonly BRAND_COLOR_SECONDARY = '#8A71D6';
  public static readonly BRAND_COLOR_TERTIARY = '#71D6C0';
  public static readonly BRAND_COLOR_QUATERNARY = '#D6C071';
  public static readonly BRAND_COLOR_QUINARY = '#D67171';
  
  // Framework paths
  public static readonly PATH_TEMP = './temp';
  public static readonly PATH_REPORTS = './reports';
  public static readonly PATH_SCREENSHOTS = './screenshots';
  public static readonly PATH_VIDEOS = './videos';
  public static readonly PATH_LOGS = './logs';
  public static readonly PATH_DATA = './data';
  public static readonly PATH_CONFIG = './config';
  public static readonly PATH_EXPORTS = './exports';
  
  // Framework file names
  public static readonly FILE_CONFIG = 'cstestforge.json';
  public static readonly FILE_LOG = 'cstestforge.log';
  public static readonly FILE_ERROR_LOG = 'cstestforge-error.log';
  public static readonly FILE_REPORT = 'cstestforge-report.html';
  public static readonly FILE_RESULTS = 'cstestforge-results.json';
  
  // Framework timeouts (in milliseconds)
  public static readonly TIMEOUT_DEFAULT = 30000; // 30 seconds
  public static readonly TIMEOUT_SMALL = 5000; // 5 seconds
  public static readonly TIMEOUT_MEDIUM = 60000; // 1 minute
  public static readonly TIMEOUT_LARGE = 300000; // 5 minutes
  public static readonly TIMEOUT_ELEMENT = 10000; // 10 seconds
  public static readonly TIMEOUT_PAGE_LOAD = 60000; // 1 minute
  public static readonly TIMEOUT_SCRIPT = 30000; // 30 seconds
  public static readonly TIMEOUT_AJAX = 30000; // 30 seconds
  public static readonly TIMEOUT_IMPLICIT = 0; // 0 seconds (disabled by default)
  public static readonly TIMEOUT_EXPLICIT = 10000; // 10 seconds
  public static readonly TIMEOUT_RETRY = 5000; // 5 seconds
  public static readonly TIMEOUT_ANIMATION = 1000; // 1 second
  public static readonly TIMEOUT_TRANSITION = 500; // 0.5 seconds
  
  // Framework retries
  public static readonly RETRY_DEFAULT = 3;
  public static readonly RETRY_SMALL = 1;
  public static readonly RETRY_MEDIUM = 5;
  public static readonly RETRY_LARGE = 10;
  
  // Framework polling intervals (in milliseconds)
  public static readonly POLLING_DEFAULT = 500; // 0.5 seconds
  public static readonly POLLING_SMALL = 100; // 0.1 seconds
  public static readonly POLLING_MEDIUM = 1000; // 1 second
  public static readonly POLLING_LARGE = 5000; // 5 seconds
  
  // Framework wait conditions
  public static readonly WAIT_CONDITION_VISIBLE = 'visible';
  public static readonly WAIT_CONDITION_INVISIBLE = 'invisible';
  public static readonly WAIT_CONDITION_PRESENT = 'present';
  public static readonly WAIT_CONDITION_NOT_PRESENT = 'notPresent';
  public static readonly WAIT_CONDITION_CLICKABLE = 'clickable';
  public static readonly WAIT_CONDITION_NOT_CLICKABLE = 'notClickable';
  public static readonly WAIT_CONDITION_SELECTED = 'selected';
  public static readonly WAIT_CONDITION_NOT_SELECTED = 'notSelected';
  public static readonly WAIT_CONDITION_TEXT = 'text';
  public static readonly WAIT_CONDITION_NOT_TEXT = 'notText';
  public static readonly WAIT_CONDITION_VALUE = 'value';
  public static readonly WAIT_CONDITION_NOT_VALUE = 'notValue';
  public static readonly WAIT_CONDITION_ATTRIBUTE = 'attribute';
  public static readonly WAIT_CONDITION_NOT_ATTRIBUTE = 'notAttribute';
  public static readonly WAIT_CONDITION_PROPERTY = 'property';
  public static readonly WAIT_CONDITION_NOT_PROPERTY = 'notProperty';
  public static readonly WAIT_CONDITION_STALENESS = 'staleness';
  
  // Framework assertion types
  public static readonly ASSERTION_TYPE_EQUALS = 'equals';
  public static readonly ASSERTION_TYPE_NOT_EQUALS = 'notEquals';
  public static readonly ASSERTION_TYPE_CONTAINS = 'contains';
  public static readonly ASSERTION_TYPE_NOT_CONTAINS = 'notContains';
  public static readonly ASSERTION_TYPE_STARTS_WITH = 'startsWith';
  public static readonly ASSERTION_TYPE_ENDS_WITH = 'endsWith';
  public static readonly ASSERTION_TYPE_MATCHES = 'matches';
  public static readonly ASSERTION_TYPE_NOT_MATCHES = 'notMatches';
  public static readonly ASSERTION_TYPE_GREATER_THAN = 'greaterThan';
  public static readonly ASSERTION_TYPE_LESS_THAN = 'lessThan';
  public static readonly ASSERTION_TYPE_GREATER_THAN_OR_EQUALS = 'greaterThanOrEquals';
  public static readonly ASSERTION_TYPE_LESS_THAN_OR_EQUALS = 'lessThanOrEquals';
  public static readonly ASSERTION_TYPE_TRUE = 'true';
  public static readonly ASSERTION_TYPE_FALSE = 'false';
  public static readonly ASSERTION_TYPE_NULL = 'null';
  public static readonly ASSERTION_TYPE_NOT_NULL = 'notNull';
  public static readonly ASSERTION_TYPE_UNDEFINED = 'undefined';
  public static readonly ASSERTION_TYPE_NOT_UNDEFINED = 'notUndefined';
  public static readonly ASSERTION_TYPE_EMPTY = 'empty';
  public static readonly ASSERTION_TYPE_NOT_EMPTY = 'notEmpty';
  
  // Framework log levels
  public static readonly LOG_LEVEL_TRACE = 'trace';
  public static readonly LOG_LEVEL_DEBUG = 'debug';
  public static readonly LOG_LEVEL_INFO = 'info';
  public static readonly LOG_LEVEL_WARN = 'warn';
  public static readonly LOG_LEVEL_ERROR = 'error';
  public static readonly LOG_LEVEL_FATAL = 'fatal';
  
  // Framework test statuses
  public static readonly TEST_STATUS_PASSED = 'passed';
  public static readonly TEST_STATUS_FAILED = 'failed';
  public static readonly TEST_STATUS_SKIPPED = 'skipped';
  public static readonly TEST_STATUS_PENDING = 'pending';
  public static readonly TEST_STATUS_RUNNING = 'running';
  public static readonly TEST_STATUS_BLOCKED = 'blocked';
  public static readonly TEST_STATUS_RERUN = 'rerun';
  public static readonly TEST_STATUS_RETRY = 'retry';
  public static readonly TEST_STATUS_ERROR = 'error';
  
  // Framework report types
  public static readonly REPORT_TYPE_HTML = 'html';
  public static readonly REPORT_TYPE_JSON = 'json';
  public static readonly REPORT_TYPE_XML = 'xml';
  public static readonly REPORT_TYPE_TEXT = 'text';
  public static readonly REPORT_TYPE_CSV = 'csv';
  public static readonly REPORT_TYPE_EXCEL = 'excel';
  public static readonly REPORT_TYPE_PDF = 'pdf';
  
  // Framework test types
  public static readonly TEST_TYPE_UI = 'ui';
  public static readonly TEST_TYPE_API = 'api';
  public static readonly TEST_TYPE_UNIT = 'unit';
  public static readonly TEST_TYPE_INTEGRATION = 'integration';
  public static readonly TEST_TYPE_E2E = 'e2e';
  public static readonly TEST_TYPE_PERFORMANCE = 'performance';
  public static readonly TEST_TYPE_SECURITY = 'security';
  public static readonly TEST_TYPE_ACCESSIBILITY = 'accessibility';
  public static readonly TEST_TYPE_VISUAL = 'visual';
  public static readonly TEST_TYPE_MOBILE = 'mobile';
  
  // Framework environment types
  public static readonly ENV_TYPE_DEV = 'dev';
  public static readonly ENV_TYPE_QA = 'qa';
  public static readonly ENV_TYPE_STAGING = 'staging';
  public static readonly ENV_TYPE_PROD = 'prod';
  public static readonly ENV_TYPE_TEST = 'test';
  
  // Framework element types
  public static readonly ELEMENT_TYPE_BUTTON = 'button';
  public static readonly ELEMENT_TYPE_CHECKBOX = 'checkbox';
  public static readonly ELEMENT_TYPE_COLOR = 'color';
  public static readonly ELEMENT_TYPE_DATE = 'date';
  public static readonly ELEMENT_TYPE_DATETIME_LOCAL = 'datetime-local';
  public static readonly ELEMENT_TYPE_EMAIL = 'email';
  public static readonly ELEMENT_TYPE_FILE = 'file';
  public static readonly ELEMENT_TYPE_HIDDEN = 'hidden';
  public static readonly ELEMENT_TYPE_IMAGE = 'image';
  public static readonly ELEMENT_TYPE_MONTH = 'month';
  public static readonly ELEMENT_TYPE_NUMBER = 'number';
  public static readonly ELEMENT_TYPE_PASSWORD = 'password';
  public static readonly ELEMENT_TYPE_RADIO = 'radio';
  public static readonly ELEMENT_TYPE_RANGE = 'range';
  public static readonly ELEMENT_TYPE_RESET = 'reset';
  public static readonly ELEMENT_TYPE_SEARCH = 'search';
  public static readonly ELEMENT_TYPE_SUBMIT = 'submit';
  public static readonly ELEMENT_TYPE_TEL = 'tel';
  public static readonly ELEMENT_TYPE_TEXT = 'text';
  public static readonly ELEMENT_TYPE_TIME = 'time';
  public static readonly ELEMENT_TYPE_URL = 'url';
  public static readonly ELEMENT_TYPE_WEEK = 'week';
  public static readonly ELEMENT_TYPE_INPUT = 'input';
  public static readonly ELEMENT_TYPE_TEXTAREA = 'textarea';
  public static readonly ELEMENT_TYPE_SELECT = 'select';
  public static readonly ELEMENT_TYPE_OPTION = 'option';
  public static readonly ELEMENT_TYPE_OPTGROUP = 'optgroup';
  public static readonly ELEMENT_TYPE_LINK = 'a';
  public static readonly ELEMENT_TYPE_IMAGE_LINK = 'img';
  public static readonly ELEMENT_TYPE_LABEL = 'label';
  public static readonly ELEMENT_TYPE_DIV = 'div';
  public static readonly ELEMENT_TYPE_SPAN = 'span';
  public static readonly ELEMENT_TYPE_TABLE = 'table';
  public static readonly ELEMENT_TYPE_TR = 'tr';
  public static readonly ELEMENT_TYPE_TD = 'td';
  public static readonly ELEMENT_TYPE_TH = 'th';
  public static readonly ELEMENT_TYPE_FORM = 'form';
  public static readonly ELEMENT_TYPE_IFRAME = 'iframe';
  public static readonly ELEMENT_TYPE_H1 = 'h1';
  public static readonly ELEMENT_TYPE_H2 = 'h2';
  public static readonly ELEMENT_TYPE_H3 = 'h3';
  public static readonly ELEMENT_TYPE_H4 = 'h4';
  public static readonly ELEMENT_TYPE_H5 = 'h5';
  public static readonly ELEMENT_TYPE_H6 = 'h6';
  public static readonly ELEMENT_TYPE_P = 'p';
  public static readonly ELEMENT_TYPE_UL = 'ul';
  public static readonly ELEMENT_TYPE_OL = 'ol';
  public static readonly ELEMENT_TYPE_LI = 'li';
  
  // Framework browser types
  public static readonly BROWSER_TYPE_CHROME = 'chrome';
  public static readonly BROWSER_TYPE_FIREFOX = 'firefox';
  public static readonly BROWSER_TYPE_EDGE = 'edge';
  public static readonly BROWSER_TYPE_SAFARI = 'safari';
  public static readonly BROWSER_TYPE_IE = 'ie';
  public static readonly BROWSER_TYPE_OPERA = 'opera';
  
  // Framework mobile platform types
  public static readonly PLATFORM_TYPE_ANDROID = 'android';
  public static readonly PLATFORM_TYPE_IOS = 'ios';
  
  // Framework action types
  public static readonly ACTION_TYPE_CLICK = 'click';
  public static readonly ACTION_TYPE_DOUBLE_CLICK = 'doubleClick';
  public static readonly ACTION_TYPE_RIGHT_CLICK = 'rightClick';
  public static readonly ACTION_TYPE_HOVER = 'hover';
  public static readonly ACTION_TYPE_TYPE = 'type';
  public static readonly ACTION_TYPE_CLEAR = 'clear';
  public static readonly ACTION_TYPE_SELECT = 'select';
  public static readonly ACTION_TYPE_FOCUS = 'focus';
  public static readonly ACTION_TYPE_BLUR = 'blur';
  public static readonly ACTION_TYPE_SUBMIT = 'submit';
  public static readonly ACTION_TYPE_SCROLL_TO = 'scrollTo';
  public static readonly ACTION_TYPE_SCROLL_INTO_VIEW = 'scrollIntoView';
  public static readonly ACTION_TYPE_DRAG_AND_DROP = 'dragAndDrop';
  public static readonly ACTION_TYPE_UPLOAD = 'upload';
  public static readonly ACTION_TYPE_PRESS_KEY = 'pressKey';
  public static readonly ACTION_TYPE_PRESS_KEYS = 'pressKeys';
  public static readonly ACTION_TYPE_WAIT = 'wait';
  public static readonly ACTION_TYPE_NAVIGATE = 'navigate';
  public static readonly ACTION_TYPE_RELOAD = 'reload';
  public static readonly ACTION_TYPE_BACK = 'back';
  public static readonly ACTION_TYPE_FORWARD = 'forward';
  public static readonly ACTION_TYPE_EXECUTE_SCRIPT = 'executeScript';
  public static readonly ACTION_TYPE_TAKE_SCREENSHOT = 'takeScreenshot';
  
  // Framework data source types
  public static readonly DATA_SOURCE_TYPE_CSV = 'csv';
  public static readonly DATA_SOURCE_TYPE_EXCEL = 'excel';
  public static readonly DATA_SOURCE_TYPE_JSON = 'json';
  public static readonly DATA_SOURCE_TYPE_XML = 'xml';
  public static readonly DATA_SOURCE_TYPE_YAML = 'yaml';
  public static readonly DATA_SOURCE_TYPE_DATABASE = 'database';
  public static readonly DATA_SOURCE_TYPE_API = 'api';
  
  // Framework database types
  public static readonly DATABASE_TYPE_MYSQL = 'mysql';
  public static readonly DATABASE_TYPE_POSTGRES = 'postgres';
  public static readonly DATABASE_TYPE_ORACLE = 'oracle';
  public static readonly DATABASE_TYPE_MSSQL = 'mssql';
  public static readonly DATABASE_TYPE_SQLITE = 'sqlite';
  public static readonly DATABASE_TYPE_MONGODB = 'mongodb';
  
  // Framework HTTP methods
  public static readonly HTTP_METHOD_GET = 'GET';
  public static readonly HTTP_METHOD_POST = 'POST';
  public static readonly HTTP_METHOD_PUT = 'PUT';
  public static readonly HTTP_METHOD_DELETE = 'DELETE';
  public static readonly HTTP_METHOD_PATCH = 'PATCH';
  public static readonly HTTP_METHOD_HEAD = 'HEAD';
  public static readonly HTTP_METHOD_OPTIONS = 'OPTIONS';
  
  // Framework HTTP status codes
  public static readonly HTTP_STATUS_OK = 200;
  public static readonly HTTP_STATUS_CREATED = 201;
  public static readonly HTTP_STATUS_ACCEPTED = 202;
  public static readonly HTTP_STATUS_NO_CONTENT = 204;
  public static readonly HTTP_STATUS_MOVED_PERMANENTLY = 301;
  public static readonly HTTP_STATUS_FOUND = 302;
  public static readonly HTTP_STATUS_SEE_OTHER = 303;
  public static readonly HTTP_STATUS_NOT_MODIFIED = 304;
  public static readonly HTTP_STATUS_TEMPORARY_REDIRECT = 307;
  public static readonly HTTP_STATUS_PERMANENT_REDIRECT = 308;
  public static readonly HTTP_STATUS_BAD_REQUEST = 400;
  public static readonly HTTP_STATUS_UNAUTHORIZED = 401;
  public static readonly HTTP_STATUS_FORBIDDEN = 403;
  public static readonly HTTP_STATUS_NOT_FOUND = 404;
  public static readonly HTTP_STATUS_METHOD_NOT_ALLOWED = 405;
  public static readonly HTTP_STATUS_NOT_ACCEPTABLE = 406;
  public static readonly HTTP_STATUS_CONFLICT = 409;
  public static readonly HTTP_STATUS_GONE = 410;
  public static readonly HTTP_STATUS_UNPROCESSABLE_ENTITY = 422;
  public static readonly HTTP_STATUS_TOO_MANY_REQUESTS = 429;
  public static readonly HTTP_STATUS_INTERNAL_SERVER_ERROR = 500;
  public static readonly HTTP_STATUS_NOT_IMPLEMENTED = 501;
  public static readonly HTTP_STATUS_BAD_GATEWAY = 502;
  public static readonly HTTP_STATUS_SERVICE_UNAVAILABLE = 503;
  public static readonly HTTP_STATUS_GATEWAY_TIMEOUT = 504;
  
  // Framework content types
  public static readonly CONTENT_TYPE_JSON = 'application/json';
  public static readonly CONTENT_TYPE_XML = 'application/xml';
  public static readonly CONTENT_TYPE_FORM = 'application/x-www-form-urlencoded';
  public static readonly CONTENT_TYPE_MULTIPART = 'multipart/form-data';
  public static readonly CONTENT_TYPE_TEXT = 'text/plain';
  public static readonly CONTENT_TYPE_HTML = 'text/html';
  public static readonly CONTENT_TYPE_CSS = 'text/css';
  public static readonly CONTENT_TYPE_JAVASCRIPT = 'application/javascript';
  
  // Framework message severities
  public static readonly MESSAGE_SEVERITY_INFO = 'info';
  public static readonly MESSAGE_SEVERITY_WARNING = 'warning';
  public static readonly MESSAGE_SEVERITY_ERROR = 'error';
  public static readonly MESSAGE_SEVERITY_SUCCESS = 'success';
  
  // Framework date formats
  public static readonly DATE_FORMAT_ISO = 'YYYY-MM-DDTHH:mm:ss.SSSZ';
  public static readonly DATE_FORMAT_DATE = 'YYYY-MM-DD';
  public static readonly DATE_FORMAT_TIME = 'HH:mm:ss';
  public static readonly DATE_FORMAT_DATETIME = 'YYYY-MM-DD HH:mm:ss';
  public static readonly DATE_FORMAT_US_DATE = 'MM/DD/YYYY';
  public static readonly DATE_FORMAT_EU_DATE = 'DD/MM/YYYY';
  public static readonly DATE_FORMAT_US_DATETIME = 'MM/DD/YYYY HH:mm:ss';
  public static readonly DATE_FORMAT_EU_DATETIME = 'DD/MM/YYYY HH:mm:ss';
  public static readonly DATE_FORMAT_YEAR_MONTH = 'YYYY-MM';
  public static readonly DATE_FORMAT_MONTH_DAY = 'MM-DD';
  public static readonly DATE_FORMAT_HOUR_MINUTE = 'HH:mm';
  public static readonly DATE_FORMAT_MINUTE_SECOND = 'mm:ss';
  
  // Framework time units (for timeouts, waits, etc.)
  public static readonly TIME_UNIT_MILLISECOND = 'ms';
  public static readonly TIME_UNIT_SECOND = 's';
  public static readonly TIME_UNIT_MINUTE = 'm';
  public static readonly TIME_UNIT_HOUR = 'h';
  public static readonly TIME_UNIT_DAY = 'd';
  
  // Framework key codes
  public static readonly KEY_CODE_ENTER = 'Enter';
  public static readonly KEY_CODE_TAB = 'Tab';
  public static readonly KEY_CODE_ESCAPE = 'Escape';
  public static readonly KEY_CODE_SPACE = ' ';
  public static readonly KEY_CODE_BACKSPACE = 'Backspace';
  public static readonly KEY_CODE_DELETE = 'Delete';
  public static readonly KEY_CODE_ARROW_UP = 'ArrowUp';
  public static readonly KEY_CODE_ARROW_DOWN = 'ArrowDown';
  public static readonly KEY_CODE_ARROW_LEFT = 'ArrowLeft';
  public static readonly KEY_CODE_ARROW_RIGHT = 'ArrowRight';
  public static readonly KEY_CODE_PAGE_UP = 'PageUp';
  public static readonly KEY_CODE_PAGE_DOWN = 'PageDown';
  public static readonly KEY_CODE_HOME = 'Home';
  public static readonly KEY_CODE_END = 'End';
  public static readonly KEY_CODE_SHIFT = 'Shift';
  public static readonly KEY_CODE_CONTROL = 'Control';
  public static readonly KEY_CODE_ALT = 'Alt';
  public static readonly KEY_CODE_META = 'Meta';
  
  // Framework file extensions
  public static readonly FILE_EXT_CSV = '.csv';
  public static readonly FILE_EXT_EXCEL = '.xlsx';
  public static readonly FILE_EXT_JSON = '.json';
  public static readonly FILE_EXT_XML = '.xml';
  public static readonly FILE_EXT_YAML = '.yaml';
  public static readonly FILE_EXT_YML = '.yml';
  public static readonly FILE_EXT_TXT = '.txt';
  public static readonly FILE_EXT_HTML = '.html';
  public static readonly FILE_EXT_HTM = '.htm';
  public static readonly FILE_EXT_PDF = '.pdf';
  public static readonly FILE_EXT_PNG = '.png';
  public static readonly FILE_EXT_JPG = '.jpg';
  public static readonly FILE_EXT_JPEG = '.jpeg';
  public static readonly FILE_EXT_GIF = '.gif';
  public static readonly FILE_EXT_SVG = '.svg';
  public static readonly FILE_EXT_MP4 = '.mp4';
  public static readonly FILE_EXT_WEBM = '.webm';
  public static readonly FILE_EXT_OGG = '.ogg';
  public static readonly FILE_EXT_ZIP = '.zip';
  public static readonly FILE_EXT_LOG = '.log';
  
  // Framework special characters
  public static readonly CHAR_NEWLINE = '\n';
  public static readonly CHAR_TAB = '\t';
  public static readonly CHAR_SPACE = ' ';
  public static readonly CHAR_COMMA = ',';
  public static readonly CHAR_SEMICOLON = ';';
  public static readonly CHAR_COLON = ':';
  public static readonly CHAR_DOT = '.';
  public static readonly CHAR_DASH = '-';
  public static readonly CHAR_UNDERSCORE = '_';
  public static readonly CHAR_SLASH = '/';
  public static readonly CHAR_BACKSLASH = '\\';
  public static readonly CHAR_PIPE = '|';
  public static readonly CHAR_QUOTE = '"';
  public static readonly CHAR_SINGLE_QUOTE = "'";
  public static readonly CHAR_BACKTICK = '`';
  public static readonly CHAR_OPEN_BRACKET = '[';
  public static readonly CHAR_CLOSE_BRACKET = ']';
  public static readonly CHAR_OPEN_BRACE = '{';
  public static readonly CHAR_CLOSE_BRACE = '}';
  public static readonly CHAR_OPEN_PAREN = '(';
  public static readonly CHAR_CLOSE_PAREN = ')';
  public static readonly CHAR_LESS_THAN = '<';
  public static readonly CHAR_GREATER_THAN = '>';
  public static readonly CHAR_EQUALS = '=';
  public static readonly CHAR_PLUS = '+';
  public static readonly CHAR_MINUS = '-';
  public static readonly CHAR_ASTERISK = '*';
  public static readonly CHAR_AMPERSAND = '&';
  public static readonly CHAR_CARET = '^';
  public static readonly CHAR_PERCENT = '%';
  public static readonly CHAR_DOLLAR = '$';
  public static readonly CHAR_HASH = '#';
  public static readonly CHAR_AT = '@';
  public static readonly CHAR_EXCLAMATION = '!';
  public static readonly CHAR_QUESTION = '?';
}

export default CSConstants;


/**
 * CSLogger.ts
 * 
 * Advanced logging utility for the CSTestForge framework.
 * Provides multi-level logging with various output targets.
 */

import CSConstants from './CSConstants';

/**
 * Log levels for the logger
 */
export enum LogLevel {
  TRACE = 0,
  DEBUG = 1,
  INFO = 2,
  WARN = 3,
  ERROR = 4,
  FATAL = 5,
  OFF = 6
}

/**
 * Output target for log messages
 */
export enum LogTarget {
  CONSOLE = 'console',
  FILE = 'file',
  MEMORY = 'memory',
  REMOTE = 'remote'
}

/**
 * Log message structure
 */
export interface LogMessage {
  /** Timestamp of the log message */
  timestamp: Date;
  /** Log level */
  level: LogLevel;
  /** Source of the log (e.g., class name, component) */
  source: string;
  /** Log message */
  message: string;
  /** Additional data */
  data?: any;
  /** Error object if applicable */
  error?: Error;
}

/**
 * File logging configuration
 */
export interface FileLogConfig {
  /** File path for log file */
  filePath: string;
  /** Maximum file size in bytes before rotation */
  maxSize?: number;
  /** Maximum number of backup files to keep */
  maxFiles?: number;
  /** Whether to append to existing log file */
  append?: boolean;
}

/**
 * Remote logging configuration
 */
export interface RemoteLogConfig {
  /** URL to send logs to */
  url: string;
  /** Authentication token/key */
  authToken?: string;
  /** Batch size for sending logs */
  batchSize?: number;
  /** Send interval in milliseconds */
  sendInterval?: number;
  /** Additional headers */
  headers?: Record<string, string>;
}

/**
 * Logger configuration
 */
export interface LoggerConfig {
  /** Minimum log level to record */
  level?: LogLevel;
  /** Output targets */
  targets?: LogTarget[];
  /** Source name for logs */
  source?: string;
  /** File logging configuration */
  fileConfig?: FileLogConfig;
  /** Remote logging configuration */
  remoteConfig?: RemoteLogConfig;
  /** Whether to include timestamp in logs */
  includeTimestamp?: boolean;
  /** Format for log messages */
  format?: string;
  /** Date format for timestamps */
  dateFormat?: string;
  /** Maximum number of logs to keep in memory */
  maxMemoryLogs?: number;
}

/**
 * Advanced logger for CSTestForge framework
 */
export class CSLogger {
  private static instance: CSLogger;
  private config: LoggerConfig;
  private memoryLogs: LogMessage[] = [];
  private remoteBatch: LogMessage[] = [];
  private sendTimer: NodeJS.Timeout | null = null;
  
  /**
   * Private constructor for singleton pattern
   * 
   * @param config Logger configuration
   */
  private constructor(config: LoggerConfig = {}) {
    this.config = {
      level: LogLevel.INFO,
      targets: [LogTarget.CONSOLE],
      source: 'CSTestForge',
      includeTimestamp: true,
      format: '[{timestamp}] [{level}] [{source}]: {message}',
      dateFormat: 'YYYY-MM-DD HH:mm:ss.SSS',
      maxMemoryLogs: 1000,
      ...config
    };
    
    // Start remote logger if configured
    if (this.config.targets?.includes(LogTarget.REMOTE) && this.config.remoteConfig) {
      this.startRemoteLogger();
    }
  }
  
  /**
   * Gets the singleton instance of the logger
   * 
   * @param config Optional configuration for the logger
   * @returns The logger instance
   */
  public static getInstance(config?: LoggerConfig): CSLogger {
    if (!CSLogger.instance) {
      CSLogger.instance = new CSLogger(config);
    } else if (config) {
      // Update existing instance with new config
      CSLogger.instance.configure(config);
    }
    
    return CSLogger.instance;
  }
  
  /**
   * Configures the logger
   * 
   * @param config Logger configuration
   */
  public configure(config: Partial<LoggerConfig>): void {
    // Stop remote logger if it's running
    if (this.sendTimer) {
      clearInterval(this.sendTimer);
      this.sendTimer = null;
    }
    
    // Merge new config with existing config
    this.config = {
      ...this.config,
      ...config,
      fileConfig: config.fileConfig 
        ? { ...this.config.fileConfig, ...config.fileConfig } 
        : this.config.fileConfig,
      remoteConfig: config.remoteConfig 
        ? { ...this.config.remoteConfig, ...config.remoteConfig } 
        : this.config.remoteConfig
    };
    
    // Start remote logger if configured
    if (this.config.targets?.includes(LogTarget.REMOTE) && this.config.remoteConfig) {
      this.startRemoteLogger();
    }
  }
  
  /**
   * Logs a message at TRACE level
   * 
   * @param message Log message
   * @param data Additional data
   * @param source Override source name
   */
  public trace(message: string, data?: any, source?: string): void {
    this.log(LogLevel.TRACE, message, data, undefined, source);
  }
  
  /**
   * Logs a message at DEBUG level
   * 
   * @param message Log message
   * @param data Additional data
   * @param source Override source name
   */
  public debug(message: string, data?: any, source?: string): void {
    this.log(LogLevel.DEBUG, message, data, undefined, source);
  }
  
  /**
   * Logs a message at INFO level
   * 
   * @param message Log message
   * @param data Additional data
   * @param source Override source name
   */
  public info(message: string, data?: any, source?: string): void {
    this.log(LogLevel.INFO, message, data, undefined, source);
  }
  
  /**
   * Logs a message at WARN level
   * 
   * @param message Log message
   * @param data Additional data
   * @param error Optional error object
   * @param source Override source name
   */
  public warn(message: string, data?: any, error?: Error, source?: string): void {
    this.log(LogLevel.WARN, message, data, error, source);
  }
  
  /**
   * Logs a message at ERROR level
   * 
   * @param message Log message
   * @param error Error object
   * @param data Additional data
   * @param source Override source name
   */
  public error(message: string, error?: Error, data?: any, source?: string): void {
    this.log(LogLevel.ERROR, message, data, error, source);
  }
  
  /**
   * Logs a message at FATAL level
   * 
   * @param message Log message
   * @param error Error object
   * @param data Additional data
   * @param source Override source name
   */
  public fatal(message: string, error?: Error, data?: any, source?: string): void {
    this.log(LogLevel.FATAL, message, data, error, source);
  }
  
  /**
   * Gets logs stored in memory
   * 
   * @param level Optional filter by log level
   * @param source Optional filter by source
   * @param limit Maximum number of logs to return (default: all logs)
   * @param newest Whether to return newest logs first (default: true)
   * @returns Array of log messages
   */
  public getMemoryLogs(
    level?: LogLevel, 
    source?: string, 
    limit?: number, 
    newest: boolean = true
  ): LogMessage[] {
    let logs = [...this.memoryLogs];
    
    // Filter by level
    if (level !== undefined) {
      logs = logs.filter(log => log.level >= level);
    }
    
    // Filter by source
    if (source) {
      logs = logs.filter(log => log.source === source);
    }
    
    // Sort by timestamp
    if (newest) {
      logs.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    } else {
      logs.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    }
    
    // Limit results
    if (limit !== undefined && limit > 0) {
      logs = logs.slice(0, limit);
    }
    
    return logs;
  }
  
  /**
   * Clears memory logs
   */
  public clearMemoryLogs(): void {
    this.memoryLogs = [];
  }
  
  /**
   * Gets the current log level
   * 
   * @returns The current log level
   */
  public getLevel(): LogLevel {
    return this.config.level || LogLevel.INFO;
  }
  
  /**
   * Sets the log level
   * 
   * @param level New log level
   */
  public setLevel(level: LogLevel): void {
    this.config.level = level;
  }
  
  /**
   * Adds a target to the logger
   * 
   * @param target Target to add
   */
  public addTarget(target: LogTarget): void {
    if (!this.config.targets) {
      this.config.targets = [];
    }
    
    if (!this.config.targets.includes(target)) {
      this.config.targets.push(target);
    }
    
    // Start remote logger if adding remote target
    if (target === LogTarget.REMOTE && 
        this.config.remoteConfig && 
        !this.sendTimer) {
      this.startRemoteLogger();
    }
  }
  
  /**
   * Removes a target from the logger
   * 
   * @param target Target to remove
   */
  public removeTarget(target: LogTarget): void {
    if (!this.config.targets) {
      return;
    }
    
    const index = this.config.targets.indexOf(target);
    if (index !== -1) {
      this.config.targets.splice(index, 1);
    }
    
    // Stop remote logger if removing remote target
    if (target === LogTarget.REMOTE && this.sendTimer) {
      clearInterval(this.sendTimer);
      this.sendTimer = null;
    }
  }
  
  /**
   * Main logging method
   * 
   * @param level Log level
   * @param message Log message
   * @param data Additional data
   * @param error Error object
   * @param source Override source name
   */
  private log(
    level: LogLevel, 
    message: string, 
    data?: any, 
    error?: Error, 
    source?: string
  ): void {
    // Check if level is enabled
    if (level < (this.config.level || LogLevel.INFO)) {
      return;
    }
    
    // Create log message
    const logMessage: LogMessage = {
      timestamp: new Date(),
      level,
      source: source || this.config.source || 'CSTestForge',
      message,
      data,
      error
    };
    
    // Process each target
    const targets = this.config.targets || [LogTarget.CONSOLE];
    
    for (const target of targets) {
      switch (target) {
        case LogTarget.CONSOLE:
          this.logToConsole(logMessage);
          break;
        case LogTarget.FILE:
          this.logToFile(logMessage);
          break;
        case LogTarget.MEMORY:
          this.logToMemory(logMessage);
          break;
        case LogTarget.REMOTE:
          this.logToRemote(logMessage);
          break;
      }
    }
  }
  
  /**
   * Formats a log message according to the format string
   * 
   * @param logMessage Log message
   * @returns Formatted log message
   */
  private formatLogMessage(logMessage: LogMessage): string {
    const { timestamp, level, source, message, data, error } = logMessage;
    
    // Replace placeholders in format string
    let formatted = (this.config.format || '[{timestamp}] [{level}] [{source}]: {message}')
      .replace('{timestamp}', this.formatTimestamp(timestamp))
      .replace('{level}', this.getLevelName(level))
      .replace('{source}', source)
      .replace('{message}', message);
    
    // Add data if present
    if (data !== undefined) {
      let dataStr: string;
      
      try {
        if (typeof data === 'object' && data !== null) {
          dataStr = JSON.stringify(data, this.safeJsonReplacer);
        } else {
          dataStr = String(data);
        }
        
        formatted += ` Data: ${dataStr}`;
      } catch (err) {
        formatted += ` Data: [Object cannot be stringified]`;
      }
    }
    
    // Add error if present
    if (error) {
      formatted += ` Error: ${error.name}: ${error.message}`;
      if (error.stack) {
        formatted += `\n${error.stack}`;
      }
    }
    
    return formatted;
  }
  
  /**
   * Formats a timestamp according to the date format
   * 
   * @param timestamp Timestamp to format
   * @returns Formatted timestamp
   */
  private formatTimestamp(timestamp: Date): string {
    if (!this.config.includeTimestamp) {
      return '';
    }
    
    // Simple formatter that supports common format patterns
    const year = timestamp.getFullYear();
    const month = (timestamp.getMonth() + 1).toString().padStart(2, '0');
    const day = timestamp.getDate().toString().padStart(2, '0');
    const hours = timestamp.getHours().toString().padStart(2, '0');
    const minutes = timestamp.getMinutes().toString().padStart(2, '0');
    const seconds = timestamp.getSeconds().toString().padStart(2, '0');
    const milliseconds = timestamp.getMilliseconds().toString().padStart(3, '0');
    
    const format = this.config.dateFormat || 'YYYY-MM-DD HH:mm:ss.SSS';
    
    return format
      .replace('YYYY', year.toString())
      .replace('MM', month)
      .replace('DD', day)
      .replace('HH', hours)
      .replace('mm', minutes)
      .replace('ss', seconds)
      .replace('SSS', milliseconds);
  }
  
  /**
   * Gets the name of a log level
   * 
   * @param level Log level
   * @returns Level name (TRACE, DEBUG, INFO, WARN, ERROR, FATAL)
   */
  private getLevelName(level: LogLevel): string {
    switch (level) {
      case LogLevel.TRACE:
        return 'TRACE';
      case LogLevel.DEBUG:
        return 'DEBUG';
      case LogLevel.INFO:
        return 'INFO';
      case LogLevel.WARN:
        return 'WARN';
      case LogLevel.ERROR:
        return 'ERROR';
      case LogLevel.FATAL:
        return 'FATAL';
      case LogLevel.OFF:
        return 'OFF';
      default:
        return 'UNKNOWN';
    }
  }
  
  /**
   * Logs a message to the console
   * 
   * @param logMessage Log message
   */
  private logToConsole(logMessage: LogMessage): void {
    const formatted = this.formatLogMessage(logMessage);
    
    // Use appropriate console method based on level
    switch (logMessage.level) {
      case LogLevel.TRACE:
      case LogLevel.DEBUG:
        console.debug(formatted);
        break;
      case LogLevel.INFO:
        console.info(formatted);
        break;
      case LogLevel.WARN:
        console.warn(formatted);
        break;
      case LogLevel.ERROR:
      case LogLevel.FATAL:
        console.error(formatted);
        break;
    }
  }
  
  /**
   * Logs a message to a file
   * 
   * @param logMessage Log message
   */
  private logToFile(logMessage: LogMessage): void {
    // Skip if no file configuration
    if (!this.config.fileConfig) {
      console.warn('File logging is enabled but no file configuration is provided');
      return;
    }
    
    const { filePath } = this.config.fileConfig;
    const formatted = this.formatLogMessage(logMessage);
    
    // In browser environment, we can use localStorage as a simplified alternative
    if (typeof window !== 'undefined') {
      try {
        // Create a log entry with timestamp
        const timestamp = new Date().getTime();
        const logEntry = { timestamp, message: formatted };
        
        // Get existing logs from localStorage or create new array
        const logsKey = `CSLogger_${filePath}`;
        const existingLogsStr = localStorage.getItem(logsKey);
        const existingLogs = existingLogsStr ? JSON.parse(existingLogsStr) : [];
        
        // Add new log entry
        existingLogs.push(logEntry);
        
        // Respect max size if configured
        const maxSize = this.config.fileConfig.maxSize || Number.MAX_SAFE_INTEGER;
        const maxFiles = this.config.fileConfig.maxFiles || 1;
        
        // Check if we need to rotate
        let totalSize = JSON.stringify(existingLogs).length;
        if (totalSize > maxSize) {
          // Simple rotation: split into chunks and keep only the most recent chunks
          const chunks = this.chunkLogs(existingLogs, maxSize / maxFiles);
          const keptChunks = chunks.slice(-maxFiles);
          
          // Store only the kept chunks
          localStorage.setItem(logsKey, JSON.stringify([].concat(...keptChunks)));
        } else {
          // Store all logs
          localStorage.setItem(logsKey, JSON.stringify(existingLogs));
        }
      } catch (err) {
        console.error('Error writing to localStorage logs', err);
      }
    } 
    // In Node.js environment, we can use the fs module
    else if (typeof require === 'function') {
      try {
        // Dynamically require fs to avoid issues in browser environment
        const fs = require('fs');
        const path = require('path');
        
        // Create directory if it doesn't exist
        const directory = path.dirname(filePath);
        if (!fs.existsSync(directory)) {
          fs.mkdirSync(directory, { recursive: true });
        }
        
        // Check if file exists and get its size
        let fileSize = 0;
        if (fs.existsSync(filePath)) {
          const stats = fs.statSync(filePath);
          fileSize = stats.size;
        }
        
        // Check if we need to rotate
        const maxSize = this.config.fileConfig.maxSize || Number.MAX_SAFE_INTEGER;
        if (fileSize > maxSize) {
          this.rotateLogFiles(filePath);
        }
        
        // Append to file
        fs.appendFileSync(filePath, formatted + '\n', 'utf8');
      } catch (err) {
        console.error('Error writing to file logs', err);
      }
    }
    // If neither browser nor Node.js, log a warning
    else {
      console.warn('File logging is not supported in this environment');
    }
  }
  
  /**
   * Rotates log files when they exceed the maximum size
   * 
   * @param filePath Path to the log file
   */
  private rotateLogFiles(filePath: string): void {
    // Skip if no file configuration
    if (!this.config.fileConfig) {
      return;
    }
    
    const { maxFiles = 5 } = this.config.fileConfig;
    
    try {
      // Dynamically require fs to avoid issues in browser environment
      const fs = require('fs');
      const path = require('path');
      
      // Delete the oldest backup file if it exists
      const oldestBackup = `${filePath}.${maxFiles}`;
      if (fs.existsSync(oldestBackup)) {
        fs.unlinkSync(oldestBackup);
      }
      
      // Shift backup files
      for (let i = maxFiles - 1; i >= 1; i--) {
        const oldPath = `${filePath}.${i}`;
        const newPath = `${filePath}.${i + 1}`;
        
        if (fs.existsSync(oldPath)) {
          fs.renameSync(oldPath, newPath);
        }
      }
      
      // Rename current log file to .1
      fs.renameSync(filePath, `${filePath}.1`);
      
      // Create a new empty log file
      fs.writeFileSync(filePath, '', 'utf8');
    } catch (err) {
      console.error('Error rotating log files', err);
    }
  }
  
  /**
   * Chunks an array of logs into smaller arrays based on a target size
   * 
   * @param logs Array of log entries
   * @param targetSize Target size for each chunk in bytes
   * @returns Array of chunked logs
   */
  private chunkLogs(logs: any[], targetSize: number): any[][] {
    const chunks: any[][] = [];
    let currentChunk: any[] = [];
    let currentSize = 0;
    
    for (const log of logs) {
      const logSize = JSON.stringify(log).length;
      
      // If adding this log would exceed the target size, start a new chunk
      if (currentSize + logSize > targetSize && currentChunk.length > 0) {
        chunks.push(currentChunk);
        currentChunk = [];
        currentSize = 0;
      }
      
      // Add the log to the current chunk
      currentChunk.push(log);
      currentSize += logSize;
    }
    
    // Add the last chunk if it has logs
    if (currentChunk.length > 0) {
      chunks.push(currentChunk);
    }
    
    return chunks;
  }
  
  /**
   * Logs a message to memory
   * 
   * @param logMessage Log message
   */
  private logToMemory(logMessage: LogMessage): void {
    this.memoryLogs.push(logMessage);
    
    // Respect max memory logs
    const maxMemoryLogs = this.config.maxMemoryLogs || 1000;
    if (this.memoryLogs.length > maxMemoryLogs) {
      this.memoryLogs = this.memoryLogs.slice(-maxMemoryLogs);
    }
  }
  
  /**
   * Adds a log message to the remote batch
   * 
   * @param logMessage Log message
   */
  private logToRemote(logMessage: LogMessage): void {
    // Skip if no remote configuration
    if (!this.config.remoteConfig) {
      return;
    }
    
    // Add to batch
    this.remoteBatch.push(logMessage);
    
    // Send immediately if batch size reached
    const batchSize = this.config.remoteConfig.batchSize || 10;
    if (this.remoteBatch.length >= batchSize) {
      this.sendRemoteBatch();
    }
  }
  
  /**
   * Starts the remote logger
   */
  private startRemoteLogger(): void {
    // Skip if no remote configuration
    if (!this.config.remoteConfig) {
      return;
    }
    
    // Start sending logs periodically
    const sendInterval = this.config.remoteConfig.sendInterval || 10000; // Default: 10 seconds
    this.sendTimer = setInterval(() => {
      if (this.remoteBatch.length > 0) {
        this.sendRemoteBatch();
      }
    }, sendInterval);
  }
  
  /**
   * Sends the remote batch to the remote server
   */
  private sendRemoteBatch(): void {
    // Skip if no remote configuration
    if (!this.config.remoteConfig) {
      return;
    }
    
    // Skip if no logs to send
    if (this.remoteBatch.length === 0) {
      return;
    }
    
    const { url, authToken, headers = {} } = this.config.remoteConfig;
    const batch = [...this.remoteBatch];
    this.remoteBatch = [];
    
    // Prepare headers
    const requestHeaders: Record<string, string> = {
      'Content-Type': 'application/json',
      ...headers
    };
    
    // Add authorization header if provided
    if (authToken) {
      requestHeaders['Authorization'] = `Bearer ${authToken}`;
    }
    
    // Send logs to remote server
    this.sendHttpRequest(url, 'POST', requestHeaders, batch)
      .catch(err => {
        console.error('Error sending logs to remote server', err);
        
        // Add logs back to the batch
        this.remoteBatch = [...batch, ...this.remoteBatch];
        
        // Limit batch size to avoid excessive memory usage
        const batchSize = this.config.remoteConfig?.batchSize || 10;
        const maxBatchSize = batchSize * 5;
        if (this.remoteBatch.length > maxBatchSize) {
          this.remoteBatch = this.remoteBatch.slice(-maxBatchSize);
        }
      });
  }
  
  /**
   * Sends an HTTP request to a remote server
   * 
   * @param url URL to send request to
   * @param method HTTP method (GET, POST, etc.)
   * @param headers HTTP headers
   * @param body Request body
   * @returns Promise that resolves when the request is complete
   */
  private sendHttpRequest(
    url: string, 
    method: string, 
    headers: Record<string, string>, 
    body: any
  ): Promise<any> {
    // In browser environment, use fetch API
    if (typeof window !== 'undefined' && window.fetch) {
      return window.fetch(url, {
        method,
        headers,
        body: JSON.stringify(body)
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
        }
        return response.json();
      });
    }
    // In Node.js environment, use http/https module
    else if (typeof require === 'function') {
      return new Promise((resolve, reject) => {
        try {
          // Dynamically require http or https based on the URL
          const isHttps = url.startsWith('https:');
          const httpModule = isHttps ? require('https') : require('http');
          const urlModule = require('url');
          
          // Parse URL
          const parsedUrl = urlModule.parse(url);
          
          // Prepare request options
          const options = {
            hostname: parsedUrl.hostname,
            port: parsedUrl.port,
            path: parsedUrl.path,
            method,
            headers
          };
          
          // Create request
          const req = httpModule.request(options, (res: any) => {
            let data = '';
            
            // Collect response data
            res.on('data', (chunk: string) => {
              data += chunk;
            });
            
            // Process response
            res.on('end', () => {
              if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                try {
                  resolve(JSON.parse(data));
                } catch (err) {
                  resolve(data);
                }
              } else {
                reject(new Error(`HTTP error: ${res.statusCode} ${res.statusMessage}`));
              }
            });
          });
          
          // Handle errors
          req.on('error', (err: Error) => {
            reject(err);
          });
          
          // Send request body
          req.write(JSON.stringify(body));
          req.end();
        } catch (err) {
          reject(err);
        }
      });
    }
    // If neither browser nor Node.js, return a rejected promise
    else {
      return Promise.reject(new Error('HTTP requests are not supported in this environment'));
    }
  }
  
  /**
   * Safe JSON replacer function that handles circular references
   * 
   * @param key Property key
   * @param value Property value
   * @returns Safe value for JSON.stringify
   */
  private safeJsonReplacer(key: string, value: any): any {
    // Handle circular references
    if (typeof value === 'object' && value !== null) {
      if (this.seen.has(value)) {
        return '[Circular Reference]';
      }
      this.seen.add(value);
    }
    
    // Handle Error objects
    if (value instanceof Error) {
      return {
        name: value.name,
        message: value.message,
        stack: value.stack
      };
    }
    
    // Handle functions
    if (typeof value === 'function') {
      return '[Function]';
    }
    
    // Handle symbols
    if (typeof value === 'symbol') {
      return value.toString();
    }
    
    // Handle BigInt
    if (typeof value === 'bigint') {
      return value.toString();
    }
    
    return value;
  }
  
  // Private property for tracking seen objects (circular references)
  private seen = new WeakSet();
}

export default CSLogger;


/**
 * CSFileUtils.ts
 * 
 * Utility class for file system operations.
 * Provides cross-platform (Browser/Node.js) file handling capabilities.
 */

import CSLogger from './CSLogger';

/**
 * Options for reading files
 */
export interface ReadFileOptions {
  /** Encoding for the file contents (default: 'utf8') */
  encoding?: string;
  /** Flag for file operations (default: 'r') */
  flag?: string;
}

/**
 * Options for writing files
 */
export interface WriteFileOptions {
  /** Encoding for the file contents (default: 'utf8') */
  encoding?: string;
  /** Flag for file operations (default: 'w') */
  flag?: string;
  /** File mode (default: 0o666) */
  mode?: number;
  /** Whether to create the directory if it doesn't exist (default: true) */
  createDir?: boolean;
}

/**
 * Options for copying files
 */
export interface CopyOptions {
  /** Whether to overwrite existing files (default: false) */
  overwrite?: boolean;
  /** Whether to create the destination directory if it doesn't exist (default: true) */
  createDir?: boolean;
  /** Whether to preserve file attributes (default: true) */
  preserveTimestamps?: boolean;
}

/**
 * File stats object
 */
export interface FileStats {
  /** Whether the path is a directory */
  isDirectory: boolean;
  /** Whether the path is a file */
  isFile: boolean;
  /** Whether the path is a symbolic link */
  isSymbolicLink: boolean;
  /** Size of the file in bytes */
  size: number;
  /** Time of last access */
  atime: Date;
  /** Time of last modification */
  mtime: Date;
  /** Time of creation */
  ctime: Date;
  /** Time of birth (creation) */
  birthtime: Date;
}

/**
 * Result of reading a directory
 */
export interface ReadDirResult {
  /** Array of file and directory names */
  names: string[];
  /** Array of file and directory paths (full paths) */
  paths: string[];
  /** Array of objects containing name, path, and type (file/directory) */
  items: Array<{
    name: string;
    path: string;
    type: 'file' | 'directory' | 'symlink' | 'unknown';
  }>;
}

/**
 * Custom file system error
 */
export class FileSystemError extends Error {
  /** Error code */
  code: string;
  /** Path associated with the error */
  path?: string;
  
  /**
   * Creates a new FileSystemError
   * 
   * @param message Error message
   * @param code Error code
   * @param path Path associated with the error
   */
  constructor(message: string, code: string, path?: string) {
    super(message);
    this.name = 'FileSystemError';
    this.code = code;
    this.path = path;
  }
}

/**
 * Utility class for file system operations
 */
export class CSFileUtils {
  private static readonly logger = CSLogger.getInstance();
  private static readonly ENVIRONMENT = typeof window !== 'undefined' ? 'browser' : 'node';
  
  /**
   * File system module (Node.js only)
   */
  private static get fs(): any {
    if (this.ENVIRONMENT === 'browser') {
      return null;
    }
    
    try {
      return require('fs');
    } catch (err) {
      throw new FileSystemError(
        'File system module is not available in this environment',
        'MODULE_NOT_FOUND'
      );
    }
  }
  
  /**
   * Path module (Node.js only)
   */
  private static get path(): any {
    if (this.ENVIRONMENT === 'browser') {
      return null;
    }
    
    try {
      return require('path');
    } catch (err) {
      throw new FileSystemError(
        'Path module is not available in this environment',
        'MODULE_NOT_FOUND'
      );
    }
  }
  
  /**
   * Checks if running in browser environment
   * 
   * @returns True if running in browser, false otherwise
   */
  public static isBrowser(): boolean {
    return this.ENVIRONMENT === 'browser';
  }
  
  /**
   * Checks if running in Node.js environment
   * 
   * @returns True if running in Node.js, false otherwise
   */
  public static isNode(): boolean {
    return this.ENVIRONMENT === 'node';
  }
  
  /**
   * Checks if a file or directory exists
   * 
   * @param path Path to check
   * @returns Promise resolving to true if the path exists, false otherwise
   */
  public static async exists(path: string): Promise<boolean> {
    try {
      if (this.isNode()) {
        return this.fs.existsSync(path);
      } else {
        // In browser, use window.fs API if available
        if (window.fs) {
          try {
            await window.fs.stat(path);
            return true;
          } catch (err) {
            // If error is ENOENT, file doesn't exist
            if (err.code === 'ENOENT') {
              return false;
            }
            throw err;
          }
        }
        
        // Fallback to localStorage for browser
        if (typeof localStorage !== 'undefined') {
          return localStorage.getItem(`CSFileUtils_${path}`) !== null;
        }
        
        throw new FileSystemError(
          'File system API is not available in this environment',
          'API_NOT_AVAILABLE'
        );
      }
    } catch (err) {
      // Handle ENOENT error (path doesn't exist)
      if (err.code === 'ENOENT') {
        return false;
      }
      
      this.logger.error(`Error checking if path exists: ${path}`, err);
      throw new FileSystemError(
        `Error checking if path exists: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        path
      );
    }
  }
  
  /**
   * Reads a file
   * 
   * @param path Path to the file
   * @param options Options for reading the file
   * @returns Promise resolving to the file contents
   */
  public static async readFile(path: string, options: ReadFileOptions = {}): Promise<string | Buffer> {
    const encoding = options.encoding || 'utf8';
    const flag = options.flag || 'r';
    
    try {
      if (this.isNode()) {
        // Use native fs module in Node.js
        return this.fs.promises.readFile(path, { encoding, flag });
      } else {
        // In browser, use window.fs API if available
        if (window.fs) {
          const data = await window.fs.readFile(path, { encoding });
          return data;
        }
        
        // Fallback to localStorage for browser
        if (typeof localStorage !== 'undefined') {
          const data = localStorage.getItem(`CSFileUtils_${path}`);
          
          if (data === null) {
            throw new FileSystemError(
              `File not found: ${path}`,
              'ENOENT',
              path
            );
          }
          
          return data;
        }
        
        throw new FileSystemError(
          'File system API is not available in this environment',
          'API_NOT_AVAILABLE'
        );
      }
    } catch (err) {
      this.logger.error(`Error reading file: ${path}`, err);
      throw new FileSystemError(
        `Error reading file: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        path
      );
    }
  }
  
  /**
   * Writes data to a file
   * 
   * @param path Path to the file
   * @param data Data to write
   * @param options Options for writing the file
   * @returns Promise resolving when the file is written
   */
  public static async writeFile(
    path: string,
    data: string | Buffer | ArrayBuffer,
    options: WriteFileOptions = {}
  ): Promise<void> {
    const encoding = options.encoding || 'utf8';
    const flag = options.flag || 'w';
    const mode = options.mode || 0o666;
    const createDir = options.createDir !== false;
    
    try {
      // Create directory if it doesn't exist
      if (createDir) {
        const dirPath = this.isNode() 
          ? this.path.dirname(path)
          : path.substring(0, path.lastIndexOf('/'));
          
        await this.mkdir(dirPath, { recursive: true });
      }
      
      if (this.isNode()) {
        // Use native fs module in Node.js
        await this.fs.promises.writeFile(path, data, { encoding, flag, mode });
      } else {
        // In browser, use window.fs API if available
        if (window.fs) {
          await window.fs.writeFile(path, data, { encoding });
          return;
        }
        
        // Fallback to localStorage for browser
        if (typeof localStorage !== 'undefined') {
          if (data instanceof ArrayBuffer) {
            // Convert ArrayBuffer to string
            data = new TextDecoder(encoding).decode(data);
          } else if (data instanceof Buffer) {
            // Convert Buffer to string
            data = data.toString(encoding);
          }
          
          localStorage.setItem(`CSFileUtils_${path}`, data as string);
          return;
        }
        
        throw new FileSystemError(
          'File system API is not available in this environment',
          'API_NOT_AVAILABLE'
        );
      }
    } catch (err) {
      this.logger.error(`Error writing file: ${path}`, err);
      throw new FileSystemError(
        `Error writing file: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        path
      );
    }
  }
  
  /**
   * Appends data to a file
   * 
   * @param path Path to the file
   * @param data Data to append
   * @param options Options for appending to the file
   * @returns Promise resolving when the data is appended
   */
  public static async appendFile(
    path: string,
    data: string | Buffer | ArrayBuffer,
    options: WriteFileOptions = {}
  ): Promise<void> {
    try {
      if (this.isNode()) {
        // Use native fs module in Node.js
        const encoding = options.encoding || 'utf8';
        const mode = options.mode || 0o666;
        const createDir = options.createDir !== false;
        
        // Create directory if it doesn't exist
        if (createDir) {
          const dirPath = this.path.dirname(path);
          await this.mkdir(dirPath, { recursive: true });
        }
        
        await this.fs.promises.appendFile(path, data, { encoding, mode });
      } else {
        // In browser, read existing file and then write
        let existingData = '';
        
        if (await this.exists(path)) {
          existingData = await this.readFile(path, options) as string;
        }
        
        // Convert data to string if needed
        let newData: string;
        if (data instanceof ArrayBuffer) {
          // Convert ArrayBuffer to string
          newData = new TextDecoder(options.encoding || 'utf8').decode(data);
        } else if (data instanceof Buffer) {
          // Convert Buffer to string
          newData = data.toString(options.encoding || 'utf8');
        } else {
          newData = data;
        }
        
        // Combine and write
        await this.writeFile(path, existingData + newData, options);
      }
    } catch (err) {
      this.logger.error(`Error appending to file: ${path}`, err);
      throw new FileSystemError(
        `Error appending to file: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        path
      );
    }
  }
  
  /**
   * Deletes a file
   * 
   * @param path Path to the file
   * @returns Promise resolving when the file is deleted
   */
  public static async deleteFile(path: string): Promise<void> {
    try {
      if (this.isNode()) {
        // Use native fs module in Node.js
        await this.fs.promises.unlink(path);
      } else {
        // In browser, use window.fs API if available
        if (window.fs) {
          await window.fs.unlink(path);
          return;
        }
        
        // Fallback to localStorage for browser
        if (typeof localStorage !== 'undefined') {
          localStorage.removeItem(`CSFileUtils_${path}`);
          return;
        }
        
        throw new FileSystemError(
          'File system API is not available in this environment',
          'API_NOT_AVAILABLE'
        );
      }
    } catch (err) {
      // Ignore if file doesn't exist
      if (err.code === 'ENOENT') {
        return;
      }
      
      this.logger.error(`Error deleting file: ${path}`, err);
      throw new FileSystemError(
        `Error deleting file: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        path
      );
    }
  }
  
  /**
   * Creates a directory
   * 
   * @param path Path to the directory
   * @param options Options for creating the directory
   * @returns Promise resolving when the directory is created
   */
  public static async mkdir(path: string, options: { recursive?: boolean; mode?: number } = {}): Promise<void> {
    const recursive = options.recursive !== false;
    const mode = options.mode || 0o777;
    
    try {
      if (this.isNode()) {
        // Use native fs module in Node.js
        await this.fs.promises.mkdir(path, { recursive, mode });
      } else {
        // In browser, use window.fs API if available
        if (window.fs) {
          await window.fs.mkdir(path, { recursive });
          return;
        }
        
        // Fallback to localStorage for browser
        if (typeof localStorage !== 'undefined') {
          // Just mark the directory as existing
          localStorage.setItem(`CSFileUtils_${path}_isDir`, 'true');
          
          // If recursive, create parent directories too
          if (recursive && path.includes('/')) {
            const parentPath = path.substring(0, path.lastIndexOf('/'));
            if (parentPath) {
              await this.mkdir(parentPath, { recursive: true });
            }
          }
          
          return;
        }
        
        throw new FileSystemError(
          'File system API is not available in this environment',
          'API_NOT_AVAILABLE'
        );
      }
    } catch (err) {
      // Ignore if directory already exists
      if (err.code === 'EEXIST') {
        return;
      }
      
      this.logger.error(`Error creating directory: ${path}`, err);
      throw new FileSystemError(
        `Error creating directory: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        path
      );
    }
  }
  
  /**
   * Removes a directory
   * 
   * @param path Path to the directory
   * @param options Options for removing the directory
   * @returns Promise resolving when the directory is removed
   */
  public static async rmdir(
    path: string,
    options: { recursive?: boolean } = {}
  ): Promise<void> {
    const recursive = options.recursive !== false;
    
    try {
      if (this.isNode()) {
        // Use native fs module in Node.js
        if (recursive && typeof this.fs.promises.rm === 'function') {
          // Use fs.rm if available (Node.js 14.14.0+)
          await this.fs.promises.rm(path, { recursive, force: true });
        } else if (recursive) {
          // Fallback to rimraf for older Node.js versions
          await this.rmdirRecursive(path);
        } else {
          // Use rmdir for non-recursive removal
          await this.fs.promises.rmdir(path);
        }
      } else {
        // In browser, use window.fs API if available
        if (window.fs) {
          if (recursive) {
            // Get all files and directories inside this directory
            const entries = await this.readDir(path);
            
            // Delete all files and subdirectories
            for (const item of entries.items) {
              if (item.type === 'file') {
                await this.deleteFile(item.path);
              } else if (item.type === 'directory') {
                await this.rmdir(item.path, { recursive: true });
              }
            }
          }
          
          // Remove the directory itself
          await window.fs.rmdir(path);
          return;
        }
        
        // Fallback to localStorage for browser
        if (typeof localStorage !== 'undefined') {
          // Get all keys that start with this path
          const keys = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(`CSFileUtils_${path}`)) {
              keys.push(key);
            }
          }
          
          // Remove all matching keys
          for (const key of keys) {
            localStorage.removeItem(key);
          }
          
          return;
        }
        
        throw new FileSystemError(
          'File system API is not available in this environment',
          'API_NOT_AVAILABLE'
        );
      }
    } catch (err) {
      // Ignore if directory doesn't exist
      if (err.code === 'ENOENT') {
        return;
      }
      
      this.logger.error(`Error removing directory: ${path}`, err);
      throw new FileSystemError(
        `Error removing directory: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        path
      );
    }
  }
  
  /**
   * Recursively removes a directory (Node.js implementation)
   * 
   * @param path Path to the directory
   * @returns Promise resolving when the directory is removed
   */
  private static async rmdirRecursive(path: string): Promise<void> {
    // Only applicable in Node.js
    if (!this.isNode()) return;
    
    try {
      // Get directory contents
      const entries = await this.fs.promises.readdir(path, { withFileTypes: true });
      
      // Process all entries
      for (const entry of entries) {
        const entryPath = this.path.join(path, entry.name);
        
        if (entry.isDirectory()) {
          // Recursively remove subdirectory
          await this.rmdirRecursive(entryPath);
        } else {
          // Delete file
          await this.fs.promises.unlink(entryPath);
        }
      }
      
      // Remove directory itself
      await this.fs.promises.rmdir(path);
    } catch (err) {
      // Ignore if directory doesn't exist
      if (err.code === 'ENOENT') {
        return;
      }
      
      throw err;
    }
  }
  
  /**
   * Reads a directory
   * 
   * @param path Path to the directory
   * @returns Promise resolving to directory contents
   */
  public static async readDir(path: string): Promise<ReadDirResult> {
    try {
      if (this.isNode()) {
        // Use native fs module in Node.js
        const entries = await this.fs.promises.readdir(path, { withFileTypes: true });
        
        const result: ReadDirResult = {
          names: [],
          paths: [],
          items: []
        };
        
        for (const entry of entries) {
          const entryPath = this.path.join(path, entry.name);
          let type: 'file' | 'directory' | 'symlink' | 'unknown' = 'unknown';
          
          if (entry.isFile()) type = 'file';
          else if (entry.isDirectory()) type = 'directory';
          else if (entry.isSymbolicLink()) type = 'symlink';
          
          result.names.push(entry.name);
          result.paths.push(entryPath);
          result.items.push({
            name: entry.name,
            path: entryPath,
            type
          });
        }
        
        return result;
      } else {
        // In browser, use window.fs API if available
        if (window.fs) {
          const entries = await window.fs.readdir(path);
          
          const result: ReadDirResult = {
            names: [],
            paths: [],
            items: []
          };
          
          for (const entry of entries) {
            const entryPath = `${path}/${entry}`;
            
            // Get file stats to determine type
            let type: 'file' | 'directory' | 'symlink' | 'unknown' = 'unknown';
            try {
              const stats = await window.fs.stat(entryPath);
              if (stats.isDirectory()) type = 'directory';
              else if (stats.isFile()) type = 'file';
              else if (stats.isSymbolicLink()) type = 'symlink';
            } catch (err) {
              // Ignore errors
            }
            
            result.names.push(entry);
            result.paths.push(entryPath);
            result.items.push({
              name: entry,
              path: entryPath,
              type
            });
          }
          
          return result;
        }
        
        // Fallback to localStorage for browser
        if (typeof localStorage !== 'undefined') {
          const result: ReadDirResult = {
            names: [],
            paths: [],
            items: []
          };
          
          // Get all keys that start with this path
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(`CSFileUtils_${path}/`)) {
              // Extract the relative path and first segment
              const relativePath = key.substring(`CSFileUtils_${path}/`.length);
              const segments = relativePath.split('/');
              const firstSegment = segments[0];
              
              // Skip if already processed
              if (result.names.includes(firstSegment)) {
                continue;
              }
              
              // Determine if it's a file or directory
              const entryPath = `${path}/${firstSegment}`;
              let type: 'file' | 'directory' | 'symlink' | 'unknown' = 'unknown';
              
              if (localStorage.getItem(`CSFileUtils_${entryPath}_isDir`) === 'true') {
                type = 'directory';
              } else if (segments.length === 1) {
                type = 'file';
              } else {
                type = 'directory';
              }
              
              result.names.push(firstSegment);
              result.paths.push(entryPath);
              result.items.push({
                name: firstSegment,
                path: entryPath,
                type
              });
            }
          }
          
          return result;
        }
        
        throw new FileSystemError(
          'File system API is not available in this environment',
          'API_NOT_AVAILABLE'
        );
      }
    } catch (err) {
      this.logger.error(`Error reading directory: ${path}`, err);
      throw new FileSystemError(
        `Error reading directory: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        path
      );
    }
  }
  
  /**
   * Gets file or directory stats
   * 
   * @param path Path to the file or directory
   * @returns Promise resolving to file stats
   */
  public static async stat(path: string): Promise<FileStats> {
    try {
      if (this.isNode()) {
        // Use native fs module in Node.js
        const stats = await this.fs.promises.stat(path);
        
        return {
          isDirectory: stats.isDirectory(),
          isFile: stats.isFile(),
          isSymbolicLink: stats.isSymbolicLink(),
          size: stats.size,
          atime: stats.atime,
          mtime: stats.mtime,
          ctime: stats.ctime,
          birthtime: stats.birthtime
        };
      } else {
        // In browser, use window.fs API if available
        if (window.fs) {
          const stats = await window.fs.stat(path);
          
          return {
            isDirectory: stats.isDirectory(),
            isFile: stats.isFile(),
            isSymbolicLink: stats.isSymbolicLink(),
            size: stats.size,
            atime: new Date(stats.atime),
            mtime: new Date(stats.mtime),
            ctime: new Date(stats.ctime),
            birthtime: new Date(stats.birthtime)
          };
        }
        
        // Fallback to localStorage for browser
        if (typeof localStorage !== 'undefined') {
          // Check if it's a directory
          const isDirectory = localStorage.getItem(`CSFileUtils_${path}_isDir`) === 'true';
          
          // Check if it's a file
          const fileContent = localStorage.getItem(`CSFileUtils_${path}`);
          const isFile = fileContent !== null;
          
          if (!isDirectory && !isFile) {
            throw new FileSystemError(
              `File or directory not found: ${path}`,
              'ENOENT',
              path
            );
          }
          
          // Create a simple stats object
          const now = new Date();
          
          return {
            isDirectory,
            isFile,
            isSymbolicLink: false,
            size: isFile ? fileContent!.length : 0,
            atime: now,
            mtime: now,
            ctime: now,
            birthtime: now
          };
        }
        
        throw new FileSystemError(
          'File system API is not available in this environment',
          'API_NOT_AVAILABLE'
        );
      }
    } catch (err) {
      this.logger.error(`Error getting stats: ${path}`, err);
      throw new FileSystemError(
        `Error getting stats: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        path
      );
    }
  }
  
  /**
   * Copies a file
   * 
   * @param src Source path
   * @param dest Destination path
   * @param options Copy options
   * @returns Promise resolving when the file is copied
   */
  public static async copyFile(
    src: string,
    dest: string,
    options: CopyOptions = {}
  ): Promise<void> {
    const overwrite = options.overwrite || false;
    const createDir = options.createDir !== false;
    
    try {
      // Check if destination exists
      if (!overwrite && await this.exists(dest)) {
        throw new FileSystemError(
          `Destination already exists: ${dest}`,
          'EEXIST',
          dest
        );
      }
      
      // Create destination directory if it doesn't exist
      if (createDir) {
        const destDir = this.isNode()
          ? this.path.dirname(dest)
          : dest.substring(0, dest.lastIndexOf('/'));
          
        await this.mkdir(destDir, { recursive: true });
      }
      
      if (this.isNode()) {
        // Use native fs module in Node.js
        await this.fs.promises.copyFile(
          src,
          dest,
          overwrite ? 0 : this.fs.constants.COPYFILE_EXCL
        );
        
        // Preserve timestamps if requested
        if (options.preserveTimestamps) {
          const stats = await this.fs.promises.stat(src);
          await this.fs.promises.utimes(
            dest,
            stats.atime,
            stats.mtime
          );
        }
      } else {
        // Read source file and write to destination
        const content = await this.readFile(src);
        await this.writeFile(dest, content);
      }
    } catch (err) {
      this.logger.error(`Error copying file: ${src} to ${dest}`, err);
      throw new FileSystemError(
        `Error copying file: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        `${src} -> ${dest}`
      );
    }
  }
  
  /**
   * Copies a directory recursively
   * 
   * @param src Source directory
   * @param dest Destination directory
   * @param options Copy options
   * @returns Promise resolving when the directory is copied
   */
  public static async copyDir(
    src: string,
    dest: string,
    options: CopyOptions = {}
  ): Promise<void> {
    const overwrite = options.overwrite || false;
    const createDir = options.createDir !== false;
    
    try {
      // Check if source exists and is a directory
      const srcStats = await this.stat(src);
      if (!srcStats.isDirectory) {
        throw new FileSystemError(
          `Source is not a directory: ${src}`,
          'EINVAL',
          src
        );
      }
      
      // Check if destination exists
      const destExists = await this.exists(dest);
      
      // If destination exists and is a file, it's an error
      if (destExists) {
        const destStats = await this.stat(dest);
        if (destStats.isFile) {
          throw new FileSystemError(
            `Destination is a file: ${dest}`,
            'EINVAL',
            dest
          );
        }
        
        // If destination exists and overwrite is false, it's an error
        if (!overwrite) {
          throw new FileSystemError(
            `Destination already exists: ${dest}`,
            'EEXIST',
            dest
          );
        }
      }
      
      // Create destination directory
      await this.mkdir(dest, { recursive: createDir });
      
      // Get source directory contents
      const entries = await this.readDir(src);
      
      // Copy each entry
      for (const entry of entries.items) {
        const srcPath = entry.path;
        const destPath = this.isNode()
          ? this.path.join(dest, this.path.basename(srcPath))
          : `${dest}/${srcPath.substring(srcPath.lastIndexOf('/') + 1)}`;
        
        if (entry.type === 'file') {
          // Copy file
          await this.copyFile(srcPath, destPath, options);
        } else if (entry.type === 'directory') {
          // Recursively copy directory
          await this.copyDir(srcPath, destPath, options);
        }
      }
    } catch (err) {
      this.logger.error(`Error copying directory: ${src} to ${dest}`, err);
      throw new FileSystemError(
        `Error copying directory: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        `${src} -> ${dest}`
      );
    }
  }
  
  /**
   * Moves a file or directory
   * 
   * @param src Source path
   * @param dest Destination path
   * @param options Copy options
   * @returns Promise resolving when the path is moved
   */
  public static async move(
    src: string,
    dest: string,
    options: CopyOptions = {}
  ): Promise<void> {
    const overwrite = options.overwrite || false;
    const createDir = options.createDir !== false;
    
    try {
      // Check if source exists
      if (!await this.exists(src)) {
        throw new FileSystemError(
          `Source does not exist: ${src}`,
          'ENOENT',
          src
        );
      }
      
      // Check if destination exists
      if (!overwrite && await this.exists(dest)) {
        throw new FileSystemError(
          `Destination already exists: ${dest}`,
          'EEXIST',
          dest
        );
      }
      
      // Create destination directory if it doesn't exist
      if (createDir) {
        const destDir = this.isNode()
          ? this.path.dirname(dest)
          : dest.substring(0, dest.lastIndexOf('/'));
          
        await this.mkdir(destDir, { recursive: true });
      }
      
      if (this.isNode()) {
        // Use native fs module in Node.js
        try {
          // Try rename first (fastest, but may not work across devices)
          await this.fs.promises.rename(src, dest);
        } catch (err) {
          // If rename fails, fall back to copy and delete
          const stats = await this.stat(src);
          
          if (stats.isFile) {
            await this.copyFile(src, dest, options);
          } else if (stats.isDirectory) {
            await this.copyDir(src, dest, options);
          } else {
            throw new FileSystemError(
              `Source is neither a file nor a directory: ${src}`,
              'EINVAL',
              src
            );
          }
          
          // Delete source after successful copy
          if (stats.isFile) {
            await this.deleteFile(src);
          } else {
            await this.rmdir(src, { recursive: true });
          }
        }
      } else {
        // In browser, always use copy and delete
        const stats = await this.stat(src);
        
        if (stats.isFile) {
          await this.copyFile(src, dest, options);
          await this.deleteFile(src);
        } else if (stats.isDirectory) {
          await this.copyDir(src, dest, options);
          await this.rmdir(src, { recursive: true });
        } else {
          throw new FileSystemError(
            `Source is neither a file nor a directory: ${src}`,
            'EINVAL',
            src
          );
        }
      }
    } catch (err) {
      this.logger.error(`Error moving: ${src} to ${dest}`, err);
      throw new FileSystemError(
        `Error moving: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        `${src} -> ${dest}`
      );
    }
  }
  
  /**
   * Renames a file or directory
   * 
   * @param oldPath Old path
   * @param newPath New path
   * @returns Promise resolving when the path is renamed
   */
  public static async rename(oldPath: string, newPath: string): Promise<void> {
    try {
      if (this.isNode()) {
        // Use native fs module in Node.js
        await this.fs.promises.rename(oldPath, newPath);
      } else {
        // In browser, use move operation
        await this.move(oldPath, newPath, { overwrite: true });
      }
    } catch (err) {
      this.logger.error(`Error renaming: ${oldPath} to ${newPath}`, err);
      throw new FileSystemError(
        `Error renaming: ${err.message}`,
        err.code || 'UNKNOWN_ERROR',
        `${oldPath} -> ${newPath}`
      );
    }
  }
}

// Declare window.fs interface for browser environment
declare global {
  interface Window {
    fs?: {
      readFile: (path: string, options?: { encoding?: string }) => Promise<string | ArrayBuffer>;
      writeFile: (path: string, data: string | ArrayBuffer, options?: { encoding?: string }) => Promise<void>;
      appendFile: (path: string, data: string | ArrayBuffer, options?: { encoding?: string }) => Promise<void>;
      unlink: (path: string) => Promise<void>;
      mkdir: (path: string, options?: { recursive?: boolean }) => Promise<void>;
      rmdir: (path: string) => Promise<void>;
      readdir: (path: string) => Promise<string[]>;
      stat: (path: string) => Promise<{
        isDirectory: () => boolean;
        isFile: () => boolean;
        isSymbolicLink: () => boolean;
        size: number;
        atime: number | Date;
        mtime: number | Date;
        ctime: number | Date;
        birthtime: number | Date;
      }>;
    };
  }
}

export default CSFileUtils;


/**
 * CSPathUtils.ts
 * 
 * Utility class for path operations.
 * Provides cross-platform (Browser/Node.js) path handling capabilities.
 */

import CSLogger from './CSLogger';

/**
 * Path parsing result
 */
export interface ParsedPath {
  /** The root of the path (e.g., '/' on Unix) */
  root: string;
  /** The directory path without the root */
  dir: string;
  /** The file name without the extension */
  name: string;
  /** The file extension (with leading dot) */
  ext: string;
  /** The full base name (name + extension) */
  base: string;
}

/**
 * Path utility class
 */
export class CSPathUtils {
  private static readonly logger = CSLogger.getInstance();
  private static readonly ENVIRONMENT = typeof window !== 'undefined' ? 'browser' : 'node';
  
  // Path separator for current platform
  public static readonly sep = CSPathUtils.isNode() && require('path').sep || '/';
  
  // Path delimiter for environment variables
  public static readonly delimiter = CSPathUtils.isNode() && require('path').delimiter || ':';
  
  /**
   * Path module (Node.js only)
   */
  private static get path(): any {
    if (this.ENVIRONMENT === 'browser') {
      return null;
    }
    
    try {
      return require('path');
    } catch (err) {
      this.logger.error('Path module is not available in this environment', err);
      return null;
    }
  }
  
  /**
   * Checks if running in browser environment
   * 
   * @returns True if running in browser, false otherwise
   */
  public static isNode(): boolean {
    return this.ENVIRONMENT === 'node';
  }
  
  /**
   * Checks if running in browser environment
   * 
   * @returns True if running in browser, false otherwise
   */
  public static isBrowser(): boolean {
    return this.ENVIRONMENT === 'browser';
  }
  
  /**
   * Normalizes a path, resolving '..' and '.' segments
   * 
   * @param path Path to normalize
   * @returns Normalized path
   */
  public static normalize(path: string): string {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.normalize(path);
    }
    
    // Custom implementation for browser
    if (!path) return '.';
    
    // Replace backslashes with forward slashes for consistency
    const isAbsolute = path.startsWith('/');
    path = path.replace(/\\/g, '/');
    
    // Split path into segments
    const segments = path.split('/').filter(Boolean);
    const result: string[] = [];
    
    // Process segments
    for (const segment of segments) {
      if (segment === '.') {
        // Skip '.' segments
        continue;
      } else if (segment === '..') {
        // Handle '..' segments
        if (result.length > 0 && result[result.length - 1] !== '..') {
          result.pop();
        } else if (!isAbsolute) {
          result.push('..');
        }
      } else {
        // Add regular segments
        result.push(segment);
      }
    }
    
    // Join segments
    let normalizedPath = result.join('/');
    
    // Handle special cases
    if (path.startsWith('/')) {
      normalizedPath = '/' + normalizedPath;
    }
    
    return normalizedPath || '.';
  }
  
  /**
   * Joins all arguments together and normalizes the resulting path
   * 
   * @param paths Path segments to join
   * @returns Joined path
   */
  public static join(...paths: string[]): string {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.join(...paths);
    }
    
    // Custom implementation for browser
    if (paths.length === 0) return '.';
    
    // Convert all paths to forward slash format
    const normalizedPaths = paths.map(path => {
      return path.replace(/\\/g, '/');
    });
    
    // Join paths with a slash
    let joinedPath = normalizedPaths.join('/');
    
    // Normalize the path
    return this.normalize(joinedPath);
  }
  
  /**
   * Resolves a sequence of paths or path segments into an absolute path
   * 
   * @param paths Path segments to resolve
   * @returns Resolved absolute path
   */
  public static resolve(...paths: string[]): string {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.resolve(...paths);
    }
    
    // Custom implementation for browser
    if (paths.length === 0) return '.';
    
    let resolvedPath = '';
    let isAbsolute = false;
    
    // Process paths from right to left
    for (let i = paths.length - 1; i >= 0; i--) {
      const path = paths[i];
      
      // Skip empty paths
      if (!path) continue;
      
      // Combine with current result
      resolvedPath = path + (resolvedPath ? '/' + resolvedPath : '');
      
      // Check if path is absolute
      if (path.startsWith('/')) {
        isAbsolute = true;
        break;
      }
    }
    
    // Use current working directory as base if not absolute
    if (!isAbsolute) {
      // In browser, use a simulated working directory
      if (this.isBrowser()) {
        const cwd = '/'; // Simulated root directory
        resolvedPath = cwd + (resolvedPath ? '/' + resolvedPath : '');
      } else {
        // In Node.js, use process.cwd()
        const cwd = process.cwd();
        resolvedPath = cwd + (cwd.endsWith('/') ? '' : '/') + resolvedPath;
      }
    }
    
    // Normalize the result
    return this.normalize(resolvedPath);
  }
  
  /**
   * Returns the directory name of a path
   * 
   * @param path Path to extract directory from
   * @returns Directory name
   */
  public static dirname(path: string): string {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.dirname(path);
    }
    
    // Custom implementation for browser
    if (!path) return '.';
    
    // Normalize path to use forward slashes
    path = path.replace(/\\/g, '/');
    
    // Handle special cases
    if (path === '/') return '/';
    if (path === '.' || path === '..') return '.';
    
    // Find last slash
    const lastSlashIndex = path.lastIndexOf('/');
    
    if (lastSlashIndex === -1) {
      // No slashes found
      return '.';
    }
    
    if (lastSlashIndex === 0) {
      // Root directory
      return '/';
    }
    
    // Return directory part
    return path.substring(0, lastSlashIndex);
  }
  
  /**
   * Returns the last portion of a path
   * 
   * @param path Path to extract file name from
   * @param ext Optional extension to remove
   * @returns Base name
   */
  public static basename(path: string, ext?: string): string {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.basename(path, ext);
    }
    
    // Custom implementation for browser
    if (!path) return '';
    
    // Normalize path to use forward slashes
    path = path.replace(/\\/g, '/');
    
    // Handle trailing slash
    if (path.endsWith('/')) {
      path = path.substring(0, path.length - 1);
    }
    
    // Find last slash
    const lastSlashIndex = path.lastIndexOf('/');
    
    // Extract base name
    const baseName = lastSlashIndex === -1 ? path : path.substring(lastSlashIndex + 1);
    
    // Remove extension if specified
    if (ext && baseName.endsWith(ext)) {
      return baseName.substring(0, baseName.length - ext.length);
    }
    
    return baseName;
  }
  
  /**
   * Returns the extension of a path
   * 
   * @param path Path to extract extension from
   * @returns Extension with leading dot
   */
  public static extname(path: string): string {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.extname(path);
    }
    
    // Custom implementation for browser
    if (!path) return '';
    
    // Find last dot after last slash
    const lastSlashIndex = path.lastIndexOf('/');
    const fileName = lastSlashIndex === -1 ? path : path.substring(lastSlashIndex + 1);
    
    // Skip if filename starts with a dot (hidden file)
    if (fileName.startsWith('.') && fileName.indexOf('.', 1) === -1) {
      return '';
    }
    
    const lastDotIndex = fileName.lastIndexOf('.');
    
    // No dot found or dot is the first character
    if (lastDotIndex <= 0) {
      return '';
    }
    
    // Return extension with dot
    return fileName.substring(lastDotIndex);
  }
  
  /**
   * Returns an object with path components
   * 
   * @param path Path to parse
   * @returns Parsed path components
   */
  public static parse(path: string): ParsedPath {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.parse(path);
    }
    
    // Custom implementation for browser
    if (!path) {
      return {
        root: '',
        dir: '',
        base: '',
        ext: '',
        name: ''
      };
    }
    
    // Normalize path to use forward slashes
    path = path.replace(/\\/g, '/');
    
    // Extract root
    const root = path.startsWith('/') ? '/' : '';
    
    // Extract directory
    const dir = this.dirname(path);
    
    // Extract base name
    const base = this.basename(path);
    
    // Extract extension
    const ext = this.extname(path);
    
    // Extract name without extension
    const name = ext ? base.substring(0, base.length - ext.length) : base;
    
    return {
      root,
      dir,
      base,
      ext,
      name
    };
  }
  
  /**
   * Returns a path string from an object of path components
   * 
   * @param pathObject Object with path components
   * @returns Formatted path string
   */
  public static format(pathObject: Partial<ParsedPath>): string {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.format(pathObject);
    }
    
    // Custom implementation for browser
    if (!pathObject) return '';
    
    // Extract components
    const { root = '', dir = '', base = '', name = '', ext = '' } = pathObject;
    
    // Use base if provided, otherwise combine name and ext
    const file = base || (name + ext);
    
    // Use dir if provided, otherwise use root
    let result = dir || root;
    
    // Add separator if needed
    if (result && !result.endsWith('/')) {
      result += '/';
    }
    
    // Add file
    result += file;
    
    return result;
  }
  
  /**
   * Determines if path is an absolute path
   * 
   * @param path Path to check
   * @returns True if path is absolute, false otherwise
   */
  public static isAbsolute(path: string): boolean {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.isAbsolute(path);
    }
    
    // Custom implementation for browser
    if (!path) return false;
    
    // Check if path starts with a root
    return path.startsWith('/');
  }
  
  /**
   * Solves the relative path from 'from' to 'to'
   * 
   * @param from Source path
   * @param to Destination path
   * @returns Relative path
   */
  public static relative(from: string, to: string): string {
    if (this.isNode() && this.path) {
      // Use native path module in Node.js
      return this.path.relative(from, to);
    }
    
    // Custom implementation for browser
    if (from === to) return '';
    
    // Normalize paths
    from = this.normalize(from);
    to = this.normalize(to);
    
    // Split paths into segments
    const fromSegments = from.split('/').filter(Boolean);
    const toSegments = to.split('/').filter(Boolean);
    
    // Find common prefix
    let commonLength = 0;
    const minLength = Math.min(fromSegments.length, toSegments.length);
    
    while (commonLength < minLength && fromSegments[commonLength] === toSegments[commonLength]) {
      commonLength++;
    }
    
    // Build relative path
    const relSegments = [];
    
    // Add '..' for each segment in 'from' after the common prefix
    for (let i = 0; i < fromSegments.length - commonLength; i++) {
      relSegments.push('..');
    }
    
    // Add segments from 'to' after the common prefix
    for (let i = commonLength; i < toSegments.length; i++) {
      relSegments.push(toSegments[i]);
    }
    
    // Join segments
    return relSegments.join('/') || '.';
  }
  
  /**
   * Creates a directory recursively
   * 
   * @param path Directory path to create
   * @param mode Access mode (Node.js only)
   * @returns True if directory was created, false if it already existed
   */
  public static async makeDirectory(path: string, mode?: number): Promise<boolean> {
    try {
      if (this.isNode() && this.path) {
        const fs = require('fs');
        
        // Check if directory exists
        if (fs.existsSync(path)) {
          // Check if it's a directory
          const stats = fs.statSync(path);
          if (stats.isDirectory()) {
            return false; // Directory already exists
          } else {
            throw new Error(`Path exists but is not a directory: ${path}`);
          }
        }
        
        // Create directory
        fs.mkdirSync(path, { recursive: true, mode });
        return true;
      } else {
        // Use browser's window.fs if available
        if (typeof window !== 'undefined' && window.fs) {
          try {
            await window.fs.mkdir(path, { recursive: true });
            return true;
          } catch (err) {
            // If error is EEXIST, directory already exists
            if (err.code === 'EEXIST') {
              return false;
            }
            throw err;
          }
        }
        
        // If no file system API available, use localStorage for simulation
        if (typeof localStorage !== 'undefined') {
          // Check if directory exists
          const dirExists = localStorage.getItem(`CSFileUtils_${path}_isDir`) === 'true';
          
          if (dirExists) {
            return false; // Directory already exists
          }
          
          // Create directory by setting a flag in localStorage
          localStorage.setItem(`CSFileUtils_${path}_isDir`, 'true');
          
          // Create parent directories recursively
          if (path.includes('/')) {
            const parentPath = path.substring(0, path.lastIndexOf('/'));
            if (parentPath) {
              await this.makeDirectory(parentPath);
            }
          }
          
          return true;
        }
        
        // No file system API or localStorage available
        throw new Error('File system API is not available in this environment');
      }
    } catch (err) {
      this.logger.error(`Error creating directory: ${path}`, err);
      throw err;
    }
  }
  
  /**
   * Returns the current working directory
   * 
   * @returns Current working directory
   */
  public static getCurrentDirectory(): string {
    if (this.isNode()) {
      return process.cwd();
    }
    
    // In browser, return a simulated working directory
    return '/';
  }
  
  /**
   * Returns the home directory of the current user
   * 
   * @returns Home directory
   */
  public static getHomeDirectory(): string {
    if (this.isNode()) {
      return process.env.HOME || process.env.USERPROFILE || '/';
    }
    
    // In browser, return a simulated home directory
    return '/home/user';
  }
  
  /**
   * Returns the temporary directory
   * 
   * @returns Temporary directory
   */
  public static getTempDirectory(): string {
    if (this.isNode()) {
      return process.env.TEMP || process.env.TMP || '/tmp';
    }
    
    // In browser, return a simulated temp directory
    return '/tmp';
  }
  
  /**
   * Normalizes a file path to use the correct path separator for the current platform
   * 
   * @param path Path to normalize
   * @returns Normalized path with correct separators
   */
  public static normalizeSeparators(path: string): string {
    if (!path) return '';
    
    // In Node.js, use the platform-specific separator
    if (this.isNode() && this.path) {
      // Replace all forward slashes with platform-specific separator
      return path.replace(/\//g, this.path.sep);
    }
    
    // In browser, always use forward slashes
    return path.replace(/\\/g, '/');
  }
  
  /**
   * Creates a safe file name by removing invalid characters
   * 
   * @param fileName File name to make safe
   * @returns Safe file name
   */
  public static safeFileName(fileName: string): string {
    if (!fileName) return '';
    
    // Remove invalid file name characters
    return fileName.replace(/[<>:"/\\|?*\x00-\x1F]/g, '_');
  }
  
  /**
   * Gets the relative path from the current working directory
   * 
   * @param path Absolute path
   * @returns Relative path from current directory
   */
  public static getRelativeFromCwd(path: string): string {
    return this.relative(this.getCurrentDirectory(), path);
  }
  
  /**
   * Gets the absolute path by resolving from the current working directory
   * 
   * @param path Relative or absolute path
   * @returns Absolute path
   */
  public static getAbsoluteFromCwd(path: string): string {
    if (this.isAbsolute(path)) {
      return path;
    }
    
    return this.join(this.getCurrentDirectory(), path);
  }
  
  /**
   * Creates a path with file name and extension
   * 
   * @param dir Directory path
   * @param name File name
   * @param ext File extension (with or without leading dot)
   * @returns Complete file path
   */
  public static createFilePath(dir: string, name: string, ext: string): string {
    // Ensure extension has a leading dot
    if (ext && !ext.startsWith('.')) {
      ext = '.' + ext;
    }
    
    return this.join(dir, name + ext);
  }
  
  /**
   * Ensures a directory exists, creating it if necessary
   * 
   * @param dir Directory path
   * @returns Promise resolving when directory exists
   */
  public static async ensureDirectoryExists(dir: string): Promise<void> {
    await this.makeDirectory(dir);
  }
  
  /**
   * Checks if a path is a child of a parent directory
   * 
   * @param parent Parent directory path
   * @param child Child path
   * @returns True if child is inside parent, false otherwise
   */
  public static isChildOf(parent: string, child: string): boolean {
    // Normalize paths
    parent = this.normalize(parent);
    child = this.normalize(child);
    
    // Ensure paths end with a separator
    if (!parent.endsWith('/')) parent += '/';
    
    // Check if child starts with parent
    return child.startsWith(parent);
  }
  
  /**
   * Gets the common base directory of multiple paths
   * 
   * @param paths Array of paths
   * @returns Common base directory
   */
  public static getCommonDirectory(paths: string[]): string {
    if (!paths || paths.length === 0) return '';
    if (paths.length === 1) return this.dirname(paths[0]);
    
    // Normalize all paths and split into segments
    const normalizedPaths = paths.map(p => this.normalize(p));
    const segments = normalizedPaths.map(p => p.split('/'));
    
    // Find common prefix
    const commonSegments: string[] = [];
    const firstPathSegments = segments[0];
    
    for (let i = 0; i < firstPathSegments.length; i++) {
      const segment = firstPathSegments[i];
      let isCommon = true;
      
      // Check if segment is common across all paths
      for (let j = 1; j < segments.length; j++) {
        if (i >= segments[j].length || segments[j][i] !== segment) {
          isCommon = false;
          break;
        }
      }
      
      if (isCommon) {
        commonSegments.push(segment);
      } else {
        break;
      }
    }
    
    // Join common segments
    return commonSegments.join('/');
  }
  
  /**
   * Generates a unique file name in a directory
   * 
   * @param dir Directory path
   * @param baseName Base file name
   * @param ext File extension
   * @returns Unique file path
   */
  public static getUniqueFilePath(dir: string, baseName: string, ext: string): string {
    // Ensure extension has a leading dot
    if (ext && !ext.startsWith('.')) {
      ext = '.' + ext;
    }
    
    // Make base name safe
    baseName = this.safeFileName(baseName);
    
    // Generate a timestamp to ensure uniqueness
    const timestamp = new Date().getTime();
    const uniqueName = `${baseName}_${timestamp}${ext}`;
    
    return this.join(dir, uniqueName);
  }
  
  /**
   * Gets the depth of a path (number of segments)
   * 
   * @param path Path to analyze
   * @returns Number of path segments
   */
  public static getPathDepth(path: string): number {
    if (!path) return 0;
    
    // Normalize path
    path = this.normalize(path);
    
    // Split into segments and filter out empty segments
    const segments = path.split('/').filter(Boolean);
    
    return segments.length;
  }
  
  /**
   * Gets the size of a path in human-readable format
   * 
   * @param sizeInBytes Size in bytes
   * @param decimals Number of decimal places (default: 2)
   * @returns Human-readable size string
   */
  public static formatSize(sizeInBytes: number, decimals: number = 2): string {
    if (sizeInBytes === 0) return '0 Bytes';
    
    const units = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const base = 1024;
    const unitIndex = Math.floor(Math.log(sizeInBytes) / Math.log(base));
    
    return parseFloat((sizeInBytes / Math.pow(base, unitIndex)).toFixed(decimals)) + ' ' + units[unitIndex];
  }
}

export default CSPathUtils;


/**
 * CSTextUtils.ts
 * 
 * Utility class for text manipulation operations.
 * Provides advanced string handling functions for use across the framework.
 */

import CSLogger from './CSLogger';

/**
 * Case conversion types
 */
export enum TextCase {
  UPPER = 'upper',
  LOWER = 'lower',
  TITLE = 'title',
  CAMEL = 'camel',
  PASCAL = 'pascal',
  SNAKE = 'snake',
  KEBAB = 'kebab',
  CONSTANT = 'constant'
}

/**
 * Options for string truncation
 */
export interface TruncateOptions {
  /** Maximum length of the string */
  length: number;
  /** Suffix to append if truncated (default: '...') */
  suffix?: string;
  /** Whether to truncate at word boundaries (default: false) */
  wordBoundary?: boolean;
  /** Word separator used if truncating at word boundaries (default: ' ') */
  wordSeparator?: string;
}

/**
 * String interpolation parameters
 */
export type StringInterpolationParams = Record<string, string | number | boolean | null | undefined>;

/**
 * Text manipulation utility class
 */
export class CSTextUtils {
  private static readonly logger = CSLogger.getInstance();
  
  /**
   * Checks if a string is null, undefined, or empty
   * 
   * @param str String to check
   * @returns True if the string is null, undefined, or empty
   */
  public static isEmpty(str: string | null | undefined): boolean {
    return str === null || str === undefined || str.trim() === '';
  }
  
  /**
   * Checks if a string is not null, undefined, or empty
   * 
   * @param str String to check
   * @returns True if the string is not null, undefined, or empty
   */
  public static isNotEmpty(str: string | null | undefined): boolean {
    return !this.isEmpty(str);
  }
  
  /**
   * Truncates a string to a specified length
   * 
   * @param str String to truncate
   * @param options Truncation options
   * @returns Truncated string
   */
  public static truncate(str: string, options: TruncateOptions): string {
    if (!str) return '';
    
    const {
      length,
      suffix = '...',
      wordBoundary = false,
      wordSeparator = ' '
    } = options;
    
    // If string is shorter than max length, return as is
    if (str.length <= length) {
      return str;
    }
    
    // Calculate actual truncation length accounting for suffix
    const truncateLength = length - suffix.length;
    
    if (truncateLength <= 0) {
      // If suffix is longer than truncate length, just return the suffix
      return suffix;
    }
    
    if (!wordBoundary) {
      // Simple truncation at character boundary
      return str.substring(0, truncateLength) + suffix;
    }
    
    // Truncate at word boundary
    let truncated = str.substring(0, truncateLength);
    
    // Find last word separator
    const lastSeparatorIndex = truncated.lastIndexOf(wordSeparator);
    
    if (lastSeparatorIndex !== -1) {
      // Truncate at word boundary
      truncated = truncated.substring(0, lastSeparatorIndex);
    }
    
    return truncated + suffix;
  }
  
  /**
   * Pads a string to a specified length
   * 
   * @param str String to pad
   * @param length Target length
   * @param padChar Character to use for padding (default: ' ')
   * @param padEnd Whether to pad at the end (default: true)
   * @returns Padded string
   */
  public static pad(str: string, length: number, padChar: string = ' ', padEnd: boolean = true): string {
    if (!str) return ''.padEnd(length, padChar);
    
    if (str.length >= length) {
      return str;
    }
    
    const padCount = length - str.length;
    const padding = padChar.repeat(padCount);
    
    return padEnd ? str + padding : padding + str;
  }
  
  /**
   * Converts a string to a specified case
   * 
   * @param str String to convert
   * @param caseType Target case type
   * @returns Converted string
   */
  public static toCase(str: string, caseType: TextCase): string {
    if (!str) return '';
    
    // Split string into words
    const words = this.splitIntoWords(str);
    
    switch (caseType) {
      case TextCase.UPPER:
        return str.toUpperCase();
        
      case TextCase.LOWER:
        return str.toLowerCase();
        
      case TextCase.TITLE:
        return words.map(word => 
          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        ).join(' ');
        
      case TextCase.CAMEL:
        return words.map((word, index) => 
          index === 0 
            ? word.toLowerCase() 
            : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        ).join('');
        
      case TextCase.PASCAL:
        return words.map(word => 
          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        ).join('');
        
      case TextCase.SNAKE:
        return words.map(word => word.toLowerCase()).join('_');
        
      case TextCase.KEBAB:
        return words.map(word => word.toLowerCase()).join('-');
        
      case TextCase.CONSTANT:
        return words.map(word => word.toUpperCase()).join('_');
        
      default:
        return str;
    }
  }
  
  /**
   * Splits a string into words
   * 
   * @param str String to split
   * @returns Array of words
   */
  private static splitIntoWords(str: string): string[] {
    if (!str) return [];
    
    // Handle camelCase and PascalCase
    str = str.replace(/([a-z])([A-Z])/g, '$1 $2');
    
    // Handle snake_case and CONSTANT_CASE
    str = str.replace(/_+/g, ' ');
    
    // Handle kebab-case
    str = str.replace(/-+/g, ' ');
    
    // Split by whitespace and filter out empty strings
    return str.split(/\s+/).filter(Boolean);
  }
  
  /**
   * Capitalizes the first letter of a string
   * 
   * @param str String to capitalize
   * @returns Capitalized string
   */
  public static capitalize(str: string): string {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  
  /**
   * Uncapitalizes the first letter of a string
   * 
   * @param str String to uncapitalize
   * @returns Uncapitalized string
   */
  public static uncapitalize(str: string): string {
    if (!str) return '';
    return str.charAt(0).toLowerCase() + str.slice(1);
  }
  
  /**
   * Reverses a string
   * 
   * @param str String to reverse
   * @returns Reversed string
   */
  public static reverse(str: string): string {
    if (!str) return '';
    return [...str].reverse().join('');
  }
  
  /**
   * Counts occurrences of a substring in a string
   * 
   * @param str String to search in
   * @param substring Substring to count
   * @param caseSensitive Whether the search is case-sensitive (default: true)
   * @returns Number of occurrences
   */
  public static countOccurrences(str: string, substring: string, caseSensitive: boolean = true): number {
    if (!str || !substring) return 0;
    
    if (!caseSensitive) {
      str = str.toLowerCase();
      substring = substring.toLowerCase();
    }
    
    // Split by substring and count
    return str.split(substring).length - 1;
  }
  
  /**
   * Checks if a string contains a substring
   * 
   * @param str String to search in
   * @param substring Substring to search for
   * @param caseSensitive Whether the search is case-sensitive (default: true)
   * @returns True if the string contains the substring
   */
  public static contains(str: string, substring: string, caseSensitive: boolean = true): boolean {
    if (!str || !substring) return false;
    
    if (!caseSensitive) {
      str = str.toLowerCase();
      substring = substring.toLowerCase();
    }
    
    return str.includes(substring);
  }
  
  /**
   * Checks if a string starts with a prefix
   * 
   * @param str String to check
   * @param prefix Prefix to check for
   * @param caseSensitive Whether the check is case-sensitive (default: true)
   * @returns True if the string starts with the prefix
   */
  public static startsWith(str: string, prefix: string, caseSensitive: boolean = true): boolean {
    if (!str || !prefix) return false;
    
    if (!caseSensitive) {
      str = str.toLowerCase();
      prefix = prefix.toLowerCase();
    }
    
    return str.startsWith(prefix);
  }
  
  /**
   * Checks if a string ends with a suffix
   * 
   * @param str String to check
   * @param suffix Suffix to check for
   * @param caseSensitive Whether the check is case-sensitive (default: true)
   * @returns True if the string ends with the suffix
   */
  public static endsWith(str: string, suffix: string, caseSensitive: boolean = true): boolean {
    if (!str || !suffix) return false;
    
    if (!caseSensitive) {
      str = str.toLowerCase();
      suffix = suffix.toLowerCase();
    }
    
    return str.endsWith(suffix);
  }
  
  /**
   * Removes a prefix from a string if present
   * 
   * @param str String to process
   * @param prefix Prefix to remove
   * @param caseSensitive Whether the check is case-sensitive (default: true)
   * @returns String without the prefix
   */
  public static removePrefix(str: string, prefix: string, caseSensitive: boolean = true): string {
    if (!str || !prefix) return str || '';
    
    if (this.startsWith(str, prefix, caseSensitive)) {
      return str.substring(prefix.length);
    }
    
    return str;
  }
  
  /**
   * Removes a suffix from a string if present
   * 
   * @param str String to process
   * @param suffix Suffix to remove
   * @param caseSensitive Whether the check is case-sensitive (default: true)
   * @returns String without the suffix
   */
  public static removeSuffix(str: string, suffix: string, caseSensitive: boolean = true): string {
    if (!str || !suffix) return str || '';
    
    if (this.endsWith(str, suffix, caseSensitive)) {
      return str.substring(0, str.length - suffix.length);
    }
    
    return str;
  }
  
  /**
   * Removes all whitespace from a string
   * 
   * @param str String to process
   * @returns String without whitespace
   */
  public static removeWhitespace(str: string): string {
    if (!str) return '';
    return str.replace(/\s+/g, '');
  }
  
  /**
   * Normalizes whitespace in a string (replaces multiple whitespace with a single space)
   * 
   * @param str String to process
   * @returns String with normalized whitespace
   */
  public static normalizeWhitespace(str: string): string {
    if (!str) return '';
    return str.replace(/\s+/g, ' ').trim();
  }
  
  /**
   * Converts a string to a URL-friendly slug
   * 
   * @param str String to convert
   * @returns URL-friendly slug
   */
  public static slugify(str: string): string {
    if (!str) return '';
    
    // Convert to lowercase and remove accents
    str = str.toLowerCase();
    str = this.removeAccents(str);
    
    // Replace non-alphanumeric characters with dashes
    str = str.replace(/[^a-z0-9]+/g, '-');
    
    // Remove leading and trailing dashes
    str = str.replace(/^-+|-+$/g, '');
    
    return str;
  }
  
  /**
   * Removes accents from a string
   * 
   * @param str String to process
   * @returns String without accents
   */
  public static removeAccents(str: string): string {
    if (!str) return '';
    
    // Use Unicode normalization to decompose accented characters
    return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }
  
  /**
   * Interpolates values into a string with placeholders
   * 
   * @param template String template with placeholders
   * @param params Parameters to interpolate
   * @param fallback Fallback value for missing parameters (default: '')
   * @returns Interpolated string
   */
  public static interpolate(
    template: string,
    params: StringInterpolationParams,
    fallback: string = ''
  ): string {
    if (!template) return '';
    if (!params) return template;
    
    // Replace placeholders with values
    return template.replace(/\${(\w+)}/g, (match, key) => {
      const value = params[key];
      
      if (value === null || value === undefined) {
        return fallback;
      }
      
      return String(value);
    });
  }
  
  /**
   * Truncates a string in the middle
   * 
   * @param str String to truncate
   * @param maxLength Maximum length including separator
   * @param separator Separator to use (default: '...')
   * @returns Truncated string
   */
  public static truncateMiddle(str: string, maxLength: number, separator: string = '...'): string {
    if (!str) return '';
    
    if (str.length <= maxLength) {
      return str;
    }
    
    const sepLength = separator.length;
    
    // Calculate the length of the parts to keep
    const partLength = Math.floor((maxLength - sepLength) / 2);
    const endPos = str.length - partLength;
    
    // Truncate the string
    return str.substring(0, partLength) + separator + str.substring(endPos);
  }
  
  /**
   * Escapes HTML special characters in a string
   * 
   * @param str String to escape
   * @returns Escaped string
   */
  public static escapeHtml(str: string): string {
    if (!str) return '';
    
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
  
  /**
   * Unescapes HTML special characters in a string
   * 
   * @param str String to unescape
   * @returns Unescaped string
   */
  public static unescapeHtml(str: string): string {
    if (!str) return '';
    
    return str
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#039;/g, "'");
  }
  
  /**
   * Checks if a string matches a regular expression
   * 
   * @param str String to check
   * @param pattern Regular expression pattern
   * @param flags Regular expression flags
   * @returns True if the string matches the pattern
   */
  public static matches(str: string, pattern: string | RegExp, flags?: string): boolean {
    if (!str) return false;
    
    const regex = typeof pattern === 'string'
      ? new RegExp(pattern, flags)
      : pattern;
    
    return regex.test(str);
  }
  
  /**
   * Extracts substrings matching a regular expression
   * 
   * @param str String to search in
   * @param pattern Regular expression pattern
   * @param flags Regular expression flags
   * @param group Capture group to extract (default: 0)
   * @returns Array of matching substrings
   */
  public static extract(str: string, pattern: string | RegExp, flags?: string, group: number = 0): string[] {
    if (!str) return [];
    
    const regex = typeof pattern === 'string'
      ? new RegExp(pattern, flags?.includes('g') ? flags : (flags || '') + 'g')
      : pattern;
    
    const matches: string[] = [];
    let match: RegExpExecArray | null;
    
    while ((match = regex.exec(str)) !== null) {
      if (match[group] !== undefined) {
        matches.push(match[group]);
      }
    }
    
    return matches;
  }
  
  /**
   * Masks a portion of a string with a specified character
   * 
   * @param str String to mask
   * @param start Start index (inclusive)
   * @param end End index (exclusive)
   * @param maskChar Character to use for masking (default: '*')
   * @returns Masked string
   */
  public static mask(str: string, start: number, end: number, maskChar: string = '*'): string {
    if (!str) return '';
    
    // Validate indices
    start = Math.max(0, start);
    end = Math.min(str.length, end);
    
    if (start >= end || start >= str.length) {
      return str;
    }
    
    // Create mask
    const maskLength = end - start;
    const mask = maskChar.repeat(maskLength);
    
    // Replace substring with mask
    return str.substring(0, start) + mask + str.substring(end);
  }
  
  /**
   * Checks if a string is a valid email address
   * 
   * @param str String to check
   * @returns True if the string is a valid email address
   */
  public static isEmail(str: string): boolean {
    if (!str) return false;
    
    // Simple email validation
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    return emailRegex.test(str);
  }
  
  /**
   * Checks if a string is a valid URL
   * 
   * @param str String to check
   * @returns True if the string is a valid URL
   */
  public static isUrl(str: string): boolean {
    if (!str) return false;
    
    try {
      // Use URL constructor for validation
      new URL(str);
      return true;
    } catch (err) {
      return false;
    }
  }
  
  /**
   * Checks if a string is a valid numeric value
   * 
   * @param str String to check
   * @returns True if the string is a valid numeric value
   */
  public static isNumeric(str: string): boolean {
    if (!str) return false;
    
    return /^-?\d+(\.\d+)?$/.test(str);
  }
  
  /**
   * Checks if a string is a valid integer
   * 
   * @param str String to check
   * @returns True if the string is a valid integer
   */
  public static isInteger(str: string): boolean {
    if (!str) return false;
    
    return /^-?\d+$/.test(str);
  }
  
  /**
   * Checks if a string is a valid hexadecimal value
   * 
   * @param str String to check
   * @returns True if the string is a valid hexadecimal value
   */
  public static isHex(str: string): boolean {
    if (!str) return false;
    
    return /^[0-9A-Fa-f]+$/.test(str);
  }
  
  /**
   * Checks if a string is a valid JSON
   * 
   * @param str String to check
   * @returns True if the string is a valid JSON
   */
  public static isJson(str: string): boolean {
    if (!str) return false;
    
    try {
      JSON.parse(str);
      return true;
    } catch (err) {
      return false;
    }
  }
  
  /**
   * Truncates a string to a specified number of characters
   * 
   * @param str String to truncate
   * @param maxLength Maximum length
   * @param suffix Suffix to append if truncated (default: '...')
   * @returns Truncated string
   */
  public static truncateToCharCount(str: string, maxLength: number, suffix: string = '...'): string {
    return this.truncate(str, { length: maxLength, suffix });
  }
  
  /**
   * Truncates a string to a specified number of words
   * 
   * @param str String to truncate
   * @param maxWords Maximum number of words
   * @param suffix Suffix to append if truncated (default: '...')
   * @returns Truncated string
   */
  public static truncateToWordCount(str: string, maxWords: number, suffix: string = '...'): string {
    if (!str) return '';
    
    const words = str.split(/\s+/);
    
    if (words.length <= maxWords) {
      return str;
    }
    
    return words.slice(0, maxWords).join(' ') + suffix;
  }
  
  /**
   * Wraps text at a specified line length
   * 
   * @param str String to wrap
   * @param lineLength Maximum line length
   * @param breakChar Character to use for line breaks (default: '\n')
   * @returns Wrapped text
   */
  public static wrapText(str: string, lineLength: number, breakChar: string = '\n'): string {
    if (!str) return '';
    
    const lines: string[] = [];
    let line = '';
    
    // Split by words
    const words = str.split(/\s+/);
    
    for (const word of words) {
      // If adding this word would exceed line length
      if (line.length + word.length + 1 > lineLength && line.length > 0) {
        lines.push(line);
        line = word;
      } else {
        // Add word to current line
        line = line.length === 0 ? word : line + ' ' + word;
      }
    }
    
    // Add the last line
    if (line.length > 0) {
      lines.push(line);
    }
    
    return lines.join(breakChar);
  }
  
  /**
   * Formats a string with placeholders
   * 
   * @param format Format string with placeholders
   * @param args Values to replace placeholders
   * @returns Formatted string
   */
  public static format(format: string, ...args: any[]): string {
    if (!format) return '';
    
    // Replace placeholders with values
    return format.replace(/{(\d+)}/g, (match, index) => {
      const argIndex = parseInt(index, 10);
      return argIndex < args.length ? String(args[argIndex]) : match;
    });
  }
  
  /**
   * Generates a random string
   * 
   * @param length Length of the string (default: 10)
   * @param charset Character set to use (default: alphanumeric)
   * @returns Random string
   */
  public static randomString(length: number = 10, charset?: string): string {
    const chars = charset || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    
    // Generate random characters
    for (let i = 0; i < length; i++) {
      const randomIndex = Math.floor(Math.random() * chars.length);
      result += chars.charAt(randomIndex);
    }
    
    return result;
  }
  
  /**
   * Compares two strings lexicographically
   * 
   * @param str1 First string
   * @param str2 Second string
   * @param caseSensitive Whether the comparison is case-sensitive (default: true)
   * @returns Negative if str1 < str2, positive if str1 > str2, 0 if equal
   */
  public static compare(str1: string, str2: string, caseSensitive: boolean = true): number {
    if (str1 === str2) return 0;
    if (!str1) return -1;
    if (!str2) return 1;
    
    if (!caseSensitive) {
      str1 = str1.toLowerCase();
      str2 = str2.toLowerCase();
    }
    
    return str1 < str2 ? -1 : 1;
  }
  
  /**
   * Splits a string into chunks of a specified length
   * 
   * @param str String to split
   * @param chunkSize Size of each chunk
   * @returns Array of chunks
   */
  public static splitIntoChunks(str: string, chunkSize: number): string[] {
    if (!str) return [];
    if (chunkSize <= 0) return [str];
    
    const chunks: string[] = [];
    
    for (let i = 0; i < str.length; i += chunkSize) {
      chunks.push(str.substring(i, i + chunkSize));
    }
    
    return chunks;
  }
  
  /**
   * Converts the first character of a string to uppercase and the rest to lowercase
   * 
   * @param str String to convert
   * @returns Converted string
   */
  public static capitalizeFirst(str: string): string {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  }
  
  /**
   * Converts a byte size to a human-readable string
   * 
   * @param bytes Number of bytes
   * @param decimals Number of decimal places (default: 2)
   * @returns Human-readable size string
   */
  public static formatByteSize(bytes: number, decimals: number = 2): string {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
  }
  
  /**
   * Calculates the Levenshtein distance between two strings
   * 
   * @param str1 First string
   * @param str2 Second string
   * @returns Levenshtein distance
   */
  public static levenshteinDistance(str1: string, str2: string): number {
    if (str1 === str2) return 0;
    if (!str1) return str2.length;
    if (!str2) return str1.length;
    
    const matrix: number[][] = [];
    
    // Initialize matrix
    for (let i = 0; i <= str1.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str2.length; j++) {
      matrix[0][j] = j;
    }
    
    // Fill matrix
    for (let i = 1; i <= str1.length; i++) {
      for (let j = 1; j <= str2.length; j++) {
        const cost = str1.charAt(i - 1) === str2.charAt(j - 1) ? 0 : 1;
        
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1, // Deletion
          matrix[i][j - 1] + 1, // Insertion
          matrix[i - 1][j - 1] + cost // Substitution
        );
      }
    }
    
    return matrix[str1.length][str2.length];
  }
  
  /**
   * Calculates the similarity between two strings (0-1)
   * 
   * @param str1 First string
   * @param str2 Second string
   * @returns Similarity (0 = completely different, 1 = identical)
   */
  public static similarity(str1: string, str2: string): number {
    if (str1 === str2) return 1;
    if (!str1 || !str2) return 0;
    
    const distance = this.levenshteinDistance(str1, str2);
    const maxLength = Math.max(str1.length, str2.length);
    
    return 1 - distance / maxLength;
  }
  
  /**
   * Converts a string to Base64
   * 
   * @param str String to convert
   * @returns Base64-encoded string
   */
  public static toBase64(str: string): string {
    if (!str) return '';
    
    if (typeof btoa === 'function') {
      // Browser environment
      return btoa(str);
    } else if (typeof Buffer !== 'undefined') {
      // Node.js environment
      return Buffer.from(str).toString('base64');
    } else {
      // Fallback implementation
      const base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      let result = '';
      let i = 0;
      
      do {
        const a = str.charCodeAt(i++);
        const b = i < str.length ? str.charCodeAt(i++) : 0;
        const c = i < str.length ? str.charCodeAt(i++) : 0;
        
        const byte1 = a >> 2;
        const byte2 = ((a & 3) << 4) | (b >> 4);
        const byte3 = ((b & 15) << 2) | (c >> 6);
        const byte4 = c & 63;
        
        result += base64chars.charAt(byte1) + base64chars.charAt(byte2) +
                 (isNaN(b) ? '=' : base64chars.charAt(byte3)) +
                 (isNaN(c) ? '=' : base64chars.charAt(byte4));
      } while (i < str.length);
      
      return result;
    }
  }
  
  /**
   * Converts a Base64 string to plain text
   * 
   * @param base64 Base64-encoded string
   * @returns Decoded string
   */
  public static fromBase64(base64: string): string {
    if (!base64) return '';
    
    if (typeof atob === 'function') {
      // Browser environment
      return atob(base64);
    } else if (typeof Buffer !== 'undefined') {
      // Node.js environment
      return Buffer.from(base64, 'base64').toString();
    } else {
      // Fallback implementation not provided for brevity
      // A proper implementation would be complex and requires handling all edge cases
      throw new Error('Base64 decoding is not supported in this environment');
    }
  }
}

export default CSTextUtils;


/**
 * CSEncryptionUtils.ts
 * 
 * Utility class for encryption and hashing operations.
 * Provides cross-platform (Browser/Node.js) cryptographic capabilities.
 */

import CSLogger from './CSLogger';

/**
 * Hashing algorithm types
 */
export enum HashAlgorithm {
  MD5 = 'md5',
  SHA1 = 'sha1',
  SHA256 = 'sha256',
  SHA384 = 'sha384',
  SHA512 = 'sha512'
}

/**
 * Encryption algorithm types
 */
export enum EncryptionAlgorithm {
  AES = 'aes',
  AES_CBC = 'aes-cbc',
  AES_GCM = 'aes-gcm'
}

/**
 * Encoding types for output
 */
export enum Encoding {
  HEX = 'hex',
  BASE64 = 'base64',
  UTF8 = 'utf8'
}

/**
 * Options for encryption
 */
export interface EncryptionOptions {
  /** Encryption algorithm */
  algorithm: EncryptionAlgorithm;
  /** Key to use for encryption */
  key: string;
  /** Initialization vector (needed for some algorithms) */
  iv?: string;
  /** Encoding for the output */
  outputEncoding?: Encoding;
  /** Encoding for the input */
  inputEncoding?: Encoding;
}

/**
 * Options for decryption
 */
export interface DecryptionOptions {
  /** Encryption algorithm */
  algorithm: EncryptionAlgorithm;
  /** Key to use for decryption */
  key: string;
  /** Initialization vector (needed for some algorithms) */
  iv?: string;
  /** Encoding for the input */
  inputEncoding?: Encoding;
  /** Encoding for the output */
  outputEncoding?: Encoding;
}

/**
 * Options for hashing
 */
export interface HashOptions {
  /** Hash algorithm */
  algorithm: HashAlgorithm;
  /** Encoding for the output */
  encoding?: Encoding;
  /** Salt to use for the hash */
  salt?: string;
  /** Number of iterations for the hash */
  iterations?: number;
}

/**
 * Key derivation options
 */
export interface KeyDerivationOptions {
  /** Password to derive key from */
  password: string;
  /** Salt to use for key derivation */
  salt: string;
  /** Number of iterations for key derivation */
  iterations?: number;
  /** Key length in bytes */
  keyLength?: number;
  /** Digest algorithm to use */
  digest?: HashAlgorithm;
}

/**
 * Encryption utility class
 */
export class CSEncryptionUtils {
  private static readonly logger = CSLogger.getInstance();
  private static readonly ENVIRONMENT = typeof window !== 'undefined' ? 'browser' : 'node';
  
  /**
   * Crypto module (Node.js only)
   */
  private static get crypto(): any {
    if (this.ENVIRONMENT === 'browser') {
      return null;
    }
    
    try {
      return require('crypto');
    } catch (err) {
      this.logger.error('Crypto module is not available in this environment', err);
      return null;
    }
  }
  
  /**
   * SubtleCrypto interface (Browser only)
   */
  private static get subtle(): SubtleCrypto | null {
    if (this.ENVIRONMENT !== 'browser') {
      return null;
    }
    
    if (window.crypto && window.crypto.subtle) {
      return window.crypto.subtle;
    }
    
    this.logger.error('SubtleCrypto API is not available in this browser');
    return null;
  }
  
  /**
   * Checks if running in browser environment
   * 
   * @returns True if running in browser, false otherwise
   */
  public static isBrowser(): boolean {
    return this.ENVIRONMENT === 'browser';
  }
  
  /**
   * Checks if running in Node.js environment
   * 
   * @returns True if running in Node.js, false otherwise
   */
  public static isNode(): boolean {
    return this.ENVIRONMENT === 'node';
  }
  
  /**
   * Checks if encryption is supported in the current environment
   * 
   * @returns True if encryption is supported, false otherwise
   */
  public static isEncryptionSupported(): boolean {
    return (this.isNode() && !!this.crypto) || (this.isBrowser() && !!this.subtle);
  }
  
  /**
   * Generates a cryptographically secure random string
   * 
   * @param length Length of the string (default: 16)
   * @param encoding Encoding of the output (default: Encoding.HEX)
   * @returns Random string
   */
  public static generateRandomString(length: number = 16, encoding: Encoding = Encoding.HEX): string {
    try {
      let randomBytes: Uint8Array;
      
      if (this.isNode() && this.crypto) {
        // Use Node.js crypto module
        randomBytes = this.crypto.randomBytes(length);
      } else if (this.isBrowser() && window.crypto) {
        // Use browser's crypto API
        randomBytes = new Uint8Array(length);
        window.crypto.getRandomValues(randomBytes);
      } else {
        throw new Error('Cryptographic API is not available in this environment');
      }
      
      // Convert to requested encoding
      switch (encoding) {
        case Encoding.HEX:
          return this.bufferToHex(randomBytes);
        case Encoding.BASE64:
          return this.bufferToBase64(randomBytes);
        case Encoding.UTF8:
          return this.bufferToUtf8(randomBytes);
        default:
          return this.bufferToHex(randomBytes);
      }
    } catch (err) {
      this.logger.error('Error generating random string', err);
      throw err;
    }
  }
  
  /**
   * Generates a secure random initialization vector
   * 
   * @param length Length of the IV in bytes (default: 16)
   * @param encoding Encoding of the output (default: Encoding.HEX)
   * @returns Initialization vector
   */
  public static generateIV(length: number = 16, encoding: Encoding = Encoding.HEX): string {
    return this.generateRandomString(length, encoding);
  }
  
  /**
   * Generates a secure random salt
   * 
   * @param length Length of the salt in bytes (default: 16)
   * @param encoding Encoding of the output (default: Encoding.HEX)
   * @returns Salt
   */
  public static generateSalt(length: number = 16, encoding: Encoding = Encoding.HEX): string {
    return this.generateRandomString(length, encoding);
  }
  
  /**
   * Encrypts data using the specified algorithm and key
   * 
   * @param data Data to encrypt
   * @param options Encryption options
   * @returns Encrypted data
   */
  public static async encrypt(data: string, options: EncryptionOptions): Promise<string> {
    try {
      const { 
        algorithm, 
        key, 
        iv = this.generateIV(), 
        outputEncoding = Encoding.BASE64,
        inputEncoding = Encoding.UTF8
      } = options;
      
      if (this.isNode() && this.crypto) {
        // Use Node.js crypto module
        return this.encryptNode(data, algorithm, key, iv, inputEncoding, outputEncoding);
      } else if (this.isBrowser() && this.subtle) {
        // Use browser's SubtleCrypto API
        return this.encryptBrowser(data, algorithm, key, iv, inputEncoding, outputEncoding);
      } else {
        throw new Error('Cryptographic API is not available in this environment');
      }
    } catch (err) {
      this.logger.error('Error encrypting data', err);
      throw err;
    }
  }
  
  /**
   * Decrypts data using the specified algorithm and key
   * 
   * @param encryptedData Data to decrypt
   * @param options Decryption options
   * @returns Decrypted data
   */
  public static async decrypt(encryptedData: string, options: DecryptionOptions): Promise<string> {
    try {
      const { 
        algorithm, 
        key, 
        iv, 
        inputEncoding = Encoding.BASE64,
        outputEncoding = Encoding.UTF8
      } = options;
      
      if (!iv && (algorithm === EncryptionAlgorithm.AES_CBC || algorithm === EncryptionAlgorithm.AES_GCM)) {
        throw new Error(`IV is required for ${algorithm} algorithm`);
      }
      
      if (this.isNode() && this.crypto) {
        // Use Node.js crypto module
        return this.decryptNode(encryptedData, algorithm, key, iv || '', inputEncoding, outputEncoding);
      } else if (this.isBrowser() && this.subtle) {
        // Use browser's SubtleCrypto API
        return this.decryptBrowser(encryptedData, algorithm, key, iv || '', inputEncoding, outputEncoding);
      } else {
        throw new Error('Cryptographic API is not available in this environment');
      }
    } catch (err) {
      this.logger.error('Error decrypting data', err);
      throw err;
    }
  }
  
  /**
   * Computes a hash of the data
   * 
   * @param data Data to hash
   * @param options Hash options
   * @returns Hash value
   */
  public static async hash(data: string, options: HashOptions): Promise<string> {
    try {
      const { 
        algorithm, 
        encoding = Encoding.HEX,
        salt = '',
        iterations = 1
      } = options;
      
      // Apply salt if provided
      const dataToHash = salt ? data + salt : data;
      
      if (this.isNode() && this.crypto) {
        // Use Node.js crypto module
        let hashValue = this.hashNode(dataToHash, algorithm);
        
        // Apply multiple iterations if needed
        for (let i = 1; i < iterations; i++) {
          hashValue = this.hashNode(hashValue, algorithm);
        }
        
        // Encode the hash
        switch (encoding) {
          case Encoding.HEX:
            return hashValue;
          case Encoding.BASE64:
            return Buffer.from(hashValue, 'hex').toString('base64');
          case Encoding.UTF8:
            return Buffer.from(hashValue, 'hex').toString('utf8');
          default:
            return hashValue;
        }
      } else if (this.isBrowser() && this.subtle) {
        // Use browser's SubtleCrypto API
        return this.hashBrowser(dataToHash, algorithm, iterations, encoding);
      } else {
        throw new Error('Cryptographic API is not available in this environment');
      }
    } catch (err) {
      this.logger.error('Error hashing data', err);
      throw err;
    }
  }
  
  /**
   * Derives a key from a password
   * 
   * @param options Key derivation options
   * @returns Derived key
   */
  public static async deriveKey(options: KeyDerivationOptions): Promise<string> {
    try {
      const {
        password,
        salt,
        iterations = 10000,
        keyLength = 32,
        digest = HashAlgorithm.SHA256
      } = options;
      
      if (this.isNode() && this.crypto) {
        // Use Node.js pbkdf2 function
        return new Promise<string>((resolve, reject) => {
          this.crypto.pbkdf2(
            password,
            salt,
            iterations,
            keyLength,
            digest,
            (err: Error | null, derivedKey: Buffer) => {
              if (err) {
                reject(err);
              } else {
                resolve(derivedKey.toString('hex'));
              }
            }
          );
        });
      } else if (this.isBrowser() && this.subtle) {
        // Use browser's SubtleCrypto API
        const encoder = new TextEncoder();
        const passwordBuffer = encoder.encode(password);
        const saltBuffer = encoder.encode(salt);
        
        // Import password as raw key material
        const importedKey = await this.subtle.importKey(
          'raw',
          passwordBuffer,
          { name: 'PBKDF2' },
          false,
          ['deriveBits']
        );
        
        // Map digest algorithm to browser API name
        const hashAlgorithm = this.mapHashAlgorithmToBrowser(digest);
        
        // Derive key bits
        const derivedBits = await this.subtle.deriveBits(
          {
            name: 'PBKDF2',
            salt: saltBuffer,
            iterations,
            hash: hashAlgorithm
          },
          importedKey,
          keyLength * 8
        );
        
        // Convert to hex string
        return this.bufferToHex(new Uint8Array(derivedBits));
      } else {
        throw new Error('Cryptographic API is not available in this environment');
      }
    } catch (err) {
      this.logger.error('Error deriving key', err);
      throw err;
    }
  }
  
  /**
   * Securely compares two strings in constant time
   * 
   * @param a First string
   * @param b Second string
   * @returns True if strings are equal, false otherwise
   */
  public static secureCompare(a: string, b: string): boolean {
    // Ensure strings are the same length
    if (a.length !== b.length) {
      return false;
    }
    
    // Perform constant-time comparison
    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    
    return result === 0;
  }
  
  /**
   * Encrypts data using Node.js crypto module
   * 
   * @param data Data to encrypt
   * @param algorithm Encryption algorithm
   * @param key Encryption key
   * @param iv Initialization vector
   * @param inputEncoding Input encoding
   * @param outputEncoding Output encoding
   * @returns Encrypted data
   */
  private static encryptNode(
    data: string,
    algorithm: EncryptionAlgorithm,
    key: string,
    iv: string,
    inputEncoding: Encoding,
    outputEncoding: Encoding
  ): string {
    // Map algorithm to Node.js crypto algorithm
    const cryptoAlgorithm = this.mapAlgorithmToNode(algorithm);
    
    // Convert key and IV to buffers
    const keyBuffer = Buffer.from(key, 'utf8');
    const ivBuffer = Buffer.from(iv, 'hex');
    
    // Create cipher
    const cipher = this.crypto.createCipheriv(
      cryptoAlgorithm,
      keyBuffer.length === 32 ? keyBuffer : this.crypto.scryptSync(keyBuffer, 'salt', 32),
      ivBuffer
    );
    
    // Convert input data to appropriate encoding
    let inputData: string | Buffer = data;
    if (inputEncoding === Encoding.BASE64) {
      inputData = Buffer.from(data, 'base64');
    } else if (inputEncoding === Encoding.HEX) {
      inputData = Buffer.from(data, 'hex');
    }
    
    // Encrypt data
    let encrypted = cipher.update(inputData, 'utf8', outputEncoding === Encoding.HEX ? 'hex' : 'base64');
    encrypted += cipher.final(outputEncoding === Encoding.HEX ? 'hex' : 'base64');
    
    // For UTF8 output, convert from base64
    if (outputEncoding === Encoding.UTF8) {
      return Buffer.from(encrypted, 'base64').toString('utf8');
    }
    
    return encrypted;
  }
  
  /**
   * Decrypts data using Node.js crypto module
   * 
   * @param encryptedData Data to decrypt
   * @param algorithm Encryption algorithm
   * @param key Decryption key
   * @param iv Initialization vector
   * @param inputEncoding Input encoding
   * @param outputEncoding Output encoding
   * @returns Decrypted data
   */
  private static decryptNode(
    encryptedData: string,
    algorithm: EncryptionAlgorithm,
    key: string,
    iv: string,
    inputEncoding: Encoding,
    outputEncoding: Encoding
  ): string {
    // Map algorithm to Node.js crypto algorithm
    const cryptoAlgorithm = this.mapAlgorithmToNode(algorithm);
    
    // Convert key and IV to buffers
    const keyBuffer = Buffer.from(key, 'utf8');
    const ivBuffer = Buffer.from(iv, 'hex');
    
    // Create decipher
    const decipher = this.crypto.createDecipheriv(
      cryptoAlgorithm,
      keyBuffer.length === 32 ? keyBuffer : this.crypto.scryptSync(keyBuffer, 'salt', 32),
      ivBuffer
    );
    
    // Convert input data to appropriate encoding
    let inputData = encryptedData;
    if (inputEncoding === Encoding.UTF8) {
      inputData = Buffer.from(encryptedData, 'utf8').toString('base64');
    }
    
    // Decrypt data
    let decrypted = decipher.update(inputData, inputEncoding === Encoding.HEX ? 'hex' : 'base64', 'utf8');
    decrypted += decipher.final('utf8');
    
    // Handle output encoding
    if (outputEncoding === Encoding.HEX) {
      return Buffer.from(decrypted, 'utf8').toString('hex');
    } else if (outputEncoding === Encoding.BASE64) {
      return Buffer.from(decrypted, 'utf8').toString('base64');
    }
    
    return decrypted;
  }
  
  /**
   * Encrypts data using browser's SubtleCrypto API
   * 
   * @param data Data to encrypt
   * @param algorithm Encryption algorithm
   * @param key Encryption key
   * @param iv Initialization vector
   * @param inputEncoding Input encoding
   * @param outputEncoding Output encoding
   * @returns Encrypted data
   */
  private static async encryptBrowser(
    data: string,
    algorithm: EncryptionAlgorithm,
    key: string,
    iv: string,
    inputEncoding: Encoding,
    outputEncoding: Encoding
  ): Promise<string> {
    // Ensure SubtleCrypto is available
    if (!this.subtle) {
      throw new Error('SubtleCrypto API is not available in this browser');
    }
    
    // Convert input data based on encoding
    let inputDataBuffer: ArrayBuffer;
    if (inputEncoding === Encoding.UTF8) {
      inputDataBuffer = new TextEncoder().encode(data);
    } else if (inputEncoding === Encoding.BASE64) {
      inputDataBuffer = this.base64ToBuffer(data);
    } else if (inputEncoding === Encoding.HEX) {
      inputDataBuffer = this.hexToBuffer(data);
    } else {
      inputDataBuffer = new TextEncoder().encode(data);
    }
    
    // Convert key and IV to buffers
    const keyBuffer = new TextEncoder().encode(key);
    const ivBuffer = this.hexToBuffer(iv);
    
    // Map algorithm to browser API parameters
    const cryptoAlgorithm = this.mapAlgorithmToBrowser(algorithm);
    
    // Import key
    const cryptoKey = await this.subtle.importKey(
      'raw',
      await this.subtle.digest('SHA-256', keyBuffer),
      cryptoAlgorithm.algorithm,
      false,
      ['encrypt']
    );
    
    // Encrypt data
    const encryptedBuffer = await this.subtle.encrypt(
      {
        name: cryptoAlgorithm.name,
        iv: ivBuffer,
        ...(cryptoAlgorithm.additionalParams || {})
      },
      cryptoKey,
      inputDataBuffer
    );
    
    // Convert to requested output encoding
    switch (outputEncoding) {
      case Encoding.HEX:
        return this.bufferToHex(new Uint8Array(encryptedBuffer));
      case Encoding.BASE64:
        return this.bufferToBase64(new Uint8Array(encryptedBuffer));
      case Encoding.UTF8:
        return this.bufferToUtf8(new Uint8Array(encryptedBuffer));
      default:
        return this.bufferToBase64(new Uint8Array(encryptedBuffer));
    }
  }
  
  /**
   * Decrypts data using browser's SubtleCrypto API
   * 
   * @param encryptedData Data to decrypt
   * @param algorithm Encryption algorithm
   * @param key Decryption key
   * @param iv Initialization vector
   * @param inputEncoding Input encoding
   * @param outputEncoding Output encoding
   * @returns Decrypted data
   */
  private static async decryptBrowser(
    encryptedData: string,
    algorithm: EncryptionAlgorithm,
    key: string,
    iv: string,
    inputEncoding: Encoding,
    outputEncoding: Encoding
  ): Promise<string> {
    // Ensure SubtleCrypto is available
    if (!this.subtle) {
      throw new Error('SubtleCrypto API is not available in this browser');
    }
    
    // Convert encrypted data based on encoding
    let encryptedBuffer: ArrayBuffer;
    if (inputEncoding === Encoding.BASE64) {
      encryptedBuffer = this.base64ToBuffer(encryptedData);
    } else if (inputEncoding === Encoding.HEX) {
      encryptedBuffer = this.hexToBuffer(encryptedData);
    } else {
      throw new Error('Unsupported input encoding for decryption');
    }
    
    // Convert key and IV to buffers
    const keyBuffer = new TextEncoder().encode(key);
    const ivBuffer = this.hexToBuffer(iv);
    
    // Map algorithm to browser API parameters
    const cryptoAlgorithm = this.mapAlgorithmToBrowser(algorithm);
    
    // Import key
    const cryptoKey = await this.subtle.importKey(
      'raw',
      await this.subtle.digest('SHA-256', keyBuffer),
      cryptoAlgorithm.algorithm,
      false,
      ['decrypt']
    );
    
    // Decrypt data
    const decryptedBuffer = await this.subtle.decrypt(
      {
        name: cryptoAlgorithm.name,
        iv: ivBuffer,
        ...(cryptoAlgorithm.additionalParams || {})
      },
      cryptoKey,
      encryptedBuffer
    );
    
    // Convert to requested output encoding
    switch (outputEncoding) {
      case Encoding.HEX:
        return this.bufferToHex(new Uint8Array(decryptedBuffer));
      case Encoding.BASE64:
        return this.bufferToBase64(new Uint8Array(decryptedBuffer));
      case Encoding.UTF8:
        return new TextDecoder().decode(decryptedBuffer);
      default:
        return new TextDecoder().decode(decryptedBuffer);
    }
  }
  
  /**
   * Hashes data using Node.js crypto module
   * 
   * @param data Data to hash
   * @param algorithm Hash algorithm
   * @returns Hash value
   */
  private static hashNode(data: string, algorithm: HashAlgorithm): string {
    // Map algorithm to Node.js hash algorithm
    const hashAlgorithm = this.mapHashAlgorithmToNode(algorithm);
    
    // Create hash
    const hash = this.crypto.createHash(hashAlgorithm);
    
    // Update hash with data
    hash.update(data, 'utf8');
    
    // Return hash as hex
    return hash.digest('hex');
  }
  
  /**
   * Hashes data using browser's SubtleCrypto API
   * 
   * @param data Data to hash
   * @param algorithm Hash algorithm
   * @param iterations Number of hash iterations
   * @param encoding Output encoding
   * @returns Hash value
   */
  private static async hashBrowser(
    data: string,
    algorithm: HashAlgorithm,
    iterations: number,
    encoding: Encoding
  ): Promise<string> {
    // Ensure SubtleCrypto is available
    if (!this.subtle) {
      throw new Error('SubtleCrypto API is not available in this browser');
    }
    
    // Convert data to buffer
    let dataBuffer = new TextEncoder().encode(data);
    
    // Map algorithm to browser API name
    const hashAlgorithm = this.mapHashAlgorithmToBrowser(algorithm);
    
    // Apply hash iterations
    let hashBuffer = await this.subtle.digest(hashAlgorithm, dataBuffer);
    
    for (let i = 1; i < iterations; i++) {
      hashBuffer = await this.subtle.digest(hashAlgorithm, hashBuffer);
    }
    
    // Convert to requested encoding
    switch (encoding) {
      case Encoding.HEX:
        return this.bufferToHex(new Uint8Array(hashBuffer));
      case Encoding.BASE64:
        return this.bufferToBase64(new Uint8Array(hashBuffer));
      case Encoding.UTF8:
        return this.bufferToUtf8(new Uint8Array(hashBuffer));
      default:
        return this.bufferToHex(new Uint8Array(hashBuffer));
    }
  }
  
  /**
   * Maps encryption algorithm to Node.js crypto algorithm
   * 
   * @param algorithm Encryption algorithm
   * @returns Node.js crypto algorithm
   */
  private static mapAlgorithmToNode(algorithm: EncryptionAlgorithm): string {
    switch (algorithm) {
      case EncryptionAlgorithm.AES:
      case EncryptionAlgorithm.AES_CBC:
        return 'aes-256-cbc';
      case EncryptionAlgorithm.AES_GCM:
        return 'aes-256-gcm';
      default:
        throw new Error(`Unsupported encryption algorithm: ${algorithm}`);
    }
  }
  
  /**
   * Maps encryption algorithm to browser SubtleCrypto parameters
   * 
   * @param algorithm Encryption algorithm
   * @returns Browser SubtleCrypto parameters
   */
  private static mapAlgorithmToBrowser(algorithm: EncryptionAlgorithm): {
    name: string;
    algorithm: AesKeyGenParams;
    additionalParams?: any;
  } {
    switch (algorithm) {
      case EncryptionAlgorithm.AES:
      case EncryptionAlgorithm.AES_CBC:
        return {
          name: 'AES-CBC',
          algorithm: { name: 'AES-CBC', length: 256 }
        };
      case EncryptionAlgorithm.AES_GCM:
        return {
          name: 'AES-GCM',
          algorithm: { name: 'AES-GCM', length: 256 },
          additionalParams: { tagLength: 128 }
        };
      default:
        throw new Error(`Unsupported encryption algorithm: ${algorithm}`);
    }
  }
  
  /**
   * Maps hash algorithm to Node.js crypto algorithm
   * 
   * @param algorithm Hash algorithm
   * @returns Node.js crypto algorithm
   */
  private static mapHashAlgorithmToNode(algorithm: HashAlgorithm): string {
    switch (algorithm) {
      case HashAlgorithm.MD5:
        return 'md5';
      case HashAlgorithm.SHA1:
        return 'sha1';
      case HashAlgorithm.SHA256:
        return 'sha256';
      case HashAlgorithm.SHA384:
        return 'sha384';
      case HashAlgorithm.SHA512:
        return 'sha512';
      default:
        throw new Error(`Unsupported hash algorithm: ${algorithm}`);
    }
  }
  
  /**
   * Maps hash algorithm to browser SubtleCrypto algorithm
   * 
   * @param algorithm Hash algorithm
   * @returns Browser SubtleCrypto algorithm
   */
  private static mapHashAlgorithmToBrowser(algorithm: HashAlgorithm): string {
    switch (algorithm) {
      case HashAlgorithm.SHA1:
        return 'SHA-1';
      case HashAlgorithm.SHA256:
        return 'SHA-256';
      case HashAlgorithm.SHA384:
        return 'SHA-384';
      case HashAlgorithm.SHA512:
        return 'SHA-512';
      case HashAlgorithm.MD5:
        // Note: MD5 is not supported in SubtleCrypto
        throw new Error('MD5 is not supported in SubtleCrypto API');
      default:
        throw new Error(`Unsupported hash algorithm: ${algorithm}`);
    }
  }
  
  /**
   * Converts a buffer to hex string
   * 
   * @param buffer Buffer to convert
   * @returns Hex string
   */
  private static bufferToHex(buffer: Uint8Array): string {
    return Array.from(buffer)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
  
  /**
   * Converts a buffer to base64 string
   * 
   * @param buffer Buffer to convert
   * @returns Base64 string
   */
  private static bufferToBase64(buffer: Uint8Array): string {
    if (typeof btoa === 'function') {
      // Browser
      const binary = Array.from(buffer)
        .map(b => String.fromCharCode(b))
        .join('');
      return btoa(binary);
    } else if (typeof Buffer !== 'undefined') {
      // Node.js
      return Buffer.from(buffer).toString('base64');
    } else {
      throw new Error('Base64 conversion is not supported in this environment');
    }
  }
  
  /**
   * Converts a buffer to UTF-8 string
   * 
   * @param buffer Buffer to convert
   * @returns UTF-8 string
   */
  private static bufferToUtf8(buffer: Uint8Array): string {
    if (typeof TextDecoder !== 'undefined') {
      // Browser
      return new TextDecoder().decode(buffer);
    } else if (typeof Buffer !== 'undefined') {
      // Node.js
      return Buffer.from(buffer).toString('utf8');
    } else {
      throw new Error('UTF-8 conversion is not supported in this environment');
    }
  }
  
  /**
   * Converts a hex string to buffer
   * 
   * @param hex Hex string
   * @returns Buffer
   */
  private static hexToBuffer(hex: string): Uint8Array {
    if (hex.length % 2 !== 0) {
      throw new Error('Hex string must have an even number of characters');
    }
    
    const buffer = new Uint8Array(hex.length / 2);
    
    for (let i = 0; i < hex.length; i += 2) {
      buffer[i / 2] = parseInt(hex.substring(i, i + 2), 16);
    }
    
    return buffer;
  }
  
  /**
   * Converts a base64 string to buffer
   * 
   * @param base64 Base64 string
   * @returns Buffer
   */
  private static base64ToBuffer(base64: string): Uint8Array {
    if (typeof atob === 'function') {
      // Browser
      const binaryString = atob(base64);
      const buffer = new Uint8Array(binaryString.length);
      
      for (let i = 0; i < binaryString.length; i++) {
        buffer[i] = binaryString.charCodeAt(i);
      }
      
      return buffer;
    } else if (typeof Buffer !== 'undefined') {
      // Node.js
      return Buffer.from(base64, 'base64');
    } else {
      throw new Error('Base64 conversion is not supported in this environment');
    }
  }
}

export default CSEncryptionUtils;


/**
 * CSScreenshotManager.ts
 * 
 * Utility class for capturing and managing screenshots.
 * Provides cross-platform (Browser/Node.js) screenshot capabilities.
 */

import CSLogger from './CSLogger';
import CSFileUtils from './CSFileUtils';
import CSPathUtils from './CSPathUtils';
import CSDateUtils from './CSDateUtils';
import CSConstants from './CSConstants';

/**
 * Screenshot format types
 */
export enum ScreenshotFormat {
  PNG = 'png',
  JPEG = 'jpeg',
  BMP = 'bmp'
}

/**
 * Screenshot quality options (for JPEG format)
 */
export type ScreenshotQuality = number; // 0-100

/**
 * Screenshot dimensions
 */
export interface ScreenshotDimensions {
  width: number;
  height: number;
}

/**
 * Screenshot options
 */
export interface ScreenshotOptions {
  /** Screenshot format */
  format?: ScreenshotFormat;
  /** Screenshot quality (for JPEG format) */
  quality?: ScreenshotQuality;
  /** Path to save the screenshot */
  path?: string;
  /** Whether to return the screenshot as base64 data */
  returnAsBase64?: boolean;
  /** Clip region for the screenshot */
  clip?: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  /** Whether to hide scrollbars */
  hideScrollbars?: boolean;
  /** Whether to only capture the viewport */
  viewportOnly?: boolean;
  /** Whether to create the directory if it doesn't exist */
  createDirectory?: boolean;
  /** Whether to capture the cursor */
  captureCursor?: boolean;
}

/**
 * Screenshot result
 */
export interface ScreenshotResult {
  /** Path to the saved screenshot */
  path?: string;
  /** Base64-encoded screenshot data */
  base64Data?: string;
  /** Screenshot dimensions */
  dimensions?: ScreenshotDimensions;
  /** Screenshot format */
  format: ScreenshotFormat;
  /** Timestamp when the screenshot was taken */
  timestamp: Date;
}

/**
 * Screenshot manager for both Selenium and Playwright
 */
export class CSScreenshotManager {
  private static readonly logger = CSLogger.getInstance();
  private static readonly ENVIRONMENT = typeof window !== 'undefined' ? 'browser' : 'node';
  
  // Default options for screenshots
  private static readonly DEFAULT_OPTIONS: ScreenshotOptions = {
    format: ScreenshotFormat.PNG,
    quality: 90,
    returnAsBase64: false,
    hideScrollbars: true,
    viewportOnly: false,
    createDirectory: true,
    captureCursor: false
  };
  
  // Instance for current test run
  private static instance: CSScreenshotManager;
  
  // Directory for screenshots
  private screenshotDir: string;
  
  // Count of screenshots in current run
  private screenshotCount: number = 0;
  
  // WebDriver/Playwright instances
  private webDriver: any;
  private webDriverType: 'selenium' | 'playwright' | null = null;
  private page: any;
  
  /**
   * Private constructor for singleton pattern
   * 
   * @param screenshotDir Directory to save screenshots
   */
  private constructor(screenshotDir: string = CSConstants.PATH_SCREENSHOTS) {
    this.screenshotDir = screenshotDir;
  }
  
  /**
   * Gets the screenshot manager instance
   * 
   * @param screenshotDir Directory to save screenshots
   * @returns Screenshot manager instance
   */
  public static getInstance(screenshotDir?: string): CSScreenshotManager {
    if (!CSScreenshotManager.instance) {
      CSScreenshotManager.instance = new CSScreenshotManager(screenshotDir);
    } else if (screenshotDir) {
      CSScreenshotManager.instance.setScreenshotDir(screenshotDir);
    }
    
    return CSScreenshotManager.instance;
  }
  
  /**
   * Sets the screenshot directory
   * 
   * @param screenshotDir Directory to save screenshots
   */
  public setScreenshotDir(screenshotDir: string): void {
    this.screenshotDir = screenshotDir;
  }
  
  /**
   * Sets the WebDriver instance for Selenium screenshots
   * 
   * @param driver WebDriver instance
   */
  public setWebDriver(driver: any): void {
    this.webDriver = driver;
    this.webDriverType = 'selenium';
    this.page = null;
  }
  
  /**
   * Sets the Playwright page instance for Playwright screenshots
   * 
   * @param page Playwright page instance
   */
  public setPlaywrightPage(page: any): void {
    this.page = page;
    this.webDriverType = 'playwright';
    this.webDriver = null;
  }
  
  /**
   * Captures a screenshot using Selenium or Playwright
   * 
   * @param namePrefix Prefix for the screenshot file name
   * @param options Screenshot options
   * @returns Promise resolving to screenshot result
   */
  public async capture(namePrefix: string = 'screenshot', options: Partial<ScreenshotOptions> = {}): Promise<ScreenshotResult> {
    try {
      // Merge with default options
      const mergedOptions: ScreenshotOptions = {
        ...CSScreenshotManager.DEFAULT_OPTIONS,
        ...options
      };
      
      // Generate screenshot path if not provided
      const path = options.path || this.generateScreenshotPath(namePrefix, mergedOptions.format!);
      
      // Create directory if needed
      if (mergedOptions.createDirectory) {
        await this.ensureScreenshotDirectoryExists(path);
      }
      
      // Capture screenshot based on WebDriver type
      if (this.webDriverType === 'selenium' && this.webDriver) {
        return this.captureSeleniumScreenshot(path, mergedOptions);
      } else if (this.webDriverType === 'playwright' && this.page) {
        return this.capturePlaywrightScreenshot(path, mergedOptions);
      } else if (CSScreenshotManager.ENVIRONMENT === 'browser') {
        return this.captureBrowserScreenshot(path, mergedOptions);
      } else {
        throw new Error('No WebDriver or Playwright page instance set for screenshot capture');
      }
    } catch (err) {
      this.logger.error(`Error capturing screenshot: ${err.message}`, err);
      throw err;
    }
  }
  
  /**
   * Captures a screenshot on error
   * 
   * @param error Error object
   * @param namePrefix Prefix for the screenshot file name
   * @param options Screenshot options
   * @returns Promise resolving to screenshot result or null if capture fails
   */
  public async captureOnError(error: Error, namePrefix: string = 'error', options: Partial<ScreenshotOptions> = {}): Promise<ScreenshotResult | null> {
    try {
      // Generate error screenshot name
      const errorName = error.name.replace(/[^a-zA-Z0-9]/g, '_');
      const screenshotName = `${namePrefix}_${errorName}`;
      
      // Capture screenshot
      const result = await this.capture(screenshotName, options);
      
      // Log screenshot capture
      this.logger.info(`Screenshot captured on error: ${result.path}`, { error });
      
      return result;
    } catch (err) {
      this.logger.error(`Failed to capture screenshot on error: ${err.message}`, err);
      return null;
    }
  }
  
  /**
   * Compares two screenshots for visual differences
   * 
   * @param screenshot1 Path or base64 data of first screenshot
   * @param screenshot2 Path or base64 data of second screenshot
   * @param options Comparison options
   * @returns Promise resolving to comparison result
   */
  public async compareScreenshots(
    screenshot1: string,
    screenshot2: string,
    options: {
      threshold?: number;
      outputPath?: string;
      highlightDifferences?: boolean;
      ignoreRegions?: Array<{ x: number, y: number, width: number, height: number }>;
    } = {}
  ): Promise<{
    matches: boolean;
    diffPercentage: number;
    diffPath?: string;
    dimensions: { width: number, height: number };
  }> {
    try {
      // Load images
      const img1 = await this.loadScreenshotData(screenshot1);
      const img2 = await this.loadScreenshotData(screenshot2);
      
      // Compare images
      return this.performImageComparison(img1, img2, options);
    } catch (err) {
      this.logger.error(`Error comparing screenshots: ${err.message}`, err);
      throw err;
    }
  }
  
  /**
   * Generates a unique path for a screenshot
   * 
   * @param namePrefix Prefix for the screenshot file name
   * @param format Screenshot format
   * @returns Screenshot path
   */
  private generateScreenshotPath(namePrefix: string, format: ScreenshotFormat): string {
    // Increment screenshot count
    this.screenshotCount++;
    
    // Format date for the filename
    const dateStr = CSDateUtils.format(new Date(), 'YYYY-MM-DD_HH-mm-ss');
    
    // Create file name with counter to ensure uniqueness
    const fileName = `${namePrefix}_${dateStr}_${this.screenshotCount}.${format}`;
    
    // Return full path
    return CSPathUtils.join(this.screenshotDir, fileName);
  }
  
  /**
   * Ensures the screenshot directory exists
   * 
   * @param path Screenshot path
   */
  private async ensureScreenshotDirectoryExists(path: string): Promise<void> {
    const directory = CSPathUtils.dirname(path);
    await CSFileUtils.mkdir(directory, { recursive: true });
  }
  
  /**
   * Captures a screenshot using Selenium WebDriver
   * 
   * @param path Path to save the screenshot
   * @param options Screenshot options
   * @returns Promise resolving to screenshot result
   */
  private async captureSeleniumScreenshot(
    path: string,
    options: ScreenshotOptions
  ): Promise<ScreenshotResult> {
    try {
      // Handle Selenium-specific options
      if (options.hideScrollbars) {
        await this.executeScriptInSelenium('document.documentElement.style.overflow = "hidden";');
      }
      
      let base64Data: string;
      
      // Handle clip region
      if (options.clip) {
        // Execute script to capture specific region
        base64Data = await this.captureSeleniumRegion(options.clip);
      } else if (options.viewportOnly) {
        // Capture only the viewport
        base64Data = await this.captureSeleniumViewport();
      } else {
        // Capture full page
        base64Data = await this.webDriver.takeScreenshot();
      }
      
      // Remove the 'data:image/png;base64,' prefix if present
      base64Data = this.stripBase64Header(base64Data);
      
      // Convert to requested format if needed
      if (options.format !== ScreenshotFormat.PNG) {
        base64Data = await this.convertScreenshotFormat(
          base64Data,
          ScreenshotFormat.PNG,
          options.format!,
          options.quality
        );
      }
      
      // Restore scrollbars if needed
      if (options.hideScrollbars) {
        await this.executeScriptInSelenium('document.documentElement.style.overflow = "";');
      }
      
      // Get dimensions
      const dimensions = await this.getSeleniumScreenshotDimensions();
      
      // Save screenshot if path is provided
      if (path) {
        await CSFileUtils.writeFile(
          path,
          Buffer.from(base64Data, 'base64')
        );
      }
      
      // Return result
      return {
        path: path,
        base64Data: options.returnAsBase64 ? base64Data : undefined,
        dimensions,
        format: options.format!,
        timestamp: new Date()
      };
    } catch (err) {
      this.logger.error(`Error capturing Selenium screenshot: ${err.message}`, err);
      throw err;
    }
  }
  
  /**
   * Captures a screenshot using Playwright
   * 
   * @param path Path to save the screenshot
   * @param options Screenshot options
   * @returns Promise resolving to screenshot result
   */
  private async capturePlaywrightScreenshot(
    path: string,
    options: ScreenshotOptions
  ): Promise<ScreenshotResult> {
    try {
      // Prepare Playwright-specific options
      const playwrightOptions: any = {
        path,
        type: options.format === ScreenshotFormat.JPEG ? 'jpeg' : 'png',
        quality: options.format === ScreenshotFormat.JPEG ? options.quality : undefined,
        fullPage: !options.viewportOnly,
        clip: options.clip,
        omitBackground: false,
        animations: 'disabled',
        scale: 'css',
        caret: 'initial'
      };
      
      // Capture screenshot
      const buffer = await this.page.screenshot(playwrightOptions);
      
      // Convert buffer to base64
      const base64Data = buffer.toString('base64');
      
      // Get dimensions
      const dimensions = await this.getPlaywrightScreenshotDimensions();
      
      // Return result
      return {
        path,
        base64Data: options.returnAsBase64 ? base64Data : undefined,
        dimensions,
        format: options.format!,
        timestamp: new Date()
      };
    } catch (err) {
      this.logger.error(`Error capturing Playwright screenshot: ${err.message}`, err);
      throw err;
    }
  }
  
  /**
   * Captures a screenshot in the browser
   * 
   * @param path Path to save the screenshot
   * @param options Screenshot options
   * @returns Promise resolving to screenshot result
   */
  private async captureBrowserScreenshot(
    path: string,
    options: ScreenshotOptions
  ): Promise<ScreenshotResult> {
    try {
      if (!document) {
        throw new Error('Document object not available for browser screenshot capture');
      }
      
      // Create canvas for screenshot
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      if (!ctx) {
        throw new Error('Failed to get canvas context for screenshot');
      }
      
      // Get the target element (full document or viewport)
      const targetElement = options.viewportOnly ? window : document.documentElement;
      
      // Set canvas dimensions
      const width = options.viewportOnly ? window.innerWidth : targetElement.scrollWidth;
      const height = options.viewportOnly ? window.innerHeight : targetElement.scrollHeight;
      
      canvas.width = options.clip ? options.clip.width : width;
      canvas.height = options.clip ? options.clip.height : height;
      
      // Handle scrollbars
      const originalOverflow = document.documentElement.style.overflow;
      if (options.hideScrollbars) {
        document.documentElement.style.overflow = 'hidden';
      }
      
      // Create a clean copy of the page for rendering
      const html2canvas = await this.loadHtml2Canvas();
      
      // Capture the content
      const renderedCanvas = await html2canvas(targetElement, {
        width,
        height,
        x: options.clip ? options.clip.x : 0,
        y: options.clip ? options.clip.y : 0,
        windowWidth: document.documentElement.offsetWidth,
        windowHeight: document.documentElement.offsetHeight,
        useCORS: true,
        allowTaint: true,
        scale: window.devicePixelRatio,
        logging: false,
        imageTimeout: 10000,
        removeContainer: true
      });
      
      // Restore scrollbars
      if (options.hideScrollbars) {
        document.documentElement.style.overflow = originalOverflow;
      }
      
      // Get the image data as base64
      let base64Data = renderedCanvas.toDataURL(
        options.format === ScreenshotFormat.JPEG ? 'image/jpeg' : 'image/png',
        options.format === ScreenshotFormat.JPEG ? options.quality! / 100 : undefined
      );
      
      // Remove the data URL prefix
      base64Data = this.stripBase64Header(base64Data);
      
      // Save screenshot if path is provided
      if (path && typeof window !== 'undefined' && window.fs) {
        const binaryData = this.base64ToBinary(base64Data);
        await window.fs.writeFile(path, binaryData);
      }
      
      // Return result
      return {
        path,
        base64Data: options.returnAsBase64 ? base64Data : undefined,
        dimensions: {
          width: canvas.width,
          height: canvas.height
        },
        format: options.format!,
        timestamp: new Date()
      };
    } catch (err) {
      this.logger.error(`Error capturing browser screenshot: ${err.message}`, err);
      throw err;
    }
  }
  
  /**
   * Captures a specific region using Selenium
   * 
   * @param clip Region to capture
   * @returns Promise resolving to base64-encoded screenshot data
   */
  private async captureSeleniumRegion(clip: { x: number; y: number; width: number; height: number }): Promise<string> {
    // Execute script to capture the region
    const script = `
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const scrollX = window.scrollX;
      const scrollY = window.scrollY;
      
      canvas.width = ${clip.width};
      canvas.height = ${clip.height};
      
      // Use html2canvas for capturing
      return new Promise((resolve) => {
        const html2canvas = document.createElement('script');
        html2canvas.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        html2canvas.onload = () => {
          window.html2canvas(document.documentElement, {
            x: ${clip.x} + scrollX,
            y: ${clip.y} + scrollY,
            width: ${clip.width},
            height: ${clip.height},
          }).then(canvas => {
            resolve(canvas.toDataURL('image/png'));
          });
        };
        document.head.appendChild(html2canvas);
      });
    `;
    
    return await this.executeScriptInSelenium(script);
  }
  
  /**
   * Captures only the viewport using Selenium
   * 
   * @returns Promise resolving to base64-encoded screenshot data
   */
  private async captureSeleniumViewport(): Promise<string> {
    // Execute script to capture the viewport
    const script = `
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Use html2canvas for capturing
      return new Promise((resolve) => {
        const html2canvas = document.createElement('script');
        html2canvas.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        html2canvas.onload = () => {
          window.html2canvas(document.documentElement, {
            width: window.innerWidth,
            height: window.innerHeight,
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
          }).then(canvas => {
            resolve(canvas.toDataURL('image/png'));
          });
        };
        document.head.appendChild(html2canvas);
      });
    `;
    
    return await this.executeScriptInSelenium(script);
  }
  
  /**
   * Gets the dimensions of a Selenium screenshot
   * 
   * @returns Promise resolving to screenshot dimensions
   */
  private async getSeleniumScreenshotDimensions(): Promise<ScreenshotDimensions> {
    // Execute script to get dimensions
    const script = `
      return {
        width: document.documentElement.scrollWidth,
        height: document.documentElement.scrollHeight
      };
    `;
    
    return await this.executeScriptInSelenium(script);
  }
  
  /**
   * Gets the dimensions of a Playwright screenshot
   * 
   * @returns Promise resolving to screenshot dimensions
   */
  private async getPlaywrightScreenshotDimensions(): Promise<ScreenshotDimensions> {
    // Get page dimensions
    const dimensions = await this.page.evaluate(() => {
      return {
        width: document.documentElement.scrollWidth,
        height: document.documentElement.scrollHeight
      };
    });
    
    return dimensions;
  }
  
  /**
   * Executes a script in Selenium
   * 
   * @param script Script to execute
   * @returns Promise resolving to script result
   */
  private async executeScriptInSelenium(script: string): Promise<any> {
    return await this.webDriver.executeScript(script);
  }
  
  /**
   * Strips the base64 header from a data URL
   * 
   * @param base64Data Base64 data URL
   * @returns Base64 data without header
   */
  private stripBase64Header(base64Data: string): string {
    // Check if the string starts with a data URL prefix
    const match = base64Data.match(/^data:image\/[^;]+;base64,/);
    
    if (match) {
      return base64Data.substring(match[0].length);
    }
    
    return base64Data;
  }
  
  /**
   * Converts a screenshot from one format to another
   * 
   * @param base64Data Base64-encoded screenshot data
   * @param fromFormat Source format
   * @param toFormat Target format
   * @param quality Quality for JPEG format
   * @returns Promise resolving to converted base64 data
   */
  private async convertScreenshotFormat(
    base64Data: string,
    fromFormat: ScreenshotFormat,
    toFormat: ScreenshotFormat,
    quality?: number
  ): Promise<string> {
    // If formats are the same, return as is
    if (fromFormat === toFormat) {
      return base64Data;
    }
    
    // Create image and canvas for conversion
    const img = await this.createImageFromBase64(base64Data, fromFormat);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
      throw new Error('Failed to get canvas context for format conversion');
    }
    
    // Set canvas dimensions
    canvas.width = img.width;
    canvas.height = img.height;
    
    // Draw image to canvas
    ctx.drawImage(img, 0, 0);
    
    // Get data URL in the target format
    const mimeType = `image/${toFormat}`;
    const dataUrl = canvas.toDataURL(
      mimeType,
      toFormat === ScreenshotFormat.JPEG ? (quality || 90) / 100 : undefined
    );
    
    // Strip data URL header
    return this.stripBase64Header(dataUrl);
  }
  
  /**
   * Creates an Image object from base64 data
   * 
   * @param base64Data Base64-encoded image data
   * @param format Image format
   * @returns Promise resolving to Image object
   */
  private createImageFromBase64(base64Data: string, format: ScreenshotFormat): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Failed to load image from base64 data'));
      
      img.src = `data:image/${format};base64,${base64Data}`;
    });
  }
  
  /**
   * Loads a screenshot from path or base64 data
   * 
   * @param source Path or base64 data
   * @returns Promise resolving to screenshot data
   */
  private async loadScreenshotData(source: string): Promise<{
    data: Uint8Array;
    width: number;
    height: number;
    format: ScreenshotFormat;
  }> {
    try {
      let data: Uint8Array;
      let format: ScreenshotFormat;
      
      // Check if source is a base64 string or a file path
      if (source.startsWith('data:image/') || /^[A-Za-z0-9+/]+={0,2}$/.test(source)) {
        // Source is base64 data
        data = this.base64ToBinary(this.stripBase64Header(source));
        
        // Determine format from data URL
        if (source.startsWith('data:image/jpeg')) {
          format = ScreenshotFormat.JPEG;
        } else if (source.startsWith('data:image/bmp')) {
          format = ScreenshotFormat.BMP;
        } else {
          format = ScreenshotFormat.PNG;
        }
      } else {
        // Source is a file path
        data = await CSFileUtils.readFile(source) as Buffer;
        
        // Determine format from file extension
        if (source.toLowerCase().endsWith('.jpg') || source.toLowerCase().endsWith('.jpeg')) {
          format = ScreenshotFormat.JPEG;
        } else if (source.toLowerCase().endsWith('.bmp')) {
          format = ScreenshotFormat.BMP;
        } else {
          format = ScreenshotFormat.PNG;
        }
      }
      
      // Get image dimensions
      const dimensions = await this.getImageDimensions(data, format);
      
      return {
        data,
        width: dimensions.width,
        height: dimensions.height,
        format
      };
    } catch (err) {
      this.logger.error(`Error loading screenshot data: ${err.message}`, err);
      throw err;
    }
  }
  
  /**
   * Gets the dimensions of an image from binary data
   * 
   * @param data Image binary data
   * @param format Image format
   * @returns Promise resolving to image dimensions
   */
  private async getImageDimensions(data: Uint8Array, format: ScreenshotFormat): Promise<{ width: number; height: number }> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => resolve({ width: img.width, height: img.height });
      img.onerror = () => reject(new Error('Failed to load image for dimension detection'));
      
      const blob = new Blob([data], { type: `image/${format}` });
      img.src = URL.createObjectURL(blob);
    });
  }
  
  /**
   * Performs image comparison between two screenshots
   * 
   * @param img1 First screenshot data
   * @param img2 Second screenshot data
   * @param options Comparison options
   * @returns Promise resolving to comparison result
   */
  private async performImageComparison(
    img1: {
      data: Uint8Array;
      width: number;
      height: number;
      format: ScreenshotFormat;
    },
    img2: {
      data: Uint8Array;
      width: number;
      height: number;
      format: ScreenshotFormat;
    },
    options: {
      threshold?: number;
      outputPath?: string;
      highlightDifferences?: boolean;
      ignoreRegions?: Array<{ x: number, y: number, width: number, height: number }>;
    }
  ): Promise<{
    matches: boolean;
    diffPercentage: number;
    diffPath?: string;
    dimensions: { width: number, height: number };
  }> {
    // Apply default options
    const threshold = options.threshold !== undefined ? options.threshold : 0.1; // 0.1% difference threshold
    const highlightDifferences = options.highlightDifferences !== undefined ? options.highlightDifferences : true;
    const ignoreRegions = options.ignoreRegions || [];
    
    // Create canvases for comparison
    const canvas1 = await this.createCanvasFromImageData(img1.data, img1.format);
    const canvas2 = await this.createCanvasFromImageData(img2.data, img2.format);
    
    // Get contexts
    const ctx1 = canvas1.getContext('2d');
    const ctx2 = canvas2.getContext('2d');
    
    if (!ctx1 || !ctx2) {
      throw new Error('Failed to get canvas context for image comparison');
    }
    
    // Resize canvases to match dimensions
    const maxWidth = Math.max(img1.width, img2.width);
    const maxHeight = Math.max(img1.height, img2.height);
    
    // Adjust canvas sizes
    canvas1.width = maxWidth;
    canvas1.height = maxHeight;
    canvas2.width = maxWidth;
    canvas2.height = maxHeight;
    
    // Redraw images
    const img1Element = await this.createImageFromImageData(img1.data, img1.format);
    const img2Element = await this.createImageFromImageData(img2.data, img2.format);
    
    ctx1.drawImage(img1Element, 0, 0);
    ctx2.drawImage(img2Element, 0, 0);
    
    // Apply ignore regions
    for (const region of ignoreRegions) {
      ctx1.fillStyle = '#000';
      ctx2.fillStyle = '#000';
      
      ctx1.fillRect(region.x, region.y, region.width, region.height);
      ctx2.fillRect(region.x, region.y, region.width, region.height);
    }
    
    // Get image data
    const imageData1 = ctx1.getImageData(0, 0, maxWidth, maxHeight);
    const imageData2 = ctx2.getImageData(0, 0, maxWidth, maxHeight);
    
    // Compare pixels
    const diffCanvas = document.createElement('canvas');
    diffCanvas.width = maxWidth;
    diffCanvas.height = maxHeight;
    const diffCtx = diffCanvas.getContext('2d');
    
    if (!diffCtx) {
      throw new Error('Failed to get canvas context for diff image');
    }
    
    // Create blank diff image
    diffCtx.fillStyle = '#fff';
    diffCtx.fillRect(0, 0, maxWidth, maxHeight);
    
    // Calculate differences
    const diffImageData = diffCtx.createImageData(maxWidth, maxHeight);
    
    let diffPixelCount = 0;
    const totalPixels = maxWidth * maxHeight;
    
    // Compare pixel by pixel
    for (let y = 0; y < maxHeight; y++) {
      for (let x = 0; x < maxWidth; x++) {
        const idx = (y * maxWidth + x) * 4;
        
        // Get pixel colors from both images
        const r1 = imageData1.data[idx];
        const g1 = imageData1.data[idx + 1];
        const b1 = imageData1.data[idx + 2];
        const a1 = imageData1.data[idx + 3];
        
        const r2 = imageData2.data[idx];
        const g2 = imageData2.data[idx + 1];
        const b2 = imageData2.data[idx + 2];
        const a2 = imageData2.data[idx + 3];
        
        // Calculate color distance (Euclidean distance in RGB space)
        const colorDiff = Math.sqrt(
          Math.pow((r1 || 0) - (r2 || 0), 2) +
          Math.pow((g1 || 0) - (g2 || 0), 2) +
          Math.pow((b1 || 0) - (b2 || 0), 2) +
          Math.pow((a1 || 0) - (a2 || 0), 2) / 255
        );
        
        // Consider it different if the color difference is significant
        const isDifferent = colorDiff > 10; // Threshold for color difference
        
        if (isDifferent) {
          diffPixelCount++;
          
          if (highlightDifferences) {
            // Mark different pixels in red
            diffImageData.data[idx] = 255; // R
            diffImageData.data[idx + 1] = 0; // G
            diffImageData.data[idx + 2] = 0; // B
            diffImageData.data[idx + 3] = 255; // A
          } else {
            // Copy pixels from the second image
            diffImageData.data[idx] = r2 || 0;
            diffImageData.data[idx + 1] = g2 || 0;
            diffImageData.data[idx + 2] = b2 || 0;
            diffImageData.data[idx + 3] = a2 || 0;
          }
        } else {
          // Copy pixels from the second image
          diffImageData.data[idx] = r2 || 0;
          diffImageData.data[idx + 1] = g2 || 0;
          diffImageData.data[idx + 2] = b2 || 0;
          diffImageData.data[idx + 3] = a2 || 0;
        }
      }
    }
    
    // Put diff image data
    diffCtx.putImageData(diffImageData, 0, 0);
    
    // Calculate difference percentage
    const diffPercentage = (diffPixelCount / totalPixels) * 100;
    
    // Check if images match
    const matches = diffPercentage <= threshold;
    
    // Save diff image if output path is provided
    let diffPath: string | undefined;
    
    if (options.outputPath) {
      // Get diff image data
      const diffDataUrl = diffCanvas.toDataURL('image/png');
      const diffData = this.stripBase64Header(diffDataUrl);
      
      // Save diff image
      await CSFileUtils.writeFile(
        options.outputPath,
        Buffer.from(diffData, 'base64')
      );
      
      diffPath = options.outputPath;
    }
    
    // Return result
    return {
      matches,
      diffPercentage,
      diffPath,
      dimensions: { width: maxWidth, height: maxHeight }
    };
  }
  
  /**
   * Creates a canvas from image data
   * 
   * @param data Image binary data
   * @param format Image format
   * @returns Promise resolving to canvas element
   */
  private async createCanvasFromImageData(data: Uint8Array, format: ScreenshotFormat): Promise<HTMLCanvasElement> {
    const img = await this.createImageFromImageData(data, format);
    
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      throw new Error('Failed to get canvas context');
    }
    
    ctx.drawImage(img, 0, 0);
    
    return canvas;
  }
  
  /**
   * Creates an image element from image data
   * 
   * @param data Image binary data
   * @param format Image format
   * @returns Promise resolving to image element
   */
  private async createImageFromImageData(data: Uint8Array, format: ScreenshotFormat): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Failed to load image from binary data'));
      
      const blob = new Blob([data], { type: `image/${format}` });
      img.src = URL.createObjectURL(blob);
    });
  }
  
  /**
   * Loads the html2canvas library
   * 
   * @returns Promise resolving to html2canvas function
   */
  private async loadHtml2Canvas(): Promise<any> {
    // Check if html2canvas is already loaded
    if (typeof window !== 'undefined' && (window as any).html2canvas) {
      return (window as any).html2canvas;
    }
    
    // Load html2canvas
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
      script.async = true;
      
      script.onload = () => {
        if (typeof (window as any).html2canvas === 'function') {
          resolve((window as any).html2canvas);
        } else {
          reject(new Error('Failed to load html2canvas library'));
        }
      };
      
      script.onerror = () => {
        reject(new Error('Failed to load html2canvas library'));
      };
      
      document.head.appendChild(script);
    });
  }
  
  /**
   * Converts base64 data to binary
   * 
   * @param base64 Base64-encoded data
   * @returns Binary data
   */
  private base64ToBinary(base64: string): Uint8Array {
    if (typeof atob === 'function') {
      // Browser environment
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      
      return bytes;
    } else if (typeof Buffer !== 'undefined') {
      // Node.js environment
      return Buffer.from(base64, 'base64');
    } else {
      throw new Error('Base64 conversion is not supported in this environment');
    }
  }
  
  /**
   * Cleans up resources
   */
  public cleanup(): void {
    // Reset counters
    this.screenshotCount = 0;
    
    // Clear references
    this.webDriver = null;
    this.page = null;
    this.webDriverType = null;
  }
  
  /**
   * Gets the count of screenshots taken
   * 
   * @returns Screenshot count
   */
  public getScreenshotCount(): number {
    return this.screenshotCount;
  }
  
  /**
   * Gets the screenshot directory
   * 
   * @returns Screenshot directory
   */
  public getScreenshotDir(): string {
    return this.screenshotDir;
  }
  
  /**
   * Lists all screenshots in the screenshot directory
   * 
   * @returns Promise resolving to array of screenshot paths
   */
  public async listScreenshots(): Promise<string[]> {
    try {
      // Read directory contents
      const dirContents = await CSFileUtils.readDir(this.screenshotDir);
      
      // Filter for image files
      const imageExtensions = ['.png', '.jpg', '.jpeg', '.bmp'];
      
      return dirContents.paths.filter(path => {
        const extension = CSPathUtils.extname(path).toLowerCase();
        return imageExtensions.includes(extension);
      });
    } catch (err) {
      this.logger.error(`Error listing screenshots: ${err.message}`, err);
      return [];
    }
  }
  
  /**
   * Checks if screenshot capabilities are available
   * 
   * @returns True if screenshot capabilities are available
   */
  public isScreenshotCapable(): boolean {
    return !!(this.webDriver || this.page || (typeof document !== 'undefined' && document.body));
  }
  
  /**
   * Deletes a screenshot
   * 
   * @param path Path to the screenshot
   * @returns Promise resolving to true if the screenshot was deleted
   */
  public async deleteScreenshot(path: string): Promise<boolean> {
    try {
      await CSFileUtils.deleteFile(path);
      return true;
    } catch (err) {
      this.logger.error(`Error deleting screenshot: ${err.message}`, err);
      return false;
    }
  }
  
  /**
   * Creates an animated GIF from a sequence of screenshots
   * 
   * @param screenshotPaths Array of screenshot paths
   * @param outputPath Output path for the GIF
   * @param options Options for the GIF
   * @returns Promise resolving to the output path
   */
  public async createAnimatedGif(
    screenshotPaths: string[],
    outputPath: string,
    options: {
      delay?: number;
      repeat?: number;
      quality?: number;
      width?: number;
      height?: number;
    } = {}
  ): Promise<string> {
    try {
      // Check if GIF.js is available or load it
      const GIF = await this.loadGifJs();
      
      // Load screenshots
      const images: HTMLImageElement[] = await Promise.all(
        screenshotPaths.map(async path => {
          const data = await CSFileUtils.readFile(path) as Buffer;
          return this.createImageFromImageData(data, this.getFormatFromPath(path));
        })
      );
      
      // Apply default options
      const delay = options.delay || 200; // 200ms between frames
      const repeat = options.repeat ?? 0; // 0 = loop forever
      const quality = options.quality || 10; // 10 = high quality
      
      // Create GIF
      const gif = new GIF({
        workers: 2,
        quality,
        repeat,
        width: options.width,
        height: options.height,
        workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
      });
      
      // Add frames
      for (const img of images) {
        gif.addFrame(img, { delay });
      }
      
      // Render GIF
      const blob = await new Promise<Blob>((resolve, reject) => {
        gif.on('finished', (blob: Blob) => {
          resolve(blob);
        });
        
        gif.on('error', (err: Error) => {
          reject(err);
        });
        
        gif.render();
      });
      
      // Convert blob to buffer
      const arrayBuffer = await blob.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      
      // Save GIF
      await CSFileUtils.writeFile(outputPath, buffer);
      
      return outputPath;
    } catch (err) {
      this.logger.error(`Error creating animated GIF: ${err.message}`, err);
      throw err;
    }
  }
  
  /**
   * Loads the GIF.js library
   * 
   * @returns Promise resolving to GIF.js constructor
   */
  private async loadGifJs(): Promise<any> {
    // Check if GIF.js is already loaded
    if (typeof window !== 'undefined' && (window as any).GIF) {
      return (window as any).GIF;
    }
    
    // Load GIF.js
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js';
      script.async = true;
      
      script.onload = () => {
        if (typeof (window as any).GIF === 'function') {
          resolve((window as any).GIF);
        } else {
          reject(new Error('Failed to load GIF.js library'));
        }
      };
      
      script.onerror = () => {
        reject(new Error('Failed to load GIF.js library'));
      };
      
      document.head.appendChild(script);
    });
  }
  
  /**
   * Gets the format from a file path
   * 
   * @param path File path
   * @returns Screenshot format
   */
  private getFormatFromPath(path: string): ScreenshotFormat {
    const extension = CSPathUtils.extname(path).toLowerCase();
    
    if (extension === '.jpg' || extension === '.jpeg') {
      return ScreenshotFormat.JPEG;
    } else if (extension === '.bmp') {
      return ScreenshotFormat.BMP;
    } else {
      return ScreenshotFormat.PNG;
    }
  }
  
  /**
   * Resizes a screenshot
   * 
   * @param sourcePath Source screenshot path
   * @param targetPath Target screenshot path
   * @param width Target width
   * @param height Target height
   * @param options Resize options
   * @returns Promise resolving to the target path
   */
  public async resizeScreenshot(
    sourcePath: string,
    targetPath: string,
    width: number,
    height: number,
    options: {
      preserveAspectRatio?: boolean;
      format?: ScreenshotFormat;
      quality?: number;
    } = {}
  ): Promise<string> {
    try {
      // Apply default options
      const preserveAspectRatio = options.preserveAspectRatio !== false;
      const format = options.format || this.getFormatFromPath(sourcePath);
      const quality = options.quality || 90;
      
      // Load source image
      const sourceData = await CSFileUtils.readFile(sourcePath) as Buffer;
      const sourceImage = await this.createImageFromImageData(sourceData, this.getFormatFromPath(sourcePath));
      
      // Calculate dimensions
      let targetWidth = width;
      let targetHeight = height;
      
      if (preserveAspectRatio) {
        const aspectRatio = sourceImage.width / sourceImage.height;
        
        if (width / height > aspectRatio) {
          // Height is the limiting factor
          targetWidth = Math.round(height * aspectRatio);
          targetHeight = height;
        } else {
          // Width is the limiting factor
          targetWidth = width;
          targetHeight = Math.round(width / aspectRatio);
        }
      }
      
      // Create canvas for resizing
      const canvas = document.createElement('canvas');
      canvas.width = targetWidth;
      canvas.height = targetHeight;
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        throw new Error('Failed to get canvas context for resizing');
      }
      
      // Draw image with resizing
      ctx.drawImage(sourceImage, 0, 0, targetWidth, targetHeight);
      
      // Get resized image data
      const mimeType = `image/${format}`;
      const dataUrl = canvas.toDataURL(
        mimeType,
        format === ScreenshotFormat.JPEG ? quality / 100 : undefined
      );
      
      // Strip data URL header
      const base64Data = this.stripBase64Header(dataUrl);
      
      // Save resized image
      await CSFileUtils.writeFile(
        targetPath,
        Buffer.from(base64Data, 'base64')
      );
      
      return targetPath;
    } catch (err) {
      this.logger.error(`Error resizing screenshot: ${err.message}`, err);
      throw err;
    }
  }
  
  /**
   * Crops a screenshot
   * 
   * @param sourcePath Source screenshot path
   * @param targetPath Target screenshot path
   * @param x X coordinate
   * @param y Y coordinate
   * @param width Width
   * @param height Height
   * @param options Crop options
   * @returns Promise resolving to the target path
   */
  public async cropScreenshot(
    sourcePath: string,
    targetPath: string,
    x: number,
    y: number,
    width: number,
    height: number,
    options: {
      format?: ScreenshotFormat;
      quality?: number;
    } = {}
  ): Promise<string> {
    try {
      // Apply default options
      const format = options.format || this.getFormatFromPath(sourcePath);
      const quality = options.quality || 90;
      
      // Load source image
      const sourceData = await CSFileUtils.readFile(sourcePath) as Buffer;
      const sourceImage = await this.createImageFromImageData(sourceData, this.getFormatFromPath(sourcePath));
      
      // Validate coordinates
      if (x < 0) x = 0;
      if (y < 0) y = 0;
      if (x + width > sourceImage.width) width = sourceImage.width - x;
      if (y + height > sourceImage.height) height = sourceImage.height - y;
      
      if (width <= 0 || height <= 0) {
        throw new Error('Invalid crop dimensions');
      }
      
      // Create canvas for cropping
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        throw new Error('Failed to get canvas context for cropping');
      }
      
      // Draw image with cropping
      ctx.drawImage(sourceImage, x, y, width, height, 0, 0, width, height);
      
      // Get cropped image data
      const mimeType = `image/${format}`;
      const dataUrl = canvas.toDataURL(
        mimeType,
        format === ScreenshotFormat.JPEG ? quality / 100 : undefined
      );
      
      // Strip data URL header
      const base64Data = this.stripBase64Header(dataUrl);
      
      // Save cropped image
      await CSFileUtils.writeFile(
        targetPath,
        Buffer.from(base64Data, 'base64')
      );
      
      return targetPath;
    } catch (err) {
      this.logger.error(`Error cropping screenshot: ${err.message}`, err);
      throw err;
    }
  }
  
  /**
   * Adds a watermark to a screenshot
   * 
   * @param sourcePath Source screenshot path
   * @param targetPath Target screenshot path
   * @param watermarkText Watermark text
   * @param options Watermark options
   * @returns Promise resolving to the target path
   */
  public async addWatermark(
    sourcePath: string,
    targetPath: string,
    watermarkText: string,
    options: {
      position?: 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight' | 'center';
      fontSize?: number;
      color?: string;
      opacity?: number;
      format?: ScreenshotFormat;
      quality?: number;
    } = {}
  ): Promise<string> {
    try {
      // Apply default options
      const position = options.position || 'bottomRight';
      const fontSize = options.fontSize || 24;
      const color = options.color || 'rgba(255, 255, 255, 0.7)';
      const opacity = options.opacity || 0.7;
      const format = options.format || this.getFormatFromPath(sourcePath);
      const quality = options.quality || 90;
      
      // Load source image
      const sourceData = await CSFileUtils.readFile(sourcePath) as Buffer;
      const sourceImage = await this.createImageFromImageData(sourceData, this.getFormatFromPath(sourcePath));
      
      // Create canvas for watermarking
      const canvas = document.createElement('canvas');
      canvas.width = sourceImage.width;
      canvas.height = sourceImage.height;
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        throw new Error('Failed to get canvas context for watermarking');
      }
      
      // Draw original image
      ctx.drawImage(sourceImage, 0, 0);
      
      // Configure text settings
      ctx.font = `${fontSize}px Arial`;
      ctx.fillStyle = color;
      ctx.globalAlpha = opacity;
      
      // Calculate text metrics
      const metrics = ctx.measureText(watermarkText);
      const textWidth = metrics.width;
      const textHeight = fontSize;
      
      // Position the text
      let x = 0;
      let y = 0;
      
      const padding = 20;
      
      switch (position) {
        case 'topLeft':
          x = padding;
          y = textHeight + padding;
          break;
        case 'topRight':
          x = canvas.width - textWidth - padding;
          y = textHeight + padding;
          break;
        case 'bottomLeft':
          x = padding;
          y = canvas.height - padding;
          break;
        case 'bottomRight':
          x = canvas.width - textWidth - padding;
          y = canvas.height - padding;
          break;
        case 'center':
          x = (canvas.width - textWidth) / 2;
          y = (canvas.height + textHeight) / 2;
          break;
      }
      
      // Draw the watermark text
      ctx.fillText(watermarkText, x, y);
      
      // Reset global alpha
      ctx.globalAlpha = 1.0;
      
      // Get watermarked image data
      const mimeType = `image/${format}`;
      const dataUrl = canvas.toDataURL(
        mimeType,
        format === ScreenshotFormat.JPEG ? quality / 100 : undefined
      );
      
      // Strip data URL header
      const base64Data = this.stripBase64Header(dataUrl);
      
      // Save watermarked image
      await CSFileUtils.writeFile(
        targetPath,
        Buffer.from(base64Data, 'base64')
      );
      
      return targetPath;
    } catch (err) {
      this.logger.error(`Error adding watermark to screenshot: ${err.message}`, err);
      throw err;
    }
  }
}

// Extend window interface for browser environment
declare global {
  interface Window {
    fs?: {
      writeFile: (path: string, data: ArrayBuffer | string, options?: { encoding?: string }) => Promise<void>;
    };
  }
}

export default CSScreenshotManager;


/**
 * CSDataSource.ts
 * 
 * Interface for data sources in the CSTestForge framework.
 * Defines the contract for data source implementations.
 */

/**
 * Data source options
 */
export interface CSDataSourceOptions {
  /** Path to the data source file or connection string */
  source: string;
  /** Sheet name (for Excel data sources) */
  sheetName?: string;
  /** Sheet index (for Excel data sources) */
  sheetIndex?: number;
  /** Delimiter character (for CSV data sources) */
  delimiter?: string;
  /** Whether the first row contains headers (for tabular data sources) */
  hasHeader?: boolean;
  /** Database query (for database data sources) */
  query?: string;
  /** Connection timeout in milliseconds (for database data sources) */
  timeout?: number;
  /** Authentication credentials (for database or API data sources) */
  credentials?: {
    username?: string;
    password?: string;
    token?: string;
  };
  /** Data mapping function to transform raw data */
  mapper?: (data: any) => any;
  /** Column mapping to rename or rearrange columns */
  columnMapping?: Record<string, string>;
  /** Filters to apply to the data */
  filters?: Array<{
    /** Column/field to filter on */
    field: string;
    /** Operator for the filter */
    operator: '=' | '!=' | '>' | '>=' | '<' | '<=' | 'contains' | 'startsWith' | 'endsWith' | 'matches';
    /** Value to compare against */
    value: any;
  }>;
  /** Custom properties for specific data source implementations */
  [key: string]: any;
}

/**
 * Interface for data sources
 */
export interface CSDataSource {
  /**
   * Initializes the data source
   * 
   * @param options Data source options
   * @returns Promise resolving when initialization is complete
   */
  initialize(options: CSDataSourceOptions): Promise<void>;
  
  /**
   * Retrieves all data from the source
   * 
   * @returns Promise resolving to the data
   */
  getAllData(): Promise<Array<Record<string, any>>>;
  
  /**
   * Retrieves data for a specific test
   * 
   * @param testName Name of the test
   * @returns Promise resolving to the data for the test
   */
  getDataForTest(testName: string): Promise<Array<Record<string, any>>>;
  
  /**
   * Retrieves data for a specific test method
   * 
   * @param testName Name of the test
   * @param methodName Name of the test method
   * @returns Promise resolving to the data for the test method
   */
  getDataForTestMethod(testName: string, methodName: string): Promise<Array<Record<string, any>>>;
  
  /**
   * Retrieves filtered data based on criteria
   * 
   * @param filters Filters to apply
   * @returns Promise resolving to the filtered data
   */
  getFilteredData(filters: Array<{
    field: string;
    operator: '=' | '!=' | '>' | '>=' | '<' | '<=' | 'contains' | 'startsWith' | 'endsWith' | 'matches';
    value: any;
  }>): Promise<Array<Record<string, any>>>;
  
  /**
   * Closes the data source and releases resources
   * 
   * @returns Promise resolving when the data source is closed
   */
  close(): Promise<void>;
  
  /**
   * Gets information about the data source structure
   * 
   * @returns Promise resolving to information about the data source
   */
  getMetadata(): Promise<{
    /** Source type (e.g., 'csv', 'excel', 'json', 'database') */
    type: string;
    /** Available fields/columns in the data source */
    fields: Array<{
      /** Field/column name */
      name: string;
      /** Field/column data type */
      type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
    }>;
    /** Total number of records in the data source */
    totalRecords: number;
    /** Additional metadata specific to the data source type */
    [key: string]: any;
  }>;
}


/**
 * CSDataProvider.ts
 * 
 * Data provider decorator for test methods.
 * Enables data-driven testing with various data sources.
 */

import { CSDataSourceOptions } from './interfaces/CSDataSource';
import { CSDataSourceFactory } from './CSDataSourceFactory';
import CSLogger from '../utils/CSLogger';

/**
 * Data provider registry to store mappings between test methods and data providers
 */
export class CSDataProviderRegistry {
  private static instance: CSDataProviderRegistry;
  private registry: Map<string, CSDataProviderConfig> = new Map();
  private logger = CSLogger.getInstance();
  
  /**
   * Gets the singleton instance of the registry
   * 
   * @returns Registry instance
   */
  public static getInstance(): CSDataProviderRegistry {
    if (!CSDataProviderRegistry.instance) {
      CSDataProviderRegistry.instance = new CSDataProviderRegistry();
    }
    
    return CSDataProviderRegistry.instance;
  }
  
  /**
   * Registers a data provider for a test method
   * 
   * @param target Target class
   * @param methodName Method name
   * @param config Data provider configuration
   */
  public register(target: any, methodName: string, config: CSDataProviderConfig): void {
    const className = target.constructor.name;
    const fullName = `${className}.${methodName}`;
    
    this.logger.debug(`Registering data provider for ${fullName}`, config);
    this.registry.set(fullName, config);
  }
  
  /**
   * Gets a data provider configuration for a test method
   * 
   * @param target Target class
   * @param methodName Method name
   * @returns Data provider configuration
   */
  public getConfig(target: any, methodName: string): CSDataProviderConfig | undefined {
    const className = target.constructor.name;
    const fullName = `${className}.${methodName}`;
    
    return this.registry.get(fullName);
  }
  
  /**
   * Gets all registered data providers
   * 
   * @returns Map of data provider configurations
   */
  public getAllConfigs(): Map<string, CSDataProviderConfig> {
    return new Map(this.registry);
  }
  
  /**
   * Clears all registered data providers
   */
  public clear(): void {
    this.registry.clear();
  }
}

/**
 * Data provider configuration
 */
export interface CSDataProviderConfig {
  /** Data source type */
  type: 'csv' | 'excel' | 'json' | 'database' | 'api' | 'custom';
  /** Data source options */
  options: CSDataSourceOptions;
  /** Name of the data provider (for reference) */
  name?: string;
  /** Description of the data provider */
  description?: string;
  /** Whether to ignore the test if no data is available */
  ignoreIfNoData?: boolean;
  /** Whether to fail the test if no data is available */
  failIfNoData?: boolean;
  /** Number of parallel threads for execution (0 = sequential) */
  parallelThreads?: number;
  /** Function to iterate through data (for custom data providers) */
  iterateFunction?: (testName: string, methodName: string) => Promise<Array<Record<string, any>>>;
}

/**
 * Method decorator for data-driven tests
 * 
 * @param config Data provider configuration
 * @returns Method decorator
 * 
 * @example
 * ```typescript
 * class MyTest {
 *   @CSDataProvider({
 *     type: 'csv',
 *     options: {
 *       source: './data/test-data.csv',
 *       hasHeader: true
 *     }
 *   })
 *   async testWithData(data: Record<string, any>) {
 *     // Test implementation using data
 *   }
 * }
 * ```
 */
export function CSDataProvider(config: CSDataProviderConfig): MethodDecorator {
  return (target: Object, methodName: string | symbol, descriptor: PropertyDescriptor) => {
    const originalMethod = descriptor.value;
    
    // Register the data provider configuration
    CSDataProviderRegistry.getInstance().register(target, methodName as string, config);
    
    // Replace the original method with the data provider wrapper
    descriptor.value = async function(...args: any[]) {
      const logger = CSLogger.getInstance();
      
      try {
        // Create data source using factory
        const dataSourceFactory = new CSDataSourceFactory();
        const dataSource = await dataSourceFactory.createDataSource(config.type, config.options);
        
        // Get data for the test method
        let testData: Array<Record<string, any>>;
        
        if (config.iterateFunction) {
          // Use custom iteration function
          testData = await config.iterateFunction(target.constructor.name, methodName as string);
        } else {
          // Use standard data source
          testData = await dataSource.getDataForTestMethod(target.constructor.name, methodName as string);
        }
        
        // Check if data is available
        if (!testData || testData.length === 0) {
          if (config.failIfNoData) {
            throw new Error(`No data available for test method ${target.constructor.name}.${methodName}`);
          }
          
          if (config.ignoreIfNoData) {
            logger.info(`Ignoring test method ${target.constructor.name}.${methodName} due to no data available`);
            return;
          }
          
          // Execute with original arguments if no data provider data available
          logger.info(`No data available for test method ${target.constructor.name}.${methodName}, executing with original arguments`);
          return await originalMethod.apply(this, args);
        }
        
        // Execute the test method for each data set
        const results: any[] = [];
        
        if (config.parallelThreads && config.parallelThreads > 0) {
          // Execute in parallel
          const parallelPromises = testData.map(data => {
            return originalMethod.apply(this, [data, ...args]);
          });
          
          // Wait for all parallel executions to complete
          const parallelResults = await Promise.all(parallelPromises);
          results.push(...parallelResults);
        } else {
          // Execute sequentially
          for (const data of testData) {
            const result = await originalMethod.apply(this, [data, ...args]);
            results.push(result);
          }
        }
        
        // Close the data source
        await dataSource.close();
        
        return results;
      } catch (error) {
        logger.error(`Error executing data provider for ${target.constructor.name}.${methodName}`, error);
        throw error;
      }
    };
    
    return descriptor;
  };
}

/**
 * Processes test methods with data providers
 */
export class CSDataProviderProcessor {
  private logger = CSLogger.getInstance();
  
  /**
   * Executes a test method with its data provider
   * 
   * @param target Target class instance
   * @param methodName Method name
   * @param args Method arguments
   * @returns Promise resolving to method results
   */
  public async executeTestMethod(target: any, methodName: string, ...args: any[]): Promise<any[]> {
    try {
      // Get data provider configuration for the method
      const config = CSDataProviderRegistry.getInstance().getConfig(target, methodName);
      
      if (!config) {
        // No data provider, execute the method directly
        const method = target[methodName];
        const result = await method.apply(target, args);
        return [result];
      }
      
      // Create data source using factory
      const dataSourceFactory = new CSDataSourceFactory();
      const dataSource = await dataSourceFactory.createDataSource(config.type, config.options);
      
      // Get data for the test method
      let testData: Array<Record<string, any>>;
      
      if (config.iterateFunction) {
        // Use custom iteration function
        testData = await config.iterateFunction(target.constructor.name, methodName);
      } else {
        // Use standard data source
        testData = await dataSource.getDataForTestMethod(target.constructor.name, methodName);
      }
      
      // Check if data is available
      if (!testData || testData.length === 0) {
        if (config.failIfNoData) {
          throw new Error(`No data available for test method ${target.constructor.name}.${methodName}`);
        }
        
        if (config.ignoreIfNoData) {
          this.logger.info(`Ignoring test method ${target.constructor.name}.${methodName} due to no data available`);
          return [];
        }
        
        // Execute with original arguments if no data provider data available
        this.logger.info(`No data available for test method ${target.constructor.name}.${methodName}, executing with original arguments`);
        const method = target[methodName];
        const result = await method.apply(target, args);
        return [result];
      }
      
      // Execute the test method for each data set
      const results: any[] = [];
      const method = target[methodName];
      
      if (config.parallelThreads && config.parallelThreads > 0) {
        // Execute in parallel
        const parallelPromises = testData.map(data => {
          return method.apply(target, [data, ...args]);
        });
        
        // Wait for all parallel executions to complete
        const parallelResults = await Promise.all(parallelPromises);
        results.push(...parallelResults);
      } else {
        // Execute sequentially
        for (const data of testData) {
          const result = await method.apply(target, [data, ...args]);
          results.push(result);
        }
      }
      
      // Close the data source
      await dataSource.close();
      
      return results;
    } catch (error) {
      this.logger.error(`Error executing data provider for ${target.constructor.name}.${methodName}`, error);
      throw error;
    }
  }
  
  /**
   * Gets all test methods with data providers
   * 
   * @param target Target class
   * @returns Array of method names with data providers
   */
  public getDataProviderMethods(target: any): string[] {
    const registry = CSDataProviderRegistry.getInstance();
    const configs = registry.getAllConfigs();
    const className = target.constructor.name;
    
    const methods: string[] = [];
    
    for (const [key, _] of configs) {
      const [configClassName, methodName] = key.split('.');
      
      if (configClassName === className) {
        methods.push(methodName);
      }
    }
    
    return methods;
  }
  
  /**
   * Gets the data provider configuration for a test method
   * 
   * @param target Target class
   * @param methodName Method name
   * @returns Data provider configuration
   */
  public getDataProviderConfig(target: any, methodName: string): CSDataProviderConfig | undefined {
    return CSDataProviderRegistry.getInstance().getConfig(target, methodName);
  }
  
  /**
   * Checks if a test method has a data provider
   * 
   * @param target Target class
   * @param methodName Method name
   * @returns True if the method has a data provider
   */
  public hasDataProvider(target: any, methodName: string): boolean {
    return !!CSDataProviderRegistry.getInstance().getConfig(target, methodName);
  }
}

export default CSDataProvider;



/**
 * CSDataSourceFactory.ts
 * 
 * Factory for creating data sources in the CSTestForge framework.
 * Instantiates appropriate data source based on type and configuration.
 */

import { CSDataSource, CSDataSourceOptions } from './interfaces/CSDataSource';
import CSLogger from '../utils/CSLogger';

/**
 * Factory for creating data sources
 */
export class CSDataSourceFactory {
  private logger = CSLogger.getInstance();
  
  /**
   * Creates a data source based on type and options
   * 
   * @param type Data source type
   * @param options Data source options
   * @returns Promise resolving to the created data source
   */
  public async createDataSource(
    type: 'csv' | 'excel' | 'json' | 'database' | 'api' | 'custom',
    options: CSDataSourceOptions
  ): Promise<CSDataSource> {
    try {
      let dataSource: CSDataSource;
      
      switch (type) {
        case 'csv':
          dataSource = await this.createCsvDataSource();
          break;
        case 'excel':
          dataSource = await this.createExcelDataSource();
          break;
        case 'json':
          dataSource = await this.createJsonDataSource();
          break;
        case 'database':
          dataSource = await this.createDatabaseDataSource();
          break;
        case 'api':
          dataSource = await this.createApiDataSource();
          break;
        case 'custom':
          dataSource = await this.createCustomDataSource(options);
          break;
        default:
          throw new Error(`Unsupported data source type: ${type}`);
      }
      
      // Initialize the data source
      await dataSource.initialize(options);
      
      return dataSource;
    } catch (error) {
      this.logger.error(`Error creating data source: ${error.message}`, error);
      throw error;
    }
  }
  
  /**
   * Creates a CSV data source
   * 
   * @returns Promise resolving to the CSV data source
   */
  private async createCsvDataSource(): Promise<CSDataSource> {
    try {
      // Dynamically import the CSV data source to avoid bundling issues
      const module = await import('./sources/CSCsvDataSource');
      return new module.default();
    } catch (error) {
      this.logger.error(`Error creating CSV data source: ${error.message}`, error);
      throw error;
    }
  }
  
  /**
   * Creates an Excel data source
   * 
   * @returns Promise resolving to the Excel data source
   */
  private async createExcelDataSource(): Promise<CSDataSource> {
    try {
      // Dynamically import the Excel data source to avoid bundling issues
      const module = await import('./sources/CSExcelDataSource');
      return new module.default();
    } catch (error) {
      this.logger.error(`Error creating Excel data source: ${error.message}`, error);
      throw error;
    }
  }
  
  /**
   * Creates a JSON data source
   * 
   * @returns Promise resolving to the JSON data source
   */
  private async createJsonDataSource(): Promise<CSDataSource> {
    try {
      // Dynamically import the JSON data source to avoid bundling issues
      const module = await import('./sources/CSJsonDataSource');
      return new module.default();
    } catch (error) {
      this.logger.error(`Error creating JSON data source: ${error.message}`, error);
      throw error;
    }
  }
  
  /**
   * Creates a database data source
   * 
   * @returns Promise resolving to the database data source
   */
  private async createDatabaseDataSource(): Promise<CSDataSource> {
    try {
      // Dynamically import the database data source to avoid bundling issues
      const module = await import('./sources/CSDatabaseDataSource');
      return new module.default();
    } catch (error) {
      this.logger.error(`Error creating database data source: ${error.message}`, error);
      throw error;
    }
  }
  
  /**
   * Creates an API data source
   * 
   * @returns Promise resolving to the API data source
   */
  private async createApiDataSource(): Promise<CSDataSource> {
    try {
      // Dynamically import the API data source to avoid bundling issues
      const module = await import('./sources/CSApiDataSource');
      return new module.default();
    } catch (error) {
      this.logger.error(`Error creating API data source: ${error.message}`, error);
      throw error;
    }
  }
  
  /**
   * Creates a custom data source
   * 
   * @param options Data source options
   * @returns Promise resolving to the custom data source
   */
  private async createCustomDataSource(options: CSDataSourceOptions): Promise<CSDataSource> {
    try {
      // Check if custom data source class is provided
      if (!options.customDataSourceClass) {
        throw new Error('Custom data source class is required for custom data source type');
      }
      
      // Dynamically import or instantiate the custom data source
      if (typeof options.customDataSourceClass === 'string') {
        // Import by path
        const module = await import(options.customDataSourceClass);
        return new module.default();
      } else {
        // Use provided class
        return new options.customDataSourceClass();
      }
    } catch (error) {
      this.logger.error(`Error creating custom data source: ${error.message}`, error);
      throw error;
    }
  }
  
  /**
   * Registers a custom data source type
   * 
   * @param type Custom data source type
   * @param dataSourceClass Data source class
   */
  public registerCustomDataSourceType(type: string, dataSourceClass: new () => CSDataSource): void {
    try {
      // Register the custom data source type
      CSDataSourceFactory.customDataSources.set(type, dataSourceClass);
      this.logger.info(`Registered custom data source type: ${type}`);
    } catch (error) {
      this.logger.error(`Error registering custom data source type: ${error.message}`, error);
      throw error;
    }
  }
  
  /**
   * Gets a registered custom data source type
   * 
   * @param type Custom data source type
   * @returns Data source class
   */
  public getCustomDataSourceType(type: string): (new () => CSDataSource) | undefined {
    return CSDataSourceFactory.customDataSources.get(type);
  }
  
  /**
   * Registry for custom data source types
   */
  private static customDataSources: Map<string, new () => CSDataSource> = new Map();
}

// Add custom data source class property to options
declare module './interfaces/CSDataSource' {
  interface CSDataSourceOptions {
    /** Custom data source class (for custom data source type) */
    customDataSourceClass?: string | (new () => CSDataSource);
  }
}

export default CSDataSourceFactory;


