CSPresenceWait.java
--------------------------------

package com.cstestforge.framework.playwright.java.wait;

import com.cstestforge.framework.core.config.FrameworkConfig;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.ElementHandle;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.TimeoutError;
import com.microsoft.playwright.options.WaitForSelectorState;

/**
 * Implementation of a wait strategy that checks for the presence of an element in the DOM.
 * This differs from visibility wait as it only checks if the element exists in the DOM,
 * not whether it's visible to the user.
 */
public class CSPresenceWait extends CSAbstractWaitStrategy {

    private static final CSLogger logger = CSLogger.getLogger(CSPresenceWait.class);

    /**
     * Constructor with default timeout from framework configuration.
     * 
     * @param page The Playwright Page instance
     */
    public CSPresenceWait(Page page) {
        super(page, FrameworkConfig.getInstance().getDefaultTimeoutSeconds());
    }

    /**
     * Constructor with custom timeout.
     * 
     * @param page The Playwright Page instance
     * @param timeoutSeconds Custom timeout in seconds
     */
    public CSPresenceWait(Page page, int timeoutSeconds) {
        super(page, timeoutSeconds);
    }

    /**
     * Waits until the specified element is present in the DOM.
     * 
     * @param locator The locator to find the element
     * @return true if the element is present, false otherwise
     */
    @Override
    public boolean waitForElement(String locator) {
        try {
            // Convert timeout from seconds to milliseconds
            int timeoutMs = getTimeoutSeconds() * 1000;
            logger.debug("Waiting for element presence using locator: " + locator);
            
            // Use the Playwright Page's waitForSelector method with state "attached"
            // which means the element is present in the DOM (but may not be visible)
            ElementHandle element = page.waitForSelector(locator, 
                new Page.WaitForSelectorOptions()
                    .setState(WaitForSelectorState.ATTACHED)
                    .setTimeout(timeoutMs));
            
            return element != null;
        } catch (TimeoutError e) {
            logger.warn("Timed out waiting for element presence: " + locator, e);
            return false;
        } catch (Exception e) {
            logger.error("Error while waiting for element presence: " + locator, e);
            return false;
        }
    }

    /**
     * Waits until the specified Locator is present in the DOM.
     * 
     * @param locator The Playwright Locator object
     * @return true if the element is present, false otherwise
     */
    public boolean waitForElement(Locator locator) {
        try {
            // Convert timeout from seconds to milliseconds
            int timeoutMs = getTimeoutSeconds() * 1000;
            logger.debug("Waiting for element presence using Playwright Locator");
            
            // Use Playwright Locator's waitFor method to wait for the element to be attached
            locator.waitFor(new Locator.WaitForOptions()
                .setState(WaitForSelectorState.ATTACHED)
                .setTimeout(timeoutMs));
            
            return true;
        } catch (TimeoutError e) {
            logger.warn("Timed out waiting for locator element presence", e);
            return false;
        } catch (Exception e) {
            logger.error("Error while waiting for locator element presence", e);
            return false;
        }
    }

    /**
     * Waits until the specified element is present and returns it.
     * 
     * @param locator The locator to find the element
     * @return The ElementHandle if present, null otherwise
     */
    public ElementHandle waitForElementAndGet(String locator) {
        try {
            // Convert timeout from seconds to milliseconds
            int timeoutMs = getTimeoutSeconds() * 1000;
            logger.debug("Waiting for element presence and getting it: " + locator);
            
            return page.waitForSelector(locator, 
                new Page.WaitForSelectorOptions()
                    .setState(WaitForSelectorState.ATTACHED)
                    .setTimeout(timeoutMs));
        } catch (TimeoutError e) {
            logger.warn("Timed out waiting for element presence: " + locator, e);
            return null;
        } catch (Exception e) {
            logger.error("Error while waiting for element presence: " + locator, e);
            return null;
        }
    }

    /**
     * Waits for multiple elements matching the given locator to be present.
     * 
     * @param locator The locator to match multiple elements
     * @return true if at least one element is present, false otherwise
     */
    public boolean waitForElements(String locator) {
        try {
            // First wait for at least one element to be present
            boolean isPresent = waitForElement(locator);
            if (!isPresent) {
                return false;
            }
            
            // Now check if we actually got any elements
            return page.querySelectorAll(locator).size() > 0;
        } catch (Exception e) {
            logger.error("Error while waiting for elements presence: " + locator, e);
            return false;
        }
    }
}



CSInvisibilityWait.java
----------------------------

package com.cstestforge.framework.playwright.java.wait;

import com.cstestforge.framework.core.config.FrameworkConfig;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.ElementHandle;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.TimeoutError;
import com.microsoft.playwright.options.WaitForSelectorState;

/**
 * Implementation of a wait strategy that checks for the invisibility of an element.
 * This wait strategy can be used to verify that an element is either not present in the DOM
 * or is present but not visible.
 */
public class CSInvisibilityWait extends CSAbstractWaitStrategy {

    private static final CSLogger logger = CSLogger.getLogger(CSInvisibilityWait.class);

    /**
     * Constructor with default timeout from framework configuration.
     * 
     * @param page The Playwright Page instance
     */
    public CSInvisibilityWait(Page page) {
        super(page, FrameworkConfig.getInstance().getDefaultTimeoutSeconds());
    }

    /**
     * Constructor with custom timeout.
     * 
     * @param page The Playwright Page instance
     * @param timeoutSeconds Custom timeout in seconds
     */
    public CSInvisibilityWait(Page page, int timeoutSeconds) {
        super(page, timeoutSeconds);
    }

    /**
     * Waits until the specified element is invisible or not present in the DOM.
     * 
     * @param locator The locator to find the element
     * @return true if the element is invisible or not present, false if it's visible
     */
    @Override
    public boolean waitForElement(String locator) {
        try {
            // Convert timeout from seconds to milliseconds
            int timeoutMs = getTimeoutSeconds() * 1000;
            logger.debug("Waiting for element invisibility using locator: " + locator);
            
            // First check if element exists using a very short timeout
            ElementHandle element;
            try {
                element = page.waitForSelector(locator, 
                    new Page.WaitForSelectorOptions()
                        .setState(WaitForSelectorState.ATTACHED)
                        .setTimeout(100)); // Very short timeout to check existence
            } catch (TimeoutError e) {
                // Element doesn't exist, which means it's "invisible"
                return true;
            }
            
            if (element == null) {
                // Element doesn't exist, which means it's "invisible"
                return true;
            }
            
            // Element exists, now check if it's visible
            boolean isVisible = element.isVisible();
            
            // Start polling to wait until element becomes invisible or timeout
            long startTime = System.currentTimeMillis();
            while (isVisible && (System.currentTimeMillis() - startTime < timeoutMs)) {
                try {
                    Thread.sleep(100); // Poll every 100ms
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    logger.warn("Interrupted while waiting for element invisibility", ie);
                    return false;
                }
                
                try {
                    // Re-check if element still exists
                    element = page.querySelector(locator);
                    if (element == null) {
                        return true; // Element no longer exists
                    }
                    
                    // Re-check visibility
                    isVisible = element.isVisible();
                } catch (Exception e) {
                    // If we get an exception accessing the element, it's likely gone
                    return true;
                }
            }
            
            return !isVisible;
        } catch (Exception e) {
            logger.error("Error while waiting for element invisibility: " + locator, e);
            // We consider an error as the element being invisible
            // since most errors will be due to the element not being found
            return true;
        }
    }

    /**
     * Waits until the specified Locator is invisible or not present.
     * 
     * @param locator The Playwright Locator object
     * @return true if the element is invisible or not present, false if it's visible
     */
    public boolean waitForElement(Locator locator) {
        try {
            // Convert timeout from seconds to milliseconds
            int timeoutMs = getTimeoutSeconds() * 1000;
            logger.debug("Waiting for element invisibility using Playwright Locator");
            
            // First check if the element exists with a count
            int count = locator.count();
            if (count == 0) {
                // No elements found, so it's "invisible"
                return true;
            }
            
            // Element exists, check if it's visible
            boolean isVisible = locator.first().isVisible();
            if (!isVisible) {
                return true; // Already invisible
            }
            
            // Start polling to wait until element becomes invisible or timeout
            long startTime = System.currentTimeMillis();
            while (isVisible && (System.currentTimeMillis() - startTime < timeoutMs)) {
                try {
                    Thread.sleep(100); // Poll every 100ms
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    logger.warn("Interrupted while waiting for locator invisibility", ie);
                    return false;
                }
                
                try {
                    // Re-check count
                    count = locator.count();
                    if (count == 0) {
                        return true; // No elements found
                    }
                    
                    // Re-check visibility
                    isVisible = locator.first().isVisible();
                } catch (Exception e) {
                    // If we get an exception accessing the locator, it's likely gone
                    return true;
                }
            }
            
            return !isVisible;
        } catch (Exception e) {
            logger.error("Error while waiting for locator invisibility", e);
            // We consider an error as the element being invisible
            return true;
        }
    }

    /**
     * Waits until all elements matching the given locator are invisible.
     * 
     * @param locator The locator to match multiple elements
     * @return true if all elements are invisible, false if any are visible
     */
    public boolean waitForAllElementsInvisible(String locator) {
        try {
            // Convert timeout from seconds to milliseconds
            int timeoutMs = getTimeoutSeconds() * 1000;
            logger.debug("Waiting for all elements to be invisible: " + locator);
            
            // Start polling to wait until all elements become invisible or timeout
            long startTime = System.currentTimeMillis();
            while (System.currentTimeMillis() - startTime < timeoutMs) {
                // Get all elements matching the locator
                var elements = page.querySelectorAll(locator);
                
                // If no elements found, they're all "invisible"
                if (elements.isEmpty()) {
                    return true;
                }
                
                // Check if any of the elements are visible
                boolean anyVisible = false;
                for (var element : elements) {
                    if (element.isVisible()) {
                        anyVisible = true;
                        break;
                    }
                }
                
                // If none are visible, we're done
                if (!anyVisible) {
                    return true;
                }
                
                // Wait before next poll
                try {
                    Thread.sleep(100);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    logger.warn("Interrupted while waiting for all elements invisibility", ie);
                    return false;
                }
            }
            
            // Timeout reached, check one last time if all elements are invisible
            var elements = page.querySelectorAll(locator);
            if (elements.isEmpty()) {
                return true;
            }
            
            for (var element : elements) {
                if (element.isVisible()) {
                    return false; // At least one element is still visible
                }
            }
            
            return true; // All elements are invisible
        } catch (Exception e) {
            logger.error("Error while waiting for all elements invisibility: " + locator, e);
            // In case of error, we assume the elements are invisible
            return true;
        }
    }
}



LocatorHealingService.java
---------------------------------

package com.cstestforge.framework.core.selfhealing;

import com.cstestforge.framework.core.config.FrameworkConfig;
import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.JavascriptExecutor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Core service for self-healing locators in the CSTestForge framework.
 * This service maintains a history of successful locators and their element fingerprints,
 * and provides automatic healing of broken locators during test execution.
 */
public class LocatorHealingService {
    private static final CSLogger logger = CSLogger.getLogger(LocatorHealingService.class);
    
    // Singleton instance
    private static LocatorHealingService instance;
    
    // Configuration
    private final boolean healingEnabled;
    private final int maxHistoryPerLocator;
    private final double minSimilarityScore;
    
    // Healing strategies
    private final List<HealingStrategy> healingStrategies;
    
    // Cache of locator history for healing
    private final Map<String, List<ElementFingerprint>> locatorHistory;
    
    // Cache of healed locators for the current test run
    private final Map<String, String> healedLocatorsCache;
    
    // Statistics for reporting
    private int totalHealingAttempts = 0;
    private int successfulHealings = 0;
    private final Map<String, Integer> strategySuccessCount = new HashMap<>();
    
    /**
     * Private constructor to enforce singleton pattern
     */
    private LocatorHealingService() {
        FrameworkConfig config = FrameworkConfig.getInstance();
        this.healingEnabled = config.isSelfHealingEnabled();
        this.maxHistoryPerLocator = config.getMaxLocatorHistorySize();
        this.minSimilarityScore = config.getMinSimilarityScore();
        
        this.locatorHistory = new ConcurrentHashMap<>();
        this.healedLocatorsCache = new ConcurrentHashMap<>();
        
        // Initialize healing strategies in order of preference
        this.healingStrategies = new ArrayList<>();
        this.healingStrategies.add(new AttributeHealingStrategy());
        this.healingStrategies.add(new TextHealingStrategy());
        this.healingStrategies.add(new PositionHealingStrategy());
        this.healingStrategies.add(new StructureHealingStrategy());
        
        // Initialize success counters for each strategy
        for (HealingStrategy strategy : healingStrategies) {
            strategySuccessCount.put(strategy.getClass().getSimpleName(), 0);
        }
        
        logger.info("LocatorHealingService initialized with healing " + 
                   (healingEnabled ? "enabled" : "disabled") + 
                   ", max history: " + maxHistoryPerLocator + 
                   ", min similarity: " + minSimilarityScore);
    }
    
    /**
     * Get the singleton instance of the LocatorHealingService
     * 
     * @return The singleton instance
     */
    public static synchronized LocatorHealingService getInstance() {
        if (instance == null) {
            instance = new LocatorHealingService();
        }
        return instance;
    }
    
    /**
     * Records a successful locator usage by capturing the element's fingerprint.
     * This information is used later for healing broken locators.
     * 
     * @param driver The WebDriver instance
     * @param locator The locator string
     * @param element The successfully located WebElement
     */
    public void recordSuccessfulLocator(WebDriver driver, String locator, WebElement element) {
        if (!healingEnabled) {
            return;
        }
        
        try {
            // Create fingerprint from the element
            ElementFingerprint fingerprint = createFingerprint(driver, element, locator);
            
            // Add to history
            locatorHistory.computeIfAbsent(locator, k -> new ArrayList<>())
                .add(fingerprint);
            
            // Trim history if it exceeds the maximum
            List<ElementFingerprint> history = locatorHistory.get(locator);
            if (history.size() > maxHistoryPerLocator) {
                locatorHistory.put(locator, history.subList(history.size() - maxHistoryPerLocator, history.size()));
            }
            
            logger.debug("Recorded fingerprint for locator: " + locator);
        } catch (Exception e) {
            logger.warn("Failed to record fingerprint for locator: " + locator, e);
        }
    }
    
    /**
     * Attempts to heal a broken locator using historical fingerprints.
     * 
     * @param driver The WebDriver instance
     * @param originalLocator The original locator that failed
     * @return A healed locator, or the original locator if healing was not possible
     */
    public String healLocator(WebDriver driver, String originalLocator) {
        if (!healingEnabled) {
            return originalLocator;
        }
        
        // Increment healing attempt counter
        totalHealingAttempts++;
        
        // Check if we already healed this locator in this session
        if (healedLocatorsCache.containsKey(originalLocator)) {
            String healedLocator = healedLocatorsCache.get(originalLocator);
            logger.debug("Using previously healed locator from cache for: " + originalLocator + " -> " + healedLocator);
            return healedLocator;
        }
        
        // If we have no history for this locator, we can't heal it
        if (!locatorHistory.containsKey(originalLocator)) {
            logger.debug("No history found for locator: " + originalLocator);
            return originalLocator;
        }
        
        List<ElementFingerprint> fingerprints = locatorHistory.get(originalLocator);
        if (fingerprints.isEmpty()) {
            return originalLocator;
        }
        
        // Get the most recent fingerprint
        ElementFingerprint targetFingerprint = fingerprints.get(fingerprints.size() - 1);
        logger.debug("Attempting to heal locator: " + originalLocator + " using fingerprint: " + targetFingerprint);
        
        // Try each healing strategy in order until one works
        for (HealingStrategy strategy : healingStrategies) {
            try {
                String healedLocator = strategy.heal(driver, originalLocator, targetFingerprint);
                
                // If the strategy returned a locator, verify it actually works
                if (healedLocator != null && !healedLocator.equals(originalLocator)) {
                    try {
                        WebElement element = driver.findElement(By.cssSelector(healedLocator));
                        
                        if (element != null) {
                            // Verify the healed element matches the fingerprint
                            ElementFingerprint newFingerprint = createFingerprint(driver, element, healedLocator);
                            double similarity = SimilarityScorer.calculateSimilarity(targetFingerprint, newFingerprint);
                            
                            if (similarity >= minSimilarityScore) {
                                // Cache the successful healed locator
                                healedLocatorsCache.put(originalLocator, healedLocator);
                                
                                // Update statistics
                                successfulHealings++;
                                String strategyName = strategy.getClass().getSimpleName();
                                strategySuccessCount.put(strategyName, strategySuccessCount.get(strategyName) + 1);
                                
                                logger.info("Successfully healed locator: " + originalLocator + " -> " + healedLocator + 
                                           " using strategy: " + strategyName + " with similarity: " + similarity);
                                
                                return healedLocator;
                            } else {
                                logger.debug("Healed locator similarity too low: " + similarity + " < " + minSimilarityScore);
                            }
                        }
                    } catch (NoSuchElementException e) {
                        // The healed locator didn't work
                        logger.debug("Healed locator failed: " + healedLocator, e);
                    }
                }
            } catch (Exception e) {
                logger.warn("Error in healing strategy: " + strategy.getClass().getSimpleName(), e);
            }
        }
        
        // If we get here, healing failed
        logger.info("Failed to heal locator: " + originalLocator);
        return originalLocator;
    }
    
    /**
     * Creates a fingerprint of an element's characteristics for future identification.
     * 
     * @param driver The WebDriver instance
     * @param element The WebElement to fingerprint
     * @param locator The locator used to find the element
     * @return The ElementFingerprint
     */
    private ElementFingerprint createFingerprint(WebDriver driver, WebElement element, String locator) {
        ElementFingerprint fingerprint = new ElementFingerprint();
        
        try {
            // Basic attributes
            fingerprint.setTagName(element.getTagName());
            fingerprint.setId(element.getAttribute("id"));
            fingerprint.setClassName(element.getAttribute("class"));
            fingerprint.setName(element.getAttribute("name"));
            fingerprint.setType(element.getAttribute("type"));
            fingerprint.setValue(element.getAttribute("value"));
            fingerprint.setText(element.getText());
            fingerprint.setHref(element.getAttribute("href"));
            fingerprint.setSrc(element.getAttribute("src"));
            fingerprint.setAlt(element.getAttribute("alt"));
            fingerprint.setTitle(element.getAttribute("title"));
            fingerprint.setRole(element.getAttribute("role"));
            fingerprint.setAriaLabel(element.getAttribute("aria-label"));
            fingerprint.setDataAttributes(getDataAttributes(element));
            
            // Position
            if (element.isDisplayed()) {
                fingerprint.setX(element.getLocation().getX());
                fingerprint.setY(element.getLocation().getY());
                fingerprint.setWidth(element.getSize().getWidth());
                fingerprint.setHeight(element.getSize().getHeight());
            }
            
            // Structure
            fingerprint.setXPath(getXPath(driver, element));
            fingerprint.setParentId(getParentAttribute(element, "id"));
            fingerprint.setParentClass(getParentAttribute(element, "class"));
            fingerprint.setParentTagName(getParentTagName(element));
            
            // CSS properties
            JavascriptExecutor js = (JavascriptExecutor) driver;
            String cssPosition = (String) js.executeScript(
                    "return window.getComputedStyle(arguments[0]).getPropertyValue('position');", element);
            fingerprint.setCssPosition(cssPosition);
            
            // Original locator for reference
            fingerprint.setOriginalLocator(locator);
            
            // Siblings data
            fingerprintSiblings(driver, element, fingerprint);
            
        } catch (Exception e) {
            logger.warn("Error creating element fingerprint", e);
        }
        
        return fingerprint;
    }
    
    /**
     * Gets all data-* attributes of an element.
     * 
     * @param element The WebElement
     * @return Map of data attribute names to values
     */
    private Map<String, String> getDataAttributes(WebElement element) {
        Map<String, String> dataAttributes = new HashMap<>();
        try {
            JavascriptExecutor js = (JavascriptExecutor) element.getWrappedDriver();
            
            @SuppressWarnings("unchecked")
            Map<String, Object> result = (Map<String, Object>) js.executeScript(
                    "var items = {}; " +
                    "for (var i = 0; i < arguments[0].attributes.length; i++) { " +
                    "   var attr = arguments[0].attributes[i]; " +
                    "   if (attr.name.indexOf('data-') === 0) { " +
                    "       items[attr.name] = attr.value; " +
                    "   } " +
                    "} " +
                    "return items;", element);
            
            for (Map.Entry<String, Object> entry : result.entrySet()) {
                dataAttributes.put(entry.getKey(), entry.getValue() != null ? entry.getValue().toString() : null);
            }
        } catch (Exception e) {
            logger.warn("Failed to get data attributes", e);
        }
        return dataAttributes;
    }
    
    /**
     * Gets the XPath for an element.
     * 
     * @param driver The WebDriver
     * @param element The WebElement
     * @return The XPath as a String
     */
    private String getXPath(WebDriver driver, WebElement element) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            return (String) js.executeScript(
                    "function getPathTo(element) { " +
                    "    if (element.id !== '') " +
                    "        return '//*[@id=\"' + element.id + '\"]'; " +
                    "    if (element === document.body) " +
                    "        return '/html/body'; " +
                    "    var ix = 0; " +
                    "    var siblings = element.parentNode.childNodes; " +
                    "    for (var i = 0; i < siblings.length; i++) { " +
                    "        var sibling = siblings[i]; " +
                    "        if (sibling === element) " +
                    "            return getPathTo(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (ix + 1) + ']'; " +
                    "        if (sibling.nodeType === 1 && sibling.tagName === element.tagName) " +
                    "            ix++; " +
                    "    } " +
                    "} " +
                    "return getPathTo(arguments[0]);", element);
        } catch (Exception e) {
            logger.warn("Failed to get XPath", e);
            return null;
        }
    }
    
    /**
     * Gets an attribute from the parent element.
     * 
     * @param element The WebElement
     * @param attribute The attribute name
     * @return The attribute value
     */
    private String getParentAttribute(WebElement element, String attribute) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) element.getWrappedDriver();
            return (String) js.executeScript(
                    "return arguments[0].parentNode." + attribute + ";", element);
        } catch (Exception e) {
            logger.warn("Failed to get parent attribute: " + attribute, e);
            return null;
        }
    }
    
    /**
     * Gets the tag name of the parent element.
     * 
     * @param element The WebElement
     * @return The parent tag name
     */
    private String getParentTagName(WebElement element) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) element.getWrappedDriver();
            return (String) js.executeScript(
                    "return arguments[0].parentNode.tagName;", element);
        } catch (Exception e) {
            logger.warn("Failed to get parent tag name", e);
            return null;
        }
    }
    
    /**
     * Records fingerprint information about element siblings.
     * 
     * @param driver The WebDriver
     * @param element The WebElement
     * @param fingerprint The ElementFingerprint to update
     */
    private void fingerprintSiblings(WebDriver driver, WebElement element, ElementFingerprint fingerprint) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            
            @SuppressWarnings("unchecked")
            List<Map<String, Object>> siblingsData = (List<Map<String, Object>>) js.executeScript(
                    "var siblings = []; " +
                    "var el = arguments[0]; " +
                    "if (el.parentNode) { " +
                    "    var children = el.parentNode.children; " +
                    "    for(var i = 0; i < children.length; i++) { " +
                    "        var child = children[i]; " +
                    "        if(child !== el) { " +
                    "            siblings.push({ " +
                    "                tagName: child.tagName, " +
                    "                id: child.id, " +
                    "                className: child.className, " +
                    "                text: child.textContent, " +
                    "                position: i " +
                    "            }); " +
                    "        } " +
                    "    } " +
                    "} " +
                    "return siblings;", element);
            
            List<Map<String, String>> processedSiblings = new ArrayList<>();
            for (Map<String, Object> sibling : siblingsData) {
                Map<String, String> processedSibling = new HashMap<>();
                for (Map.Entry<String, Object> entry : sibling.entrySet()) {
                    processedSibling.put(entry.getKey(), entry.getValue() != null ? entry.getValue().toString() : null);
                }
                processedSiblings.add(processedSibling);
            }
            
            fingerprint.setSiblingsData(processedSiblings);
            
        } catch (Exception e) {
            logger.warn("Failed to fingerprint siblings", e);
        }
    }
    
    /**
     * Get statistics about the healing performance
     * 
     * @return A map of statistics
     */
    public Map<String, Object> getStatistics() {
        Map<String, Object> stats = new HashMap<>();
        stats.put("totalHealingAttempts", totalHealingAttempts);
        stats.put("successfulHealings", successfulHealings);
        stats.put("successRate", totalHealingAttempts > 0 ? 
                ((double) successfulHealings / totalHealingAttempts) * 100.0 : 0.0);
        stats.put("strategySuccessCounts", strategySuccessCount);
        
        // Calculate strategy success percentages
        Map<String, Double> strategySuccessPercentages = new HashMap<>();
        for (Map.Entry<String, Integer> entry : strategySuccessCount.entrySet()) {
            double percentage = successfulHealings > 0 ? 
                    ((double) entry.getValue() / successfulHealings) * 100.0 : 0.0;
            strategySuccessPercentages.put(entry.getKey(), percentage);
        }
        stats.put("strategySuccessPercentages", strategySuccessPercentages);
        
        // Add cache sizes
        stats.put("locatorHistorySize", locatorHistory.size());
        stats.put("healedLocatorsCacheSize", healedLocatorsCache.size());
        
        return stats;
    }
    
    /**
     * Clears all stored history and caches
     */
    public void clearAll() {
        locatorHistory.clear();
        healedLocatorsCache.clear();
        totalHealingAttempts = 0;
        successfulHealings = 0;
        for (String key : strategySuccessCount.keySet()) {
            strategySuccessCount.put(key, 0);
        }
        logger.info("LocatorHealingService cleared all history and caches");
    }
    
    /**
     * Checks if healing is enabled
     * 
     * @return true if healing is enabled, false otherwise
     */
    public boolean isHealingEnabled() {
        return healingEnabled;
    }
    
    /**
     * Gets the currently registered healing strategies
     * 
     * @return List of healing strategies
     */
    public List<HealingStrategy> getHealingStrategies() {
        return new ArrayList<>(healingStrategies);
    }
    
    /**
     * Gets the names of all healing strategies
     * 
     * @return List of strategy names
     */
    public List<String> getHealingStrategyNames() {
        return healingStrategies.stream()
                .map(strategy -> strategy.getClass().getSimpleName())
                .collect(Collectors.toList());
    }
}


ElementFingerprint.java
------------------------------------

package com.cstestforge.framework.core.selfhealing;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.StringJoiner;

/**
 * A comprehensive fingerprint of a web element's characteristics for use in self-healing locator strategies.
 * This class captures a wide range of element properties that can be used to identify and match
 * elements across different executions, even when the original locator has changed.
 */
public class ElementFingerprint {
    // Basic attributes
    private String tagName;
    private String id;
    private String className;
    private String name;
    private String type;
    private String value;
    private String text;
    private String href;
    private String src;
    private String alt;
    private String title;
    private String role;
    private String ariaLabel;
    private Map<String, String> dataAttributes = new HashMap<>();
    
    // Position
    private int x;
    private int y;
    private int width;
    private int height;
    
    // Structure
    private String xPath;
    private String parentId;
    private String parentClass;
    private String parentTagName;
    private List<Map<String, String>> siblingsData;
    
    // CSS properties
    private String cssPosition;
    
    // Original locator
    private String originalLocator;
    
    // Timestamp for when the fingerprint was created
    private long timestamp = System.currentTimeMillis();

    /**
     * Default constructor
     */
    public ElementFingerprint() {
    }
    
    /**
     * Calculates a normalized weight for this fingerprint's attributes based on their importance
     * for identifying elements. More specific attributes receive higher weights.
     * 
     * @return A map of attribute names to their calculated weights
     */
    public Map<String, Double> calculateAttributeWeights() {
        Map<String, Double> weights = new HashMap<>();
        
        // ID is the most reliable attribute (if present)
        weights.put("id", id != null && !id.isEmpty() ? 1.0 : 0.0);
        
        // Name, ariaLabel, and role are also quite reliable
        weights.put("name", name != null && !name.isEmpty() ? 0.8 : 0.0);
        weights.put("ariaLabel", ariaLabel != null && !ariaLabel.isEmpty() ? 0.8 : 0.0);
        weights.put("role", role != null && !role.isEmpty() ? 0.7 : 0.0);
        
        // Other attributes are somewhat reliable
        weights.put("tagName", tagName != null && !tagName.isEmpty() ? 0.5 : 0.0);
        weights.put("className", className != null && !className.isEmpty() ? 0.7 : 0.0);
        weights.put("type", type != null && !type.isEmpty() ? 0.6 : 0.0);
        weights.put("value", value != null && !value.isEmpty() ? 0.6 : 0.0);
        weights.put("text", text != null && !text.isEmpty() ? 0.7 : 0.0);
        weights.put("href", href != null && !href.isEmpty() ? 0.7 : 0.0);
        weights.put("src", src != null && !src.isEmpty() ? 0.7 : 0.0);
        weights.put("alt", alt != null && !alt.isEmpty() ? 0.6 : 0.0);
        weights.put("title", title != null && !title.isEmpty() ? 0.6 : 0.0);
        
        // Structure is moderately reliable
        weights.put("parentId", parentId != null && !parentId.isEmpty() ? 0.7 : 0.0);
        weights.put("parentClass", parentClass != null && !parentClass.isEmpty() ? 0.6 : 0.0);
        weights.put("parentTagName", parentTagName != null && !parentTagName.isEmpty() ? 0.5 : 0.0);
        weights.put("xPath", xPath != null && !xPath.isEmpty() ? 0.6 : 0.0);
        
        // Position is less reliable as it can change between page loads
        boolean hasPosition = x > 0 || y > 0 || width > 0 || height > 0;
        weights.put("position", hasPosition ? 0.3 : 0.0);
        
        // CSS properties are moderately reliable
        weights.put("cssPosition", cssPosition != null && !cssPosition.isEmpty() ? 0.5 : 0.0);
        
        // Data attributes can be very reliable if present
        double dataAttributesWeight = dataAttributes.isEmpty() ? 0.0 : 0.8;
        weights.put("dataAttributes", dataAttributesWeight);
        
        // Siblings data provides context
        boolean hasSiblings = siblingsData != null && !siblingsData.isEmpty();
        weights.put("siblings", hasSiblings ? 0.5 : 0.0);
        
        return weights;
    }
    
    /**
     * Returns a map of all attribute names to their values
     * 
     * @return Map of attributes
     */
    public Map<String, Object> getAllAttributes() {
        Map<String, Object> allAttributes = new HashMap<>();
        
        allAttributes.put("tagName", tagName);
        allAttributes.put("id", id);
        allAttributes.put("className", className);
        allAttributes.put("name", name);
        allAttributes.put("type", type);
        allAttributes.put("value", value);
        allAttributes.put("text", text);
        allAttributes.put("href", href);
        allAttributes.put("src", src);
        allAttributes.put("alt", alt);
        allAttributes.put("title", title);
        allAttributes.put("role", role);
        allAttributes.put("ariaLabel", ariaLabel);
        allAttributes.put("dataAttributes", dataAttributes);
        
        allAttributes.put("x", x);
        allAttributes.put("y", y);
        allAttributes.put("width", width);
        allAttributes.put("height", height);
        
        allAttributes.put("xPath", xPath);
        allAttributes.put("parentId", parentId);
        allAttributes.put("parentClass", parentClass);
        allAttributes.put("parentTagName", parentTagName);
        allAttributes.put("siblingsData", siblingsData);
        
        allAttributes.put("cssPosition", cssPosition);
        
        allAttributes.put("originalLocator", originalLocator);
        allAttributes.put("timestamp", timestamp);
        
        return allAttributes;
    }
    
    /**
     * Gets the most significant attributes for locator generation
     * 
     * @return Map of significant attributes
     */
    public Map<String, String> getSignificantAttributes() {
        Map<String, String> significant = new HashMap<>();
        
        // Add non-null attributes in order of significance
        if (id != null && !id.isEmpty()) {
            significant.put("id", id);
        }
        
        if (name != null && !name.isEmpty()) {
            significant.put("name", name);
        }
        
        if (ariaLabel != null && !ariaLabel.isEmpty()) {
            significant.put("aria-label", ariaLabel);
        }
        
        if (role != null && !role.isEmpty()) {
            significant.put("role", role);
        }
        
        if (tagName != null && !tagName.isEmpty()) {
            significant.put("tagName", tagName);
        }
        
        if (className != null && !className.isEmpty()) {
            significant.put("class", className);
        }
        
        if (type != null && !type.isEmpty()) {
            significant.put("type", type);
        }
        
        if (title != null && !title.isEmpty()) {
            significant.put("title", title);
        }
        
        // Add data attributes if present
        for (Map.Entry<String, String> entry : dataAttributes.entrySet()) {
            if (entry.getValue() != null && !entry.getValue().isEmpty()) {
                significant.put(entry.getKey(), entry.getValue());
            }
        }
        
        return significant;
    }
    
    /**
     * Checks if this fingerprint has enough useful data for healing
     * 
     * @return true if the fingerprint is usable for healing
     */
    public boolean isUsableForHealing() {
        // At least the tag name must be present
        if (tagName == null || tagName.isEmpty()) {
            return false;
        }
        
        // And at least one of these significant attributes should be present
        return (id != null && !id.isEmpty()) ||
               (name != null && !name.isEmpty()) ||
               (className != null && !className.isEmpty()) ||
               (text != null && !text.isEmpty()) ||
               (ariaLabel != null && !ariaLabel.isEmpty()) ||
               (role != null && !role.isEmpty()) ||
               (!dataAttributes.isEmpty());
    }
    
    @Override
    public String toString() {
        return new StringJoiner(", ", ElementFingerprint.class.getSimpleName() + "[", "]")
                .add("tagName='" + tagName + "'")
                .add("id='" + id + "'")
                .add("className='" + className + "'")
                .add("text='" + (text != null && text.length() > 20 ? text.substring(0, 20) + "..." : text) + "'")
                .add("originalLocator='" + originalLocator + "'")
                .toString();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ElementFingerprint that = (ElementFingerprint) o;
        return Objects.equals(tagName, that.tagName) &&
               Objects.equals(id, that.id) &&
               Objects.equals(className, that.className) &&
               Objects.equals(name, that.name) &&
               Objects.equals(text, that.text) &&
               Objects.equals(originalLocator, that.originalLocator);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(tagName, id, className, name, text, originalLocator);
    }

    // Getters and Setters
    
    public String getTagName() {
        return tagName;
    }

    public void setTagName(String tagName) {
        this.tagName = tagName;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getClassName() {
        return className;
    }

    public void setClassName(String className) {
        this.className = className;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getHref() {
        return href;
    }

    public void setHref(String href) {
        this.href = href;
    }

    public String getSrc() {
        return src;
    }

    public void setSrc(String src) {
        this.src = src;
    }

    public String getAlt() {
        return alt;
    }

    public void setAlt(String alt) {
        this.alt = alt;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public String getAriaLabel() {
        return ariaLabel;
    }

    public void setAriaLabel(String ariaLabel) {
        this.ariaLabel = ariaLabel;
    }

    public Map<String, String> getDataAttributes() {
        return dataAttributes;
    }

    public void setDataAttributes(Map<String, String> dataAttributes) {
        this.dataAttributes = dataAttributes != null ? dataAttributes : new HashMap<>();
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getWidth() {
        return width;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public String getXPath() {
        return xPath;
    }

    public void setXPath(String xPath) {
        this.xPath = xPath;
    }

    public String getParentId() {
        return parentId;
    }

    public void setParentId(String parentId) {
        this.parentId = parentId;
    }

    public String getParentClass() {
        return parentClass;
    }

    public void setParentClass(String parentClass) {
        this.parentClass = parentClass;
    }

    public String getParentTagName() {
        return parentTagName;
    }

    public void setParentTagName(String parentTagName) {
        this.parentTagName = parentTagName;
    }

    public List<Map<String, String>> getSiblingsData() {
        return siblingsData;
    }

    public void setSiblingsData(List<Map<String, String>> siblingsData) {
        this.siblingsData = siblingsData;
    }

    public String getCssPosition() {
        return cssPosition;
    }

    public void setCssPosition(String cssPosition) {
        this.cssPosition = cssPosition;
    }

    public String getOriginalLocator() {
        return originalLocator;
    }

    public void setOriginalLocator(String originalLocator) {
        this.originalLocator = originalLocator;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
}



SimilarityScorer.java
---------------------------

package com.cstestforge.framework.core.selfhealing;

import com.cstestforge.framework.core.utils.CSLogger;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Utility class for calculating similarity scores between element fingerprints.
 * This is a critical component for the self-healing locator service,
 * allowing it to determine if a found element matches the expected one.
 */
public class SimilarityScorer {
    private static final CSLogger logger = CSLogger.getLogger(SimilarityScorer.class);
    
    // Default attribute weights if not provided
    private static final Map<String, Double> DEFAULT_WEIGHTS = Map.of(
        "id", 1.0,
        "tagName", 0.9,
        "name", 0.8,
        "className", 0.7,
        "text", 0.7,
        "ariaLabel", 0.8,
        "role", 0.7,
        "dataAttributes", 0.8,
        "type", 0.6,
        "value", 0.5,
        "href", 0.6,
        "src", 0.6,
        "alt", 0.5,
        "title", 0.5,
        "position", 0.3,
        "structure", 0.6
    );
    
    // Minimum similarity for considering attributes the same
    private static final double TEXT_SIMILARITY_THRESHOLD = 0.8;
    private static final double CLASS_SIMILARITY_THRESHOLD = 0.7;
    
    /**
     * Calculates a similarity score between two element fingerprints.
     * 
     * @param original The original element fingerprint
     * @param candidate The candidate element fingerprint
     * @return A similarity score between 0.0 and 1.0, where 1.0 means identical
     */
    public static double calculateSimilarity(ElementFingerprint original, ElementFingerprint candidate) {
        if (original == null || candidate == null) {
            return 0.0;
        }
        
        double totalScore = 0.0;
        double totalWeight = 0.0;
        
        // Get attribute weights from the original fingerprint, or use defaults
        Map<String, Double> weights = original.calculateAttributeWeights();
        for (String key : DEFAULT_WEIGHTS.keySet()) {
            if (!weights.containsKey(key)) {
                weights.put(key, DEFAULT_WEIGHTS.get(key));
            }
        }
        
        // Tag name is mandatory to match
        if (!compareStrings(original.getTagName(), candidate.getTagName())) {
            return 0.0;
        }
        
        // ID is very significant - if both have IDs and they don't match, return low score
        if (original.getId() != null && !original.getId().isEmpty() &&
            candidate.getId() != null && !candidate.getId().isEmpty() &&
            !compareStrings(original.getId(), candidate.getId())) {
            return 0.1; // Very low score but not zero to allow for other strategies
        }
        
        // Compare basic attributes
        totalScore += compareAttribute("id", original.getId(), candidate.getId(), weights.get("id"));
        totalWeight += weights.get("id");
        
        totalScore += compareAttribute("name", original.getName(), candidate.getName(), weights.get("name"));
        totalWeight += weights.get("name");
        
        totalScore += compareAttribute("type", original.getType(), candidate.getType(), weights.get("type"));
        totalWeight += weights.get("type");
        
        // For class names, we need to consider partial matches
        double classNameScore = compareClassNames(original.getClassName(), candidate.getClassName());
        totalScore += classNameScore * weights.get("className");
        totalWeight += weights.get("className");
        
        // For text, we need to consider partial matches and account for dynamic content
        double textScore = compareText(original.getText(), candidate.getText());
        totalScore += textScore * weights.get("text");
        totalWeight += weights.get("text");
        
        totalScore += compareAttribute("href", original.getHref(), candidate.getHref(), weights.get("href"));
        totalWeight += weights.get("href");
        
        totalScore += compareAttribute("src", original.getSrc(), candidate.getSrc(), weights.get("src"));
        totalWeight += weights.get("src");
        
        totalScore += compareAttribute("alt", original.getAlt(), candidate.getAlt(), weights.get("alt"));
        totalWeight += weights.get("alt");
        
        totalScore += compareAttribute("title", original.getTitle(), candidate.getTitle(), weights.get("title"));
        totalWeight += weights.get("title");
        
        totalScore += compareAttribute("role", original.getRole(), candidate.getRole(), weights.get("role"));
        totalWeight += weights.get("role");
        
        totalScore += compareAttribute("ariaLabel", original.getAriaLabel(), candidate.getAriaLabel(), weights.get("ariaLabel"));
        totalWeight += weights.get("ariaLabel");
        
        // Compare data attributes
        double dataAttributesScore = compareDataAttributes(original.getDataAttributes(), candidate.getDataAttributes());
        totalScore += dataAttributesScore * weights.get("dataAttributes");
        totalWeight += weights.get("dataAttributes");
        
        // Compare positional data
        double positionScore = comparePosition(original, candidate);
        totalScore += positionScore * weights.get("position");
        totalWeight += weights.get("position");
        
        // Compare structural data
        double structureScore = compareStructure(original, candidate);
        totalScore += structureScore * weights.get("structure");
        totalWeight += weights.get("structure");
        
        // Calculate final score
        double finalScore = totalWeight > 0 ? totalScore / totalWeight : 0.0;
        
        logger.debug(String.format("Similarity score between original and candidate: %.2f", finalScore));
        
        return finalScore;
    }
    
    /**
     * Compares two string values and returns a score.
     * 
     * @param attributeName The name of the attribute
     * @param original The original value
     * @param candidate The candidate value
     * @param weight The weight of this attribute
     * @return The weighted score
     */
    private static double compareAttribute(String attributeName, String original, String candidate, double weight) {
        if (weight <= 0) {
            return 0.0;
        }
        
        boolean originalEmpty = original == null || original.isEmpty();
        boolean candidateEmpty = candidate == null || candidate.isEmpty();
        
        // If both are empty, they match
        if (originalEmpty && candidateEmpty) {
            return weight;
        }
        
        // If only one is empty, they don't match
        if (originalEmpty || candidateEmpty) {
            return 0.0;
        }
        
        // Both have values, compare them
        boolean matches = compareStrings(original, candidate);
        
        logger.debug(String.format("Comparing %s: original='%s', candidate='%s', match=%b", 
                attributeName, original, candidate, matches));
        
        return matches ? weight : 0.0;
    }
    
    /**
     * Compares two strings for equality, handling null values.
     * 
     * @param s1 First string
     * @param s2 Second string
     * @return true if the strings are equal
     */
    private static boolean compareStrings(String s1, String s2) {
        if (s1 == null && s2 == null) {
            return true;
        }
        
        if (s1 == null || s2 == null) {
            return false;
        }
        
        return s1.equals(s2);
    }
    
    /**
     * Compares class names, allowing for partial matches and order differences.
     * 
     * @param original Original class name string
     * @param candidate Candidate class name string
     * @return Similarity score between 0.0 and 1.0
     */
    private static double compareClassNames(String original, String candidate) {
        if (original == null && candidate == null) {
            return 1.0;
        }
        
        if (original == null || candidate == null || original.isEmpty() || candidate.isEmpty()) {
            return 0.0;
        }
        
        // If they're exactly the same, return 1.0
        if (original.equals(candidate)) {
            return 1.0;
        }
        
        // Split into individual classes
        Set<String> originalClasses = new HashSet<>(Arrays.asList(original.split("\\s+")));
        Set<String> candidateClasses = new HashSet<>(Arrays.asList(candidate.split("\\s+")));
        
        // Remove empty strings
        originalClasses.remove("");
        candidateClasses.remove("");
        
        if (originalClasses.isEmpty() || candidateClasses.isEmpty()) {
            return 0.0;
        }
        
        // Calculate Jaccard similarity: intersection size / union size
        Set<String> intersection = new HashSet<>(originalClasses);
        intersection.retainAll(candidateClasses);
        
        Set<String> union = new HashSet<>(originalClasses);
        union.addAll(candidateClasses);
        
        double similarity = (double) intersection.size() / union.size();
        
        logger.debug(String.format("Class similarity: %.2f (intersection=%d, union=%d)",
                similarity, intersection.size(), union.size()));
        
        return similarity >= CLASS_SIMILARITY_THRESHOLD ? similarity : 0.0;
    }
    
    /**
     * Compares text content, accounting for dynamic content.
     * 
     * @param original Original text
     * @param candidate Candidate text
     * @return Similarity score between 0.0 and 1.0
     */
    private static double compareText(String original, String candidate) {
        if (original == null && candidate == null) {
            return 1.0;
        }
        
        if (original == null || candidate == null) {
            return 0.0;
        }
        
        // Normalize: trim and collapse whitespace
        original = original.trim().replaceAll("\\s+", " ");
        candidate = candidate.trim().replaceAll("\\s+", " ");
        
        if (original.isEmpty() && candidate.isEmpty()) {
            return 1.0;
        }
        
        if (original.isEmpty() || candidate.isEmpty()) {
            return 0.0;
        }
        
        // If they're exactly the same, return 1.0
        if (original.equals(candidate)) {
            return 1.0;
        }
        
        // Check if they start with the same text (accounts for dynamic suffixes)
        int minLength = Math.min(original.length(), candidate.length());
        int maxLength = Math.max(original.length(), candidate.length());
        
        // If one is much longer than the other, they're probably different
        if (minLength < maxLength * 0.5) {
            return 0.0;
        }
        
        // Calculate character-based similarity
        int matchingChars = 0;
        for (int i = 0; i < minLength; i++) {
            if (original.charAt(i) == candidate.charAt(i)) {
                matchingChars++;
            }
        }
        
        double similarity = (double) matchingChars / maxLength;
        
        logger.debug(String.format("Text similarity: %.2f (matching=%d, max=%d)",
                similarity, matchingChars, maxLength));
        
        return similarity >= TEXT_SIMILARITY_THRESHOLD ? similarity : 0.0;
    }
    
    /**
     * Compares data attributes for similarity.
     * 
     * @param originalData Original data attributes
     * @param candidateData Candidate data attributes
     * @return Similarity score between 0.0 and 1.0
     */
    private static double compareDataAttributes(Map<String, String> originalData, Map<String, String> candidateData) {
        if (originalData == null || candidateData == null) {
            return 0.0;
        }
        
        if (originalData.isEmpty() && candidateData.isEmpty()) {
            return 1.0;
        }
        
        if (originalData.isEmpty() || candidateData.isEmpty()) {
            return 0.0;
        }
        
        // Count matching attributes
        int matchCount = 0;
        int totalCount = 0;
        
        for (Map.Entry<String, String> entry : originalData.entrySet()) {
            String key = entry.getKey();
            String originalValue = entry.getValue();
            
            totalCount++;
            
            if (candidateData.containsKey(key)) {
                String candidateValue = candidateData.get(key);
                if (compareStrings(originalValue, candidateValue)) {
                    matchCount++;
                }
            }
        }
        
        // Add candidate attributes that weren't in original
        for (String key : candidateData.keySet()) {
            if (!originalData.containsKey(key)) {
                totalCount++;
            }
        }
        
        double similarity = totalCount > 0 ? (double) matchCount / totalCount : 0.0;
        
        logger.debug(String.format("Data attributes similarity: %.2f (matches=%d, total=%d)",
                similarity, matchCount, totalCount));
        
        return similarity;
    }
    
    /**
     * Compares positional data between fingerprints.
     * Position is less reliable for matching but can be useful
     * when other attributes don't provide enough discrimination.
     * 
     * @param original Original fingerprint
     * @param candidate Candidate fingerprint
     * @return Similarity score between 0.0 and 1.0
     */
    private static double comparePosition(ElementFingerprint original, ElementFingerprint candidate) {
        // If either has no position data, we can't compare
        boolean originalHasPosition = original.getWidth() > 0 && original.getHeight() > 0;
        boolean candidateHasPosition = candidate.getWidth() > 0 && candidate.getHeight() > 0;
        
        if (!originalHasPosition || !candidateHasPosition) {
            return 0.0;
        }
        
        // Compare size similarity
        double sizeSimilarity = compareDimensions(original, candidate);
        
        // Compare position similarity (this is less reliable but still useful)
        double positionSimilarity = compareLocation(original, candidate);
        
        // Weighted combination - size is more reliable than absolute position
        double similarity = sizeSimilarity * 0.7 + positionSimilarity * 0.3;
        
        logger.debug(String.format("Position similarity: %.2f (size=%.2f, position=%.2f)",
                similarity, sizeSimilarity, positionSimilarity));
        
        return similarity;
    }
    
    /**
     * Compares element dimensions (width and height).
     * 
     * @param original Original fingerprint
     * @param candidate Candidate fingerprint
     * @return Similarity score between 0.0 and 1.0
     */
    private static double compareDimensions(ElementFingerprint original, ElementFingerprint candidate) {
        int originalWidth = original.getWidth();
        int originalHeight = original.getHeight();
        int candidateWidth = candidate.getWidth();
        int candidateHeight = candidate.getHeight();
        
        // Calculate ratio of widths and heights
        double widthRatio = Math.min(originalWidth, candidateWidth) / (double) Math.max(originalWidth, candidateWidth);
        double heightRatio = Math.min(originalHeight, candidateHeight) / (double) Math.max(originalHeight, candidateHeight);
        
        // Return average similarity
        return (widthRatio + heightRatio) / 2.0;
    }
    
    /**
     * Compares element positions (x and y coordinates).
     * Position is highly variable but can help disambiguate similar elements.
     * 
     * @param original Original fingerprint
     * @param candidate Candidate fingerprint
     * @return Similarity score between 0.0 and 1.0
     */
    private static double compareLocation(ElementFingerprint original, ElementFingerprint candidate) {
        int originalX = original.getX();
        int originalY = original.getY();
        int candidateX = candidate.getX();
        int candidateY = candidate.getY();
        
        // Calculate absolute distance
        double distance = Math.sqrt(Math.pow(originalX - candidateX, 2) + Math.pow(originalY - candidateY, 2));
        
        // Normalize by the size of the viewport (approximate)
        // Using a reference size of 1000px as a heuristic for normalization
        double normalizedDistance = Math.min(1.0, distance / 1000.0);
        
        // Convert to similarity (1.0 = same position, 0.0 = far apart)
        return 1.0 - normalizedDistance;
    }
    
    /**
     * Compares structural data (parent, siblings) between fingerprints.
     * 
     * @param original Original fingerprint
     * @param candidate Candidate fingerprint
     * @return Similarity score between 0.0 and 1.0
     */
    private static double compareStructure(ElementFingerprint original, ElementFingerprint candidate) {
        double parentScore = compareParent(original, candidate);
        double siblingsScore = compareSiblings(original, candidate);
        double xpathScore = compareXPath(original, candidate);
        
        // Weighted average of structural comparisons
        // Parent and siblings are more reliable than XPath for matching
        double structureScore = parentScore * 0.5 + siblingsScore * 0.3 + xpathScore * 0.2;
        
        logger.debug(String.format("Structure similarity: %.2f (parent=%.2f, siblings=%.2f, xpath=%.2f)",
                structureScore, parentScore, siblingsScore, xpathScore));
        
        return structureScore;
    }
    
    /**
     * Compares parent element data.
     * 
     * @param original Original fingerprint
     * @param candidate Candidate fingerprint
     * @return Similarity score between 0.0 and 1.0
     */
    private static double compareParent(ElementFingerprint original, ElementFingerprint candidate) {
        double idScore = compareAttribute("parentId", original.getParentId(), candidate.getParentId(), 1.0);
        double classScore = compareClassNames(original.getParentClass(), candidate.getParentClass());
        double tagScore = compareAttribute("parentTagName", original.getParentTagName(), candidate.getParentTagName(), 1.0);
        
        // Parent tag name match is required
        if (tagScore == 0.0) {
            return 0.0;
        }
        
        // If parent has an ID and it matches, that's a strong signal
        if (idScore > 0.0) {
            return (idScore * 0.7 + tagScore * 0.3);
        }
        
        // Otherwise use class and tag
        return (classScore * 0.6 + tagScore * 0.4);
    }
    
    /**
     * Compares siblings data to identify structural similarities.
     * 
     * @param original Original fingerprint
     * @param candidate Candidate fingerprint
     * @return Similarity score between 0.0 and 1.0
     */
    private static double compareSiblings(ElementFingerprint original, ElementFingerprint candidate) {
        if (original.getSiblingsData() == null || candidate.getSiblingsData() == null) {
            return 0.0;
        }
        
        int originalCount = original.getSiblingsData().size();
        int candidateCount = candidate.getSiblingsData().size();
        
        // If both have no siblings, that's a match
        if (originalCount == 0 && candidateCount == 0) {
            return 1.0;
        }
        
        // If only one has siblings, that's a partial match (same parent, different children)
        if (originalCount == 0 || candidateCount == 0) {
            return 0.5;
        }
        
        // Calculate count similarity
        double countSimilarity = Math.min(originalCount, candidateCount) / 
                                (double) Math.max(originalCount, candidateCount);
        
        // If we have very different numbers of siblings, that's a sign we might be in different contexts
        if (countSimilarity < 0.5) {
            return countSimilarity;
        }
        
        // We'll do a simple comparison of siblings by position and tag name
        // For a real implementation, you might want to do deeper comparisons
        int matchCount = 0;
        int comparedCount = Math.min(originalCount, candidateCount);
        
        for (int i = 0; i < comparedCount; i++) {
            Map<String, String> originalSibling = original.getSiblingsData().get(i);
            Map<String, String> candidateSibling = candidate.getSiblingsData().get(i);
            
            // Check if tag names match
            String originalTag = originalSibling.get("tagName");
            String candidateTag = candidateSibling.get("tagName");
            
            if (compareStrings(originalTag, candidateTag)) {
                matchCount++;
            }
        }
        
        double siblingMatchRate = comparedCount > 0 ? 
                (double) matchCount / comparedCount : 0.0;
        
        // Combine count similarity and match rate
        return countSimilarity * 0.4 + siblingMatchRate * 0.6;
    }
    
    /**
     * Compares XPath data to identify structural similarities.
     * XPath comparison is less reliable but can help disambiguate elements.
     * 
     * @param original Original fingerprint
     * @param candidate Candidate fingerprint
     * @return Similarity score between 0.0 and 1.0
     */
    private static double compareXPath(ElementFingerprint original, ElementFingerprint candidate) {
        String originalXPath = original.getXPath();
        String candidateXPath = candidate.getXPath();
        
        if (originalXPath == null || candidateXPath == null || 
            originalXPath.isEmpty() || candidateXPath.isEmpty()) {
            return 0.0;
        }
        
        // If they're identical, that's a perfect match
        if (originalXPath.equals(candidateXPath)) {
            return 1.0;
        }
        
        // Split XPaths into parts
        String[] originalParts = originalXPath.split("/");
        String[] candidateParts = candidateXPath.split("/");
        
        // Compare path length
        int originalLength = originalParts.length;
        int candidateLength = candidateParts.length;
        double lengthSimilarity = Math.min(originalLength, candidateLength) / 
                                 (double) Math.max(originalLength, candidateLength);
        
        // Compare path parts from the end (most specific) to the beginning
        int matchCount = 0;
        int maxComparisons = Math.min(originalLength, candidateLength);
        
        for (int i = 1; i <= maxComparisons; i++) {
            String originalPart = originalParts[originalLength - i];
            String candidatePart = candidateParts[candidateLength - i];
            
            // Simple comparison - they're either the same or different
            // A more sophisticated approach could parse the parts and compare tag names and indices
            if (originalPart.equals(candidatePart)) {
                matchCount++;
            } else {
                // Once we hit a difference, stop counting matches
                // (because ancestor paths are less discriminative)
                break;
            }
        }
        
        double partsSimilarity = matchCount / (double) maxComparisons;
        
        // Weighted combination - matching parts are more important than length similarity
        return partsSimilarity * 0.8 + lengthSimilarity * 0.2;
    }
}


AttributeHealingStrategy.java
------------------------------------

package com.cstestforge.framework.core.selfhealing;

import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * A healing strategy that uses element attributes to find alternative locators.
 * This strategy prioritizes ID, name, and other stable attributes to generate
 * CSS selectors that can be used when the original locator fails.
 */
public class AttributeHealingStrategy implements HealingStrategy {
    private static final CSLogger logger = CSLogger.getLogger(AttributeHealingStrategy.class);
    
    // Minimum similarity score required to consider a match
    private static final double MIN_SIMILARITY = 0.8;
    
    // Maximum number of candidate elements to evaluate
    private static final int MAX_CANDIDATES = 10;
    
    @Override
    public String heal(WebDriver driver, String originalLocator, ElementFingerprint fingerprint) {
        logger.debug("Attempting to heal locator using AttributeHealingStrategy: " + originalLocator);
        
        if (driver == null || fingerprint == null) {
            logger.warn("Driver or fingerprint is null, cannot heal locator");
            return originalLocator;
        }
        
        try {
            // Generate attribute-based alternative locators
            List<String> alternativeLocators = generateAlternativeLocators(fingerprint);
            
            if (alternativeLocators.isEmpty()) {
                logger.debug("No alternative locators generated");
                return originalLocator;
            }
            
            logger.debug("Generated " + alternativeLocators.size() + " alternative locators");
            
            // Try each alternative locator and find the best match
            String bestLocator = findBestMatch(driver, alternativeLocators, fingerprint);
            
            if (bestLocator != null) {
                logger.info("Found healing locator: " + bestLocator);
                return bestLocator;
            }
            
            // If no good match found, try JavaScript-based element finding
            String jsLocator = findElementWithJavaScript(driver, fingerprint);
            if (jsLocator != null) {
                logger.info("Found healing locator using JavaScript: " + jsLocator);
                return jsLocator;
            }
            
            logger.debug("No suitable healing locator found");
            return originalLocator;
            
        } catch (Exception e) {
            logger.error("Error in AttributeHealingStrategy", e);
            return originalLocator;
        }
    }
    
    /**
     * Generates alternative CSS selectors based on element attributes.
     * 
     * @param fingerprint The element fingerprint
     * @return List of alternative CSS selectors
     */
    private List<String> generateAlternativeLocators(ElementFingerprint fingerprint) {
        List<String> locators = new ArrayList<>();
        
        // Basic tag name to start with
        String tag = fingerprint.getTagName();
        if (tag == null || tag.isEmpty()) {
            logger.warn("Fingerprint has no tag name, cannot generate alternative locators");
            return locators;
        }
        
        // ID is the most reliable attribute
        String id = fingerprint.getId();
        if (id != null && !id.isEmpty()) {
            locators.add("#" + escapeSelector(id));
            locators.add(tag + "#" + escapeSelector(id));
        }
        
        // Name attribute
        String name = fingerprint.getName();
        if (name != null && !name.isEmpty()) {
            locators.add(tag + "[name='" + escapeAttributeValue(name) + "']");
        }
        
        // Aria-label
        String ariaLabel = fingerprint.getAriaLabel();
        if (ariaLabel != null && !ariaLabel.isEmpty()) {
            locators.add(tag + "[aria-label='" + escapeAttributeValue(ariaLabel) + "']");
        }
        
        // Class
        String className = fingerprint.getClassName();
        if (className != null && !className.isEmpty()) {
            // Handle multiple classes
            String[] classes = className.split("\\s+");
            for (String cls : classes) {
                if (!cls.isEmpty()) {
                    locators.add(tag + "." + escapeSelector(cls));
                }
            }
            
            // Try with specific combinations of classes
            if (classes.length > 1) {
                StringBuilder classSelector = new StringBuilder(tag);
                for (String cls : classes) {
                    if (!cls.isEmpty()) {
                        classSelector.append(".").append(escapeSelector(cls));
                    }
                }
                locators.add(classSelector.toString());
            }
        }
        
        // Role
        String role = fingerprint.getRole();
        if (role != null && !role.isEmpty()) {
            locators.add(tag + "[role='" + escapeAttributeValue(role) + "']");
        }
        
        // Type
        String type = fingerprint.getType();
        if (type != null && !type.isEmpty()) {
            locators.add(tag + "[type='" + escapeAttributeValue(type) + "']");
        }
        
        // Title
        String title = fingerprint.getTitle();
        if (title != null && !title.isEmpty()) {
            locators.add(tag + "[title='" + escapeAttributeValue(title) + "']");
        }
        
        // Text content for elements that typically have text
        String text = fingerprint.getText();
        if (text != null && !text.isEmpty() && text.length() < 50) {
            // For elements that typically have text content
            if (tag.equals("a") || tag.equals("button") || tag.equals("h1") || 
                tag.equals("h2") || tag.equals("h3") || tag.equals("h4") || 
                tag.equals("h5") || tag.equals("h6") || tag.equals("label") ||
                tag.equals("span") || tag.equals("p") || tag.equals("div")) {
                
                // Exact text match
                locators.add(tag + ":contains('" + escapeAttributeValue(text) + "')");
                
                // Start of text match (for dynamic content)
                if (text.length() > 10) {
                    String startText = text.substring(0, Math.min(text.length(), 20));
                    locators.add(tag + ":contains('" + escapeAttributeValue(startText) + "')");
                }
            }
        }
        
        // Data attributes
        Map<String, String> dataAttributes = fingerprint.getDataAttributes();
        if (dataAttributes != null && !dataAttributes.isEmpty()) {
            for (Map.Entry<String, String> entry : dataAttributes.entrySet()) {
                String attrName = entry.getKey();
                String attrValue = entry.getValue();
                
                if (attrValue != null && !attrValue.isEmpty()) {
                    locators.add(tag + "[" + attrName + "='" + escapeAttributeValue(attrValue) + "']");
                }
            }
        }
        
        // Combinations of attributes for more specificity
        // Create combinations only if we have more than one significant attribute
        Map<String, String> significantAttrs = fingerprint.getSignificantAttributes();
        if (significantAttrs.size() > 1) {
            // Limit to 3 attributes max to avoid overly specific selectors
            List<String> attrSelectors = new ArrayList<>();
            for (Map.Entry<String, String> entry : significantAttrs.entrySet()) {
                String attrName = entry.getKey();
                String attrValue = entry.getValue();
                
                // Skip tagName as it's already included
                if (attrName.equals("tagName")) {
                    continue;
                }
                
                // Handle class selector differently
                if (attrName.equals("class")) {
                    String[] classes = attrValue.split("\\s+");
                    if (classes.length > 0 && !classes[0].isEmpty()) {
                        attrSelectors.add("." + escapeSelector(classes[0]));
                    }
                    continue;
                }
                
                // Handle ID selector differently
                if (attrName.equals("id")) {
                    attrSelectors.add("#" + escapeSelector(attrValue));
                    continue;
                }
                
                // Standard attribute selector
                attrSelectors.add("[" + attrName + "='" + escapeAttributeValue(attrValue) + "']");
            }
            
            // Generate combinations of 2 attributes
            if (attrSelectors.size() >= 2) {
                for (int i = 0; i < attrSelectors.size(); i++) {
                    for (int j = i+1; j < attrSelectors.size(); j++) {
                        locators.add(tag + attrSelectors.get(i) + attrSelectors.get(j));
                    }
                }
            }
            
            // Generate combinations of 3 attributes
            if (attrSelectors.size() >= 3) {
                for (int i = 0; i < attrSelectors.size(); i++) {
                    for (int j = i+1; j < attrSelectors.size(); j++) {
                        for (int k = j+1; k < attrSelectors.size(); k++) {
                            locators.add(tag + attrSelectors.get(i) + attrSelectors.get(j) + attrSelectors.get(k));
                        }
                    }
                }
            }
        }
        
        // Parent-based selectors
        String parentId = fingerprint.getParentId();
        String parentClass = fingerprint.getParentClass();
        String parentTag = fingerprint.getParentTagName();
        
        if (parentTag != null && !parentTag.isEmpty()) {
            // Parent with ID
            if (parentId != null && !parentId.isEmpty()) {
                locators.add("#" + escapeSelector(parentId) + " > " + tag);
                
                // Add more specificity with element attributes
                if (id != null && !id.isEmpty()) {
                    locators.add("#" + escapeSelector(parentId) + " > " + tag + "#" + escapeSelector(id));
                }
                
                if (className != null && !className.isEmpty()) {
                    String[] classes = className.split("\\s+");
                    if (classes.length > 0 && !classes[0].isEmpty()) {
                        locators.add("#" + escapeSelector(parentId) + " > " + tag + "." + escapeSelector(classes[0]));
                    }
                }
            }
            
            // Parent with class
            if (parentClass != null && !parentClass.isEmpty()) {
                String[] parentClasses = parentClass.split("\\s+");
                if (parentClasses.length > 0 && !parentClasses[0].isEmpty()) {
                    locators.add("." + escapeSelector(parentClasses[0]) + " > " + tag);
                    
                    // Add more specificity with element attributes
                    if (id != null && !id.isEmpty()) {
                        locators.add("." + escapeSelector(parentClasses[0]) + " > " + tag + "#" + escapeSelector(id));
                    }
                    
                    if (className != null && !className.isEmpty()) {
                        String[] classes = className.split("\\s+");
                        if (classes.length > 0 && !classes[0].isEmpty()) {
                            locators.add("." + escapeSelector(parentClasses[0]) + " > " + tag + "." + escapeSelector(classes[0]));
                        }
                    }
                }
            }
        }
        
        // Remove duplicates and return
        return locators.stream().distinct().collect(Collectors.toList());
    }
    
    /**
     * Finds the best matching locator from a list of candidates.
     * 
     * @param driver The WebDriver
     * @param locators List of candidate locators
     * @param fingerprint The original element fingerprint
     * @return The best matching locator, or null if none meets the threshold
     */
    private String findBestMatch(WebDriver driver, List<String> locators, ElementFingerprint fingerprint) {
        String bestLocator = null;
        double bestScore = 0.0;
        
        for (String locator : locators) {
            try {
                List<WebElement> elements = driver.findElements(By.cssSelector(locator));
                
                // If we found too many elements, this locator is too general
                if (elements.size() > MAX_CANDIDATES) {
                    logger.debug("Locator found too many elements: " + locator + " (" + elements.size() + ")");
                    continue;
                }
                
                // If we found no elements, this locator doesn't work
                if (elements.isEmpty()) {
                    continue;
                }
                
                // For each element, calculate similarity score
                for (WebElement element : elements) {
                    ElementFingerprint candidateFingerprint = createFingerprint(driver, element, locator);
                    double similarity = SimilarityScorer.calculateSimilarity(fingerprint, candidateFingerprint);
                    
                    logger.debug("Locator: " + locator + ", Similarity: " + similarity);
                    
                    if (similarity > bestScore) {
                        bestScore = similarity;
                        bestLocator = locator;
                        
                        // If we found a very good match, we can stop searching
                        if (similarity >= 0.95) {
                            return bestLocator;
                        }
                    }
                }
            } catch (Exception e) {
                logger.debug("Error testing locator: " + locator, e);
            }
        }
        
        // Only return if the best score is above our threshold
        return bestScore >= MIN_SIMILARITY ? bestLocator : null;
    }
    
    /**
     * Uses JavaScript to find an element based on its fingerprint.
     * This is a more advanced approach when standard selectors fail.
     * 
     * @param driver The WebDriver
     * @param fingerprint The element fingerprint
     * @return A new CSS selector or null if no match found
     */
    private String findElementWithJavaScript(WebDriver driver, ElementFingerprint fingerprint) {
        if (!(driver instanceof JavascriptExecutor)) {
            return null;
        }
        
        JavascriptExecutor js = (JavascriptExecutor) driver;
        
        try {
            Map<String, Object> attributes = new HashMap<>();
            
            // Add significant attributes to the search
            attributes.put("tagName", fingerprint.getTagName());
            
            if (fingerprint.getId() != null && !fingerprint.getId().isEmpty()) {
                attributes.put("id", fingerprint.getId());
            }
            
            if (fingerprint.getClassName() != null && !fingerprint.getClassName().isEmpty()) {
                attributes.put("className", fingerprint.getClassName());
            }
            
            if (fingerprint.getName() != null && !fingerprint.getName().isEmpty()) {
                attributes.put("name", fingerprint.getName());
            }
            
            if (fingerprint.getText() != null && !fingerprint.getText().isEmpty()) {
                attributes.put("text", fingerprint.getText());
            }
            
            if (fingerprint.getAriaLabel() != null && !fingerprint.getAriaLabel().isEmpty()) {
                attributes.put("ariaLabel", fingerprint.getAriaLabel());
            }
            
            // Prepare data attributes
            Map<String, String> dataAttrs = fingerprint.getDataAttributes();
            if (dataAttrs != null && !dataAttrs.isEmpty()) {
                for (Map.Entry<String, String> entry : dataAttrs.entrySet()) {
                    attributes.put(entry.getKey(), entry.getValue());
                }
            }
            
            // JavaScript to find elements by attributes and compute similarity
            String script = 
                    "var fingerprint = arguments[0];" +
                    "var tagName = fingerprint.tagName.toLowerCase();" +
                    "var candidates = document.getElementsByTagName(tagName);" +
                    "var bestMatch = null;" +
                    "var bestScore = 0;" +
                    "for (var i = 0; i < candidates.length; i++) {" +
                    "    var candidate = candidates[i];" +
                    "    var score = 0;" +
                    "    var totalWeight = 0;" +
                    "    " +
                    "    // Check each attribute" +
                    "    for (var attr in fingerprint) {" +
                    "        if (attr === 'tagName') continue;" +
                    "        var weight = 0;" +
                    "        var match = false;" +
                    "        " +
                    "        if (attr === 'id') {" +
                    "            weight = 10;" +
                    "            match = candidate.id === fingerprint[attr];" +
                    "        } else if (attr === 'className') {" +
                    "            weight = 7;" +
                    "            var classes = fingerprint[attr].split(/\\s+/);" +
                    "            var candidateClasses = candidate.className.split(/\\s+/);" +
                    "            var matchCount = 0;" +
                    "            for (var j = 0; j < classes.length; j++) {" +
                    "                if (candidateClasses.indexOf(classes[j]) >= 0) {" +
                    "                    matchCount++;" +
                    "                }" +
                    "            }" +
                    "            match = matchCount > 0;" +
                    "            score += (matchCount / classes.length) * weight;" +
                    "            totalWeight += weight;" +
                    "            continue;" +
                    "        } else if (attr === 'text') {" +
                    "            weight = 7;" +
                    "            var candidateText = candidate.textContent || candidate.innerText || '';" +
                    "            match = candidateText.indexOf(fingerprint[attr]) >= 0;" +
                    "        } else if (attr === 'ariaLabel') {" +
                    "            weight = 8;" +
                    "            match = candidate.getAttribute('aria-label') === fingerprint[attr];" +
                    "        } else if (attr.indexOf('data-') === 0) {" +
                    "            weight = 8;" +
                    "            match = candidate.getAttribute(attr) === fingerprint[attr];" +
                    "        } else {" +
                    "            weight = 5;" +
                    "            match = candidate[attr] === fingerprint[attr] || " +
                    "                   candidate.getAttribute(attr) === fingerprint[attr];" +
                    "        }" +
                    "        " +
                    "        if (match) {" +
                    "            score += weight;" +
                    "        }" +
                    "        totalWeight += weight;" +
                    "    }" +
                    "    " +
                    "    // Calculate final score" +
                    "    var finalScore = totalWeight > 0 ? score / totalWeight : 0;" +
                    "    if (finalScore > bestScore) {" +
                    "        bestScore = finalScore;" +
                    "        bestMatch = candidate;" +
                    "    }" +
                    "}" +
                    "" +
                    "// Generate a CSS selector for the best match if found" +
                    "if (bestMatch && bestScore >= 0.7) {" +
                    "    // Try to generate a good CSS selector" +
                    "    var selector = '';" +
                    "    " +
                    "    // ID is most reliable" +
                    "    if (bestMatch.id) {" +
                    "        return '#' + bestMatch.id;" +
                    "    }" +
                    "    " +
                    "    // Try attribute combinations" +
                    "    selector = tagName;" +
                    "    " +
                    "    // Add class if available" +
                    "    if (bestMatch.className) {" +
                    "        var mainClass = bestMatch.className.split(/\\s+/)[0];" +
                    "        if (mainClass) {" +
                    "            selector += '.' + mainClass;" +
                    "        }" +
                    "    }" +
                    "    " +
                    "    // Add name if available" +
                    "    if (bestMatch.name) {" +
                    "        selector += '[name=\"' + bestMatch.name + '\"]';" +
                    "    }" +
                    "    " +
                    "    // Add role if available" +
                    "    var role = bestMatch.getAttribute('role');" +
                    "    if (role) {" +
                    "        selector += '[role=\"' + role + '\"]';" +
                    "    }" +
                    "    " +
                    "    // If we have a good selector, return it" +
                    "    if (selector !== tagName) {" +
                    "        return selector;" +
                    "    }" +
                    "    " +
                    "    // If we can't generate a good selector, return null" +
                    "    return null;" +
                    "}" +
                    "return null;";
            
            Object result = js.executeScript(script, attributes);
            
            if (result != null) {
                return result.toString();
            }
        } catch (Exception e) {
            logger.warn("Error finding element with JavaScript", e);
        }
        
        return null;
    }
    
    /**
     * Creates a fingerprint from a WebElement for comparison.
     * 
     * @param driver The WebDriver
     * @param element The WebElement
     * @param locator The locator used to find the element
     * @return The ElementFingerprint
     */
    private ElementFingerprint createFingerprint(WebDriver driver, WebElement element, String locator) {
        ElementFingerprint fingerprint = new ElementFingerprint();
        
        try {
            // Basic attributes
            fingerprint.setTagName(element.getTagName());
            fingerprint.setId(element.getAttribute("id"));
            fingerprint.setClassName(element.getAttribute("class"));
            fingerprint.setName(element.getAttribute("name"));
            fingerprint.setType(element.getAttribute("type"));
            fingerprint.setValue(element.getAttribute("value"));
            fingerprint.setText(element.getText());
            fingerprint.setHref(element.getAttribute("href"));
            fingerprint.setSrc(element.getAttribute("src"));
            fingerprint.setAlt(element.getAttribute("alt"));
            fingerprint.setTitle(element.getAttribute("title"));
            fingerprint.setRole(element.getAttribute("role"));
            fingerprint.setAriaLabel(element.getAttribute("aria-label"));
            
            // Data attributes
            Map<String, String> dataAttributes = getDataAttributes(element);
            fingerprint.setDataAttributes(dataAttributes);
            
            // Position
            if (element.isDisplayed()) {
                fingerprint.setX(element.getLocation().getX());
                fingerprint.setY(element.getLocation().getY());
                fingerprint.setWidth(element.getSize().getWidth());
                fingerprint.setHeight(element.getSize().getHeight());
            }
            
            // Original locator for reference
            fingerprint.setOriginalLocator(locator);
            
        } catch (Exception e) {
            logger.warn("Error creating element fingerprint for comparison", e);
        }
        
        return fingerprint;
    }
    
    /**
     * Gets all data-* attributes of an element.
     * 
     * @param element The WebElement
     * @return Map of data attribute names to values
     */
    private Map<String, String> getDataAttributes(WebElement element) {
        Map<String, String> dataAttributes = new HashMap<>();
        try {
            JavascriptExecutor js = (JavascriptExecutor) element.getWrappedDriver();
            
            @SuppressWarnings("unchecked")
            Map<String, Object> result = (Map<String, Object>) js.executeScript(
                    "var items = {}; " +
                    "for (var i = 0; i < arguments[0].attributes.length; i++) { " +
                    "   var attr = arguments[0].attributes[i]; " +
                    "   if (attr.name.indexOf('data-') === 0) { " +
                    "       items[attr.name] = attr.value; " +
                    "   } " +
                    "} " +
                    "return items;", element);
            
            for (Map.Entry<String, Object> entry : result.entrySet()) {
                dataAttributes.put(entry.getKey(), entry.getValue() != null ? entry.getValue().toString() : null);
            }
        } catch (Exception e) {
            logger.warn("Failed to get data attributes", e);
        }
        return dataAttributes;
    }
    
    /**
     * Escapes special characters in CSS selectors.
     * 
     * @param selector The selector to escape
     * @return The escaped selector
     */
    private String escapeSelector(String selector) {
        if (selector == null) {
            return "";
        }
        
        // Escape special characters in CSS selectors
        return selector.replaceAll("([ #.:~+><!])", "\\\\$1");
    }
    
    /**
     * Escapes special characters in attribute values for CSS selectors.
     * 
     * @param value The attribute value to escape
     * @return The escaped attribute value
     */
    private String escapeAttributeValue(String value) {
        if (value == null) {
            return "";
        }
        
        // Escape quotes and backslashes in attribute values
        return value.replace("\\", "\\\\").replace("'", "\\'");
    }
}


HealingStrategy.java
-----------------------------

package com.cstestforge.framework.core.selfhealing;

import org.openqa.selenium.WebDriver;

/**
 * Interface for all self-healing locator strategies.
 * Each implementation provides a different approach to heal broken locators
 * using information from the element fingerprint.
 */
public interface HealingStrategy {
    
    /**
     * Attempts to heal a broken locator using the element fingerprint.
     * 
     * @param driver The WebDriver instance
     * @param originalLocator The original locator that failed
     * @param fingerprint The fingerprint of the element from a previous successful location
     * @return A healed locator if successful, or the original locator if healing fails
     */
    String heal(WebDriver driver, String originalLocator, ElementFingerprint fingerprint);
}



TextHealingStrategy.java
--------------------------------

package com.cstestforge.framework.core.selfhealing;

import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * A healing strategy that uses element text content to find alternative locators.
 * This is useful for elements like buttons, links, and labels where the text
 * is a reliable identifier even when other attributes change.
 */
public class TextHealingStrategy implements HealingStrategy {
    private static final CSLogger logger = CSLogger.getLogger(TextHealingStrategy.class);
    
    // Minimum similarity score required to consider a match
    private static final double MIN_SIMILARITY = 0.8;
    
    // Maximum number of candidate elements to evaluate
    private static final int MAX_CANDIDATES = 10;
    
    // Maximum text length to use for exact matching
    private static final int MAX_TEXT_LENGTH_FOR_EXACT = 100;
    
    // Minimum text length to be usable for healing
    private static final int MIN_TEXT_LENGTH = 3;

    @Override
    public String heal(WebDriver driver, String originalLocator, ElementFingerprint fingerprint) {
        logger.debug("Attempting to heal locator using TextHealingStrategy: " + originalLocator);
        
        if (driver == null || fingerprint == null) {
            logger.warn("Driver or fingerprint is null, cannot heal locator");
            return originalLocator;
        }
        
        String text = fingerprint.getText();
        if (text == null || text.isEmpty() || text.length() < MIN_TEXT_LENGTH) {
            logger.debug("Element text is too short or empty, cannot use text healing strategy");
            return originalLocator;
        }
        
        try {
            // Generate text-based locators
            List<String> textLocators = generateTextLocators(fingerprint);
            
            if (textLocators.isEmpty()) {
                logger.debug("No text-based locators generated");
                return originalLocator;
            }
            
            logger.debug("Generated " + textLocators.size() + " text-based locators");
            
            // Find the best match
            String bestLocator = findBestMatch(driver, textLocators, fingerprint);
            
            if (bestLocator != null) {
                logger.info("Found healing locator using text: " + bestLocator);
                return bestLocator;
            }
            
            // If no good match with CSS selectors, try XPath
            String xpathLocator = findElementWithXPath(driver, fingerprint);
            if (xpathLocator != null) {
                logger.info("Found healing locator using XPath text search: " + xpathLocator);
                return xpathLocator;
            }
            
            // If still no match, try JavaScript
            String jsLocator = findElementWithJavaScript(driver, fingerprint);
            if (jsLocator != null) {
                logger.info("Found healing locator using JavaScript text search: " + jsLocator);
                return jsLocator;
            }
            
            logger.debug("No suitable text-based healing locator found");
            return originalLocator;
            
        } catch (Exception e) {
            logger.error("Error in TextHealingStrategy", e);
            return originalLocator;
        }
    }
    
    /**
     * Generates locators based on element text content.
     * 
     * @param fingerprint The element fingerprint
     * @return List of text-based locators
     */
    private List<String> generateTextLocators(ElementFingerprint fingerprint) {
        List<String> locators = new ArrayList<>();
        
        String tag = fingerprint.getTagName();
        String text = fingerprint.getText();
        
        if (tag == null || tag.isEmpty() || text == null || text.isEmpty()) {
            return Collections.emptyList();
        }
        
        // Normalize text: trim and collapse whitespace
        text = text.trim().replaceAll("\\s+", " ");
        
        if (text.isEmpty() || text.length() < MIN_TEXT_LENGTH) {
            return Collections.emptyList();
        }
        
        // Add tag-specific selectors
        switch (tag.toLowerCase()) {
            case "a":
                // Link text
                if (text.length() <= MAX_TEXT_LENGTH_FOR_EXACT) {
                    locators.add("a:contains('" + escapeAttributeValue(text) + "')");
                }
                
                // Partial link text if text is long
                if (text.length() > 20) {
                    String partialText = text.substring(0, 20);
                    locators.add("a:contains('" + escapeAttributeValue(partialText) + "')");
                }
                
                // Link with href and text
                String href = fingerprint.getHref();
                if (href != null && !href.isEmpty()) {
                    String hrefPattern = href.replaceAll("\\?.*$", ""); // Remove query parameters
                    locators.add("a[href*='" + escapeAttributeValue(hrefPattern) + "']:contains('" + escapeAttributeValue(text) + "')");
                }
                break;
                
            case "button":
                // Button text
                if (text.length() <= MAX_TEXT_LENGTH_FOR_EXACT) {
                    locators.add("button:contains('" + escapeAttributeValue(text) + "')");
                }
                
                // Partial button text if text is long
                if (text.length() > 20) {
                    String partialText = text.substring(0, 20);
                    locators.add("button:contains('" + escapeAttributeValue(partialText) + "')");
                }
                
                // Button with type and text
                String type = fingerprint.getType();
                if (type != null && !type.isEmpty()) {
                    locators.add("button[type='" + escapeAttributeValue(type) + "']:contains('" + escapeAttributeValue(text) + "')");
                }
                break;
                
            case "input":
                // Input with value
                String value = fingerprint.getValue();
                if (value != null && !value.isEmpty()) {
                    locators.add("input[value='" + escapeAttributeValue(value) + "']");
                    
                    // Type-specific input
                    type = fingerprint.getType();
                    if (type != null && !type.isEmpty()) {
                        locators.add("input[type='" + escapeAttributeValue(type) + "'][value='" + escapeAttributeValue(value) + "']");
                    }
                }
                
                // Input with placeholder
                String placeholder = fingerprint.getAriaLabel(); // Often placeholder is stored as aria-label
                if (placeholder != null && !placeholder.isEmpty()) {
                    locators.add("input[placeholder='" + escapeAttributeValue(placeholder) + "']");
                }
                break;
                
            case "label":
                // Label text
                if (text.length() <= MAX_TEXT_LENGTH_FOR_EXACT) {
                    locators.add("label:contains('" + escapeAttributeValue(text) + "')");
                }
                
                // Label for attribute
                String forAttr = fingerprint.getAriaLabel(); // Sometimes "for" is captured as aria-label
                if (forAttr != null && !forAttr.isEmpty()) {
                    locators.add("label[for='" + escapeAttributeValue(forAttr) + "']");
                }
                break;
                
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
                // Heading text
                if (text.length() <= MAX_TEXT_LENGTH_FOR_EXACT) {
                    locators.add(tag + ":contains('" + escapeAttributeValue(text) + "')");
                }
                
                // Partial heading text if text is long
                if (text.length() > 20) {
                    String partialText = text.substring(0, 20);
                    locators.add(tag + ":contains('" + escapeAttributeValue(partialText) + "')");
                }
                break;
                
            default:
                // Default tag with text
                if (text.length() <= MAX_TEXT_LENGTH_FOR_EXACT) {
                    locators.add(tag + ":contains('" + escapeAttributeValue(text) + "')");
                }
                
                // Partial text if text is long
                if (text.length() > 20) {
                    String partialText = text.substring(0, 20);
                    locators.add(tag + ":contains('" + escapeAttributeValue(partialText) + "')");
                }
                
                // Class with text
                String className = fingerprint.getClassName();
                if (className != null && !className.isEmpty()) {
                    String[] classes = className.split("\\s+");
                    for (String cls : classes) {
                        if (!cls.isEmpty()) {
                            if (text.length() <= MAX_TEXT_LENGTH_FOR_EXACT) {
                                locators.add(tag + "." + escapeSelector(cls) + ":contains('" + escapeAttributeValue(text) + "')");
                            } else {
                                String partialText = text.substring(0, 20);
                                locators.add(tag + "." + escapeSelector(cls) + ":contains('" + escapeAttributeValue(partialText) + "')");
                            }
                            break; // Just use the first class to avoid too many combinations
                        }
                    }
                }
                break;
        }
        
        // Add XPath-style text locators (will be converted to proper XPath in findElementWithXPath)
        locators.add(String.format("xpath://%s[contains(text(),'%s')]", tag, text));
        
        if (text.length() > 20) {
            String partialText = text.substring(0, 20);
            locators.add(String.format("xpath://%s[contains(text(),'%s')]", tag, partialText));
        }
        
        // Add more specific XPath with class if available
        String className = fingerprint.getClassName();
        if (className != null && !className.isEmpty()) {
            String mainClass = className.split("\\s+")[0];
            if (!mainClass.isEmpty()) {
                locators.add(String.format("xpath://%s[contains(@class,'%s')][contains(text(),'%s')]", 
                        tag, mainClass, text));
            }
        }
        
        return locators.stream().distinct().collect(Collectors.toList());
    }
    
    /**
     * Finds the best matching locator from a list of candidates.
     * 
     * @param driver The WebDriver
     * @param locators List of candidate locators
     * @param fingerprint The original element fingerprint
     * @return The best matching locator, or null if none meets the threshold
     */
    private String findBestMatch(WebDriver driver, List<String> locators, ElementFingerprint fingerprint) {
        String bestLocator = null;
        double bestScore = 0.0;
        
        for (String locator : locators) {
            try {
                // Handle XPath locators separately
                if (locator.startsWith("xpath:")) {
                    continue;
                }
                
                List<WebElement> elements = driver.findElements(By.cssSelector(locator));
                
                // If we found too many elements, this locator is too general
                if (elements.size() > MAX_CANDIDATES) {
                    logger.debug("Locator found too many elements: " + locator + " (" + elements.size() + ")");
                    continue;
                }
                
                // If we found no elements, this locator doesn't work
                if (elements.isEmpty()) {
                    continue;
                }
                
                // For each element, calculate similarity score
                for (WebElement element : elements) {
                    ElementFingerprint candidateFingerprint = createFingerprint(driver, element, locator);
                    double similarity = SimilarityScorer.calculateSimilarity(fingerprint, candidateFingerprint);
                    
                    logger.debug("Locator: " + locator + ", Similarity: " + similarity);
                    
                    if (similarity > bestScore) {
                        bestScore = similarity;
                        bestLocator = locator;
                        
                        // If we found a very good match, we can stop searching
                        if (similarity >= 0.95) {
                            return bestLocator;
                        }
                    }
                }
            } catch (Exception e) {
                logger.debug("Error testing locator: " + locator, e);
            }
        }
        
        // Only return if the best score is above our threshold
        return bestScore >= MIN_SIMILARITY ? bestLocator : null;
    }
    
    /**
     * Tries to find an element using XPath text search.
     * 
     * @param driver The WebDriver
     * @param fingerprint The element fingerprint
     * @return An XPath locator if found, or null if no match
     */
    private String findElementWithXPath(WebDriver driver, ElementFingerprint fingerprint) {
        String tag = fingerprint.getTagName();
        String text = fingerprint.getText();
        
        if (tag == null || tag.isEmpty() || text == null || text.isEmpty()) {
            return null;
        }
        
        // Normalize text
        text = text.trim().replaceAll("\\s+", " ");
        
        if (text.isEmpty() || text.length() < MIN_TEXT_LENGTH) {
            return null;
        }
        
        try {
            // List of XPath expressions to try in order of preference
            List<String> xpaths = new ArrayList<>();
            
            // Exact text match
            if (text.length() <= MAX_TEXT_LENGTH_FOR_EXACT) {
                xpaths.add(String.format("//%s[text()='%s']", tag, escapeXPathValue(text)));
            }
            
            // Contains text
            xpaths.add(String.format("//%s[contains(text(),'%s')]", tag, escapeXPathValue(text)));
            
            // Start of text if longer
            if (text.length() > 20) {
                String partialText = text.substring(0, 20);
                xpaths.add(String.format("//%s[starts-with(text(),'%s')]", tag, escapeXPathValue(partialText)));
            }
            
            // With class if available
            String className = fingerprint.getClassName();
            if (className != null && !className.isEmpty()) {
                String mainClass = className.split("\\s+")[0];
                if (!mainClass.isEmpty()) {
                    xpaths.add(String.format("//%s[contains(@class,'%s')][contains(text(),'%s')]", 
                            tag, escapeXPathValue(mainClass), escapeXPathValue(text)));
                }
            }
            
            // Try each XPath
            for (String xpath : xpaths) {
                try {
                    List<WebElement> elements = driver.findElements(By.xpath(xpath));
                    
                    // If we found too many elements, this XPath is too general
                    if (elements.size() > MAX_CANDIDATES) {
                        continue;
                    }
                    
                    // If we found no elements, this XPath doesn't work
                    if (elements.isEmpty()) {
                        continue;
                    }
                    
                    // For each element, calculate similarity score
                    for (WebElement element : elements) {
                        ElementFingerprint candidateFingerprint = createFingerprint(driver, element, xpath);
                        double similarity = SimilarityScorer.calculateSimilarity(fingerprint, candidateFingerprint);
                        
                        if (similarity >= MIN_SIMILARITY) {
                            return xpath;
                        }
                    }
                } catch (Exception e) {
                    logger.debug("Error testing XPath: " + xpath, e);
                }
            }
        } catch (Exception e) {
            logger.warn("Error finding element with XPath", e);
        }
        
        return null;
    }
    
    /**
     * Uses JavaScript to find an element based on its text content.
     * 
     * @param driver The WebDriver
     * @param fingerprint The element fingerprint
     * @return A CSS selector if found, or null if no match
     */
    private String findElementWithJavaScript(WebDriver driver, ElementFingerprint fingerprint) {
        if (!(driver instanceof JavascriptExecutor)) {
            return null;
        }
        
        String tag = fingerprint.getTagName();
        String text = fingerprint.getText();
        
        if (tag == null || tag.isEmpty() || text == null || text.isEmpty()) {
            return null;
        }
        
        JavascriptExecutor js = (JavascriptExecutor) driver;
        
        try {
            // JavaScript to find elements by text content
            String script = 
                    "var tag = arguments[0];" +
                    "var text = arguments[1];" +
                    "var elements = document.getElementsByTagName(tag);" +
                    "var bestMatch = null;" +
                    "var bestScore = 0;" +
                    "" +
                    "function normalizeText(str) {" +
                    "    return (str || '').trim().replace(/\\s+/g, ' ');" +
                    "}" +
                    "" +
                    "function textSimilarity(a, b) {" +
                    "    a = normalizeText(a).toLowerCase();" +
                    "    b = normalizeText(b).toLowerCase();" +
                    "    " +
                    "    if (!a || !b) return 0;" +
                    "    if (a === b) return 1;" +
                    "    " +
                    "    // Check if one contains the other" +
                    "    if (a.includes(b)) return b.length / a.length;" +
                    "    if (b.includes(a)) return a.length / b.length;" +
                    "    " +
                    "    // Calculate character-by-character similarity" +
                    "    var matchCount = 0;" +
                    "    var maxLen = Math.max(a.length, b.length);" +
                    "    var minLen = Math.min(a.length, b.length);" +
                    "    " +
                    "    for (var i = 0; i < minLen; i++) {" +
                    "        if (a[i] === b[i]) matchCount++;" +
                    "    }" +
                    "    " +
                    "    return matchCount / maxLen;" +
                    "}" +
                    "" +
                    "for (var i = 0; i < elements.length; i++) {" +
                    "    var element = elements[i];" +
                    "    var elementText = element.textContent || element.innerText || '';" +
                    "    var similarity = textSimilarity(elementText, text);" +
                    "    " +
                    "    if (similarity > bestScore) {" +
                    "        bestScore = similarity;" +
                    "        bestMatch = element;" +
                    "    }" +
                    "}" +
                    "" +
                    "if (bestMatch && bestScore >= 0.7) {" +
                    "    // Generate a CSS selector for the best match" +
                    "    var selector = tag;" +
                    "    " +
                    "    // Add ID if available" +
                    "    if (bestMatch.id) {" +
                    "        return '#' + bestMatch.id;" +
                    "    }" +
                    "    " +
                    "    // Add class if available" +
                    "    if (bestMatch.className) {" +
                    "        var mainClass = bestMatch.className.split(/\\s+/)[0];" +
                    "        if (mainClass) {" +
                    "            selector += '.' + mainClass;" +
                    "        }" +
                    "    }" +
                    "    " +
                    "    // Add attribute selectors for exact text matching" +
                    "    if (bestScore > 0.9) {" +
                    "        return selector + ':contains(\"' + text + '\")';" +
                    "    }" +
                    "    " +
                    "    return selector;" +
                    "}" +
                    "" +
                    "return null;";
            
            Object result = js.executeScript(script, tag, text);
            
            if (result != null) {
                return result.toString();
            }
        } catch (Exception e) {
            logger.warn("Error finding element with JavaScript", e);
        }
        
        return null;
    }
    
    /**
     * Creates a fingerprint from a WebElement for comparison.
     * 
     * @param driver The WebDriver
     * @param element The WebElement
     * @param locator The locator used to find the element
     * @return The ElementFingerprint
     */
    private ElementFingerprint createFingerprint(WebDriver driver, WebElement element, String locator) {
        ElementFingerprint fingerprint = new ElementFingerprint();
        
        try {
            // Basic attributes
            fingerprint.setTagName(element.getTagName());
            fingerprint.setId(element.getAttribute("id"));
            fingerprint.setClassName(element.getAttribute("class"));
            fingerprint.setName(element.getAttribute("name"));
            fingerprint.setType(element.getAttribute("type"));
            fingerprint.setValue(element.getAttribute("value"));
            fingerprint.setText(element.getText());
            fingerprint.setHref(element.getAttribute("href"));
            fingerprint.setSrc(element.getAttribute("src"));
            fingerprint.setAlt(element.getAttribute("alt"));
            fingerprint.setTitle(element.getAttribute("title"));
            fingerprint.setRole(element.getAttribute("role"));
            fingerprint.setAriaLabel(element.getAttribute("aria-label"));
            
            // Position
            if (element.isDisplayed()) {
                fingerprint.setX(element.getLocation().getX());
                fingerprint.setY(element.getLocation().getY());
                fingerprint.setWidth(element.getSize().getWidth());
                fingerprint.setHeight(element.getSize().getHeight());
            }
            
            // Original locator for reference
            fingerprint.setOriginalLocator(locator);
            
        } catch (Exception e) {
            logger.warn("Error creating element fingerprint for comparison", e);
        }
        
        return fingerprint;
    }
    
    /**
     * Escapes special characters in CSS selectors.
     * 
     * @param selector The selector to escape
     * @return The escaped selector
     */
    private String escapeSelector(String selector) {
        if (selector == null) {
            return "";
        }
        
        // Escape special characters in CSS selectors
        return selector.replaceAll("([ #.:~+><!])", "\\\\$1");
    }
    
    /**
     * Escapes special characters in attribute values for CSS selectors.
     * 
     * @param value The attribute value to escape
     * @return The escaped attribute value
     */
    private String escapeAttributeValue(String value) {
        if (value == null) {
            return "";
        }
        
        // Escape quotes and backslashes in attribute values
        return value.replace("\\", "\\\\").replace("'", "\\'");
    }
    
    /**
     * Escapes special characters in XPath values.
     * 
     * @param value The XPath value to escape
     * @return The escaped XPath value
     */
    private String escapeXPathValue(String value) {
        if (value == null) {
            return "";
        }
        
        // XPath uses either single or double quotes, and doesn't have a built-in escape mechanism
        // If the string contains a single quote, use double quotes, and vice versa
        if (value.contains("'") && !value.contains("\"")) {
            return "\"" + value + "\"";
        } else if (value.contains("\"") && !value.contains("'")) {
            return "'" + value + "'";
        } else if (!value.contains("'")) {
            // Default to single quotes if neither is present
            return "'" + value + "'";
        } else {
            // If both are present, we need to use a concat expression
            // This is a simplified version; a complete implementation would handle this better
            StringBuilder result = new StringBuilder("concat(");
            boolean inQuote = false;
            StringBuilder currentPart = new StringBuilder("'");
            
            for (char c : value.toCharArray()) {
                if (c == '\'') {
                    if (inQuote) {
                        currentPart.append("'");
                        result.append(currentPart.toString());
                        result.append(",\"'\",");
                        currentPart = new StringBuilder("'");
                        inQuote = true;
                    } else {
                        if (currentPart.length() > 1) {
                            currentPart.append("'");
                            result.append(currentPart.toString());
                            result.append(",\"'\",");
                            currentPart = new StringBuilder("'");
                        } else {
                            result.append("\"'\",");
                        }
                    }
                } else {
                    currentPart.append(c);
                    inQuote = true;
                }
            }
            
            if (currentPart.length() > 1) {
                currentPart.append("'");
                result.append(currentPart.toString());
            }
            
            // Remove trailing comma if it exists
            if (result.charAt(result.length() - 1) == ',') {
                result.deleteCharAt(result.length() - 1);
            }
            
            result.append(")");
            return result.toString();
        }
    }
}



PositionHealingStrategy.java
-----------------------------------

package com.cstestforge.framework.core.selfhealing;

import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.Point;
import org.openqa.selenium.Dimension;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * A healing strategy that uses element position and dimensions to find alternative locators.
 * This is useful as a fallback when other attributes have changed but the element's
 * position and size within the page layout remain similar.
 */
public class PositionHealingStrategy implements HealingStrategy {
    private static final CSLogger logger = CSLogger.getLogger(PositionHealingStrategy.class);
    
    // Minimum similarity score required to consider a match
    private static final double MIN_SIMILARITY = 0.8;
    
    // Maximum position difference (in pixels) to consider a match
    private static final int MAX_POSITION_DIFFERENCE = 20;
    
    // Maximum size difference (in percentage) to consider a match
    private static final double MAX_SIZE_DIFFERENCE_PERCENT = 10.0;

    @Override
    public String heal(WebDriver driver, String originalLocator, ElementFingerprint fingerprint) {
        logger.debug("Attempting to heal locator using PositionHealingStrategy: " + originalLocator);
        
        if (driver == null || fingerprint == null) {
            logger.warn("Driver or fingerprint is null, cannot heal locator");
            return originalLocator;
        }
        
        if (!hasValidPositionData(fingerprint)) {
            logger.debug("Fingerprint has no valid position data, cannot use position healing strategy");
            return originalLocator;
        }
        
        try {
            // First, try to find elements by position using JavaScript
            String jsLocator = findElementByPositionWithJS(driver, fingerprint);
            if (jsLocator != null) {
                logger.info("Found healing locator by position with JavaScript: " + jsLocator);
                return jsLocator;
            }
            
            // If JS approach fails, try with standard selectors
            List<String> positionLocators = generatePositionBasedLocators(fingerprint);
            if (positionLocators.isEmpty()) {
                logger.debug("No position-based locators generated");
                return originalLocator;
            }
            
            logger.debug("Generated " + positionLocators.size() + " position-based locators");
            
            // Try to find the best match
            String bestLocator = findBestMatchByPosition(driver, positionLocators, fingerprint);
            if (bestLocator != null) {
                logger.info("Found healing locator by position matching: " + bestLocator);
                return bestLocator;
            }
            
            // Try to find by XPath with position predicates
            String xpathLocator = findByXPathWithPosition(driver, fingerprint);
            if (xpathLocator != null) {
                logger.info("Found healing locator using XPath with position: " + xpathLocator);
                return xpathLocator;
            }
            
            logger.debug("No suitable position-based healing locator found");
            return originalLocator;
            
        } catch (Exception e) {
            logger.error("Error in PositionHealingStrategy", e);
            return originalLocator;
        }
    }
    
    /**
     * Checks if the fingerprint has valid position data.
     * 
     * @param fingerprint The element fingerprint
     * @return true if the fingerprint has valid position data
     */
    private boolean hasValidPositionData(ElementFingerprint fingerprint) {
        return fingerprint.getWidth() > 0 && 
               fingerprint.getHeight() > 0 && 
               (fingerprint.getX() > 0 || fingerprint.getY() > 0);
    }
    
    /**
     * Generates locators based on element position and surrounding elements.
     * 
     * @param fingerprint The element fingerprint
     * @return List of position-based locators
     */
    private List<String> generatePositionBasedLocators(ElementFingerprint fingerprint) {
        List<String> locators = new ArrayList<>();
        
        String tag = fingerprint.getTagName();
        if (tag == null || tag.isEmpty()) {
            return locators;
        }
        
        // Add tag-only selector
        locators.add(tag);
        
        // Add class if available
        String className = fingerprint.getClassName();
        if (className != null && !className.isEmpty()) {
            String[] classes = className.split("\\s+");
            for (String cls : classes) {
                if (!cls.isEmpty()) {
                    locators.add(tag + "." + escapeSelector(cls));
                }
            }
        }
        
        // Add nth-child selectors
        if (fingerprint.getSiblingsData() != null) {
            int siblingCount = fingerprint.getSiblingsData().size();
            
            // Try with parent tag and nth-child
            String parentTag = fingerprint.getParentTagName();
            if (parentTag != null && !parentTag.isEmpty()) {
                // We don't know exactly which child index this element has without more context,
                // but we can generate some reasonable guesses
                for (int i = 1; i <= siblingCount + 1; i++) {
                    locators.add(parentTag.toLowerCase() + " > " + tag + ":nth-child(" + i + ")");
                }
            }
            
            // Try with parent class and nth-child
            String parentClass = fingerprint.getParentClass();
            if (parentClass != null && !parentClass.isEmpty()) {
                String[] parentClasses = parentClass.split("\\s+");
                if (parentClasses.length > 0 && !parentClasses[0].isEmpty()) {
                    String parentSelector = "." + escapeSelector(parentClasses[0]);
                    for (int i = 1; i <= siblingCount + 1; i++) {
                        locators.add(parentSelector + " > " + tag + ":nth-child(" + i + ")");
                    }
                }
            }
            
            // Try with parent ID and nth-child
            String parentId = fingerprint.getParentId();
            if (parentId != null && !parentId.isEmpty()) {
                String parentSelector = "#" + escapeSelector(parentId);
                for (int i = 1; i <= siblingCount + 1; i++) {
                    locators.add(parentSelector + " > " + tag + ":nth-child(" + i + ")");
                }
            }
        }
        
        // Add first/last selectors if appropriate
        locators.add(tag + ":first-child");
        locators.add(tag + ":last-child");
        
        return locators.stream().distinct().collect(Collectors.toList());
    }
    
    /**
     * Finds an element by position using JavaScript.
     * 
     * @param driver The WebDriver
     * @param fingerprint The element fingerprint
     * @return A CSS selector if found, or null if no match
     */
    private String findElementByPositionWithJS(WebDriver driver, ElementFingerprint fingerprint) {
        if (!(driver instanceof JavascriptExecutor)) {
            return null;
        }
        
        JavascriptExecutor js = (JavascriptExecutor) driver;
        
        try {
            int targetX = fingerprint.getX();
            int targetY = fingerprint.getY();
            int targetWidth = fingerprint.getWidth();
            int targetHeight = fingerprint.getHeight();
            String tagName = fingerprint.getTagName();
            
            // JavaScript to find elements by their position and size
            String script =
                    "function findElementByPosition(tagName, targetX, targetY, targetWidth, targetHeight, maxPosDiff, maxSizeDiffPercent) {" +
                    "    var elements = document.getElementsByTagName(tagName);" +
                    "    var bestMatch = null;" +
                    "    var bestScore = 0;" +
                    "    " +
                    "    function getPositionScore(el) {" +
                    "        var rect = el.getBoundingClientRect();" +
                    "        var x = rect.left + window.scrollX;" +
                    "        var y = rect.top + window.scrollY;" +
                    "        var width = rect.width;" +
                    "        var height = rect.height;" +
                    "        " +
                    "        // Check if dimensions are zero (element not visible)" +
                    "        if (width === 0 || height === 0) return 0;" +
                    "        " +
                    "        // Calculate position difference" +
                    "        var xDiff = Math.abs(x - targetX);" +
                    "        var yDiff = Math.abs(y - targetY);" +
                    "        var posDiff = Math.sqrt(xDiff*xDiff + yDiff*yDiff);" +
                    "        " +
                    "        // If position difference is too large, reject immediately" +
                    "        if (posDiff > maxPosDiff) return 0;" +
                    "        " +
                    "        // Calculate size differences as percentages" +
                    "        var widthDiffPercent = Math.abs(width - targetWidth) / Math.max(width, targetWidth) * 100;" +
                    "        var heightDiffPercent = Math.abs(height - targetHeight) / Math.max(height, targetHeight) * 100;" +
                    "        " +
                    "        // If size differences are too large, reject" +
                    "        if (widthDiffPercent > maxSizeDiffPercent || heightDiffPercent > maxSizeDiffPercent) return 0;" +
                    "        " +
                    "        // Calculate position score (1.0 = exact match, 0.0 = maxPosDiff away)" +
                    "        var positionScore = 1.0 - (posDiff / maxPosDiff);" +
                    "        " +
                    "        // Calculate size score (1.0 = exact match, 0.0 = maxSizeDiffPercent difference)" +
                    "        var sizeScore = 1.0 - ((widthDiffPercent + heightDiffPercent) / (2 * maxSizeDiffPercent));" +
                    "        " +
                    "        // Combined score (weight position less than size, as positions can vary more)" +
                    "        return positionScore * 0.4 + sizeScore * 0.6;" +
                    "    }" +
                    "    " +
                    "    for (var i = 0; i < elements.length; i++) {" +
                    "        var score = getPositionScore(elements[i]);" +
                    "        if (score > bestScore) {" +
                    "            bestScore = score;" +
                    "            bestMatch = elements[i];" +
                    "        }" +
                    "    }" +
                    "    " +
                    "    // If we found a good match, generate a CSS selector for it" +
                    "    if (bestMatch && bestScore > 0.8) {" +
                    "        // Generate the best selector we can" +
                    "        var selector = tagName;" +
                    "        " +
                    "        // ID is most reliable" +
                    "        if (bestMatch.id) {" +
                    "            return '#' + bestMatch.id;" +
                    "        }" +
                    "        " +
                    "        // Class is next best" +
                    "        if (bestMatch.className) {" +
                    "            var mainClass = bestMatch.className.split(/\\s+/)[0];" +
                    "            if (mainClass) {" +
                    "                selector += '.' + mainClass;" +
                    "            }" +
                    "        }" +
                    "        " +
                    "        // Try to add a more specific selector if possible" +
                    "        var parent = bestMatch.parentElement;" +
                    "        if (parent) {" +
                    "            if (parent.id) {" +
                    "                return '#' + parent.id + ' > ' + selector;" +
                    "            }" +
                    "            " +
                    "            if (parent.className) {" +
                    "                var parentClass = parent.className.split(/\\s+/)[0];" +
                    "                if (parentClass) {" +
                    "                    return '.' + parentClass + ' > ' + selector;" +
                    "                }" +
                    "            }" +
                    "            " +
                    "            // Try nth-child" +
                    "            var siblings = parent.children;" +
                    "            for (var j = 0; j < siblings.length; j++) {" +
                    "                if (siblings[j] === bestMatch) {" +
                    "                    return parent.tagName.toLowerCase() + ' > ' + selector + ':nth-child(' + (j+1) + ')';" +
                    "                }" +
                    "            }" +
                    "        }" +
                    "        " +
                    "        return selector;" +
                    "    }" +
                    "    " +
                    "    return null;" +
                    "}" +
                    "" +
                    "return findElementByPosition(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);";
            
            Object result = js.executeScript(script, tagName.toLowerCase(), targetX, targetY, targetWidth, targetHeight, 
                                             MAX_POSITION_DIFFERENCE, MAX_SIZE_DIFFERENCE_PERCENT);
            
            if (result != null) {
                return result.toString();
            }
        } catch (Exception e) {
            logger.warn("Error finding element by position with JavaScript", e);
        }
        
        return null;
    }
    
    /**
     * Finds the best matching locator by comparing element positions.
     * 
     * @param driver The WebDriver
     * @param locators List of candidate locators
     * @param fingerprint The original element fingerprint
     * @return The best matching locator, or null if none meets the criteria
     */
    private String findBestMatchByPosition(WebDriver driver, List<String> locators, ElementFingerprint fingerprint) {
        String bestLocator = null;
        double bestScore = 0.0;
        
        for (String locator : locators) {
            try {
                List<WebElement> elements = driver.findElements(By.cssSelector(locator));
                
                // If we found no elements, this locator doesn't work
                if (elements.isEmpty()) {
                    continue;
                }
                
                // For each element, calculate position similarity score
                for (WebElement element : elements) {
                    if (!element.isDisplayed()) {
                        continue;
                    }
                    
                    double score = calculatePositionSimilarity(fingerprint, element);
                    
                    logger.debug("Locator: " + locator + ", Position similarity: " + score);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestLocator = locator;
                        
                        // If we found a very good match, we can stop searching
                        if (score >= 0.95) {
                            return bestLocator;
                        }
                    }
                }
            } catch (Exception e) {
                logger.debug("Error testing locator: " + locator, e);
            }
        }
        
        // Only return if the best score is above our threshold
        return bestScore >= MIN_SIMILARITY ? bestLocator : null;
    }
    
    /**
     * Calculates position similarity between fingerprint and element.
     * 
     * @param fingerprint The element fingerprint
     * @param element The WebElement to compare
     * @return Similarity score between 0.0 and 1.0
     */
    private double calculatePositionSimilarity(ElementFingerprint fingerprint, WebElement element) {
        try {
            // Get element position and size
            Point location = element.getLocation();
            Dimension size = element.getSize();
            
            int elementX = location.getX();
            int elementY = location.getY();
            int elementWidth = size.getWidth();
            int elementHeight = size.getHeight();
            
            // Get fingerprint position and size
            int targetX = fingerprint.getX();
            int targetY = fingerprint.getY();
            int targetWidth = fingerprint.getWidth();
            int targetHeight = fingerprint.getHeight();
            
            // Calculate position difference
            double xDiff = Math.abs(elementX - targetX);
            double yDiff = Math.abs(elementY - targetY);
            double posDiff = Math.sqrt(xDiff*xDiff + yDiff*yDiff);
            
            // Calculate position score (1.0 = exact match, 0.0 = maxPosDiff away)
            double positionScore = Math.max(0.0, 1.0 - (posDiff / MAX_POSITION_DIFFERENCE));
            
            // Calculate size differences as percentages
            double widthDiffPercent = Math.abs(elementWidth - targetWidth) / (double) Math.max(elementWidth, targetWidth) * 100.0;
            double heightDiffPercent = Math.abs(elementHeight - targetHeight) / (double) Math.max(elementHeight, targetHeight) * 100.0;
            
            // Calculate size score (1.0 = exact match, 0.0 = maxSizeDiffPercent difference)
            double sizeScore = Math.max(0.0, 1.0 - ((widthDiffPercent + heightDiffPercent) / (2.0 * MAX_SIZE_DIFFERENCE_PERCENT)));
            
            // Combined score (weight position less than size, as positions can vary more)
            return positionScore * 0.4 + sizeScore * 0.6;
            
        } catch (Exception e) {
            logger.warn("Error calculating position similarity", e);
            return 0.0;
        }
    }
    
    /**
     * Tries to find an element using XPath with position predicates.
     * 
     * @param driver The WebDriver
     * @param fingerprint The element fingerprint
     * @return An XPath locator if found, or null if no match
     */
    private String findByXPathWithPosition(WebDriver driver, ElementFingerprint fingerprint) {
        String tag = fingerprint.getTagName();
        
        if (tag == null || tag.isEmpty()) {
            return null;
        }
        
        try {
            // Generate XPath expressions with position information
            List<String> xpaths = new ArrayList<>();
            
            // Try by position in parent (nth-child)
            String parentTag = fingerprint.getParentTagName();
            if (parentTag != null && !parentTag.isEmpty()) {
                for (int i = 1; i <= 10; i++) {  // Try reasonable indexes
                    xpaths.add(String.format("//%s/%s[%d]", parentTag.toLowerCase(), tag, i));
                }
            }
            
            // Try with class
            String className = fingerprint.getClassName();
            if (className != null && !className.isEmpty()) {
                String[] classes = className.split("\\s+");
                for (String cls : classes) {
                    if (!cls.isEmpty()) {
                        xpaths.add(String.format("//%s[contains(@class,'%s')]", tag, cls));
                    }
                }
            }
            
            // Try with parent class
            String parentClass = fingerprint.getParentClass();
            if (parentClass != null && !parentClass.isEmpty() && parentTag != null && !parentTag.isEmpty()) {
                String[] parentClasses = parentClass.split("\\s+");
                for (String cls : parentClasses) {
                    if (!cls.isEmpty()) {
                        xpaths.add(String.format("//%s[contains(@class,'%s')]/%s", 
                                parentTag.toLowerCase(), cls, tag));
                    }
                }
            }
            
            // Try each XPath and find the best match by position
            String bestXPath = null;
            double bestScore = 0.0;
            
            for (String xpath : xpaths) {
                try {
                    List<WebElement> elements = driver.findElements(By.xpath(xpath));
                    
                    if (elements.isEmpty()) {
                        continue;
                    }
                    
                    for (WebElement element : elements) {
                        if (!element.isDisplayed()) {
                            continue;
                        }
                        
                        double score = calculatePositionSimilarity(fingerprint, element);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestXPath = xpath;
                            
                            if (score >= 0.95) {
                                return bestXPath;
                            }
                        }
                    }
                } catch (Exception e) {
                    logger.debug("Error testing XPath: " + xpath, e);
                }
            }
            
            return bestScore >= MIN_SIMILARITY ? bestXPath : null;
            
        } catch (Exception e) {
            logger.warn("Error finding element with XPath position predicates", e);
            return null;
        }
    }
    
    /**
     * Escapes special characters in CSS selectors.
     * 
     * @param selector The selector to escape
     * @return The escaped selector
     */
    private String escapeSelector(String selector) {
        if (selector == null) {
            return "";
        }
        
        // Escape special characters in CSS selectors
        return selector.replaceAll("([ #.:~+><!])", "\\\\$1");
    }
}


StructureHealingStrategy.java
------------------------------------

package com.cstestforge.framework.core.selfhealing;

import com.cstestforge.framework.core.utils.CSLogger;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * A healing strategy that uses DOM structure and relationships to find alternative locators.
 * This strategy focuses on parent-child relationships, sibling positions, and structural paths
 * to locate elements when other identifying attributes have changed.
 */
public class StructureHealingStrategy implements HealingStrategy {
    private static final CSLogger logger = CSLogger.getLogger(StructureHealingStrategy.class);
    
    // Minimum similarity score required to consider a match
    private static final double MIN_SIMILARITY = 0.8;
    
    // Maximum number of candidate elements to evaluate
    private static final int MAX_CANDIDATES = 10;

    @Override
    public String heal(WebDriver driver, String originalLocator, ElementFingerprint fingerprint) {
        logger.debug("Attempting to heal locator using StructureHealingStrategy: " + originalLocator);
        
        if (driver == null || fingerprint == null) {
            logger.warn("Driver or fingerprint is null, cannot heal locator");
            return originalLocator;
        }
        
        if (!hasValidStructuralData(fingerprint)) {
            logger.debug("Fingerprint has insufficient structural data, cannot use structure healing strategy");
            return originalLocator;
        }
        
        try {
            // Generate structural locators
            List<String> structuralLocators = generateStructuralLocators(fingerprint);
            
            if (structuralLocators.isEmpty()) {
                logger.debug("No structural locators generated");
                return originalLocator;
            }
            
            logger.debug("Generated " + structuralLocators.size() + " structural locators");
            
            // Find the best match using standard locators
            String bestLocator = findBestMatchByStructure(driver, structuralLocators, fingerprint);
            if (bestLocator != null) {
                logger.info("Found healing locator using DOM structure: " + bestLocator);
                return bestLocator;
            }
            
            // Try with XPath if CSS selectors didn't work
            String xpathLocator = findElementWithXPath(driver, fingerprint);
            if (xpathLocator != null) {
                logger.info("Found healing locator using XPath structure: " + xpathLocator);
                return xpathLocator;
            }
            
            // Try with JavaScript traversal
            String jsLocator = findElementWithJavaScript(driver, fingerprint);
            if (jsLocator != null) {
                logger.info("Found healing locator using JavaScript DOM traversal: " + jsLocator);
                return jsLocator;
            }
            
            logger.debug("No suitable structural healing locator found");
            return originalLocator;
            
        } catch (Exception e) {
            logger.error("Error in StructureHealingStrategy", e);
            return originalLocator;
        }
    }
    
    /**
     * Checks if the fingerprint has valid structural data.
     * 
     * @param fingerprint The element fingerprint
     * @return true if the fingerprint has valid structural data
     */
    private boolean hasValidStructuralData(ElementFingerprint fingerprint) {
        // Need at least some parent information
        return fingerprint.getTagName() != null && !fingerprint.getTagName().isEmpty() &&
               ((fingerprint.getParentTagName() != null && !fingerprint.getParentTagName().isEmpty()) ||
                (fingerprint.getParentId() != null && !fingerprint.getParentId().isEmpty()) ||
                (fingerprint.getParentClass() != null && !fingerprint.getParentClass().isEmpty()) ||
                (fingerprint.getXPath() != null && !fingerprint.getXPath().isEmpty()));
    }
    
    /**
     * Generates CSS selectors based on DOM structure.
     * 
     * @param fingerprint The element fingerprint
     * @return List of structural CSS selectors
     */
    private List<String> generateStructuralLocators(ElementFingerprint fingerprint) {
        List<String> locators = new ArrayList<>();
        
        String tag = fingerprint.getTagName();
        if (tag == null || tag.isEmpty()) {
            return locators;
        }
        
        // Use parent ID if available (very reliable)
        String parentId = fingerprint.getParentId();
        if (parentId != null && !parentId.isEmpty()) {
            locators.add("#" + escapeSelector(parentId) + " > " + tag);
            
            // Add class to make it more specific
            String className = fingerprint.getClassName();
            if (className != null && !className.isEmpty()) {
                String[] classes = className.split("\\s+");
                for (String cls : classes) {
                    if (!cls.isEmpty()) {
                        locators.add("#" + escapeSelector(parentId) + " > " + tag + "." + escapeSelector(cls));
                    }
                }
            }
        }
        
        // Use parent class if available
        String parentClass = fingerprint.getParentClass();
        String parentTag = fingerprint.getParentTagName();
        if (parentClass != null && !parentClass.isEmpty() && parentTag != null && !parentTag.isEmpty()) {
            String[] parentClasses = parentClass.split("\\s+");
            for (String cls : parentClasses) {
                if (!cls.isEmpty()) {
                    String parentSelector = parentTag.toLowerCase() + "." + escapeSelector(cls);
                    locators.add(parentSelector + " > " + tag);
                    
                    // Add element class for more specificity
                    String className = fingerprint.getClassName();
                    if (className != null && !className.isEmpty()) {
                        String[] classes = className.split("\\s+");
                        for (String elementClass : classes) {
                            if (!elementClass.isEmpty()) {
                                locators.add(parentSelector + " > " + tag + "." + escapeSelector(elementClass));
                            }
                        }
                    }
                }
            }
        } else if (parentTag != null && !parentTag.isEmpty()) {
            // Just use parent tag if class not available
            locators.add(parentTag.toLowerCase() + " > " + tag);
        }
        
        // Try with sibling information
        List<Map<String, String>> siblingsData = fingerprint.getSiblingsData();
        if (siblingsData != null && !siblingsData.isEmpty()) {
            // Add nth-child selectors based on the number of siblings
            int siblingCount = siblingsData.size();
            
            // Try with parent selectors
            if (parentId != null && !parentId.isEmpty()) {
                for (int i = 1; i <= siblingCount + 1; i++) {
                    locators.add("#" + escapeSelector(parentId) + " > " + tag + ":nth-child(" + i + ")");
                }
            } else if (parentClass != null && !parentClass.isEmpty() && parentTag != null && !parentTag.isEmpty()) {
                String[] parentClasses = parentClass.split("\\s+");
                if (parentClasses.length > 0 && !parentClasses[0].isEmpty()) {
                    String parentSelector = parentTag.toLowerCase() + "." + escapeSelector(parentClasses[0]);
                    for (int i = 1; i <= siblingCount + 1; i++) {
                        locators.add(parentSelector + " > " + tag + ":nth-child(" + i + ")");
                    }
                }
            } else if (parentTag != null && !parentTag.isEmpty()) {
                for (int i = 1; i <= siblingCount + 1; i++) {
                    locators.add(parentTag.toLowerCase() + " > " + tag + ":nth-child(" + i + ")");
                }
            }
            
            // Try adjacent sibling selectors
            for (Map<String, String> sibling : siblingsData) {
                String siblingTag = sibling.get("tagName");
                String siblingClass = sibling.get("className");
                
                if (siblingTag != null && !siblingTag.isEmpty()) {
                    // Convert tagName to lowercase (browser returns uppercase tags)
                    siblingTag = siblingTag.toLowerCase();
                    
                    // Simple adjacent selector
                    locators.add(siblingTag + " + " + tag);
                    
                    // With sibling class
                    if (siblingClass != null && !siblingClass.isEmpty()) {
                        String[] siblingClasses = siblingClass.split("\\s+");
                        for (String cls : siblingClasses) {
                            if (!cls.isEmpty()) {
                                locators.add(siblingTag + "." + escapeSelector(cls) + " + " + tag);
                            }
                        }
                    }
                    
                    // With element class
                    String className = fingerprint.getClassName();
                    if (className != null && !className.isEmpty()) {
                        String[] classes = className.split("\\s+");
                        for (String cls : classes) {
                            if (!cls.isEmpty()) {
                                locators.add(siblingTag + " + " + tag + "." + escapeSelector(cls));
                                
                                // With both sibling and element class
                                if (siblingClass != null && !siblingClass.isEmpty()) {
                                    String[] siblingClasses = siblingClass.split("\\s+");
                                    for (String sibCls : siblingClasses) {
                                        if (!sibCls.isEmpty()) {
                                            locators.add(siblingTag + "." + escapeSelector(sibCls) + " + " + 
                                                        tag + "." + escapeSelector(cls));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Try parent-child relationships with class combinations
        String className = fingerprint.getClassName();
        if (className != null && !className.isEmpty() && parentClass != null && !parentClass.isEmpty() && 
            parentTag != null && !parentTag.isEmpty()) {
            
            String[] classes = className.split("\\s+");
            String[] parentClasses = parentClass.split("\\s+");
            
            for (String cls : classes) {
                if (!cls.isEmpty()) {
                    for (String parentCls : parentClasses) {
                        if (!parentCls.isEmpty()) {
                            locators.add(parentTag.toLowerCase() + "." + escapeSelector(parentCls) + " " + 
                                         tag + "." + escapeSelector(cls));
                        }
                    }
                }
            }
        }
        
        // If we have XPath, try to convert it to CSS where possible
        String xpath = fingerprint.getXPath();
        if (xpath != null && !xpath.isEmpty()) {
            try {
                // Very simple conversion for basic XPaths
                // This won't handle complex XPaths with predicates, but works for simple paths
                if (xpath.matches("^/html/body(/[^/\\[\\]]+)+$")) {
                    String cssPath = xpath.replaceAll("^/html/body/", "")
                            .replace("/", " > ")
                            .toLowerCase();
                    locators.add(cssPath);
                }
            } catch (Exception e) {
                logger.debug("Error converting XPath to CSS: " + xpath, e);
            }
        }
        
        return locators.stream().distinct().collect(Collectors.toList());
    }
    
    /**
     * Finds the best matching locator by comparing element structure.
     * 
     * @param driver The WebDriver
     * @param locators List of candidate locators
     * @param fingerprint The original element fingerprint
     * @return The best matching locator, or null if none meets the criteria
     */
    private String findBestMatchByStructure(WebDriver driver, List<String> locators, ElementFingerprint fingerprint) {
        String bestLocator = null;
        double bestScore = 0.0;
        
        for (String locator : locators) {
            try {
                List<WebElement> elements = driver.findElements(By.cssSelector(locator));
                
                // If we found too many elements, this locator is too general
                if (elements.size() > MAX_CANDIDATES) {
                    logger.debug("Locator found too many elements: " + locator + " (" + elements.size() + ")");
                    continue;
                }
                
                // If we found no elements, this locator doesn't work
                if (elements.isEmpty()) {
                    continue;
                }
                
                // For each element, calculate structural similarity score
                for (WebElement element : elements) {
                    ElementFingerprint candidateFingerprint = createFingerprint(driver, element, locator);
                    double similarity = SimilarityScorer.calculateSimilarity(fingerprint, candidateFingerprint);
                    
                    logger.debug("Locator: " + locator + ", Structural similarity: " + similarity);
                    
                    if (similarity > bestScore) {
                        bestScore = similarity;
                        bestLocator = locator;
                        
                        // If we found a very good match, we can stop searching
                        if (similarity >= 0.95) {
                            return bestLocator;
                        }
                    }
                }
            } catch (Exception e) {
                logger.debug("Error testing locator: " + locator, e);
            }
        }
        
        // Only return if the best score is above our threshold
        return bestScore >= MIN_SIMILARITY ? bestLocator : null;
    }
    
    /**
     * Tries to find an element using XPath structural selectors.
     * 
     * @param driver The WebDriver
     * @param fingerprint The element fingerprint
     * @return An XPath locator if found, or null if no match
     */
    private String findElementWithXPath(WebDriver driver, ElementFingerprint fingerprint) {
        String tag = fingerprint.getTagName();
        String parentTag = fingerprint.getParentTagName();
        String xpath = fingerprint.getXPath();
        
        if (tag == null || tag.isEmpty()) {
            return null;
        }
        
        List<String> xpaths = new ArrayList<>();
        
        // If we have the original XPath, try it first
        if (xpath != null && !xpath.isEmpty()) {
            xpaths.add(xpath);
        }
        
        // Create structural XPaths
        if (parentTag != null && !parentTag.isEmpty()) {
            // Parent with tag
            xpaths.add("//" + parentTag.toLowerCase() + "/" + tag);
            
            // Parent with ID
            String parentId = fingerprint.getParentId();
            if (parentId != null && !parentId.isEmpty()) {
                xpaths.add("//" + parentTag.toLowerCase() + "[@id='" + escapeXPathValue(parentId) + "']/" + tag);
            }
            
            // Parent with class
            String parentClass = fingerprint.getParentClass();
            if (parentClass != null && !parentClass.isEmpty()) {
                String[] parentClasses = parentClass.split("\\s+");
                for (String cls : parentClasses) {
                    if (!cls.isEmpty()) {
                        xpaths.add("//" + parentTag.toLowerCase() + "[contains(@class,'" + escapeXPathValue(cls) + "')]/" + tag);
                    }
                }
            }
            
            // Try with position (nth-child)
            for (int i = 1; i <= 10; i++) {  // Try reasonable indexes
                // With parent tag only
                xpaths.add("//" + parentTag.toLowerCase() + "/" + tag + "[" + i + "]");
                
                // With parent ID
                if (parentId != null && !parentId.isEmpty()) {
                    xpaths.add("//" + parentTag.toLowerCase() + "[@id='" + escapeXPathValue(parentId) + "']/" + tag + "[" + i + "]");
                }
                
                // With parent class
                if (parentClass != null && !parentClass.isEmpty()) {
                    String[] parentClasses = parentClass.split("\\s+");
                    if (parentClasses.length > 0 && !parentClasses[0].isEmpty()) {
                        xpaths.add("//" + parentTag.toLowerCase() + "[contains(@class,'" + escapeXPathValue(parentClasses[0]) + "')]/" + 
                                  tag + "[" + i + "]");
                    }
                }
            }
        }
        
        // Try with element class
        String className = fingerprint.getClassName();
        if (className != null && !className.isEmpty()) {
            String[] classes = className.split("\\s+");
            for (String cls : classes) {
                if (!cls.isEmpty()) {
                    xpaths.add("//" + tag + "[contains(@class,'" + escapeXPathValue(cls) + "')]");
                    
                    // With parent
                    if (parentTag != null && !parentTag.isEmpty()) {
                        xpaths.add("//" + parentTag.toLowerCase() + "/" + tag + "[contains(@class,'" + escapeXPathValue(cls) + "')]");
                        
                        // With parent ID
                        String parentId = fingerprint.getParentId();
                        if (parentId != null && !parentId.isEmpty()) {
                            xpaths.add("//" + parentTag.toLowerCase() + "[@id='" + escapeXPathValue(parentId) + "']/" + 
                                      tag + "[contains(@class,'" + escapeXPathValue(cls) + "')]");
                        }
                        
                        // With parent class
                        String parentClass = fingerprint.getParentClass();
                        if (parentClass != null && !parentClass.isEmpty()) {
                            String[] parentClasses = parentClass.split("\\s+");
                            if (parentClasses.length > 0 && !parentClasses[0].isEmpty()) {
                                xpaths.add("//" + parentTag.toLowerCase() + "[contains(@class,'" + escapeXPathValue(parentClasses[0]) + "')]/" + 
                                          tag + "[contains(@class,'" + escapeXPathValue(cls) + "')]");
                            }
                        }
                    }
                }
            }
        }
        
        // Try ancestor-based paths
        xpaths.add("//ancestor::*[1]/" + tag);
        xpaths.add("//ancestor::*[2]/" + tag);
        
        // Try each XPath and find the best match
        String bestXPath = null;
        double bestScore = 0.0;
        
        for (String xpathLocator : xpaths) {
            try {
                List<WebElement> elements = driver.findElements(By.xpath(xpathLocator));
                
                // If we found too many elements, this XPath is too general
                if (elements.size() > MAX_CANDIDATES) {
                    continue;
                }
                
                // If we found no elements, this XPath doesn't work
                if (elements.isEmpty()) {
                    continue;
                }
                
                // For each element, calculate structural similarity score
                for (WebElement element : elements) {
                    ElementFingerprint candidateFingerprint = createFingerprint(driver, element, xpathLocator);
                    double similarity = SimilarityScorer.calculateSimilarity(fingerprint, candidateFingerprint);
                    
                    if (similarity > bestScore) {
                        bestScore = similarity;
                        bestXPath = xpathLocator;
                        
                        if (similarity >= 0.95) {
                            return bestXPath;
                        }
                    }
                }
            } catch (Exception e) {
                logger.debug("Error testing XPath: " + xpathLocator, e);
            }
        }
        
        return bestScore >= MIN_SIMILARITY ? bestXPath : null;
    }
    
    /**
     * Uses JavaScript to find an element using DOM structure traversal.
     * 
     * @param driver The WebDriver
     * @param fingerprint The element fingerprint
     * @return A locator if found, or null if no match
     */
    private String findElementWithJavaScript(WebDriver driver, ElementFingerprint fingerprint) {
        if (!(driver instanceof JavascriptExecutor)) {
            return null;
        }
        
        JavascriptExecutor js = (JavascriptExecutor) driver;
        
        try {
            Map<String, Object> params = new HashMap<>();
            params.put("tagName", fingerprint.getTagName());
            params.put("parentTagName", fingerprint.getParentTagName());
            params.put("className", fingerprint.getClassName());
            params.put("parentClassName", fingerprint.getParentClass());
            params.put("id", fingerprint.getId());
            params.put("parentId", fingerprint.getParentId());
            
            // JavaScript to find elements by traversing DOM structure
            String script =
                    "function findElementByStructure(params) {" +
                    "    var tagName = params.tagName && params.tagName.toLowerCase();" +
                    "    var parentTagName = params.parentTagName && params.parentTagName.toLowerCase();" +
                    "    var className = params.className;" +
                    "    var parentClassName = params.parentClassName;" +
                    "    var id = params.id;" +
                    "    var parentId = params.parentId;" +
                    "    " +
                    "    if (!tagName) return null;" +
                    "    " +
                    "    var candidates = document.getElementsByTagName(tagName);" +
                    "    var bestMatch = null;" +
                    "    var bestScore = 0;" +
                    "    " +
                    "    function getStructuralScore(element) {" +
                    "        var score = 0;" +
                    "        var totalWeight = 0;" +
                    "        " +
                    "        // Check basic element attributes" +
                    "        if (id && element.id === id) {" +
                    "            return 1.0; // Perfect match if ID matches" +
                    "        }" +
                    "        " +
                    "        // Check element class" +
                    "        if (className && element.className) {" +
                    "            var elementClasses = element.className.split(/\\s+/);" +
                    "            var fingerprintClasses = className.split(/\\s+/);" +
                    "            var matchCount = 0;" +
                    "            " +
                    "            for (var i = 0; i < fingerprintClasses.length; i++) {" +
                    "                if (elementClasses.indexOf(fingerprintClasses[i]) >= 0) {" +
                    "                    matchCount++;" +
                    "                }" +
                    "            }" +
                    "            " +
                    "            var classScore = fingerprintClasses.length > 0 ? " +
                    "                matchCount / fingerprintClasses.length : 0;" +
                    "            score += classScore * 0.3;" +
                    "            totalWeight += 0.3;" +
                    "        }" +
                    "        " +
                    "        // Check parent structure" +
                    "        var parent = element.parentElement;" +
                    "        if (parent) {" +
                    "            // Parent tag name" +
                    "            if (parentTagName && parent.tagName.toLowerCase() === parentTagName) {" +
                    "                score += 0.2;" +
                    "                totalWeight += 0.2;" +
                    "            } else if (parentTagName) {" +
                    "                totalWeight += 0.2;" +
                    "            }" +
                    "            " +
                    "            // Parent ID" +
                    "            if (parentId && parent.id === parentId) {" +
                    "                score += 0.3;" +
                    "                totalWeight += 0.3;" +
                    "            } else if (parentId) {" +
                    "                totalWeight += 0.3;" +
                    "            }" +
                    "            " +
                    "            // Parent class" +
                    "            if (parentClassName && parent.className) {" +
                    "                var parentElementClasses = parent.className.split(/\\s+/);" +
                    "                var parentFingerprintClasses = parentClassName.split(/\\s+/);" +
                    "                var parentMatchCount = 0;" +
                    "                " +
                    "                for (var j = 0; j < parentFingerprintClasses.length; j++) {" +
                    "                    if (parentElementClasses.indexOf(parentFingerprintClasses[j]) >= 0) {" +
                    "                        parentMatchCount++;" +
                    "                    }" +
                    "                }" +
                    "                " +
                    "                var parentClassScore = parentFingerprintClasses.length > 0 ? " +
                    "                    parentMatchCount / parentFingerprintClasses.length : 0;" +
                    "                score += parentClassScore * 0.2;" +
                    "                totalWeight += 0.2;" +
                    "            }" +
                    "            " +
                    "            // Check siblings" +
                    "            var siblings = parent.children;" +
                    "            var siblingIndex = -1;" +
                    "            " +
                    "            for (var k = 0; k < siblings.length; k++) {" +
                    "                if (siblings[k] === element) {" +
                    "                    siblingIndex = k;" +
                    "                    break;" +
                    "                }" +
                    "            }" +
                    "            " +
                    "            // Check if this is the only element with this tag as a child of its parent" +
                    "            var sameTagSiblings = parent.querySelectorAll(':scope > ' + tagName);" +
                    "            if (sameTagSiblings.length === 1) {" +
                    "                score += 0.1;" +
                    "                totalWeight += 0.1;" +
                    "            }" +
                    "        }" +
                    "        " +
                    "        return totalWeight > 0 ? score / totalWeight : 0;" +
                    "    }" +
                    "    " +
                    "    for (var i = 0; i < candidates.length; i++) {" +
                    "        var score = getStructuralScore(candidates[i]);" +
                    "        if (score > bestScore) {" +
                    "            bestScore = score;" +
                    "            bestMatch = candidates[i];" +
                    "        }" +
                    "    }" +
                    "    " +
                    "    if (bestMatch && bestScore >= 0.8) {" +
                    "        // Generate a CSS selector for the best match" +
                    "        var selector = null;" +
                    "        " +
                    "        // ID is most reliable" +
                    "        if (bestMatch.id) {" +
                    "            return '#' + bestMatch.id;" +
                    "        }" +
                    "        " +
                    "        // Start with tag" +
                    "        selector = tagName;" +
                    "        " +
                    "        // Add class if available" +
                    "        if (bestMatch.className) {" +
                    "            var mainClass = bestMatch.className.split(/\\s+/)[0];" +
                    "            if (mainClass) {" +
                    "                selector += '.' + mainClass;" +
                    "            }" +
                    "        }" +
                    "        " +
                    "        // Try to add parent context" +
                    "        var parent = bestMatch.parentElement;" +
                    "        if (parent) {" +
                    "            if (parent.id) {" +
                    "                return '#' + parent.id + ' > ' + selector;" +
                    "            }" +
                    "            " +
                    "            if (parent.className) {" +
                    "                var parentClass = parent.className.split(/\\s+/)[0];" +
                    "                if (parentClass) {" +
                    "                    return parent.tagName.toLowerCase() + '.' + parentClass + ' > ' + selector;" +
                    "                }" +
                    "            }" +
                    "            " +
                    "            // Try to use nth-child" +
                    "            var siblings = parent.children;" +
                    "            for (var j = 0; j < siblings.length; j++) {" +
                    "                if (siblings[j] === bestMatch) {" +
                    "                    return parent.tagName.toLowerCase() + ' > ' + selector + ':nth-child(' + (j+1) + ')';" +
                    "                }" +
                    "            }" +
                    "            " +
                    "            // Last resort: use parent tag" +
                    "            return parent.tagName.toLowerCase() + ' > ' + selector;" +
                    "        }" +
                    "        " +
                    "        return selector;" +
                    "    }" +
                    "    " +
                    "    return null;" +
                    "}" +
                    "" +
                    "return findElementByStructure(arguments[0]);";
            
            Object result = js.executeScript(script, params);
            
            if (result != null) {
                return result.toString();
            }
        } catch (Exception e) {
            logger.warn("Error finding element with JavaScript DOM traversal", e);
        }
        
        return null;
    }
    
    /**
     * Creates a fingerprint from a WebElement for comparison.
     * 
     * @param driver The WebDriver
     * @param element The WebElement
     * @param locator The locator used to find the element
     * @return The ElementFingerprint
     */
    private ElementFingerprint createFingerprint(WebDriver driver, WebElement element, String locator) {
        ElementFingerprint fingerprint = new ElementFingerprint();
        
        try {
            // Basic attributes
            fingerprint.setTagName(element.getTagName());
            fingerprint.setId(element.getAttribute("id"));
            fingerprint.setClassName(element.getAttribute("class"));
            
            // Get parent information
            if (driver instanceof JavascriptExecutor) {
                JavascriptExecutor js = (JavascriptExecutor) driver;
                
                try {
                    fingerprint.setParentTagName((String) js.executeScript(
                            "return arguments[0].parentNode.tagName;", element));
                    fingerprint.setParentId((String) js.executeScript(
                            "return arguments[0].parentNode.id;", element));
                    fingerprint.setParentClass((String) js.executeScript(
                            "return arguments[0].parentNode.className;", element));
                } catch (Exception e) {
                    logger.debug("Error getting parent info", e);
                }
                
                try {
                    String xpath = (String) js.executeScript(
                            "function getXPath(element) {" +
                            "    if (element.id !== '') return '//*[@id=\"' + element.id + '\"]';" +
                            "    if (element === document.body) return '/html/body';" +
                            "    var ix = 0;" +
                            "    var siblings = element.parentNode.childNodes;" +
                            "    for (var i = 0; i < siblings.length; i++) {" +
                            "        var sibling = siblings[i];" +
                            "        if (sibling === element) return getXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (ix + 1) + ']';" +
                            "        if (sibling.nodeType === 1 && sibling.tagName === element.tagName) ix++;" +
                            "    }" +
                            "}" +
                            "return getXPath(arguments[0]);", element);
                    fingerprint.setXPath(xpath);
                } catch (Exception e) {
                    logger.debug("Error getting XPath", e);
                }
            }
            
            // Original locator for reference
            fingerprint.setOriginalLocator(locator);
            
        } catch (Exception e) {
            logger.warn("Error creating element fingerprint for comparison", e);
        }
        
        return fingerprint;
    }
    
    /**
     * Escapes special characters in CSS selectors.
     * 
     * @param selector The selector to escape
     * @return The escaped selector
     */
    private String escapeSelector(String selector) {
        if (selector == null) {
            return "";
        }
        
        // Escape special characters in CSS selectors
        return selector.replaceAll("([ #.:~+><!])", "\\\\$1");
    }
    
    /**
     * Escapes special characters in XPath values.
     * 
     * @param value The XPath value to escape
     * @return The escaped XPath value
     */
    private String escapeXPathValue(String value) {
        if (value == null) {
            return "";
        }
        
        // Use single quotes if the string doesn't contain any
        if (!value.contains("'")) {
            return "'" + value + "'";
        }
        
        // Use double quotes if the string doesn't contain any
        if (!value.contains("\"")) {
            return "\"" + value + "\"";
        }
        
        // If both types of quotes are present, use concat function
        StringBuilder result = new StringBuilder("concat(");
        boolean inQuote = false;
        StringBuilder currentPart = new StringBuilder("'");
        
        for (char c : value.toCharArray()) {
            if (c == '\'') {
                if (inQuote) {
                    currentPart.append("'");
                    result.append(currentPart.toString());
                    result.append(",\"'\",");
                    currentPart = new StringBuilder("'");
                    inQuote = true;
                } else {
                    if (currentPart.length() > 1) {
                        currentPart.append("'");
                        result.append(currentPart.toString());
                        result.append(",\"'\",");
                        currentPart = new StringBuilder("'");
                    } else {
                        result.append("\"'\",");
                    }
                }
            } else {
                currentPart.append(c);
                inQuote = true;
            }
        }
        
        if (currentPart.length() > 1) {
            currentPart.append("'");
            result.append(currentPart.toString());
        }
        
        // Remove trailing comma if it exists
        if (result.charAt(result.length() - 1) == ',') {
            result.deleteCharAt(result.length() - 1);
        }
        
        result.append(")");
        return result.toString();
    }
}



LoopActionConfig.java
-------------------------------

package com.cstestforge.model.recorder;

import com.cstestforge.framework.core.utils.CSLogger;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeName;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Configuration model for loop actions in the recorder.
 * Supports different types of loops: for, for-each, while, and do-while.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonTypeName("loop")
public class LoopActionConfig extends ActionConfig {
    private static final CSLogger logger = CSLogger.getLogger(LoopActionConfig.class);
    
    /**
     * Enum representing different types of loops.
     */
    public enum LoopType {
        @JsonProperty("for")
        FOR,
        
        @JsonProperty("foreach")
        FOREACH,
        
        @JsonProperty("while")
        WHILE,
        
        @JsonProperty("dowhile")
        DOWHILE
    }
    
    @JsonProperty("loopType")
    private LoopType loopType;
    
    @JsonProperty("initExpression")
    private String initExpression;
    
    @JsonProperty("conditionExpression")
    private String conditionExpression;
    
    @JsonProperty("incrementExpression")
    private String incrementExpression;
    
    @JsonProperty("iterationVariable")
    private String iterationVariable;
    
    @JsonProperty("iterationCollection")
    private String iterationCollection;
    
    @JsonProperty("iterationCollectionType")
    private String iterationCollectionType;
    
    @JsonProperty("maxIterations")
    private int maxIterations = 1000; // Default max iterations to prevent infinite loops
    
    @JsonProperty("breakOnError")
    private boolean breakOnError = true;
    
    @JsonProperty("actions")
    private List<ActionConfig> actions = new ArrayList<>();
    
    /**
     * Default constructor.
     */
    public LoopActionConfig() {
        setType("loop");
    }
    
    /**
     * Constructor for FOR loop.
     * 
     * @param initExpression Initialization expression (e.g., "int i = 0")
     * @param conditionExpression Condition expression (e.g., "i < 10")
     * @param incrementExpression Increment expression (e.g., "i++")
     */
    public LoopActionConfig(String initExpression, String conditionExpression, String incrementExpression) {
        setType("loop");
        this.loopType = LoopType.FOR;
        this.initExpression = initExpression;
        this.conditionExpression = conditionExpression;
        this.incrementExpression = incrementExpression;
    }
    
    /**
     * Constructor for FOREACH loop.
     * 
     * @param iterationVariable Variable name for each item (e.g., "item")
     * @param iterationCollection Collection to iterate over (e.g., "items")
     * @param iterationCollectionType Type of items in collection (e.g., "String")
     */
    public LoopActionConfig(String iterationVariable, String iterationCollection, String iterationCollectionType) {
        setType("loop");
        this.loopType = LoopType.FOREACH;
        this.iterationVariable = iterationVariable;
        this.iterationCollection = iterationCollection;
        this.iterationCollectionType = iterationCollectionType;
    }
    
    /**
     * Constructor for WHILE or DOWHILE loop.
     * 
     * @param loopType Loop type (WHILE or DOWHILE)
     * @param conditionExpression Condition expression (e.g., "x > 0")
     */
    public LoopActionConfig(LoopType loopType, String conditionExpression) {
        setType("loop");
        if (loopType != LoopType.WHILE && loopType != LoopType.DOWHILE) {
            throw new IllegalArgumentException("This constructor only supports WHILE or DOWHILE loop types");
        }
        this.loopType = loopType;
        this.conditionExpression = conditionExpression;
    }
    
    /**
     * Validates the loop configuration based on its type.
     * 
     * @return true if the configuration is valid, false otherwise
     */
    public boolean validate() {
        if (loopType == null) {
            logger.error("Loop type is required");
            return false;
        }
        
        switch (loopType) {
            case FOR:
                if (conditionExpression == null || conditionExpression.isEmpty()) {
                    logger.error("Condition expression is required for FOR loop");
                    return false;
                }
                break;
                
            case FOREACH:
                if (iterationVariable == null || iterationVariable.isEmpty()) {
                    logger.error("Iteration variable is required for FOREACH loop");
                    return false;
                }
                if (iterationCollection == null || iterationCollection.isEmpty()) {
                    logger.error("Iteration collection is required for FOREACH loop");
                    return false;
                }
                break;
                
            case WHILE:
            case DOWHILE:
                if (conditionExpression == null || conditionExpression.isEmpty()) {
                    logger.error("Condition expression is required for WHILE/DOWHILE loop");
                    return false;
                }
                break;
                
            default:
                logger.error("Unsupported loop type: " + loopType);
                return false;
        }
        
        if (maxIterations <= 0) {
            logger.error("Max iterations must be greater than 0");
            return false;
        }
        
        return true;
    }
    
    /**
     * Generates Java code for this loop configuration.
     * 
     * @return Java code string representation of the loop
     */
    public String generateJavaCode() {
        StringBuilder code = new StringBuilder();
        
        switch (loopType) {
            case FOR:
                code.append("for (").append(initExpression).append("; ")
                    .append(conditionExpression).append("; ")
                    .append(incrementExpression).append(") {\n");
                break;
                
            case FOREACH:
                code.append("for (")
                    .append(iterationCollectionType != null && !iterationCollectionType.isEmpty() ? 
                           iterationCollectionType : "Object")
                    .append(" ")
                    .append(iterationVariable)
                    .append(" : ")
                    .append(iterationCollection)
                    .append(") {\n");
                break;
                
            case WHILE:
                code.append("while (").append(conditionExpression).append(") {\n");
                break;
                
            case DOWHILE:
                code.append("do {\n");
                break;
                
            default:
                return "// Unsupported loop type: " + loopType;
        }
        
        // Add iteration counter for infinite loop protection
        code.append("    int iterationCounter = 0;\n");
        code.append("    if (iterationCounter++ > ").append(maxIterations).append(") {\n");
        code.append("        logger.warn(\"Maximum iterations reached. Breaking loop.\");\n");
        code.append("        break;\n");
        code.append("    }\n\n");
        
        // Add error handling if configured
        if (breakOnError) {
            code.append("    try {\n");
        }
        
        // Add nested actions
        for (ActionConfig action : actions) {
            // Indent the action code
            String actionCode = action.toString().replace("\n", "\n    ");
            code.append("    ").append(actionCode).append("\n");
        }
        
        // Close error handling if configured
        if (breakOnError) {
            code.append("    } catch (Exception e) {\n");
            code.append("        logger.error(\"Error in loop iteration: \" + e.getMessage());\n");
            code.append("        break;\n");
            code.append("    }\n");
        }
        
        // Close the loop
        code.append("}");
        
        // Add the do-while condition for do-while loops
        if (loopType == LoopType.DOWHILE) {
            code.append(" while (").append(conditionExpression).append(");");
        }
        
        return code.toString();
    }
    
    /**
     * Generates TypeScript code for this loop configuration.
     * 
     * @return TypeScript code string representation of the loop
     */
    public String generateTypeScriptCode() {
        StringBuilder code = new StringBuilder();
        
        switch (loopType) {
            case FOR:
                code.append("for (").append(initExpression).append("; ")
                    .append(conditionExpression).append("; ")
                    .append(incrementExpression).append(") {\n");
                break;
                
            case FOREACH:
                // TypeScript forEach uses a different syntax than Java
                code.append("for (const ")
                    .append(iterationVariable)
                    .append(" of ")
                    .append(iterationCollection)
                    .append(") {\n");
                break;
                
            case WHILE:
                code.append("while (").append(conditionExpression).append(") {\n");
                break;
                
            case DOWHILE:
                code.append("do {\n");
                break;
                
            default:
                return "// Unsupported loop type: " + loopType;
        }
        
        // Add iteration counter for infinite loop protection
        code.append("    let iterationCounter = 0;\n");
        code.append("    if (iterationCounter++ > ").append(maxIterations).append(") {\n");
        code.append("        console.warn(\"Maximum iterations reached. Breaking loop.\");\n");
        code.append("        break;\n");
        code.append("    }\n\n");
        
        // Add error handling if configured
        if (breakOnError) {
            code.append("    try {\n");
        }
        
        // Add nested actions
        for (ActionConfig action : actions) {
            // Indent the action code
            String actionCode = action.toString().replace("\n", "\n    ");
            code.append("    ").append(actionCode).append("\n");
        }
        
        // Close error handling if configured
        if (breakOnError) {
            code.append("    } catch (e) {\n");
            code.append("        console.error(`Error in loop iteration: ${e.message}`);\n");
            code.append("        break;\n");
            code.append("    }\n");
        }
        
        // Close the loop
        code.append("}");
        
        // Add the do-while condition for do-while loops
        if (loopType == LoopType.DOWHILE) {
            code.append(" while (").append(conditionExpression).append(");");
        }
        
        return code.toString();
    }
    
    /**
     * Adds an action to the loop.
     * 
     * @param action The action to add
     */
    public void addAction(ActionConfig action) {
        if (action != null) {
            actions.add(action);
        }
    }
    
    /**
     * Removes an action from the loop.
     * 
     * @param action The action to remove
     * @return true if the action was removed, false otherwise
     */
    public boolean removeAction(ActionConfig action) {
        return actions.remove(action);
    }
    
    /**
     * Gets the index of an action in the loop.
     * 
     * @param action The action to find
     * @return The index of the action, or -1 if not found
     */
    public int indexOf(ActionConfig action) {
        return actions.indexOf(action);
    }
    
    /**
     * Moves an action to a new position in the loop.
     * 
     * @param action The action to move
     * @param newIndex The new index for the action
     * @return true if the action was moved, false otherwise
     */
    public boolean moveAction(ActionConfig action, int newIndex) {
        int currentIndex = actions.indexOf(action);
        if (currentIndex == -1 || newIndex < 0 || newIndex >= actions.size()) {
            return false;
        }
        
        actions.remove(currentIndex);
        actions.add(newIndex, action);
        return true;
    }
    
    /**
     * Serializes this loop configuration to a string representation.
     * 
     * @return String representation of the loop
     */
    @Override
    public String toString() {
        switch (loopType) {
            case FOR:
                return String.format("ForLoop [init=%s, condition=%s, increment=%s, actions=%d]",
                        initExpression, conditionExpression, incrementExpression, actions.size());
                
            case FOREACH:
                return String.format("ForEachLoop [var=%s, collection=%s, type=%s, actions=%d]",
                        iterationVariable, iterationCollection, iterationCollectionType, actions.size());
                
            case WHILE:
                return String.format("WhileLoop [condition=%s, actions=%d]",
                        conditionExpression, actions.size());
                
            case DOWHILE:
                return String.format("DoWhileLoop [condition=%s, actions=%d]",
                        conditionExpression, actions.size());
                
            default:
                return "UnknownLoop [type=" + loopType + "]";
        }
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        
        LoopActionConfig that = (LoopActionConfig) o;
        
        if (maxIterations != that.maxIterations) return false;
        if (breakOnError != that.breakOnError) return false;
        if (loopType != that.loopType) return false;
        if (!Objects.equals(initExpression, that.initExpression)) return false;
        if (!Objects.equals(conditionExpression, that.conditionExpression)) return false;
        if (!Objects.equals(incrementExpression, that.incrementExpression)) return false;
        if (!Objects.equals(iterationVariable, that.iterationVariable)) return false;
        if (!Objects.equals(iterationCollection, that.iterationCollection)) return false;
        if (!Objects.equals(iterationCollectionType, that.iterationCollectionType)) return false;
        return Objects.equals(actions, that.actions);
    }
    
    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (loopType != null ? loopType.hashCode() : 0);
        result = 31 * result + (initExpression != null ? initExpression.hashCode() : 0);
        result = 31 * result + (conditionExpression != null ? conditionExpression.hashCode() : 0);
        result = 31 * result + (incrementExpression != null ? incrementExpression.hashCode() : 0);
        result = 31 * result + (iterationVariable != null ? iterationVariable.hashCode() : 0);
        result = 31 * result + (iterationCollection != null ? iterationCollection.hashCode() : 0);
        result = 31 * result + (iterationCollectionType != null ? iterationCollectionType.hashCode() : 0);
        result = 31 * result + maxIterations;
        result = 31 * result + (breakOnError ? 1 : 0);
        result = 31 * result + (actions != null ? actions.hashCode() : 0);
        return result;
    }
    
    // Getters and Setters
    
    public LoopType getLoopType() {
        return loopType;
    }
    
    public void setLoopType(LoopType loopType) {
        this.loopType = loopType;
    }
    
    public String getInitExpression() {
        return initExpression;
    }
    
    public void setInitExpression(String initExpression) {
        this.initExpression = initExpression;
    }
    
    public String getConditionExpression() {
        return conditionExpression;
    }
    
    public void setConditionExpression(String conditionExpression) {
        this.conditionExpression = conditionExpression;
    }
    
    public String getIncrementExpression() {
        return incrementExpression;
    }
    
    public void setIncrementExpression(String incrementExpression) {
        this.incrementExpression = incrementExpression;
    }
    
    public String getIterationVariable() {
        return iterationVariable;
    }
    
    public void setIterationVariable(String iterationVariable) {
        this.iterationVariable = iterationVariable;
    }
    
    public String getIterationCollection() {
        return iterationCollection;
    }
    
    public void setIterationCollection(String iterationCollection) {
        this.iterationCollection = iterationCollection;
    }
    
    public String getIterationCollectionType() {
        return iterationCollectionType;
    }
    
    public void setIterationCollectionType(String iterationCollectionType) {
        this.iterationCollectionType = iterationCollectionType;
    }
    
    public int getMaxIterations() {
        return maxIterations;
    }
    
    public void setMaxIterations(int maxIterations) {
        this.maxIterations = maxIterations;
    }
    
    public boolean isBreakOnError() {
        return breakOnError;
    }
    
    public void setBreakOnError(boolean breakOnError) {
        this.breakOnError = breakOnError;
    }
    
    public List<ActionConfig> getActions() {
        return actions;
    }
    
    public void setActions(List<ActionConfig> actions) {
        this.actions = actions != null ? actions : new ArrayList<>();
    }
}


DataProviderActionConfig.java
---------------------------------

package com.cstestforge.model.recorder;

import com.cstestforge.framework.core.utils.CSLogger;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeName;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Configuration model for data provider actions in the recorder.
 * Supports different types of data sources like CSV, Excel, JSON, and database.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonTypeName("dataProvider")
public class DataProviderActionConfig extends ActionConfig {
    private static final CSLogger logger = CSLogger.getLogger(DataProviderActionConfig.class);
    
    /**
     * Enum representing different types of data sources.
     */
    public enum DataSourceType {
        @JsonProperty("csv")
        CSV,
        
        @JsonProperty("excel")
        EXCEL,
        
        @JsonProperty("json")
        JSON,
        
        @JsonProperty("database")
        DATABASE,
        
        @JsonProperty("inline")
        INLINE
    }
    
    @JsonProperty("dataSourceType")
    private DataSourceType dataSourceType;
    
    @JsonProperty("filePath")
    private String filePath;
    
    @JsonProperty("sheetName")
    private String sheetName;
    
    @JsonProperty("connectionString")
    private String connectionString;
    
    @JsonProperty("query")
    private String query;
    
    @JsonProperty("columns")
    private List<String> columns = new ArrayList<>();
    
    @JsonProperty("inlineData")
    private List<Map<String, String>> inlineData = new ArrayList<>();
    
    @JsonProperty("filterExpression")
    private String filterExpression;
    
    @JsonProperty("dataVariableName")
    private String dataVariableName;
    
    @JsonProperty("skipHeader")
    private boolean skipHeader = true;
    
    @JsonProperty("delimiter")
    private String delimiter = ",";
    
    @JsonProperty("nullValue")
    private String nullValue = "";
    
    @JsonProperty("actions")
    private List<ActionConfig> actions = new ArrayList<>();
    
    /**
     * Default constructor.
     */
    public DataProviderActionConfig() {
        setType("dataProvider");
    }
    
    /**
     * Constructor for file-based data sources (CSV, Excel, JSON).
     * 
     * @param dataSourceType Type of data source
     * @param filePath Path to the data file
     * @param dataVariableName Name of the variable to store the data
     */
    public DataProviderActionConfig(DataSourceType dataSourceType, String filePath, String dataVariableName) {
        setType("dataProvider");
        this.dataSourceType = dataSourceType;
        this.filePath = filePath;
        this.dataVariableName = dataVariableName;
        
        if (dataSourceType == DataSourceType.EXCEL && (sheetName == null || sheetName.isEmpty())) {
            this.sheetName = "Sheet1"; // Default sheet name for Excel
        }
    }
    
    /**
     * Constructor for database data source.
     * 
     * @param connectionString Database connection string
     * @param query SQL query
     * @param dataVariableName Name of the variable to store the data
     */
    public DataProviderActionConfig(String connectionString, String query, String dataVariableName) {
        setType("dataProvider");
        this.dataSourceType = DataSourceType.DATABASE;
        this.connectionString = connectionString;
        this.query = query;
        this.dataVariableName = dataVariableName;
    }
    
    /**
     * Constructor for inline data source.
     * 
     * @param inlineData List of data rows (each row is a map of column name to value)
     * @param dataVariableName Name of the variable to store the data
     */
    public DataProviderActionConfig(List<Map<String, String>> inlineData, String dataVariableName) {
        setType("dataProvider");
        this.dataSourceType = DataSourceType.INLINE;
        this.inlineData = inlineData;
        this.dataVariableName = dataVariableName;
        
        // Extract columns from the first row
        if (inlineData != null && !inlineData.isEmpty()) {
            this.columns = new ArrayList<>(inlineData.get(0).keySet());
        }
    }
    
    /**
     * Validates the data provider configuration based on its type.
     * 
     * @return true if the configuration is valid, false otherwise
     */
    public boolean validate() {
        if (dataSourceType == null) {
            logger.error("Data source type is required");
            return false;
        }
        
        if (dataVariableName == null || dataVariableName.isEmpty()) {
            logger.error("Data variable name is required");
            return false;
        }
        
        switch (dataSourceType) {
            case CSV:
            case EXCEL:
            case JSON:
                if (filePath == null || filePath.isEmpty()) {
                    logger.error("File path is required for " + dataSourceType + " data source");
                    return false;
                }
                
                if (dataSourceType == DataSourceType.EXCEL && (sheetName == null || sheetName.isEmpty())) {
                    logger.error("Sheet name is required for Excel data source");
                    return false;
                }
                break;
                
            case DATABASE:
                if (connectionString == null || connectionString.isEmpty()) {
                    logger.error("Connection string is required for database data source");
                    return false;
                }
                
                if (query == null || query.isEmpty()) {
                    logger.error("Query is required for database data source");
                    return false;
                }
                break;
                
            case INLINE:
                if (inlineData == null || inlineData.isEmpty()) {
                    logger.error("Inline data is required for inline data source");
                    return false;
                }
                break;
                
            default:
                logger.error("Unsupported data source type: " + dataSourceType);
                return false;
        }
        
        return true;
    }
    
    /**
     * Generates Java code for this data provider configuration.
     * 
     * @return Java code string representation of the data provider
     */
    public String generateJavaCode() {
        StringBuilder code = new StringBuilder();
        
        // Data source initialization based on type
        switch (dataSourceType) {
            case CSV:
                code.append("// Initialize CSV data source\n");
                code.append("CSDataSource ").append(dataVariableName).append("Source = new CsvDataSource(\"")
                    .append(filePath).append("\");\n");
                code.append("((CsvDataSource) ").append(dataVariableName).append("Source)")
                    .append(".setDelimiter(\"").append(delimiter).append("\")")
                    .append(".setSkipHeader(").append(skipHeader).append(")")
                    .append(".setNullValue(\"").append(nullValue).append("\");\n");
                break;
                
            case EXCEL:
                code.append("// Initialize Excel data source\n");
                code.append("CSDataSource ").append(dataVariableName).append("Source = new ExcelDataSource(\"")
                    .append(filePath).append("\", \"").append(sheetName).append("\");\n");
                code.append("((ExcelDataSource) ").append(dataVariableName).append("Source)")
                    .append(".setSkipHeader(").append(skipHeader).append(")")
                    .append(".setNullValue(\"").append(nullValue).append("\");\n");
                break;
                
            case JSON:
                code.append("// Initialize JSON data source\n");
                code.append("CSDataSource ").append(dataVariableName).append("Source = new JsonDataSource(\"")
                    .append(filePath).append("\");\n");
                code.append("((JsonDataSource) ").append(dataVariableName).append("Source)")
                    .append(".setNullValue(\"").append(nullValue).append("\");\n");
                break;
                
            case DATABASE:
                code.append("// Initialize Database data source\n");
                code.append("CSDataSource ").append(dataVariableName).append("Source = new DatabaseDataSource(\"")
                    .append(connectionString).append("\", \"").append(query).append("\");\n");
                break;
                
            case INLINE:
                code.append("// Initialize Inline data source\n");
                code.append("List<Map<String, Object>> ").append(dataVariableName).append("Data = new ArrayList<>();\n");
                
                // Add each row of data
                for (Map<String, String> row : inlineData) {
                    code.append("{\n");
                    code.append("    Map<String, Object> row = new HashMap<>();\n");
                    for (Map.Entry<String, String> entry : row.entrySet()) {
                        code.append("    row.put(\"").append(entry.getKey()).append("\", \"")
                            .append(entry.getValue()).append("\");\n");
                    }
                    code.append("    ").append(dataVariableName).append("Data.add(row);\n");
                    code.append("}\n");
                }
                
                code.append("CSDataSource ").append(dataVariableName).append("Source = new InlineDataSource(")
                    .append(dataVariableName).append("Data);\n");
                break;
                
            default:
                return "// Unsupported data source type: " + dataSourceType;
        }
        
        // Apply filter if provided
        if (filterExpression != null && !filterExpression.isEmpty()) {
            code.append(dataVariableName).append("Source.setFilter(\"").append(filterExpression).append("\");\n");
        }
        
        // Load the data
        code.append("List<Map<String, Object>> ").append(dataVariableName)
            .append(" = ").append(dataVariableName).append("Source.getData();\n");
        
        // Loop through the data
        code.append("\n// Process each row in the data\n");
        code.append("for (Map<String, Object> row : ").append(dataVariableName).append(") {\n");
        
        // Add row index for reference
        code.append("    int rowIndex = ").append(dataVariableName).append(".indexOf(row);\n");
        
        // Column accessors for convenience
        if (!columns.isEmpty()) {
            code.append("\n    // Column accessor variables\n");
            for (String column : columns) {
                code.append("    Object ").append(sanitizeVariableName(column))
                    .append(" = row.get(\"").append(column).append("\");\n");
            }
            code.append("\n");
        }
        
        // Add error handling
        code.append("    try {\n");
        
        // Add nested actions
        for (ActionConfig action : actions) {
            // Indent the action code
            String actionCode = action.toString().replace("\n", "\n        ");
            code.append("        ").append(actionCode).append("\n");
        }
        
        // Close error handling
        code.append("    } catch (Exception e) {\n");
        code.append("        logger.error(\"Error processing row \" + rowIndex + \": \" + e.getMessage());\n");
        code.append("    }\n");
        
        // Close the loop
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Generates TypeScript code for this data provider configuration.
     * 
     * @return TypeScript code string representation of the data provider
     */
    public String generateTypeScriptCode() {
        StringBuilder code = new StringBuilder();
        
        // Data source initialization based on type
        switch (dataSourceType) {
            case CSV:
                code.append("// Initialize CSV data source\n");
                code.append("const ").append(dataVariableName).append("Source = new CsvDataSource(\"")
                    .append(filePath).append("\");\n");
                code.append(dataVariableName).append("Source")
                    .append(".setDelimiter(\"").append(delimiter).append("\")")
                    .append(".setSkipHeader(").append(skipHeader).append(")")
                    .append(".setNullValue(\"").append(nullValue).append("\");\n");
                break;
                
            case EXCEL:
                code.append("// Initialize Excel data source\n");
                code.append("const ").append(dataVariableName).append("Source = new ExcelDataSource(\"")
                    .append(filePath).append("\", \"").append(sheetName).append("\");\n");
                code.append(dataVariableName).append("Source")
                    .append(".setSkipHeader(").append(skipHeader).append(")")
                    .append(".setNullValue(\"").append(nullValue).append("\");\n");
                break;
                
            case JSON:
                code.append("// Initialize JSON data source\n");
                code.append("const ").append(dataVariableName).append("Source = new JsonDataSource(\"")
                    .append(filePath).append("\");\n");
                code.append(dataVariableName).append("Source")
                    .append(".setNullValue(\"").append(nullValue).append("\");\n");
                break;
                
            case DATABASE:
                code.append("// Initialize Database data source\n");
                code.append("const ").append(dataVariableName).append("Source = new DatabaseDataSource(\"")
                    .append(connectionString).append("\", \"").append(query).append("\");\n");
                break;
                
            case INLINE:
                code.append("// Initialize Inline data source\n");
                code.append("const ").append(dataVariableName).append("Data: Array<Record<string, any>> = [\n");
                
                // Add each row of data
                for (int i = 0; i < inlineData.size(); i++) {
                    Map<String, String> row = inlineData.get(i);
                    code.append("    {\n");
                    
                    int entryCount = 0;
                    for (Map.Entry<String, String> entry : row.entrySet()) {
                        code.append("        \"").append(entry.getKey()).append("\": \"")
                            .append(entry.getValue()).append("\"");
                            
                        if (++entryCount < row.size()) {
                            code.append(",");
                        }
                        code.append("\n");
                    }
                    
                    code.append("    }");
                    if (i < inlineData.size() - 1) {
                        code.append(",");
                    }
                    code.append("\n");
                }
                
                code.append("];\n\n");
                code.append("const ").append(dataVariableName).append("Source = new InlineDataSource(")
                    .append(dataVariableName).append("Data);\n");
                break;
                
            default:
                return "// Unsupported data source type: " + dataSourceType;
        }
        
        // Apply filter if provided
        if (filterExpression != null && !filterExpression.isEmpty()) {
            code.append(dataVariableName).append("Source.setFilter(\"").append(filterExpression).append("\");\n");
        }
        
        // Load the data
        code.append("const ").append(dataVariableName)
            .append(" = ").append(dataVariableName).append("Source.getData();\n");
        
        // Loop through the data
        code.append("\n// Process each row in the data\n");
        code.append("for (let rowIndex = 0; rowIndex < ").append(dataVariableName).append(".length; rowIndex++) {\n");
        code.append("    const row = ").append(dataVariableName).append("[rowIndex];\n");
        
        // Column accessors for convenience
        if (!columns.isEmpty()) {
            code.append("\n    // Column accessor variables\n");
            for (String column : columns) {
                code.append("    const ").append(sanitizeVariableName(column))
                    .append(" = row[\"").append(column).append("\"];\n");
            }
            code.append("\n");
        }
        
        // Add error handling
        code.append("    try {\n");
        
        // Add nested actions
        for (ActionConfig action : actions) {
            // Indent the action code
            String actionCode = action.toString().replace("\n", "\n        ");
            code.append("        ").append(actionCode).append("\n");
        }
        
        // Close error handling
        code.append("    } catch (e) {\n");
        code.append("        console.error(`Error processing row ${rowIndex}: ${e.message}`);\n");
        code.append("    }\n");
        
        // Close the loop
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Sanitizes column names to be valid variable names.
     * 
     * @param name Column name
     * @return Sanitized variable name
     */
    private String sanitizeVariableName(String name) {
        if (name == null || name.isEmpty()) {
            return "column";
        }
        
        // Replace invalid characters with underscore
        String sanitized = name.replaceAll("[^a-zA-Z0-9_]", "_");
        
        // Ensure it starts with a letter or underscore
        if (!sanitized.matches("^[a-zA-Z_].*")) {
            sanitized = "_" + sanitized;
        }
        
        return sanitized;
    }
    
    /**
     * Adds an action to the data provider.
     * 
     * @param action The action to add
     */
    public void addAction(ActionConfig action) {
        if (action != null) {
            actions.add(action);
        }
    }
    
    /**
     * Removes an action from the data provider.
     * 
     * @param action The action to remove
     * @return true if the action was removed, false otherwise
     */
    public boolean removeAction(ActionConfig action) {
        return actions.remove(action);
    }
    
    /**
     * Gets the index of an action in the data provider.
     * 
     * @param action The action to find
     * @return The index of the action, or -1 if not found
     */
    public int indexOf(ActionConfig action) {
        return actions.indexOf(action);
    }
    
    /**
     * Moves an action to a new position in the data provider.
     * 
     * @param action The action to move
     * @param newIndex The new index for the action
     * @return true if the action was moved, false otherwise
     */
    public boolean moveAction(ActionConfig action, int newIndex) {
        int currentIndex = actions.indexOf(action);
        if (currentIndex == -1 || newIndex < 0 || newIndex >= actions.size()) {
            return false;
        }
        
        actions.remove(currentIndex);
        actions.add(newIndex, action);
        return true;
    }
    
    /**
     * Adds or updates a column in the data provider.
     * 
     * @param columnName The name of the column
     */
    public void addColumn(String columnName) {
        if (columnName != null && !columnName.isEmpty() && !columns.contains(columnName)) {
            columns.add(columnName);
        }
    }
    
    /**
     * Removes a column from the data provider.
     * 
     * @param columnName The name of the column
     * @return true if the column was removed, false otherwise
     */
    public boolean removeColumn(String columnName) {
        return columns.remove(columnName);
    }
    
    /**
     * Adds a row of data to the inline data source.
     * 
     * @param row The row to add
     */
    public void addRow(Map<String, String> row) {
        if (row != null && !row.isEmpty()) {
            inlineData.add(row);
            
            // Update columns if new columns found
            for (String column : row.keySet()) {
                addColumn(column);
            }
        }
    }
    
    /**
     * Removes a row from the inline data source.
     * 
     * @param index The index of the row to remove
     * @return true if the row was removed, false otherwise
     */
    public boolean removeRow(int index) {
        if (index >= 0 && index < inlineData.size()) {
            inlineData.remove(index);
            return true;
        }
        return false;
    }
    
    /**
     * Serializes this data provider configuration to a string representation.
     * 
     * @return String representation of the data provider
     */
    @Override
    public String toString() {
        switch (dataSourceType) {
            case CSV:
                return String.format("CSVDataProvider [file=%s, variable=%s, columns=%d, actions=%d]",
                        filePath, dataVariableName, columns.size(), actions.size());
                
            case EXCEL:
                return String.format("ExcelDataProvider [file=%s, sheet=%s, variable=%s, columns=%d, actions=%d]",
                        filePath, sheetName, dataVariableName, columns.size(), actions.size());
                
            case JSON:
                return String.format("JSONDataProvider [file=%s, variable=%s, columns=%d, actions=%d]",
                        filePath, dataVariableName, columns.size(), actions.size());
                
            case DATABASE:
                return String.format("DatabaseDataProvider [connection=%s, query=%s, variable=%s, actions=%d]",
                        connectionString, query, dataVariableName, actions.size());
                
            case INLINE:
                return String.format("InlineDataProvider [rows=%d, columns=%d, variable=%s, actions=%d]",
                        inlineData.size(), columns.size(), dataVariableName, actions.size());
                
            default:
                return "UnknownDataProvider [type=" + dataSourceType + "]";
        }
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        
        DataProviderActionConfig that = (DataProviderActionConfig) o;
        
        if (skipHeader != that.skipHeader) return false;
        if (dataSourceType != that.dataSourceType) return false;
        if (!Objects.equals(filePath, that.filePath)) return false;
        if (!Objects.equals(sheetName, that.sheetName)) return false;
        if (!Objects.equals(connectionString, that.connectionString)) return false;
        if (!Objects.equals(query, that.query)) return false;
        if (!Objects.equals(columns, that.columns)) return false;
        if (!Objects.equals(inlineData, that.inlineData)) return false;
        if (!Objects.equals(filterExpression, that.filterExpression)) return false;
        if (!Objects.equals(dataVariableName, that.dataVariableName)) return false;
        if (!Objects.equals(delimiter, that.delimiter)) return false;
        if (!Objects.equals(nullValue, that.nullValue)) return false;
        return Objects.equals(actions, that.actions);
    }
    
    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (dataSourceType != null ? dataSourceType.hashCode() : 0);
        result = 31 * result + (filePath != null ? filePath.hashCode() : 0);
        result = 31 * result + (sheetName != null ? sheetName.hashCode() : 0);
        result = 31 * result + (connectionString != null ? connectionString.hashCode() : 0);
        result = 31 * result + (query != null ? query.hashCode() : 0);
        result = 31 * result + (columns != null ? columns.hashCode() : 0);
        result = 31 * result + (inlineData != null ? inlineData.hashCode() : 0);
        result = 31 * result + (filterExpression != null ? filterExpression.hashCode() : 0);
        result = 31 * result + (dataVariableName != null ? dataVariableName.hashCode() : 0);
        result = 31 * result + (skipHeader ? 1 : 0);
        result = 31 * result + (delimiter != null ? delimiter.hashCode() : 0);
        result = 31 * result + (nullValue != null ? nullValue.hashCode() : 0);
        result = 31 * result + (actions != null ? actions.hashCode() : 0);
        return result;
    }
    
    // Getters and Setters
    
    public DataSourceType getDataSourceType() {
        return dataSourceType;
    }
    
    public void setDataSourceType(DataSourceType dataSourceType) {
        this.dataSourceType = dataSourceType;
    }
    
    public String getFilePath() {
        return filePath;
    }
    
    public void setFilePath(String filePath) {
        this.filePath = filePath;
    }
    
    public String getSheetName() {
        return sheetName;
    }
    
    public void setSheetName(String sheetName) {
        this.sheetName = sheetName;
    }
    
    public String getConnectionString() {
        return connectionString;
    }
    
    public void setConnectionString(String connectionString) {
        this.connectionString = connectionString;
    }
    
    public String getQuery() {
        return query;
    }
    
    public void setQuery(String query) {
        this.query = query;
    }
    
    public List<String> getColumns() {
        return columns;
    }
    
    public void setColumns(List<String> columns) {
        this.columns = columns != null ? columns : new ArrayList<>();
    }
    
    public List<Map<String, String>> getInlineData() {
        return inlineData;
    }
    
    public void setInlineData(List<Map<String, String>> inlineData) {
        this.inlineData = inlineData != null ? inlineData : new ArrayList<>();
    }
    
    public String getFilterExpression() {
        return filterExpression;
    }
    
    public void setFilterExpression(String filterExpression) {
        this.filterExpression = filterExpression;
    }
    
    public String getDataVariableName() {
        return dataVariableName;
    }
    
    public void setDataVariableName(String dataVariableName) {
        this.dataVariableName = dataVariableName;
    }
    
    public boolean isSkipHeader() {
        return skipHeader;
    }
    
    public void setSkipHeader(boolean skipHeader) {
        this.skipHeader = skipHeader;
    }
    
    public String getDelimiter() {
        return delimiter;
    }
    
    public void setDelimiter(String delimiter) {
        this.delimiter = delimiter;
    }
    
    public String getNullValue() {
        return nullValue;
    }
    
    public void setNullValue(String nullValue) {
        this.nullValue = nullValue;
    }
    
    public List<ActionConfig> getActions() {
        return actions;
    }
    
    public void setActions(List<ActionConfig> actions) {
        this.actions = actions != null ? actions : new ArrayList<>();
    }
}



WaitActionConfig.java
--------------------------------

package com.cstestforge.model.recorder;

import com.cstestforge.framework.core.utils.CSLogger;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeName;

import java.util.Objects;

/**
 * Configuration model for wait actions in the recorder.
 * Supports different types of waits: fixed time, element visibility, element clickability,
 * element presence, element invisibility, text presence, and custom condition waits.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonTypeName("wait")
public class WaitActionConfig extends ActionConfig {
    private static final CSLogger logger = CSLogger.getLogger(WaitActionConfig.class);
    
    /**
     * Enum representing different types of waits.
     */
    public enum WaitType {
        @JsonProperty("fixed")
        FIXED,
        
        @JsonProperty("visibility")
        VISIBILITY,
        
        @JsonProperty("clickability")
        CLICKABILITY,
        
        @JsonProperty("presence")
        PRESENCE,
        
        @JsonProperty("invisibility")
        INVISIBILITY,
        
        @JsonProperty("text")
        TEXT,
        
        @JsonProperty("attribute")
        ATTRIBUTE,
        
        @JsonProperty("custom")
        CUSTOM
    }
    
    @JsonProperty("waitType")
    private WaitType waitType;
    
    @JsonProperty("timeout")
    private int timeout = 30;
    
    @JsonProperty("pollingInterval")
    private int pollingInterval = 500;
    
    @JsonProperty("locator")
    private String locator;
    
    @JsonProperty("locatorType")
    private String locatorType;
    
    @JsonProperty("text")
    private String text;
    
    @JsonProperty("attributeName")
    private String attributeName;
    
    @JsonProperty("attributeValue")
    private String attributeValue;
    
    @JsonProperty("customExpression")
    private String customExpression;
    
    @JsonProperty("failOnTimeout")
    private boolean failOnTimeout = true;
    
    @JsonProperty("screenshot")
    private boolean screenshot = false;
    
    @JsonProperty("successMessage")
    private String successMessage;
    
    @JsonProperty("errorMessage")
    private String errorMessage;
    
    /**
     * Default constructor.
     */
    public WaitActionConfig() {
        setType("wait");
    }
    
    /**
     * Constructor for fixed wait.
     * 
     * @param timeout Wait timeout in seconds
     */
    public WaitActionConfig(int timeout) {
        setType("wait");
        this.waitType = WaitType.FIXED;
        this.timeout = timeout;
    }
    
    /**
     * Constructor for element-based waits.
     * 
     * @param waitType Type of element wait
     * @param locator Element locator
     * @param locatorType Locator type (CSS, XPath, etc.)
     * @param timeout Wait timeout in seconds
     */
    public WaitActionConfig(WaitType waitType, String locator, String locatorType, int timeout) {
        setType("wait");
        this.waitType = waitType;
        this.locator = locator;
        this.locatorType = locatorType;
        this.timeout = timeout;
    }
    
    /**
     * Constructor for text wait.
     * 
     * @param locator Element locator
     * @param locatorType Locator type
     * @param text Text to wait for
     * @param timeout Wait timeout in seconds
     */
    public WaitActionConfig(String locator, String locatorType, String text, int timeout) {
        setType("wait");
        this.waitType = WaitType.TEXT;
        this.locator = locator;
        this.locatorType = locatorType;
        this.text = text;
        this.timeout = timeout;
    }
    
    /**
     * Constructor for attribute wait.
     * 
     * @param locator Element locator
     * @param locatorType Locator type
     * @param attributeName Attribute name
     * @param attributeValue Attribute value
     * @param timeout Wait timeout in seconds
     */
    public WaitActionConfig(String locator, String locatorType, String attributeName, String attributeValue, int timeout) {
        setType("wait");
        this.waitType = WaitType.ATTRIBUTE;
        this.locator = locator;
        this.locatorType = locatorType;
        this.attributeName = attributeName;
        this.attributeValue = attributeValue;
        this.timeout = timeout;
    }
    
    /**
     * Constructor for custom condition wait.
     * 
     * @param customExpression Custom JavaScript condition expression
     * @param timeout Wait timeout in seconds
     */
    public WaitActionConfig(String customExpression, int timeout) {
        setType("wait");
        this.waitType = WaitType.CUSTOM;
        this.customExpression = customExpression;
        this.timeout = timeout;
    }
    
    /**
     * Validates the wait configuration based on its type.
     * 
     * @return true if the configuration is valid, false otherwise
     */
    public boolean validate() {
        if (waitType == null) {
            logger.error("Wait type is required");
            return false;
        }
        
        if (timeout <= 0) {
            logger.error("Timeout must be greater than 0");
            return false;
        }
        
        switch (waitType) {
            case FIXED:
                // Fixed wait only requires timeout
                break;
                
            case VISIBILITY:
            case CLICKABILITY:
            case PRESENCE:
            case INVISIBILITY:
                if (locator == null || locator.isEmpty()) {
                    logger.error("Locator is required for " + waitType + " wait");
                    return false;
                }
                break;
                
            case TEXT:
                if (locator == null || locator.isEmpty()) {
                    logger.error("Locator is required for TEXT wait");
                    return false;
                }
                if (text == null || text.isEmpty()) {
                    logger.error("Text is required for TEXT wait");
                    return false;
                }
                break;
                
            case ATTRIBUTE:
                if (locator == null || locator.isEmpty()) {
                    logger.error("Locator is required for ATTRIBUTE wait");
                    return false;
                }
                if (attributeName == null || attributeName.isEmpty()) {
                    logger.error("Attribute name is required for ATTRIBUTE wait");
                    return false;
                }
                break;
                
            case CUSTOM:
                if (customExpression == null || customExpression.isEmpty()) {
                    logger.error("Custom expression is required for CUSTOM wait");
                    return false;
                }
                break;
                
            default:
                logger.error("Unsupported wait type: " + waitType);
                return false;
        }
        
        return true;
    }
    
    /**
     * Generates Java code for this wait configuration.
     * 
     * @return Java code string representation of the wait
     */
    public String generateJavaCode() {
        StringBuilder code = new StringBuilder();
        
        switch (waitType) {
            case FIXED:
                code.append("// Fixed time wait\n");
                code.append("try {\n");
                code.append("    Thread.sleep(").append(timeout * 1000).append(");\n");
                if (successMessage != null && !successMessage.isEmpty()) {
                    code.append("    logger.info(\"").append(successMessage).append("\");\n");
                }
                code.append("} catch (InterruptedException e) {\n");
                code.append("    Thread.currentThread().interrupt();\n");
                if (errorMessage != null && !errorMessage.isEmpty()) {
                    code.append("    logger.error(\"").append(errorMessage).append(": \" + e.getMessage());\n");
                } else {
                    code.append("    logger.error(\"Fixed wait interrupted: \" + e.getMessage());\n");
                }
                code.append("}");
                break;
                
            case VISIBILITY:
                code.append("// Wait for element visibility\n");
                code.append("try {\n");
                code.append("    CSVisibilityWait wait = new CSVisibilityWait(driver, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    boolean result = wait.waitForElement(\"").append(locator).append("\");\n");
                
                generateWaitResultProcessing(code);
                break;
                
            case CLICKABILITY:
                code.append("// Wait for element clickability\n");
                code.append("try {\n");
                code.append("    CSClickableWait wait = new CSClickableWait(driver, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    boolean result = wait.waitForElement(\"").append(locator).append("\");\n");
                
                generateWaitResultProcessing(code);
                break;
                
            case PRESENCE:
                code.append("// Wait for element presence\n");
                code.append("try {\n");
                code.append("    CSPresenceWait wait = new CSPresenceWait(driver, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    boolean result = wait.waitForElement(\"").append(locator).append("\");\n");
                
                generateWaitResultProcessing(code);
                break;
                
            case INVISIBILITY:
                code.append("// Wait for element invisibility\n");
                code.append("try {\n");
                code.append("    CSInvisibilityWait wait = new CSInvisibilityWait(driver, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    boolean result = wait.waitForElement(\"").append(locator).append("\");\n");
                
                generateWaitResultProcessing(code);
                break;
                
            case TEXT:
                code.append("// Wait for text presence\n");
                code.append("try {\n");
                code.append("    CSTextWait wait = new CSTextWait(driver, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    boolean result = wait.waitForText(\"").append(locator).append("\", \"")
                     .append(text).append("\");\n");
                
                generateWaitResultProcessing(code);
                break;
                
            case ATTRIBUTE:
                code.append("// Wait for attribute value\n");
                code.append("try {\n");
                code.append("    CSAttributeWait wait = new CSAttributeWait(driver, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    boolean result = wait.waitForAttribute(\"").append(locator).append("\", \"")
                     .append(attributeName).append("\", \"").append(attributeValue).append("\");\n");
                
                generateWaitResultProcessing(code);
                break;
                
            case CUSTOM:
                code.append("// Wait for custom JavaScript condition\n");
                code.append("try {\n");
                code.append("    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(")
                     .append(timeout).append("));\n");
                code.append("    wait.pollingEvery(Duration.ofMillis(").append(pollingInterval).append("));\n");
                code.append("    boolean result = wait.until(driver -> {\n");
                code.append("        try {\n");
                code.append("            Object evalResult = ((JavascriptExecutor) driver).executeScript(\"")
                     .append(escapeJavaScript(customExpression)).append("\");\n");
                code.append("            return Boolean.TRUE.equals(evalResult);\n");
                code.append("        } catch (Exception e) {\n");
                code.append("            return false;\n");
                code.append("        }\n");
                code.append("    });\n");
                
                generateWaitResultProcessing(code);
                break;
                
            default:
                return "// Unsupported wait type: " + waitType;
        }
        
        return code.toString();
    }
    
    /**
     * Helper method to generate the result processing code for waits.
     * 
     * @param code StringBuilder to append the code to
     */
    private void generateWaitResultProcessing(StringBuilder code) {
        if (screenshot) {
            code.append("    if (result) {\n");
            code.append("        CSScreenshotManager.takeScreenshot(driver, \"Wait_Success_\");\n");
            code.append("    } else {\n");
            code.append("        CSScreenshotManager.takeScreenshot(driver, \"Wait_Failure_\");\n");
            code.append("    }\n");
        }
        
        if (successMessage != null && !successMessage.isEmpty()) {
            code.append("    if (result) {\n");
            code.append("        logger.info(\"").append(successMessage).append("\");\n");
            code.append("    }\n");
        }
        
        if (failOnTimeout) {
            code.append("    if (!result) {\n");
            if (errorMessage != null && !errorMessage.isEmpty()) {
                code.append("        throw new RuntimeException(\"").append(errorMessage).append("\");\n");
            } else {
                code.append("        throw new RuntimeException(\"Wait condition not satisfied within timeout of ")
                     .append(timeout).append(" seconds\");\n");
            }
            code.append("    }\n");
        } else if (errorMessage != null && !errorMessage.isEmpty()) {
            code.append("    if (!result) {\n");
            code.append("        logger.warn(\"").append(errorMessage).append("\");\n");
            code.append("    }\n");
        }
        
        code.append("} catch (Exception e) {\n");
        code.append("    logger.error(\"Error during wait: \" + e.getMessage());\n");
        if (failOnTimeout) {
            code.append("    throw e;\n");
        }
        code.append("}");
    }
    
    /**
     * Generates TypeScript code for this wait configuration.
     * 
     * @return TypeScript code string representation of the wait
     */
    public String generateTypeScriptCode() {
        StringBuilder code = new StringBuilder();
        
        switch (waitType) {
            case FIXED:
                code.append("// Fixed time wait\n");
                code.append("await new Promise(resolve => {\n");
                code.append("    setTimeout(resolve, ").append(timeout * 1000).append(");\n");
                if (successMessage != null && !successMessage.isEmpty()) {
                    code.append("    console.log(\"").append(successMessage).append("\");\n");
                }
                code.append("});");
                break;
                
            case VISIBILITY:
                code.append("// Wait for element visibility\n");
                code.append("try {\n");
                code.append("    const wait = new CSVisibilityWait(page, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    const result = await wait.waitForElement(\"").append(locator).append("\");\n");
                
                generateTypeScriptWaitResultProcessing(code);
                break;
                
            case CLICKABILITY:
                code.append("// Wait for element clickability\n");
                code.append("try {\n");
                code.append("    const wait = new CSClickableWait(page, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    const result = await wait.waitForElement(\"").append(locator).append("\");\n");
                
                generateTypeScriptWaitResultProcessing(code);
                break;
                
            case PRESENCE:
                code.append("// Wait for element presence\n");
                code.append("try {\n");
                code.append("    const wait = new CSPresenceWait(page, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    const result = await wait.waitForElement(\"").append(locator).append("\");\n");
                
                generateTypeScriptWaitResultProcessing(code);
                break;
                
            case INVISIBILITY:
                code.append("// Wait for element invisibility\n");
                code.append("try {\n");
                code.append("    const wait = new CSInvisibilityWait(page, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    const result = await wait.waitForElement(\"").append(locator).append("\");\n");
                
                generateTypeScriptWaitResultProcessing(code);
                break;
                
            case TEXT:
                code.append("// Wait for text presence\n");
                code.append("try {\n");
                code.append("    const wait = new CSTextWait(page, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    const result = await wait.waitForText(\"").append(locator).append("\", \"")
                     .append(text).append("\");\n");
                
                generateTypeScriptWaitResultProcessing(code);
                break;
                
            case ATTRIBUTE:
                code.append("// Wait for attribute value\n");
                code.append("try {\n");
                code.append("    const wait = new CSAttributeWait(page, ").append(timeout).append(");\n");
                code.append("    wait.setPollingInterval(").append(pollingInterval).append(");\n");
                code.append("    const result = await wait.waitForAttribute(\"").append(locator).append("\", \"")
                     .append(attributeName).append("\", \"").append(attributeValue).append("\");\n");
                
                generateTypeScriptWaitResultProcessing(code);
                break;
                
            case CUSTOM:
                code.append("// Wait for custom JavaScript condition\n");
                code.append("try {\n");
                code.append("    const startTime = Date.now();\n");
                code.append("    const timeoutMs = ").append(timeout * 1000).append(";\n");
                code.append("    const pollingMs = ").append(pollingInterval).append(";\n");
                code.append("    let result = false;\n");
                code.append("    \n");
                code.append("    while (Date.now() - startTime < timeoutMs) {\n");
                code.append("        try {\n");
                code.append("            result = await page.evaluate(() => {\n");
                code.append("                return ").append(customExpression).append(";\n");
                code.append("            });\n");
                code.append("            \n");
                code.append("            if (result) {\n");
                code.append("                break;\n");
                code.append("            }\n");
                code.append("        } catch (e) {\n");
                code.append("            // Ignore errors and continue polling\n");
                code.append("        }\n");
                code.append("        \n");
                code.append("        await new Promise(resolve => setTimeout(resolve, pollingMs));\n");
                code.append("    }\n");
                
                generateTypeScriptWaitResultProcessing(code);
                break;
                
            default:
                return "// Unsupported wait type: " + waitType;
        }
        
        return code.toString();
    }
    
    /**
     * Helper method to generate the TypeScript result processing code for waits.
     * 
     * @param code StringBuilder to append the code to
     */
    private void generateTypeScriptWaitResultProcessing(StringBuilder code) {
        if (screenshot) {
            code.append("    if (result) {\n");
            code.append("        await CSScreenshotManager.takeScreenshot(page, \"Wait_Success_\");\n");
            code.append("    } else {\n");
            code.append("        await CSScreenshotManager.takeScreenshot(page, \"Wait_Failure_\");\n");
            code.append("    }\n");
        }
        
        if (successMessage != null && !successMessage.isEmpty()) {
            code.append("    if (result) {\n");
            code.append("        console.log(\"").append(successMessage).append("\");\n");
            code.append("    }\n");
        }
        
        if (failOnTimeout) {
            code.append("    if (!result) {\n");
            if (errorMessage != null && !errorMessage.isEmpty()) {
                code.append("        throw new Error(\"").append(errorMessage).append("\");\n");
            } else {
                code.append("        throw new Error(\"Wait condition not satisfied within timeout of ")
                     .append(timeout).append(" seconds\");\n");
            }
            code.append("    }\n");
        } else if (errorMessage != null && !errorMessage.isEmpty()) {
            code.append("    if (!result) {\n");
            code.append("        console.warn(\"").append(errorMessage).append("\");\n");
            code.append("    }\n");
        }
        
        code.append("} catch (e) {\n");
        code.append("    console.error(`Error during wait: ${e.message}`);\n");
        if (failOnTimeout) {
            code.append("    throw e;\n");
        }
        code.append("}");
    }
    
    /**
     * Escapes JavaScript code for use in string literals.
     * 
     * @param js JavaScript code
     * @return Escaped JavaScript code
     */
    private String escapeJavaScript(String js) {
        if (js == null) {
            return "";
        }
        
        return js.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
    
    /**
     * Serializes this wait configuration to a string representation.
     * 
     * @return String representation of the wait
     */
    @Override
    public String toString() {
        switch (waitType) {
            case FIXED:
                return String.format("FixedWait [timeout=%d sec]", timeout);
                
            case VISIBILITY:
                return String.format("VisibilityWait [locator=%s, timeout=%d sec]", locator, timeout);
                
            case CLICKABILITY:
                return String.format("ClickabilityWait [locator=%s, timeout=%d sec]", locator, timeout);
                
            case PRESENCE:
                return String.format("PresenceWait [locator=%s, timeout=%d sec]", locator, timeout);
                
            case INVISIBILITY:
                return String.format("InvisibilityWait [locator=%s, timeout=%d sec]", locator, timeout);
                
            case TEXT:
                return String.format("TextWait [locator=%s, text=%s, timeout=%d sec]", locator, text, timeout);
                
            case ATTRIBUTE:
                return String.format("AttributeWait [locator=%s, attribute=%s, value=%s, timeout=%d sec]", 
                                    locator, attributeName, attributeValue, timeout);
                
            case CUSTOM:
                return String.format("CustomWait [expression=%s, timeout=%d sec]", 
                                    (customExpression != null && customExpression.length() > 20) ? 
                                    customExpression.substring(0, 20) + "..." : customExpression, 
                                    timeout);
                
            default:
                return "UnknownWait [type=" + waitType + "]";
        }
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        
        WaitActionConfig that = (WaitActionConfig) o;
        
        if (timeout != that.timeout) return false;
        if (pollingInterval != that.pollingInterval) return false;
        if (failOnTimeout != that.failOnTimeout) return false;
        if (screenshot != that.screenshot) return false;
        if (waitType != that.waitType) return false;
        if (!Objects.equals(locator, that.locator)) return false;
        if (!Objects.equals(locatorType, that.locatorType)) return false;
        if (!Objects.equals(text, that.text)) return false;
        if (!Objects.equals(attributeName, that.attributeName)) return false;
        if (!Objects.equals(attributeValue, that.attributeValue)) return false;
        if (!Objects.equals(customExpression, that.customExpression)) return false;
        if (!Objects.equals(successMessage, that.successMessage)) return false;
        return Objects.equals(errorMessage, that.errorMessage);
    }
    
    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (waitType != null ? waitType.hashCode() : 0);
        result = 31 * result + timeout;
        result = 31 * result + pollingInterval;
        result = 31 * result + (locator != null ? locator.hashCode() : 0);
        result = 31 * result + (locatorType != null ? locatorType.hashCode() : 0);
        result = 31 * result + (text != null ? text.hashCode() : 0);
        result = 31 * result + (attributeName != null ? attributeName.hashCode() : 0);
        result = 31 * result + (attributeValue != null ? attributeValue.hashCode() : 0);
        result = 31 * result + (customExpression != null ? customExpression.hashCode() : 0);
        result = 31 * result + (failOnTimeout ? 1 : 0);
        result = 31 * result + (screenshot ? 1 : 0);
        result = 31 * result + (successMessage != null ? successMessage.hashCode() : 0);
        result = 31 * result + (errorMessage != null ? errorMessage.hashCode() : 0);
        return result;
    }
    
    // Getters and Setters
    
    public WaitType getWaitType() {
        return waitType;
    }
    
    public void setWaitType(WaitType waitType) {
        this.waitType = waitType;
    }
    
    public int getTimeout() {
        return timeout;
    }
    
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }
    
    public int getPollingInterval() {
        return pollingInterval;
    }
    
    public void setPollingInterval(int pollingInterval) {
        this.pollingInterval = pollingInterval;
    }
    
    public String getLocator() {
        return locator;
    }
    
    public void setLocator(String locator) {
        this.locator = locator;
    }
    
    public String getLocatorType() {
        return locatorType;
    }
    
    public void setLocatorType(String locatorType) {
        this.locatorType = locatorType;
    }
    
    public String getText() {
        return text;
    }
    
    public void setText(String text) {
        this.text = text;
    }
    
    public String getAttributeName() {
        return attributeName;
    }
    
    public void setAttributeName(String attributeName) {
        this.attributeName = attributeName;
    }
    
    public String getAttributeValue() {
        return attributeValue;
    }
    
    public void setAttributeValue(String attributeValue) {
        this.attributeValue = attributeValue;
    }
    
    public String getCustomExpression() {
        return customExpression;
    }
    
    public void setCustomExpression(String customExpression) {
        this.customExpression = customExpression;
    }
    
    public boolean isFailOnTimeout() {
        return failOnTimeout;
    }
    
    public void setFailOnTimeout(boolean failOnTimeout) {
        this.failOnTimeout = failOnTimeout;
    }
    
    public boolean isScreenshot() {
        return screenshot;
    }
    
    public void setScreenshot(boolean screenshot) {
        this.screenshot = screenshot;
    }
    
    public String getSuccessMessage() {
        return successMessage;
    }
    
    public void setSuccessMessage(String successMessage) {
        this.successMessage = successMessage;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
}



AssertionActionConfig.java
-------------------------------

package com.cstestforge.model.recorder;

import com.cstestforge.framework.core.utils.CSLogger;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeName;

import java.util.Objects;

/**
 * Configuration model for assertion actions in the recorder.
 * Supports different types of assertions: element existence, element visibility,
 * text content, attribute value, element count, and custom JavaScript assertions.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonTypeName("assertion")
public class AssertionActionConfig extends ActionConfig {
    private static final CSLogger logger = CSLogger.getLogger(AssertionActionConfig.class);
    
    /**
     * Enum representing different types of assertions.
     */
    public enum AssertionType {
        @JsonProperty("exists")
        EXISTS,
        
        @JsonProperty("notExists")
        NOT_EXISTS,
        
        @JsonProperty("visible")
        VISIBLE,
        
        @JsonProperty("notVisible")
        NOT_VISIBLE,
        
        @JsonProperty("enabled")
        ENABLED,
        
        @JsonProperty("disabled")
        DISABLED,
        
        @JsonProperty("text")
        TEXT,
        
        @JsonProperty("textContains")
        TEXT_CONTAINS,
        
        @JsonProperty("attribute")
        ATTRIBUTE,
        
        @JsonProperty("count")
        COUNT,
        
        @JsonProperty("custom")
        CUSTOM,
        
        @JsonProperty("title")
        TITLE,
        
        @JsonProperty("url")
        URL
    }
    
    /**
     * Enum representing different comparisons for numeric values.
     */
    public enum NumericComparison {
        @JsonProperty("equals")
        EQUALS,
        
        @JsonProperty("notEquals")
        NOT_EQUALS,
        
        @JsonProperty("greaterThan")
        GREATER_THAN,
        
        @JsonProperty("lessThan")
        LESS_THAN,
        
        @JsonProperty("greaterThanOrEquals")
        GREATER_THAN_OR_EQUALS,
        
        @JsonProperty("lessThanOrEquals")
        LESS_THAN_OR_EQUALS
    }
    
    @JsonProperty("assertionType")
    private AssertionType assertionType;
    
    @JsonProperty("locator")
    private String locator;
    
    @JsonProperty("locatorType")
    private String locatorType;
    
    @JsonProperty("expectedText")
    private String expectedText;
    
    @JsonProperty("caseSensitive")
    private boolean caseSensitive = false;
    
    @JsonProperty("trimText")
    private boolean trimText = true;
    
    @JsonProperty("attributeName")
    private String attributeName;
    
    @JsonProperty("attributeValue")
    private String attributeValue;
    
    @JsonProperty("expectedCount")
    private Integer expectedCount;
    
    @JsonProperty("numericComparison")
    private NumericComparison numericComparison = NumericComparison.EQUALS;
    
    @JsonProperty("customExpression")
    private String customExpression;
    
    @JsonProperty("expectedTitle")
    private String expectedTitle;
    
    @JsonProperty("expectedUrl")
    private String expectedUrl;
    
    @JsonProperty("urlPartial")
    private boolean urlPartial = false;
    
    @JsonProperty("softAssertion")
    private boolean softAssertion = false;
    
    @JsonProperty("screenshot")
    private boolean screenshot = false;
    
    @JsonProperty("description")
    private String description;
    
    /**
     * Default constructor.
     */
    public AssertionActionConfig() {
        setType("assertion");
    }
    
    /**
     * Constructor for element existence and visibility assertions.
     * 
     * @param assertionType Type of assertion (EXISTS, NOT_EXISTS, VISIBLE, NOT_VISIBLE)
     * @param locator Element locator
     * @param locatorType Locator type (CSS, XPath, etc.)
     */
    public AssertionActionConfig(AssertionType assertionType, String locator, String locatorType) {
        setType("assertion");
        this.assertionType = assertionType;
        this.locator = locator;
        this.locatorType = locatorType;
    }
    
    /**
     * Constructor for text assertions.
     * 
     * @param assertionType Type of assertion (TEXT, TEXT_CONTAINS)
     * @param locator Element locator
     * @param locatorType Locator type
     * @param expectedText Expected text
     * @param caseSensitive Whether the comparison is case-sensitive
     */
    public AssertionActionConfig(AssertionType assertionType, String locator, String locatorType, 
                                String expectedText, boolean caseSensitive) {
        setType("assertion");
        this.assertionType = assertionType;
        this.locator = locator;
        this.locatorType = locatorType;
        this.expectedText = expectedText;
        this.caseSensitive = caseSensitive;
    }
    
    /**
     * Constructor for attribute assertions.
     * 
     * @param locator Element locator
     * @param locatorType Locator type
     * @param attributeName Attribute name
     * @param attributeValue Expected attribute value
     */
    public AssertionActionConfig(String locator, String locatorType, String attributeName, String attributeValue) {
        setType("assertion");
        this.assertionType = AssertionType.ATTRIBUTE;
        this.locator = locator;
        this.locatorType = locatorType;
        this.attributeName = attributeName;
        this.attributeValue = attributeValue;
    }
    
    /**
     * Constructor for element count assertions.
     * 
     * @param locator Element locator
     * @param locatorType Locator type
     * @param expectedCount Expected element count
     * @param numericComparison Comparison operator
     */
    public AssertionActionConfig(String locator, String locatorType, int expectedCount, 
                                NumericComparison numericComparison) {
        setType("assertion");
        this.assertionType = AssertionType.COUNT;
        this.locator = locator;
        this.locatorType = locatorType;
        this.expectedCount = expectedCount;
        this.numericComparison = numericComparison;
    }
    
    /**
     * Constructor for custom JavaScript assertions.
     * 
     * @param customExpression Custom JavaScript expression that should evaluate to true/false
     */
    public AssertionActionConfig(String customExpression) {
        setType("assertion");
        this.assertionType = AssertionType.CUSTOM;
        this.customExpression = customExpression;
    }
    
    /**
     * Constructor for page title assertions.
     * 
     * @param expectedTitle Expected page title
     * @param caseSensitive Whether the comparison is case-sensitive
     */
    public AssertionActionConfig(String expectedTitle, boolean caseSensitive) {
        setType("assertion");
        this.assertionType = AssertionType.TITLE;
        this.expectedTitle = expectedTitle;
        this.caseSensitive = caseSensitive;
    }
    
    /**
     * Constructor for URL assertions.
     * 
     * @param expectedUrl Expected URL
     * @param urlPartial Whether to check for partial URL match
     */
    public AssertionActionConfig(String expectedUrl, boolean urlPartial, boolean isUrlAssertion) {
        setType("assertion");
        this.assertionType = AssertionType.URL;
        this.expectedUrl = expectedUrl;
        this.urlPartial = urlPartial;
    }
    
    /**
     * Validates the assertion configuration based on its type.
     * 
     * @return true if the configuration is valid, false otherwise
     */
    public boolean validate() {
        if (assertionType == null) {
            logger.error("Assertion type is required");
            return false;
        }
        
        switch (assertionType) {
            case EXISTS:
            case NOT_EXISTS:
            case VISIBLE:
            case NOT_VISIBLE:
            case ENABLED:
            case DISABLED:
                if (locator == null || locator.isEmpty()) {
                    logger.error("Locator is required for " + assertionType + " assertion");
                    return false;
                }
                break;
                
            case TEXT:
            case TEXT_CONTAINS:
                if (locator == null || locator.isEmpty()) {
                    logger.error("Locator is required for " + assertionType + " assertion");
                    return false;
                }
                if (expectedText == null) {
                    logger.error("Expected text is required for " + assertionType + " assertion");
                    return false;
                }
                break;
                
            case ATTRIBUTE:
                if (locator == null || locator.isEmpty()) {
                    logger.error("Locator is required for ATTRIBUTE assertion");
                    return false;
                }
                if (attributeName == null || attributeName.isEmpty()) {
                    logger.error("Attribute name is required for ATTRIBUTE assertion");
                    return false;
                }
                break;
                
            case COUNT:
                if (locator == null || locator.isEmpty()) {
                    logger.error("Locator is required for COUNT assertion");
                    return false;
                }
                if (expectedCount == null) {
                    logger.error("Expected count is required for COUNT assertion");
                    return false;
                }
                if (numericComparison == null) {
                    logger.error("Numeric comparison is required for COUNT assertion");
                    return false;
                }
                break;
                
            case CUSTOM:
                if (customExpression == null || customExpression.isEmpty()) {
                    logger.error("Custom expression is required for CUSTOM assertion");
                    return false;
                }
                break;
                
            case TITLE:
                if (expectedTitle == null || expectedTitle.isEmpty()) {
                    logger.error("Expected title is required for TITLE assertion");
                    return false;
                }
                break;
                
            case URL:
                if (expectedUrl == null || expectedUrl.isEmpty()) {
                    logger.error("Expected URL is required for URL assertion");
                    return false;
                }
                break;
                
            default:
                logger.error("Unsupported assertion type: " + assertionType);
                return false;
        }
        
        return true;
    }
    
    /**
     * Generates Java code for this assertion configuration.
     * 
     * @return Java code string representation of the assertion
     */
    public String generateJavaCode() {
        StringBuilder code = new StringBuilder();
        
        // Add description as a comment if available
        if (description != null && !description.isEmpty()) {
            code.append("// ").append(description).append("\n");
        }
        
        // Take screenshot before assertion if configured
        if (screenshot) {
            code.append("CSScreenshotManager.takeScreenshot(driver, \"Assertion_Before_\");\n\n");
        }
        
        code.append("try {\n");
        
        switch (assertionType) {
            case EXISTS:
                code.append("    // Assert element exists\n");
                code.append("    WebElement element = driver.findElement(").append(generateLocator()).append(");\n");
                code.append("    CSAssertions.assertNotNull(element, \"Element should exist\");\n");
                break;
                
            case NOT_EXISTS:
                code.append("    // Assert element does not exist\n");
                code.append("    List<WebElement> elements = driver.findElements(").append(generateLocator()).append(");\n");
                code.append("    CSAssertions.assertEquals(elements.size(), 0, \"Element should not exist\");\n");
                break;
                
            case VISIBLE:
                code.append("    // Assert element is visible\n");
                code.append("    WebElement element = driver.findElement(").append(generateLocator()).append(");\n");
                code.append("    CSAssertions.assertTrue(element.isDisplayed(), \"Element should be visible\");\n");
                break;
                
            case NOT_VISIBLE:
                code.append("    // Assert element is not visible\n");
                code.append("    List<WebElement> elements = driver.findElements(").append(generateLocator()).append(");\n");
                code.append("    if (!elements.isEmpty()) {\n");
                code.append("        CSAssertions.assertFalse(elements.get(0).isDisplayed(), \"Element should not be visible\");\n");
                code.append("    }\n");
                break;
                
            case ENABLED:
                code.append("    // Assert element is enabled\n");
                code.append("    WebElement element = driver.findElement(").append(generateLocator()).append(");\n");
                code.append("    CSAssertions.assertTrue(element.isEnabled(), \"Element should be enabled\");\n");
                break;
                
            case DISABLED:
                code.append("    // Assert element is disabled\n");
                code.append("    WebElement element = driver.findElement(").append(generateLocator()).append(");\n");
                code.append("    CSAssertions.assertFalse(element.isEnabled(), \"Element should be disabled\");\n");
                break;
                
            case TEXT:
                code.append("    // Assert element text equals\n");
                code.append("    WebElement element = driver.findElement(").append(generateLocator()).append(");\n");
                code.append("    String actualText = element.getText();\n");
                if (trimText) {
                    code.append("    actualText = actualText.trim();\n");
                }
                if (!caseSensitive) {
                    code.append("    CSAssertions.assertEquals(actualText.toLowerCase(), \"")
                         .append(escapeJava(expectedText.toLowerCase())).append("\", \"Element text should match\");\n");
                } else {
                    code.append("    CSAssertions.assertEquals(actualText, \"")
                         .append(escapeJava(expectedText)).append("\", \"Element text should match\");\n");
                }
                break;
                
            case TEXT_CONTAINS:
                code.append("    // Assert element text contains\n");
                code.append("    WebElement element = driver.findElement(").append(generateLocator()).append(");\n");
                code.append("    String actualText = element.getText();\n");
                if (trimText) {
                    code.append("    actualText = actualText.trim();\n");
                }
                if (!caseSensitive) {
                    code.append("    CSAssertions.assertTrue(actualText.toLowerCase().contains(\"")
                         .append(escapeJava(expectedText.toLowerCase())).append("\"), \"Element text should contain the expected value\");\n");
                } else {
                    code.append("    CSAssertions.assertTrue(actualText.contains(\"")
                         .append(escapeJava(expectedText)).append("\"), \"Element text should contain the expected value\");\n");
                }
                break;
                
            case ATTRIBUTE:
                code.append("    // Assert element attribute\n");
                code.append("    WebElement element = driver.findElement(").append(generateLocator()).append(");\n");
                code.append("    String attributeValue = element.getAttribute(\"").append(attributeName).append("\");\n");
                if (attributeValue != null) {
                    code.append("    CSAssertions.assertEquals(attributeValue, \"")
                         .append(escapeJava(attributeValue)).append("\", \"Element attribute value should match\");\n");
                } else {
                    code.append("    // Assert any non-null attribute value\n");
                    code.append("    CSAssertions.assertNotNull(attributeValue, \"Element should have attribute '")
                         .append(attributeName).append("'\");\n");
                }
                break;
                
            case COUNT:
                code.append("    // Assert element count\n");
                code.append("    List<WebElement> elements = driver.findElements(").append(generateLocator()).append(");\n");
                code.append("    int count = elements.size();\n");
                
                switch (numericComparison) {
                    case EQUALS:
                        code.append("    CSAssertions.assertEquals(count, ").append(expectedCount)
                             .append(", \"Element count should equal ").append(expectedCount).append("\");\n");
                        break;
                    case NOT_EQUALS:
                        code.append("    CSAssertions.assertNotEquals(count, ").append(expectedCount)
                             .append(", \"Element count should not equal ").append(expectedCount).append("\");\n");
                        break;
                    case GREATER_THAN:
                        code.append("    CSAssertions.assertTrue(count > ").append(expectedCount)
                             .append(", \"Element count should be greater than ").append(expectedCount).append("\");\n");
                        break;
                    case LESS_THAN:
                        code.append("    CSAssertions.assertTrue(count < ").append(expectedCount)
                             .append(", \"Element count should be less than ").append(expectedCount).append("\");\n");
                        break;
                    case GREATER_THAN_OR_EQUALS:
                        code.append("    CSAssertions.assertTrue(count >= ").append(expectedCount)
                             .append(", \"Element count should be greater than or equal to ").append(expectedCount).append("\");\n");
                        break;
                    case LESS_THAN_OR_EQUALS:
                        code.append("    CSAssertions.assertTrue(count <= ").append(expectedCount)
                             .append(", \"Element count should be less than or equal to ").append(expectedCount).append("\");\n");
                        break;
                    default:
                        code.append("    // Unsupported numeric comparison\n");
                }
                break;
                
            case CUSTOM:
                code.append("    // Assert custom expression\n");
                code.append("    Boolean result = (Boolean) ((JavascriptExecutor) driver).executeScript(\"")
                     .append(escapeJavaScript(customExpression)).append("\");\n");
                code.append("    CSAssertions.assertTrue(Boolean.TRUE.equals(result), \"Custom assertion should evaluate to true\");\n");
                break;
                
            case TITLE:
                code.append("    // Assert page title\n");
                code.append("    String actualTitle = driver.getTitle();\n");
                if (!caseSensitive) {
                    code.append("    CSAssertions.assertEquals(actualTitle.toLowerCase(), \"")
                         .append(escapeJava(expectedTitle.toLowerCase())).append("\", \"Page title should match\");\n");
                } else {
                    code.append("    CSAssertions.assertEquals(actualTitle, \"")
                         .append(escapeJava(expectedTitle)).append("\", \"Page title should match\");\n");
                }
                break;
                
            case URL:
                code.append("    // Assert page URL\n");
                code.append("    String actualUrl = driver.getCurrentUrl();\n");
                if (urlPartial) {
                    code.append("    CSAssertions.assertTrue(actualUrl.contains(\"")
                         .append(escapeJava(expectedUrl)).append("\"), \"Page URL should contain the expected value\");\n");
                } else {
                    code.append("    CSAssertions.assertEquals(actualUrl, \"")
                         .append(escapeJava(expectedUrl)).append("\", \"Page URL should match\");\n");
                }
                break;
                
            default:
                code.append("    // Unsupported assertion type: ").append(assertionType).append("\n");
        }
        
        // Take screenshot after assertion if configured
        if (screenshot) {
            code.append("\n    CSScreenshotManager.takeScreenshot(driver, \"Assertion_Passed_\");\n");
        }
        
        // Handle soft assertions
        if (softAssertion) {
            code.append("} catch (AssertionError e) {\n");
            code.append("    // Soft assertion: log the failure but continue execution\n");
            code.append("    logger.warn(\"Soft assertion failed: \" + e.getMessage());\n");
            if (screenshot) {
                code.append("    CSScreenshotManager.takeScreenshot(driver, \"Assertion_Failed_\");\n");
            }
        }
        
        // Add catch block for other exceptions
        code.append("} catch (Exception e) {\n");
        if (screenshot) {
            code.append("    CSScreenshotManager.takeScreenshot(driver, \"Assertion_Error_\");\n");
        }
        if (softAssertion) {
            code.append("    // Soft assertion: log the error but continue execution\n");
            code.append("    logger.warn(\"Error during soft assertion: \" + e.getMessage());\n");
        } else {
            code.append("    logger.error(\"Error during assertion: \" + e.getMessage());\n");
            code.append("    throw e;\n");
        }
        code.append("}");
        
        return code.toString();
    }
    
    /**
     * Generates TypeScript code for this assertion configuration.
     * 
     * @return TypeScript code string representation of the assertion
     */
    public String generateTypeScriptCode() {
        StringBuilder code = new StringBuilder();
        
        // Add description as a comment if available
        if (description != null && !description.isEmpty()) {
            code.append("// ").append(description).append("\n");
        }
        
        // Take screenshot before assertion if configured
        if (screenshot) {
            code.append("await CSScreenshotManager.takeScreenshot(page, \"Assertion_Before_\");\n\n");
        }
        
        code.append("try {\n");
        
        switch (assertionType) {
            case EXISTS:
                code.append("    // Assert element exists\n");
                code.append("    const element = await page.$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    CSAssertions.assertNotNull(element, \"Element should exist\");\n");
                break;
                
            case NOT_EXISTS:
                code.append("    // Assert element does not exist\n");
                code.append("    const elements = await page.$$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    CSAssertions.assertEquals(elements.length, 0, \"Element should not exist\");\n");
                break;
                
            case VISIBLE:
                code.append("    // Assert element is visible\n");
                code.append("    const element = await page.$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    CSAssertions.assertNotNull(element, \"Element should exist\");\n");
                code.append("    const isVisible = await element.isVisible();\n");
                code.append("    CSAssertions.assertTrue(isVisible, \"Element should be visible\");\n");
                break;
                
            case NOT_VISIBLE:
                code.append("    // Assert element is not visible\n");
                code.append("    const elements = await page.$$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    if (elements.length > 0) {\n");
                code.append("        const isVisible = await elements[0].isVisible();\n");
                code.append("        CSAssertions.assertFalse(isVisible, \"Element should not be visible\");\n");
                code.append("    }\n");
                break;
                
            case ENABLED:
                code.append("    // Assert element is enabled\n");
                code.append("    const element = await page.$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    CSAssertions.assertNotNull(element, \"Element should exist\");\n");
                code.append("    const isEnabled = await element.isEnabled();\n");
                code.append("    CSAssertions.assertTrue(isEnabled, \"Element should be enabled\");\n");
                break;
                
            case DISABLED:
                code.append("    // Assert element is disabled\n");
                code.append("    const element = await page.$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    CSAssertions.assertNotNull(element, \"Element should exist\");\n");
                code.append("    const isEnabled = await element.isEnabled();\n");
                code.append("    CSAssertions.assertFalse(isEnabled, \"Element should be disabled\");\n");
                break;
                
            case TEXT:
                code.append("    // Assert element text equals\n");
                code.append("    const element = await page.$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    CSAssertions.assertNotNull(element, \"Element should exist\");\n");
                code.append("    let actualText = await element.textContent() || \"\";\n");
                if (trimText) {
                    code.append("    actualText = actualText.trim();\n");
                }
                if (!caseSensitive) {
                    code.append("    CSAssertions.assertEquals(actualText.toLowerCase(), \"")
                         .append(escapeJavaScript(expectedText.toLowerCase())).append("\", \"Element text should match\");\n");
                } else {
                    code.append("    CSAssertions.assertEquals(actualText, \"")
                         .append(escapeJavaScript(expectedText)).append("\", \"Element text should match\");\n");
                }
                break;
                
            case TEXT_CONTAINS:
                code.append("    // Assert element text contains\n");
                code.append("    const element = await page.$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    CSAssertions.assertNotNull(element, \"Element should exist\");\n");
                code.append("    let actualText = await element.textContent() || \"\";\n");
                if (trimText) {
                    code.append("    actualText = actualText.trim();\n");
                }
                if (!caseSensitive) {
                    code.append("    CSAssertions.assertTrue(actualText.toLowerCase().includes(\"")
                         .append(escapeJavaScript(expectedText.toLowerCase())).append("\"), \"Element text should contain the expected value\");\n");
                } else {
                    code.append("    CSAssertions.assertTrue(actualText.includes(\"")
                         .append(escapeJavaScript(expectedText)).append("\"), \"Element text should contain the expected value\");\n");
                }
                break;
                
            case ATTRIBUTE:
                code.append("    // Assert element attribute\n");
                code.append("    const element = await page.$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    CSAssertions.assertNotNull(element, \"Element should exist\");\n");
                code.append("    const attributeValue = await element.getAttribute(\"").append(attributeName).append("\");\n");
                if (attributeValue != null) {
                    code.append("    CSAssertions.assertEquals(attributeValue, \"")
                         .append(escapeJavaScript(attributeValue)).append("\", \"Element attribute value should match\");\n");
                } else {
                    code.append("    // Assert any non-null attribute value\n");
                    code.append("    CSAssertions.assertNotNull(attributeValue, \"Element should have attribute '")
                         .append(attributeName).append("'\");\n");
                }
                break;
                
            case COUNT:
                code.append("    // Assert element count\n");
                code.append("    const elements = await page.$$(\"").append(escapeJavaScript(locator)).append("\");\n");
                code.append("    const count = elements.length;\n");
                
                switch (numericComparison) {
                    case EQUALS:
                        code.append("    CSAssertions.assertEquals(count, ").append(expectedCount)
                             .append(", \"Element count should equal ").append(expectedCount).append("\");\n");
                        break;
                    case NOT_EQUALS:
                        code.append("    CSAssertions.assertNotEquals(count, ").append(expectedCount)
                             .append(", \"Element count should not equal ").append(expectedCount).append("\");\n");
                        break;
                    case GREATER_THAN:
                        code.append("    CSAssertions.assertTrue(count > ").append(expectedCount)
                             .append(", \"Element count should be greater than ").append(expectedCount).append("\");\n");
                        break;
                    case LESS_THAN:
                        code.append("    CSAssertions.assertTrue(count < ").append(expectedCount)
                             .append(", \"Element count should be less than ").append(expectedCount).append("\");\n");
                        break;
                    case GREATER_THAN_OR_EQUALS:
                        code.append("    CSAssertions.assertTrue(count >= ").append(expectedCount)
                             .append(", \"Element count should be greater than or equal to ").append(expectedCount).append("\");\n");
                        break;
                    case LESS_THAN_OR_EQUALS:
                        code.append("    CSAssertions.assertTrue(count <= ").append(expectedCount)
                             .append(", \"Element count should be less than or equal to ").append(expectedCount).append("\");\n");
                        break;
                    default:
                        code.append("    // Unsupported numeric comparison\n");
                }
                break;
                
            case CUSTOM:
                code.append("    // Assert custom expression\n");
                code.append("    const result = await page.evaluate(() => {\n");
                code.append("        return ").append(customExpression).append(";\n");
                code.append("    });\n");
                code.append("    CSAssertions.assertTrue(result === true, \"Custom assertion should evaluate to true\");\n");
                break;
                
            case TITLE:
                code.append("    // Assert page title\n");
                code.append("    const actualTitle = await page.title();\n");
                if (!caseSensitive) {
                    code.append("    CSAssertions.assertEquals(actualTitle.toLowerCase(), \"")
                         .append(escapeJavaScript(expectedTitle.toLowerCase())).append("\", \"Page title should match\");\n");
                } else {
                    code.append("    CSAssertions.assertEquals(actualTitle, \"")
                         .append(escapeJavaScript(expectedTitle)).append("\", \"Page title should match\");\n");
                }
                break;
                
            case URL:
                code.append("    // Assert page URL\n");
                code.append("    const actualUrl = page.url();\n");
                if (urlPartial) {
                    code.append("    CSAssertions.assertTrue(actualUrl.includes(\"")
                         .append(escapeJavaScript(expectedUrl)).append("\"), \"Page URL should contain the expected value\");\n");
                } else {
                    code.append("    CSAssertions.assertEquals(actualUrl, \"")
                         .append(escapeJavaScript(expectedUrl)).append("\", \"Page URL should match\");\n");
                }
                break;
                
            default:
                code.append("    // Unsupported assertion type: ").append(assertionType).append("\n");
        }
        
        // Take screenshot after assertion if configured
        if (screenshot) {
            code.append("\n    await CSScreenshotManager.takeScreenshot(page, \"Assertion_Passed_\");\n");
        }
        
        // Handle soft assertions
        if (softAssertion) {
            code.append("} catch (e) {\n");
            code.append("    if (e instanceof Error && e.name === 'AssertionError') {\n");
            code.append("        // Soft assertion: log the failure but continue execution\n");
            code.append("        console.warn(`Soft assertion failed: ${e.message}`);\n");
            if (screenshot) {
                code.append("        await CSScreenshotManager.takeScreenshot(page, \"Assertion_Failed_\");\n");
            }
            code.append("    } else {\n");
            code.append("        // Log other errors\n");
            code.append("        console.warn(`Error during soft assertion: ${e instanceof Error ? e.message : String(e)}`);\n");
            if (screenshot) {
                code.append("        await CSScreenshotManager.takeScreenshot(page, \"Assertion_Error_\");\n");
            }
            code.append("    }\n");
        } else {
            code.append("} catch (e) {\n");
            if (screenshot) {
                code.append("    await CSScreenshotManager.takeScreenshot(page, \"Assertion_Error_\");\n");
            }
            code.append("    console.error(`Error during assertion: ${e instanceof Error ? e.message : String(e)}`);\n");
            code.append("    throw e;\n");
        }
        
        code.append("}");
        
        return code.toString();
    }
    
    /**
     * Generates a locator expression based on the locator type.
     * 
     * @return Locator expression
     */
    private String generateLocator() {
        if (locatorType == null || locatorType.isEmpty() || "css".equalsIgnoreCase(locatorType)) {
            return "By.cssSelector(\"" + escapeJava(locator) + "\")";
        } else if ("xpath".equalsIgnoreCase(locatorType)) {
            return "By.xpath(\"" + escapeJava(locator) + "\")";
        } else if ("id".equalsIgnoreCase(locatorType)) {
            return "By.id(\"" + escapeJava(locator) + "\")";
        } else if ("name".equalsIgnoreCase(locatorType)) {
            return "By.name(\"" + escapeJava(locator) + "\")";
        } else if ("linkText".equalsIgnoreCase(locatorType) || "link".equalsIgnoreCase(locatorType)) {
            return "By.linkText(\"" + escapeJava(locator) + "\")";
        } else if ("partialLinkText".equalsIgnoreCase(locatorType) || "partialLink".equalsIgnoreCase(locatorType)) {
            return "By.partialLinkText(\"" + escapeJava(locator) + "\")";
        } else if ("className".equalsIgnoreCase(locatorType) || "class".equalsIgnoreCase(locatorType)) {
            return "By.className(\"" + escapeJava(locator) + "\")";
        } else if ("tagName".equalsIgnoreCase(locatorType) || "tag".equalsIgnoreCase(locatorType)) {
            return "By.tagName(\"" + escapeJava(locator) + "\")";
        } else {
            return "By.cssSelector(\"" + escapeJava(locator) + "\")";
        }
    }
    
    /**
     * Escapes Java string literals.
     * 
     * @param str String to escape
     * @return Escaped string
     */
    private String escapeJava(String str) {
        if (str == null) {
            return "";
        }
        
        return str.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
    
    /**
     * Escapes JavaScript code for use in string literals.
     * 
     * @param js JavaScript code
     * @return Escaped JavaScript code
     */
    private String escapeJavaScript(String js) {
        if (js == null) {
            return "";
        }
        
        return js.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
    
    /**
     * Serializes this assertion configuration to a string representation.
     * 
     * @return String representation of the assertion
     */
    @Override
    public String toString() {
        switch (assertionType) {
            case EXISTS:
                return String.format("AssertExists [locator=%s]", locator);
                
            case NOT_EXISTS:
                return String.format("AssertNotExists [locator=%s]", locator);
                
            case VISIBLE:
                return String.format("AssertVisible [locator=%s]", locator);
                
            case NOT_VISIBLE:
                return String.format("AssertNotVisible [locator=%s]", locator);
                
            case ENABLED:
                return String.format("AssertEnabled [locator=%s]", locator);
                
            case DISABLED:
                return String.format("AssertDisabled [locator=%s]", locator);
                
            case TEXT:
                return String.format("AssertText [locator=%s, text=%s, caseSensitive=%b]", 
                                    locator, expectedText, caseSensitive);
                
            case TEXT_CONTAINS:
                return String.format("AssertTextContains [locator=%s, text=%s, caseSensitive=%b]", 
                                    locator, expectedText, caseSensitive);
                
            case ATTRIBUTE:
                return String.format("AssertAttribute [locator=%s, attribute=%s, value=%s]", 
                                    locator, attributeName, attributeValue);
                
            case COUNT:
                return String.format("AssertCount [locator=%s, count=%s %s]", 
                                    locator, numericComparison.toString().toLowerCase(), expectedCount);
                
            case CUSTOM:
                String expressionSummary = customExpression;
                if (expressionSummary != null && expressionSummary.length() > 20) {
                    expressionSummary = expressionSummary.substring(0, 20) + "...";
                }
                return String.format("AssertCustom [expression=%s]", expressionSummary);
                
            case TITLE:
                return String.format("AssertTitle [title=%s, caseSensitive=%b]", 
                                    expectedTitle, caseSensitive);
                
            case URL:
                return String.format("AssertUrl [url=%s, partial=%b]", 
                                    expectedUrl, urlPartial);
                
            default:
                return "UnknownAssertion [type=" + assertionType + "]";
        }
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        
        AssertionActionConfig that = (AssertionActionConfig) o;
        
        if (caseSensitive != that.caseSensitive) return false;
        if (trimText != that.trimText) return false;
        if (urlPartial != that.urlPartial) return false;
        if (softAssertion != that.softAssertion) return false;
        if (screenshot != that.screenshot) return false;
        if (assertionType != that.assertionType) return false;
        if (!Objects.equals(locator, that.locator)) return false;
        if (!Objects.equals(locatorType, that.locatorType)) return false;
        if (!Objects.equals(expectedText, that.expectedText)) return false;
        if (!Objects.equals(attributeName, that.attributeName)) return false;
        if (!Objects.equals(attributeValue, that.attributeValue)) return false;
        if (!Objects.equals(expectedCount, that.expectedCount)) return false;
        if (numericComparison != that.numericComparison) return false;
        if (!Objects.equals(customExpression, that.customExpression)) return false;
        if (!Objects.equals(expectedTitle, that.expectedTitle)) return false;
        if (!Objects.equals(expectedUrl, that.expectedUrl)) return false;
        return Objects.equals(description, that.description);
    }
    
    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (assertionType != null ? assertionType.hashCode() : 0);
        result = 31 * result + (locator != null ? locator.hashCode() : 0);
        result = 31 * result + (locatorType != null ? locatorType.hashCode() : 0);
        result = 31 * result + (expectedText != null ? expectedText.hashCode() : 0);
        result = 31 * result + (caseSensitive ? 1 : 0);
        result = 31 * result + (trimText ? 1 : 0);
        result = 31 * result + (attributeName != null ? attributeName.hashCode() : 0);
        result = 31 * result + (attributeValue != null ? attributeValue.hashCode() : 0);
        result = 31 * result + (expectedCount != null ? expectedCount.hashCode() : 0);
        result = 31 * result + (numericComparison != null ? numericComparison.hashCode() : 0);
        result = 31 * result + (customExpression != null ? customExpression.hashCode() : 0);
        result = 31 * result + (expectedTitle != null ? expectedTitle.hashCode() : 0);
        result = 31 * result + (expectedUrl != null ? expectedUrl.hashCode() : 0);
        result = 31 * result + (urlPartial ? 1 : 0);
        result = 31 * result + (softAssertion ? 1 : 0);
        result = 31 * result + (screenshot ? 1 : 0);
        result = 31 * result + (description != null ? description.hashCode() : 0);
        return result;
    }
    
    // Getters and Setters
    
    public AssertionType getAssertionType() {
        return assertionType;
    }
    
    public void setAssertionType(AssertionType assertionType) {
        this.assertionType = assertionType;
    }
    
    public String getLocator() {
        return locator;
    }
    
    public void setLocator(String locator) {
        this.locator = locator;
    }
    
    public String getLocatorType() {
        return locatorType;
    }
    
    public void setLocatorType(String locatorType) {
        this.locatorType = locatorType;
    }
    
    public String getExpectedText() {
        return expectedText;
    }
    
    public void setExpectedText(String expectedText) {
        this.expectedText = expectedText;
    }
    
    public boolean isCaseSensitive() {
        return caseSensitive;
    }
    
    public void setCaseSensitive(boolean caseSensitive) {
        this.caseSensitive = caseSensitive;
    }
    
    public boolean isTrimText() {
        return trimText;
    }
    
    public void setTrimText(boolean trimText) {
        this.trimText = trimText;
    }
    
    public String getAttributeName() {
        return attributeName;
    }
    
    public void setAttributeName(String attributeName) {
        this.attributeName = attributeName;
    }
    
    public String getAttributeValue() {
        return attributeValue;
    }
    
    public void setAttributeValue(String attributeValue) {
        this.attributeValue = attributeValue;
    }
    
    public Integer getExpectedCount() {
        return expectedCount;
    }
    
    public void setExpectedCount(Integer expectedCount) {
        this.expectedCount = expectedCount;
    }
    
    public NumericComparison getNumericComparison() {
        return numericComparison;
    }
    
    public void setNumericComparison(NumericComparison numericComparison) {
        this.numericComparison = numericComparison;
    }
    
    public String getCustomExpression() {
        return customExpression;
    }
    
    public void setCustomExpression(String customExpression) {
        this.customExpression = customExpression;
    }
    
    public String getExpectedTitle() {
        return expectedTitle;
    }
    
    public void setExpectedTitle(String expectedTitle) {
        this.expectedTitle = expectedTitle;
    }
    
    public String getExpectedUrl() {
        return expectedUrl;
    }
    
    public void setExpectedUrl(String expectedUrl) {
        this.expectedUrl = expectedUrl;
    }
    
    public boolean isUrlPartial() {
        return urlPartial;
    }
    
    public void setUrlPartial(boolean urlPartial) {
        this.urlPartial = urlPartial;
    }
    
    public boolean isSoftAssertion() {
        return softAssertion;
    }
    
    public void setSoftAssertion(boolean softAssertion) {
        this.softAssertion = softAssertion;
    }
    
    public boolean isScreenshot() {
        return screenshot;
    }
    
    public void setScreenshot(boolean screenshot) {
        this.screenshot = screenshot;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
}



TestExecutionRequest.java
-------------------------------

package com.cstestforge.model.execution;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.Objects;

/**
 * Represents a request to execute one or more tests.
 * This model contains all the information needed to run tests,
 * including the test identifiers, environment settings, and execution options.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class TestExecutionRequest {
    
    /**
     * Unique identifier for this execution request.
     */
    private String executionId;
    
    /**
     * List of test case identifiers to execute.
     */
    private List<String> testCaseIds;
    
    /**
     * Test suite identifier if executing a test suite.
     * May be null if executing individual test cases.
     */
    private String testSuiteId;
    
    /**
     * Project identifier that the tests belong to.
     */
    private String projectId;
    
    /**
     * Environment to execute the tests in (e.g., "qa", "staging", "production").
     */
    private String environment;
    
    /**
     * Configuration for the execution environment.
     */
    private ExecutionEnvironment executionEnvironment;
    
    /**
     * Configuration for parallel execution.
     * May be null if parallel execution is not requested.
     */
    private ParallelConfig parallelConfig;
    
    /**
     * Flag to indicate whether to record a video of the test execution.
     */
    private boolean recordVideo = false;
    
    /**
     * Flag to indicate whether to take screenshots on failures only.
     */
    private boolean screenshotOnFailureOnly = true;
    
    /**
     * Flag to enable detailed logging during test execution.
     */
    private boolean detailedLogging = false;
    
    /**
     * Flag to enable self-healing for locators during test execution.
     */
    private boolean enableSelfHealing = true;
    
    /**
     * Maximum execution time in minutes before forcibly terminating tests.
     * Default is 60 minutes (1 hour).
     */
    private int timeoutMinutes = 60;
    
    /**
     * Tags to filter tests for execution. Only tests with these tags will be executed.
     * If empty, all tests are considered for execution.
     */
    private List<String> tags = new ArrayList<>();
    
    /**
     * Additional parameters to pass to the tests.
     * These can be accessed by the tests during execution.
     */
    private Map<String, String> parameters = new HashMap<>();
    
    /**
     * Timestamp when the request was created.
     */
    private long createdTimestamp = System.currentTimeMillis();
    
    /**
     * User who initiated the execution request.
     */
    private String requestedBy;
    
    /**
     * Description or purpose of this test execution.
     */
    private String description;
    
    /**
     * Default constructor.
     */
    public TestExecutionRequest() {
        this.executionId = generateExecutionId();
    }
    
    /**
     * Constructor with project ID.
     * 
     * @param projectId The project identifier
     */
    public TestExecutionRequest(String projectId) {
        this.executionId = generateExecutionId();
        this.projectId = projectId;
    }
    
    /**
     * Constructor for executing individual test cases.
     * 
     * @param projectId The project identifier
     * @param testCaseIds List of test case identifiers
     */
    public TestExecutionRequest(String projectId, List<String> testCaseIds) {
        this.executionId = generateExecutionId();
        this.projectId = projectId;
        this.testCaseIds = testCaseIds;
    }
    
    /**
     * Constructor for executing a test suite.
     * 
     * @param projectId The project identifier
     * @param testSuiteId The test suite identifier
     */
    public TestExecutionRequest(String projectId, String testSuiteId) {
        this.executionId = generateExecutionId();
        this.projectId = projectId;
        this.testSuiteId = testSuiteId;
    }
    
    /**
     * Constructor with project ID and environment.
     * 
     * @param projectId The project identifier
     * @param environment The execution environment
     */
    public TestExecutionRequest(String projectId, String environment) {
        this.executionId = generateExecutionId();
        this.projectId = projectId;
        this.environment = environment;
    }
    
    /**
     * Validates that the test execution request contains all required information.
     * 
     * @return true if the request is valid, false otherwise
     */
    public boolean validate() {
        // Project ID is always required
        if (projectId == null || projectId.isEmpty()) {
            return false;
        }
        
        // Either test case IDs or test suite ID must be provided
        if ((testCaseIds == null || testCaseIds.isEmpty()) && (testSuiteId == null || testSuiteId.isEmpty())) {
            return false;
        }
        
        // If environment is specified, check if execution environment is also specified
        if (environment != null && !environment.isEmpty() && executionEnvironment == null) {
            // Create a default execution environment based on the environment name
            executionEnvironment = new ExecutionEnvironment(environment);
        }
        
        // Validate timeout value (must be positive)
        if (timeoutMinutes <= 0) {
            timeoutMinutes = 60; // Reset to default if invalid
        }
        
        return true;
    }
    
    /**
     * Generates a unique execution ID.
     * 
     * @return A unique execution ID
     */
    private String generateExecutionId() {
        return "EXEC-" + UUID.randomUUID().toString();
    }
    
    /**
     * Adds a test case ID to the list of test cases to execute.
     * 
     * @param testCaseId The test case identifier
     */
    public void addTestCaseId(String testCaseId) {
        if (testCaseId != null && !testCaseId.isEmpty()) {
            if (testCaseIds == null) {
                testCaseIds = new ArrayList<>();
            }
            testCaseIds.add(testCaseId);
        }
    }
    
    /**
     * Adds a parameter to the test execution request.
     * 
     * @param key Parameter key
     * @param value Parameter value
     */
    public void addParameter(String key, String value) {
        if (key != null && !key.isEmpty()) {
            parameters.put(key, value);
        }
    }
    
    /**
     * Adds a tag to the test execution request.
     * 
     * @param tag Tag to add
     */
    public void addTag(String tag) {
        if (tag != null && !tag.isEmpty()) {
            tags.add(tag);
        }
    }
    
    /**
     * Returns a string representation of the test execution request.
     * 
     * @return String representation
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("TestExecutionRequest{");
        sb.append("executionId='").append(executionId).append('\'');
        sb.append(", projectId='").append(projectId).append('\'');
        
        if (testSuiteId != null && !testSuiteId.isEmpty()) {
            sb.append(", testSuiteId='").append(testSuiteId).append('\'');
        }
        
        if (testCaseIds != null && !testCaseIds.isEmpty()) {
            sb.append(", testCases=").append(testCaseIds.size());
        }
        
        sb.append(", environment='").append(environment).append('\'');
        
        if (parallelConfig != null) {
            sb.append(", parallel=").append(parallelConfig.getMaxThreads()).append(" threads");
        }
        
        sb.append(", tags=").append(tags.size());
        sb.append(", params=").append(parameters.size());
        sb.append(", timeout=").append(timeoutMinutes).append("min");
        sb.append('}');
        
        return sb.toString();
    }
    
    /**
     * Returns a descriptive string for logging or display purposes.
     * 
     * @return Descriptive representation of the request
     */
    public String getDisplayName() {
        if (description != null && !description.isEmpty()) {
            return description;
        }
        
        StringBuilder sb = new StringBuilder();
        
        if (testSuiteId != null && !testSuiteId.isEmpty()) {
            sb.append("Suite[").append(testSuiteId).append("]");
        } else if (testCaseIds != null && !testCaseIds.isEmpty()) {
            sb.append("Tests[").append(testCaseIds.size()).append("]");
        }
        
        sb.append(" on ").append(environment != null ? environment : "default");
        
        if (requestedBy != null && !requestedBy.isEmpty()) {
            sb.append(" by ").append(requestedBy);
        }
        
        return sb.toString();
    }
    
    /**
     * Compares this execution request with another object for equality.
     * 
     * @param o The object to compare with
     * @return true if the objects are equal, false otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        TestExecutionRequest that = (TestExecutionRequest) o;
        
        return Objects.equals(executionId, that.executionId);
    }
    
    /**
     * Returns a hash code for this execution request.
     * 
     * @return Hash code
     */
    @Override
    public int hashCode() {
        return Objects.hash(executionId);
    }
    
    // Getters and Setters
    
    public String getExecutionId() {
        return executionId;
    }
    
    public void setExecutionId(String executionId) {
        this.executionId = executionId;
    }
    
    public List<String> getTestCaseIds() {
        return testCaseIds;
    }
    
    public void setTestCaseIds(List<String> testCaseIds) {
        this.testCaseIds = testCaseIds;
    }
    
    public String getTestSuiteId() {
        return testSuiteId;
    }
    
    public void setTestSuiteId(String testSuiteId) {
        this.testSuiteId = testSuiteId;
    }
    
    public String getProjectId() {
        return projectId;
    }
    
    public void setProjectId(String projectId) {
        this.projectId = projectId;
    }
    
    public String getEnvironment() {
        return environment;
    }
    
    public void setEnvironment(String environment) {
        this.environment = environment;
    }
    
    public ExecutionEnvironment getExecutionEnvironment() {
        return executionEnvironment;
    }
    
    public void setExecutionEnvironment(ExecutionEnvironment executionEnvironment) {
        this.executionEnvironment = executionEnvironment;
    }
    
    public ParallelConfig getParallelConfig() {
        return parallelConfig;
    }
    
    public void setParallelConfig(ParallelConfig parallelConfig) {
        this.parallelConfig = parallelConfig;
    }
    
    public boolean isRecordVideo() {
        return recordVideo;
    }
    
    public void setRecordVideo(boolean recordVideo) {
        this.recordVideo = recordVideo;
    }
    
    public boolean isScreenshotOnFailureOnly() {
        return screenshotOnFailureOnly;
    }
    
    public void setScreenshotOnFailureOnly(boolean screenshotOnFailureOnly) {
        this.screenshotOnFailureOnly = screenshotOnFailureOnly;
    }
    
    public boolean isDetailedLogging() {
        return detailedLogging;
    }
    
    public void setDetailedLogging(boolean detailedLogging) {
        this.detailedLogging = detailedLogging;
    }
    
    public boolean isEnableSelfHealing() {
        return enableSelfHealing;
    }
    
    public void setEnableSelfHealing(boolean enableSelfHealing) {
        this.enableSelfHealing = enableSelfHealing;
    }
    
    public int getTimeoutMinutes() {
        return timeoutMinutes;
    }
    
    public void setTimeoutMinutes(int timeoutMinutes) {
        this.timeoutMinutes = timeoutMinutes;
    }
    
    public List<String> getTags() {
        return tags;
    }
    
    public void setTags(List<String> tags) {
        this.tags = tags != null ? tags : new ArrayList<>();
    }
    
    public Map<String, String> getParameters() {
        return parameters;
    }
    
    public void setParameters(Map<String, String> parameters) {
        this.parameters = parameters != null ? parameters : new HashMap<>();
    }
    
    public long getCreatedTimestamp() {
        return createdTimestamp;
    }
    
    public void setCreatedTimestamp(long createdTimestamp) {
        this.createdTimestamp = createdTimestamp;
    }
    
    public String getRequestedBy() {
        return requestedBy;
    }
    
    public void setRequestedBy(String requestedBy) {
        this.requestedBy = requestedBy;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
}


TestExecutionResult.java
-----------------------------------

package com.cstestforge.model.execution;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Represents the result of a test execution request.
 * This model contains all the information about the test execution,
 * including overall status, individual test results, and execution metrics.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class TestExecutionResult {
    
    /**
     * Execution ID associated with this result, matching the original request ID.
     */
    private String executionId;
    
    /**
     * Project ID associated with this execution.
     */
    private String projectId;
    
    /**
     * Test suite ID if this execution was for a test suite.
     */
    private String testSuiteId;
    
    /**
     * Overall status of the execution.
     */
    private TestStatus status;
    
    /**
     * List of individual test case results.
     */
    private List<TestCaseResult> testCaseResults = new ArrayList<>();
    
    /**
     * Total duration of the execution in milliseconds.
     */
    private long durationMs;
    
    /**
     * Timestamp when the execution started.
     */
    private long startTimestamp;
    
    /**
     * Timestamp when the execution ended.
     */
    private long endTimestamp;
    
    /**
     * Summary metrics for the execution.
     */
    private Map<String, Object> metrics = new HashMap<>();
    
    /**
     * Path to the execution logs.
     */
    private String logPath;
    
    /**
     * Path to the execution report.
     */
    private String reportPath;
    
    /**
     * Path to the execution video.
     */
    private String videoPath;
    
    /**
     * Execution environment information.
     */
    private ExecutionEnvironment environment;
    
    /**
     * System resource metrics collected during execution.
     */
    private ResourceMetrics resourceMetrics;
    
    /**
     * User who requested this execution.
     */
    private String requestedBy;
    
    /**
     * Agent/machine that performed the execution.
     */
    private String executedOn;
    
    /**
     * Any error that occurred during the execution setup or teardown
     * (not related to individual test failures).
     */
    private String error;
    
    /**
     * Default constructor.
     */
    public TestExecutionResult() {
        this.startTimestamp = System.currentTimeMillis();
        this.status = TestStatus.RUNNING;
    }
    
    /**
     * Constructor with execution ID.
     * 
     * @param executionId The execution identifier
     */
    public TestExecutionResult(String executionId) {
        this.executionId = executionId;
        this.startTimestamp = System.currentTimeMillis();
        this.status = TestStatus.RUNNING;
    }
    
    /**
     * Constructor with execution request.
     * 
     * @param request The execution request
     */
    public TestExecutionResult(TestExecutionRequest request) {
        this.executionId = request.getExecutionId();
        this.projectId = request.getProjectId();
        this.testSuiteId = request.getTestSuiteId();
        this.environment = request.getExecutionEnvironment();
        this.requestedBy = request.getRequestedBy();
        this.startTimestamp = System.currentTimeMillis();
        this.status = TestStatus.RUNNING;
    }
    
    /**
     * Adds a test case result to the execution result.
     * 
     * @param testCaseResult The test case result to add
     */
    public void addTestCaseResult(TestCaseResult testCaseResult) {
        if (testCaseResult != null) {
            this.testCaseResults.add(testCaseResult);
            updateMetrics();
        }
    }
    
    /**
     * Updates the execution status based on the individual test case results.
     */
    public void updateStatus() {
        if (testCaseResults.isEmpty()) {
            // No test results yet, maintain current status
            return;
        }
        
        // Check if any test is still running
        boolean anyRunning = false;
        boolean anyFailed = false;
        boolean anySkipped = false;
        
        for (TestCaseResult result : testCaseResults) {
            switch (result.getStatus()) {
                case RUNNING:
                    anyRunning = true;
                    break;
                case FAILED:
                case ERROR:
                    anyFailed = true;
                    break;
                case SKIPPED:
                    anySkipped = true;
                    break;
            }
        }
        
        // Determine overall status
        if (anyRunning) {
            this.status = TestStatus.RUNNING;
        } else if (anyFailed) {
            this.status = TestStatus.FAILED;
        } else if (anySkipped && testCaseResults.size() == anySkipped) {
            this.status = TestStatus.SKIPPED; // All tests were skipped
        } else {
            this.status = TestStatus.PASSED; // All tests passed
        }
    }
    
    /**
     * Updates metrics based on the current test case results.
     */
    public void updateMetrics() {
        int total = testCaseResults.size();
        int passed = 0;
        int failed = 0;
        int skipped = 0;
        int running = 0;
        int error = 0;
        
        long totalDuration = 0;
        
        for (TestCaseResult result : testCaseResults) {
            switch (result.getStatus()) {
                case PASSED:
                    passed++;
                    break;
                case FAILED:
                    failed++;
                    break;
                case SKIPPED:
                    skipped++;
                    break;
                case RUNNING:
                    running++;
                    break;
                case ERROR:
                    error++;
                    break;
            }
            
            totalDuration += result.getDurationMs();
        }
        
        // Update metrics map
        metrics.put("total", total);
        metrics.put("passed", passed);
        metrics.put("failed", failed);
        metrics.put("skipped", skipped);
        metrics.put("running", running);
        metrics.put("error", error);
        
        // Calculate pass/fail percentages if there are completed tests
        int completed = passed + failed + error;
        if (completed > 0) {
            double passRate = (double) passed / completed * 100.0;
            double failRate = (double) (failed + error) / completed * 100.0;
            
            metrics.put("passRate", Math.round(passRate * 100.0) / 100.0); // Round to 2 decimal places
            metrics.put("failRate", Math.round(failRate * 100.0) / 100.0); // Round to 2 decimal places
        }
        
        // Update total duration
        this.durationMs = totalDuration;
        metrics.put("durationMs", durationMs);
        
        // Calculate average duration if there are completed tests
        if (completed > 0) {
            double avgDuration = (double) totalDuration / completed;
            metrics.put("avgDurationMs", Math.round(avgDuration));
        }
    }
    
    /**
     * Marks the execution as complete, updating all status information and timestamps.
     */
    public void markComplete() {
        this.endTimestamp = System.currentTimeMillis();
        this.durationMs = endTimestamp - startTimestamp;
        
        updateStatus();
        updateMetrics();
        
        // If status is still RUNNING, set it to ERROR as the execution is now complete
        if (this.status == TestStatus.RUNNING) {
            this.status = TestStatus.ERROR;
        }
    }
    
    /**
     * Marks the execution as failed with an error message.
     * 
     * @param errorMessage The error message
     */
    public void markFailed(String errorMessage) {
        this.endTimestamp = System.currentTimeMillis();
        this.durationMs = endTimestamp - startTimestamp;
        this.status = TestStatus.ERROR;
        this.error = errorMessage;
        
        updateMetrics();
    }
    
    /**
     * Gets a specific metric by name.
     * 
     * @param metricName The name of the metric
     * @return The metric value, or null if not found
     */
    public Object getMetric(String metricName) {
        return metrics.get(metricName);
    }
    
    /**
     * Gets a specific metric as a double value.
     * 
     * @param metricName The name of the metric
     * @param defaultValue The default value to return if the metric is not found or not a number
     * @return The metric value as a double
     */
    public double getMetricAsDouble(String metricName, double defaultValue) {
        Object value = metrics.get(metricName);
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        return defaultValue;
    }
    
    /**
     * Gets a specific metric as an integer value.
     * 
     * @param metricName The name of the metric
     * @param defaultValue The default value to return if the metric is not found or not a number
     * @return The metric value as an integer
     */
    public int getMetricAsInt(String metricName, int defaultValue) {
        Object value = metrics.get(metricName);
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        return defaultValue;
    }
    
    /**
     * Adds a custom metric to the execution result.
     * 
     * @param metricName The name of the metric
     * @param value The metric value
     */
    public void addCustomMetric(String metricName, Object value) {
        if (metricName != null && !metricName.isEmpty()) {
            metrics.put(metricName, value);
        }
    }
    
    /**
     * Returns true if the execution was successful (all tests passed).
     * 
     * @return true if the execution was successful, false otherwise
     */
    public boolean isSuccessful() {
        return status == TestStatus.PASSED;
    }
    
    /**
     * Returns true if the execution is still running.
     * 
     * @return true if the execution is still running, false otherwise
     */
    public boolean isRunning() {
        return status == TestStatus.RUNNING;
    }
    
    /**
     * Returns a string representation of the execution result.
     * 
     * @return String representation
     */
    @Override
    public String toString() {
        updateMetrics(); // Ensure metrics are up to date
        
        StringBuilder sb = new StringBuilder("TestExecutionResult{");
        sb.append("executionId='").append(executionId).append('\'');
        sb.append(", status=").append(status);
        sb.append(", tests=").append(testCaseResults.size());
        
        int passed = getMetricAsInt("passed", 0);
        int failed = getMetricAsInt("failed", 0);
        int skipped = getMetricAsInt("skipped", 0);
        
        sb.append(" (").append(passed).append(" passed, ")
          .append(failed).append(" failed, ")
          .append(skipped).append(" skipped)");
        
        double passRate = getMetricAsDouble("passRate", 0.0);
        sb.append(", passRate=").append(passRate).append("%");
        
        sb.append(", duration=").append(formatDuration(durationMs));
        sb.append('}');
        
        return sb.toString();
    }
    
    /**
     * Formats a duration in milliseconds as a human-readable string.
     * 
     * @param durationMs Duration in milliseconds
     * @return Formatted duration string
     */
    private String formatDuration(long durationMs) {
        long seconds = durationMs / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        
        seconds %= 60;
        minutes %= 60;
        
        if (hours > 0) {
            return String.format("%dh %dm %ds", hours, minutes, seconds);
        } else if (minutes > 0) {
            return String.format("%dm %ds", minutes, seconds);
        } else {
            return String.format("%ds", seconds);
        }
    }
    
    /**
     * Inner class representing the result of a single test case execution.
     */
    public static class TestCaseResult {
        private String testCaseId;
        private String testCaseName;
        private TestStatus status;
        private long startTimestamp;
        private long endTimestamp;
        private long durationMs;
        private String errorMessage;
        private String stackTrace;
        private List<String> screenshots = new ArrayList<>();
        private List<TestLog> logs = new ArrayList<>();
        private Map<String, Object> metadata = new HashMap<>();
        
        /**
         * Default constructor.
         */
        public TestCaseResult() {
            this.startTimestamp = System.currentTimeMillis();
            this.status = TestStatus.RUNNING;
        }
        
        /**
         * Constructor with test case ID and name.
         * 
         * @param testCaseId The test case identifier
         * @param testCaseName The test case name
         */
        public TestCaseResult(String testCaseId, String testCaseName) {
            this.testCaseId = testCaseId;
            this.testCaseName = testCaseName;
            this.startTimestamp = System.currentTimeMillis();
            this.status = TestStatus.RUNNING;
        }
        
        /**
         * Marks the test case as complete with the specified status.
         * 
         * @param status The final test status
         */
        public void markComplete(TestStatus status) {
            this.endTimestamp = System.currentTimeMillis();
            this.durationMs = endTimestamp - startTimestamp;
            this.status = status;
        }
        
        /**
         * Marks the test case as failed with an error message.
         * 
         * @param errorMessage The error message
         * @param stackTrace The stack trace
         */
        public void markFailed(String errorMessage, String stackTrace) {
            this.endTimestamp = System.currentTimeMillis();
            this.durationMs = endTimestamp - startTimestamp;
            this.status = TestStatus.FAILED;
            this.errorMessage = errorMessage;
            this.stackTrace = stackTrace;
        }
        
        /**
         * Marks the test case as having an error with an error message.
         * 
         * @param errorMessage The error message
         * @param stackTrace The stack trace
         */
        public void markError(String errorMessage, String stackTrace) {
            this.endTimestamp = System.currentTimeMillis();
            this.durationMs = endTimestamp - startTimestamp;
            this.status = TestStatus.ERROR;
            this.errorMessage = errorMessage;
            this.stackTrace = stackTrace;
        }
        
        /**
         * Adds a log entry to the test case result.
         * 
         * @param log The log entry
         */
        public void addLog(TestLog log) {
            if (log != null) {
                this.logs.add(log);
            }
        }
        
        /**
         * Adds a screenshot path to the test case result.
         * 
         * @param screenshotPath The path to the screenshot
         */
        public void addScreenshot(String screenshotPath) {
            if (screenshotPath != null && !screenshotPath.isEmpty()) {
                this.screenshots.add(screenshotPath);
            }
        }
        
        /**
         * Adds a metadata entry to the test case result.
         * 
         * @param key The metadata key
         * @param value The metadata value
         */
        public void addMetadata(String key, Object value) {
            if (key != null && !key.isEmpty()) {
                this.metadata.put(key, value);
            }
        }
        
        /**
         * Returns a string representation of the test case result.
         * 
         * @return String representation
         */
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder("TestCaseResult{");
            sb.append("id='").append(testCaseId).append('\'');
            if (testCaseName != null && !testCaseName.isEmpty()) {
                sb.append(", name='").append(testCaseName).append('\'');
            }
            sb.append(", status=").append(status);
            sb.append(", duration=").append(durationMs).append("ms");
            
            if (errorMessage != null && !errorMessage.isEmpty()) {
                // Truncate long error messages
                String error = errorMessage.length() > 100 ? 
                    errorMessage.substring(0, 97) + "..." : errorMessage;
                sb.append(", error='").append(error).append('\'');
            }
            
            sb.append(", logs=").append(logs.size());
            sb.append(", screenshots=").append(screenshots.size());
            sb.append('}');
            
            return sb.toString();
        }
        
        // Getters and Setters
        
        public String getTestCaseId() {
            return testCaseId;
        }
        
        public void setTestCaseId(String testCaseId) {
            this.testCaseId = testCaseId;
        }
        
        public String getTestCaseName() {
            return testCaseName;
        }
        
        public void setTestCaseName(String testCaseName) {
            this.testCaseName = testCaseName;
        }
        
        public TestStatus getStatus() {
            return status;
        }
        
        public void setStatus(TestStatus status) {
            this.status = status;
        }
        
        public long getStartTimestamp() {
            return startTimestamp;
        }
        
        public void setStartTimestamp(long startTimestamp) {
            this.startTimestamp = startTimestamp;
        }
        
        public long getEndTimestamp() {
            return endTimestamp;
        }
        
        public void setEndTimestamp(long endTimestamp) {
            this.endTimestamp = endTimestamp;
            
            // Update duration if both timestamps are available
            if (startTimestamp > 0 && endTimestamp > 0) {
                this.durationMs = endTimestamp - startTimestamp;
            }
        }
        
        public long getDurationMs() {
            return durationMs;
        }
        
        public void setDurationMs(long durationMs) {
            this.durationMs = durationMs;
        }
        
        public String getErrorMessage() {
            return errorMessage;
        }
        
        public void setErrorMessage(String errorMessage) {
            this.errorMessage = errorMessage;
        }
        
        public String getStackTrace() {
            return stackTrace;
        }
        
        public void setStackTrace(String stackTrace) {
            this.stackTrace = stackTrace;
        }
        
        public List<String> getScreenshots() {
            return screenshots;
        }
        
        public void setScreenshots(List<String> screenshots) {
            this.screenshots = screenshots != null ? screenshots : new ArrayList<>();
        }
        
        public List<TestLog> getLogs() {
            return logs;
        }
        
        public void setLogs(List<TestLog> logs) {
            this.logs = logs != null ? logs : new ArrayList<>();
        }
        
        public Map<String, Object> getMetadata() {
            return metadata;
        }
        
        public void setMetadata(Map<String, Object> metadata) {
            this.metadata = metadata != null ? metadata : new HashMap<>();
        }
        
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            
            TestCaseResult that = (TestCaseResult) o;
            
            return Objects.equals(testCaseId, that.testCaseId);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(testCaseId);
        }
    }
    
    // Getters and Setters
    
    public String getExecutionId() {
        return executionId;
    }
    
    public void setExecutionId(String executionId) {
        this.executionId = executionId;
    }
    
    public String getProjectId() {
        return projectId;
    }
    
    public void setProjectId(String projectId) {
        this.projectId = projectId;
    }
    
    public String getTestSuiteId() {
        return testSuiteId;
    }
    
    public void setTestSuiteId(String testSuiteId) {
        this.testSuiteId = testSuiteId;
    }
    
    public TestStatus getStatus() {
        return status;
    }
    
    public void setStatus(TestStatus status) {
        this.status = status;
    }
    
    public List<TestCaseResult> getTestCaseResults() {
        return testCaseResults;
    }
    
    public void setTestCaseResults(List<TestCaseResult> testCaseResults) {
        this.testCaseResults = testCaseResults != null ? testCaseResults : new ArrayList<>();
        updateMetrics();
    }
    
    public long getDurationMs() {
        return durationMs;
    }
    
    public void setDurationMs(long durationMs) {
        this.durationMs = durationMs;
        metrics.put("durationMs", durationMs);
    }
    
    public long getStartTimestamp() {
        return startTimestamp;
    }
    
    public void setStartTimestamp(long startTimestamp) {
        this.startTimestamp = startTimestamp;
    }
    
    public long getEndTimestamp() {
        return endTimestamp;
    }
    
    public void setEndTimestamp(long endTimestamp) {
        this.endTimestamp = endTimestamp;
        
        // Update duration if both timestamps are available
        if (startTimestamp > 0 && endTimestamp > 0) {
            this.durationMs = endTimestamp - startTimestamp;
            metrics.put("durationMs", durationMs);
        }
    }
    
    public Map<String, Object> getMetrics() {
        return metrics;
    }
    
    public void setMetrics(Map<String, Object> metrics) {
        this.metrics = metrics != null ? metrics : new HashMap<>();
    }
    
    public String getLogPath() {
        return logPath;
    }
    
    public void setLogPath(String logPath) {
        this.logPath = logPath;
    }
    
    public String getReportPath() {
        return reportPath;
    }
    
    public void setReportPath(String reportPath) {
        this.reportPath = reportPath;
    }
    
    public String getVideoPath() {
        return videoPath;
    }
    
    public void setVideoPath(String videoPath) {
        this.videoPath = videoPath;
    }
    
    public ExecutionEnvironment getEnvironment() {
        return environment;
    }
    
    public void setEnvironment(ExecutionEnvironment environment) {
        this.environment = environment;
    }
    
    public ResourceMetrics getResourceMetrics() {
        return resourceMetrics;
    }
    
    public void setResourceMetrics(ResourceMetrics resourceMetrics) {
        this.resourceMetrics = resourceMetrics;
    }
    
    public String getRequestedBy() {
        return requestedBy;
    }
    
    public void setRequestedBy(String requestedBy) {
        this.requestedBy = requestedBy;
    }
    
    public String getExecutedOn() {
        return executedOn;
    }
    
    public void setExecutedOn(String executedOn) {
        this.executedOn = executedOn;
    }
    
    public String getError() {
        return error;
    }
    
    public void setError(String error) {
        this.error = error;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        TestExecutionResult that = (TestExecutionResult) o;
        
        return Objects.equals(executionId, that.executionId);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(executionId);
    }
}



TestStatus.java
---------------------------

package com.cstestforge.model.execution;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.HashMap;
import java.util.Map;

/**
 * Enumeration of possible test execution statuses.
 * This enum is used to represent the status of both individual test cases
 * and overall test executions.
 */
public enum TestStatus {
    /**
     * Test is currently running.
     */
    RUNNING("running"),
    
    /**
     * Test has passed successfully.
     */
    PASSED("passed"),
    
    /**
     * Test has failed due to an assertion failure.
     */
    FAILED("failed"),
    
    /**
     * Test was skipped and not executed.
     */
    SKIPPED("skipped"),
    
    /**
     * Test encountered an error during execution (not an assertion failure).
     */
    ERROR("error"),
    
    /**
     * Test was blocked from executing (e.g., by a dependency failure).
     */
    BLOCKED("blocked");
    
    private final String value;
    private static final Map<String, TestStatus> valueMap = new HashMap<>();
    
    static {
        for (TestStatus status : TestStatus.values()) {
            valueMap.put(status.value, status);
        }
    }
    
    /**
     * Constructor with string value.
     * 
     * @param value String representation of the status
     */
    TestStatus(String value) {
        this.value = value;
    }
    
    /**
     * Gets the string value of the status.
     * 
     * @return String representation
     */
    @JsonValue
    public String getValue() {
        return value;
    }
    
    /**
     * Creates a TestStatus from a string value.
     * 
     * @param value String representation
     * @return TestStatus enum value, or null if not found
     */
    @JsonCreator
    public static TestStatus fromValue(String value) {
        if (value == null) {
            return null;
        }
        
        // Try direct lookup first
        TestStatus status = valueMap.get(value.toLowerCase());
        if (status != null) {
            return status;
        }
        
        // Fall back to case-insensitive comparison of enum names
        for (TestStatus s : TestStatus.values()) {
            if (s.name().equalsIgnoreCase(value)) {
                return s;
            }
        }
        
        // Default to ERROR for unknown statuses
        return ERROR;
    }
    
    /**
     * Checks if this status represents a terminal state (not running).
     * 
     * @return true if the status is terminal, false otherwise
     */
    public boolean isTerminal() {
        return this != RUNNING;
    }
    
    /**
     * Checks if this status represents a successful execution.
     * 
     * @return true if the status is successful, false otherwise
     */
    public boolean isSuccessful() {
        return this == PASSED;
    }
    
    /**
     * Checks if this status represents a failed execution.
     * 
     * @return true if the status is a failure, false otherwise
     */
    public boolean isFailure() {
        return this == FAILED || this == ERROR;
    }
    
    /**
     * Checks if this status represents a skipped or blocked execution.
     * 
     * @return true if the status is skipped or blocked, false otherwise
     */
    public boolean isSkipped() {
        return this == SKIPPED || this == BLOCKED;
    }
    
    /**
     * Returns a color code representation of the status for UI display.
     * 
     * @return Hexadecimal color code
     */
    public String getColorCode() {
        switch (this) {
            case PASSED:
                return "#4CAF50"; // Green
            case FAILED:
                return "#F44336"; // Red
            case ERROR:
                return "#FF9800"; // Orange
            case SKIPPED:
                return "#9E9E9E"; // Gray
            case BLOCKED:
                return "#607D8B"; // Blue Gray
            case RUNNING:
                return "#2196F3"; // Blue
            default:
                return "#000000"; // Black
        }
    }
    
    /**
     * Returns a CSS class name representation of the status for UI display.
     * 
     * @return CSS class name
     */
    public String getCssClass() {
        return "status-" + value;
    }
    
    /**
     * Returns a descriptive label for the status.
     * 
     * @return Status label
     */
    public String getLabel() {
        switch (this) {
            case PASSED:
                return "Passed";
            case FAILED:
                return "Failed";
            case ERROR:
                return "Error";
            case SKIPPED:
                return "Skipped";
            case BLOCKED:
                return "Blocked";
            case RUNNING:
                return "Running";
            default:
                return name();
        }
    }
    
    /**
     * Returns the string representation of the status.
     * 
     * @return String representation
     */
    @Override
    public String toString() {
        return value;
    }
}


TestLog.java
---------------------

package com.cstestforge.model.execution;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Objects;

/**
 * Represents a log entry recorded during test execution.
 * This model contains information about a single log event,
 * including its timestamp, level, message, and associated test or step.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class TestLog {
    
    /**
     * Enumeration of log levels.
     */
    public enum LogLevel {
        TRACE("TRACE"),
        DEBUG("DEBUG"),
        INFO("INFO"),
        WARN("WARN"),
        ERROR("ERROR"),
        FATAL("FATAL");
        
        private final String value;
        
        LogLevel(String value) {
            this.value = value;
        }
        
        @Override
        public String toString() {
            return value;
        }
    }
    
    /**
     * Timestamp when the log was recorded.
     */
    private long timestamp;
    
    /**
     * Level of the log message.
     */
    private LogLevel level;
    
    /**
     * The log message.
     */
    private String message;
    
    /**
     * An optional exception stack trace associated with the log.
     */
    private String stackTrace;
    
    /**
     * The execution ID associated with this log.
     */
    private String executionId;
    
    /**
     * The test case ID associated with this log.
     */
    private String testCaseId;
    
    /**
     * The test step ID associated with this log, if applicable.
     */
    private String testStepId;
    
    /**
     * The source of the log (class or component name).
     */
    private String source;
    
    /**
     * The thread name that generated the log.
     */
    private String threadName;
    
    /**
     * Default constructor.
     */
    public TestLog() {
        this.timestamp = System.currentTimeMillis();
    }
    
    /**
     * Constructor with level and message.
     * 
     * @param level The log level
     * @param message The log message
     */
    public TestLog(LogLevel level, String message) {
        this.timestamp = System.currentTimeMillis();
        this.level = level;
        this.message = message;
    }
    
    /**
     * Constructor with level, message, and test case ID.
     * 
     * @param level The log level
     * @param message The log message
     * @param testCaseId The test case identifier
     */
    public TestLog(LogLevel level, String message, String testCaseId) {
        this.timestamp = System.currentTimeMillis();
        this.level = level;
        this.message = message;
        this.testCaseId = testCaseId;
    }
    
    /**
     * Constructor with level, message, test case ID, and execution ID.
     * 
     * @param level The log level
     * @param message The log message
     * @param testCaseId The test case identifier
     * @param executionId The execution identifier
     */
    public TestLog(LogLevel level, String message, String testCaseId, String executionId) {
        this.timestamp = System.currentTimeMillis();
        this.level = level;
        this.message = message;
        this.testCaseId = testCaseId;
        this.executionId = executionId;
    }
    
    /**
     * Constructor with all fields.
     * 
     * @param level The log level
     * @param message The log message
     * @param stackTrace The stack trace
     * @param testCaseId The test case identifier
     * @param testStepId The test step identifier
     * @param executionId The execution identifier
     * @param source The log source
     * @param threadName The thread name
     */
    public TestLog(LogLevel level, String message, String stackTrace, String testCaseId, 
                   String testStepId, String executionId, String source, String threadName) {
        this.timestamp = System.currentTimeMillis();
        this.level = level;
        this.message = message;
        this.stackTrace = stackTrace;
        this.testCaseId = testCaseId;
        this.testStepId = testStepId;
        this.executionId = executionId;
        this.source = source;
        this.threadName = threadName;
    }
    
    /**
     * Creates a new trace level log.
     * 
     * @param message The log message
     * @return A new TestLog instance
     */
    public static TestLog trace(String message) {
        return new TestLog(LogLevel.TRACE, message);
    }
    
    /**
     * Creates a new debug level log.
     * 
     * @param message The log message
     * @return A new TestLog instance
     */
    public static TestLog debug(String message) {
        return new TestLog(LogLevel.DEBUG, message);
    }
    
    /**
     * Creates a new info level log.
     * 
     * @param message The log message
     * @return A new TestLog instance
     */
    public static TestLog info(String message) {
        return new TestLog(LogLevel.INFO, message);
    }
    
    /**
     * Creates a new warn level log.
     * 
     * @param message The log message
     * @return A new TestLog instance
     */
    public static TestLog warn(String message) {
        return new TestLog(LogLevel.WARN, message);
    }
    
    /**
     * Creates a new error level log.
     * 
     * @param message The log message
     * @return A new TestLog instance
     */
    public static TestLog error(String message) {
        return new TestLog(LogLevel.ERROR, message);
    }
    
    /**
     * Creates a new error level log with a stack trace.
     * 
     * @param message The log message
     * @param e The exception
     * @return A new TestLog instance
     */
    public static TestLog error(String message, Throwable e) {
        TestLog log = new TestLog(LogLevel.ERROR, message);
        if (e != null) {
            StringBuilder stackTrace = new StringBuilder();
            stackTrace.append(e.toString()).append("\n");
            
            for (StackTraceElement element : e.getStackTrace()) {
                stackTrace.append("\tat ").append(element.toString()).append("\n");
            }
            
            log.setStackTrace(stackTrace.toString());
        }
        return log;
    }
    
    /**
     * Creates a new fatal level log.
     * 
     * @param message The log message
     * @return A new TestLog instance
     */
    public static TestLog fatal(String message) {
        return new TestLog(LogLevel.FATAL, message);
    }
    
    /**
     * Creates a new fatal level log with a stack trace.
     * 
     * @param message The log message
     * @param e The exception
     * @return A new TestLog instance
     */
    public static TestLog fatal(String message, Throwable e) {
        TestLog log = new TestLog(LogLevel.FATAL, message);
        if (e != null) {
            StringBuilder stackTrace = new StringBuilder();
            stackTrace.append(e.toString()).append("\n");
            
            for (StackTraceElement element : e.getStackTrace()) {
                stackTrace.append("\tat ").append(element.toString()).append("\n");
            }
            
            log.setStackTrace(stackTrace.toString());
        }
        return log;
    }
    
    /**
     * Returns a formatted timestamp string.
     * 
     * @return Formatted timestamp string
     */
    public String getFormattedTimestamp() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
        return sdf.format(new Date(timestamp));
    }
    
    /**
     * Returns a formatted log entry string.
     * 
     * @return Formatted log entry
     */
    public String getFormattedLog() {
        StringBuilder sb = new StringBuilder();
        sb.append(getFormattedTimestamp())
          .append(" [").append(level).append("]");
        
        if (threadName != null && !threadName.isEmpty()) {
            sb.append(" [").append(threadName).append("]");
        }
        
        if (source != null && !source.isEmpty()) {
            sb.append(" [").append(source).append("]");
        }
        
        sb.append(": ").append(message);
        
        if (testCaseId != null && !testCaseId.isEmpty()) {
            sb.append(" (Test: ").append(testCaseId);
            
            if (testStepId != null && !testStepId.isEmpty()) {
                sb.append(", Step: ").append(testStepId);
            }
            
            sb.append(")");
        }
        
        if (stackTrace != null && !stackTrace.isEmpty()) {
            sb.append("\n").append(stackTrace);
        }
        
        return sb.toString();
    }
    
    /**
     * Returns the color code for this log level.
     * 
     * @return Hexadecimal color code
     */
    public String getLevelColor() {
        switch (level) {
            case TRACE:
                return "#9E9E9E"; // Gray
            case DEBUG:
                return "#2196F3"; // Blue
            case INFO:
                return "#4CAF50"; // Green
            case WARN:
                return "#FF9800"; // Orange
            case ERROR:
                return "#F44336"; // Red
            case FATAL:
                return "#9C27B0"; // Purple
            default:
                return "#000000"; // Black
        }
    }
    
    /**
     * Checks if this log is at or above the specified level.
     * 
     * @param level The log level to check against
     * @return true if this log is at or above the specified level, false otherwise
     */
    public boolean isLevelAtLeast(LogLevel level) {
        return this.level.ordinal() >= level.ordinal();
    }
    
    /**
     * Returns a string representation of the log.
     * 
     * @return String representation
     */
    @Override
    public String toString() {
        return getFormattedLog();
    }
    
    /**
     * Compares this log with another object for equality.
     * 
     * @param o The object to compare with
     * @return true if the objects are equal, false otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        TestLog testLog = (TestLog) o;
        
        if (timestamp != testLog.timestamp) return false;
        if (level != testLog.level) return false;
        if (!Objects.equals(message, testLog.message)) return false;
        if (!Objects.equals(testCaseId, testLog.testCaseId)) return false;
        if (!Objects.equals(testStepId, testLog.testStepId)) return false;
        return Objects.equals(executionId, testLog.executionId);
    }
    
    /**
     * Returns a hash code for this log.
     * 
     * @return Hash code
     */
    @Override
    public int hashCode() {
        int result = (int) (timestamp ^ (timestamp >>> 32));
        result = 31 * result + (level != null ? level.hashCode() : 0);
        result = 31 * result + (message != null ? message.hashCode() : 0);
        result = 31 * result + (testCaseId != null ? testCaseId.hashCode() : 0);
        result = 31 * result + (testStepId != null ? testStepId.hashCode() : 0);
        result = 31 * result + (executionId != null ? executionId.hashCode() : 0);
        return result;
    }
    
    // Getters and Setters
    
    public long getTimestamp() {
        return timestamp;
    }
    
    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
    
    public LogLevel getLevel() {
        return level;
    }
    
    public void setLevel(LogLevel level) {
        this.level = level;
    }
    
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public String getStackTrace() {
        return stackTrace;
    }
    
    public void setStackTrace(String stackTrace) {
        this.stackTrace = stackTrace;
    }
    
    public String getExecutionId() {
        return executionId;
    }
    
    public void setExecutionId(String executionId) {
        this.executionId = executionId;
    }
    
    public String getTestCaseId() {
        return testCaseId;
    }
    
    public void setTestCaseId(String testCaseId) {
        this.testCaseId = testCaseId;
    }
    
    public String getTestStepId() {
        return testStepId;
    }
    
    public void setTestStepId(String testStepId) {
        this.testStepId = testStepId;
    }
    
    public String getSource() {
        return source;
    }
    
    public void setSource(String source) {
        this.source = source;
    }
    
    public String getThreadName() {
        return threadName;
    }
    
    public void setThreadName(String threadName) {
        this.threadName = threadName;
    }
}


ExecutionEnvironment.java
----------------------------------

package com.cstestforge.model.execution;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Represents the environment configuration for test execution.
 * This model contains information about the execution environment,
 * including URLs, credentials, browser settings, and other configuration.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ExecutionEnvironment {
    
    /**
     * Enumeration of browser types.
     */
    public enum BrowserType {
        CHROME("chrome"),
        FIREFOX("firefox"),
        EDGE("edge"),
        SAFARI("safari"),
        IE("ie");
        
        private final String value;
        
        BrowserType(String value) {
            this.value = value;
        }
        
        @Override
        public String toString() {
            return value;
        }
        
        public static BrowserType fromString(String value) {
            for (BrowserType type : BrowserType.values()) {
                if (type.value.equalsIgnoreCase(value)) {
                    return type;
                }
            }
            return CHROME; // Default to Chrome
        }
    }
    
    /**
     * Enumeration of platform types.
     */
    public enum PlatformType {
        WINDOWS("windows"),
        MAC("mac"),
        LINUX("linux"),
        ANDROID("android"),
        IOS("ios");
        
        private final String value;
        
        PlatformType(String value) {
            this.value = value;
        }
        
        @Override
        public String toString() {
            return value;
        }
        
        public static PlatformType fromString(String value) {
            for (PlatformType type : PlatformType.values()) {
                if (type.value.equalsIgnoreCase(value)) {
                    return type;
                }
            }
            return WINDOWS; // Default to Windows
        }
    }
    
    /**
     * Environment name (e.g., "qa", "staging", "production").
     */
    private String name;
    
    /**
     * Base URL for the application under test.
     */
    private String baseUrl;
    
    /**
     * API base URL for the application under test.
     */
    private String apiBaseUrl;
    
    /**
     * Browser type to use for testing.
     */
    private BrowserType browserType = BrowserType.CHROME;
    
    /**
     * Browser version to use for testing.
     */
    private String browserVersion;
    
    /**
     * Platform type to use for testing.
     */
    private PlatformType platformType = PlatformType.WINDOWS;
    
    /**
     * Platform version to use for testing.
     */
    private String platformVersion;
    
    /**
     * Browser window width.
     */
    private int browserWidth = 1366;
    
    /**
     * Browser window height.
     */
    private int browserHeight = 768;
    
    /**
     * Flag to run tests in headless mode.
     */
    private boolean headless = false;
    
    /**
     * Username for the application under test.
     */
    private String username;
    
    /**
     * Password for the application under test.
     */
    private String password;
    
    /**
     * API key for the application under test.
     */
    private String apiKey;
    
    /**
     * Authentication token for the application under test.
     */
    private String authToken;
    
    /**
     * Proxy settings for the browser.
     */
    private String proxy;
    
    /**
     * Flag to enable network throttling.
     */
    private boolean networkThrottling = false;
    
    /**
     * Network download speed in Kbps when throttling is enabled.
     */
    private int networkDownloadKbps = 5000;
    
    /**
     * Network upload speed in Kbps when throttling is enabled.
     */
    private int networkUploadKbps = 2000;
    
    /**
     * Network latency in ms when throttling is enabled.
     */
    private int networkLatencyMs = 20;
    
    /**
     * Browser user agent string.
     */
    private String userAgent;
    
    /**
     * Flag to enable browser incognito/private mode.
     */
    private boolean incognito = false;
    
    /**
     * Browser extensions to install.
     */
    private List<String> extensions = new ArrayList<>();
    
    /**
     * Browser command-line arguments.
     */
    private List<String> browserArgs = new ArrayList<>();
    
    /**
     * Environment variables for the test execution.
     */
    private Map<String, String> environmentVariables = new HashMap<>();
    
    /**
     * Additional capabilities for the browser.
     */
    private Map<String, Object> additionalCapabilities = new HashMap<>();
    
    /**
     * Default constructor.
     */
    public ExecutionEnvironment() {
    }
    
    /**
     * Constructor with environment name.
     * 
     * @param name The environment name
     */
    public ExecutionEnvironment(String name) {
        this.name = name;
    }
    
    /**
     * Constructor with environment name and base URL.
     * 
     * @param name The environment name
     * @param baseUrl The base URL
     */
    public ExecutionEnvironment(String name, String baseUrl) {
        this.name = name;
        this.baseUrl = baseUrl;
    }
    
    /**
     * Constructor with environment name, base URL, and browser type.
     * 
     * @param name The environment name
     * @param baseUrl The base URL
     * @param browserType The browser type
     */
    public ExecutionEnvironment(String name, String baseUrl, BrowserType browserType) {
        this.name = name;
        this.baseUrl = baseUrl;
        this.browserType = browserType;
    }
    
    /**
     * Constructor with environment name, base URL, browser type, and platform type.
     * 
     * @param name The environment name
     * @param baseUrl The base URL
     * @param browserType The browser type
     * @param platformType The platform type
     */
    public ExecutionEnvironment(String name, String baseUrl, BrowserType browserType, PlatformType platformType) {
        this.name = name;
        this.baseUrl = baseUrl;
        this.browserType = browserType;
        this.platformType = platformType;
    }
    
    /**
     * Adds an environment variable to the execution environment.
     * 
     * @param key Environment variable name
     * @param value Environment variable value
     */
    public void addEnvironmentVariable(String key, String value) {
        if (key != null && !key.isEmpty()) {
            environmentVariables.put(key, value);
        }
    }
    
    /**
     * Adds a browser extension to the execution environment.
     * 
     * @param extension Browser extension path or ID
     */
    public void addExtension(String extension) {
        if (extension != null && !extension.isEmpty()) {
            extensions.add(extension);
        }
    }
    
    /**
     * Adds a browser command-line argument to the execution environment.
     * 
     * @param arg Browser command-line argument
     */
    public void addBrowserArg(String arg) {
        if (arg != null && !arg.isEmpty()) {
            browserArgs.add(arg);
        }
    }
    
    /**
     * Adds an additional capability to the execution environment.
     * 
     * @param key Capability name
     * @param value Capability value
     */
    public void addCapability(String key, Object value) {
        if (key != null && !key.isEmpty()) {
            additionalCapabilities.put(key, value);
        }
    }
    
    /**
     * Returns a string representation of the execution environment.
     * 
     * @return String representation
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("ExecutionEnvironment{");
        sb.append("name='").append(name).append('\'');
        
        if (baseUrl != null && !baseUrl.isEmpty()) {
            sb.append(", baseUrl='").append(baseUrl).append('\'');
        }
        
        sb.append(", browser=").append(browserType);
        
        if (browserVersion != null && !browserVersion.isEmpty()) {
            sb.append(" ").append(browserVersion);
        }
        
        sb.append(", platform=").append(platformType);
        
        if (platformVersion != null && !platformVersion.isEmpty()) {
            sb.append(" ").append(platformVersion);
        }
        
        if (headless) {
            sb.append(", headless=true");
        }
        
        sb.append(", resolution=").append(browserWidth).append("x").append(browserHeight);
        
        sb.append('}');
        
        return sb.toString();
    }
    
    /**
     * Compares this environment with another object for equality.
     * 
     * @param o The object to compare with
     * @return true if the objects are equal, false otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        ExecutionEnvironment that = (ExecutionEnvironment) o;
        
        if (browserWidth != that.browserWidth) return false;
        if (browserHeight != that.browserHeight) return false;
        if (headless != that.headless) return false;
        if (networkThrottling != that.networkThrottling) return false;
        if (networkDownloadKbps != that.networkDownloadKbps) return false;
        if (networkUploadKbps != that.networkUploadKbps) return false;
        if (networkLatencyMs != that.networkLatencyMs) return false;
        if (incognito != that.incognito) return false;
        if (!Objects.equals(name, that.name)) return false;
        if (!Objects.equals(baseUrl, that.baseUrl)) return false;
        if (!Objects.equals(apiBaseUrl, that.apiBaseUrl)) return false;
        if (browserType != that.browserType) return false;
        if (!Objects.equals(browserVersion, that.browserVersion)) return false;
        if (platformType != that.platformType) return false;
        if (!Objects.equals(platformVersion, that.platformVersion)) return false;
        if (!Objects.equals(username, that.username)) return false;
        if (!Objects.equals(password, that.password)) return false;
        if (!Objects.equals(apiKey, that.apiKey)) return false;
        if (!Objects.equals(authToken, that.authToken)) return false;
        if (!Objects.equals(proxy, that.proxy)) return false;
        if (!Objects.equals(userAgent, that.userAgent)) return false;
        if (!Objects.equals(extensions, that.extensions)) return false;
        if (!Objects.equals(browserArgs, that.browserArgs)) return false;
        if (!Objects.equals(environmentVariables, that.environmentVariables)) return false;
        return Objects.equals(additionalCapabilities, that.additionalCapabilities);
    }
    
    /**
     * Returns a hash code for this environment.
     * 
     * @return Hash code
     */
    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + (baseUrl != null ? baseUrl.hashCode() : 0);
        result = 31 * result + (apiBaseUrl != null ? apiBaseUrl.hashCode() : 0);
        result = 31 * result + (browserType != null ? browserType.hashCode() : 0);
        result = 31 * result + (browserVersion != null ? browserVersion.hashCode() : 0);
        result = 31 * result + (platformType != null ? platformType.hashCode() : 0);
        result = 31 * result + (platformVersion != null ? platformVersion.hashCode() : 0);
        result = 31 * result + browserWidth;
        result = 31 * result + browserHeight;
        result = 31 * result + (headless ? 1 : 0);
        result = 31 * result + (username != null ? username.hashCode() : 0);
        result = 31 * result + (password != null ? password.hashCode() : 0);
        result = 31 * result + (apiKey != null ? apiKey.hashCode() : 0);
        result = 31 * result + (authToken != null ? authToken.hashCode() : 0);
        result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
        result = 31 * result + (networkThrottling ? 1 : 0);
        result = 31 * result + networkDownloadKbps;
        result = 31 * result + networkUploadKbps;
        result = 31 * result + networkLatencyMs;
        result = 31 * result + (userAgent != null ? userAgent.hashCode() : 0);
        result = 31 * result + (incognito ? 1 : 0);
        result = 31 * result + (extensions != null ? extensions.hashCode() : 0);
        result = 31 * result + (browserArgs != null ? browserArgs.hashCode() : 0);
        result = 31 * result + (environmentVariables != null ? environmentVariables.hashCode() : 0);
        result = 31 * result + (additionalCapabilities != null ? additionalCapabilities.hashCode() : 0);
        return result;
    }
    
    // Getters and Setters
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getBaseUrl() {
        return baseUrl;
    }
    
    public void setBaseUrl(String baseUrl) {
        this.baseUrl = baseUrl;
    }
    
    public String getApiBaseUrl() {
        return apiBaseUrl;
    }
    
    public void setApiBaseUrl(String apiBaseUrl) {
        this.apiBaseUrl = apiBaseUrl;
    }
    
    public BrowserType getBrowserType() {
        return browserType;
    }
    
    public void setBrowserType(BrowserType browserType) {
        this.browserType = browserType;
    }
    
    public String getBrowserVersion() {
        return browserVersion;
    }
    
    public void setBrowserVersion(String browserVersion) {
        this.browserVersion = browserVersion;
    }
    
    public PlatformType getPlatformType() {
        return platformType;
    }
    
    public void setPlatformType(PlatformType platformType) {
        this.platformType = platformType;
    }
    
    public String getPlatformVersion() {
        return platformVersion;
    }
    
    public void setPlatformVersion(String platformVersion) {
        this.platformVersion = platformVersion;
    }
    
    public int getBrowserWidth() {
        return browserWidth;
    }
    
    public void setBrowserWidth(int browserWidth) {
        this.browserWidth = browserWidth;
    }
    
    public int getBrowserHeight() {
        return browserHeight;
    }
    
    public void setBrowserHeight(int browserHeight) {
        this.browserHeight = browserHeight;
    }
    
    public boolean isHeadless() {
        return headless;
    }
    
    public void setHeadless(boolean headless) {
        this.headless = headless;
    }
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
    
    public String getApiKey() {
        return apiKey;
    }
    
    public void setApiKey(String apiKey) {
        this.apiKey = apiKey;
    }
    
    public String getAuthToken() {
        return authToken;
    }
    
    public void setAuthToken(String authToken) {
        this.authToken = authToken;
    }
    
    public String getProxy() {
        return proxy;
    }
    
    public void setProxy(String proxy) {
        this.proxy = proxy;
    }
    
    public boolean isNetworkThrottling() {
        return networkThrottling;
    }
    
    public void setNetworkThrottling(boolean networkThrottling) {
        this.networkThrottling = networkThrottling;
    }
    
    public int getNetworkDownloadKbps() {
        return networkDownloadKbps;
    }
    
    public void setNetworkDownloadKbps(int networkDownloadKbps) {
        this.networkDownloadKbps = networkDownloadKbps;
    }
    
    public int getNetworkUploadKbps() {
        return networkUploadKbps;
    }
    
    public void setNetworkUploadKbps(int networkUploadKbps) {
        this.networkUploadKbps = networkUploadKbps;
    }
    
    public int getNetworkLatencyMs() {
        return networkLatencyMs;
    }
    
    public void setNetworkLatencyMs(int networkLatencyMs) {
        this.networkLatencyMs = networkLatencyMs;
    }
    
    public String getUserAgent() {
        return userAgent;
    }
    
    public void setUserAgent(String userAgent) {
        this.userAgent = userAgent;
    }
    
    public boolean isIncognito() {
        return incognito;
    }
    
    public void setIncognito(boolean incognito) {
        this.incognito = incognito;
    }
    
    public List<String> getExtensions() {
        return extensions;
    }
    
    public void setExtensions(List<String> extensions) {
        this.extensions = extensions != null ? extensions : new ArrayList<>();
    }
    
    public List<String> getBrowserArgs() {
        return browserArgs;
    }
    
    public void setBrowserArgs(List<String> browserArgs) {
        this.browserArgs = browserArgs != null ? browserArgs : new ArrayList<>();
    }
    
    public Map<String, String> getEnvironmentVariables() {
        return environmentVariables;
    }
    
    public void setEnvironmentVariables(Map<String, String> environmentVariables) {
        this.environmentVariables = environmentVariables != null ? environmentVariables : new HashMap<>();
    }
    
    public Map<String, Object> getAdditionalCapabilities() {
        return additionalCapabilities;
    }
    
    public void setAdditionalCapabilities(Map<String, Object> additionalCapabilities) {
        this.additionalCapabilities = additionalCapabilities != null ? additionalCapabilities : new HashMap<>();
    }
}


ResourceMetrics.java
------------------------------

package com.cstestforge.model.execution;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Represents resource usage metrics collected during test execution.
 * This model tracks CPU, memory, disk, and network usage over time,
 * as well as browser-specific metrics for performance analysis.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ResourceMetrics {
    
    /**
     * The execution ID this metrics collection is associated with.
     */
    private String executionId;
    
    /**
     * Timestamp when metrics collection started.
     */
    private long startTimestamp;
    
    /**
     * Timestamp when metrics collection ended.
     */
    private long endTimestamp;
    
    /**
     * Sampling interval in milliseconds.
     */
    private long samplingIntervalMs;
    
    /**
     * Maximum CPU usage percentage observed.
     */
    private double maxCpuUsage;
    
    /**
     * Average CPU usage percentage.
     */
    private double avgCpuUsage;
    
    /**
     * CPU usage percentage over time.
     * Key: Timestamp, Value: CPU usage percentage
     */
    private Map<Long, Double> cpuUsageOverTime = new HashMap<>();
    
    /**
     * Maximum memory usage in megabytes observed.
     */
    private double maxMemoryUsageMb;
    
    /**
     * Average memory usage in megabytes.
     */
    private double avgMemoryUsageMb;
    
    /**
     * Memory usage in megabytes over time.
     * Key: Timestamp, Value: Memory usage in MB
     */
    private Map<Long, Double> memoryUsageOverTime = new HashMap<>();
    
    /**
     * Total disk read in megabytes.
     */
    private double totalDiskReadMb;
    
    /**
     * Total disk write in megabytes.
     */
    private double totalDiskWriteMb;
    
    /**
     * Disk usage operations over time.
     * Key: Timestamp, Value: Map with "read" and "write" keys (in MB/s)
     */
    private Map<Long, Map<String, Double>> diskUsageOverTime = new HashMap<>();
    
    /**
     * Total network received in megabytes.
     */
    private double totalNetworkReceivedMb;
    
    /**
     * Total network sent in megabytes.
     */
    private double totalNetworkSentMb;
    
    /**
     * Network usage over time.
     * Key: Timestamp, Value: Map with "received" and "sent" keys (in MB/s)
     */
    private Map<Long, Map<String, Double>> networkUsageOverTime = new HashMap<>();
    
    /**
     * Browser CPU usage percentage.
     */
    private double browserCpuUsage;
    
    /**
     * Browser memory usage in megabytes.
     */
    private double browserMemoryUsageMb;
    
    /**
     * Number of browser pages/tabs open.
     */
    private int browserPageCount;
    
    /**
     * Number of active browser connections.
     */
    private int browserConnectionCount;
    
    /**
     * Browser's JavaScript heap size in megabytes.
     */
    private double jsHeapSizeMb;
    
    /**
     * Browser metrics over time.
     * Key: Timestamp, Value: Map with browser metrics
     */
    private Map<Long, Map<String, Object>> browserMetricsOverTime = new HashMap<>();
    
    /**
     * Page load times in milliseconds.
     * Key: Page URL, Value: Load time in milliseconds
     */
    private Map<String, Long> pageLoadTimes = new HashMap<>();
    
    /**
     * List of slow resources loaded (over 1 second).
     */
    private List<SlowResource> slowResources = new ArrayList<>();
    
    /**
     * JavaScript errors encountered during execution.
     */
    private List<JsError> jsErrors = new ArrayList<>();
    
    /**
     * Performance timing marks in milliseconds.
     * Key: Mark name, Value: Time in milliseconds
     */
    private Map<String, Long> performanceMarks = new HashMap<>();
    
    /**
     * Performance timing measures in milliseconds.
     * Key: Measure name, Value: Duration in milliseconds
     */
    private Map<String, Long> performanceMeasures = new HashMap<>();
    
    /**
     * Additional metrics collected during execution.
     */
    private Map<String, Object> additionalMetrics = new HashMap<>();
    
    /**
     * Default constructor.
     */
    public ResourceMetrics() {
        this.startTimestamp = System.currentTimeMillis();
        this.samplingIntervalMs = 1000; // Default to 1 second
    }
    
    /**
     * Constructor with execution ID.
     * 
     * @param executionId The execution identifier
     */
    public ResourceMetrics(String executionId) {
        this.executionId = executionId;
        this.startTimestamp = System.currentTimeMillis();
        this.samplingIntervalMs = 1000; // Default to 1 second
    }
    
    /**
     * Constructor with execution ID and sampling interval.
     * 
     * @param executionId The execution identifier
     * @param samplingIntervalMs The sampling interval in milliseconds
     */
    public ResourceMetrics(String executionId, long samplingIntervalMs) {
        this.executionId = executionId;
        this.startTimestamp = System.currentTimeMillis();
        this.samplingIntervalMs = samplingIntervalMs;
    }
    
    /**
     * Records CPU usage at the current time.
     * 
     * @param cpuUsage CPU usage percentage (0-100)
     */
    public void recordCpuUsage(double cpuUsage) {
        long timestamp = System.currentTimeMillis();
        cpuUsageOverTime.put(timestamp, cpuUsage);
        
        if (cpuUsage > maxCpuUsage) {
            maxCpuUsage = cpuUsage;
        }
        
        // Recalculate average
        double sum = 0;
        for (Double usage : cpuUsageOverTime.values()) {
            sum += usage;
        }
        avgCpuUsage = sum / cpuUsageOverTime.size();
    }
    
    /**
     * Records memory usage at the current time.
     * 
     * @param memoryUsageMb Memory usage in megabytes
     */
    public void recordMemoryUsage(double memoryUsageMb) {
        long timestamp = System.currentTimeMillis();
        memoryUsageOverTime.put(timestamp, memoryUsageMb);
        
        if (memoryUsageMb > maxMemoryUsageMb) {
            maxMemoryUsageMb = memoryUsageMb;
        }
        
        // Recalculate average
        double sum = 0;
        for (Double usage : memoryUsageOverTime.values()) {
            sum += usage;
        }
        avgMemoryUsageMb = sum / memoryUsageOverTime.size();
    }
    
    /**
     * Records disk usage at the current time.
     * 
     * @param readMbps Disk read in megabytes per second
     * @param writeMbps Disk write in megabytes per second
     */
    public void recordDiskUsage(double readMbps, double writeMbps) {
        long timestamp = System.currentTimeMillis();
        long elapsedMs = timestamp - startTimestamp;
        
        // Convert MB/s to MB for this interval
        double intervalSeconds = samplingIntervalMs / 1000.0;
        double readMb = readMbps * intervalSeconds;
        double writeMb = writeMbps * intervalSeconds;
        
        // Update totals
        totalDiskReadMb += readMb;
        totalDiskWriteMb += writeMb;
        
        // Record point-in-time values
        Map<String, Double> diskMetrics = new HashMap<>();
        diskMetrics.put("read", readMbps);
        diskMetrics.put("write", writeMbps);
        diskUsageOverTime.put(timestamp, diskMetrics);
    }
    
    /**
     * Records network usage at the current time.
     * 
     * @param receivedMbps Network received in megabytes per second
     * @param sentMbps Network sent in megabytes per second
     */
    public void recordNetworkUsage(double receivedMbps, double sentMbps) {
        long timestamp = System.currentTimeMillis();
        long elapsedMs = timestamp - startTimestamp;
        
        // Convert MB/s to MB for this interval
        double intervalSeconds = samplingIntervalMs / 1000.0;
        double receivedMb = receivedMbps * intervalSeconds;
        double sentMb = sentMbps * intervalSeconds;
        
        // Update totals
        totalNetworkReceivedMb += receivedMb;
        totalNetworkSentMb += sentMb;
        
        // Record point-in-time values
        Map<String, Double> networkMetrics = new HashMap<>();
        networkMetrics.put("received", receivedMbps);
        networkMetrics.put("sent", sentMbps);
        networkUsageOverTime.put(timestamp, networkMetrics);
    }
    
    /**
     * Records browser metrics at the current time.
     * 
     * @param cpuUsage Browser CPU usage percentage
     * @param memoryUsageMb Browser memory usage in megabytes
     * @param pageCount Number of browser pages/tabs
     * @param connectionCount Number of active browser connections
     * @param jsHeapSizeMb JavaScript heap size in megabytes
     */
    public void recordBrowserMetrics(double cpuUsage, double memoryUsageMb, 
                                    int pageCount, int connectionCount, double jsHeapSizeMb) {
        long timestamp = System.currentTimeMillis();
        
        // Update current values
        this.browserCpuUsage = cpuUsage;
        this.browserMemoryUsageMb = memoryUsageMb;
        this.browserPageCount = pageCount;
        this.browserConnectionCount = connectionCount;
        this.jsHeapSizeMb = jsHeapSizeMb;
        
        // Record point-in-time values
        Map<String, Object> browserMetrics = new HashMap<>();
        browserMetrics.put("cpuUsage", cpuUsage);
        browserMetrics.put("memoryUsageMb", memoryUsageMb);
        browserMetrics.put("pageCount", pageCount);
        browserMetrics.put("connectionCount", connectionCount);
        browserMetrics.put("jsHeapSizeMb", jsHeapSizeMb);
        browserMetricsOverTime.put(timestamp, browserMetrics);
    }
    
    /**
     * Records a page load time.
     * 
     * @param url Page URL
     * @param loadTimeMs Load time in milliseconds
     */
    public void recordPageLoadTime(String url, long loadTimeMs) {
        if (url != null && !url.isEmpty()) {
            pageLoadTimes.put(url, loadTimeMs);
        }
    }
    
    /**
     * Records a slow resource load.
     * 
     * @param url Resource URL
     * @param loadTimeMs Load time in milliseconds
     * @param resourceType Resource type (e.g., "script", "image", "stylesheet")
     */
    public void recordSlowResource(String url, long loadTimeMs, String resourceType) {
        if (url != null && !url.isEmpty() && loadTimeMs > 1000) { // Only record if over 1 second
            SlowResource resource = new SlowResource(url, loadTimeMs, resourceType);
            slowResources.add(resource);
        }
    }
    
    /**
     * Records a JavaScript error.
     * 
     * @param message Error message
     * @param source Source file
     * @param lineNumber Line number
     * @param columnNumber Column number
     */
    public void recordJsError(String message, String source, int lineNumber, int columnNumber) {
        if (message != null && !message.isEmpty()) {
            JsError error = new JsError(message, source, lineNumber, columnNumber);
            jsErrors.add(error);
        }
    }
    
    /**
     * Records a performance mark.
     * 
     * @param name Mark name
     * @param timeMs Time in milliseconds
     */
    public void recordPerformanceMark(String name, long timeMs) {
        if (name != null && !name.isEmpty()) {
            performanceMarks.put(name, timeMs);
        }
    }
    
    /**
     * Records a performance measure.
     * 
     * @param name Measure name
     * @param durationMs Duration in milliseconds
     */
    public void recordPerformanceMeasure(String name, long durationMs) {
        if (name != null && !name.isEmpty()) {
            performanceMeasures.put(name, durationMs);
        }
    }
    
    /**
     * Records an additional metric.
     * 
     * @param name Metric name
     * @param value Metric value
     */
    public void recordAdditionalMetric(String name, Object value) {
        if (name != null && !name.isEmpty()) {
            additionalMetrics.put(name, value);
        }
    }
    
    /**
     * Marks metrics collection as complete.
     */
    public void markComplete() {
        this.endTimestamp = System.currentTimeMillis();
    }
    
    /**
     * Gets the average page load time in milliseconds.
     * 
     * @return Average page load time
     */
    public double getAvgPageLoadTimeMs() {
        if (pageLoadTimes.isEmpty()) {
            return 0;
        }
        
        double sum = 0;
        for (Long loadTime : pageLoadTimes.values()) {
            sum += loadTime;
        }
        return sum / pageLoadTimes.size();
    }
    
    /**
     * Gets the average slow resource load time in milliseconds.
     * 
     * @return Average slow resource load time
     */
    public double getAvgSlowResourceLoadTimeMs() {
        if (slowResources.isEmpty()) {
            return 0;
        }
        
        double sum = 0;
        for (SlowResource resource : slowResources) {
            sum += resource.getLoadTimeMs();
        }
        return sum / slowResources.size();
    }
    
    /**
     * Gets the network throughput in megabytes per second.
     * 
     * @return Network throughput
     */
    public double getNetworkThroughputMbps() {
        long durationSeconds = (endTimestamp - startTimestamp) / 1000;
        if (durationSeconds <= 0) {
            return 0;
        }
        
        double totalMb = totalNetworkReceivedMb + totalNetworkSentMb;
        return totalMb / durationSeconds;
    }
    
    /**
     * Gets a summary of resource metrics.
     * 
     * @return Summary map
     */
    public Map<String, Object> getSummary() {
        Map<String, Object> summary = new HashMap<>();
        summary.put("executionId", executionId);
        summary.put("durationMs", endTimestamp - startTimestamp);
        summary.put("cpuAvg", avgCpuUsage);
        summary.put("cpuMax", maxCpuUsage);
        summary.put("memoryAvg", avgMemoryUsageMb);
        summary.put("memoryMax", maxMemoryUsageMb);
        summary.put("diskReadTotal", totalDiskReadMb);
        summary.put("diskWriteTotal", totalDiskWriteMb);
        summary.put("networkReceivedTotal", totalNetworkReceivedMb);
        summary.put("networkSentTotal", totalNetworkSentMb);
        summary.put("networkThroughput", getNetworkThroughputMbps());
        summary.put("jsErrors", jsErrors.size());
        summary.put("slowResources", slowResources.size());
        summary.put("avgPageLoadTime", getAvgPageLoadTimeMs());
        summary.put("avgSlowResourceTime", getAvgSlowResourceLoadTimeMs());
        return summary;
    }
    
    /**
     * Returns a string representation of the resource metrics.
     * 
     * @return String representation
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("ResourceMetrics{");
        sb.append("executionId='").append(executionId).append('\'');
        sb.append(", duration=").append(endTimestamp - startTimestamp).append("ms");
        sb.append(", cpuAvg=").append(String.format("%.2f", avgCpuUsage)).append("%");
        sb.append(", cpuMax=").append(String.format("%.2f", maxCpuUsage)).append("%");
        sb.append(", memoryAvg=").append(String.format("%.2f", avgMemoryUsageMb)).append("MB");
        sb.append(", memoryMax=").append(String.format("%.2f", maxMemoryUsageMb)).append("MB");
        sb.append(", diskRead=").append(String.format("%.2f", totalDiskReadMb)).append("MB");
        sb.append(", diskWrite=").append(String.format("%.2f", totalDiskWriteMb)).append("MB");
        sb.append(", netReceived=").append(String.format("%.2f", totalNetworkReceivedMb)).append("MB");
        sb.append(", netSent=").append(String.format("%.2f", totalNetworkSentMb)).append("MB");
        sb.append(", jsErrors=").append(jsErrors.size());
        sb.append('}');
        return sb.toString();
    }
    
    /**
     * Inner class representing a slow-loading resource.
     */
    public static class SlowResource {
        private String url;
        private long loadTimeMs;
        private String resourceType;
        private long timestamp;
        
        /**
         * Default constructor.
         */
        public SlowResource() {
            this.timestamp = System.currentTimeMillis();
        }
        
        /**
         * Constructor with all fields.
         * 
         * @param url Resource URL
         * @param loadTimeMs Load time in milliseconds
         * @param resourceType Resource type
         */
        public SlowResource(String url, long loadTimeMs, String resourceType) {
            this.url = url;
            this.loadTimeMs = loadTimeMs;
            this.resourceType = resourceType;
            this.timestamp = System.currentTimeMillis();
        }
        
        // Getters and Setters
        
        public String getUrl() {
            return url;
        }
        
        public void setUrl(String url) {
            this.url = url;
        }
        
        public long getLoadTimeMs() {
            return loadTimeMs;
        }
        
        public void setLoadTimeMs(long loadTimeMs) {
            this.loadTimeMs = loadTimeMs;
        }
        
        public String getResourceType() {
            return resourceType;
        }
        
        public void setResourceType(String resourceType) {
            this.resourceType = resourceType;
        }
        
        public long getTimestamp() {
            return timestamp;
        }
        
        public void setTimestamp(long timestamp) {
            this.timestamp = timestamp;
        }
        
        @Override
        public String toString() {
            return String.format("%s (%s): %dms", url, resourceType, loadTimeMs);
        }
    }
    
    /**
     * Inner class representing a JavaScript error.
     */
    public static class JsError {
        private String message;
        private String source;
        private int lineNumber;
        private int columnNumber;
        private long timestamp;
        
        /**
         * Default constructor.
         */
        public JsError() {
            this.timestamp = System.currentTimeMillis();
        }
        
        /**
         * Constructor with all fields.
         * 
         * @param message Error message
         * @param source Source file
         * @param lineNumber Line number
         * @param columnNumber Column number
         */
        public JsError(String message, String source, int lineNumber, int columnNumber) {
            this.message = message;
            this.source = source;
            this.lineNumber = lineNumber;
            this.columnNumber = columnNumber;
            this.timestamp = System.currentTimeMillis();
        }
        
        // Getters and Setters
        
        public String getMessage() {
            return message;
        }
        
        public void setMessage(String message) {
            this.message = message;
        }
        
        public String getSource() {
            return source;
        }
        
        public void setSource(String source) {
            this.source = source;
        }
        
        public int getLineNumber() {
            return lineNumber;
        }
        
        public void setLineNumber(int lineNumber) {
            this.lineNumber = lineNumber;
        }
        
        public int getColumnNumber() {
            return columnNumber;
        }
        
        public void setColumnNumber(int columnNumber) {
            this.columnNumber = columnNumber;
        }
        
        public long getTimestamp() {
            return timestamp;
        }
        
        public void setTimestamp(long timestamp) {
            this.timestamp = timestamp;
        }
        
        @Override
        public String toString() {
            return String.format("%s [%s:%d:%d]", message, source, lineNumber, columnNumber);
        }
    }
    
    // Getters and Setters
    
    public String getExecutionId() {
        return executionId;
    }
    
    public void setExecutionId(String executionId) {
        this.executionId = executionId;
    }
    
    public long getStartTimestamp() {
        return startTimestamp;
    }
    
    public void setStartTimestamp(long startTimestamp) {
        this.startTimestamp = startTimestamp;
    }
    
    public long getEndTimestamp() {
        return endTimestamp;
    }
    
    public void setEndTimestamp(long endTimestamp) {
        this.endTimestamp = endTimestamp;
    }
    
    public long getSamplingIntervalMs() {
        return samplingIntervalMs;
    }
    
    public void setSamplingIntervalMs(long samplingIntervalMs) {
        this.samplingIntervalMs = samplingIntervalMs;
    }
    
    public double getMaxCpuUsage() {
        return maxCpuUsage;
    }
    
    public void setMaxCpuUsage(double maxCpuUsage) {
        this.maxCpuUsage = maxCpuUsage;
    }
    
    public double getAvgCpuUsage() {
        return avgCpuUsage;
    }
    
    public void setAvgCpuUsage(double avgCpuUsage) {
        this.avgCpuUsage = avgCpuUsage;
    }
    
    public Map<Long, Double> getCpuUsageOverTime() {
        return cpuUsageOverTime;
    }
    
    public void setCpuUsageOverTime(Map<Long, Double> cpuUsageOverTime) {
        this.cpuUsageOverTime = cpuUsageOverTime != null ? cpuUsageOverTime : new HashMap<>();
    }
    
    public double getMaxMemoryUsageMb() {
        return maxMemoryUsageMb;
    }
    
    public void setMaxMemoryUsageMb(double maxMemoryUsageMb) {
        this.maxMemoryUsageMb = maxMemoryUsageMb;
    }
    
    public double getAvgMemoryUsageMb() {
        return avgMemoryUsageMb;
    }
    
    public void setAvgMemoryUsageMb(double avgMemoryUsageMb) {
        this.avgMemoryUsageMb = avgMemoryUsageMb;
    }
    
    public Map<Long, Double> getMemoryUsageOverTime() {
        return memoryUsageOverTime;
    }
    
    public void setMemoryUsageOverTime(Map<Long, Double> memoryUsageOverTime) {
        this.memoryUsageOverTime = memoryUsageOverTime != null ? memoryUsageOverTime : new HashMap<>();
    }
    
    public double getTotalDiskReadMb() {
        return totalDiskReadMb;
    }
    
    public void setTotalDiskReadMb(double totalDiskReadMb) {
        this.totalDiskReadMb = totalDiskReadMb;
    }
    
    public double getTotalDiskWriteMb() {
        return totalDiskWriteMb;
    }
    
    public void setTotalDiskWriteMb(double totalDiskWriteMb) {
        this.totalDiskWriteMb = totalDiskWriteMb;
    }
    
    public Map<Long, Map<String, Double>> getDiskUsageOverTime() {
        return diskUsageOverTime;
    }
    
    public void setDiskUsageOverTime(Map<Long, Map<String, Double>> diskUsageOverTime) {
        this.diskUsageOverTime = diskUsageOverTime != null ? diskUsageOverTime : new HashMap<>();
    }
    
    public double getTotalNetworkReceivedMb() {
        return totalNetworkReceivedMb;
    }
    
    public void setTotalNetworkReceivedMb(double totalNetworkReceivedMb) {
        this.totalNetworkReceivedMb = totalNetworkReceivedMb;
    }
    
    public double getTotalNetworkSentMb() {
        return totalNetworkSentMb;
    }
    
    public void setTotalNetworkSentMb(double totalNetworkSentMb) {
        this.totalNetworkSentMb = totalNetworkSentMb;
    }
    
    public Map<Long, Map<String, Double>> getNetworkUsageOverTime() {
        return networkUsageOverTime;
    }
    
    public void setNetworkUsageOverTime(Map<Long, Map<String, Double>> networkUsageOverTime) {
        this.networkUsageOverTime = networkUsageOverTime != null ? networkUsageOverTime : new HashMap<>();
    }
    
    public double getBrowserCpuUsage() {
        return browserCpuUsage;
    }
    
    public void setBrowserCpuUsage(double browserCpuUsage) {
        this.browserCpuUsage = browserCpuUsage;
    }
    
    public double getBrowserMemoryUsageMb() {
        return browserMemoryUsageMb;
    }
    
    public void setBrowserMemoryUsageMb(double browserMemoryUsageMb) {
        this.browserMemoryUsageMb = browserMemoryUsageMb;
    }
    
    public int getBrowserPageCount() {
        return browserPageCount;
    }
    
    public void setBrowserPageCount(int browserPageCount) {
        this.browserPageCount = browserPageCount;
    }
    
    public int getBrowserConnectionCount() {
        return browserConnectionCount;
    }
    
    public void setBrowserConnectionCount(int browserConnectionCount) {
        this.browserConnectionCount = browserConnectionCount;
    }
    
    public double getJsHeapSizeMb() {
        return jsHeapSizeMb;
    }
    
    public void setJsHeapSizeMb(double jsHeapSizeMb) {
        this.jsHeapSizeMb = jsHeapSizeMb;
    }
    
    public Map<Long, Map<String, Object>> getBrowserMetricsOverTime() {
        return browserMetricsOverTime;
    }
    
    public void setBrowserMetricsOverTime(Map<Long, Map<String, Object>> browserMetricsOverTime) {
        this.browserMetricsOverTime = browserMetricsOverTime != null ? browserMetricsOverTime : new HashMap<>();
    }
    
    public Map<String, Long> getPageLoadTimes() {
        return pageLoadTimes;
    }
    
    public void setPageLoadTimes(Map<String, Long> pageLoadTimes) {
        this.pageLoadTimes = pageLoadTimes != null ? pageLoadTimes : new HashMap<>();
    }
    
    public List<SlowResource> getSlowResources() {
        return slowResources;
    }
    
    public void setSlowResources(List<SlowResource> slowResources) {
        this.slowResources = slowResources != null ? slowResources : new ArrayList<>();
    }
    
    public List<JsError> getJsErrors() {
        return jsErrors;
    }
    
    public void setJsErrors(List<JsError> jsErrors) {
        this.jsErrors = jsErrors != null ? jsErrors : new ArrayList<>();
    }
    
    public Map<String, Long> getPerformanceMarks() {
        return performanceMarks;
    }
    
    public void setPerformanceMarks(Map<String, Long> performanceMarks) {
        this.performanceMarks = performanceMarks != null ? performanceMarks : new HashMap<>();
    }
    
    public Map<String, Long> getPerformanceMeasures() {
        return performanceMeasures;
    }
    
    public void setPerformanceMeasures(Map<String, Long> performanceMeasures) {
        this.performanceMeasures = performanceMeasures != null ? performanceMeasures : new HashMap<>();
    }
    
    public Map<String, Object> getAdditionalMetrics() {
        return additionalMetrics;
    }
    
    public void setAdditionalMetrics(Map<String, Object> additionalMetrics) {
        this.additionalMetrics = additionalMetrics != null ? additionalMetrics : new HashMap<>();
    }
}



ParallelConfig.java
----------------------------

package com.cstestforge.model.execution;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Configuration model for parallel test execution.
 * This model contains settings related to running tests in parallel,
 * including thread count, distribution strategy, and resource constraints.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ParallelConfig {
    
    /**
     * Enumeration of distribution strategies for parallel execution.
     */
    public enum DistributionStrategy {
        /**
         * Distribute tests to threads in the order they appear in the test suite.
         */
        SEQUENTIAL("sequential"),
        
        /**
         * Distribute tests to threads in a round-robin fashion.
         */
        ROUND_ROBIN("round-robin"),
        
        /**
         * Distribute tests to threads based on their estimated duration,
         * with longest tests first to optimize overall execution time.
         */
        WEIGHTED("weighted"),
        
        /**
         * Distribute tests to threads randomly.
         */
        RANDOM("random"),
        
        /**
         * Distribute tests to threads based on their dependencies,
         * maximizing parallel execution while respecting dependencies.
         */
        DEPENDENCY_AWARE("dependency-aware"),
        
        /**
         * Distribute tests to threads based on tags or groups.
         */
        GROUP_BASED("group-based");
        
        private final String value;
        
        DistributionStrategy(String value) {
            this.value = value;
        }
        
        @Override
        public String toString() {
            return value;
        }
        
        public static DistributionStrategy fromString(String value) {
            for (DistributionStrategy strategy : DistributionStrategy.values()) {
                if (strategy.value.equalsIgnoreCase(value)) {
                    return strategy;
                }
            }
            return ROUND_ROBIN; // Default to round-robin
        }
    }
    
    /**
     * Enumeration of thread pooling strategies.
     */
    public enum ThreadPoolStrategy {
        /**
         * Fixed thread pool with a constant number of threads.
         */
        FIXED("fixed"),
        
        /**
         * Cached thread pool that creates new threads as needed and reuses idle threads.
         */
        CACHED("cached"),
        
        /**
         * Thread pool with a fixed core size but allowing temporary excess threads.
         */
        ELASTIC("elastic"),
        
        /**
         * Work-stealing thread pool for task-based parallelism.
         */
        WORK_STEALING("work-stealing");
        
        private final String value;
        
        ThreadPoolStrategy(String value) {
            this.value = value;
        }
        
        @Override
        public String toString() {
            return value;
        }
        
        public static ThreadPoolStrategy fromString(String value) {
            for (ThreadPoolStrategy strategy : ThreadPoolStrategy.values()) {
                if (strategy.value.equalsIgnoreCase(value)) {
                    return strategy;
                }
            }
            return FIXED; // Default to fixed
        }
    }
    
    /**
     * Maximum number of threads to use for parallel execution.
     */
    private int maxThreads = 4;
    
    /**
     * Minimum number of threads to use for parallel execution (for elastic strategy).
     */
    private int minThreads = 2;
    
    /**
     * Keep-alive time in seconds for idle threads (for cached and elastic strategies).
     */
    private int threadKeepAliveSeconds = 60;
    
    /**
     * Strategy for distributing tests to threads.
     */
    private DistributionStrategy distributionStrategy = DistributionStrategy.ROUND_ROBIN;
    
    /**
     * Thread pool strategy.
     */
    private ThreadPoolStrategy threadPoolStrategy = ThreadPoolStrategy.FIXED;
    
    /**
     * Maximum memory usage percentage before scaling back parallelism.
     */
    private int maxMemoryUsagePercent = 85;
    
    /**
     * Maximum CPU usage percentage before scaling back parallelism.
     */
    private int maxCpuUsagePercent = 90;
    
    /**
     * Size of the task queue for thread pools that use queuing.
     */
    private int taskQueueSize = 100;
    
    /**
     * Timeout in minutes for thread termination when shutting down.
     */
    private int shutdownTimeoutMinutes = 5;
    
    /**
     * Flag to enable dynamic scaling of thread count based on system resources.
     */
    private boolean enableDynamicScaling = true;
    
    /**
     * Interval in seconds for checking system resources when dynamic scaling is enabled.
     */
    private int resourceCheckIntervalSeconds = 30;
    
    /**
     * Maximum number of threads to increase or decrease during dynamic scaling.
     */
    private int maxThreadDelta = 2;
    
    /**
     * Map of thread-specific execution environments.
     * Key: Thread name/ID, Value: Environment configuration
     */
    private Map<String, ExecutionEnvironment> threadEnvironments = new HashMap<>();
    
    /**
     * Priority weights for different test types.
     * Key: Test type or tag, Value: Priority weight (higher values get higher priority)
     */
    private Map<String, Integer> testPriorities = new HashMap<>();
    
    /**
     * Thread isolation level for browser sessions.
     * true = one browser session per thread, false = shared browser sessions
     */
    private boolean isolateBrowserSessions = true;
    
    /**
     * List of test groups to run in sequence (not in parallel).
     */
    private List<String> sequentialGroups = new ArrayList<>();
    
    /**
     * Default constructor.
     */
    public ParallelConfig() {
    }
    
    /**
     * Constructor with max threads.
     * 
     * @param maxThreads Maximum number of threads
     */
    public ParallelConfig(int maxThreads) {
        this.maxThreads = maxThreads;
    }
    
    /**
     * Constructor with max threads and distribution strategy.
     * 
     * @param maxThreads Maximum number of threads
     * @param distributionStrategy Distribution strategy
     */
    public ParallelConfig(int maxThreads, DistributionStrategy distributionStrategy) {
        this.maxThreads = maxThreads;
        this.distributionStrategy = distributionStrategy;
    }
    
    /**
     * Constructor with max threads, distribution strategy, and thread pool strategy.
     * 
     * @param maxThreads Maximum number of threads
     * @param distributionStrategy Distribution strategy
     * @param threadPoolStrategy Thread pool strategy
     */
    public ParallelConfig(int maxThreads, DistributionStrategy distributionStrategy, 
                         ThreadPoolStrategy threadPoolStrategy) {
        this.maxThreads = maxThreads;
        this.distributionStrategy = distributionStrategy;
        this.threadPoolStrategy = threadPoolStrategy;
    }
    
    /**
     * Validates the parallel configuration and adjusts values if necessary.
     * 
     * @return true if the configuration is valid, false otherwise
     */
    public boolean validate() {
        boolean isValid = true;
        
        // Validate thread counts
        if (maxThreads <= 0) {
            maxThreads = Runtime.getRuntime().availableProcessors();
            isValid = false;
        }
        
        if (minThreads <= 0) {
            minThreads = 1;
            isValid = false;
        }
        
        if (minThreads > maxThreads) {
            minThreads = maxThreads;
            isValid = false;
        }
        
        // Validate resource limits
        if (maxMemoryUsagePercent <= 0 || maxMemoryUsagePercent > 100) {
            maxMemoryUsagePercent = 85;
            isValid = false;
        }
        
        if (maxCpuUsagePercent <= 0 || maxCpuUsagePercent > 100) {
            maxCpuUsagePercent = 90;
            isValid = false;
        }
        
        // Validate timeouts
        if (threadKeepAliveSeconds < 0) {
            threadKeepAliveSeconds = 60;
            isValid = false;
        }
        
        if (shutdownTimeoutMinutes <= 0) {
            shutdownTimeoutMinutes = 5;
            isValid = false;
        }
        
        if (resourceCheckIntervalSeconds <= 0) {
            resourceCheckIntervalSeconds = 30;
            isValid = false;
        }
        
        if (maxThreadDelta <= 0) {
            maxThreadDelta = 2;
            isValid = false;
        }
        
        return isValid;
    }
    
    /**
     * Calculates the initial thread count based on system resources.
     * 
     * @return Initial thread count
     */
    public int calculateInitialThreadCount() {
        // Get available processors
        int availableProcessors = Runtime.getRuntime().availableProcessors();
        
        // Start with processor count
        int threadCount = availableProcessors;
        
        // Consider available memory
        long maxMemory = Runtime.getRuntime().maxMemory() / (1024 * 1024); // in MB
        long freeMemory = Runtime.getRuntime().freeMemory() / (1024 * 1024); // in MB
        
        // Conservative estimate: each browser instance may need around 200-500 MB
        long estimatedMemoryPerThread = 350; // MB
        
        // Calculate max threads based on memory
        int memoryBasedThreads = (int) (maxMemory / estimatedMemoryPerThread);
        
        // Use the minimum of processor-based and memory-based counts
        threadCount = Math.min(threadCount, memoryBasedThreads);
        
        // Respect min/max thread configuration
        threadCount = Math.max(minThreads, Math.min(maxThreads, threadCount));
        
        return threadCount;
    }
    
    /**
     * Adds a thread-specific execution environment.
     * 
     * @param threadName Thread name/ID
     * @param environment Execution environment
     */
    public void addThreadEnvironment(String threadName, ExecutionEnvironment environment) {
        if (threadName != null && !threadName.isEmpty() && environment != null) {
            threadEnvironments.put(threadName, environment);
        }
    }
    
    /**
     * Sets a priority weight for a test type or tag.
     * 
     * @param testType Test type or tag
     * @param priority Priority weight
     */
    public void setTestPriority(String testType, int priority) {
        if (testType != null && !testType.isEmpty()) {
            testPriorities.put(testType, priority);
        }
    }
    
    /**
     * Adds a test group to run in sequence.
     * 
     * @param group Test group
     */
    public void addSequentialGroup(String group) {
        if (group != null && !group.isEmpty()) {
            sequentialGroups.add(group);
        }
    }
    
    /**
     * Returns a string representation of the parallel configuration.
     * 
     * @return String representation
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("ParallelConfig{");
        sb.append("maxThreads=").append(maxThreads);
        sb.append(", distribution=").append(distributionStrategy);
        sb.append(", poolStrategy=").append(threadPoolStrategy);
        
        if (enableDynamicScaling) {
            sb.append(", dynamicScaling=true");
        }
        
        if (!sequentialGroups.isEmpty()) {
            sb.append(", sequentialGroups=").append(sequentialGroups.size());
        }
        
        sb.append('}');
        
        return sb.toString();
    }
    
    /**
     * Compares this parallel configuration with another object for equality.
     * 
     * @param o The object to compare with
     * @return true if the objects are equal, false otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        ParallelConfig that = (ParallelConfig) o;
        
        if (maxThreads != that.maxThreads) return false;
        if (minThreads != that.minThreads) return false;
        if (threadKeepAliveSeconds != that.threadKeepAliveSeconds) return false;
        if (maxMemoryUsagePercent != that.maxMemoryUsagePercent) return false;
        if (maxCpuUsagePercent != that.maxCpuUsagePercent) return false;
        if (taskQueueSize != that.taskQueueSize) return false;
        if (shutdownTimeoutMinutes != that.shutdownTimeoutMinutes) return false;
        if (enableDynamicScaling != that.enableDynamicScaling) return false;
        if (resourceCheckIntervalSeconds != that.resourceCheckIntervalSeconds) return false;
        if (maxThreadDelta != that.maxThreadDelta) return false;
        if (isolateBrowserSessions != that.isolateBrowserSessions) return false;
        if (distributionStrategy != that.distributionStrategy) return false;
        if (threadPoolStrategy != that.threadPoolStrategy) return false;
        if (!Objects.equals(threadEnvironments, that.threadEnvironments)) return false;
        if (!Objects.equals(testPriorities, that.testPriorities)) return false;
        return Objects.equals(sequentialGroups, that.sequentialGroups);
    }
    
    /**
     * Returns a hash code for this parallel configuration.
     * 
     * @return Hash code
     */
    @Override
    public int hashCode() {
        int result = maxThreads;
        result = 31 * result + minThreads;
        result = 31 * result + threadKeepAliveSeconds;
        result = 31 * result + (distributionStrategy != null ? distributionStrategy.hashCode() : 0);
        result = 31 * result + (threadPoolStrategy != null ? threadPoolStrategy.hashCode() : 0);
        result = 31 * result + maxMemoryUsagePercent;
        result = 31 * result + maxCpuUsagePercent;
        result = 31 * result + taskQueueSize;
        result = 31 * result + shutdownTimeoutMinutes;
        result = 31 * result + (enableDynamicScaling ? 1 : 0);
        result = 31 * result + resourceCheckIntervalSeconds;
        result = 31 * result + maxThreadDelta;
        result = 31 * result + (threadEnvironments != null ? threadEnvironments.hashCode() : 0);
        result = 31 * result + (testPriorities != null ? testPriorities.hashCode() : 0);
        result = 31 * result + (isolateBrowserSessions ? 1 : 0);
        result = 31 * result + (sequentialGroups != null ? sequentialGroups.hashCode() : 0);
        return result;
    }
    
    // Getters and Setters
    
    public int getMaxThreads() {
        return maxThreads;
    }
    
    public void setMaxThreads(int maxThreads) {
        this.maxThreads = maxThreads;
    }
    
    public int getMinThreads() {
        return minThreads;
    }
    
    public void setMinThreads(int minThreads) {
        this.minThreads = minThreads;
    }
    
    public int getThreadKeepAliveSeconds() {
        return threadKeepAliveSeconds;
    }
    
    public void setThreadKeepAliveSeconds(int threadKeepAliveSeconds) {
        this.threadKeepAliveSeconds = threadKeepAliveSeconds;
    }
    
    public DistributionStrategy getDistributionStrategy() {
        return distributionStrategy;
    }
    
    public void setDistributionStrategy(DistributionStrategy distributionStrategy) {
        this.distributionStrategy = distributionStrategy;
    }
    
    public ThreadPoolStrategy getThreadPoolStrategy() {
        return threadPoolStrategy;
    }
    
    public void setThreadPoolStrategy(ThreadPoolStrategy threadPoolStrategy) {
        this.threadPoolStrategy = threadPoolStrategy;
    }
    
    public int getMaxMemoryUsagePercent() {
        return maxMemoryUsagePercent;
    }
    
    public void setMaxMemoryUsagePercent(int maxMemoryUsagePercent) {
        this.maxMemoryUsagePercent = maxMemoryUsagePercent;
    }
    
    public int getMaxCpuUsagePercent() {
        return maxCpuUsagePercent;
    }
    
    public void setMaxCpuUsagePercent(int maxCpuUsagePercent) {
        this.maxCpuUsagePercent = maxCpuUsagePercent;
    }
    
    public int getTaskQueueSize() {
        return taskQueueSize;
    }
    
    public void setTaskQueueSize(int taskQueueSize) {
        this.taskQueueSize = taskQueueSize;
    }
    
    public int getShutdownTimeoutMinutes() {
        return shutdownTimeoutMinutes;
    }
    
    public void setShutdownTimeoutMinutes(int shutdownTimeoutMinutes) {
        this.shutdownTimeoutMinutes = shutdownTimeoutMinutes;
    }
    
    public boolean isEnableDynamicScaling() {
        return enableDynamicScaling;
    }
    
    public void setEnableDynamicScaling(boolean enableDynamicScaling) {
        this.enableDynamicScaling = enableDynamicScaling;
    }
    
    public int getResourceCheckIntervalSeconds() {
        return resourceCheckIntervalSeconds;
    }
    
    public void setResourceCheckIntervalSeconds(int resourceCheckIntervalSeconds) {
        this.resourceCheckIntervalSeconds = resourceCheckIntervalSeconds;
    }
    
    public int getMaxThreadDelta() {
        return maxThreadDelta;
    }
    
    public void setMaxThreadDelta(int maxThreadDelta) {
        this.maxThreadDelta = maxThreadDelta;
    }
    
    public Map<String, ExecutionEnvironment> getThreadEnvironments() {
        return threadEnvironments;
    }
    
    public void setThreadEnvironments(Map<String, ExecutionEnvironment> threadEnvironments) {
        this.threadEnvironments = threadEnvironments != null ? threadEnvironments : new HashMap<>();
    }
    
    public Map<String, Integer> getTestPriorities() {
        return testPriorities;
    }
    
    public void setTestPriorities(Map<String, Integer> testPriorities) {
        this.testPriorities = testPriorities != null ? testPriorities : new HashMap<>();
    }
    
    public boolean isIsolateBrowserSessions() {
        return isolateBrowserSessions;
    }
    
    public void setIsolateBrowserSessions(boolean isolateBrowserSessions) {
        this.isolateBrowserSessions = isolateBrowserSessions;
    }
    
    public List<String> getSequentialGroups() {
        return sequentialGroups;
    }
    
    public void setSequentialGroups(List<String> sequentialGroups) {
        this.sequentialGroups = sequentialGroups != null ? sequentialGroups : new ArrayList<>();
    }
}


ExecutionConfig.java
-----------------------------


package com.cstestforge.model.execution;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Global execution configuration for test executions.
 * This model provides global settings that apply to all test executions,
 * including defaults, retry policies, and failure handling.
 */
@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ExecutionConfig {
    
    /**
     * Enumeration of failure handling strategies.
     */
    public enum FailureHandlingStrategy {
        /**
         * Continue execution of remaining tests after a failure.
         */
        CONTINUE("continue"),
        
        /**
         * Stop execution immediately upon encountering a failure.
         */
        STOP_IMMEDIATELY("stop-immediately"),
        
        /**
         * Stop execution of the current test suite upon encountering a failure,
         * but continue with other test suites.
         */
        STOP_SUITE("stop-suite");
        
        private final String value;
        
        FailureHandlingStrategy(String value) {
            this.value = value;
        }
        
        @Override
        public String toString() {
            return value;
        }
        
        public static FailureHandlingStrategy fromString(String value) {
            for (FailureHandlingStrategy strategy : FailureHandlingStrategy.values()) {
                if (strategy.value.equalsIgnoreCase(value)) {
                    return strategy;
                }
            }
            return CONTINUE; // Default to continue
        }
    }
    
    /**
     * Enumeration of dependency handling strategies.
     */
    public enum DependencyHandlingStrategy {
        /**
         * Skip dependent tests if a dependency fails.
         */
        SKIP_DEPENDENT("skip-dependent"),
        
        /**
         * Ignore dependencies and execute all tests regardless of dependency failures.
         */
        IGNORE_DEPENDENCIES("ignore-dependencies"),
        
        /**
         * Mark dependent tests as blocked if a dependency fails.
         */
        MARK_BLOCKED("mark-blocked");
        
        private final String value;
        
        DependencyHandlingStrategy(String value) {
            this.value = value;
        }
        
        @Override
        public String toString() {
            return value;
        }
        
        public static DependencyHandlingStrategy fromString(String value) {
            for (DependencyHandlingStrategy strategy : DependencyHandlingStrategy.values()) {
                if (strategy.value.equalsIgnoreCase(value)) {
                    return strategy;
                }
            }
            return SKIP_DEPENDENT; // Default to skip dependent
        }
    }
    
    /**
     * Default name of the execution environment.
     */
    private String defaultEnvironment = "qa";
    
    /**
     * Default execution environment configuration.
     */
    private ExecutionEnvironment defaultExecutionEnvironment;
    
    /**
     * Maximum number of retry attempts for failed tests.
     */
    private int maxRetryAttempts = 1;
    
    /**
     * Enable or disable test retries.
     */
    private boolean retryEnabled = true;
    
    /**
     * Failure handling strategy.
     */
    private FailureHandlingStrategy failureHandlingStrategy = FailureHandlingStrategy.CONTINUE;
    
    /**
     * Dependency handling strategy.
     */
    private DependencyHandlingStrategy dependencyHandlingStrategy = DependencyHandlingStrategy.SKIP_DEPENDENT;
    
    /**
     * Interval in milliseconds to wait between test retries.
     */
    private long retryIntervalMs = 5000;
    
    /**
     * Execution timeout in minutes.
     */
    private int executionTimeoutMinutes = 60;
    
    /**
     * Default parallel configuration.
     */
    private ParallelConfig defaultParallelConfig;
    
    /**
     * Enable or disable report generation.
     */
    private boolean reportEnabled = true;
    
    /**
     * Enable or disable screenshots.
     */
    private boolean screenshotEnabled = true;
    
    /**
     * Only take screenshots on test failures.
     */
    private boolean screenshotOnFailureOnly = false;
    
    /**
     * Enable or disable video recording.
     */
    private boolean videoEnabled = false;
    
    /**
     * Enable or disable detailed logging.
     */
    private boolean detailedLoggingEnabled = false;
    
    /**
     * Enable or disable self-healing.
     */
    private boolean selfHealingEnabled = true;
    
    /**
     * Minimum log level for reporting.
     */
    private TestLog.LogLevel minimumLogLevel = TestLog.LogLevel.INFO;
    
    /**
     * Map of environment-specific configurations.
     * Key: Environment name, Value: Environment configuration
     */
    private Map<String, ExecutionEnvironment> environments = new HashMap<>();
    
    /**
     * List of retry-able exceptions.
     */
    private List<String> retryableExceptions = new ArrayList<>();
    
    /**
     * Map of custom execution parameters.
     */
    private Map<String, String> customParameters = new HashMap<>();
    
    /**
     * Global execution hooks configuration.
     */
    private ExecutionHooks executionHooks = new ExecutionHooks();
    
    /**
     * Default constructor.
     */
    public ExecutionConfig() {
        // Initialize default execution environment
        defaultExecutionEnvironment = new ExecutionEnvironment(defaultEnvironment);
        
        // Initialize default parallel config
        defaultParallelConfig = new ParallelConfig();
        
        // Initialize default retryable exceptions
        retryableExceptions.add("org.openqa.selenium.StaleElementReferenceException");
        retryableExceptions.add("org.openqa.selenium.TimeoutException");
        retryableExceptions.add("org.openqa.selenium.ElementClickInterceptedException");
        retryableExceptions.add("org.openqa.selenium.ElementNotInteractableException");
        retryableExceptions.add("java.net.SocketException");
        retryableExceptions.add("java.net.ConnectException");
    }
    
    /**
     * Constructor with default environment name.
     * 
     * @param defaultEnvironment Default environment name
     */
    public ExecutionConfig(String defaultEnvironment) {
        this.defaultEnvironment = defaultEnvironment;
        
        // Initialize default execution environment
        defaultExecutionEnvironment = new ExecutionEnvironment(defaultEnvironment);
        
        // Initialize default parallel config
        defaultParallelConfig = new ParallelConfig();
        
        // Initialize default retryable exceptions
        retryableExceptions.add("org.openqa.selenium.StaleElementReferenceException");
        retryableExceptions.add("org.openqa.selenium.TimeoutException");
        retryableExceptions.add("org.openqa.selenium.ElementClickInterceptedException");
        retryableExceptions.add("org.openqa.selenium.ElementNotInteractableException");
        retryableExceptions.add("java.net.SocketException");
        retryableExceptions.add("java.net.ConnectException");
    }
    
    /**
     * Validates the execution configuration and adjusts values if necessary.
     * 
     * @return true if the configuration is valid, false otherwise
     */
    public boolean validate() {
        boolean isValid = true;
        
        // Validate retry attempts
        if (maxRetryAttempts < 0) {
            maxRetryAttempts = 0;
            isValid = false;
        }
        
        // Validate retry interval
        if (retryIntervalMs < 0) {
            retryIntervalMs = 5000;
            isValid = false;
        }
        
        // Validate execution timeout
        if (executionTimeoutMinutes <= 0) {
            executionTimeoutMinutes = 60;
            isValid = false;
        }
        
        // Validate default environment
        if (defaultEnvironment == null || defaultEnvironment.isEmpty()) {
            defaultEnvironment = "qa";
            isValid = false;
        }
        
        // Validate default execution environment
        if (defaultExecutionEnvironment == null) {
            defaultExecutionEnvironment = new ExecutionEnvironment(defaultEnvironment);
            isValid = false;
        }
        
        // Validate default parallel config
        if (defaultParallelConfig == null) {
            defaultParallelConfig = new ParallelConfig();
            isValid = false;
        } else {
            isValid = defaultParallelConfig.validate() && isValid;
        }
        
        return isValid;
    }
    
    /**
     * Gets the execution environment for the specified environment name.
     * 
     * @param environment Environment name
     * @return Execution environment
     */
    public ExecutionEnvironment getEnvironment(String environment) {
        if (environment == null || environment.isEmpty()) {
            return defaultExecutionEnvironment;
        }
        
        return environments.getOrDefault(environment, defaultExecutionEnvironment);
    }
    
    /**
     * Adds a new environment configuration.
     * 
     * @param name Environment name
     * @param environment Environment configuration
     */
    public void addEnvironment(String name, ExecutionEnvironment environment) {
        if (name != null && !name.isEmpty() && environment != null) {
            environments.put(name, environment);
        }
    }
    
    /**
     * Adds a retryable exception.
     * 
     * @param exceptionClass Exception class name
     */
    public void addRetryableException(String exceptionClass) {
        if (exceptionClass != null && !exceptionClass.isEmpty()) {
            retryableExceptions.add(exceptionClass);
        }
    }
    
    /**
     * Checks if an exception is retryable.
     * 
     * @param exceptionClass Exception class name
     * @return true if the exception is retryable, false otherwise
     */
    public boolean isRetryableException(String exceptionClass) {
        if (exceptionClass == null || exceptionClass.isEmpty()) {
            return false;
        }
        
        for (String retryableException : retryableExceptions) {
            if (exceptionClass.equals(retryableException) || exceptionClass.endsWith(retryableException)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Adds a custom parameter.
     * 
     * @param key Parameter key
     * @param value Parameter value
     */
    public void addCustomParameter(String key, String value) {
        if (key != null && !key.isEmpty()) {
            customParameters.put(key, value);
        }
    }
    
    /**
     * Gets a custom parameter.
     * 
     * @param key Parameter key
     * @param defaultValue Default value
     * @return Parameter value, or default value if not found
     */
    public String getCustomParameter(String key, String defaultValue) {
        if (key == null || key.isEmpty()) {
            return defaultValue;
        }
        
        return customParameters.getOrDefault(key, defaultValue);
    }
    
    /**
     * Returns a string representation of the execution configuration.
     * 
     * @return String representation
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("ExecutionConfig{");
        sb.append("defaultEnvironment='").append(defaultEnvironment).append('\'');
        sb.append(", retry=").append(retryEnabled ? "enabled" : "disabled");
        
        if (retryEnabled) {
            sb.append(", maxRetries=").append(maxRetryAttempts);
        }
        
        sb.append(", failureHandling=").append(failureHandlingStrategy);
        sb.append(", timeout=").append(executionTimeoutMinutes).append("min");
        sb.append(", environments=").append(environments.size());
        sb.append('}');
        
        return sb.toString();
    }
    
    /**
     * Inner class for execution hooks configuration.
     */
    public static class ExecutionHooks {
        private String beforeExecution;
        private String afterExecution;
        private String beforeTestSuite;
        private String afterTestSuite;
        private String beforeTestCase;
        private String afterTestCase;
        private String onTestSuccess;
        private String onTestFailure;
        private String onTestSkipped;
        
        /**
         * Default constructor.
         */
        public ExecutionHooks() {
        }
        
        // Getters and Setters
        
        public String getBeforeExecution() {
            return beforeExecution;
        }
        
        public void setBeforeExecution(String beforeExecution) {
            this.beforeExecution = beforeExecution;
        }
        
        public String getAfterExecution() {
            return afterExecution;
        }
        
        public void setAfterExecution(String afterExecution) {
            this.afterExecution = afterExecution;
        }
        
        public String getBeforeTestSuite() {
            return beforeTestSuite;
        }
        
        public void setBeforeTestSuite(String beforeTestSuite) {
            this.beforeTestSuite = beforeTestSuite;
        }
        
        public String getAfterTestSuite() {
            return afterTestSuite;
        }
        
        public void setAfterTestSuite(String afterTestSuite) {
            this.afterTestSuite = afterTestSuite;
        }
        
        public String getBeforeTestCase() {
            return beforeTestCase;
        }
        
        public void setBeforeTestCase(String beforeTestCase) {
            this.beforeTestCase = beforeTestCase;
        }
        
        public String getAfterTestCase() {
            return afterTestCase;
        }
        
        public void setAfterTestCase(String afterTestCase) {
            this.afterTestCase = afterTestCase;
        }
        
        public String getOnTestSuccess() {
            return onTestSuccess;
        }
        
        public void setOnTestSuccess(String onTestSuccess) {
            this.onTestSuccess = onTestSuccess;
        }
        
        public String getOnTestFailure() {
            return onTestFailure;
        }
        
        public void setOnTestFailure(String onTestFailure) {
            this.onTestFailure = onTestFailure;
        }
        
        public String getOnTestSkipped() {
            return onTestSkipped;
        }
        
        public void setOnTestSkipped(String onTestSkipped) {
            this.onTestSkipped = onTestSkipped;
        }
        
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            
            ExecutionHooks that = (ExecutionHooks) o;
            
            if (!Objects.equals(beforeExecution, that.beforeExecution)) return false;
            if (!Objects.equals(afterExecution, that.afterExecution)) return false;
            if (!Objects.equals(beforeTestSuite, that.beforeTestSuite)) return false;
            if (!Objects.equals(afterTestSuite, that.afterTestSuite)) return false;
            if (!Objects.equals(beforeTestCase, that.beforeTestCase)) return false;
            if (!Objects.equals(afterTestCase, that.afterTestCase)) return false;
            if (!Objects.equals(onTestSuccess, that.onTestSuccess)) return false;
            if (!Objects.equals(onTestFailure, that.onTestFailure)) return false;
            return Objects.equals(onTestSkipped, that.onTestSkipped);
        }
        
        @Override
        public int hashCode() {
            int result = beforeExecution != null ? beforeExecution.hashCode() : 0;
            result = 31 * result + (afterExecution != null ? afterExecution.hashCode() : 0);
            result = 31 * result + (beforeTestSuite != null ? beforeTestSuite.hashCode() : 0);
            result = 31 * result + (afterTestSuite != null ? afterTestSuite.hashCode() : 0);
            result = 31 * result + (beforeTestCase != null ? beforeTestCase.hashCode() : 0);
            result = 31 * result + (afterTestCase != null ? afterTestCase.hashCode() : 0);
            result = 31 * result + (onTestSuccess != null ? onTestSuccess.hashCode() : 0);
            result = 31 * result + (onTestFailure != null ? onTestFailure.hashCode() : 0);
            result = 31 * result + (onTestSkipped != null ? onTestSkipped.hashCode() : 0);
            return result;
        }
    }
    
    /**
     * Compares this execution configuration with another object for equality.
     * 
     * @param o The object to compare with
     * @return true if the objects are equal, false otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        ExecutionConfig that = (ExecutionConfig) o;
        
        if (maxRetryAttempts != that.maxRetryAttempts) return false;
        if (retryEnabled != that.retryEnabled) return false;
        if (retryIntervalMs != that.retryIntervalMs) return false;
        if (executionTimeoutMinutes != that.executionTimeoutMinutes) return false;
        if (reportEnabled != that.reportEnabled) return false;
        if (screenshotEnabled != that.screenshotEnabled) return false;
        if (screenshotOnFailureOnly != that.screenshotOnFailureOnly) return false;
        if (videoEnabled != that.videoEnabled) return false;
        if (detailedLoggingEnabled != that.detailedLoggingEnabled) return false;
        if (selfHealingEnabled != that.selfHealingEnabled) return false;
        if (!Objects.equals(defaultEnvironment, that.defaultEnvironment)) return false;
        if (!Objects.equals(defaultExecutionEnvironment, that.defaultExecutionEnvironment)) return false;
        if (failureHandlingStrategy != that.failureHandlingStrategy) return false;
        if (dependencyHandlingStrategy != that.dependencyHandlingStrategy) return false;
        if (!Objects.equals(defaultParallelConfig, that.defaultParallelConfig)) return false;
        if (minimumLogLevel != that.minimumLogLevel) return false;
        if (!Objects.equals(environments, that.environments)) return false;
        if (!Objects.equals(retryableExceptions, that.retryableExceptions)) return false;
        if (!Objects.equals(customParameters, that.customParameters)) return false;
        return Objects.equals(executionHooks, that.executionHooks);
    }
    
    /**
     * Returns a hash code for this execution configuration.
     * 
     * @return Hash code
     */
    @Override
    public int hashCode() {
        int result = defaultEnvironment != null ? defaultEnvironment.hashCode() : 0;
        result = 31 * result + (defaultExecutionEnvironment != null ? defaultExecutionEnvironment.hashCode() : 0);
        result = 31 * result + maxRetryAttempts;
        result = 31 * result + (retryEnabled ? 1 : 0);
        result = 31 * result + (failureHandlingStrategy != null ? failureHandlingStrategy.hashCode() : 0);
        result = 31 * result + (dependencyHandlingStrategy != null ? dependencyHandlingStrategy.hashCode() : 0);
        result = 31 * result + (int) (retryIntervalMs ^ (retryIntervalMs >>> 32));
        result = 31 * result + executionTimeoutMinutes;
        result = 31 * result + (defaultParallelConfig != null ? defaultParallelConfig.hashCode() : 0);
        result = 31 * result + (reportEnabled ? 1 : 0);
        result = 31 * result + (screenshotEnabled ? 1 : 0);
        result = 31 * result + (screenshotOnFailureOnly ? 1 : 0);
        result = 31 * result + (videoEnabled ? 1 : 0);
        result = 31 * result + (detailedLoggingEnabled ? 1 : 0);
        result = 31 * result + (selfHealingEnabled ? 1 : 0);
        result = 31 * result + (minimumLogLevel != null ? minimumLogLevel.hashCode() : 0);
        result = 31 * result + (environments != null ? environments.hashCode() : 0);
        result = 31 * result + (retryableExceptions != null ? retryableExceptions.hashCode() : 0);
        result = 31 * result + (customParameters != null ? customParameters.hashCode() : 0);
        result = 31 * result + (executionHooks != null ? executionHooks.hashCode() : 0);
        return result;
    }
    
    // Getters and Setters
    
    public String getDefaultEnvironment() {
        return defaultEnvironment;
    }
    
    public void setDefaultEnvironment(String defaultEnvironment) {
        this.defaultEnvironment = defaultEnvironment;
    }
    
    public ExecutionEnvironment getDefaultExecutionEnvironment() {
        return defaultExecutionEnvironment;
    }
    
    public void setDefaultExecutionEnvironment(ExecutionEnvironment defaultExecutionEnvironment) {
        this.defaultExecutionEnvironment = defaultExecutionEnvironment;
    }
    
    public int getMaxRetryAttempts() {
        return maxRetryAttempts;
    }
    
    public void setMaxRetryAttempts(int maxRetryAttempts) {
        this.maxRetryAttempts = maxRetryAttempts;
    }
    
    public boolean isRetryEnabled() {
        return retryEnabled;
    }
    
    public void setRetryEnabled(boolean retryEnabled) {
        this.retryEnabled = retryEnabled;
    }
    
    public FailureHandlingStrategy getFailureHandlingStrategy() {
        return failureHandlingStrategy;
    }
    
    public void setFailureHandlingStrategy(FailureHandlingStrategy failureHandlingStrategy) {
        this.failureHandlingStrategy = failureHandlingStrategy;
    }
    
    public DependencyHandlingStrategy getDependencyHandlingStrategy() {
        return dependencyHandlingStrategy;
    }
    
    public void setDependencyHandlingStrategy(DependencyHandlingStrategy dependencyHandlingStrategy) {
        this.dependencyHandlingStrategy = dependencyHandlingStrategy;
    }
    
    public long getRetryIntervalMs() {
        return retryIntervalMs;
    }
    
    public void setRetryIntervalMs(long retryIntervalMs) {
        this.retryIntervalMs = retryIntervalMs;
    }
    
    public int getExecutionTimeoutMinutes() {
        return executionTimeoutMinutes;
    }
    
    public void setExecutionTimeoutMinutes(int executionTimeoutMinutes) {
        this.executionTimeoutMinutes = executionTimeoutMinutes;
    }
    
    public ParallelConfig getDefaultParallelConfig() {
        return defaultParallelConfig;
    }
    
    public void setDefaultParallelConfig(ParallelConfig defaultParallelConfig) {
        this.defaultParallelConfig = defaultParallelConfig;
    }
    
    public boolean isReportEnabled() {
        return reportEnabled;
    }
    
    public void setReportEnabled(boolean reportEnabled) {
        this.reportEnabled = reportEnabled;
    }
    
    public boolean isScreenshotEnabled() {
        return screenshotEnabled;
    }
    
    public void setScreenshotEnabled(boolean screenshotEnabled) {
        this.screenshotEnabled = screenshotEnabled;
    }
    
    public boolean isScreenshotOnFailureOnly() {
        return screenshotOnFailureOnly;
    }
    
    public void setScreenshotOnFailureOnly(boolean screenshotOnFailureOnly) {
        this.screenshotOnFailureOnly = screenshotOnFailureOnly;
    }
    
    public boolean isVideoEnabled() {
        return videoEnabled;
    }
    
    public void setVideoEnabled(boolean videoEnabled) {
        this.videoEnabled = videoEnabled;
    }
    
    public boolean isDetailedLoggingEnabled() {
        return detailedLoggingEnabled;
    }
    
    public void setDetailedLoggingEnabled(boolean detailedLoggingEnabled) {
        this.detailedLoggingEnabled = detailedLoggingEnabled;
    }
    
    public boolean isSelfHealingEnabled() {
        return selfHealingEnabled;
    }
    
    public void setSelfHealingEnabled(boolean selfHealingEnabled) {
        this.selfHealingEnabled = selfHealingEnabled;
    }
    
    public TestLog.LogLevel getMinimumLogLevel() {
        return minimumLogLevel;
    }
    
    public void setMinimumLogLevel(TestLog.LogLevel minimumLogLevel) {
        this.minimumLogLevel = minimumLogLevel;
    }
    
    public Map<String, ExecutionEnvironment> getEnvironments() {
        return environments;
    }
    
    public void setEnvironments(Map<String, ExecutionEnvironment> environments) {
        this.environments = environments != null ? environments : new HashMap<>();
    }
    
    public List<String> getRetryableExceptions() {
        return retryableExceptions;
    }
    
    public void setRetryableExceptions(List<String> retryableExceptions) {
        this.retryableExceptions = retryableExceptions != null ? retryableExceptions : new ArrayList<>();
    }
    
    public Map<String, String> getCustomParameters() {
        return customParameters;
    }
    
    public void setCustomParameters(Map<String, String> customParameters) {
        this.customParameters = customParameters != null ? customParameters : new HashMap<>();
    }
    
    public ExecutionHooks getExecutionHooks() {
        return executionHooks;
    }
    
    public void setExecutionHooks(ExecutionHooks executionHooks) {
        this.executionHooks = executionHooks != null ? executionHooks : new ExecutionHooks();
    }
}


