ProjectStorageImpl.java
---------------------------------------
package com.cstestforge.service.storage.impl;

import com.cstestforge.model.project.Project;
import com.cstestforge.model.project.TestCase;
import com.cstestforge.model.project.TestSuite;
import com.cstestforge.framework.core.utils.CSConstants;
import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;
import com.cstestforge.service.storage.BackupService;
import com.cstestforge.service.storage.DataSerializer;
import com.cstestforge.service.storage.DataVersioningService;
import com.cstestforge.service.storage.FileLockManager;
import com.cstestforge.service.storage.StoragePathResolver;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Implementation of project data storage using file system.
 * This class provides operations for storing and retrieving project data
 * including projects, test suites, and test cases without using a database.
 * 
 * @author CSTestForge Team
 */
@Service
public class ProjectStorageImpl {

    private static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss");
    private static final String PROJECT_INDEX_FILE = "project_index.json";
    private static final String PROJECT_FILE_PREFIX = "project_";
    private static final String SUITE_FILE_PREFIX = "suite_";
    private static final String TESTCASE_FILE_PREFIX = "testcase_";
    private static final String FILE_EXTENSION = ".json";
    
    // Cache to improve performance and reduce file system access
    private final ConcurrentHashMap<String, Project> projectCache = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, TestSuite> suiteCache = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, TestCase> testCaseCache = new ConcurrentHashMap<>();
    
    // Thread safety for file operations
    private final ReadWriteLock projectIndexLock = new ReentrantReadWriteLock();
    private final ConcurrentHashMap<String, ReadWriteLock> projectLocks = new ConcurrentHashMap<>();
    
    @Autowired
    private StoragePathResolver pathResolver;
    
    @Autowired
    private DataSerializer dataSerializer;
    
    @Autowired
    private FileLockManager fileLockManager;
    
    @Autowired
    private BackupService backupService;
    
    @Autowired
    private DataVersioningService versioningService;
    
    /**
     * Initialize the project storage system.
     * Creates necessary directories if they don't exist.
     */
    public void initialize() {
        try {
            // Ensure base directory exists
            Path projectsBasePath = pathResolver.resolveProjectsBasePath();
            if (!Files.exists(projectsBasePath)) {
                Files.createDirectories(projectsBasePath);
                CSLogger.info("Created projects base directory at: " + projectsBasePath);
            }
            
            // Ensure project index file exists
            Path projectIndexPath = projectsBasePath.resolve(PROJECT_INDEX_FILE);
            if (!Files.exists(projectIndexPath)) {
                List<String> emptyIndex = new ArrayList<>();
                String serialized = dataSerializer.serialize(emptyIndex);
                Files.write(projectIndexPath, serialized.getBytes());
                CSLogger.info("Created initial project index file");
            }
        } catch (IOException e) {
            CSLogger.error("Failed to initialize project storage", e);
            throw new RuntimeException("Failed to initialize project storage", e);
        }
    }
    
    /**
     * Creates a new project and stores it in the file system.
     * 
     * @param project The project to create
     * @return The created project with a generated ID
     */
    public Project createProject(Project project) {
        if (project.getId() == null || project.getId().trim().isEmpty()) {
            project.setId(UUID.randomUUID().toString());
        }
        
        String projectId = project.getId();
        project.setCreatedAt(LocalDateTime.now());
        project.setUpdatedAt(LocalDateTime.now());
        
        try {
            // Create project directory
            Path projectDir = pathResolver.resolveProjectPath(projectId);
            if (!Files.exists(projectDir)) {
                Files.createDirectories(projectDir);
            }
            
            // Create suites directory
            Path suitesDir = projectDir.resolve("suites");
            if (!Files.exists(suitesDir)) {
                Files.createDirectories(suitesDir);
            }
            
            // Save project file
            saveProjectFile(project);
            
            // Update project index
            updateProjectIndex(projectId, true);
            
            // Add to cache
            projectCache.put(projectId, project);
            
            return project;
        } catch (IOException e) {
            CSLogger.error("Failed to create project: " + projectId, e);
            throw new RuntimeException("Failed to create project: " + projectId, e);
        }
    }
    
    /**
     * Updates an existing project.
     * 
     * @param project The project to update
     * @return The updated project
     */
    public Project updateProject(Project project) {
        String projectId = project.getId();
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty for update operation");
        }
        
        try {
            // Verify project exists
            Path projectFilePath = getProjectFilePath(projectId);
            if (!Files.exists(projectFilePath)) {
                throw new IllegalArgumentException("Project does not exist: " + projectId);
            }
            
            // Make a backup before updating
            backupService.backupFile(projectFilePath);
            
            // Update timestamp
            project.setUpdatedAt(LocalDateTime.now());
            
            // Save project file
            saveProjectFile(project);
            
            // Update cache
            projectCache.put(projectId, project);
            
            return project;
        } catch (IOException e) {
            CSLogger.error("Failed to update project: " + projectId, e);
            throw new RuntimeException("Failed to update project: " + projectId, e);
        }
    }
    
    /**
     * Deletes a project and all its associated test suites and test cases.
     * 
     * @param projectId The ID of the project to delete
     * @return True if the project was successfully deleted, false otherwise
     */
    public boolean deleteProject(String projectId) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        try {
            // Get project directory
            Path projectDir = pathResolver.resolveProjectPath(projectId);
            if (!Files.exists(projectDir)) {
                return false;
            }
            
            // Backup project directory before deletion
            backupService.backupDirectory(projectDir);
            
            // Remove from project index
            updateProjectIndex(projectId, false);
            
            // Delete project directory recursively
            CSFileUtils.deleteDirectoryRecursively(projectDir.toFile());
            
            // Remove from cache
            projectCache.remove(projectId);
            
            // Remove any suite and test case cache entries for this project
            suiteCache.entrySet().removeIf(entry -> entry.getKey().startsWith(projectId + "_"));
            testCaseCache.entrySet().removeIf(entry -> entry.getKey().startsWith(projectId + "_"));
            
            return true;
        } catch (IOException e) {
            CSLogger.error("Failed to delete project: " + projectId, e);
            throw new RuntimeException("Failed to delete project: " + projectId, e);
        }
    }
    
    /**
     * Retrieves a project by its ID.
     * 
     * @param projectId The ID of the project to retrieve
     * @return An Optional containing the project if found, or empty if not found
     */
    public Optional<Project> getProject(String projectId) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        // Check cache first
        Project cachedProject = projectCache.get(projectId);
        if (cachedProject != null) {
            return Optional.of(cachedProject);
        }
        
        try {
            Path projectFilePath = getProjectFilePath(projectId);
            if (!Files.exists(projectFilePath)) {
                return Optional.empty();
            }
            
            // Acquire read lock
            ReadWriteLock projectLock = getProjectLock(projectId);
            projectLock.readLock().lock();
            
            try {
                // Lock the file
                fileLockManager.acquireReadLock(projectFilePath);
                
                try {
                    // Read and deserialize project file
                    String content = new String(Files.readAllBytes(projectFilePath));
                    Project project = dataSerializer.deserialize(content, Project.class);
                    
                    // Cache the result
                    projectCache.put(projectId, project);
                    
                    return Optional.of(project);
                } finally {
                    fileLockManager.releaseReadLock(projectFilePath);
                }
            } finally {
                projectLock.readLock().unlock();
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read project: " + projectId, e);
            throw new RuntimeException("Failed to read project: " + projectId, e);
        }
    }
    
    /**
     * Lists all projects.
     * 
     * @return A list of all projects
     */
    public List<Project> listProjects() {
        try {
            List<String> projectIds = getProjectIndex();
            List<Project> projects = new ArrayList<>();
            
            for (String projectId : projectIds) {
                getProject(projectId).ifPresent(projects::add);
            }
            
            return projects;
        } catch (IOException e) {
            CSLogger.error("Failed to list projects", e);
            throw new RuntimeException("Failed to list projects", e);
        }
    }
    
    /**
     * Creates a new test suite within a project.
     * 
     * @param projectId The ID of the project
     * @param testSuite The test suite to create
     * @return The created test suite with a generated ID
     */
    public TestSuite createTestSuite(String projectId, TestSuite testSuite) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        // Verify project exists
        getProject(projectId).orElseThrow(() -> 
            new IllegalArgumentException("Project does not exist: " + projectId));
        
        if (testSuite.getId() == null || testSuite.getId().trim().isEmpty()) {
            testSuite.setId(UUID.randomUUID().toString());
        }
        
        String suiteId = testSuite.getId();
        testSuite.setProjectId(projectId);
        testSuite.setCreatedAt(LocalDateTime.now());
        testSuite.setUpdatedAt(LocalDateTime.now());
        
        try {
            // Create test suite directory
            Path suiteDir = getSuiteDirectory(projectId, suiteId);
            if (!Files.exists(suiteDir)) {
                Files.createDirectories(suiteDir);
            }
            
            // Save test suite file
            saveTestSuiteFile(testSuite);
            
            // Update parent project to include this suite
            updateProjectWithSuite(projectId, suiteId, true);
            
            // Add to cache
            suiteCache.put(getCacheKey(projectId, suiteId), testSuite);
            
            return testSuite;
        } catch (IOException e) {
            CSLogger.error("Failed to create test suite: " + suiteId + " in project: " + projectId, e);
            throw new RuntimeException("Failed to create test suite", e);
        }
    }
    
    /**
     * Updates an existing test suite.
     * 
     * @param projectId The ID of the project
     * @param testSuite The test suite to update
     * @return The updated test suite
     */
    public TestSuite updateTestSuite(String projectId, TestSuite testSuite) {
        String suiteId = testSuite.getId();
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Suite ID cannot be null or empty");
        }
        
        try {
            // Verify test suite exists
            Path suiteFilePath = getTestSuiteFilePath(projectId, suiteId);
            if (!Files.exists(suiteFilePath)) {
                throw new IllegalArgumentException("Test suite does not exist: " + suiteId);
            }
            
            // Make a backup before updating
            backupService.backupFile(suiteFilePath);
            
            // Update timestamp
            testSuite.setUpdatedAt(LocalDateTime.now());
            
            // Save test suite file
            saveTestSuiteFile(testSuite);
            
            // Update cache
            suiteCache.put(getCacheKey(projectId, suiteId), testSuite);
            
            return testSuite;
        } catch (IOException e) {
            CSLogger.error("Failed to update test suite: " + suiteId + " in project: " + projectId, e);
            throw new RuntimeException("Failed to update test suite", e);
        }
    }
    
    /**
     * Deletes a test suite and all its associated test cases.
     * 
     * @param projectId The ID of the project
     * @param suiteId The ID of the test suite to delete
     * @return True if the test suite was successfully deleted, false otherwise
     */
    public boolean deleteTestSuite(String projectId, String suiteId) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Suite ID cannot be null or empty");
        }
        
        try {
            // Get test suite directory
            Path suiteDir = getSuiteDirectory(projectId, suiteId);
            if (!Files.exists(suiteDir)) {
                return false;
            }
            
            // Backup test suite directory before deletion
            backupService.backupDirectory(suiteDir);
            
            // Update parent project to remove this suite
            updateProjectWithSuite(projectId, suiteId, false);
            
            // Delete test suite directory recursively
            CSFileUtils.deleteDirectoryRecursively(suiteDir.toFile());
            
            // Remove from cache
            suiteCache.remove(getCacheKey(projectId, suiteId));
            
            // Remove any test case cache entries for this suite
            testCaseCache.entrySet().removeIf(entry -> entry.getKey().startsWith(projectId + "_" + suiteId + "_"));
            
            return true;
        } catch (IOException e) {
            CSLogger.error("Failed to delete test suite: " + suiteId + " in project: " + projectId, e);
            throw new RuntimeException("Failed to delete test suite", e);
        }
    }
    
    /**
     * Retrieves a test suite by its ID.
     * 
     * @param projectId The ID of the project
     * @param suiteId The ID of the test suite to retrieve
     * @return An Optional containing the test suite if found, or empty if not found
     */
    public Optional<TestSuite> getTestSuite(String projectId, String suiteId) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Suite ID cannot be null or empty");
        }
        
        // Check cache first
        String cacheKey = getCacheKey(projectId, suiteId);
        TestSuite cachedSuite = suiteCache.get(cacheKey);
        if (cachedSuite != null) {
            return Optional.of(cachedSuite);
        }
        
        try {
            Path suiteFilePath = getTestSuiteFilePath(projectId, suiteId);
            if (!Files.exists(suiteFilePath)) {
                return Optional.empty();
            }
            
            // Lock the file
            fileLockManager.acquireReadLock(suiteFilePath);
            
            try {
                // Read and deserialize test suite file
                String content = new String(Files.readAllBytes(suiteFilePath));
                TestSuite testSuite = dataSerializer.deserialize(content, TestSuite.class);
                
                // Cache the result
                suiteCache.put(cacheKey, testSuite);
                
                return Optional.of(testSuite);
            } finally {
                fileLockManager.releaseReadLock(suiteFilePath);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read test suite: " + suiteId + " in project: " + projectId, e);
            throw new RuntimeException("Failed to read test suite", e);
        }
    }
    
    /**
     * Lists all test suites within a project.
     * 
     * @param projectId The ID of the project
     * @return A list of test suites
     */
    public List<TestSuite> listTestSuites(String projectId) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        try {
            // Get project to find suite IDs
            Optional<Project> projectOpt = getProject(projectId);
            if (!projectOpt.isPresent()) {
                return Collections.emptyList();
            }
            
            Project project = projectOpt.get();
            List<String> suiteIds = project.getTestSuiteIds();
            List<TestSuite> suites = new ArrayList<>();
            
            for (String suiteId : suiteIds) {
                getTestSuite(projectId, suiteId).ifPresent(suites::add);
            }
            
            return suites;
        } catch (Exception e) {
            CSLogger.error("Failed to list test suites for project: " + projectId, e);
            throw new RuntimeException("Failed to list test suites", e);
        }
    }
    
    /**
     * Creates a new test case within a test suite.
     * 
     * @param projectId The ID of the project
     * @param suiteId The ID of the test suite
     * @param testCase The test case to create
     * @return The created test case with a generated ID
     */
    public TestCase createTestCase(String projectId, String suiteId, TestCase testCase) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Suite ID cannot be null or empty");
        }
        
        // Verify test suite exists
        getTestSuite(projectId, suiteId).orElseThrow(() -> 
            new IllegalArgumentException("Test suite does not exist: " + suiteId));
        
        if (testCase.getId() == null || testCase.getId().trim().isEmpty()) {
            testCase.setId(UUID.randomUUID().toString());
        }
        
        String testCaseId = testCase.getId();
        testCase.setProjectId(projectId);
        testCase.setSuiteId(suiteId);
        testCase.setCreatedAt(LocalDateTime.now());
        testCase.setUpdatedAt(LocalDateTime.now());
        
        try {
            // Save test case file
            saveTestCaseFile(testCase);
            
            // Update parent test suite to include this test case
            updateTestSuiteWithTestCase(projectId, suiteId, testCaseId, true);
            
            // Add to cache
            testCaseCache.put(getCacheKey(projectId, suiteId, testCaseId), testCase);
            
            return testCase;
        } catch (IOException e) {
            CSLogger.error("Failed to create test case: " + testCaseId + " in suite: " + suiteId, e);
            throw new RuntimeException("Failed to create test case", e);
        }
    }
    
    /**
     * Updates an existing test case.
     * 
     * @param projectId The ID of the project
     * @param suiteId The ID of the test suite
     * @param testCase The test case to update
     * @return The updated test case
     */
    public TestCase updateTestCase(String projectId, String suiteId, TestCase testCase) {
        String testCaseId = testCase.getId();
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Suite ID cannot be null or empty");
        }
        if (testCaseId == null || testCaseId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Case ID cannot be null or empty");
        }
        
        try {
            // Verify test case exists
            Path testCaseFilePath = getTestCaseFilePath(projectId, suiteId, testCaseId);
            if (!Files.exists(testCaseFilePath)) {
                throw new IllegalArgumentException("Test case does not exist: " + testCaseId);
            }
            
            // Make a backup before updating
            backupService.backupFile(testCaseFilePath);
            
            // Create a new version
            versioningService.createVersion(testCaseFilePath, testCase.getVersion());
            
            // Update timestamp and increment version
            testCase.setUpdatedAt(LocalDateTime.now());
            testCase.setVersion(testCase.getVersion() + 1);
            
            // Save test case file
            saveTestCaseFile(testCase);
            
            // Update cache
            testCaseCache.put(getCacheKey(projectId, suiteId, testCaseId), testCase);
            
            return testCase;
        } catch (IOException e) {
            CSLogger.error("Failed to update test case: " + testCaseId + " in suite: " + suiteId, e);
            throw new RuntimeException("Failed to update test case", e);
        }
    }
    
    /**
     * Deletes a test case.
     * 
     * @param projectId The ID of the project
     * @param suiteId The ID of the test suite
     * @param testCaseId The ID of the test case to delete
     * @return True if the test case was successfully deleted, false otherwise
     */
    public boolean deleteTestCase(String projectId, String suiteId, String testCaseId) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Suite ID cannot be null or empty");
        }
        if (testCaseId == null || testCaseId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Case ID cannot be null or empty");
        }
        
        try {
            // Get test case file
            Path testCaseFilePath = getTestCaseFilePath(projectId, suiteId, testCaseId);
            if (!Files.exists(testCaseFilePath)) {
                return false;
            }
            
            // Backup test case file before deletion
            backupService.backupFile(testCaseFilePath);
            
            // Update parent test suite to remove this test case
            updateTestSuiteWithTestCase(projectId, suiteId, testCaseId, false);
            
            // Delete test case file
            Files.delete(testCaseFilePath);
            
            // Remove from cache
            testCaseCache.remove(getCacheKey(projectId, suiteId, testCaseId));
            
            return true;
        } catch (IOException e) {
            CSLogger.error("Failed to delete test case: " + testCaseId + " in suite: " + suiteId, e);
            throw new RuntimeException("Failed to delete test case", e);
        }
    }
    
    /**
     * Retrieves a test case by its ID.
     * 
     * @param projectId The ID of the project
     * @param suiteId The ID of the test suite
     * @param testCaseId The ID of the test case to retrieve
     * @return An Optional containing the test case if found, or empty if not found
     */
    public Optional<TestCase> getTestCase(String projectId, String suiteId, String testCaseId) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Suite ID cannot be null or empty");
        }
        if (testCaseId == null || testCaseId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Case ID cannot be null or empty");
        }
        
        // Check cache first
        String cacheKey = getCacheKey(projectId, suiteId, testCaseId);
        TestCase cachedTestCase = testCaseCache.get(cacheKey);
        if (cachedTestCase != null) {
            return Optional.of(cachedTestCase);
        }
        
        try {
            Path testCaseFilePath = getTestCaseFilePath(projectId, suiteId, testCaseId);
            if (!Files.exists(testCaseFilePath)) {
                return Optional.empty();
            }
            
            // Lock the file
            fileLockManager.acquireReadLock(testCaseFilePath);
            
            try {
                // Read and deserialize test case file
                String content = new String(Files.readAllBytes(testCaseFilePath));
                TestCase testCase = dataSerializer.deserialize(content, TestCase.class);
                
                // Cache the result
                testCaseCache.put(cacheKey, testCase);
                
                return Optional.of(testCase);
            } finally {
                fileLockManager.releaseReadLock(testCaseFilePath);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read test case: " + testCaseId + " in suite: " + suiteId, e);
            throw new RuntimeException("Failed to read test case", e);
        }
    }
    
    /**
     * Lists all test cases within a test suite.
     * 
     * @param projectId The ID of the project
     * @param suiteId The ID of the test suite
     * @return A list of test cases
     */
    public List<TestCase> listTestCases(String projectId, String suiteId) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test Suite ID cannot be null or empty");
        }
        
        try {
            // Get test suite to find test case IDs
            Optional<TestSuite> suiteOpt = getTestSuite(projectId, suiteId);
            if (!suiteOpt.isPresent()) {
                return Collections.emptyList();
            }
            
            TestSuite suite = suiteOpt.get();
            List<String> testCaseIds = suite.getTestCaseIds();
            List<TestCase> testCases = new ArrayList<>();
            
            for (String testCaseId : testCaseIds) {
                getTestCase(projectId, suiteId, testCaseId).ifPresent(testCases::add);
            }
            
            return testCases;
        } catch (Exception e) {
            CSLogger.error("Failed to list test cases for suite: " + suiteId, e);
            throw new RuntimeException("Failed to list test cases", e);
        }
    }
    
    /**
     * Searches for test cases matching the given criteria.
     * 
     * @param projectId The ID of the project (optional)
     * @param suiteId The ID of the test suite (optional)
     * @param searchText Text to search for in test case name or description
     * @param tags List of tags to filter by (optional)
     * @param status Test case status to filter by (optional)
     * @return A list of matching test cases
     */
    public List<TestCase> searchTestCases(String projectId, String suiteId, String searchText, List<String> tags, String status) {
        List<TestCase> results = new ArrayList<>();
        
        try {
            List<Project> projectsToSearch;
            if (projectId != null && !projectId.trim().isEmpty()) {
                // Search within single project
                getProject(projectId).ifPresent(p -> projectsToSearch = Collections.singletonList(p));
                projectsToSearch = getProject(projectId)
                    .map(Collections::singletonList)
                    .orElse(Collections.emptyList());
            } else {
                // Search all projects
                projectsToSearch = listProjects();
            }
            
            for (Project project : projectsToSearch) {
                List<TestSuite> suitesToSearch;
                if (suiteId != null && !suiteId.trim().isEmpty()) {
                    // Search within single suite
                    suitesToSearch = getTestSuite(project.getId(), suiteId)
                        .map(Collections::singletonList)
                        .orElse(Collections.emptyList());
                } else {
                    // Search all suites in project
                    suitesToSearch = listTestSuites(project.getId());
                }
                
                for (TestSuite suite : suitesToSearch) {
                    List<TestCase> testCases = listTestCases(project.getId(), suite.getId());
                    
                    // Apply filters
                    for (TestCase testCase : testCases) {
                        if (matchesSearchCriteria(testCase, searchText, tags, status)) {
                            results.add(testCase);
                        }
                    }
                }
            }
            
            return results;
        } catch (Exception e) {
            CSLogger.error("Failed to search test cases", e);
            throw new RuntimeException("Failed to search test cases", e);
        }
    }
    
    /**
     * Gets the list of project IDs from the project index file.
     * 
     * @return List of project IDs
     * @throws IOException If there is an error reading the index file
     */
    private List<String> getProjectIndex() throws IOException {
        Path projectIndexPath = pathResolver.resolveProjectsBasePath().resolve(PROJECT_INDEX_FILE);
        
        projectIndexLock.readLock().lock();
        try {
            fileLockManager.acquireReadLock(projectIndexPath);
            try {
                String content = new String(Files.readAllBytes(projectIndexPath));
                return dataSerializer.deserialize(content, List.class);
            } finally {
                fileLockManager.releaseReadLock(projectIndexPath);
            }
        } finally {
            projectIndexLock.readLock().unlock();
        }
    }
    
    /**
     * Updates the project index file, adding or removing a project ID.
     * 
     * @param projectId The project ID to add or remove
     * @param add True to add, false to remove
     * @throws IOException If there is an error updating the index file
     */
    private void updateProjectIndex(String projectId, boolean add) throws IOException {
        Path projectIndexPath = pathResolver.resolveProjectsBasePath().resolve(PROJECT_INDEX_FILE);
        
        projectIndexLock.writeLock().lock();
        try {
            // Make a backup before updating
            backupService.backupFile(projectIndexPath);
            
            fileLockManager.acquireWriteLock(projectIndexPath);
            try {
                // Read current index
                String content = new String(Files.readAllBytes(projectIndexPath));
                List<String> projectIds = dataSerializer.deserialize(content, List.class);
                
                // Update index
                if (add && !projectIds.contains(projectId)) {
                    projectIds.add(projectId);
                } else if (!add) {
                    projectIds.remove(projectId);
                }
                
                // Write updated index
                String serialized = dataSerializer.serialize(projectIds);
                Files.write(projectIndexPath, serialized.getBytes());
            } finally {
                fileLockManager.releaseWriteLock(projectIndexPath);
            }
        } finally {
            projectIndexLock.writeLock().unlock();
        }
    }
    
    /**
     * Updates a project to add or remove a test suite ID.
     * 
     * @param projectId The project ID
     * @param suiteId The test suite ID to add or remove
     * @param add True to add, false to remove
     * @throws IOException If there is an error updating the project
     */
    private void updateProjectWithSuite(String projectId, String suiteId, boolean add) throws IOException {
        getProject(projectId).ifPresent(project -> {
            List<String> suiteIds = project.getTestSuiteIds();
            if (suiteIds == null) {
                suiteIds = new ArrayList<>();
                project.setTestSuiteIds(suiteIds);
            }
            
            boolean modified = false;
            if (add && !suiteIds.contains(suiteId)) {
                suiteIds.add(suiteId);
                modified = true;
            } else if (!add) {
                modified = suiteIds.remove(suiteId);
            }
            
            if (modified) {
                project.setUpdatedAt(LocalDateTime.now());
                updateProject(project);
            }
        });
    }
    
    /**
     * Updates a test suite to add or remove a test case ID.
     * 
     * @param projectId The project ID
     * @param suiteId The test suite ID
     * @param testCaseId The test case ID to add or remove
     * @param add True to add, false to remove
     * @throws IOException If there is an error updating the test suite
     */
    private void updateTestSuiteWithTestCase(String projectId, String suiteId, String testCaseId, boolean add) throws IOException {
        getTestSuite(projectId, suiteId).ifPresent(suite -> {
            List<String> testCaseIds = suite.getTestCaseIds();
            if (testCaseIds == null) {
                testCaseIds = new ArrayList<>();
                suite.setTestCaseIds(testCaseIds);
            }
            
            boolean modified = false;
            if (add && !testCaseIds.contains(testCaseId)) {
                testCaseIds.add(testCaseId);
                modified = true;
            } else if (!add) {
                modified = testCaseIds.remove(testCaseId);
            }
            
            if (modified) {
                suite.setUpdatedAt(LocalDateTime.now());
                updateTestSuite(projectId, suite);
            }
        });
    }
    
    /**
     * Saves a project to the file system.
     * 
     * @param project The project to save
     * @throws IOException If there is an error saving the project
     */
    private void saveProjectFile(Project project) throws IOException {
        Path projectFilePath = getProjectFilePath(project.getId());
        
        // Make sure directory exists
        Files.createDirectories(projectFilePath.getParent());
        
        // Acquire write lock
        ReadWriteLock projectLock = getProjectLock(project.getId());
        projectLock.writeLock().lock();
        
        try {
            fileLockManager.acquireWriteLock(projectFilePath);
            try {
                // Serialize and write project
                String serialized = dataSerializer.serialize(project);
                Files.write(projectFilePath, serialized.getBytes());
            } finally {
                fileLockManager.releaseWriteLock(projectFilePath);
            }
        } finally {
            projectLock.writeLock().unlock();
        }
    }
    
    /**
     * Saves a test suite to the file system.
     * 
     * @param testSuite The test suite to save
     * @throws IOException If there is an error saving the test suite
     */
    private void saveTestSuiteFile(TestSuite testSuite) throws IOException {
        Path suiteFilePath = getTestSuiteFilePath(testSuite.getProjectId(), testSuite.getId());
        
        // Make sure directory exists
        Files.createDirectories(suiteFilePath.getParent());
        
        fileLockManager.acquireWriteLock(suiteFilePath);
        try {
            // Serialize and write test suite
            String serialized = dataSerializer.serialize(testSuite);
            Files.write(suiteFilePath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(suiteFilePath);
        }
    }
    
    /**
     * Saves a test case to the file system.
     * 
     * @param testCase The test case to save
     * @throws IOException If there is an error saving the test case
     */
    private void saveTestCaseFile(TestCase testCase) throws IOException {
        Path testCaseFilePath = getTestCaseFilePath(testCase.getProjectId(), testCase.getSuiteId(), testCase.getId());
        
        // Make sure directory exists
        Files.createDirectories(testCaseFilePath.getParent());
        
        fileLockManager.acquireWriteLock(testCaseFilePath);
        try {
            // Serialize and write test case
            String serialized = dataSerializer.serialize(testCase);
            Files.write(testCaseFilePath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(testCaseFilePath);
        }
    }
    
    /**
     * Gets the path to a project file.
     * 
     * @param projectId The project ID
     * @return Path to the project file
     */
    private Path getProjectFilePath(String projectId) {
        return pathResolver.resolveProjectPath(projectId).resolve(PROJECT_FILE_PREFIX + projectId + FILE_EXTENSION);
    }
    
    /**
     * Gets the directory for a test suite.
     * 
     * @param projectId The project ID
     * @param suiteId The test suite ID
     * @return Path to the test suite directory
     */
    private Path getSuiteDirectory(String projectId, String suiteId) {
        return pathResolver.resolveProjectPath(projectId).resolve("suites").resolve(suiteId);
    }
    
    /**
     * Gets the path to a test suite file.
     * 
     * @param projectId The project ID
     * @param suiteId The test suite ID
     * @return Path to the test suite file
     */
    private Path getTestSuiteFilePath(String projectId, String suiteId) {
        return getSuiteDirectory(projectId, suiteId).resolve(SUITE_FILE_PREFIX + suiteId + FILE_EXTENSION);
    }
    
    /**
     * Gets the path to a test case file.
     * 
     * @param projectId The project ID
     * @param suiteId The test suite ID
     * @param testCaseId The test case ID
     * @return Path to the test case file
     */
    private Path getTestCaseFilePath(String projectId, String suiteId, String testCaseId) {
        return getSuiteDirectory(projectId, suiteId).resolve(TESTCASE_FILE_PREFIX + testCaseId + FILE_EXTENSION);
    }
    
    /**
     * Gets or creates a lock for a project.
     * 
     * @param projectId The project ID
     * @return The project lock
     */
    private ReadWriteLock getProjectLock(String projectId) {
        return projectLocks.computeIfAbsent(projectId, k -> new ReentrantReadWriteLock());
    }
    
    /**
     * Creates a cache key for a test suite.
     * 
     * @param projectId The project ID
     * @param suiteId The test suite ID
     * @return The cache key
     */
    private String getCacheKey(String projectId, String suiteId) {
        return projectId + "_" + suiteId;
    }
    
    /**
     * Creates a cache key for a test case.
     * 
     * @param projectId The project ID
     * @param suiteId The test suite ID
     * @param testCaseId The test case ID
     * @return The cache key
     */
    private String getCacheKey(String projectId, String suiteId, String testCaseId) {
        return projectId + "_" + suiteId + "_" + testCaseId;
    }
    
    /**
     * Checks if a test case matches the search criteria.
     * 
     * @param testCase The test case to check
     * @param searchText Text to search for in name or description
     * @param tags Tags to filter by
     * @param status Status to filter by
     * @return True if the test case matches all criteria, false otherwise
     */
    private boolean matchesSearchCriteria(TestCase testCase, String searchText, List<String> tags, String status) {
        // Check search text in name and description
        boolean textMatches = searchText == null || searchText.trim().isEmpty() ||
            (testCase.getName() != null && testCase.getName().toLowerCase().contains(searchText.toLowerCase())) ||
            (testCase.getDescription() != null && testCase.getDescription().toLowerCase().contains(searchText.toLowerCase()));
        
        // Check tags
        boolean tagsMatch = tags == null || tags.isEmpty() ||
            (testCase.getTags() != null && testCase.getTags().stream().anyMatch(tags::contains));
        
        // Check status
        boolean statusMatches = status == null || status.trim().isEmpty() ||
            (testCase.getStatus() != null && testCase.getStatus().equalsIgnoreCase(status));
        
        return textMatches && tagsMatch && statusMatches;
    }
    
    /**
     * Clears the caches for improved memory management.
     * This should be called periodically to prevent the cache from growing too large.
     */
    public void clearCaches() {
        projectCache.clear();
        suiteCache.clear();
        testCaseCache.clear();
        CSLogger.info("Cleared all storage caches");
    }
    
    /**
     * Prunes old cache entries that haven't been accessed recently.
     * 
     * @param maxAge The maximum age in milliseconds for cache entries
     */
    public void pruneCache(long maxAge) {
        long now = System.currentTimeMillis();
        
        // Implementation would depend on tracking access times for cache entries
        // This is a simplified version that just clears all caches
        clearCaches();
    }
    
    /**
     * Performs maintenance tasks on the storage system.
     * This includes cleaning up temporary files, pruning caches, etc.
     */
    public void performMaintenance() {
        try {
            // Clean up temp backup directories older than 30 days
            Path backupsDir = pathResolver.resolveProjectsBasePath().resolve("backups");
            if (Files.exists(backupsDir)) {
                try (Stream<Path> paths = Files.list(backupsDir)) {
                    paths.filter(Files::isDirectory)
                        .filter(path -> {
                            try {
                                return Files.getLastModifiedTime(path).toMillis() < 
                                    System.currentTimeMillis() - (30 * 24 * 60 * 60 * 1000L);
                            } catch (IOException e) {
                                return false;
                            }
                        })
                        .forEach(path -> {
                            try {
                                CSFileUtils.deleteDirectoryRecursively(path.toFile());
                            } catch (IOException e) {
                                CSLogger.warn("Failed to delete old backup directory: " + path, e);
                            }
                        });
                }
            }
            
            // Prune cache
            pruneCache(24 * 60 * 60 * 1000L); // 24 hours
            
            CSLogger.info("Storage maintenance completed successfully");
        } catch (Exception e) {
            CSLogger.error("Error during storage maintenance", e);
        }
    }
}



TestResultsStorageImpl.java
--------------------------------------------

package com.cstestforge.service.storage.impl;

import com.cstestforge.framework.core.reporting.CSAttachment;
import com.cstestforge.framework.core.reporting.CSScreenshot;
import com.cstestforge.framework.core.reporting.CSTestCase;
import com.cstestforge.framework.core.reporting.CSTestResult;
import com.cstestforge.framework.core.reporting.CSTestStep;
import com.cstestforge.framework.core.reporting.CSTestSuite;
import com.cstestforge.framework.core.utils.CSConstants;
import com.cstestforge.framework.core.utils.CSDateUtils;
import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;
import com.cstestforge.service.storage.BackupService;
import com.cstestforge.service.storage.DataCompressionService;
import com.cstestforge.service.storage.DataSerializer;
import com.cstestforge.service.storage.FileLockManager;
import com.cstestforge.service.storage.StoragePathResolver;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

/**
 * Implementation of test results storage using the file system.
 * This class provides operations for storing and retrieving test execution results
 * including test suites, test cases, test steps, screenshots, videos, and logs
 * without relying on any external database systems.
 * 
 * @author CSTestForge Team
 */
@Service
public class TestResultsStorageImpl {

    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd");
    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HHmmss");
    private static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss");
    
    private static final String RESULTS_DIR = "results";
    private static final String RUNS_DIR = "runs";
    private static final String SCREENSHOTS_DIR = "screenshots";
    private static final String VIDEOS_DIR = "videos";
    private static final String ATTACHMENTS_DIR = "attachments";
    private static final String LOGS_DIR = "logs";
    private static final String METRICS_DIR = "metrics";
    
    private static final String TEST_RUN_PREFIX = "run_";
    private static final String SUITE_PREFIX = "suite_";
    private static final String CASE_PREFIX = "case_";
    private static final String STEP_PREFIX = "step_";
    private static final String LOG_PREFIX = "log_";
    private static final String METRIC_PREFIX = "metric_";
    
    private static final String JSON_EXTENSION = ".json";
    private static final String LOG_EXTENSION = ".log";
    private static final String PNG_EXTENSION = ".png";
    private static final String MP4_EXTENSION = ".mp4";
    private static final String ZIP_EXTENSION = ".zip";
    
    // Cache for improved performance
    private final ConcurrentHashMap<String, CSTestResult> testRunCache = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, List<String>> testRunIndexCache = new ConcurrentHashMap<>();
    private final AtomicInteger testRunCount = new AtomicInteger(0);
    
    @Autowired
    private StoragePathResolver pathResolver;
    
    @Autowired
    private DataSerializer dataSerializer;
    
    @Autowired
    private FileLockManager fileLockManager;
    
    @Autowired
    private BackupService backupService;
    
    @Autowired
    private DataCompressionService compressionService;
    
    /**
     * Initialize the test results storage system.
     * Creates necessary directories if they don't exist.
     */
    public void initialize() {
        try {
            // Ensure base directories exist
            Path resultsBasePath = pathResolver.resolveResultsBasePath();
            if (!Files.exists(resultsBasePath)) {
                Files.createDirectories(resultsBasePath);
                CSLogger.info("Created results base directory at: " + resultsBasePath);
            }
            
            // Create runs directory
            Path runsPath = resultsBasePath.resolve(RUNS_DIR);
            if (!Files.exists(runsPath)) {
                Files.createDirectories(runsPath);
            }
            
            // Create screenshots directory
            Path screenshotsPath = resultsBasePath.resolve(SCREENSHOTS_DIR);
            if (!Files.exists(screenshotsPath)) {
                Files.createDirectories(screenshotsPath);
            }
            
            // Create videos directory
            Path videosPath = resultsBasePath.resolve(VIDEOS_DIR);
            if (!Files.exists(videosPath)) {
                Files.createDirectories(videosPath);
            }
            
            // Create attachments directory
            Path attachmentsPath = resultsBasePath.resolve(ATTACHMENTS_DIR);
            if (!Files.exists(attachmentsPath)) {
                Files.createDirectories(attachmentsPath);
            }
            
            // Create logs directory
            Path logsPath = resultsBasePath.resolve(LOGS_DIR);
            if (!Files.exists(logsPath)) {
                Files.createDirectories(logsPath);
            }
            
            // Create metrics directory
            Path metricsPath = resultsBasePath.resolve(METRICS_DIR);
            if (!Files.exists(metricsPath)) {
                Files.createDirectories(metricsPath);
            }
            
            // Update test run count based on existing runs
            updateTestRunCount();
            
            CSLogger.info("Test results storage initialized successfully");
        } catch (IOException e) {
            CSLogger.error("Failed to initialize test results storage", e);
            throw new RuntimeException("Failed to initialize test results storage", e);
        }
    }
    
    /**
     * Creates a new test run with the given result.
     * 
     * @param testResult The test result to store
     * @return The created test result with assigned ID and paths
     */
    public CSTestResult createTestRun(CSTestResult testResult) {
        // Generate ID if not provided
        if (testResult.getId() == null || testResult.getId().trim().isEmpty()) {
            testResult.setId(generateTestRunId());
        }
        
        String runId = testResult.getId();
        testResult.setCreatedAt(LocalDateTime.now());
        testResult.setUpdatedAt(LocalDateTime.now());
        
        try {
            // Create test run directory
            Path runDir = getTestRunDirectory(runId);
            if (!Files.exists(runDir)) {
                Files.createDirectories(runDir);
            }
            
            // Create subdirectories for artifacts
            createTestRunSubdirectories(runDir);
            
            // Process test suites
            processTestSuites(testResult, runDir);
            
            // Save test run file
            saveTestRunFile(testResult);
            
            // Update test run index
            updateTestRunIndex(runId, testResult.getProjectId(), testResult.getStartTime());
            
            // Add to cache
            testRunCache.put(runId, testResult);
            
            // Increment test run count
            testRunCount.incrementAndGet();
            
            return testResult;
        } catch (IOException e) {
            CSLogger.error("Failed to create test run: " + runId, e);
            throw new RuntimeException("Failed to create test run: " + runId, e);
        }
    }
    
    /**
     * Updates an existing test run.
     * 
     * @param testResult The test result to update
     * @return The updated test result
     */
    public CSTestResult updateTestRun(CSTestResult testResult) {
        String runId = testResult.getId();
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty for update operation");
        }
        
        try {
            // Verify test run exists
            Path testRunFilePath = getTestRunFilePath(runId);
            if (!Files.exists(testRunFilePath)) {
                throw new IllegalArgumentException("Test run does not exist: " + runId);
            }
            
            // Make a backup before updating
            backupService.backupFile(testRunFilePath);
            
            // Update timestamp
            testResult.setUpdatedAt(LocalDateTime.now());
            
            // Process test suites (may have new data)
            Path runDir = getTestRunDirectory(runId);
            processTestSuites(testResult, runDir);
            
            // Save test run file
            saveTestRunFile(testResult);
            
            // Update cache
            testRunCache.put(runId, testResult);
            
            return testResult;
        } catch (IOException e) {
            CSLogger.error("Failed to update test run: " + runId, e);
            throw new RuntimeException("Failed to update test run: " + runId, e);
        }
    }
    
    /**
     * Appends a test suite to an existing test run.
     * 
     * @param runId The ID of the test run
     * @param testSuite The test suite to append
     * @return The updated test suite with ID and paths assigned
     */
    public CSTestSuite appendTestSuite(String runId, CSTestSuite testSuite) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        try {
            // Get test run
            CSTestResult testResult = getTestRun(runId)
                .orElseThrow(() -> new IllegalArgumentException("Test run not found: " + runId));
            
            // Generate ID if not provided
            if (testSuite.getId() == null || testSuite.getId().trim().isEmpty()) {
                testSuite.setId(UUID.randomUUID().toString());
            }
            
            // Set timestamps
            testSuite.setCreatedAt(LocalDateTime.now());
            testSuite.setUpdatedAt(LocalDateTime.now());
            
            // Process test case hierarchy
            Path runDir = getTestRunDirectory(runId);
            Path suiteDir = runDir.resolve(SUITE_PREFIX + testSuite.getId());
            if (!Files.exists(suiteDir)) {
                Files.createDirectories(suiteDir);
            }
            
            processTestCases(testSuite, suiteDir);
            
            // Save test suite file
            saveTestSuiteFile(runId, testSuite);
            
            // Update the parent test run
            List<CSTestSuite> testSuites = testResult.getTestSuites();
            if (testSuites == null) {
                testSuites = new ArrayList<>();
                testResult.setTestSuites(testSuites);
            }
            
            // Remove existing suite with same ID if present
            testSuites.removeIf(suite -> suite.getId().equals(testSuite.getId()));
            
            // Add the new/updated suite
            testSuites.add(testSuite);
            
            // Update the test run
            testResult.setUpdatedAt(LocalDateTime.now());
            saveTestRunFile(testResult);
            
            // Update cache
            testRunCache.put(runId, testResult);
            
            return testSuite;
        } catch (IOException e) {
            CSLogger.error("Failed to append test suite to run: " + runId, e);
            throw new RuntimeException("Failed to append test suite to run: " + runId, e);
        }
    }
    
    /**
     * Appends a test case to an existing test suite.
     * 
     * @param runId The ID of the test run
     * @param suiteId The ID of the test suite
     * @param testCase The test case to append
     * @return The updated test case with ID and paths assigned
     */
    public CSTestCase appendTestCase(String runId, String suiteId, CSTestCase testCase) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test suite ID cannot be null or empty");
        }
        
        try {
            // Get test run
            CSTestResult testResult = getTestRun(runId)
                .orElseThrow(() -> new IllegalArgumentException("Test run not found: " + runId));
            
            // Find test suite
            CSTestSuite testSuite = testResult.getTestSuites().stream()
                .filter(suite -> suite.getId().equals(suiteId))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Test suite not found: " + suiteId));
            
            // Generate ID if not provided
            if (testCase.getId() == null || testCase.getId().trim().isEmpty()) {
                testCase.setId(UUID.randomUUID().toString());
            }
            
            // Set timestamps
            testCase.setCreatedAt(LocalDateTime.now());
            testCase.setUpdatedAt(LocalDateTime.now());
            
            // Process test steps
            Path runDir = getTestRunDirectory(runId);
            Path suiteDir = runDir.resolve(SUITE_PREFIX + suiteId);
            Path caseDir = suiteDir.resolve(CASE_PREFIX + testCase.getId());
            if (!Files.exists(caseDir)) {
                Files.createDirectories(caseDir);
            }
            
            processTestSteps(testCase, caseDir, runId);
            
            // Save test case file
            saveTestCaseFile(runId, suiteId, testCase);
            
            // Update the parent test suite
            List<CSTestCase> testCases = testSuite.getTestCases();
            if (testCases == null) {
                testCases = new ArrayList<>();
                testSuite.setTestCases(testCases);
            }
            
            // Remove existing case with same ID if present
            testCases.removeIf(tc -> tc.getId().equals(testCase.getId()));
            
            // Add the new/updated case
            testCases.add(testCase);
            
            // Update the test suite
            testSuite.setUpdatedAt(LocalDateTime.now());
            saveTestSuiteFile(runId, testSuite);
            
            // Update test run
            testResult.setUpdatedAt(LocalDateTime.now());
            saveTestRunFile(testResult);
            
            // Update cache
            testRunCache.put(runId, testResult);
            
            return testCase;
        } catch (IOException e) {
            CSLogger.error("Failed to append test case to suite: " + suiteId + " in run: " + runId, e);
            throw new RuntimeException("Failed to append test case", e);
        }
    }
    
    /**
     * Appends a test step to an existing test case.
     * 
     * @param runId The ID of the test run
     * @param suiteId The ID of the test suite
     * @param caseId The ID of the test case
     * @param testStep The test step to append
     * @return The updated test step with ID and paths assigned
     */
    public CSTestStep appendTestStep(String runId, String suiteId, String caseId, CSTestStep testStep) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test suite ID cannot be null or empty");
        }
        if (caseId == null || caseId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test case ID cannot be null or empty");
        }
        
        try {
            // Get test run
            CSTestResult testResult = getTestRun(runId)
                .orElseThrow(() -> new IllegalArgumentException("Test run not found: " + runId));
            
            // Find test suite
            CSTestSuite testSuite = testResult.getTestSuites().stream()
                .filter(suite -> suite.getId().equals(suiteId))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Test suite not found: " + suiteId));
            
            // Find test case
            CSTestCase testCase = testSuite.getTestCases().filter(tc -> tc.getId().equals(caseId))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Test case not found: " + caseId));
            
            // Generate ID if not provided
            if (testStep.getId() == null || testStep.getId().trim().isEmpty()) {
                testStep.setId(UUID.randomUUID().toString());
            }
            
            // Set timestamps
            testStep.setCreatedAt(LocalDateTime.now());
            testStep.setUpdatedAt(LocalDateTime.now());
            
            // Process screenshots and attachments
            Path runDir = getTestRunDirectory(runId);
            Path suiteDir = runDir.resolve(SUITE_PREFIX + suiteId);
            Path caseDir = suiteDir.resolve(CASE_PREFIX + caseId);
            Path stepDir = caseDir.resolve(STEP_PREFIX + testStep.getId());
            if (!Files.exists(stepDir)) {
                Files.createDirectories(stepDir);
            }
            
            processScreenshots(testStep, stepDir, runId);
            processAttachments(testStep, stepDir, runId);
            
            // Save test step file
            saveTestStepFile(runId, suiteId, caseId, testStep);
            
            // Update the parent test case
            List<CSTestStep> testSteps = testCase.getTestSteps();
            if (testSteps == null) {
                testSteps = new ArrayList<>();
                testCase.setTestSteps(testSteps);
            }
            
            // Remove existing step with same ID if present
            testSteps.removeIf(step -> step.getId().equals(testStep.getId()));
            
            // Add the new/updated step
            testSteps.add(testStep);
            
            // Update the test case
            testCase.setUpdatedAt(LocalDateTime.now());
            saveTestCaseFile(runId, suiteId, testCase);
            
            // Update test suite and run timestamps
            testSuite.setUpdatedAt(LocalDateTime.now());
            saveTestSuiteFile(runId, testSuite);
            
            testResult.setUpdatedAt(LocalDateTime.now());
            saveTestRunFile(testResult);
            
            // Update cache
            testRunCache.put(runId, testResult);
            
            return testStep;
        } catch (IOException e) {
            CSLogger.error("Failed to append test step to case: " + caseId + " in suite: " + suiteId + " in run: " + runId, e);
            throw new RuntimeException("Failed to append test step", e);
        }
    }
    
    /**
     * Saves a screenshot as part of a test step.
     * 
     * @param runId The ID of the test run
     * @param suiteId The ID of the test suite
     * @param caseId The ID of the test case
     * @param stepId The ID of the test step
     * @param screenshot The screenshot to save
     * @return The updated screenshot with file path assigned
     */
    public CSScreenshot saveScreenshot(String runId, String suiteId, String caseId, String stepId, CSScreenshot screenshot) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        try {
            // Generate ID if not provided
            if (screenshot.getId() == null || screenshot.getId().trim().isEmpty()) {
                screenshot.setId(UUID.randomUUID().toString());
            }
            
            String screenshotId = screenshot.getId();
            
            // Set timestamp
            screenshot.setTimestamp(LocalDateTime.now());
            
            // Determine file path
            Path screenshotsDir = pathResolver.resolveResultsBasePath().resolve(SCREENSHOTS_DIR);
            if (!Files.exists(screenshotsDir)) {
                Files.createDirectories(screenshotsDir);
            }
            
            String fileName = runId + "_" + screenshotId + PNG_EXTENSION;
            Path screenshotPath = screenshotsDir.resolve(fileName);
            
            // Save the image data
            if (screenshot.getBase64Data() != null && !screenshot.getBase64Data().isEmpty()) {
                byte[] imageData = Base64.getDecoder().decode(screenshot.getBase64Data());
                Files.write(screenshotPath, imageData);
                
                // Clear base64 data to save space once saved to disk
                screenshot.setBase64Data(null);
            } else if (screenshot.getImageData() != null && screenshot.getImageData().length > 0) {
                Files.write(screenshotPath, screenshot.getImageData());
                
                // Clear image data to save space once saved to disk
                screenshot.setImageData(null);
            } else {
                throw new IllegalArgumentException("Screenshot must contain either base64Data or imageData");
            }
            
            // Set file path
            screenshot.setFilePath(SCREENSHOTS_DIR + "/" + fileName);
            
            // Get test step and update
            Path runDir = getTestRunDirectory(runId);
            Path suiteDir = runDir.resolve(SUITE_PREFIX + suiteId);
            Path caseDir = suiteDir.resolve(CASE_PREFIX + caseId);
            Path stepDir = caseDir.resolve(STEP_PREFIX + stepId);
            Path stepFilePath = stepDir.resolve(STEP_PREFIX + stepId + JSON_EXTENSION);
            
            if (Files.exists(stepFilePath)) {
                fileLockManager.acquireReadLock(stepFilePath);
                try {
                    String content = new String(Files.readAllBytes(stepFilePath));
                    CSTestStep testStep = dataSerializer.deserialize(content, CSTestStep.class);
                    
                    List<CSScreenshot> screenshots = testStep.getScreenshots();
                    if (screenshots == null) {
                        screenshots = new ArrayList<>();
                        testStep.setScreenshots(screenshots);
                    }
                    
                    // Remove existing screenshot with same ID if present
                    screenshots.removeIf(ss -> ss.getId().equals(screenshotId));
                    
                    // Add the new screenshot
                    screenshots.add(screenshot);
                    
                    // Update test step
                    testStep.setUpdatedAt(LocalDateTime.now());
                    saveTestStepFile(runId, suiteId, caseId, testStep);
                } finally {
                    fileLockManager.releaseReadLock(stepFilePath);
                }
            }
            
            return screenshot;
        } catch (IOException e) {
            CSLogger.error("Failed to save screenshot for step: " + stepId, e);
            throw new RuntimeException("Failed to save screenshot", e);
        }
    }
    
    /**
     * Saves an attachment as part of a test step.
     * 
     * @param runId The ID of the test run
     * @param suiteId The ID of the test suite
     * @param caseId The ID of the test case
     * @param stepId The ID of the test step
     * @param attachment The attachment to save
     * @return The updated attachment with file path assigned
     */
    public CSAttachment saveAttachment(String runId, String suiteId, String caseId, String stepId, CSAttachment attachment) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        try {
            // Generate ID if not provided
            if (attachment.getId() == null || attachment.getId().trim().isEmpty()) {
                attachment.setId(UUID.randomUUID().toString());
            }
            
            String attachmentId = attachment.getId();
            
            // Set timestamp
            attachment.setTimestamp(LocalDateTime.now());
            
            // Determine file path
            Path attachmentsDir = pathResolver.resolveResultsBasePath().resolve(ATTACHMENTS_DIR);
            if (!Files.exists(attachmentsDir)) {
                Files.createDirectories(attachmentsDir);
            }
            
            String fileName = runId + "_" + attachmentId + "_" + sanitizeFileName(attachment.getName());
            Path attachmentPath = attachmentsDir.resolve(fileName);
            
            // Save the attachment data
            if (attachment.getBase64Data() != null && !attachment.getBase64Data().isEmpty()) {
                byte[] fileData = Base64.getDecoder().decode(attachment.getBase64Data());
                Files.write(attachmentPath, fileData);
                
                // Clear base64 data to save space once saved to disk
                attachment.setBase64Data(null);
            } else if (attachment.getFileData() != null && attachment.getFileData().length > 0) {
                Files.write(attachmentPath, attachment.getFileData());
                
                // Clear file data to save space once saved to disk
                attachment.setFileData(null);
            } else {
                throw new IllegalArgumentException("Attachment must contain either base64Data or fileData");
            }
            
            // Set file path
            attachment.setFilePath(ATTACHMENTS_DIR + "/" + fileName);
            
            // Get test step and update
            Path runDir = getTestRunDirectory(runId);
            Path suiteDir = runDir.resolve(SUITE_PREFIX + suiteId);
            Path caseDir = suiteDir.resolve(CASE_PREFIX + caseId);
            Path stepDir = caseDir.resolve(STEP_PREFIX + stepId);
            Path stepFilePath = stepDir.resolve(STEP_PREFIX + stepId + JSON_EXTENSION);
            
            if (Files.exists(stepFilePath)) {
                fileLockManager.acquireReadLock(stepFilePath);
                try {
                    String content = new String(Files.readAllBytes(stepFilePath));
                    CSTestStep testStep = dataSerializer.deserialize(content, CSTestStep.class);
                    
                    List<CSAttachment> attachments = testStep.getAttachments();
                    if (attachments == null) {
                        attachments = new ArrayList<>();
                        testStep.setAttachments(attachments);
                    }
                    
                    // Remove existing attachment with same ID if present
                    attachments.removeIf(att -> att.getId().equals(attachmentId));
                    
                    // Add the new attachment
                    attachments.add(attachment);
                    
                    // Update test step
                    testStep.setUpdatedAt(LocalDateTime.now());
                    saveTestStepFile(runId, suiteId, caseId, testStep);
                } finally {
                    fileLockManager.releaseReadLock(stepFilePath);
                }
            }
            
            return attachment;
        } catch (IOException e) {
            CSLogger.error("Failed to save attachment for step: " + stepId, e);
            throw new RuntimeException("Failed to save attachment", e);
        }
    }
    
    /**
     * Appends log entries to a test run's log file.
     * 
     * @param runId The ID of the test run
     * @param logEntries The log entries to append
     */
    public void appendLogs(String runId, List<String> logEntries) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        if (logEntries == null || logEntries.isEmpty()) {
            return;
        }
        
        try {
            // Determine log file path
            Path logsDir = pathResolver.resolveResultsBasePath().resolve(LOGS_DIR);
            if (!Files.exists(logsDir)) {
                Files.createDirectories(logsDir);
            }
            
            Path logFilePath = logsDir.resolve(LOG_PREFIX + runId + LOG_EXTENSION);
            
            // Lock the file for writing
            fileLockManager.acquireWriteLock(logFilePath);
            try {
                // Append log entries
                Files.write(
                    logFilePath, 
                    logEntries.stream()
                        .map(entry -> CSDateUtils.formatTimestamp(LocalDateTime.now()) + " " + entry)
                        .collect(Collectors.joining(System.lineSeparator(), "", System.lineSeparator()))
                        .getBytes(),
                    Files.exists(logFilePath) ? 
                        java.nio.file.StandardOpenOption.APPEND : 
                        java.nio.file.StandardOpenOption.CREATE
                );
            } finally {
                fileLockManager.releaseWriteLock(logFilePath);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to append logs for run: " + runId, e);
            throw new RuntimeException("Failed to append logs", e);
        }
    }
    
    /**
     * Updates the metrics for a test run.
     * 
     * @param runId The ID of the test run
     * @param metricName The name of the metric
     * @param metricData The metric data to store
     */
    public void updateMetric(String runId, String metricName, Object metricData) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        if (metricName == null || metricName.trim().isEmpty()) {
            throw new IllegalArgumentException("Metric name cannot be null or empty");
        }
        
        try {
            // Determine metrics directory
            Path metricsDir = pathResolver.resolveResultsBasePath().resolve(METRICS_DIR);
            if (!Files.exists(metricsDir)) {
                Files.createDirectories(metricsDir);
            }
            
            // Create run metrics directory if it doesn't exist
            Path runMetricsDir = metricsDir.resolve(runId);
            if (!Files.exists(runMetricsDir)) {
                Files.createDirectories(runMetricsDir);
            }
            
            // Determine metric file path
            Path metricFilePath = runMetricsDir.resolve(METRIC_PREFIX + sanitizeFileName(metricName) + JSON_EXTENSION);
            
            // Lock the file for writing
            fileLockManager.acquireWriteLock(metricFilePath);
            try {
                // Serialize and save metric data
                String serialized = dataSerializer.serialize(metricData);
                Files.write(metricFilePath, serialized.getBytes());
            } finally {
                fileLockManager.releaseWriteLock(metricFilePath);
            }
            
            // Update test run to include this metric
            getTestRun(runId).ifPresent(testResult -> {
                Map<String, String> metrics = testResult.getMetrics();
                if (metrics == null) {
                    metrics = new HashMap<>();
                    testResult.setMetrics(metrics);
                }
                
                metrics.put(metricName, METRICS_DIR + "/" + runId + "/" + METRIC_PREFIX + sanitizeFileName(metricName) + JSON_EXTENSION);
                
                // Update the test run
                testResult.setUpdatedAt(LocalDateTime.now());
                try {
                    saveTestRunFile(testResult);
                    
                    // Update cache
                    testRunCache.put(runId, testResult);
                } catch (IOException e) {
                    CSLogger.error("Failed to update test run with metric: " + metricName, e);
                }
            });
        } catch (IOException e) {
            CSLogger.error("Failed to update metric: " + metricName + " for run: " + runId, e);
            throw new RuntimeException("Failed to update metric", e);
        }
    }
    
    /**
     * Saves a video recording as part of a test run.
     * 
     * @param runId The ID of the test run
     * @param videoName The name of the video
     * @param videoData The video data to save
     * @return The file path where the video was saved
     */
    public String saveVideo(String runId, String videoName, byte[] videoData) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        if (videoName == null || videoName.trim().isEmpty()) {
            throw new IllegalArgumentException("Video name cannot be null or empty");
        }
        
        if (videoData == null || videoData.length == 0) {
            throw new IllegalArgumentException("Video data cannot be null or empty");
        }
        
        try {
            // Determine videos directory
            Path videosDir = pathResolver.resolveResultsBasePath().resolve(VIDEOS_DIR);
            if (!Files.exists(videosDir)) {
                Files.createDirectories(videosDir);
            }
            
            // Determine video file path
            String fileName = runId + "_" + sanitizeFileName(videoName) + MP4_EXTENSION;
            Path videoFilePath = videosDir.resolve(fileName);
            
            // Save the video data
            Files.write(videoFilePath, videoData);
            
            // Update test run to include this video
            getTestRun(runId).ifPresent(testResult -> {
                List<String> videos = testResult.getVideos();
                if (videos == null) {
                    videos = new ArrayList<>();
                    testResult.setVideos(videos);
                }
                
                String videoPath = VIDEOS_DIR + "/" + fileName;
                if (!videos.contains(videoPath)) {
                    videos.add(videoPath);
                }
                
                // Update the test run
                testResult.setUpdatedAt(LocalDateTime.now());
                try {
                    saveTestRunFile(testResult);
                    
                    // Update cache
                    testRunCache.put(runId, testResult);
                } catch (IOException e) {
                    CSLogger.error("Failed to update test run with video: " + videoName, e);
                }
            });
            
            return VIDEOS_DIR + "/" + fileName;
        } catch (IOException e) {
            CSLogger.error("Failed to save video: " + videoName + " for run: " + runId, e);
            throw new RuntimeException("Failed to save video", e);
        }
    }
    
    /**
     * Finalizes a test run, compressing logs and updating final status.
     * 
     * @param runId The ID of the test run
     * @param status The final status of the test run
     * @return The finalized test result
     */
    public CSTestResult finalizeTestRun(String runId, String status) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        try {
            // Get test run
            CSTestResult testResult = getTestRun(runId)
                .orElseThrow(() -> new IllegalArgumentException("Test run not found: " + runId));
            
            // Update status and end time
            testResult.setStatus(status);
            testResult.setEndTime(LocalDateTime.now());
            testResult.setUpdatedAt(LocalDateTime.now());
            
            // Compress logs
            Path logsDir = pathResolver.resolveResultsBasePath().resolve(LOGS_DIR);
            Path logFilePath = logsDir.resolve(LOG_PREFIX + runId + LOG_EXTENSION);
            
            if (Files.exists(logFilePath)) {
                // Compress log file
                byte[] compressedLogs = compressionService.compressFile(logFilePath.toFile());
                
                // Save compressed logs
                Path compressedLogPath = logsDir.resolve(LOG_PREFIX + runId + ".gz");
                Files.write(compressedLogPath, compressedLogs);
                
                // Delete original log file
                Files.delete(logFilePath);
                
                // Update log path in test result
                testResult.setLogFile(LOGS_DIR + "/" + LOG_PREFIX + runId + ".gz");
            }
            
            // Calculate final metrics
            calculateFinalMetrics(testResult);
            
            // Save test run file
            saveTestRunFile(testResult);
            
            // Update cache
            testRunCache.put(runId, testResult);
            
            return testResult;
        } catch (IOException e) {
            CSLogger.error("Failed to finalize test run: " + runId, e);
            throw new RuntimeException("Failed to finalize test run", e);
        }
    }
    
    /**
     * Creates a ZIP archive of a test run for export or sharing.
     * 
     * @param runId The ID of the test run
     * @return The path to the created ZIP file
     */
    public Path createTestRunArchive(String runId) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        try {
            // Get test run
            getTestRun(runId)
                .orElseThrow(() -> new IllegalArgumentException("Test run not found: " + runId));
            
            // Create temporary directory for collecting files
            Path tempDir = Files.createTempDirectory("testrun_" + runId);
            
            try {
                // Copy test run directory
                Path runDir = getTestRunDirectory(runId);
                Path tempRunDir = tempDir.resolve(RUNS_DIR).resolve(runId);
                Files.createDirectories(tempRunDir);
                copyDirectory(runDir, tempRunDir);
                
                // Get test run to find any external files
                CSTestResult testResult = getTestRun(runId).get();
                
                // Copy screenshots
                if (testResult.getScreenshots() != null && !testResult.getScreenshots().isEmpty()) {
                    Path screenshotsDir = pathResolver.resolveResultsBasePath().resolve(SCREENSHOTS_DIR);
                    Path tempScreenshotsDir = tempDir.resolve(SCREENSHOTS_DIR);
                    Files.createDirectories(tempScreenshotsDir);
                    
                    for (String screenshotPath : testResult.getScreenshots()) {
                        String fileName = screenshotPath.substring(screenshotPath.lastIndexOf('/') + 1);
                        Path sourcePath = screenshotsDir.resolve(fileName);
                        Path targetPath = tempScreenshotsDir.resolve(fileName);
                        
                        if (Files.exists(sourcePath)) {
                            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
                        }
                    }
                }
                
                // Copy videos
                if (testResult.getVideos() != null && !testResult.getVideos().isEmpty()) {
                    Path videosDir = pathResolver.resolveResultsBasePath().resolve(VIDEOS_DIR);
                    Path tempVideosDir = tempDir.resolve(VIDEOS_DIR);
                    Files.createDirectories(tempVideosDir);
                    
                    for (String videoPath : testResult.getVideos()) {
                        String fileName = videoPath.substring(videoPath.lastIndexOf('/') + 1);
                        Path sourcePath = videosDir.resolve(fileName);
                        Path targetPath = tempVideosDir.resolve(fileName);
                        
                        if (Files.exists(sourcePath)) {
                            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
                        }
                    }
                }
                
                // Copy logs
                if (testResult.getLogFile() != null && !testResult.getLogFile().isEmpty()) {
                    Path logsDir = pathResolver.resolveResultsBasePath().resolve(LOGS_DIR);
                    Path tempLogsDir = tempDir.resolve(LOGS_DIR);
                    Files.createDirectories(tempLogsDir);
                    
                    String fileName = testResult.getLogFile().substring(testResult.getLogFile().lastIndexOf('/') + 1);
                    Path sourcePath = logsDir.resolve(fileName);
                    Path targetPath = tempLogsDir.resolve(fileName);
                    
                    if (Files.exists(sourcePath)) {
                        Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
                    }
                }
                
                // Copy metrics
                if (testResult.getMetrics() != null && !testResult.getMetrics().isEmpty()) {
                    Path metricsDir = pathResolver.resolveResultsBasePath().resolve(METRICS_DIR);
                    Path tempMetricsDir = tempDir.resolve(METRICS_DIR).resolve(runId);
                    Files.createDirectories(tempMetricsDir);
                    
                    Path runMetricsDir = metricsDir.resolve(runId);
                    if (Files.exists(runMetricsDir)) {
                        copyDirectory(runMetricsDir, tempMetricsDir);
                    }
                }
                
                // Create ZIP file
                Path zipFilePath = Paths.get(CSConstants.TEMP_DIR, "testrun_" + runId + "_" + 
                    TIMESTAMP_FORMATTER.format(LocalDateTime.now()) + ZIP_EXTENSION);
                
                createZipFile(tempDir, zipFilePath);
                
                return zipFilePath;
            } finally {
                // Clean up temporary directory
                CSFileUtils.deleteDirectoryRecursively(tempDir.toFile());
            }
        } catch (IOException e) {
            CSLogger.error("Failed to create archive for test run: " + runId, e);
            throw new RuntimeException("Failed to create test run archive", e);
        }
    }
    
    /**
     * Imports a test run from a ZIP archive.
     * 
     * @param archivePath The path to the ZIP archive
     * @return The ID of the imported test run
     */
    public String importTestRunArchive(Path archivePath) {
        if (archivePath == null || !Files.exists(archivePath)) {
            throw new IllegalArgumentException("Archive path is null or does not exist");
        }
        
        try {
            // Create temporary directory for extraction
            Path tempDir = Files.createTempDirectory("import_testrun");
            
            try {
                // Extract ZIP file
                extractZipFile(archivePath, tempDir);
                
                // Find test run directory
                Path runsDir = tempDir.resolve(RUNS_DIR);
                if (!Files.exists(runsDir)) {
                    throw new IllegalArgumentException("Invalid archive format: missing runs directory");
                }
                
                String runId = null;
                
                // Find the first run directory
                try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(runsDir)) {
                    for (Path runDir : dirStream) {
                        if (Files.isDirectory(runDir)) {
                            runId = runDir.getFileName().toString();
                            break;
                        }
                    }
                }
                
                if (runId == null) {
                    throw new IllegalArgumentException("Invalid archive format: no test run found");
                }
                
                // Generate a new run ID to avoid conflicts
                String newRunId = generateTestRunId();
                
                // Copy test run directory to results
                Path sourceRunDir = runsDir.resolve(runId);
                Path targetRunDir = getTestRunDirectory(newRunId);
                Files.createDirectories(targetRunDir);
                copyDirectory(sourceRunDir, targetRunDir);
                
                // Rename files to match new run ID
                updateFileReferences(targetRunDir, runId, newRunId);
                
                // Copy screenshots
                Path sourceScreenshotsDir = tempDir.resolve(SCREENSHOTS_DIR);
                if (Files.exists(sourceScreenshotsDir)) {
                    Path targetScreenshotsDir = pathResolver.resolveResultsBasePath().resolve(SCREENSHOTS_DIR);
                    Files.createDirectories(targetScreenshotsDir);
                    
                    try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(sourceScreenshotsDir)) {
                        for (Path screenshotFile : dirStream) {
                            if (Files.isRegularFile(screenshotFile)) {
                                String fileName = screenshotFile.getFileName().toString();
                                String newFileName = fileName.replace(runId + "_", newRunId + "_");
                                Path targetPath = targetScreenshotsDir.resolve(newFileName);
                                
                                Files.copy(screenshotFile, targetPath, StandardCopyOption.REPLACE_EXISTING);
                            }
                        }
                    }
                }
                
                // Copy videos
                Path sourceVideosDir = tempDir.resolve(VIDEOS_DIR);
                if (Files.exists(sourceVideosDir)) {
                    Path targetVideosDir = pathResolver.resolveResultsBasePath().resolve(VIDEOS_DIR);
                    Files.createDirectories(targetVideosDir);
                    
                    try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(sourceVideosDir)) {
                        for (Path videoFile : dirStream) {
                            if (Files.isRegularFile(videoFile)) {
                                String fileName = videoFile.getFileName().toString();
                                String newFileName = fileName.replace(runId + "_", newRunId + "_");
                                Path targetPath = targetVideosDir.resolve(newFileName);
                                
                                Files.copy(videoFile, targetPath, StandardCopyOption.REPLACE_EXISTING);
                            }
                        }
                    }
                }
                
                // Copy logs
                Path sourceLogsDir = tempDir.resolve(LOGS_DIR);
                if (Files.exists(sourceLogsDir)) {
                    Path targetLogsDir = pathResolver.resolveResultsBasePath().resolve(LOGS_DIR);
                    Files.createDirectories(targetLogsDir);
                    
                    try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(sourceLogsDir)) {
                        for (Path logFile : dirStream) {
                            if (Files.isRegularFile(logFile)) {
                                String fileName = logFile.getFileName().toString();
                                String newFileName = fileName.replace(runId, newRunId);
                                Path targetPath = targetLogsDir.resolve(newFileName);
                                
                                Files.copy(logFile, targetPath, StandardCopyOption.REPLACE_EXISTING);
                            }
                        }
                    }
                }
                
                // Copy metrics
                Path sourceMetricsDir = tempDir.resolve(METRICS_DIR).resolve(runId);
                if (Files.exists(sourceMetricsDir)) {
                    Path targetMetricsDir = pathResolver.resolveResultsBasePath().resolve(METRICS_DIR).resolve(newRunId);
                    Files.createDirectories(targetMetricsDir);
                    
                    copyDirectory(sourceMetricsDir, targetMetricsDir);
                }
                
                // Load and update test run
                Path testRunFilePath = targetRunDir.resolve(TEST_RUN_PREFIX + newRunId + JSON_EXTENSION);
                if (Files.exists(testRunFilePath)) {
                    String content = new String(Files.readAllBytes(testRunFilePath));
                    CSTestResult testResult = dataSerializer.deserialize(content, CSTestResult.class);
                    
                    // Update run ID and timestamps
                    testResult.setId(newRunId);
                    testResult.setCreatedAt(LocalDateTime.now());
                    testResult.setUpdatedAt(LocalDateTime.now());
                    
                    // Update file paths
                    updateTestResultPaths(testResult, runId, newRunId);
                    
                    // Save updated test run
                    saveTestRunFile(testResult);
                    
                    // Update test run index
                    updateTestRunIndex(newRunId, testResult.getProjectId(), testResult.getStartTime());
                    
                    // Add to cache
                    testRunCache.put(newRunId, testResult);
                    
                    // Increment test run count
                    testRunCount.incrementAndGet();
                }
                
                return newRunId;
            } finally {
                // Clean up temporary directory
                CSFileUtils.deleteDirectoryRecursively(tempDir.toFile());
            }
        } catch (IOException e) {
            CSLogger.error("Failed to import test run archive", e);
            throw new RuntimeException("Failed to import test run archive", e);
        }
    }
    
    /**
     * Deletes a test run and all associated files.
     * 
     * @param runId The ID of the test run to delete
     * @return True if the test run was successfully deleted, false otherwise
     */
    public boolean deleteTestRun(String runId) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        try {
            // Get test run directory
            Path runDir = getTestRunDirectory(runId);
            if (!Files.exists(runDir)) {
                return false;
            }
            
            // Backup test run directory before deletion
            backupService.backupDirectory(runDir);
            
            // Get test run to find external files
            Optional<CSTestResult> testResultOpt = getTestRun(runId);
            if (testResultOpt.isPresent()) {
                CSTestResult testResult = testResultOpt.get();
                
                // Delete screenshots
                if (testResult.getScreenshots() != null && !testResult.getScreenshots().isEmpty()) {
                    Path screenshotsDir = pathResolver.resolveResultsBasePath().resolve(SCREENSHOTS_DIR);
                    
                    for (String screenshotPath : testResult.getScreenshots()) {
                        String fileName = screenshotPath.substring(screenshotPath.lastIndexOf('/') + 1);
                        Path filePath = screenshotsDir.resolve(fileName);
                        
                        if (Files.exists(filePath)) {
                            Files.delete(filePath);
                        }
                    }
                }
                
                // Delete videos
                if (testResult.getVideos() != null && !testResult.getVideos().isEmpty()) {
                    Path videosDir = pathResolver.resolveResultsBasePath().resolve(VIDEOS_DIR);
                    
                    for (String videoPath : testResult.getVideos()) {
                        String fileName = videoPath.substring(videoPath.lastIndexOf('/') + 1);
                        Path filePath = videosDir.resolve(fileName);
                        
                        if (Files.exists(filePath)) {
                            Files.delete(filePath);
                        }
                    }
                }
                
                // Delete log file
                if (testResult.getLogFile() != null && !testResult.getLogFile().isEmpty()) {
                    Path logsDir = pathResolver.resolveResultsBasePath().resolve(LOGS_DIR);
                    String fileName = testResult.getLogFile().substring(testResult.getLogFile().lastIndexOf('/') + 1);
                    Path filePath = logsDir.resolve(fileName);
                    
                    if (Files.exists(filePath)) {
                        Files.delete(filePath);
                    }
                }
                
                // Delete metrics
                Path metricsDir = pathResolver.resolveResultsBasePath().resolve(METRICS_DIR).resolve(runId);
                if (Files.exists(metricsDir)) {
                    CSFileUtils.deleteDirectoryRecursively(metricsDir.toFile());
                }
                
                // Remove from test run index
                removeFromTestRunIndex(runId);
            }
            
            // Delete test run directory
            CSFileUtils.deleteDirectoryRecursively(runDir.toFile());
            
            // Remove from cache
            testRunCache.remove(runId);
            testRunIndexCache.remove(runId);
            
            return true;
        } catch (IOException e) {
            CSLogger.error("Failed to delete test run: " + runId, e);
            throw new RuntimeException("Failed to delete test run", e);
        }
    }
    
    /**
     * Retrieves a test run by its ID.
     * 
     * @param runId The ID of the test run to retrieve
     * @return An Optional containing the test run if found, or empty if not found
     */
    public Optional<CSTestResult> getTestRun(String runId) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        // Check cache first
        CSTestResult cachedTestRun = testRunCache.get(runId);
        if (cachedTestRun != null) {
            return Optional.of(cachedTestRun);
        }
        
        try {
            Path testRunFilePath = getTestRunFilePath(runId);
            if (!Files.exists(testRunFilePath)) {
                return Optional.empty();
            }
            
            // Lock the file for reading
            fileLockManager.acquireReadLock(testRunFilePath);
            
            try {
                // Read and deserialize test run file
                String content = new String(Files.readAllBytes(testRunFilePath));
                CSTestResult testResult = dataSerializer.deserialize(content, CSTestResult.class);
                
                // Cache the result
                testRunCache.put(runId, testResult);
                
                return Optional.of(testResult);
            } finally {
                fileLockManager.releaseReadLock(testRunFilePath);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read test run: " + runId, e);
            throw new RuntimeException("Failed to read test run", e);
        }
    }
    
    /**
     * Lists all test runs.
     * 
     * @return A list of all test runs
     */
    public List<CSTestResult> listTestRuns() {
        try {
            List<String> runIds = getTestRunIds(null, null, null, null);
            List<CSTestResult> testRuns = new ArrayList<>();
            
            for (String runId : runIds) {
                getTestRun(runId).ifPresent(testRuns::add);
            }
            
            return testRuns;
        } catch (IOException e) {
            CSLogger.error("Failed to list test runs", e);
            throw new RuntimeException("Failed to list test runs", e);
        }
    }
    
    /**
     * Lists test runs for a specific project.
     * 
     * @param projectId The ID of the project
     * @return A list of test runs for the project
     */
    public List<CSTestResult> listTestRunsByProject(String projectId) {
        if (projectId == null || projectId.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        try {
            List<String> runIds = getTestRunIds(projectId, null, null, null);
            List<CSTestResult> testRuns = new ArrayList<>();
            
            for (String runId : runIds) {
                getTestRun(runId).ifPresent(testRun -> {
                    if (projectId.equals(testRun.getProjectId())) {
                        testRuns.add(testRun);
                    }
                });
            }
            
            return testRuns;
        } catch (IOException e) {
            CSLogger.error("Failed to list test runs for project: " + projectId, e);
            throw new RuntimeException("Failed to list test runs for project", e);
        }
    }
    
    /**
     * Lists test runs within a date range.
     * 
     * @param startDate The start date (inclusive)
     * @param endDate The end date (inclusive)
     * @return A list of test runs within the date range
     */
    public List<CSTestResult> listTestRunsByDateRange(LocalDateTime startDate, LocalDateTime endDate) {
        if (startDate == null) {
            throw new IllegalArgumentException("Start date cannot be null");
        }
        
        try {
            List<String> runIds = getTestRunIds(null, startDate, endDate, null);
            List<CSTestResult> testRuns = new ArrayList<>();
            
            for (String runId : runIds) {
                getTestRun(runId).ifPresent(testRun -> {
                    LocalDateTime runStartTime = testRun.getStartTime();
                    
                    boolean matches = true;
                    
                    if (startDate != null && runStartTime.isBefore(startDate)) {
                        matches = false;
                    }
                    
                    if (endDate != null && runStartTime.isAfter(endDate)) {
                        matches = false;
                    }
                    
                    if (matches) {
                        testRuns.add(testRun);
                    }
                });
            }
            
            return testRuns;
        } catch (IOException e) {
            CSLogger.error("Failed to list test runs by date range", e);
            throw new RuntimeException("Failed to list test runs by date range", e);
        }
    }
    
    /**
     * Lists test runs by status.
     * 
     * @param status The status to filter by
     * @return A list of test runs with the specified status
     */
    public List<CSTestResult> listTestRunsByStatus(String status) {
        if (status == null || status.trim().isEmpty()) {
            throw new IllegalArgumentException("Status cannot be null or empty");
        }
        
        try {
            List<String> runIds = getTestRunIds(null, null, null, status);
            List<CSTestResult> testRuns = new ArrayList<>();
            
            for (String runId : runIds) {
                getTestRun(runId).ifPresent(testRun -> {
                    if (status.equals(testRun.getStatus())) {
                        testRuns.add(testRun);
                    }
                });
            }
            
            return testRuns;
        } catch (IOException e) {
            CSLogger.error("Failed to list test runs by status: " + status, e);
            throw new RuntimeException("Failed to list test runs by status", e);
        }
    }
    
    /**
     * Gets a test suite from a test run.
     * 
     * @param runId The ID of the test run
     * @param suiteId The ID of the test suite
     * @return An Optional containing the test suite if found, or empty if not found
     */
    public Optional<CSTestSuite> getTestSuite(String runId, String suiteId) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test suite ID cannot be null or empty");
        }
        
        // Try to find in full test run
        Optional<CSTestResult> testRunOpt = getTestRun(runId);
        if (testRunOpt.isPresent()) {
            CSTestResult testRun = testRunOpt.get();
            
            if (testRun.getTestSuites() != null) {
                Optional<CSTestSuite> suiteOpt = testRun.getTestSuites().stream()
                    .filter(suite -> suiteId.equals(suite.getId()))
                    .findFirst();
                
                if (suiteOpt.isPresent()) {
                    return suiteOpt;
                }
            }
        }
        
        // If not found in cached test run, try to read from file
        try {
            Path runDir = getTestRunDirectory(runId);
            Path suiteFilePath = runDir.resolve(SUITE_PREFIX + suiteId).resolve(SUITE_PREFIX + suiteId + JSON_EXTENSION);
            
            if (!Files.exists(suiteFilePath)) {
                return Optional.empty();
            }
            
            // Lock the file for reading
            fileLockManager.acquireReadLock(suiteFilePath);
            
            try {
                // Read and deserialize test suite file
                String content = new String(Files.readAllBytes(suiteFilePath));
                CSTestSuite testSuite = dataSerializer.deserialize(content, CSTestSuite.class);
                
                return Optional.of(testSuite);
            } finally {
                fileLockManager.releaseReadLock(suiteFilePath);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read test suite: " + suiteId + " in run: " + runId, e);
            throw new RuntimeException("Failed to read test suite", e);
        }
    }
    
    /**
     * Gets a test case from a test run.
     * 
     * @param runId The ID of the test run
     * @param suiteId The ID of the test suite
     * @param caseId The ID of the test case
     * @return An Optional containing the test case if found, or empty if not found
     */
    public Optional<CSTestCase> getTestCase(String runId, String suiteId, String caseId) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test suite ID cannot be null or empty");
        }
        if (caseId == null || caseId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test case ID cannot be null or empty");
        }
        
        // Try to find in full test run
        Optional<CSTestSuite> suiteOpt = getTestSuite(runId, suiteId);
        if (suiteOpt.isPresent()) {
            CSTestSuite suite = suiteOpt.get();
            
            if (suite.getTestCases() != null) {
                Optional<CSTestCase> caseOpt = suite.getTestCases().stream()
                    .filter(testCase -> caseId.equals(testCase.getId()))
                    .findFirst();
                
                if (caseOpt.isPresent()) {
                    return caseOpt;
                }
            }
        }
        
        // If not found in cached test run, try to read from file
        try {
            Path runDir = getTestRunDirectory(runId);
            Path caseFilePath = runDir.resolve(SUITE_PREFIX + suiteId)
                .resolve(CASE_PREFIX + caseId)
                .resolve(CASE_PREFIX + caseId + JSON_EXTENSION);
            
            if (!Files.exists(caseFilePath)) {
                return Optional.empty();
            }
            
            // Lock the file for reading
            fileLockManager.acquireReadLock(caseFilePath);
            
            try {
                // Read and deserialize test case file
                String content = new String(Files.readAllBytes(caseFilePath));
                CSTestCase testCase = dataSerializer.deserialize(content, CSTestCase.class);
                
                return Optional.of(testCase);
            } finally {
                fileLockManager.releaseReadLock(caseFilePath);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read test case: " + caseId + " in suite: " + suiteId + " in run: " + runId, e);
            throw new RuntimeException("Failed to read test case", e);
        }
    }
    
    /**
     * Gets a test step from a test run.
     * 
     * @param runId The ID of the test run
     * @param suiteId The ID of the test suite
     * @param caseId The ID of the test case
     * @param stepId The ID of the test step
     * @return An Optional containing the test step if found, or empty if not found
     */
    public Optional<CSTestStep> getTestStep(String runId, String suiteId, String caseId, String stepId) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        if (suiteId == null || suiteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test suite ID cannot be null or empty");
        }
        if (caseId == null || caseId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test case ID cannot be null or empty");
        }
        if (stepId == null || stepId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test step ID cannot be null or empty");
        }
        
        // Try to find in full test run
        Optional<CSTestCase> caseOpt = getTestCase(runId, suiteId, caseId);
        if (caseOpt.isPresent()) {
            CSTestCase testCase = caseOpt.get();
            
            if (testCase.getTestSteps() != null) {
                Optional<CSTestStep> stepOpt = testCase.getTestSteps().stream()
                    .filter(step -> stepId.equals(step.getId()))
                    .findFirst();
                
                if (stepOpt.isPresent()) {
                    return stepOpt;
                }
            }
        }
        
        // If not found in cached test run, try to read from file
        try {
            Path runDir = getTestRunDirectory(runId);
            Path stepFilePath = runDir.resolve(SUITE_PREFIX + suiteId)
                .resolve(CASE_PREFIX + caseId)
                .resolve(STEP_PREFIX + stepId)
                .resolve(STEP_PREFIX + stepId + JSON_EXTENSION);
            
            if (!Files.exists(stepFilePath)) {
                return Optional.empty();
            }
            
            // Lock the file for reading
            fileLockManager.acquireReadLock(stepFilePath);
            
            try {
                // Read and deserialize test step file
                String content = new String(Files.readAllBytes(stepFilePath));
                CSTestStep testStep = dataSerializer.deserialize(content, CSTestStep.class);
                
                return Optional.of(testStep);
            } finally {
                fileLockManager.releaseReadLock(stepFilePath);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read test step: " + stepId + " in case: " + caseId + " in suite: " + suiteId + " in run: " + runId, e);
            throw new RuntimeException("Failed to read test step", e);
        }
    }
    
    /**
     * Gets the logs for a test run.
     * 
     * @param runId The ID of the test run
     * @return The logs as a string, or empty string if no logs found
     */
    public String getTestRunLogs(String runId) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        try {
            // Get test run
            CSTestResult testResult = getTestRun(runId)
                .orElseThrow(() -> new IllegalArgumentException("Test run not found: " + runId));
            
            // Check if log file exists
            if (testResult.getLogFile() == null || testResult.getLogFile().isEmpty()) {
                return "";
            }
            
            String logFile = testResult.getLogFile();
            Path logsDir = pathResolver.resolveResultsBasePath().resolve(LOGS_DIR);
            String fileName = logFile.substring(logFile.lastIndexOf('/') + 1);
            Path logFilePath = logsDir.resolve(fileName);
            
            if (!Files.exists(logFilePath)) {
                return "";
            }
            
            // Check if compressed
            if (fileName.endsWith(".gz")) {
                // Decompress and return
                return compressionService.decompressFileToString(logFilePath.toFile());
            } else {
                // Read directly
                return new String(Files.readAllBytes(logFilePath));
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read logs for test run: " + runId, e);
            throw new RuntimeException("Failed to read test run logs", e);
        }
    }
    
    /**
     * Gets a metric for a test run.
     * 
     * @param runId The ID of the test run
     * @param metricName The name of the metric
     * @param clazz The class to deserialize the metric to
     * @return An Optional containing the metric if found, or empty if not found
     */
    public <T> Optional<T> getMetric(String runId, String metricName, Class<T> clazz) {
        if (runId == null || runId.trim().isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        if (metricName == null || metricName.trim().isEmpty()) {
            throw new IllegalArgumentException("Metric name cannot be null or empty");
        }
        
        try {
            Path metricsDir = pathResolver.resolveResultsBasePath().resolve(METRICS_DIR).resolve(runId);
            Path metricFilePath = metricsDir.resolve(METRIC_PREFIX + sanitizeFileName(metricName) + JSON_EXTENSION);
            
            if (!Files.exists(metricFilePath)) {
                return Optional.empty();
            }
            
            // Lock the file for reading
            fileLockManager.acquireReadLock(metricFilePath);
            
            try {
                // Read and deserialize metric file
                String content = new String(Files.readAllBytes(metricFilePath));
                T metric = dataSerializer.deserialize(content, clazz);
                
                return Optional.of(metric);
            } finally {
                fileLockManager.releaseReadLock(metricFilePath);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read metric: " + metricName + " for run: " + runId, e);
            throw new RuntimeException("Failed to read metric", e);
        }
    }
    
    /**
     * Gets aggregate metrics across multiple test runs.
     * 
     * @param projectId The ID of the project (optional)
     * @param startDate The start date (optional)
     * @param endDate The end date (optional)
     * @return A map of metric names to aggregated values
     */
    public Map<String, Object> getAggregateMetrics(String projectId, LocalDateTime startDate, LocalDateTime endDate) {
        try {
            List<CSTestResult> testRuns = new ArrayList<>();
            
            // Get test runs based on filters
            List<String> runIds = getTestRunIds(projectId, startDate, endDate, null);
            for (String runId : runIds) {
                getTestRun(runId).ifPresent(testRuns::add);
            }
            
            // Aggregate metrics
            Map<String, Object> aggregates = new HashMap<>();
            
            // Total runs
            aggregates.put("totalRuns", testRuns.size());
            
            // Pass rate
            long passedRuns = testRuns.stream()
                .filter(run -> "PASSED".equals(run.getStatus()))
                .count();
            aggregates.put("passRate", testRuns.isEmpty() ? 0 : (double) passedRuns / testRuns.size());
            
            // Average duration
            double avgDuration = testRuns.stream()
                .filter(run -> run.getStartTime() != null && run.getEndTime() != null)
                .mapToDouble(run -> {
                    return (double) java.time.Duration.between(run.getStartTime(), run.getEndTime()).getSeconds();
                })
                .average()
                .orElse(0);
            aggregates.put("averageDurationSeconds", avgDuration);
            
            // Status counts
            Map<String, Long> statusCounts = testRuns.stream()
                .collect(Collectors.groupingBy(
                    CSTestResult::getStatus,
                    Collectors.counting()
                ));
            aggregates.put("statusCounts", statusCounts);
            
            return aggregates;
        } catch (IOException e) {
            CSLogger.error("Failed to get aggregate metrics", e);
            throw new RuntimeException("Failed to get aggregate metrics", e);
        }
    }
    
    /**
     * Updates the test run count based on existing runs.
     * 
     * @throws IOException If there is an error reading the runs directory
     */
    private void updateTestRunCount() throws IOException {
        Path runsDir = pathResolver.resolveResultsBasePath().resolve(RUNS_DIR);
        if (!Files.exists(runsDir)) {
            testRunCount.set(0);
            return;
        }
        
        try (Stream<Path> paths = Files.list(runsDir).filter(Files::isDirectory)) {
            testRunCount.set((int) paths.count());
        }
    }
    
    /**
     * Generates a unique test run ID.
     * 
     * @return A unique test run ID
     */
    private String generateTestRunId() {
        LocalDateTime now = LocalDateTime.now();
        String datePart = DATE_FORMATTER.format(now);
        String timePart = TIME_FORMATTER.format(now);
        String countPart = String.format("%04d", testRunCount.get());
        
        return datePart + "-" + timePart + "-" + countPart;
    }
    
    /**
     * Creates the subdirectories for a test run.
     * 
     * @param runDir The test run directory
     * @throws IOException If there is an error creating directories
     */
    private void createTestRunSubdirectories(Path runDir) throws IOException {
        // No additional subdirectories needed at the root level
        // Subdirectories for suites, cases, and steps will be created as needed
    }
    
    /**
     * Processes test suites in a test result.
     * 
     * @param testResult The test result containing test suites
     * @param runDir The test run directory
     * @throws IOException If there is an error processing test suites
     */
    private void processTestSuites(CSTestResult testResult, Path runDir) throws IOException {
        if (testResult.getTestSuites() == null || testResult.getTestSuites().isEmpty()) {
            return;
        }
        
        for (CSTestSuite testSuite : testResult.getTestSuites()) {
            // Ensure suite has an ID
            if (testSuite.getId() == null || testSuite.getId().trim().isEmpty()) {
                testSuite.setId(UUID.randomUUID().toString());
            }
            
            // Create suite directory
            Path suiteDir = runDir.resolve(SUITE_PREFIX + testSuite.getId());
            if (!Files.exists(suiteDir)) {
                Files.createDirectories(suiteDir);
            }
            
            // Process test cases
            processTestCases(testSuite, suiteDir);
            
            // Save test suite file
            saveTestSuiteFile(testResult.getId(), testSuite);
        }
    }
    
    /**
     * Processes test cases in a test suite.
     * 
     * @param testSuite The test suite containing test cases
     * @param suiteDir The test suite directory
     * @throws IOException If there is an error processing test cases
     */
    private void processTestCases(CSTestSuite testSuite, Path suiteDir) throws IOException {
        if (testSuite.getTestCases() == null || testSuite.getTestCases().isEmpty()) {
            return;
        }
        
        for (CSTestCase testCase : testSuite.getTestCases()) {
            // Ensure case has an ID
            if (testCase.getId() == null || testCase.getId().trim().isEmpty()) {
                testCase.setId(UUID.randomUUID().toString());
            }
            
            // Create case directory
            Path caseDir = suiteDir.resolve(CASE_PREFIX + testCase.getId());
            if (!Files.exists(caseDir)) {
                Files.createDirectories(caseDir);
            }
            
            // Process test steps
            processTestSteps(testCase, caseDir, null);
            
            // Save test case file
            saveTestCaseFile(null, testSuite.getId(), testCase);
        }
    }
    
    /**
     * Processes test steps in a test case.
     * 
     * @param testCase The test case containing test steps
     * @param caseDir The test case directory
     * @param runId The test run ID (may be null if processing as part of a test case)
     * @throws IOException If there is an error processing test steps
     */
    private void processTestSteps(CSTestCase testCase, Path caseDir, String runId) throws IOException {
        if (testCase.getTestSteps() == null || testCase.getTestSteps().isEmpty()) {
            return;
        }
        
        for (CSTestStep testStep : testCase.getTestSteps()) {
            // Ensure step has an ID
            if (testStep.getId() == null || testStep.getId().trim().isEmpty()) {
                testStep.setId(UUID.randomUUID().toString());
            }
            
            // Create step directory
            Path stepDir = caseDir.resolve(STEP_PREFIX + testStep.getId());
            if (!Files.exists(stepDir)) {
                Files.createDirectories(stepDir);
            }
            
            // Process screenshots and attachments
            processScreenshots(testStep, stepDir, runId);
            processAttachments(testStep, stepDir, runId);
            
            // Save test step file
            saveTestStepFile(null, null, testCase.getId(), testStep);
        }
    }
    
    /**
     * Processes screenshots in a test step.
     * 
     * @param testStep The test step containing screenshots
     * @param stepDir The test step directory
     * @param runId The test run ID (may be null if processing as part of a test step)
     * @throws IOException If there is an error processing screenshots
     */
    private void processScreenshots(CSTestStep testStep, Path stepDir, String runId) throws IOException {
        if (testStep.getScreenshots() == null || testStep.getScreenshots().isEmpty()) {
            return;
        }
        
        // Create screenshots directory if it doesn't exist
        Path screenshotsDir = pathResolver.resolveResultsBasePath().resolve(SCREENSHOTS_DIR);
        if (!Files.exists(screenshotsDir)) {
            Files.createDirectories(screenshotsDir);
        }
        
        for (CSScreenshot screenshot : testStep.getScreenshots()) {
            // Ensure screenshot has an ID
            if (screenshot.getId() == null || screenshot.getId().trim().isEmpty()) {
                screenshot.setId(UUID.randomUUID().toString());
            }
            
            // If screenshot has base64Data or imageData, save it
            if ((screenshot.getBase64Data() != null && !screenshot.getBase64Data().isEmpty()) ||
                (screenshot.getImageData() != null && screenshot.getImageData().length > 0)) {
                
                // Determine file name
                String fileName = (runId != null ? runId : "temp") + "_" + screenshot.getId() + PNG_EXTENSION;
                Path screenshotPath = screenshotsDir.resolve(fileName);
                
                // Save the image data
                if (screenshot.getBase64Data() != null && !screenshot.getBase64Data().isEmpty()) {
                    byte[] imageData = Base64.getDecoder().decode(screenshot.getBase64Data());
                    Files.write(screenshotPath, imageData);
                    
                    // Clear base64 data to save space once saved to disk
                    screenshot.setBase64Data(null);
                } else if (screenshot.getImageData() != null && screenshot.getImageData().length > 0) {
                    Files.write(screenshotPath, screenshot.getImageData());
                    
                    // Clear image data to save space once saved to disk
                    screenshot.setImageData(null);
                }
                
                // Set file path
                screenshot.setFilePath(SCREENSHOTS_DIR + "/" + fileName);
            }
        }
    }
    
    /**
     * Processes attachments in a test step.
     * 
     * @param testStep The test step containing attachments
     * @param stepDir The test step directory
     * @param runId The test run ID (may be null if processing as part of a test step)
     * @throws IOException If there is an error processing attachments
     */
    private void processAttachments(CSTestStep testStep, Path stepDir, String runId) throws IOException {
        if (testStep.getAttachments() == null || testStep.getAttachments().isEmpty()) {
            return;
        }

        // Create attachments directory if it doesn't exist
        Path attachmentsDir = pathResolver.resolveResultsBasePath().resolve(ATTACHMENTS_DIR);
        if (!Files.exists(attachmentsDir)) {
            Files.createDirectories(attachmentsDir);
        }
        
        for (CSAttachment attachment : testStep.getAttachments()) {
            // Ensure attachment has an ID
            if (attachment.getId() == null || attachment.getId().trim().isEmpty()) {
                attachment.setId(UUID.randomUUID().toString());
            }
            
            // If attachment has base64Data or fileData, save it
            if ((attachment.getBase64Data() != null && !attachment.getBase64Data().isEmpty()) ||
                (attachment.getFileData() != null && attachment.getFileData().length > 0)) {
                
                // Determine file name
                String fileName = (runId != null ? runId : "temp") + "_" + attachment.getId() + "_" + 
                    sanitizeFileName(attachment.getName());
                Path attachmentPath = attachmentsDir.resolve(fileName);
                
                // Save the attachment data
                if (attachment.getBase64Data() != null && !attachment.getBase64Data().isEmpty()) {
                    byte[] fileData = Base64.getDecoder().decode(attachment.getBase64Data());
                    Files.write(attachmentPath, fileData);
                    
                    // Clear base64 data to save space once saved to disk
                    attachment.setBase64Data(null);
                } else if (attachment.getFileData() != null && attachment.getFileData().length > 0) {
                    Files.write(attachmentPath, attachment.getFileData());
                    
                    // Clear file data to save space once saved to disk
                    attachment.setFileData(null);
                }
                
                // Set file path
                attachment.setFilePath(ATTACHMENTS_DIR + "/" + fileName);
            }
        }
    }
    
    /**
     * Gets the path to the test run directory.
     * 
     * @param runId The ID of the test run
     * @return The path to the test run directory
     */
    private Path getTestRunDirectory(String runId) {
        return pathResolver.resolveResultsBasePath().resolve(RUNS_DIR).resolve(runId);
    }
    
    /**
     * Gets the path to the test run file.
     * 
     * @param runId The ID of the test run
     * @return The path to the test run file
     */
    private Path getTestRunFilePath(String runId) {
        return getTestRunDirectory(runId).resolve(TEST_RUN_PREFIX + runId + JSON_EXTENSION);
    }
    
    /**
     * Saves a test run file.
     * 
     * @param testResult The test result to save
     * @throws IOException If there is an error saving the file
     */
    private void saveTestRunFile(CSTestResult testResult) throws IOException {
        Path testRunFilePath = getTestRunFilePath(testResult.getId());
        
        // Make sure directory exists
        Files.createDirectories(testRunFilePath.getParent());
        
        // Lock the file for writing
        fileLockManager.acquireWriteLock(testRunFilePath);
        
        try {
            // Serialize and write test run
            String serialized = dataSerializer.serialize(testResult);
            Files.write(testRunFilePath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(testRunFilePath);
        }
    }
    
    /**
     * Saves a test suite file.
     * 
     * @param runId The ID of the test run
     * @param testSuite The test suite to save
     * @throws IOException If there is an error saving the file
     */
    private void saveTestSuiteFile(String runId, CSTestSuite testSuite) throws IOException {
        Path runDir = getTestRunDirectory(runId != null ? runId : testSuite.getRunId());
        Path suiteDir = runDir.resolve(SUITE_PREFIX + testSuite.getId());
        Path suiteFilePath = suiteDir.resolve(SUITE_PREFIX + testSuite.getId() + JSON_EXTENSION);
        
        // Make sure directory exists
        Files.createDirectories(suiteFilePath.getParent());
        
        // Lock the file for writing
        fileLockManager.acquireWriteLock(suiteFilePath);
        
        try {
            // Serialize and write test suite
            String serialized = dataSerializer.serialize(testSuite);
            Files.write(suiteFilePath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(suiteFilePath);
        }
    }
    
    /**
     * Saves a test case file.
     * 
     * @param runId The ID of the test run (may be null if suiteId has runId)
     * @param suiteId The ID of the test suite
     * @param testCase The test case to save
     * @throws IOException If there is an error saving the file
     */
    private void saveTestCaseFile(String runId, String suiteId, CSTestCase testCase) throws IOException {
        Path runDir = getTestRunDirectory(runId != null ? runId : testCase.getRunId());
        Path suiteDir = runDir.resolve(SUITE_PREFIX + suiteId);
        Path caseDir = suiteDir.resolve(CASE_PREFIX + testCase.getId());
        Path caseFilePath = caseDir.resolve(CASE_PREFIX + testCase.getId() + JSON_EXTENSION);
        
        // Make sure directory exists
        Files.createDirectories(caseFilePath.getParent());
        
        // Lock the file for writing
        fileLockManager.acquireWriteLock(caseFilePath);
        
        try {
            // Serialize and write test case
            String serialized = dataSerializer.serialize(testCase);
            Files.write(caseFilePath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(caseFilePath);
        }
    }
    
    /**
     * Saves a test step file.
     * 
     * @param runId The ID of the test run (may be null if available in case)
     * @param suiteId The ID of the test suite (may be null if available in case)
     * @param caseId The ID of the test case
     * @param testStep The test step to save
     * @throws IOException If there is an error saving the file
     */
    private void saveTestStepFile(String runId, String suiteId, String caseId, CSTestStep testStep) throws IOException {
        Path runDir = getTestRunDirectory(runId != null ? runId : testStep.getRunId());
        Path suiteDir = runDir.resolve(SUITE_PREFIX + (suiteId != null ? suiteId : testStep.getSuiteId()));
        Path caseDir = suiteDir.resolve(CASE_PREFIX + caseId);
        Path stepDir = caseDir.resolve(STEP_PREFIX + testStep.getId());
        Path stepFilePath = stepDir.resolve(STEP_PREFIX + testStep.getId() + JSON_EXTENSION);
        
        // Make sure directory exists
        Files.createDirectories(stepFilePath.getParent());
        
        // Lock the file for writing
        fileLockManager.acquireWriteLock(stepFilePath);
        
        try {
            // Serialize and write test step
            String serialized = dataSerializer.serialize(testStep);
            Files.write(stepFilePath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(stepFilePath);
        }
    }
    
    /**
     * Updates the test run index with a new test run.
     * 
     * @param runId The ID of the test run
     * @param projectId The ID of the project
     * @param startTime The start time of the test run
     * @throws IOException If there is an error updating the index
     */
    private void updateTestRunIndex(String runId, String projectId, LocalDateTime startTime) throws IOException {
        // Add to project-specific index
        if (projectId != null && !projectId.trim().isEmpty()) {
            addToProjectRunIndex(projectId, runId, startTime);
        }
        
        // Add to date-based index
        if (startTime != null) {
            addToDateRunIndex(startTime.toLocalDate().toString(), runId);
        }
        
        // Add to status-based index
        addToStatusRunIndex("RUNNING", runId);
        
        // Clear cache for this key
        testRunIndexCache.remove(runId);
    }
    
    /**
     * Removes a test run from the index.
     * 
     * @param runId The ID of the test run
     * @throws IOException If there is an error updating the index
     */
    private void removeFromTestRunIndex(String runId) throws IOException {
        // Get test run
        Optional<CSTestResult> testResultOpt = getTestRun(runId);
        if (!testResultOpt.isPresent()) {
            return;
        }
        
        CSTestResult testResult = testResultOpt.get();
        
        // Remove from project-specific index
        String projectId = testResult.getProjectId();
        if (projectId != null && !projectId.trim().isEmpty()) {
            removeFromProjectRunIndex(projectId, runId);
        }
        
        // Remove from date-based index
        LocalDateTime startTime = testResult.getStartTime();
        if (startTime != null) {
            removeFromDateRunIndex(startTime.toLocalDate().toString(), runId);
        }
        
        // Remove from status-based index
        String status = testResult.getStatus();
        if (status != null && !status.trim().isEmpty()) {
            removeFromStatusRunIndex(status, runId);
        }
        
        // Clear cache for this key
        testRunIndexCache.remove(runId);
    }
    
    /**
     * Adds a test run to the project-specific index.
     * 
     * @param projectId The ID of the project
     * @param runId The ID of the test run
     * @param startTime The start time of the test run
     * @throws IOException If there is an error updating the index
     */
    private void addToProjectRunIndex(String projectId, String runId, LocalDateTime startTime) throws IOException {
        Path indexDir = pathResolver.resolveResultsBasePath().resolve("indexes");
        if (!Files.exists(indexDir)) {
            Files.createDirectories(indexDir);
        }
        
        Path projectIndexPath = indexDir.resolve("project_" + projectId + JSON_EXTENSION);
        
        // Lock the file for reading/writing
        fileLockManager.acquireWriteLock(projectIndexPath);
        
        try {
            Map<String, LocalDateTime> runIndex;
            
            if (Files.exists(projectIndexPath)) {
                // Read existing index
                String content = new String(Files.readAllBytes(projectIndexPath));
                runIndex = dataSerializer.deserialize(content, Map.class);
            } else {
                // Create new index
                runIndex = new HashMap<>();
            }
            
            // Add run ID with start time
            runIndex.put(runId, startTime);
            
            // Write updated index
            String serialized = dataSerializer.serialize(runIndex);
            Files.write(projectIndexPath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(projectIndexPath);
        }
    }
    
    /**
     * Removes a test run from the project-specific index.
     * 
     * @param projectId The ID of the project
     * @param runId The ID of the test run
     * @throws IOException If there is an error updating the index
     */
    private void removeFromProjectRunIndex(String projectId, String runId) throws IOException {
        Path indexDir = pathResolver.resolveResultsBasePath().resolve("indexes");
        Path projectIndexPath = indexDir.resolve("project_" + projectId + JSON_EXTENSION);
        
        if (!Files.exists(projectIndexPath)) {
            return;
        }
        
        // Lock the file for reading/writing
        fileLockManager.acquireWriteLock(projectIndexPath);
        
        try {
            // Read existing index
            String content = new String(Files.readAllBytes(projectIndexPath));
            Map<String, LocalDateTime> runIndex = dataSerializer.deserialize(content, Map.class);
            
            // Remove run ID
            runIndex.remove(runId);
            
            // Write updated index
            String serialized = dataSerializer.serialize(runIndex);
            Files.write(projectIndexPath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(projectIndexPath);
        }
    }
    
    /**
     * Adds a test run to the date-based index.
     * 
     * @param dateStr The date as a string (YYYY-MM-DD)
     * @param runId The ID of the test run
     * @throws IOException If there is an error updating the index
     */
    private void addToDateRunIndex(String dateStr, String runId) throws IOException {
        Path indexDir = pathResolver.resolveResultsBasePath().resolve("indexes");
        if (!Files.exists(indexDir)) {
            Files.createDirectories(indexDir);
        }
        
        Path dateIndexPath = indexDir.resolve("date_" + dateStr + JSON_EXTENSION);
        
        // Lock the file for reading/writing
        fileLockManager.acquireWriteLock(dateIndexPath);
        
        try {
            List<String> runIds;
            
            if (Files.exists(dateIndexPath)) {
                // Read existing index
                String content = new String(Files.readAllBytes(dateIndexPath));
                runIds = dataSerializer.deserialize(content, List.class);
            } else {
                // Create new index
                runIds = new ArrayList<>();
            }
            
            // Add run ID if not already present
            if (!runIds.contains(runId)) {
                runIds.add(runId);
            }
            
            // Write updated index
            String serialized = dataSerializer.serialize(runIds);
            Files.write(dateIndexPath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(dateIndexPath);
        }
    }
    
    /**
     * Removes a test run from the date-based index.
     * 
     * @param dateStr The date as a string (YYYY-MM-DD)
     * @param runId The ID of the test run
     * @throws IOException If there is an error updating the index
     */
    private void removeFromDateRunIndex(String dateStr, String runId) throws IOException {
        Path indexDir = pathResolver.resolveResultsBasePath().resolve("indexes");
        Path dateIndexPath = indexDir.resolve("date_" + dateStr + JSON_EXTENSION);
        
        if (!Files.exists(dateIndexPath)) {
            return;
        }
        
        // Lock the file for reading/writing
        fileLockManager.acquireWriteLock(dateIndexPath);
        
        try {
            // Read existing index
            String content = new String(Files.readAllBytes(dateIndexPath));
            List<String> runIds = dataSerializer.deserialize(content, List.class);
            
            // Remove run ID
            runIds.remove(runId);
            
            // Write updated index
            String serialized = dataSerializer.serialize(runIds);
            Files.write(dateIndexPath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(dateIndexPath);
        }
    }
    
    /**
     * Adds a test run to the status-based index.
     * 
     * @param status The status of the test run
     * @param runId The ID of the test run
     * @throws IOException If there is an error updating the index
     */
    private void addToStatusRunIndex(String status, String runId) throws IOException {
        Path indexDir = pathResolver.resolveResultsBasePath().resolve("indexes");
        if (!Files.exists(indexDir)) {
            Files.createDirectories(indexDir);
        }
        
        Path statusIndexPath = indexDir.resolve("status_" + status + JSON_EXTENSION);
        
        // Lock the file for reading/writing
        fileLockManager.acquireWriteLock(statusIndexPath);
        
        try {
            List<String> runIds;
            
            if (Files.exists(statusIndexPath)) {
                // Read existing index
                String content = new String(Files.readAllBytes(statusIndexPath));
                runIds = dataSerializer.deserialize(content, List.class);
            } else {
                // Create new index
                runIds = new ArrayList<>();
            }
            
            // Add run ID if not already present
            if (!runIds.contains(runId)) {
                runIds.add(runId);
            }
            
            // Write updated index
            String serialized = dataSerializer.serialize(runIds);
            Files.write(statusIndexPath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(statusIndexPath);
        }
    }
    
    /**
     * Removes a test run from the status-based index.
     * 
     * @param status The status of the test run
     * @param runId The ID of the test run
     * @throws IOException If there is an error updating the index
     */
    private void removeFromStatusRunIndex(String status, String runId) throws IOException {
        Path indexDir = pathResolver.resolveResultsBasePath().resolve("indexes");
        Path statusIndexPath = indexDir.resolve("status_" + status + JSON_EXTENSION);
        
        if (!Files.exists(statusIndexPath)) {
            return;
        }
        
        // Lock the file for reading/writing
        fileLockManager.acquireWriteLock(statusIndexPath);
        
        try {
            // Read existing index
            String content = new String(Files.readAllBytes(statusIndexPath));
            List<String> runIds = dataSerializer.deserialize(content, List.class);
            
            // Remove run ID
            runIds.remove(runId);
            
            // Write updated index
            String serialized = dataSerializer.serialize(runIds);
            Files.write(statusIndexPath, serialized.getBytes());
        } finally {
            fileLockManager.releaseWriteLock(statusIndexPath);
        }
    }
    
    /**
     * Gets test run IDs based on the specified filters.
     * 
     * @param projectId The ID of the project (optional)
     * @param startDate The start date (optional)
     * @param endDate The end date (optional)
     * @param status The status (optional)
     * @return A list of test run IDs matching the filters
     * @throws IOException If there is an error reading the indexes
     */
    private List<String> getTestRunIds(String projectId, LocalDateTime startDate, LocalDateTime endDate, String status) throws IOException {
        // Check cache
        String cacheKey = "filter_" + (projectId != null ? projectId : "") + "_" +
            (startDate != null ? startDate.toString() : "") + "_" +
            (endDate != null ? endDate.toString() : "") + "_" +
            (status != null ? status : "");
        
        List<String> cachedIds = testRunIndexCache.get(cacheKey);
        if (cachedIds != null) {
            return cachedIds;
        }
        
        // Create set to avoid duplicates
        Set<String> runIdsSet = new HashSet<>();
        Path indexDir = pathResolver.resolveResultsBasePath().resolve("indexes");
        
        if (!Files.exists(indexDir)) {
            return Collections.emptyList();
        }
        
        // Project filter
        if (projectId != null && !projectId.trim().isEmpty()) {
            Path projectIndexPath = indexDir.resolve("project_" + projectId + JSON_EXTENSION);
            
            if (Files.exists(projectIndexPath)) {
                fileLockManager.acquireReadLock(projectIndexPath);
                
                try {
                    String content = new String(Files.readAllBytes(projectIndexPath));
                    Map<String, LocalDateTime> runIndex = dataSerializer.deserialize(content, Map.class);
                    
                    for (Map.Entry<String, LocalDateTime> entry : runIndex.entrySet()) {
                        String runId = entry.getKey();
                        LocalDateTime runStartTime = entry.getValue();
                        
                        boolean matches = true;
                        
                        if (startDate != null && runStartTime.isBefore(startDate)) {
                            matches = false;
                        }
                        
                        if (endDate != null && runStartTime.isAfter(endDate)) {
                            matches = false;
                        }
                        
                        if (matches) {
                            runIdsSet.add(runId);
                        }
                    }
                } finally {
                    fileLockManager.releaseReadLock(projectIndexPath);
                }
            }
        } else if (startDate != null || endDate != null) {
            // Date filter
            LocalDateTime current = startDate != null ? startDate : LocalDateTime.now().minusYears(1);
            LocalDateTime end = endDate != null ? endDate : LocalDateTime.now();
            
            while (!current.isAfter(end)) {
                String dateStr = current.toLocalDate().toString();
                Path dateIndexPath = indexDir.resolve("date_" + dateStr + JSON_EXTENSION);
                
                if (Files.exists(dateIndexPath)) {
                    fileLockManager.acquireReadLock(dateIndexPath);
                    
                    try {
                        String content = new String(Files.readAllBytes(dateIndexPath));
                        List<String> runIds = dataSerializer.deserialize(content, List.class);
                        
                        runIdsSet.addAll(runIds);
                    } finally {
                        fileLockManager.releaseReadLock(dateIndexPath);
                    }
                }
                
                current = current.plusDays(1);
            }
        } else if (status != null && !status.trim().isEmpty()) {
            // Status filter
            Path statusIndexPath = indexDir.resolve("status_" + status + JSON_EXTENSION);
            
            if (Files.exists(statusIndexPath)) {
                fileLockManager.acquireReadLock(statusIndexPath);
                
                try {
                    String content = new String(Files.readAllBytes(statusIndexPath));
                    List<String> runIds = dataSerializer.deserialize(content, List.class);
                    
                    runIdsSet.addAll(runIds);
                } finally {
                    fileLockManager.releaseReadLock(statusIndexPath);
                }
            }
        } else {
            // No filters, get all test runs
            try (Stream<Path> paths = Files.list(indexDir)) {
                paths.filter(path -> path.getFileName().toString().startsWith("status_"))
                    .forEach(path -> {
                        try {
                            fileLockManager.acquireReadLock(path);
                            
                            try {
                                String content = new String(Files.readAllBytes(path));
                                List<String> runIds = dataSerializer.deserialize(content, List.class);
                                
                                runIdsSet.addAll(runIds);
                            } finally {
                                fileLockManager.releaseReadLock(path);
                            }
                        } catch (IOException e) {
                            CSLogger.warn("Failed to read index file: " + path, e);
                        }
                    });
            }
        }
        
        // Convert set to list and sort
        List<String> runIds = new ArrayList<>(runIdsSet);
        
        // Sort by ID (which includes timestamp) in descending order
        Collections.sort(runIds, Comparator.reverseOrder());
        
        // Cache the result
        testRunIndexCache.put(cacheKey, runIds);
        
        return runIds;
    }
    
    /**
     * Calculates final metrics for a test run.
     * 
     * @param testResult The test result to calculate metrics for
     */
    private void calculateFinalMetrics(CSTestResult testResult) {
        // Duration
        if (testResult.getStartTime() != null && testResult.getEndTime() != null) {
            long durationSeconds = java.time.Duration.between(
                testResult.getStartTime(), testResult.getEndTime()).getSeconds();
            
            updateMetric(testResult.getId(), "duration", durationSeconds);
            
            // Add duration to test result metadata
            Map<String, Object> metadata = testResult.getMetadata();
            if (metadata == null) {
                metadata = new HashMap<>();
                testResult.setMetadata(metadata);
            }
            
            metadata.put("durationSeconds", durationSeconds);
        }
        
        // Test counts
        int totalTests = 0;
        int passedTests = 0;
        int failedTests = 0;
        int skippedTests = 0;
        
        if (testResult.getTestSuites() != null) {
            for (CSTestSuite suite : testResult.getTestSuites()) {
                if (suite.getTestCases() != null) {
                    for (CSTestCase testCase : suite.getTestCases()) {
                        totalTests++;
                        
                        if ("PASSED".equals(testCase.getStatus())) {
                            passedTests++;
                        } else if ("FAILED".equals(testCase.getStatus())) {
                            failedTests++;
                        } else if ("SKIPPED".equals(testCase.getStatus())) {
                            skippedTests++;
                        }
                    }
                }
            }
        }
        
        // Create test counts metric
        Map<String, Integer> testCounts = new HashMap<>();
        testCounts.put("total", totalTests);
        testCounts.put("passed", passedTests);
        testCounts.put("failed", failedTests);
        testCounts.put("skipped", skippedTests);
        
        updateMetric(testResult.getId(), "testCounts", testCounts);
        
        // Add test counts to test result metadata
        Map<String, Object> metadata = testResult.getMetadata();
        if (metadata == null) {
            metadata = new HashMap<>();
            testResult.setMetadata(metadata);
        }
        
        metadata.put("totalTests", totalTests);
        metadata.put("passedTests", passedTests);
        metadata.put("failedTests", failedTests);
        metadata.put("skippedTests", skippedTests);
        
        if (totalTests > 0) {
            metadata.put("passRate", (double) passedTests / totalTests);
        }
    }
    
    /**
     * Updates file references when importing a test run with a new ID.
     * 
     * @param targetDir The target directory
     * @param oldRunId The old run ID
     * @param newRunId The new run ID
     * @throws IOException If there is an error updating file references
     */
    private void updateFileReferences(Path targetDir, String oldRunId, String newRunId) throws IOException {
        // Process all JSON files in the directory tree
        try (Stream<Path> paths = Files.walk(targetDir)) {
            paths.filter(path -> path.toString().endsWith(JSON_EXTENSION))
                .forEach(path -> {
                    try {
                        // Read file content
                        String content = new String(Files.readAllBytes(path));
                        
                        // Replace run ID in file paths
                        content = content.replace("\"" + SCREENSHOTS_DIR + "/" + oldRunId + "_", 
                            "\"" + SCREENSHOTS_DIR + "/" + newRunId + "_");
                        content = content.replace("\"" + VIDEOS_DIR + "/" + oldRunId + "_", 
                            "\"" + VIDEOS_DIR + "/" + newRunId + "_");
                        content = content.replace("\"" + ATTACHMENTS_DIR + "/" + oldRunId + "_", 
                            "\"" + ATTACHMENTS_DIR + "/" + newRunId + "_");
                        content = content.replace("\"" + LOGS_DIR + "/" + LOG_PREFIX + oldRunId, 
                            "\"" + LOGS_DIR + "/" + LOG_PREFIX + newRunId);
                        
                        // Replace run ID in ID field
                        content = content.replace("\"id\":\"" + oldRunId + "\"", 
                            "\"id\":\"" + newRunId + "\"");
                        content = content.replace("\"runId\":\"" + oldRunId + "\"", 
                            "\"runId\":\"" + newRunId + "\"");
                        
                        // Write updated content
                        Files.write(path, content.getBytes());
                        
                        // Rename file if it contains the run ID
                        String fileName = path.getFileName().toString();
                        if (fileName.contains(oldRunId)) {
                            String newFileName = fileName.replace(oldRunId, newRunId);
                            Path newPath = path.resolveSibling(newFileName);
                            Files.move(path, newPath, StandardCopyOption.REPLACE_EXISTING);
                        }
                    } catch (IOException e) {
                        CSLogger.warn("Failed to update file references in: " + path, e);
                    }
                });
        }
        
        // Rename directories that contain the run ID
        try (Stream<Path> paths = Files.walk(targetDir, 1)) {
            paths.filter(Files::isDirectory)
                .filter(path -> !path.equals(targetDir))
                .filter(path -> path.getFileName().toString().contains(oldRunId))
                .sorted(Comparator.reverseOrder())
                .forEach(path -> {
                    try {
                        String dirName = path.getFileName().toString();
                        String newDirName = dirName.replace(oldRunId, newRunId);
                        Path newPath = path.resolveSibling(newDirName);
                        Files.move(path, newPath, StandardCopyOption.REPLACE_EXISTING);
                    } catch (IOException e) {
                        CSLogger.warn("Failed to rename directory: " + path, e);
                    }
                });
        }
    }
    
    /**
     * Updates file paths in a test result when importing with a new ID.
     * 
     * @param testResult The test result to update
     * @param oldRunId The old run ID
     * @param newRunId The new run ID
     */
    private void updateTestResultPaths(CSTestResult testResult, String oldRunId, String newRunId) {
        // Update run ID
        testResult.setId(newRunId);
        
        // Update screenshots paths
        if (testResult.getScreenshots() != null) {
            List<String> screenshots = testResult.getScreenshots();
            for (int i = 0; i < screenshots.size(); i++) {
                String path = screenshots.get(i);
                screenshots.set(i, path.replace(oldRunId, newRunId));
            }
        }
        
        // Update videos paths
        if (testResult.getVideos() != null) {
            List<String> videos = testResult.getVideos();
            for (int i = 0; i < videos.size(); i++) {
                String path = videos.get(i);
                videos.set(i, path.replace(oldRunId, newRunId));
            }
        }
        
        // Update log file path
        if (testResult.getLogFile() != null) {
            String logFile = testResult.getLogFile();
            testResult.setLogFile(logFile.replace(oldRunId, newRunId));
        }
        
        // Update metrics paths
        if (testResult.getMetrics() != null) {
            Map<String, String> metrics = testResult.getMetrics();
            Map<String, String> updatedMetrics = new HashMap<>();
            
            for (Map.Entry<String, String> entry : metrics.entrySet()) {
                String metricName = entry.getKey();
                String metricPath = entry.getValue();
                
                updatedMetrics.put(metricName, metricPath.replace(oldRunId, newRunId));
            }
            
            testResult.setMetrics(updatedMetrics);
        }
        
        // Update test suites
        if (testResult.getTestSuites() != null) {
            for (CSTestSuite suite : testResult.getTestSuites()) {
                suite.setRunId(newRunId);
                
                // Update test cases
                if (suite.getTestCases() != null) {
                    for (CSTestCase testCase : suite.getTestCases()) {
                        testCase.setRunId(newRunId);
                        
                        // Update test steps
                        if (testCase.getTestSteps() != null) {
                            for (CSTestStep testStep : testCase.getTestSteps()) {
                                testStep.setRunId(newRunId);
                                
                                // Update screenshots
                                if (testStep.getScreenshots() != null) {
                                    for (CSScreenshot screenshot : testStep.getScreenshots()) {
                                        if (screenshot.getFilePath() != null) {
                                            screenshot.setFilePath(
                                                screenshot.getFilePath().replace(oldRunId, newRunId));
                                        }
                                    }
                                }
                                
                                // Update attachments
                                if (testStep.getAttachments() != null) {
                                    for (CSAttachment attachment : testStep.getAttachments()) {
                                        if (attachment.getFilePath() != null) {
                                            attachment.setFilePath(
                                                attachment.getFilePath().replace(oldRunId, newRunId));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Creates a ZIP file from a directory.
     * 
     * @param sourceDir The source directory
     * @param zipFilePath The path to the ZIP file to create
     * @throws IOException If there is an error creating the ZIP file
     */
    private void createZipFile(Path sourceDir, Path zipFilePath) throws IOException {
        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFilePath.toFile()))) {
            Files.walk(sourceDir)
                .filter(path -> !Files.isDirectory(path))
                .forEach(path -> {
                    ZipEntry zipEntry = new ZipEntry(sourceDir.relativize(path).toString());
                    try {
                        zos.putNextEntry(zipEntry);
                        Files.copy(path, zos);
                        zos.closeEntry();
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                });
        }
    }
    
    /**
     * Extracts a ZIP file to a directory.
     * 
     * @param zipFilePath The path to the ZIP file
     * @param targetDir The target directory
     * @throws IOException If there is an error extracting the ZIP file
     */
    private void extractZipFile(Path zipFilePath, Path targetDir) throws IOException {
        try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zipFilePath))) {
            ZipEntry zipEntry;
            while ((zipEntry = zis.getNextEntry()) != null) {
                Path entryPath = targetDir.resolve(zipEntry.getName());
                
                // Create directories if needed
                Files.createDirectories(entryPath.getParent());
                
                // Extract file
                if (!zipEntry.isDirectory()) {
                    Files.copy(zis, entryPath, StandardCopyOption.REPLACE_EXISTING);
                }
                
                zis.closeEntry();
            }
        }
    }
    
    /**
     * Copies a directory recursively.
     * 
     * @param sourceDir The source directory
     * @param targetDir The target directory
     * @throws IOException If there is an error copying the directory
     */
    private void copyDirectory(Path sourceDir, Path targetDir) throws IOException {
        Files.walk(sourceDir)
            .forEach(sourcePath -> {
                try {
                    Path targetPath = targetDir.resolve(sourceDir.relativize(sourcePath));
                    if (Files.isDirectory(sourcePath)) {
                        if (!Files.exists(targetPath)) {
                            Files.createDirectories(targetPath);
                        }
                    } else {
                        Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            });
    }
    
    /**
     * Sanitizes a file name.
     * 
     * @param fileName The file name to sanitize
     * @return The sanitized file name
     */
    private String sanitizeFileName(String fileName) {
        if (fileName == null || fileName.trim().isEmpty()) {
            return "unnamed";
        }
        
        // Replace invalid characters
        String sanitized = fileName.replaceAll("[^a-zA-Z0-9._-]", "_");
        
        // Limit length
        if (sanitized.length() > 100) {
            sanitized = sanitized.substring(0, 100);
        }
        
        return sanitized;
    }
    
    /**
     * Clears the caches for improved memory management.
     * This should be called periodically to prevent the cache from growing too large.
     */
    public void clearCaches() {
        testRunCache.clear();
        testRunIndexCache.clear();
        CSLogger.info("Cleared all test result storage caches");
    }
    
    /**
     * Prunes old cache entries that haven't been accessed recently.
     * 
     * @param maxAge The maximum age in milliseconds for cache entries
     */
    public void pruneCache(long maxAge) {
        // Since we don't track access times for cache entries,
        // just clear all caches
        clearCaches();
    }
    
    /**
     * Performs maintenance tasks on the storage system.
     * This includes cleaning up temporary files, pruning caches, etc.
     */
    public void performMaintenance() {
        try {
            // Clean up temp export files older than 24 hours
            Path tempDir = Paths.get(CSConstants.TEMP_DIR);
            if (Files.exists(tempDir)) {
                try (Stream<Path> paths = Files.list(tempDir)) {
                    paths.filter(path -> path.getFileName().toString().startsWith("testrun_") && 
                                     path.getFileName().toString().endsWith(ZIP_EXTENSION))
                        .filter(path -> {
                            try {
                                return Files.getLastModifiedTime(path).toMillis() < 
                                    System.currentTimeMillis() - (24 * 60 * 60 * 1000L);
                            } catch (IOException e) {
                                return false;
                            }
                        })
                        .forEach(path -> {
                            try {
                                Files.delete(path);
                            } catch (IOException e) {
                                CSLogger.warn("Failed to delete old export file: " + path, e);
                            }
                        });
                }
            }
            
            // Prune cache
            pruneCache(24 * 60 * 60 * 1000L); // 24 hours
            
            // Compress old logs
            Path logsDir = pathResolver.resolveResultsBasePath().resolve(LOGS_DIR);
            if (Files.exists(logsDir)) {
                try (Stream<Path> paths = Files.list(logsDir)) {
                    paths.filter(path -> path.getFileName().toString().endsWith(LOG_EXTENSION))
                        .filter(path -> {
                            try {
                                return Files.getLastModifiedTime(path).toMillis() < 
                                    System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000L);
                            } catch (IOException e) {
                                return false;
                            }
                        })
                        .forEach(path -> {
                            try {
                                // Compress log file
                                byte[] compressedLogs = compressionService.compressFile(path.toFile());
                                
                                // Save compressed logs
                                Path compressedLogPath = Paths.get(path.toString() + ".gz");
                                Files.write(compressedLogPath, compressedLogs);
                                
                                // Delete original log file
                                Files.delete(path);
                                
                                // Update log path in test result
                                String fileName = path.getFileName().toString();
                                String runId = fileName.substring(LOG_PREFIX.length(), 
                                    fileName.length() - LOG_EXTENSION.length());
                                
                                getTestRun(runId).ifPresent(testResult -> {
                                    if (testResult.getLogFile() != null && 
                                        testResult.getLogFile().equals(LOGS_DIR + "/" + fileName)) {
                                        
                                        testResult.setLogFile(LOGS_DIR + "/" + fileName + ".gz");
                                        
                                        try {
                                            saveTestRunFile(testResult);
                                            
                                            // Update cache
                                            testRunCache.put(runId, testResult);
                                        } catch (IOException e) {
                                            CSLogger.warn("Failed to update test run with compressed log path: " + runId, e);
                                        }
                                    }
                                });
                            } catch (IOException e) {
                                CSLogger.warn("Failed to compress log file: " + path, e);
                            }
                        });
                }
            }
            
            CSLogger.info("Test results storage maintenance completed successfully");
        } catch (Exception e) {
            CSLogger.error("Error during test results storage maintenance", e);
        }
    }
}


ConfigStorageImpl.java
--------------------------------

package com.cstestforge.service.storage.impl;

import com.cstestforge.framework.core.config.ConfigValidator;
import com.cstestforge.framework.core.config.EnvironmentConfig;
import com.cstestforge.framework.core.config.FrameworkConfig;
import com.cstestforge.framework.core.utils.CSConstants;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.service.storage.BackupService;
import com.cstestforge.service.storage.DataSerializer;
import com.cstestforge.service.storage.FileLockManager;
import com.cstestforge.service.storage.StoragePathResolver;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.stream.Collectors;

/**
 * Implementation of configuration storage using the file system.
 * This class provides operations for storing and retrieving configuration
 * settings including framework configuration, environment configuration,
 * and user preferences without relying on a database.
 * 
 * @author CSTestForge Team
 */
@Service
public class ConfigStorageImpl {

    private static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss");
    private static final String CONFIG_DIR = "config";
    private static final String FRAMEWORK_CONFIG_FILE = "framework_config.json";
    private static final String ENVIRONMENT_CONFIG_FILE = "environment_config.json";
    private static final String USER_PREFERENCES_DIR = "user_preferences";
    private static final String HISTORY_DIR = "history";
    
    // Cache to improve performance
    private final ConcurrentHashMap<String, FrameworkConfig> frameworkConfigCache = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, EnvironmentConfig> environmentConfigCache = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, Map<String, Object>> userPreferencesCache = new ConcurrentHashMap<>();
    
    // Read-write locks for thread safety
    private final ReadWriteLock frameworkConfigLock = new ReentrantReadWriteLock();
    private final ReadWriteLock environmentConfigLock = new ReentrantReadWriteLock();
    private final ConcurrentHashMap<String, ReadWriteLock> userPreferencesLocks = new ConcurrentHashMap<>();
    
    @Autowired
    private StoragePathResolver pathResolver;
    
    @Autowired
    private DataSerializer dataSerializer;
    
    @Autowired
    private FileLockManager fileLockManager;
    
    @Autowired
    private BackupService backupService;
    
    @Autowired
    private ConfigValidator configValidator;
    
    /**
     * Initializes the configuration storage system.
     * Creates necessary directories if they don't exist.
     */
    public void initialize() {
        try {
            // Ensure base config directory exists
            Path configBasePath = pathResolver.resolveConfigBasePath();
            if (!Files.exists(configBasePath)) {
                Files.createDirectories(configBasePath);
                CSLogger.info("Created config base directory at: " + configBasePath);
            }
            
            // Ensure user preferences directory exists
            Path userPreferencesPath = configBasePath.resolve(USER_PREFERENCES_DIR);
            if (!Files.exists(userPreferencesPath)) {
                Files.createDirectories(userPreferencesPath);
            }
            
            // Ensure history directory exists
            Path historyPath = configBasePath.resolve(HISTORY_DIR);
            if (!Files.exists(historyPath)) {
                Files.createDirectories(historyPath);
            }
            
            // Create default framework config if it doesn't exist
            Path frameworkConfigPath = configBasePath.resolve(FRAMEWORK_CONFIG_FILE);
            if (!Files.exists(frameworkConfigPath)) {
                FrameworkConfig defaultConfig = createDefaultFrameworkConfig();
                saveFrameworkConfig(defaultConfig);
                CSLogger.info("Created default framework configuration");
            }
            
            // Create default environment config if it doesn't exist
            Path environmentConfigPath = configBasePath.resolve(ENVIRONMENT_CONFIG_FILE);
            if (!Files.exists(environmentConfigPath)) {
                EnvironmentConfig defaultConfig = createDefaultEnvironmentConfig();
                saveEnvironmentConfig(defaultConfig);
                CSLogger.info("Created default environment configuration");
            }
            
            CSLogger.info("Configuration storage initialized successfully");
        } catch (IOException e) {
            CSLogger.error("Failed to initialize configuration storage", e);
            throw new RuntimeException("Failed to initialize configuration storage", e);
        }
    }
    
    /**
     * Creates default framework configuration.
     * 
     * @return The default framework configuration
     */
    private FrameworkConfig createDefaultFrameworkConfig() {
        FrameworkConfig config = new FrameworkConfig();
        
        // Set default values
        config.setVersion(CSConstants.FRAMEWORK_VERSION);
        config.setDefaultTestingFramework("selenium");
        config.setDefaultLanguage("java");
        config.setDefaultTestFramework("testng");
        config.setMaxParallelThreads(Runtime.getRuntime().availableProcessors());
        config.setDefaultTimeoutSeconds(30);
        config.setScreenshotOnFailure(true);
        config.setScreenshotOnPass(false);
        config.setVideoRecording(false);
        config.setDetailedLogging(true);
        config.setRetryFailedTests(false);
        config.setMaxRetryCount(3);
        config.setUseAI(true);
        config.setSelfHealingLocators(true);
        
        // Set additional properties
        Map<String, Object> properties = new HashMap<>();
        properties.put("reportFormat", "html");
        properties.put("reportLogo", "default");
        properties.put("defaultBrowser", "chrome");
        properties.put("defaultMobileDevice", "iPhone 12");
        properties.put("pollInterval", 500);
        properties.put("fileEncoding", "UTF-8");
        properties.put("defaultDataSource", "excel");
        properties.put("defaultLocatorStrategy", "id");
        properties.put("preRunScriptTimeout", 60);
        properties.put("postRunScriptTimeout", 60);
        properties.put("elementHighlightColor", "#C54B8C");
        properties.put("screenshotQuality", 90);
        properties.put("videoQuality", "medium");
        properties.put("networkThrottling", false);
        
        config.setProperties(properties);
        
        return config;
    }
    
    /**
     * Creates default environment configuration.
     * 
     * @return The default environment configuration
     */
    private EnvironmentConfig createDefaultEnvironmentConfig() {
        EnvironmentConfig config = new EnvironmentConfig();
        
        // Set default environments
        Map<String, Map<String, String>> environments = new HashMap<>();
        
        // Development environment
        Map<String, String> devEnv = new HashMap<>();
        devEnv.put("baseUrl", "http://localhost:8080");
        devEnv.put("apiUrl", "http://localhost:8080/api");
        devEnv.put("username", "testuser");
        devEnv.put("password", "password");
        devEnv.put("databaseUrl", "jdbc:h2:mem:testdb");
        devEnv.put("databaseUsername", "sa");
        devEnv.put("databasePassword", "");
        environments.put("development", devEnv);
        
        // QA environment
        Map<String, String> qaEnv = new HashMap<>();
        qaEnv.put("baseUrl", "https://qa.example.com");
        qaEnv.put("apiUrl", "https://qa.example.com/api");
        qaEnv.put("username", "testuser");
        qaEnv.put("password", "password");
        qaEnv.put("databaseUrl", "jdbc:mysql://qa-db.example.com:3306/testdb");
        qaEnv.put("databaseUsername", "testuser");
        qaEnv.put("databasePassword", "password");
        environments.put("qa", qaEnv);
        
        // Staging environment
        Map<String, String> stagingEnv = new HashMap<>();
        stagingEnv.put("baseUrl", "https://staging.example.com");
        stagingEnv.put("apiUrl", "https://staging.example.com/api");
        stagingEnv.put("username", "testuser");
        stagingEnv.put("password", "password");
        stagingEnv.put("databaseUrl", "jdbc:mysql://staging-db.example.com:3306/testdb");
        stagingEnv.put("databaseUsername", "testuser");
        stagingEnv.put("databasePassword", "password");
        environments.put("staging", stagingEnv);
        
        // Production environment
        Map<String, String> prodEnv = new HashMap<>();
        prodEnv.put("baseUrl", "https://example.com");
        prodEnv.put("apiUrl", "https://example.com/api");
        prodEnv.put("username", "${env:PROD_USERNAME}");
        prodEnv.put("password", "${env:PROD_PASSWORD}");
        prodEnv.put("databaseUrl", "jdbc:mysql://db.example.com:3306/proddb");
        prodEnv.put("databaseUsername", "${env:PROD_DB_USERNAME}");
        prodEnv.put("databasePassword", "${env:PROD_DB_PASSWORD}");
        environments.put("production", prodEnv);
        
        config.setEnvironments(environments);
        config.setCurrentEnvironment("development");
        
        // Set global variables
        Map<String, String> globalVariables = new HashMap<>();
        globalVariables.put("timeout", "30");
        globalVariables.put("retryCount", "3");
        globalVariables.put("implicitWait", "10");
        globalVariables.put("screenshotPath", "${user.home}/cstestforge/screenshots");
        globalVariables.put("reportPath", "${user.home}/cstestforge/reports");
        globalVariables.put("dataPath", "${user.home}/cstestforge/data");
        globalVariables.put("logLevel", "INFO");
        
        config.setGlobalVariables(globalVariables);
        
        return config;
    }
    
    /**
     * Gets the framework configuration.
     * 
     * @return The framework configuration
     */
    public FrameworkConfig getFrameworkConfig() {
        // Check cache first
        FrameworkConfig cachedConfig = frameworkConfigCache.get("current");
        if (cachedConfig != null) {
            return cachedConfig;
        }
        
        try {
            Path configPath = pathResolver.resolveConfigBasePath().resolve(FRAMEWORK_CONFIG_FILE);
            if (!Files.exists(configPath)) {
                // Create default configuration if it doesn't exist
                FrameworkConfig defaultConfig = createDefaultFrameworkConfig();
                saveFrameworkConfig(defaultConfig);
                return defaultConfig;
            }
            
            // Acquire read lock
            frameworkConfigLock.readLock().lock();
            
            try {
                // Lock the file
                fileLockManager.acquireReadLock(configPath);
                
                try {
                    // Read and deserialize configuration
                    String content = new String(Files.readAllBytes(configPath));
                    FrameworkConfig config = dataSerializer.deserialize(content, FrameworkConfig.class);
                    
                    // Cache the result
                    frameworkConfigCache.put("current", config);
                    
                    return config;
                } finally {
                    fileLockManager.releaseReadLock(configPath);
                }
            } finally {
                frameworkConfigLock.readLock().unlock();
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read framework configuration", e);
            throw new RuntimeException("Failed to read framework configuration", e);
        }
    }
    
    /**
     * Saves the framework configuration.
     * 
     * @param config The framework configuration to save
     */
    public void saveFrameworkConfig(FrameworkConfig config) {
        // Validate configuration
        List<String> validationErrors = configValidator.validateFrameworkConfig(config);
        if (!validationErrors.isEmpty()) {
            throw new IllegalArgumentException("Invalid framework configuration: " + 
                String.join(", ", validationErrors));
        }
        
        try {
            Path configPath = pathResolver.resolveConfigBasePath().resolve(FRAMEWORK_CONFIG_FILE);
            
            // Make backup before saving
            if (Files.exists(configPath)) {
                backupFrameworkConfig();
            } else {
                // Ensure parent directory exists
                Files.createDirectories(configPath.getParent());
            }
            
            // Acquire write lock
            frameworkConfigLock.writeLock().lock();
            
            try {
                // Lock the file
                fileLockManager.acquireWriteLock(configPath);
                
                try {
                    // Serialize and write configuration
                    String serialized = dataSerializer.serialize(config);
                    Files.write(configPath, serialized.getBytes());
                    
                    // Update cache
                    frameworkConfigCache.put("current", config);
                } finally {
                    fileLockManager.releaseWriteLock(configPath);
                }
            } finally {
                frameworkConfigLock.writeLock().unlock();
            }
        } catch (IOException e) {
            CSLogger.error("Failed to save framework configuration", e);
            throw new RuntimeException("Failed to save framework configuration", e);
        }
    }
    
    /**
     * Gets the environment configuration.
     * 
     * @return The environment configuration
     */
    public EnvironmentConfig getEnvironmentConfig() {
        // Check cache first
        EnvironmentConfig cachedConfig = environmentConfigCache.get("current");
        if (cachedConfig != null) {
            return cachedConfig;
        }
        
        try {
            Path configPath = pathResolver.resolveConfigBasePath().resolve(ENVIRONMENT_CONFIG_FILE);
            if (!Files.exists(configPath)) {
                // Create default configuration if it doesn't exist
                EnvironmentConfig defaultConfig = createDefaultEnvironmentConfig();
                saveEnvironmentConfig(defaultConfig);
                return defaultConfig;
            }
            
            // Acquire read lock
            environmentConfigLock.readLock().lock();
            
            try {
                // Lock the file
                fileLockManager.acquireReadLock(configPath);
                
                try {
                    // Read and deserialize configuration
                    String content = new String(Files.readAllBytes(configPath));
                    EnvironmentConfig config = dataSerializer.deserialize(content, EnvironmentConfig.class);
                    
                    // Cache the result
                    environmentConfigCache.put("current", config);
                    
                    return config;
                } finally {
                    fileLockManager.releaseReadLock(configPath);
                }
            } finally {
                environmentConfigLock.readLock().unlock();
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read environment configuration", e);
            throw new RuntimeException("Failed to read environment configuration", e);
        }
    }
    
    /**
     * Saves the environment configuration.
     * 
     * @param config The environment configuration to save
     */
    public void saveEnvironmentConfig(EnvironmentConfig config) {
        // Validate configuration
        List<String> validationErrors = configValidator.validateEnvironmentConfig(config);
        if (!validationErrors.isEmpty()) {
            throw new IllegalArgumentException("Invalid environment configuration: " + 
                String.join(", ", validationErrors));
        }
        
        try {
            Path configPath = pathResolver.resolveConfigBasePath().resolve(ENVIRONMENT_CONFIG_FILE);
            
            // Make backup before saving
            if (Files.exists(configPath)) {
                backupEnvironmentConfig();
            } else {
                // Ensure parent directory exists
                Files.createDirectories(configPath.getParent());
            }
            
            // Acquire write lock
            environmentConfigLock.writeLock().lock();
            
            try {
                // Lock the file
                fileLockManager.acquireWriteLock(configPath);
                
                try {
                    // Serialize and write configuration
                    String serialized = dataSerializer.serialize(config);
                    Files.write(configPath, serialized.getBytes());
                    
                    // Update cache
                    environmentConfigCache.put("current", config);
                } finally {
                    fileLockManager.releaseWriteLock(configPath);
                }
            } finally {
                environmentConfigLock.writeLock().unlock();
            }
        } catch (IOException e) {
            CSLogger.error("Failed to save environment configuration", e);
            throw new RuntimeException("Failed to save environment configuration", e);
        }
    }
    
    /**
     * Gets user preferences.
     * 
     * @param userId The ID of the user
     * @return The user preferences
     */
    public Map<String, Object> getUserPreferences(String userId) {
        if (userId == null || userId.trim().isEmpty()) {
            throw new IllegalArgumentException("User ID cannot be null or empty");
        }
        
        // Check cache first
        Map<String, Object> cachedPreferences = userPreferencesCache.get(userId);
        if (cachedPreferences != null) {
            return new HashMap<>(cachedPreferences); // Return a copy to prevent modifications
        }
        
        try {
            Path preferencesPath = getUserPreferencesPath(userId);
            if (!Files.exists(preferencesPath)) {
                // Return empty preferences if file doesn't exist
                return new HashMap<>();
            }
            
            // Acquire read lock
            ReadWriteLock lock = getUserPreferencesLock(userId);
            lock.readLock().lock();
            
            try {
                // Lock the file
                fileLockManager.acquireReadLock(preferencesPath);
                
                try {
                    // Read and deserialize preferences
                    String content = new String(Files.readAllBytes(preferencesPath));
                    Map<String, Object> preferences = dataSerializer.deserialize(content, Map.class);
                    
                    // Cache the result
                    userPreferencesCache.put(userId, new HashMap<>(preferences));
                    
                    return preferences;
                } finally {
                    fileLockManager.releaseReadLock(preferencesPath);
                }
            } finally {
                lock.readLock().unlock();
            }
        } catch (IOException e) {
            CSLogger.error("Failed to read user preferences for user: " + userId, e);
            throw new RuntimeException("Failed to read user preferences", e);
        }
    }
    
    /**
     * Saves user preferences.
     * 
     * @param userId The ID of the user
     * @param preferences The preferences to save
     */
    public void saveUserPreferences(String userId, Map<String, Object> preferences) {
        if (userId == null || userId.trim().isEmpty()) {
            throw new IllegalArgumentException("User ID cannot be null or empty");
        }
        
        if (preferences == null) {
            preferences = new HashMap<>();
        }
        
        try {
            Path preferencesPath = getUserPreferencesPath(userId);
            
            // Make backup before saving
            if (Files.exists(preferencesPath)) {
                backupUserPreferences(userId);
            } else {
                // Ensure parent directory exists
                Files.createDirectories(preferencesPath.getParent());
            }
            
            // Acquire write lock
            ReadWriteLock lock = getUserPreferencesLock(userId);
            lock.writeLock().lock();
            
            try {
                // Lock the file
                fileLockManager.acquireWriteLock(preferencesPath);
                
                try {
                    // Serialize and write preferences
                    String serialized = dataSerializer.serialize(preferences);
                    Files.write(preferencesPath, serialized.getBytes());
                    
                    // Update cache
                    userPreferencesCache.put(userId, new HashMap<>(preferences));
                } finally {
                    fileLockManager.releaseWriteLock(preferencesPath);
                }
            } finally {
                lock.writeLock().unlock();
            }
        } catch (IOException e) {
            CSLogger.error("Failed to save user preferences for user: " + userId, e);
            throw new RuntimeException("Failed to save user preferences", e);
        }
    }
    
    /**
     * Updates a specific user preference.
     * 
     * @param userId The ID of the user
     * @param key The preference key
     * @param value The preference value
     */
    public void updateUserPreference(String userId, String key, Object value) {
        if (userId == null || userId.trim().isEmpty()) {
            throw new IllegalArgumentException("User ID cannot be null or empty");
        }
        
        if (key == null || key.trim().isEmpty()) {
            throw new IllegalArgumentException("Preference key cannot be null or empty");
        }
        
        // Get current preferences
        Map<String, Object> preferences = getUserPreferences(userId);
        
        // Update preference
        if (value == null) {
            preferences.remove(key);
        } else {
            preferences.put(key, value);
        }
        
        // Save updated preferences
        saveUserPreferences(userId, preferences);
    }
    
    /**
     * Gets the history of framework configuration changes.
     * 
     * @param limit The maximum number of history entries to return
     * @return A list of framework configuration history entries
     */
    public List<FrameworkConfig> getFrameworkConfigHistory(int limit) {
        try {
            Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
            if (!Files.exists(historyDir)) {
                return new ArrayList<>();
            }
            
            List<FrameworkConfig> history = new ArrayList<>();
            
            // List all framework config history files
            List<Path> historyFiles = Files.list(historyDir)
                .filter(path -> path.getFileName().toString().startsWith("framework_config_"))
                .sorted((p1, p2) -> p2.getFileName().toString().compareTo(p1.getFileName().toString())) // Sort in reverse order (newest first)
                .limit(limit)
                .collect(Collectors.toList());
            
            // Read each history file
            for (Path historyFile : historyFiles) {
                try {
                    // Lock the file
                    fileLockManager.acquireReadLock(historyFile);
                    
                    try {
                        // Read and deserialize configuration
                        String content = new String(Files.readAllBytes(historyFile));
                        FrameworkConfig config = dataSerializer.deserialize(content, FrameworkConfig.class);
                        
                        history.add(config);
                    } finally {
                        fileLockManager.releaseReadLock(historyFile);
                    }
                } catch (IOException e) {
                    CSLogger.warn("Failed to read framework configuration history file: " + historyFile, e);
                    // Continue with next file
                }
            }
            
            return history;
        } catch (IOException e) {
            CSLogger.error("Failed to get framework configuration history", e);
            throw new RuntimeException("Failed to get framework configuration history", e);
        }
    }
    
    /**
     * Gets the history of environment configuration changes.
     * 
     * @param limit The maximum number of history entries to return
     * @return A list of environment configuration history entries
     */
    public List<EnvironmentConfig> getEnvironmentConfigHistory(int limit) {
        try {
            Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
            if (!Files.exists(historyDir)) {
                return new ArrayList<>();
            }
            
            List<EnvironmentConfig> history = new ArrayList<>();
            
            // List all environment config history files
            List<Path> historyFiles = Files.list(historyDir)
                .filter(path -> path.getFileName().toString().startsWith("environment_config_"))
                .sorted((p1, p2) -> p2.getFileName().toString().compareTo(p1.getFileName().toString())) // Sort in reverse order (newest first)
                .limit(limit)
                .collect(Collectors.toList());
            
            // Read each history file
            for (Path historyFile : historyFiles) {
                try {
                    // Lock the file
                    fileLockManager.acquireReadLock(historyFile);
                    
                    try {
                        // Read and deserialize configuration
                        String content = new String(Files.readAllBytes(historyFile));
                        EnvironmentConfig config = dataSerializer.deserialize(content, EnvironmentConfig.class);
                        
                        history.add(config);
                    } finally {
                        fileLockManager.releaseReadLock(historyFile);
                    }
                } catch (IOException e) {
                    CSLogger.warn("Failed to read environment configuration history file: " + historyFile, e);
                    // Continue with next file
                }
            }
            
            return history;
        } catch (IOException e) {
            CSLogger.error("Failed to get environment configuration history", e);
            throw new RuntimeException("Failed to get environment configuration history", e);
        }
    }
    
    /**
     * Gets the history of user preference changes.
     * 
     * @param userId The ID of the user
     * @param limit The maximum number of history entries to return
     * @return A list of user preference history entries
     */
    public List<Map<String, Object>> getUserPreferencesHistory(String userId, int limit) {
        if (userId == null || userId.trim().isEmpty()) {
            throw new IllegalArgumentException("User ID cannot be null or empty");
        }
        
        try {
            Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
            if (!Files.exists(historyDir)) {
                return new ArrayList<>();
            }
            
            List<Map<String, Object>> history = new ArrayList<>();
            
            // List all user preferences history files
            List<Path> historyFiles = Files.list(historyDir)
                .filter(path -> path.getFileName().toString().startsWith("user_preferences_" + userId + "_"))
                .sorted((p1, p2) -> p2.getFileName().toString().compareTo(p1.getFileName().toString())) // Sort in reverse order (newest first)
                .limit(limit)
                .collect(Collectors.toList());
            
            // Read each history file
            for (Path historyFile : historyFiles) {
                try {
                    // Lock the file
                    fileLockManager.acquireReadLock(historyFile);
                    
                    try {
                        // Read and deserialize preferences
                        String content = new String(Files.readAllBytes(historyFile));
                        Map<String, Object> preferences = dataSerializer.deserialize(content, Map.class);
                        
                        history.add(preferences);
                    } finally {
                        fileLockManager.releaseReadLock(historyFile);
                    }
                } catch (IOException e) {
                    CSLogger.warn("Failed to read user preferences history file: " + historyFile, e);
                    // Continue with next file
                }
            }
            
            return history;
        } catch (IOException e) {
            CSLogger.error("Failed to get user preferences history for user: " + userId, e);
            throw new RuntimeException("Failed to get user preferences history", e);
        }
    }
    
    /**
     * Restores a framework configuration from history.
     * 
     * @param timestamp The timestamp of the configuration to restore
     * @return True if the configuration was successfully restored, false otherwise
     */
    public boolean restoreFrameworkConfig(String timestamp) {
        if (timestamp == null || timestamp.trim().isEmpty()) {
            throw new IllegalArgumentException("Timestamp cannot be null or empty");
        }
        
        try {
            Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
            Path historyFile = historyDir.resolve("framework_config_" + timestamp + ".json");
            
            if (!Files.exists(historyFile)) {
                return false;
            }
            
            // Lock the file
            fileLockManager.acquireReadLock(historyFile);
            
            try {
                // Read and deserialize configuration
                String content = new String(Files.readAllBytes(historyFile));
                FrameworkConfig config = dataSerializer.deserialize(content, FrameworkConfig.class);
                
                // Save as current configuration
                saveFrameworkConfig(config);
                
                return true;
            } finally {
                fileLockManager.releaseReadLock(historyFile);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to restore framework configuration from history: " + timestamp, e);
            throw new RuntimeException("Failed to restore framework configuration from history", e);
        }
    }
    
    /**
     * Restores an environment configuration from history.
     * 
     * @param timestamp The timestamp of the configuration to restore
     * @return True if the configuration was successfully restored, false otherwise
     */
    public boolean restoreEnvironmentConfig(String timestamp) {
        if (timestamp == null || timestamp.trim().isEmpty()) {
            throw new IllegalArgumentException("Timestamp cannot be null or empty");
        }
        
        try {
            Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
            Path historyFile = historyDir.resolve("environment_config_" + timestamp + ".json");
            
            if (!Files.exists(historyFile)) {
                return false;
            }
            
            // Lock the file
            fileLockManager.acquireReadLock(historyFile);
            
            try {
                // Read and deserialize configuration
                String content = new String(Files.readAllBytes(historyFile));
                EnvironmentConfig config = dataSerializer.deserialize(content, EnvironmentConfig.class);
                
                // Save as current configuration
                saveEnvironmentConfig(config);
                
                return true;
            } finally {
                fileLockManager.releaseReadLock(historyFile);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to restore environment configuration from history: " + timestamp, e);
            throw new RuntimeException("Failed to restore environment configuration from history", e);
        }
    }
    
    /**
     * Restores user preferences from history.
     * 
     * @param userId The ID of the user
     * @param timestamp The timestamp of the preferences to restore
     * @return True if the preferences were successfully restored, false otherwise
     */
    public boolean restoreUserPreferences(String userId, String timestamp) {
        if (userId == null || userId.trim().isEmpty()) {
            throw new IllegalArgumentException("User ID cannot be null or empty");
        }
        
        if (timestamp == null || timestamp.trim().isEmpty()) {
            throw new IllegalArgumentException("Timestamp cannot be null or empty");
        }
        
        try {
            Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
            Path historyFile = historyDir.resolve("user_preferences_" + userId + "_" + timestamp + ".json");
            
            if (!Files.exists(historyFile)) {
                return false;
            }
            
            // Lock the file
            fileLockManager.acquireReadLock(historyFile);
            
            try {
                // Read and deserialize preferences
                String content = new String(Files.readAllBytes(historyFile));
                Map<String, Object> preferences = dataSerializer.deserialize(content, Map.class);
                
                // Save as current preferences
                saveUserPreferences(userId, preferences);
                
                return true;
            } finally {
                fileLockManager.releaseReadLock(historyFile);
            }
        } catch (IOException e) {
            CSLogger.error("Failed to restore user preferences from history for user: " + userId + ", timestamp: " + timestamp, e);
            throw new RuntimeException("Failed to restore user preferences from history", e);
        }
    }
    
    /**
     * Backs up the current framework configuration.
     * 
     * @return The timestamp of the backup
     * @throws IOException If there is an error backing up the configuration
     */
    private String backupFrameworkConfig() throws IOException {
        Path configPath = pathResolver.resolveConfigBasePath().resolve(FRAMEWORK_CONFIG_FILE);
        
        if (!Files.exists(configPath)) {
            return null;
        }
        
        String timestamp = TIMESTAMP_FORMATTER.format(LocalDateTime.now());
        Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
        Path historyFile = historyDir.resolve("framework_config_" + timestamp + ".json");
        
        // Ensure history directory exists
        if (!Files.exists(historyDir)) {
            Files.createDirectories(historyDir);
        }
        
        // Copy current config to history
        Files.copy(configPath, historyFile);
        
        return timestamp;
    }
    
    /**
     * Backs up the current environment configuration.
     * 
     * @return The timestamp of the backup
     * @throws IOException If there is an error backing up the configuration
     */
    private String backupEnvironmentConfig() throws IOException {
        Path configPath = pathResolver.resolveConfigBasePath().resolve(ENVIRONMENT_CONFIG_FILE);
        
        if (!Files.exists(configPath)) {
            return null;
        }
        
        String timestamp = TIMESTAMP_FORMATTER.format(LocalDateTime.now());
        Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
        Path historyFile = historyDir.resolve("environment_config_" + timestamp + ".json");
        
        // Ensure history directory exists
        if (!Files.exists(historyDir)) {
            Files.createDirectories(historyDir);
        }
        
        // Copy current config to history
        Files.copy(configPath, historyFile);
        
        return timestamp;
    }
    
    /**
     * Backs up the current user preferences.
     * 
     * @param userId The ID of the user
     * @return The timestamp of the backup
     * @throws IOException If there is an error backing up the preferences
     */
    private String backupUserPreferences(String userId) throws IOException {
        Path preferencesPath = getUserPreferencesPath(userId);
        
        if (!Files.exists(preferencesPath)) {
            return null;
        }
        
        String timestamp = TIMESTAMP_FORMATTER.format(LocalDateTime.now());
        Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
        Path historyFile = historyDir.resolve("user_preferences_" + userId + "_" + timestamp + ".json");
        
        // Ensure history directory exists
        if (!Files.exists(historyDir)) {
            Files.createDirectories(historyDir);
        }
        
        // Copy current preferences to history
        Files.copy(preferencesPath, historyFile);
        
        return timestamp;
    }
    
    /**
     * Gets the path to the user preferences file.
     * 
     * @param userId The ID of the user
     * @return The path to the user preferences file
     */
    private Path getUserPreferencesPath(String userId) {
        return pathResolver.resolveConfigBasePath().resolve(USER_PREFERENCES_DIR).resolve(userId + ".json");
    }
    
    /**
     * Gets or creates a lock for user preferences.
     * 
     * @param userId The ID of the user
     * @return The user preferences lock
     */
    private ReadWriteLock getUserPreferencesLock(String userId) {
        return userPreferencesLocks.computeIfAbsent(userId, k -> new ReentrantReadWriteLock());
    }
    
    /**
     * Exports a framework configuration to a file.
     * 
     * @param config The framework configuration to export
     * @param filePath The path to export to
     * @throws IOException If there is an error exporting the configuration
     */
    public void exportFrameworkConfig(FrameworkConfig config, Path filePath) throws IOException {
        if (config == null) {
            throw new IllegalArgumentException("Configuration cannot be null");
        }
        
        if (filePath == null) {
            throw new IllegalArgumentException("File path cannot be null");
        }
        
        // Ensure parent directory exists
        if (filePath.getParent() != null && !Files.exists(filePath.getParent())) {
            Files.createDirectories(filePath.getParent());
        }
        
        // Serialize and write configuration
        String serialized = dataSerializer.serialize(config);
        Files.write(filePath, serialized.getBytes());
    }
    
    /**
     * Imports a framework configuration from a file.
     * 
     * @param filePath The path to import from
     * @return The imported framework configuration
     * @throws IOException If there is an error importing the configuration
     */
    public FrameworkConfig importFrameworkConfig(Path filePath) throws IOException {
        if (filePath == null || !Files.exists(filePath)) {
            throw new IllegalArgumentException("File path is null or does not exist");
        }
        
        // Read and deserialize configuration
        String content = new String(Files.readAllBytes(filePath));
        FrameworkConfig config = dataSerializer.deserialize(content, FrameworkConfig.class);
        
        // Validate configuration
        List<String> validationErrors = configValidator.validateFrameworkConfig(config);
        if (!validationErrors.isEmpty()) {
            throw new IllegalArgumentException("Invalid framework configuration: " + 
                String.join(", ", validationErrors));
        }
        
        return config;
    }
    
    /**
     * Exports an environment configuration to a file.
     * 
     * @param config The environment configuration to export
     * @param filePath The path to export to
     * @throws IOException If there is an error exporting the configuration
     */
    public void exportEnvironmentConfig(EnvironmentConfig config, Path filePath) throws IOException {
        if (config == null) {
            throw new IllegalArgumentException("Configuration cannot be null");
        }
        
        if (filePath == null) {
            throw new IllegalArgumentException("File path cannot be null");
        }
        
        // Ensure parent directory exists
        if (filePath.getParent() != null && !Files.exists(filePath.getParent())) {
            Files.createDirectories(filePath.getParent());
        }
        
        // Serialize and write configuration
        String serialized = dataSerializer.serialize(config);
        Files.write(filePath, serialized.getBytes());
    }
    
    /**
     * Imports an environment configuration from a file.
     * 
     * @param filePath The path to import from
     * @return The imported environment configuration
     * @throws IOException If there is an error importing the configuration
     */
    public EnvironmentConfig importEnvironmentConfig(Path filePath) throws IOException {
        if (filePath == null || !Files.exists(filePath)) {
            throw new IllegalArgumentException("File path is null or does not exist");
        }
        
        // Read and deserialize configuration
        String content = new String(Files.readAllBytes(filePath));
        EnvironmentConfig config = dataSerializer.deserialize(content, EnvironmentConfig.class);
        
        // Validate configuration
        List<String> validationErrors = configValidator.validateEnvironmentConfig(config);
        if (!validationErrors.isEmpty()) {
            throw new IllegalArgumentException("Invalid environment configuration: " + 
                String.join(", ", validationErrors));
        }
        
        return config;
    }
    
    /**
     * Adds a new environment to the environment configuration.
     * 
     * @param envName The name of the environment
     * @param envProperties The environment properties
     * @return True if the environment was added, false if it already exists
     */
    public boolean addEnvironment(String envName, Map<String, String> envProperties) {
        if (envName == null || envName.trim().isEmpty()) {
            throw new IllegalArgumentException("Environment name cannot be null or empty");
        }
        
        if (envProperties == null) {
            envProperties = new HashMap<>();
        }
        
        // Get current environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Check if environment already exists
        if (config.getEnvironments().containsKey(envName)) {
            return false;
        }
        
        // Add new environment
        config.getEnvironments().put(envName, envProperties);
        
        // Save updated configuration
        saveEnvironmentConfig(config);
        
        return true;
    }
    
    /**
     * Updates an existing environment in the environment configuration.
     * 
     * @param envName The name of the environment
     * @param envProperties The updated environment properties
     * @return True if the environment was updated, false if it doesn't exist
     */
    public boolean updateEnvironment(String envName, Map<String, String> envProperties) {
        if (envName == null || envName.trim().isEmpty()) {
            throw new IllegalArgumentException("Environment name cannot be null or empty");
        }
        
        if (envProperties == null) {
            envProperties = new HashMap<>();
        }
        
        // Get current environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Check if environment exists
        if (!config.getEnvironments().containsKey(envName)) {
            return false;
        }
        
        // Update environment
        config.getEnvironments().put(envName, envProperties);
        
        // Save updated configuration
        saveEnvironmentConfig(config);
        
        return true;
    }
    
    /**
     * Removes an environment from the environment configuration.
     * 
     * @param envName The name of the environment to remove
     * @return True if the environment was removed, false if it doesn't exist
     */
    public boolean removeEnvironment(String envName) {
        if (envName == null || envName.trim().isEmpty()) {
            throw new IllegalArgumentException("Environment name cannot be null or empty");
        }
        
        // Get current environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Check if environment exists
        if (!config.getEnvironments().containsKey(envName)) {
            return false;
        }
        
        // Check if it's the current environment
        if (envName.equals(config.getCurrentEnvironment())) {
            throw new IllegalArgumentException("Cannot remove the current environment");
        }
        
        // Remove environment
        config.getEnvironments().remove(envName);
        
        // Save updated configuration
        saveEnvironmentConfig(config);
        
        return true;
    }
    
    /**
     * Sets the current environment.
     * 
     * @param envName The name of the environment to set as current
     * @return True if the current environment was set, false if the environment doesn't exist
     */
    public boolean setCurrentEnvironment(String envName) {
        if (envName == null || envName.trim().isEmpty()) {
            throw new IllegalArgumentException("Environment name cannot be null or empty");
        }
        
        // Get current environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Check if environment exists
        if (!config.getEnvironments().containsKey(envName)) {
            return false;
        }
        
        // Set current environment
        config.setCurrentEnvironment(envName);
        
        // Save updated configuration
        saveEnvironmentConfig(config);
        
        return true;
    }
    
    /**
     * Gets the current environment properties.
     * 
     * @return The current environment properties
     */
    public Map<String, String> getCurrentEnvironmentProperties() {
        // Get current environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Get current environment name
        String currentEnv = config.getCurrentEnvironment();
        
        // Return properties for current environment
        return config.getEnvironments().getOrDefault(currentEnv, new HashMap<>());
    }
    
    /**
     * Gets the current environment name.
     * 
     * @return The current environment name
     */
    public String getCurrentEnvironmentName() {
        // Get current environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Return current environment name
        return config.getCurrentEnvironment();
    }
    
    /**
     * Gets a framework configuration property.
     * 
     * @param key The property key
     * @return An Optional containing the property value, or empty if not found
     */
    public Optional<Object> getFrameworkProperty(String key) {
        if (key == null || key.trim().isEmpty()) {
            throw new IllegalArgumentException("Property key cannot be null or empty");
        }
        
        // Get framework configuration
        FrameworkConfig config = getFrameworkConfig();
        
        // Check core properties first
        switch (key) {
            case "version":
                return Optional.ofNullable(config.getVersion());
            case "defaultTestingFramework":
                return Optional.ofNullable(config.getDefaultTestingFramework());
            case "defaultLanguage":
                return Optional.ofNullable(config.getDefaultLanguage());
            case "defaultTestFramework":
                return Optional.ofNullable(config.getDefaultTestFramework());
            case "maxParallelThreads":
                return Optional.of(config.getMaxParallelThreads());
            case "defaultTimeoutSeconds":
                return Optional.of(config.getDefaultTimeoutSeconds());
            case "screenshotOnFailure":
                return Optional.of(config.isScreenshotOnFailure());
            case "screenshotOnPass":
                return Optional.of(config.isScreenshotOnPass());
            case "videoRecording":
                return Optional.of(config.isVideoRecording());
            case "detailedLogging":
                return Optional.of(config.isDetailedLogging());
            case "retryFailedTests":
                return Optional.of(config.isRetryFailedTests());
            case "maxRetryCount":
                return Optional.of(config.getMaxRetryCount());
            case "useAI":
                return Optional.of(config.isUseAI());
            case "selfHealingLocators":
                return Optional.of(config.isSelfHealingLocators());
            default:
                // Check additional properties
                if (config.getProperties() != null) {
                    return Optional.ofNullable(config.getProperties().get(key));
                }
                return Optional.empty();
        }
    }
    
    /**
     * Sets a framework configuration property.
     * 
     * @param key The property key
     * @param value The property value
     */
    public void setFrameworkProperty(String key, Object value) {
        if (key == null || key.trim().isEmpty()) {
            throw new IllegalArgumentException("Property key cannot be null or empty");
        }
        
        // Get framework configuration
        FrameworkConfig config = getFrameworkConfig();
        
        // Update core properties first
        switch (key) {
            case "version":
                if (value == null) {
                    throw new IllegalArgumentException("Version cannot be null");
                }
                config.setVersion(value.toString());
                break;
            case "defaultTestingFramework":
                config.setDefaultTestingFramework(value != null ? value.toString() : null);
                break;
            case "defaultLanguage":
                config.setDefaultLanguage(value != null ? value.toString() : null);
                break;
            case "defaultTestFramework":
                config.setDefaultTestFramework(value != null ? value.toString() : null);
                break;
            case "maxParallelThreads":
                if (value == null) {
                    throw new IllegalArgumentException("Max parallel threads cannot be null");
                }
                config.setMaxParallelThreads(Integer.parseInt(value.toString()));
                break;
            case "defaultTimeoutSeconds":
                if (value == null) {
                    throw new IllegalArgumentException("Default timeout seconds cannot be null");
                }
                config.setDefaultTimeoutSeconds(Integer.parseInt(value.toString()));
                break;
            case "screenshotOnFailure":
                if (value == null) {
                    throw new IllegalArgumentException("Screenshot on failure cannot be null");
                }
                config.setScreenshotOnFailure(Boolean.parseBoolean(value.toString()));
                break;
            case "screenshotOnPass":
                if (value == null) {
                    throw new IllegalArgumentException("Screenshot on pass cannot be null");
                }
                config.setScreenshotOnPass(Boolean.parseBoolean(value.toString()));
                break;
            case "videoRecording":
                if (value == null) {
                    throw new IllegalArgumentException("Video recording cannot be null");
                }
                config.setVideoRecording(Boolean.parseBoolean(value.toString()));
                break;
            case "detailedLogging":
                if (value == null) {
                    throw new IllegalArgumentException("Detailed logging cannot be null");
                }
                config.setDetailedLogging(Boolean.parseBoolean(value.toString()));
                break;
            case "retryFailedTests":
                if (value == null) {
                    throw new IllegalArgumentException("Retry failed tests cannot be null");
                }
                config.setRetryFailedTests(Boolean.parseBoolean(value.toString()));
                break;
            case "maxRetryCount":
                if (value == null) {
                    throw new IllegalArgumentException("Max retry count cannot be null");
                }
                config.setMaxRetryCount(Integer.parseInt(value.toString()));
                break;
            case "useAI":
                if (value == null) {
                    throw new IllegalArgumentException("Use AI cannot be null");
                }
                config.setUseAI(Boolean.parseBoolean(value.toString()));
                break;
            case "selfHealingLocators":
                if (value == null) {
                    throw new IllegalArgumentException("Self healing locators cannot be null");
                }
                config.setSelfHealingLocators(Boolean.parseBoolean(value.toString()));
                break;
            default:
                // Update additional properties
                if (config.getProperties() == null) {
                    config.setProperties(new HashMap<>());
                }
                
                if (value == null) {
                    config.getProperties().remove(key);
                } else {
                    config.getProperties().put(key, value);
                }
                break;
        }
        
        // Save updated configuration
        saveFrameworkConfig(config);
    }
    
    /**
     * Gets an environment property.
     * 
     * @param envName The name of the environment (optional, uses current if null)
     * @param key The property key
     * @return An Optional containing the property value, or empty if not found
     */
    public Optional<String> getEnvironmentProperty(String envName, String key) {
        if (key == null || key.trim().isEmpty()) {
            throw new IllegalArgumentException("Property key cannot be null or empty");
        }
        
        // Get environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Determine environment name
        String environmentName = envName;
        if (environmentName == null || environmentName.trim().isEmpty()) {
            environmentName = config.getCurrentEnvironment();
        }
        
        // Get environment properties
        Map<String, String> envProperties = config.getEnvironments().get(environmentName);
        if (envProperties == null) {
            return Optional.empty();
        }
        
        // Return property value
        return Optional.ofNullable(envProperties.get(key));
    }
    
    /**
     * Sets an environment property.
     * 
     * @param envName The name of the environment (optional, uses current if null)
     * @param key The property key
     * @param value The property value
     * @return True if the property was set, false if the environment doesn't exist
     */
    public boolean setEnvironmentProperty(String envName, String key, String value) {
        if (key == null || key.trim().isEmpty()) {
            throw new IllegalArgumentException("Property key cannot be null or empty");
        }
        
        // Get environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Determine environment name
        String environmentName = envName;
        if (environmentName == null || environmentName.trim().isEmpty()) {
            environmentName = config.getCurrentEnvironment();
        }
        
        // Check if environment exists
        if (!config.getEnvironments().containsKey(environmentName)) {
            return false;
        }
        
        // Get environment properties
        Map<String, String> envProperties = config.getEnvironments().get(environmentName);
        
        // Update property
        if (value == null) {
            envProperties.remove(key);
        } else {
            envProperties.put(key, value);
        }
        
        // Save updated configuration
        saveEnvironmentConfig(config);
        
        return true;
    }
    
    /**
     * Gets a global variable.
     * 
     * @param key The variable key
     * @return An Optional containing the variable value, or empty if not found
     */
    public Optional<String> getGlobalVariable(String key) {
        if (key == null || key.trim().isEmpty()) {
            throw new IllegalArgumentException("Variable key cannot be null or empty");
        }
        
        // Get environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Check if global variables exist
        if (config.getGlobalVariables() == null) {
            return Optional.empty();
        }
        
        // Return variable value
        return Optional.ofNullable(config.getGlobalVariables().get(key));
    }
    
    /**
     * Sets a global variable.
     * 
     * @param key The variable key
     * @param value The variable value
     */
    public void setGlobalVariable(String key, String value) {
        if (key == null || key.trim().isEmpty()) {
            throw new IllegalArgumentException("Variable key cannot be null or empty");
        }
        
        // Get environment configuration
        EnvironmentConfig config = getEnvironmentConfig();
        
        // Ensure global variables exist
        if (config.getGlobalVariables() == null) {
            config.setGlobalVariables(new HashMap<>());
        }
        
        // Update variable
        if (value == null) {
            config.getGlobalVariables().remove(key);
        } else {
            config.getGlobalVariables().put(key, value);
        }
        
        // Save updated configuration
        saveEnvironmentConfig(config);
    }
    
    /**
     * Clears the caches for improved memory management.
     * This should be called periodically to prevent the cache from growing too large.
     */
    public void clearCaches() {
        frameworkConfigCache.clear();
        environmentConfigCache.clear();
        userPreferencesCache.clear();
        CSLogger.info("Cleared all config storage caches");
    }
    
    /**
     * Performs maintenance tasks on the storage system.
     * This includes cleaning up old history files, etc.
     */
    public void performMaintenance() {
        try {
            // Clean up old history files
            Path historyDir = pathResolver.resolveConfigBasePath().resolve(HISTORY_DIR);
            if (Files.exists(historyDir)) {
                // Keep only the last 10 history files for each type
                cleanupHistoryFiles(historyDir, "framework_config_", 10);
                cleanupHistoryFiles(historyDir, "environment_config_", 10);
                
                // Clean up user preferences history (keep last 5 for each user)
                Files.list(historyDir)
                    .filter(path -> path.getFileName().toString().startsWith("user_preferences_"))
                    .map(path -> {
                        String fileName = path.getFileName().toString();
                        int firstUnderscore = fileName.indexOf('_', "user_preferences_".length());
                        return fileName.substring("user_preferences_".length(), firstUnderscore);
                    })
                    .distinct()
                    .forEach(userId -> {
                        try {
                            cleanupHistoryFiles(historyDir, "user_preferences_" + userId + "_", 5);
                        } catch (IOException e) {
                            CSLogger.warn("Failed to clean up history files for user: " + userId, e);
                        }
                    });
            }
            
            // Clear caches
            clearCaches();
            
            CSLogger.info("Configuration storage maintenance completed successfully");
        } catch (Exception e) {
            CSLogger.error("Error during configuration storage maintenance", e);
        }
    }
    
    /**
     * Cleans up history files, keeping only the most recent ones.
     * 
     * @param historyDir The history directory
     * @param prefix The file prefix
     * @param keepCount The number of files to keep
     * @throws IOException If there is an error cleaning up history files
     */
    private void cleanupHistoryFiles(Path historyDir, String prefix, int keepCount) throws IOException {
        List<Path> historyFiles = Files.list(historyDir)
            .filter(path -> path.getFileName().toString().startsWith(prefix))
            .sorted((p1, p2) -> p2.getFileName().toString().compareTo(p1.getFileName().toString())) // Sort in reverse order (newest first)
            .collect(Collectors.toList());
        
        // Delete older files
        if (historyFiles.size() > keepCount) {
            for (int i = keepCount; i < historyFiles.size(); i++) {
                Files.delete(historyFiles.get(i));
            }
        }
    }
}


pom.xml (Root project)
------------------------------------

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.cstestforge</groupId>
    <artifactId>cstestforge</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>
    <name>CSTestForge</name>
    <description>Enterprise-grade test automation framework with multi-framework and multi-language support</description>

    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>${java.version}</maven.compiler.source>
        <maven.compiler.target>${java.version}</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        
        <!-- Dependency Versions -->
        <spring-boot.version>3.1.5</spring-boot.version>
        <selenium.version>4.15.0</selenium.version>
        <playwright.version>1.39.0</playwright.version>
        <testng.version>7.8.0</testng.version>
        <cucumber.version>7.14.0</cucumber.version>
        <jackson.version>2.15.3</jackson.version>
        <commons-io.version>2.15.0</commons-io.version>
        <commons-lang3.version>3.13.0</commons-lang3.version>
        <commons-collections4.version>4.4</commons-collections4.version>
        <commons-text.version>1.11.0</commons-text.version>
        <log4j.version>2.21.1</log4j.version>
        <slf4j.version>2.0.9</slf4j.version>
        <lombok.version>1.18.30</lombok.version>
        <poi.version>5.2.4</poi.version>
        <opencsv.version>5.8</opencsv.version>
        <gson.version>2.10.1</gson.version>
        <guava.version>32.1.2-jre</guava.version>
        
        <!-- Plugin Versions -->
        <maven-compiler-plugin.version>3.11.0</maven-compiler-plugin.version>
        <maven-surefire-plugin.version>3.2.2</maven-surefire-plugin.version>
        <maven-failsafe-plugin.version>3.2.2</maven-failsafe-plugin.version>
        <maven-resources-plugin.version>3.3.1</maven-resources-plugin.version>
        <frontend-maven-plugin.version>1.15.0</frontend-maven-plugin.version>
        <maven-clean-plugin.version>3.3.2</maven-clean-plugin.version>
        <maven-jar-plugin.version>3.3.0</maven-jar-plugin.version>
        <maven-deploy-plugin.version>3.1.1</maven-deploy-plugin.version>
        <maven-install-plugin.version>3.1.1</maven-install-plugin.version>
        <spring-boot-maven-plugin.version>${spring-boot.version}</spring-boot-maven-plugin.version>
        <maven-checkstyle-plugin.version>3.3.1</maven-checkstyle-plugin.version>
        <maven-javadoc-plugin.version>3.6.0</maven-javadoc-plugin.version>
        <jacoco-maven-plugin.version>0.8.11</jacoco-maven-plugin.version>
        
        <!-- Frontend tools -->
        <node.version>v18.18.2</node.version>
        <npm.version>10.2.0</npm.version>
        <typescript.version>5.2.2</typescript.version>
        <react.version>18.2.0</react.version>
    </properties>

    <modules>
        <module>backend</module>
        <module>frontend</module>
    </modules>

    <dependencyManagement>
        <dependencies>
            <!-- Spring Boot BOM -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            
            <!-- Selenium -->
            <dependency>
                <groupId>org.seleniumhq.selenium</groupId>
                <artifactId>selenium-java</artifactId>
                <version>${selenium.version}</version>
            </dependency>
            
            <!-- Playwright -->
            <dependency>
                <groupId>com.microsoft.playwright</groupId>
                <artifactId>playwright</artifactId>
                <version>${playwright.version}</version>
            </dependency>
            
            <!-- TestNG -->
            <dependency>
                <groupId>org.testng</groupId>
                <artifactId>testng</artifactId>
                <version>${testng.version}</version>
            </dependency>
            
            <!-- Cucumber -->
            <dependency>
                <groupId>io.cucumber</groupId>
                <artifactId>cucumber-java</artifactId>
                <version>${cucumber.version}</version>
            </dependency>
            <dependency>
                <groupId>io.cucumber</groupId>
                <artifactId>cucumber-testng</artifactId>
                <version>${cucumber.version}</version>
            </dependency>
            <dependency>
                <groupId>io.cucumber</groupId>
                <artifactId>cucumber-spring</artifactId>
                <version>${cucumber.version}</version>
            </dependency>
            
            <!-- Jackson -->
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>${jackson.version}</version>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-core</artifactId>
                <version>${jackson.version}</version>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-annotations</artifactId>
                <version>${jackson.version}</version>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.datatype</groupId>
                <artifactId>jackson-datatype-jsr310</artifactId>
                <version>${jackson.version}</version>
            </dependency>
            
            <!-- Apache Commons -->
            <dependency>
                <groupId>commons-io</groupId>
                <artifactId>commons-io</artifactId>
                <version>${commons-io.version}</version>
            </dependency>
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>${commons-lang3.version}</version>
            </dependency>
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-collections4</artifactId>
                <version>${commons-collections4.version}</version>
            </dependency>
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-text</artifactId>
                <version>${commons-text.version}</version>
            </dependency>
            
            <!-- Logging -->
            <dependency>
                <groupId>org.apache.logging.log4j</groupId>
                <artifactId>log4j-api</artifactId>
                <version>${log4j.version}</version>
            </dependency>
            <dependency>
                <groupId>org.apache.logging.log4j</groupId>
                <artifactId>log4j-core</artifactId>
                <version>${log4j.version}</version>
            </dependency>
            <dependency>
                <groupId>org.apache.logging.log4j</groupId>
                <artifactId>log4j-slf4j2-impl</artifactId>
                <version>${log4j.version}</version>
            </dependency>
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-api</artifactId>
                <version>${slf4j.version}</version>
            </dependency>
            
            <!-- Apache POI (for Excel) -->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi</artifactId>
                <version>${poi.version}</version>
            </dependency>
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi-ooxml</artifactId>
                <version>${poi.version}</version>
            </dependency>
            
            <!-- OpenCSV -->
            <dependency>
                <groupId>com.opencsv</groupId>
                <artifactId>opencsv</artifactId>
                <version>${opencsv.version}</version>
            </dependency>
            
            <!-- Gson -->
            <dependency>
                <groupId>com.google.code.gson</groupId>
                <artifactId>gson</artifactId>
                <version>${gson.version}</version>
            </dependency>
            
            <!-- Guava -->
            <dependency>
                <groupId>com.google.guava</groupId>
                <artifactId>guava</artifactId>
                <version>${guava.version}</version>
            </dependency>
            
            <!-- Lombok -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
                <scope>provided</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>${maven-compiler-plugin.version}</version>
                    <configuration>
                        <source>${java.version}</source>
                        <target>${java.version}</target>
                        <encoding>${project.build.sourceEncoding}</encoding>
                        <annotationProcessorPaths>
                            <path>
                                <groupId>org.projectlombok</groupId>
                                <artifactId>lombok</artifactId>
                                <version>${lombok.version}</version>
                            </path>
                        </annotationProcessorPaths>
                    </configuration>
                </plugin>
                
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-resources-plugin</artifactId>
                    <version>${maven-resources-plugin.version}</version>
                    <configuration>
                        <encoding>${project.build.sourceEncoding}</encoding>
                    </configuration>
                </plugin>
                
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <version>${maven-surefire-plugin.version}</version>
                    <configuration>
                        <argLine>
                            --add-opens java.base/java.lang=ALL-UNNAMED
                            --add-opens java.base/java.util=ALL-UNNAMED
                            --add-opens java.base/java.io=ALL-UNNAMED
                            --add-opens java.base/java.time=ALL-UNNAMED
                            -Xmx1024m
                        </argLine>
                    </configuration>
                </plugin>
                
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-failsafe-plugin</artifactId>
                    <version>${maven-failsafe-plugin.version}</version>
                </plugin>
                
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>${spring-boot-maven-plugin.version}</version>
                </plugin>
                
                <plugin>
                    <groupId>com.github.eirslett</groupId>
                    <artifactId>frontend-maven-plugin</artifactId>
                    <version>${frontend-maven-plugin.version}</version>
                </plugin>
                
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-clean-plugin</artifactId>
                    <version>${maven-clean-plugin.version}</version>
                </plugin>
                
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-jar-plugin</artifactId>
                    <version>${maven-jar-plugin.version}</version>
                </plugin>
                
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-install-plugin</artifactId>
                    <version>${maven-install-plugin.version}</version>
                </plugin>
                
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-deploy-plugin</artifactId>
                    <version>${maven-deploy-plugin.version}</version>
                </plugin>
                
                <plugin>
                    <groupId>org.jacoco</groupId>
                    <artifactId>jacoco-maven-plugin</artifactId>
                    <version>${jacoco-maven-plugin.version}</version>
                    <executions>
                        <execution>
                            <id>prepare-agent</id>
                            <goals>
                                <goal>prepare-agent</goal>
                            </goals>
                        </execution>
                        <execution>
                            <id>report</id>
                            <phase>prepare-package</phase>
                            <goals>
                                <goal>report</goal>
                            </goals>
                        </execution>
                    </executions>
                </plugin>
                
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-checkstyle-plugin</artifactId>
                    <version>${maven-checkstyle-plugin.version}</version>
                    <configuration>
                        <configLocation>checkstyle.xml</configLocation>
                        <encoding>${project.build.sourceEncoding}</encoding>
                        <consoleOutput>true</consoleOutput>
                        <failsOnError>true</failsOnError>
                        <linkXRef>false</linkXRef>
                    </configuration>
                    <executions>
                        <execution>
                            <id>validate</id>
                            <phase>validate</phase>
                            <goals>
                                <goal>check</goal>
                            </goals>
                        </execution>
                    </executions>
                </plugin>
                
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-javadoc-plugin</artifactId>
                    <version>${maven-javadoc-plugin.version}</version>
                    <configuration>
                        <source>${java.version}</source>
                        <encoding>${project.build.sourceEncoding}</encoding>
                        <detectJavaApiLink>false</detectJavaApiLink>
                    </configuration>
                    <executions>
                        <execution>
                            <id>attach-javadocs</id>
                            <goals>
                                <goal>jar</goal>
                            </goals>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </pluginManagement>
        
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
    
    <profiles>
        <profile>
            <id>dev</id>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
            <properties>
                <spring.profiles.active>dev</spring.profiles.active>
            </properties>
        </profile>
        
        <profile>
            <id>qa</id>
            <properties>
                <spring.profiles.active>qa</spring.profiles.active>
            </properties>
        </profile>
        
        <profile>
            <id>prod</id>
            <properties>
                <spring.profiles.active>prod</spring.profiles.active>
            </properties>
        </profile>
        
        <profile>
            <id>code-coverage</id>
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.jacoco</groupId>
                        <artifactId>jacoco-maven-plugin</artifactId>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>


backend/pom.xml
---------------------------

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>com.cstestforge</groupId>
        <artifactId>cstestforge</artifactId>
        <version>1.0.0</version>
    </parent>

    <artifactId>cstestforge-backend</artifactId>
    <name>CSTestForge Backend</name>
    <description>Backend service for CSTestForge framework</description>

    <dependencies>
        <!-- Spring Boot -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Selenium -->
        <dependency>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-java</artifactId>
        </dependency>
        
        <!-- Playwright -->
        <dependency>
            <groupId>com.microsoft.playwright</groupId>
            <artifactId>playwright</artifactId>
        </dependency>
        
        <!-- TestNG -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
        </dependency>
        
        <!-- Cucumber -->
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-java</artifactId>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-testng</artifactId>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-spring</artifactId>
        </dependency>
        
        <!-- Jackson -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-core</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-annotations</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>
        
        <!-- Apache Commons -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-collections4</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-text</artifactId>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-slf4j2-impl</artifactId>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </dependency>
        
        <!-- Apache POI (for Excel) -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
        </dependency>
        
        <!-- OpenCSV -->
        <dependency>
            <groupId>com.opencsv</groupId>
            <artifactId>opencsv</artifactId>
        </dependency>
        
        <!-- Gson -->
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
        </dependency>
        
        <!-- Guava -->
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>
        
        <!-- WebDriver Manager -->
        <dependency>
            <groupId>io.github.bonigarcia</groupId>
            <artifactId>webdrivermanager</artifactId>
            <version>5.5.3</version>
        </dependency>
        
        <!-- JSON Schema Validator -->
        <dependency>
            <groupId>com.github.java-json-tools</groupId>
            <artifactId>json-schema-validator</artifactId>
            <version>2.2.14</version>
        </dependency>
        
        <!-- Compression -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-compress</artifactId>
            <version>1.24.0</version>
        </dependency>
        
        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
                <configuration>
                    <mainClass>com.cstestforge.CSTestForgeApplication</mainClass>
                    <layout>JAR</layout>
                </configuration>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>integration-test</goal>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>


frontend/pom.xml
--------------------------------

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>com.cstestforge</groupId>
        <artifactId>cstestforge</artifactId>
        <version>1.0.0</version>
    </parent>

    <artifactId>cstestforge-frontend</artifactId>
    <n>CSTestForge Frontend</n>
    <description>Frontend application for CSTestForge framework</description>
    <packaging>jar</packaging>

    <properties>
        <frontend.directory>${project.basedir}</frontend.directory>
        <node.directory>${frontend.directory}/node</node.directory>
        <node.modules.directory>${frontend.directory}/node_modules</node.modules.directory>
        <npm.directory>${frontend.directory}/node/npm</npm.directory>
        <frontend.build.directory>${frontend.directory}/build</frontend.build.directory>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-clean-plugin</artifactId>
                <configuration>
                    <filesets>
                        <fileset>
                            <directory>${node.modules.directory}</directory>
                            <followSymlinks>false</followSymlinks>
                        </fileset>
                        <fileset>
                            <directory>${frontend.build.directory}</directory>
                            <followSymlinks>false</followSymlinks>
                        </fileset>
                    </filesets>
                </configuration>
            </plugin>
            
            <plugin>
                <groupId>com.github.eirslett</groupId>
                <artifactId>frontend-maven-plugin</artifactId>
                <configuration>
                    <workingDirectory>${frontend.directory}</workingDirectory>
                    <installDirectory>${node.directory}</installDirectory>
                </configuration>
                <executions>
                    <!-- Install Node and NPM -->
                    <execution>
                        <id>install-node-and-npm</id>
                        <goals>
                            <goal>install-node-and-npm</goal>
                        </goals>
                        <phase>generate-resources</phase>
                        <configuration>
                            <nodeVersion>${node.version}</nodeVersion>
                            <npmVersion>${npm.version}</npmVersion>
                        </configuration>
                    </execution>
                    
                    <!-- Install NPM dependencies -->
                    <execution>
                        <id>npm-install</id>
                        <goals>
                            <goal>npm</goal>
                        </goals>
                        <phase>generate-resources</phase>
                        <configuration>
                            <arguments>install</arguments>
                        </configuration>
                    </execution>
                    
                    <!-- Lint -->
                    <execution>
                        <id>npm-lint</id>
                        <goals>
                            <goal>npm</goal>
                        </goals>
                        <phase>test</phase>
                        <configuration>
                            <arguments>run lint</arguments>
                        </configuration>
                    </execution>
                    
                    <!-- Test -->
                    <execution>
                        <id>npm-test</id>
                        <goals>
                            <goal>npm</goal>
                        </goals>
                        <phase>test</phase>
                        <configuration>
                            <arguments>test</arguments>
                        </configuration>
                    </execution>
                    
                    <!-- Build -->
                    <execution>
                        <id>npm-build</id>
                        <goals>
                            <goal>npm</goal>
                        </goals>
                        <phase>compile</phase>
                        <configuration>
                            <arguments>run build</arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <executions>
                    <execution>
                        <id>copy-frontend-build</id>
                        <phase>prepare-package</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>${project.build.directory}/classes/static</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>${frontend.build.directory}</directory>
                                    <filtering>false</filtering>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <configuration>
                    <classifier>static</classifier>
                </configuration>
            </plugin>
        </plugins>
    </build>
    
    <profiles>
        <profile>
            <id>skip-frontend</id>
            <properties>
                <frontend.skip>true</frontend.skip>
            </properties>
            <build>
                <plugins>
                    <plugin>
                        <groupId>com.github.eirslett</groupId>
                        <artifactId>frontend-maven-plugin</artifactId>
                        <configuration>
                            <skip>${frontend.skip}</skip>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
        
        <profile>
            <id>development</id>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
            <build>
                <plugins>
                    <plugin>
                        <groupId>com.github.eirslett</groupId>
                        <artifactId>frontend-maven-plugin</artifactId>
                        <executions>
                            <execution>
                                <id>npm-start</id>
                                <goals>
                                    <goal>npm</goal>
                                </goals>
                                <phase>none</phase>
                                <configuration>
                                    <arguments>start</arguments>
                                </configuration>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>


frontend/package.json
---------------------------------

{
  "name": "cstestforge-frontend",
  "version": "1.0.0",
  "private": true,
  "description": "Frontend application for CSTestForge framework",
  "author": "CSTestForge Team",
  "license": "UNLICENSED",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --watchAll=false --coverage",
    "test:watch": "react-scripts test",
    "eject": "react-scripts eject",
    "lint": "eslint --ext .js,.jsx,.ts,.tsx src",
    "lint:fix": "eslint --ext .js,.jsx,.ts,.tsx src --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,js,jsx,json,css,scss}\"",
    "type-check": "tsc --noEmit",
    "analyze": "source-map-explorer 'build/static/js/*.js'",
    "storybook": "storybook dev -p 6006",
    "build-storybook": "storybook build"
  },
  "dependencies": {
    "@testing-library/jest-dom": "^6.1.4",
    "@testing-library/react": "^14.1.0",
    "@testing-library/user-event": "^14.5.1",
    "@types/jest": "^29.5.7",
    "@types/node": "^20.8.10",
    "@types/react": "^18.2.35",
    "@types/react-dom": "^18.2.14",
    "axios": "^1.6.0",
    "chart.js": "^4.4.0",
    "d3": "^7.8.5",
    "date-fns": "^2.30.0",
    "lodash": "^4.17.21",
    "papaparse": "^5.4.1",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.18.0",
    "react-scripts": "5.0.1",
    "react-syntax-highlighter": "^15.5.0",
    "recharts": "^2.9.2",
    "sass": "^1.69.5",
    "three": "^0.158.0",
    "typescript": "^5.2.2",
    "xlsx": "^0.18.5"
  },
  "devDependencies": {
    "@storybook/addon-essentials": "^7.5.3",
    "@storybook/addon-interactions": "^7.5.3",
    "@storybook/addon-links": "^7.5.3",
    "@storybook/addon-onboarding": "^1.0.8",
    "@storybook/blocks": "^7.5.3",
    "@storybook/preset-create-react-app": "^7.5.3",
    "@storybook/react": "^7.5.3",
    "@storybook/react-webpack5": "^7.5.3",
    "@storybook/testing-library": "^0.2.2",
    "@types/d3": "^7.4.3",
    "@types/lodash": "^4.14.200",
    "@types/papaparse": "^5.3.10",
    "@types/react-syntax-highlighter": "^15.5.9",
    "@typescript-eslint/eslint-plugin": "^6.9.1",
    "@typescript-eslint/parser": "^6.9.1",
    "babel-plugin-named-exports-order": "^0.0.2",
    "eslint": "^8.53.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-config-react-app": "^7.0.1",
    "eslint-plugin-import": "^2.29.0",
    "eslint-plugin-jest": "^27.6.0",
    "eslint-plugin-jsx-a11y": "^6.8.0",
    "eslint-plugin-prettier": "^5.0.1",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-storybook": "^0.6.15",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "prettier": "^3.0.3",
    "prop-types": "^15.8.1",
    "source-map-explorer": "^2.5.3",
    "storybook": "^7.5.3",
    "webpack": "^5.89.0"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "jest": {
    "collectCoverageFrom": [
      "src/**/*.{js,jsx,ts,tsx}",
      "!src/**/*.d.ts",
      "!src/index.tsx",
      "!src/serviceWorker.ts",
      "!src/reportWebVitals.ts",
      "!src/react-app-env.d.ts",
      "!src/**/*.stories.{js,jsx,ts,tsx}"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 75,
        "functions": 75,
        "lines": 75,
        "statements": 75
      }
    }
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest",
      "plugin:storybook/recommended"
    ]
  }
}


frontend/tsconfig.json
------------------------------------

{
  "compilerOptions": {
    "target": "es2020",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"],
      "@components/*": ["components/*"],
      "@core/*": ["core/*"],
      "@services/*": ["services/*"],
      "@hooks/*": ["hooks/*"],
      "@contexts/*": ["contexts/*"],
      "@utils/*": ["utils/*"],
      "@types/*": ["types/*"],
      "@styles/*": ["styles/*"],
      "@selenium/*": ["selenium/*"],
      "@playwright/*": ["playwright/*"]
    }
  },
  "include": [
    "src",
    ".eslintrc.js",
    "**/*.ts",
    "**/*.tsx",
    "jest.config.js"
  ],
  "exclude": [
    "node_modules",
    "build",
    "coverage",
    "dist",
    "lib"
  ]
}


frontend/webpack.config.js
----------------------------------------------
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');
const ESLintPlugin = require('eslint-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const webpack = require('webpack');
const dotenv = require('dotenv');

// Load environment variables from .env file
const env = dotenv.config().parsed || {};
const envKeys = Object.keys(env).reduce((prev, next) => {
  prev[`process.env.${next}`] = JSON.stringify(env[next]);
  return prev;
}, {});

module.exports = (env, argv) => {
  const isProduction = argv.mode === 'production';
  const isDevelopment = !isProduction;

  return {
    entry: path.resolve(__dirname, 'src/index.tsx'),
    output: {
      path: path.resolve(__dirname, 'build'),
      filename: isProduction
        ? 'static/js/[name].[contenthash:8].js'
        : 'static/js/[name].js',
      chunkFilename: isProduction
        ? 'static/js/[name].[contenthash:8].chunk.js'
        : 'static/js/[name].chunk.js',
      publicPath: '/',
      assetModuleFilename: 'static/media/[name].[hash][ext]',
    },
    devtool: isProduction ? 'source-map' : 'cheap-module-source-map',
    devServer: {
      static: path.resolve(__dirname, 'public'),
      port: 3000,
      hot: true,
      historyApiFallback: true,
      compress: true,
      client: {
        overlay: {
          errors: true,
          warnings: false,
        },
      },
    },
    resolve: {
      extensions: ['.tsx', '.ts', '.jsx', '.js'],
      alias: {
        '@': path.resolve(__dirname, 'src'),
        '@components': path.resolve(__dirname, 'src/components'),
        '@core': path.resolve(__dirname, 'src/core'),
        '@services': path.resolve(__dirname, 'src/services'),
        '@hooks': path.resolve(__dirname, 'src/hooks'),
        '@contexts': path.resolve(__dirname, 'src/contexts'),
        '@utils': path.resolve(__dirname, 'src/utils'),
        '@types': path.resolve(__dirname, 'src/types'),
        '@styles': path.resolve(__dirname, 'src/styles'),
        '@selenium': path.resolve(__dirname, 'src/selenium'),
        '@playwright': path.resolve(__dirname, 'src/playwright'),
      },
    },
    module: {
      rules: [
        // TypeScript and JavaScript
        {
          test: /\.(ts|tsx|js|jsx)$/,
          exclude: /node_modules/,
          use: {
            loader: 'babel-loader',
            options: {
              presets: [
                '@babel/preset-env',
                '@babel/preset-react',
                '@babel/preset-typescript',
              ],
              plugins: [
                [
                  '@babel/plugin-transform-runtime',
                  {
                    regenerator: true,
                  },
                ],
                isDevelopment && require.resolve('react-refresh/babel'),
              ].filter(Boolean),
            },
          },
        },
        // CSS, SCSS
        {
          test: /\.(css|scss|sass)$/,
          use: [
            isDevelopment ? 'style-loader' : MiniCssExtractPlugin.loader,
            {
              loader: 'css-loader',
              options: {
                importLoaders: 2,
                sourceMap: true,
                modules: {
                  auto: true,
                  localIdentName: isDevelopment
                    ? '[name]__[local]--[hash:base64:5]'
                    : '[hash:base64]',
                },
              },
            },
            {
              loader: 'postcss-loader',
              options: {
                sourceMap: true,
                postcssOptions: {
                  plugins: [
                    'postcss-flexbugs-fixes',
                    [
                      'postcss-preset-env',
                      {
                        autoprefixer: {
                          flexbox: 'no-2009',
                        },
                        stage: 3,
                      },
                    ],
                    'postcss-normalize',
                  ],
                },
              },
            },
            {
              loader: 'sass-loader',
              options: {
                sourceMap: true,
              },
            },
          ],
        },
        // Images
        {
          test: /\.(png|jpe?g|gif|webp|avif)$/i,
          type: 'asset',
          parser: {
            dataUrlCondition: {
              maxSize: 10 * 1024, // 10kb
            },
          },
        },
        // SVG
        {
          test: /\.svg$/,
          use: [
            {
              loader: '@svgr/webpack',
              options: {
                prettier: false,
                svgo: false,
                svgoConfig: {
                  plugins: [{ removeViewBox: false }],
                },
                titleProp: true,
                ref: true,
              },
            },
            {
              loader: 'file-loader',
              options: {
                name: 'static/media/[name].[hash].[ext]',
              },
            },
          ],
          issuer: {
            and: [/\.(ts|tsx|js|jsx|md|mdx)$/],
          },
        },
        // Fonts
        {
          test: /\.(woff|woff2|eot|ttf|otf)$/i,
          type: 'asset/resource',
        },
      ],
    },
    plugins: [
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        template: path.resolve(__dirname, 'public/index.html'),
        favicon: path.resolve(__dirname, 'public/favicon.ico'),
        inject: true,
        minify: isProduction
          ? {
              removeComments: true,
              collapseWhitespace: true,
              removeRedundantAttributes: true,
              useShortDoctype: true,
              removeEmptyAttributes: true,
              removeStyleLinkTypeAttributes: true,
              keepClosingSlash: true,
              minifyJS: true,
              minifyCSS: true,
              minifyURLs: true,
            }
          : false,
      }),
      isProduction &&
        new MiniCssExtractPlugin({
          filename: 'static/css/[name].[contenthash:8].css',
          chunkFilename: 'static/css/[name].[contenthash:8].chunk.css',
        }),
      isDevelopment && new webpack.HotModuleReplacementPlugin(),
      new ForkTsCheckerWebpackPlugin({
        async: isDevelopment,
        typescript: {
          configFile: path.resolve(__dirname, 'tsconfig.json'),
        },
      }),
      new ESLintPlugin({
        extensions: ['js', 'jsx', 'ts', 'tsx'],
        formatter: require.resolve('react-dev-utils/eslintFormatter'),
        eslintPath: require.resolve('eslint'),
        failOnError: isProduction,
        context: path.resolve(__dirname, 'src'),
        cache: true,
        cacheLocation: path.resolve(
          __dirname,
          'node_modules/.cache/.eslintcache'
        ),
        cwd: __dirname,
        resolvePluginsRelativeTo: __dirname,
      }),
      new webpack.DefinePlugin({
        'process.env.NODE_ENV': JSON.stringify(
          isProduction ? 'production' : 'development'
        ),
        ...envKeys,
      }),
      new CopyWebpackPlugin({
        patterns: [
          {
            from: 'public',
            to: '',
            globOptions: {
              ignore: ['**/index.html', '**/favicon.ico'],
            },
          },
        ],
      }),
      process.env.ANALYZE === 'true' &&
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          reportFilename: 'bundle-report.html',
          openAnalyzer: false,
        }),
    ].filter(Boolean),
    optimization: {
      minimize: isProduction,
      minimizer: [
        new TerserPlugin({
          terserOptions: {
            parse: {
              ecma: 8,
            },
            compress: {
              ecma: 5,
              warnings: false,
              comparisons: false,
              inline: 2,
            },
            mangle: {
              safari10: true,
            },
            output: {
              ecma: 5,
              comments: false,
              ascii_only: true,
            },
          },
          extractComments: false,
        }),
        new CssMinimizerPlugin(),
      ],
      splitChunks: {
        chunks: 'all',
        name: false,
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
          },
          common: {
            name: 'common',
            minChunks: 2,
            chunks: 'async',
            priority: 10,
            reuseExistingChunk: true,
            enforce: true,
          },
        },
      },
      runtimeChunk: {
        name: (entrypoint) => `runtime-${entrypoint.name}`,
      },
    },
    performance: {
      hints: isProduction ? 'warning' : false,
      maxEntrypointSize: 512000,
      maxAssetSize: 512000,
    },
  };
};


backend/src/main/resources/application.properties
-----------------------------------------------------


# CSTestForge Application Configuration
# Main application settings
spring.application.name=cstestforge
server.port=8080
server.servlet.context-path=/api
server.compression.enabled=true
server.compression.mime-types=application/json,application/xml,text/html,text/plain,text/css,application/javascript
server.compression.min-response-size=2048

# Logging configuration
logging.level.root=INFO
logging.level.com.cstestforge=DEBUG
logging.level.org.springframework.web=INFO
logging.level.org.hibernate=ERROR
logging.file.name=logs/cstestforge.log
logging.logback.rollingpolicy.max-file-size=10MB
logging.logback.rollingpolicy.max-history=30
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# Jackson settings
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.deserialization.fail-on-unknown-properties=false
spring.jackson.default-property-inclusion=non_null
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=UTC

# Actuator settings
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.show-details=when_authorized
management.health.diskspace.enabled=true
management.health.diskspace.threshold=1GB
management.info.git.mode=full

# WebSocket
spring.websocket.max-text-message-size=8192
spring.websocket.max-binary-message-size=16384

# Spring AOP
spring.aop.auto=true
spring.aop.proxy-target-class=true

# Spring Cache
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s

# Multipart file settings
spring.servlet.multipart.enabled=true
spring.servlet.multipart.file-size-threshold=2KB
spring.servlet.multipart.max-file-size=200MB
spring.servlet.multipart.max-request-size=215MB
spring.servlet.multipart.location=${java.io.tmpdir}

# Security settings (basic settings, to be expanded)
cstestforge.security.csrf-enabled=true
cstestforge.security.content-security-policy=default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; connect-src 'self'
cstestforge.security.allowed-origins=http://localhost:3000,http://localhost:8080

# File storage paths
cstestforge.storage.base-path=${user.home}/cstestforge
cstestforge.storage.projects-path=${cstestforge.storage.base-path}/projects
cstestforge.storage.results-path=${cstestforge.storage.base-path}/results
cstestforge.storage.config-path=${cstestforge.storage.base-path}/config
cstestforge.storage.temp-path=${java.io.tmpdir}/cstestforge

# Automation settings
cstestforge.selenium.driver-timeout=30
cstestforge.selenium.element-timeout=15
cstestforge.selenium.poll-interval=500
cstestforge.playwright.timeout=30000

# Default Test settings
cstestforge.test.default-browser=chrome
cstestforge.test.default-framework=selenium
cstestforge.test.default-language=java
cstestforge.test.default-test-type=testng
cstestforge.test.default-max-threads=4
cstestforge.test.screenshot-on-failure=true
cstestforge.test.screenshot-on-success=false
cstestforge.test.video-recording=false
cstestforge.test.retry-failed-tests=false
cstestforge.test.max-retry-count=3
cstestforge.test.use-self-healing=true

# AI Capabilities
cstestforge.ai.enabled=true
cstestforge.ai.model-path=${cstestforge.storage.base-path}/ai/models

# Include profile-specific properties
spring.profiles.active=@spring.profiles.active@


backend/src/main/resources/application-dev.properties
---------------------------------------------------------------

# Development Environment Specific Configuration

# Logging (more verbose for development)
logging.level.root=INFO
logging.level.com.cstestforge=DEBUG
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.websocket=DEBUG
logging.level.org.springframework.http=DEBUG
logging.console.enabled=true

# Enable Hot Swapping 
spring.devtools.restart.enabled=true
spring.devtools.livereload.enabled=true

# Show detailed error messages in responses
server.error.include-message=always
server.error.include-binding-errors=always
server.error.include-stacktrace=always
server.error.include-exception=true

# Actuator development settings
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

# CORS settings for development
cstestforge.security.csrf-enabled=false
cstestforge.security.allowed-origins=http://localhost:3000,http://localhost:4200

# Disable caching for development
spring.resources.cache.period=0
spring.cache.type=none

# Debug options
cstestforge.debug.browser.headless=false
cstestforge.debug.enable-network-logging=true
cstestforge.debug.enable-performance-logging=true
cstestforge.debug.enable-console-logging=true
cstestforge.debug.enable-command-logging=true

# Development test settings
cstestforge.test.default-browser=chrome
cstestforge.test.default-framework=selenium
cstestforge.test.default-language=java
cstestforge.test.default-test-type=testng
cstestforge.test.default-max-threads=1
cstestforge.test.screenshot-on-failure=true
cstestforge.test.screenshot-on-success=true
cstestforge.test.video-recording=true
cstestforge.test.detailed-logging=true

# Development storage paths
cstestforge.storage.base-path=${user.home}/cstestforge-dev
cstestforge.storage.projects-path=${cstestforge.storage.base-path}/projects
cstestforge.storage.results-path=${cstestforge.storage.base-path}/results
cstestforge.storage.config-path=${cstestforge.storage.base-path}/config
cstestforge.storage.temp-path=${java.io.tmpdir}/cstestforge-dev

# Development WebSocket settings
cstestforge.websocket.allowed-origins=http://localhost:3000,http://localhost:4200
cstestforge.websocket.endpoint=/ws
cstestforge.websocket.allowed-destination-prefixes=/topic,/queue,/app
cstestforge.websocket.heartbeat-interval=25000
cstestforge.websocket.heartbeat-time-to-live=30000

# Service monitoring in development
cstestforge.monitoring.health-check-interval=30000
cstestforge.monitoring.enable-detailed-metrics=true
cstestforge.monitoring.log-resource-usage=true
cstestforge.monitoring.storage-threshold-warning=90
cstestforge.monitoring.storage-threshold-critical=95

# AI capabilities for development
cstestforge.ai.debug-mode=true
cstestforge.ai.enable-logging=true
cstestforge.ai.model-path=${cstestforge.storage.base-path}/ai/models

# Record and playback development settings
cstestforge.recorder.enable-detailed-event-logging=true
cstestforge.recorder.capture-dom-mutations=true
cstestforge.recorder.smart-wait-detection=true
cstestforge.recorder.optimization-level=0


backend/src/main/resources/application-prod.properties
------------------------------------------------------------------

# Production Environment Specific Configuration

# Logging (minimal in production)
logging.level.root=WARN
logging.level.com.cstestforge=INFO
logging.level.org.springframework=WARN
logging.console.enabled=false
logging.file.max-size=50MB
logging.file.max-history=30

# Disable development tools in production
spring.devtools.restart.enabled=false
spring.devtools.livereload.enabled=false

# Error handling in production (don't expose details)
server.error.include-message=never
server.error.include-binding-errors=never
server.error.include-stacktrace=never
server.error.include-exception=false

# Actuator settings for production (limited exposure)
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.show-details=never
management.endpoints.web.base-path=/actuator
management.endpoints.web.exposure.exclude=env,beans,heapdump,threaddump,scheduledtasks

# Security settings
cstestforge.security.csrf-enabled=true
cstestforge.security.allowed-origins=https://cstestforge.example.com
cstestforge.security.content-security-policy=default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data:; font-src 'self' data:; connect-src 'self'
cstestforge.security.enable-strict-transport-security=true
cstestforge.security.enable-xss-protection=true
cstestforge.security.enable-content-type-options=true
cstestforge.security.enable-frame-options=true
cstestforge.security.referrer-policy=strict-origin-when-cross-origin

# Caching settings
spring.resources.cache.period=604800
spring.resources.chain.compressed=true
spring.resources.chain.cache=true
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=1000,expireAfterWrite=3600s

# Production test settings
cstestforge.test.default-browser=chrome
cstestforge.test.default-framework=selenium
cstestforge.test.default-language=java
cstestforge.test.default-test-type=testng
cstestforge.test.default-max-threads=8
cstestforge.test.screenshot-on-failure=true
cstestforge.test.screenshot-on-success=false
cstestforge.test.video-recording=false
cstestforge.test.detailed-logging=false
cstestforge.test.browser.headless=true

# Production storage paths
cstestforge.storage.base-path=/opt/cstestforge
cstestforge.storage.projects-path=${cstestforge.storage.base-path}/projects
cstestforge.storage.results-path=${cstestforge.storage.base-path}/results
cstestforge.storage.config-path=${cstestforge.storage.base-path}/config
cstestforge.storage.temp-path=/tmp/cstestforge

# Production WebSocket settings
cstestforge.websocket.allowed-origins=https://cstestforge.example.com
cstestforge.websocket.endpoint=/ws
cstestforge.websocket.allowed-destination-prefixes=/topic,/queue,/app
cstestforge.websocket.heartbeat-interval=25000
cstestforge.websocket.heartbeat-time-to-live=30000

# Service monitoring in production
cstestforge.monitoring.health-check-interval=60000
cstestforge.monitoring.enable-detailed-metrics=true
cstestforge.monitoring.log-resource-usage=true
cstestforge.monitoring.storage-threshold-warning=85
cstestforge.monitoring.storage-threshold-critical=95
cstestforge.monitoring.alert-email=alerts@example.com

# AI capabilities for production
cstestforge.ai.debug-mode=false
cstestforge.ai.enable-logging=false
cstestforge.ai.model-path=${cstestforge.storage.base-path}/ai/models

# Automatic cleanup settings
cstestforge.cleanup.enable=true
cstestforge.cleanup.cron-expression=0 0 2 * * ?
cstestforge.cleanup.retention-days-test-results=90
cstestforge.cleanup.retention-days-logs=30
cstestforge.cleanup.retention-days-temp-files=7
cstestforge.cleanup.retention-days-screenshots=30
cstestforge.cleanup.retention-days-reports=90
cstestforge.cleanup.max-temp-storage-mb=5000

# Performance settings
cstestforge.performance.max-concurrent-test-executions=20
cstestforge.performance.connection-timeout=10000
cstestforge.performance.request-timeout=30000
cstestforge.performance.socket-timeout=30000
cstestforge.performance.max-connections-per-route=20
cstestforge.performance.max-connections-total=200


backend/src/main/resources/application-qa.properties
----------------------------------------------------------------


# QA Environment Specific Configuration

# Logging (balance between dev and prod)
logging.level.root=INFO
logging.level.com.cstestforge=INFO
logging.level.org.springframework=INFO
logging.console.enabled=true
logging.file.max-size=20MB
logging.file.max-history=20

# Disable development tools in QA
spring.devtools.restart.enabled=false
spring.devtools.livereload.enabled=false

# Error handling in QA (limited details)
server.error.include-message=always
server.error.include-binding-errors=always
server.error.include-stacktrace=never
server.error.include-exception=false

# Actuator settings for QA
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.show-details=when_authorized
management.endpoints.web.base-path=/actuator

# Security settings
cstestforge.security.csrf-enabled=true
cstestforge.security.allowed-origins=https://qa.cstestforge.example.com
cstestforge.security.content-security-policy=default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data:; font-src 'self' data:; connect-src 'self'
cstestforge.security.enable-strict-transport-security=true
cstestforge.security.enable-xss-protection=true
cstestforge.security.enable-content-type-options=true
cstestforge.security.enable-frame-options=true

# Caching settings
spring.resources.cache.period=86400
spring.resources.chain.compressed=true
spring.resources.chain.cache=true
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=500,expireAfterWrite=1800s

# QA test settings
cstestforge.test.default-browser=chrome
cstestforge.test.default-framework=selenium
cstestforge.test.default-language=java
cstestforge.test.default-test-type=testng
cstestforge.test.default-max-threads=4
cstestforge.test.screenshot-on-failure=true
cstestforge.test.screenshot-on-success=true
cstestforge.test.video-recording=true
cstestforge.test.detailed-logging=true
cstestforge.test.browser.headless=true

# QA storage paths
cstestforge.storage.base-path=/opt/cstestforge-qa
cstestforge.storage.projects-path=${cstestforge.storage.base-path}/projects
cstestforge.storage.results-path=${cstestforge.storage.base-path}/results
cstestforge.storage.config-path=${cstestforge.storage.base-path}/config
cstestforge.storage.temp-path=/tmp/cstestforge-qa

# QA WebSocket settings
cstestforge.websocket.allowed-origins=https://qa.cstestforge.example.com
cstestforge.websocket.endpoint=/ws
cstestforge.websocket.allowed-destination-prefixes=/topic,/queue,/app
cstestforge.websocket.heartbeat-interval=25000
cstestforge.websocket.heartbeat-time-to-live=30000

# Service monitoring in QA
cstestforge.monitoring.health-check-interval=60000
cstestforge.monitoring.enable-detailed-metrics=true
cstestforge.monitoring.log-resource-usage=true
cstestforge.monitoring.storage-threshold-warning=80
cstestforge.monitoring.storage-threshold-critical=90
cstestforge.monitoring.alert-email=qa-alerts@example.com

# AI capabilities for QA
cstestforge.ai.debug-mode=true
cstestforge.ai.enable-logging=true
cstestforge.ai.model-path=${cstestforge.storage.base-path}/ai/models

# Test data management for QA
cstestforge.test-data.reset-database=true
cstestforge.test-data.seed-script-path=${cstestforge.storage.base-path}/scripts/seed-data.sql
cstestforge.test-data.default-users-enabled=true
cstestforge.test-data.default-projects-enabled=true

# Performance testing specific configurations
cstestforge.performance.test-enabled=true
cstestforge.performance.metrics-collection-interval=1000
cstestforge.performance.jmeter-path=${cstestforge.storage.base-path}/tools/jmeter
cstestforge.performance.gatling-path=${cstestforge.storage.base-path}/tools/gatling
cstestforge.performance.load-test-users=100
cstestforge.performance.load-test-ramp-up-seconds=30
cstestforge.performance.load-test-duration-seconds=300

# Automatic cleanup settings (more aggressive in QA)
cstestforge.cleanup.enable=true
cstestforge.cleanup.cron-expression=0 0 2 * * ?
cstestforge.cleanup.retention-days-test-results=30
cstestforge.cleanup.retention-days-logs=15
cstestforge.cleanup.retention-days-temp-files=3
cstestforge.cleanup.retention-days-screenshots=15
cstestforge.cleanup.retention-days-reports=30
cstestforge.cleanup.max-temp-storage-mb=2000


backend/src/test/resources/application-test.properties
---------------------------------------------------------------------

# Test Environment Specific Configuration

# Logging (minimal to avoid test noise)
logging.level.root=WARN
logging.level.com.cstestforge=INFO
logging.level.org.springframework=WARN
logging.console.enabled=true
logging.file.name=

# Disable development tools in tests
spring.devtools.restart.enabled=false
spring.devtools.livereload.enabled=false

# Random port for tests to avoid conflicts
server.port=0

# Actuator settings for tests
management.endpoints.web.exposure.include=health,info
management.endpoint.health.show-details=always

# Test security settings
cstestforge.security.csrf-enabled=false
cstestforge.security.allowed-origins=*

# Disable caching for tests
spring.cache.type=none

# Test data directory paths (in-memory or temporary locations)
cstestforge.storage.base-path=${java.io.tmpdir}/cstestforge-test
cstestforge.storage.projects-path=${cstestforge.storage.base-path}/projects
cstestforge.storage.results-path=${cstestforge.storage.base-path}/results
cstestforge.storage.config-path=${cstestforge.storage.base-path}/config
cstestforge.storage.temp-path=${cstestforge.storage.base-path}/temp

# Test automation settings (fast and headless)
cstestforge.test.default-browser=chrome
cstestforge.test.default-framework=selenium
cstestforge.test.default-language=java
cstestforge.test.default-test-type=testng
cstestforge.test.default-max-threads=1
cstestforge.test.screenshot-on-failure=true
cstestforge.test.screenshot-on-success=false
cstestforge.test.video-recording=false
cstestforge.test.browser.headless=true
cstestforge.test.default-timeout=5

# Mock service settings
cstestforge.test.mock-external-services=true
cstestforge.test.mock-browser-sessions=true
cstestforge.test.mock-ai-services=true

# Testing WebSockets
cstestforge.websocket.allowed-origins=*
cstestforge.websocket.endpoint=/ws
cstestforge.websocket.allowed-destination-prefixes=/topic,/queue,/app
cstestforge.websocket.heartbeat-interval=5000
cstestforge.websocket.heartbeat-time-to-live=5000

# AI service mocks for tests
cstestforge.ai.debug-mode=true
cstestforge.ai.enable-logging=true
cstestforge.ai.model-path=${cstestforge.storage.base-path}/ai/models
cstestforge.ai.use-mock-predictions=true

# Test execution settings
cstestforge.test.clean-workspace-before-tests=true
cstestforge.test.clean-workspace-after-tests=true
cstestforge.test.generate-test-reports=true
cstestforge.test.report-location=${cstestforge.storage.base-path}/test-reports
cstestforge.test.parallel-execution=false

# Performance settings for tests
cstestforge.performance.connection-timeout=5000
cstestforge.performance.request-timeout=5000
cstestforge.performance.socket-timeout=5000
cstestforge.performance.max-connections-per-route=5
cstestforge.performance.max-connections-total=20

# Clear all data after tests
cstestforge.test.auto-cleanup=true



backend/src/main/resources/logback.xml
--------------------------------------------------------

<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- Properties -->
    <property name="LOG_PATH" value="${LOG_PATH:-logs}" />
    <property name="LOG_ARCHIVE" value="${LOG_PATH}/archive" />
    <property name="LOG_FILE" value="${LOG_PATH}/cstestforge.log" />
    <property name="CONSOLE_LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} %highlight(%-5level) [%thread] %cyan(%logger{36}) - %msg%n" />
    <property name="FILE_LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{36} - %msg%n" />
    <property name="JSON_LOG_PATTERN" value="{\"timestamp\":\"%d{yyyy-MM-dd'T'HH:mm:ss.SSS'Z'}\",\"level\":\"%p\",\"thread\":\"%t\",\"logger\":\"%logger{36}\",\"message\":%message}%n" />

    <!-- Console Appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- File Appender -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}</file>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_ARCHIVE}/cstestforge-%d{yyyy-MM-dd}-%i.log.gz</fileNamePattern>
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
    </appender>

    <!-- JSON File Appender for machine processing -->
    <appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/cstestforge-json.log</file>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <includeMdcKeyName>sessionId</includeMdcKeyName>
            <includeMdcKeyName>userId</includeMdcKeyName>
            <includeMdcKeyName>requestId</includeMdcKeyName>
            <includeMdcKeyName>testId</includeMdcKeyName>
            <includeMdcKeyName>projectId</includeMdcKeyName>
            <includeMdcKeyName>browser</includeMdcKeyName>
            <includeMdcKeyName>framework</includeMdcKeyName>
            <includeMdcKeyName>language</includeMdcKeyName>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_ARCHIVE}/cstestforge-json-%d{yyyy-MM-dd}-%i.log.gz</fileNamePattern>
            <maxFileSize>20MB</maxFileSize>
            <maxHistory>15</maxHistory>
            <totalSizeCap>500MB</totalSizeCap>
        </rollingPolicy>
    </appender>

    <!-- Async Appenders for better performance -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE" />
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
        <includeCallerData>true</includeCallerData>
    </appender>

    <appender name="ASYNC_JSON_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="JSON_FILE" />
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
        <includeCallerData>false</includeCallerData>
    </appender>

    <!-- Error Log specific appender -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/error.log</file>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_ARCHIVE}/error-%d{yyyy-MM-dd}-%i.log.gz</fileNamePattern>
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>30</maxHistory>
            <totalSizeCap>500MB</totalSizeCap>
        </rollingPolicy>
    </appender>

    <!-- Performance Log specific appender -->
    <appender name="PERFORMANCE_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/performance.log</file>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_ARCHIVE}/performance-%d{yyyy-MM-dd}-%i.log.gz</fileNamePattern>
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>15</maxHistory>
            <totalSizeCap>200MB</totalSizeCap>
        </rollingPolicy>
    </appender>

    <!-- Specific Loggers -->
    <logger name="com.cstestforge" level="INFO" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
        <appender-ref ref="ASYNC_JSON_FILE" />
        <appender-ref ref="ERROR_FILE" />
    </logger>

    <logger name="com.cstestforge.performance" level="INFO" additivity="false">
        <appender-ref ref="PERFORMANCE_FILE" />
        <appender-ref ref="CONSOLE" />
    </logger>

    <logger name="org.springframework" level="INFO" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
        <appender-ref ref="ERROR_FILE" />
    </logger>

    <logger name="org.springframework.web" level="INFO" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
    </logger>

    <logger name="org.springframework.websocket" level="INFO" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
    </logger>

    <logger name="org.seleniumhq.selenium" level="WARN" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
    </logger>

    <logger name="com.microsoft.playwright" level="WARN" additivity="false">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
    </logger>

    <!-- Root Logger -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
        <appender-ref ref="ERROR_FILE" />
    </root>

    <!-- Production Profile Configuration -->
    <springProfile name="prod">
        <root level="WARN">
            <appender-ref ref="ASYNC_FILE" />
            <appender-ref ref="ASYNC_JSON_FILE" />
            <appender-ref ref="ERROR_FILE" />
        </root>
        <logger name="com.cstestforge" level="INFO" additivity="false">
            <appender-ref ref="ASYNC_FILE" />
            <appender-ref ref="ASYNC_JSON_FILE" />
            <appender-ref ref="ERROR_FILE" />
        </logger>
    </springProfile>

    <!-- Development Profile Configuration -->
    <springProfile name="dev">
        <root level="INFO">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="ASYNC_FILE" />
            <appender-ref ref="ERROR_FILE" />
        </root>
        <logger name="com.cstestforge" level="DEBUG" additivity="false">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="ASYNC_FILE" />
            <appender-ref ref="ERROR_FILE" />
        </logger>
        <logger name="org.springframework.web" level="DEBUG" additivity="false">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="ASYNC_FILE" />
        </logger>
    </springProfile>

    <!-- Test Profile Configuration -->
    <springProfile name="test">
        <root level="WARN">
            <appender-ref ref="CONSOLE" />
        </root>
        <logger name="com.cstestforge" level="INFO" additivity="false">
            <appender-ref ref="CONSOLE" />
        </logger>
    </springProfile>
</configuration>


.gitignore
------------------------------
# Java related
*.class
*.jar
*.war
*.ear
*.logs
*.iml
.idea/
*.iws
*.ipr
.gradle/
build/
target/
out/
.mvn/wrapper/maven-wrapper.jar

# Maven related
mvnw
mvnw.cmd
.mvn/
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.flattened-pom.xml

# JUnit
junit*.properties

# Eclipse related
.classpath
.project
.settings/
bin/

# IntelliJ related
*.iws
.idea/
*.iml
*.ipr
/out/

# NetBeans related
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/

# VS Code related
.vscode/
.factorypath

# Node.js / npm / Yarn
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
/.pnp
.pnp.js
frontend/node/
frontend/build/
frontend/.env
frontend/.env.local
frontend/.env.development.local
frontend/.env.test.local
frontend/.env.production.local

# React / Create React App
.DS_Store
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
coverage/
storybook-static/

# Testing
coverage/
.nyc_output/

# Compiled CSS from SASS/SCSS
*.css.map

# Build output
/build/
/dist/
/target/
/out/

# OS specific files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Log files
*.log
logs/
log/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Sensitive or environment-specific information
secrets.properties
application-secrets.properties
application-secrets.yml
application-prod.properties
application-prod.yml
*.pem

# Build artifacts
*.hprof
*.settings
*.factorypath
*.launch
.externalToolBuilders/

# Temp files
.temp/
temp/
tmp/
*.tmp
.cache/

# Backup files
*.bak
*.swp
*~

# Virtual machine crash logs
hs_err_pid*

# Project specific
cstestforge-storage/
/screenshots/
/videos/
/reports/
/downloads/
/test-results/
/ai/models/

# WebDriver binaries
drivers/
webdriver/
*.exe
chromedriver*
geckodriver*
msedgedriver*
IEDriverServer*


README.md
-----------------------------------------

# CSTestForge

[![Build Status](https://img.shields.io/badge/build-passing-brightgreen.svg)](https://example.com/build-status)
[![License](https://img.shields.io/badge/license-Proprietary-blue.svg)](LICENSE)
[![Version](https://img.shields.io/badge/version-1.0.0-green.svg)](https://example.com/releases)

CSTestForge is an enterprise-grade test automation framework designed to support multiple testing tools (Selenium, Playwright), programming languages (Java, TypeScript), and testing approaches (TestNG, BDD). The framework provides a unified API with extensible components, custom reporting capabilities, AI-enhanced features, and comprehensive test management capabilities.

## Key Features

- **Multi-Framework Support**: Full support for both Selenium WebDriver and Playwright with seamless switching capability
- **Multi-Language Support**: Complete implementation in both Java and TypeScript with consistent APIs
- **Testing Approach Flexibility**: Support for traditional TestNG-based testing and BDD with Cucumber
- **Data-Driven Testing**: Support for Excel, CSV, JSON, and database data sources
- **AI-Enhanced Capabilities**: Smart locator generation, self-healing locators, element recognition
- **Robust Reporting**: Custom HTML reports with interactive dashboards, screenshots, and video recording
- **CI/CD Integration**: Seamless integration with Azure DevOps, Jenkins, GitHub Actions
- **Enhanced Page Object Model**: Advanced implementation with fluent APIs and auto page factory
- **Record & Playback**: Advanced browser recording with smart action recognition and code generation
- **Self-Healing Capabilities**: Automatic recovery from common test failures
- **Parallel Execution**: Multi-threaded and distributed test execution
- **Real-Time Execution & Monitoring**: Live view of test execution status and controls

## Architecture

The architecture follows a modular design with clear separation of concerns:

```
CSTestForge
 Core Module (Framework-agnostic components)
 Selenium Module (Java & TypeScript)
 Playwright Module (Java & TypeScript)
 Service Module (Recorder, Execution, Export)
 Frontend Module (UI Components)
```

## Getting Started

### Prerequisites

- Java 17 or newer
- Node.js 18 or newer
- Maven 3.8 or newer
- Chrome, Firefox, Edge, or Safari browser

### Installation

1. Clone the repository:
```bash
git clone https://example.com/cstestforge.git
cd cstestforge
```

2. Build the project:
```bash
mvn clean install
```

3. Start the application:
```bash
java -jar backend/target/cstestforge-backend-1.0.0.jar
```

4. Access the web interface:
```
http://localhost:8080
```

## Project Structure

The project follows a multi-module Maven structure:

- **backend**: Java Spring Boot application that provides the core functionality and API
- **frontend**: React TypeScript application that provides the user interface

## Development

### Backend Development

```bash
cd backend
mvn spring-boot:run -Dspring-boot.run.profiles=dev
```

### Frontend Development

```bash
cd frontend
npm install
npm start
```

### Running Tests

```bash
mvn test
```

### Building for Production

```bash
mvn clean package -P prod
```

## Documentation

- [User Guide](docs/user-guide/README.md)
- [Architecture Guide](docs/architecture/README.md)
- [API Documentation](docs/api/README.md)
- [Development Guide](docs/development-guide/README.md)

## Contributing

Please read [CONTRIBUTING.md](CONTRIBUTING.md) for details on our code of conduct and the process for submitting pull requests.

## License

This project is proprietary and confidential. Unauthorized copying, distribution, or use is strictly prohibited.

## Acknowledgments

- The CSTestForge Team for their dedication and hard work
- All contributors and testers who have helped improve the framework



CHANGELOG.md
-----------------------------

# Changelog

All notable changes to the CSTestForge project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.0.0] - 2025-05-05

### Added
- Initial release of CSTestForge with complete core functionality
- Full implementation of Selenium integration for Java and TypeScript
- Full implementation of Playwright integration for Java and TypeScript
- Enhanced Page Object Model with fluent APIs
- Data-driven testing support for Excel, CSV, JSON, and database sources
- AI-enhanced capabilities including smart locator generation and self-healing
- Custom reporting engine with interactive dashboards
- Record & Playback functionality with code generation
- Real-time test execution monitoring and control
- Parallel and distributed test execution support
- CI/CD integration for Azure DevOps, Jenkins, and GitHub Actions
- Test management capabilities
- Export functionality with project templates
- File system storage implementation without database dependencies
- WebSocket implementation for real-time communication
- Configuration management system

### Technical Details
- Built on Java 17 and Spring Boot 3
- Frontend implemented with React 18 and TypeScript 5
- WebDriver integration for Chrome, Firefox, Edge, and Safari
- Playwright integration for all major browsers
- Custom component library without third-party dependencies
- Custom AI implementation for element recognition and locator generation
- TestNG and Cucumber integration for different testing approaches
- Parallel execution engine with resource management
- WebSocket implementation for real-time updates

## [0.9.0] - 2025-04-15

### Added
- Beta release for internal testing
- Core modules implemented and tested
- Initial Selenium and Playwright integration
- Basic recording and playback functionality
- Preliminary reporting capabilities
- Initial UI implementation

### Fixed
- Performance issues in parallel test execution
- Memory leaks in long-running test sessions
- Browser compatibility issues in Firefox and Safari
- WebSocket connection stability

## [0.8.0] - 2025-03-01

### Added
- Alpha release for concept validation
- Framework architecture design and prototyping
- POC implementation of core features
- Initial AI capability testing

### Known Issues
- Limited browser support
- Performance bottlenecks in large test suites
- Incomplete reporting functionality
- UI stability issues


frontend/.eslintrc.json
----------------------------------------------

{
  "root": true,
  "env": {
    "browser": true,
    "es2021": true,
    "node": true,
    "jest": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/eslint-recommended",
    "plugin:jsx-a11y/recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:import/typescript",
    "plugin:jest/recommended",
    "plugin:prettier/recommended",
    "plugin:storybook/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaFeatures": {
      "jsx": true
    },
    "ecmaVersion": 2021,
    "sourceType": "module",
    "project": "./tsconfig.json"
  },
  "plugins": [
    "react",
    "react-hooks",
    "@typescript-eslint",
    "jsx-a11y",
    "import",
    "jest",
    "prettier"
  ],
  "settings": {
    "react": {
      "version": "detect"
    },
    "import/resolver": {
      "typescript": {
        "alwaysTryTypes": true,
        "project": "./tsconfig.json"
      },
      "node": {
        "extensions": [".js", ".jsx", ".ts", ".tsx"]
      }
    }
  },
  "rules": {
    // Base rules
    "no-console": ["warn", { "allow": ["warn", "error", "info"] }],
    "no-debugger": "warn",
    "no-alert": "warn",
    "no-unused-vars": "off",
    "no-use-before-define": "off",
    "no-useless-constructor": "off",
    
    // TypeScript rules
    "@typescript-eslint/no-unused-vars": ["error", { 
      "argsIgnorePattern": "^_",
      "varsIgnorePattern": "^_",
      "caughtErrorsIgnorePattern": "^_"
    }],
    "@typescript-eslint/no-use-before-define": ["error", { 
      "functions": false,
      "classes": true,
      "variables": true,
      "typedefs": true
    }],
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-non-null-assertion": "warn",
    "@typescript-eslint/no-empty-function": "warn",
    "@typescript-eslint/ban-ts-comment": "warn",
    "@typescript-eslint/ban-types": "warn",
    "@typescript-eslint/naming-convention": [
      "error",
      {
        "selector": "interface",
        "format": ["PascalCase"],
        "prefix": ["I"]
      },
      {
        "selector": "typeAlias",
        "format": ["PascalCase"]
      },
      {
        "selector": "enum",
        "format": ["PascalCase"]
      }
    ],
    
    // React rules
    "react/prop-types": "off",
    "react/react-in-jsx-scope": "off",
    "react/display-name": "off",
    "react/jsx-filename-extension": ["warn", { "extensions": [".tsx"] }],
    "react/jsx-props-no-spreading": "off",
    "react/no-unescaped-entities": "warn",
    "react/jsx-fragments": ["error", "syntax"],
    "react/jsx-key": "error",
    "react/jsx-sort-props": ["warn", {
      "callbacksLast": true,
      "shorthandFirst": true,
      "ignoreCase": true,
      "reservedFirst": true
    }],
    
    // React Hooks rules
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn",
    
    // Import rules
    "import/no-unresolved": "error",
    "import/named": "error",
    "import/default": "error",
    "import/namespace": "error",
    "import/no-named-as-default": "warn",
    "import/no-named-as-default-member": "warn",
    "import/no-duplicates": "error",
    "import/order": ["error", {
      "groups": [
        "builtin",
        "external",
        "internal",
        ["parent", "sibling"],
        "index",
        "object",
        "type"
      ],
      "newlines-between": "always",
      "alphabetize": {
        "order": "asc",
        "caseInsensitive": true
      }
    }],
    "import/extensions": [
      "error",
      "ignorePackages",
      {
        "js": "never",
        "jsx": "never",
        "ts": "never",
        "tsx": "never"
      }
    ],
    
    // A11y rules
    "jsx-a11y/anchor-is-valid": ["error", {
      "components": ["Link"],
      "specialLink": ["hrefLeft", "hrefRight"],
      "aspects": ["invalidHref", "preferButton"]
    }],
    "jsx-a11y/click-events-have-key-events": "warn",
    "jsx-a11y/no-static-element-interactions": "warn",
    
    // Jest rules
    "jest/no-disabled-tests": "warn",
    "jest/no-focused-tests": "error",
    "jest/no-identical-title": "error",
    "jest/valid-expect": "error",
    "jest/expect-expect": "error",
    "jest/no-conditional-expect": "error",
    
    // Prettier integration
    "prettier/prettier": ["error", {
      "singleQuote": true,
      "trailingComma": "es5",
      "printWidth": 100,
      "tabWidth": 2,
      "semi": true,
      "arrowParens": "avoid",
      "endOfLine": "auto"
    }]
  },
  "overrides": [
    {
      "files": ["**/*.test.ts", "**/*.test.tsx", "**/*.spec.ts", "**/*.spec.tsx"],
      "env": {
        "jest": true
      },
      "rules": {
        "@typescript-eslint/no-explicit-any": "off",
        "@typescript-eslint/no-non-null-assertion": "off"
      }
    },
    {
      "files": ["*.js", "*.jsx"],
      "rules": {
        "@typescript-eslint/no-var-requires": "off",
        "@typescript-eslint/explicit-function-return-type": "off"
      }
    },
    {
      "files": ["*.stories.tsx", "*.stories.ts"],
      "rules": {
        "import/no-anonymous-default-export": "off"
      }
    }
  ]
}


frontend/.stylelintrc.json
-----------------------------------------

{
  "extends": [
    "stylelint-config-standard",
    "stylelint-config-standard-scss",
    "stylelint-config-prettier-scss"
  ],
  "plugins": [
    "stylelint-scss",
    "stylelint-order"
  ],
  "rules": {
    "at-rule-no-unknown": null,
    "scss/at-rule-no-unknown": true,
    "scss/dollar-variable-pattern": "^[a-z][a-zA-Z0-9]+$",
    "scss/selector-no-redundant-nesting-selector": true,
    "block-no-empty": true,
    "color-hex-length": "short",
    "color-named": "never",
    "color-no-invalid-hex": true,
    "declaration-block-no-duplicate-properties": true,
    "declaration-block-no-shorthand-property-overrides": true,
    "declaration-block-single-line-max-declarations": 1,
    "declaration-no-important": true,
    "declaration-property-value-disallowed-list": {
      "/^border/": ["none"]
    },
    "function-calc-no-unspaced-operator": true,
    "function-linear-gradient-no-nonstandard-direction": true,
    "function-url-quotes": "always",
    "length-zero-no-unit": true,
    "max-nesting-depth": [
      5,
      {
        "ignoreAtRules": ["media", "supports", "include"]
      }
    ],
    "media-feature-name-no-unknown": true,
    "no-descending-specificity": [
      true,
      {
        "ignore": ["selectors-within-list"]
      }
    ],
    "no-duplicate-selectors": true,
    "no-invalid-double-slash-comments": true,
    "property-no-unknown": true,
    "selector-max-id": 1,
    "selector-max-universal": 2,
    "selector-pseudo-class-no-unknown": true,
    "selector-pseudo-element-no-unknown": true,
    "selector-type-no-unknown": true,
    "shorthand-property-no-redundant-values": true,
    "string-no-newline": true,
    "string-quotes": "single",
    "unit-no-unknown": true,
    "value-no-vendor-prefix": true,
    "order/properties-alphabetical-order": null,
    "order/order": [
      "custom-properties",
      "declarations"
    ],
    "order/properties-order": [
      {
        "groupName": "Positioning",
        "properties": [
          "position",
          "top",
          "right",
          "bottom",
          "left",
          "z-index"
        ]
      },
      {
        "groupName": "Box Model",
        "properties": [
          "display",
          "flex",
          "flex-basis",
          "flex-direction",
          "flex-flow",
          "flex-grow",
          "flex-shrink",
          "flex-wrap",
          "grid",
          "grid-area",
          "grid-template",
          "grid-template-areas",
          "grid-template-rows",
          "grid-template-columns",
          "grid-row",
          "grid-row-start",
          "grid-row-end",
          "grid-column",
          "grid-column-start",
          "grid-column-end",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-gap",
          "grid-row-gap",
          "grid-column-gap",
          "gap",
          "row-gap",
          "column-gap",
          "align-content",
          "align-items",
          "align-self",
          "justify-content",
          "justify-items",
          "justify-self",
          "order",
          "float",
          "clear",
          "box-sizing",
          "width",
          "min-width",
          "max-width",
          "height",
          "min-height",
          "max-height",
          "padding",
          "padding-top",
          "padding-right",
          "padding-bottom",
          "padding-left",
          "margin",
          "margin-top",
          "margin-right",
          "margin-bottom",
          "margin-left",
          "overflow",
          "overflow-x",
          "overflow-y"
        ]
      },
      {
        "groupName": "Border",
        "properties": [
          "border",
          "border-width",
          "border-style",
          "border-color",
          "border-top",
          "border-top-width",
          "border-top-style",
          "border-top-color",
          "border-right",
          "border-right-width",
          "border-right-style",
          "border-right-color",
          "border-bottom",
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color",
          "border-left",
          "border-left-width",
          "border-left-style",
          "border-left-color",
          "border-radius",
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius",
          "border-image",
          "border-image-source",
          "border-image-slice",
          "border-image-width",
          "border-image-outset",
          "border-image-repeat"
        ]
      },
      {
        "groupName": "Background",
        "properties": [
          "background",
          "background-attachment",
          "background-clip",
          "background-color",
          "background-image",
          "background-origin",
          "background-position",
          "background-repeat",
          "background-size",
          "background-blend-mode"
        ]
      },
      {
        "groupName": "Typography",
        "properties": [
          "color",
          "font",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "font-smoothing",
          "osx-font-smoothing",
          "font-feature-settings",
          "letter-spacing",
          "line-height",
          "text-align",
          "text-decoration",
          "text-indent",
          "text-overflow",
          "text-rendering",
          "text-shadow",
          "text-transform",
          "text-wrap",
          "word-spacing",
          "word-break",
          "word-wrap",
          "white-space",
          "vertical-align",
          "list-style",
          "list-style-type",
          "list-style-position",
          "list-style-image"
        ]
      },
      {
        "groupName": "Effects & Animation",
        "properties": [
          "appearance",
          "clip",
          "clip-path",
          "counter-reset",
          "counter-increment",
          "resize",
          "user-select",
          "nav-index",
          "nav-up",
          "nav-right",
          "nav-down",
          "nav-left",
          "pointer-events",
          "quotes",
          "table-layout",
          "empty-cells",
          "caption-side",
          "perspective",
          "perspective-origin",
          "backface-visibility",
          "transform",
          "transform-origin",
          "transform-style",
          "transition",
          "transition-property",
          "transition-duration",
          "transition-timing-function",
          "transition-delay",
          "animation",
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-iteration-count",
          "animation-direction",
          "animation-fill-mode",
          "animation-play-state",
          "opacity",
          "visibility",
          "cursor",
          "outline",
          "outline-width",
          "outline-style",
          "outline-color",
          "outline-offset",
          "box-shadow",
          "mix-blend-mode",
          "filter",
          "backdrop-filter"
        ]
      },
      {
        "groupName": "SVG Styles",
        "properties": [
          "alignment-baseline",
          "baseline-shift",
          "dominant-baseline",
          "fill",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "stroke",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "paint-order"
        ]
      }
    ],
    "selector-class-pattern": "^[a-z][a-zA-Z0-9]+$",
    "scss/percent-placeholder-pattern": "^[a-z][a-zA-Z0-9]+$",
    "scss/at-function-pattern": "^[a-z][a-zA-Z0-9]+$",
    "scss/at-mixin-pattern": "^[a-z][a-zA-Z0-9]+$",
    "keyframes-name-pattern": "^[a-z][a-zA-Z0-9]+$",
    "declaration-block-trailing-semicolon": "always",
    "no-empty-source": null,
    "selector-class-pattern": null,
    "custom-property-pattern": null,
    "property-no-vendor-prefix": [
      true,
      {
        "ignoreProperties": ["appearance", "text-size-adjust", "font-smoothing"]
      }
    ],
    "value-keyword-case": [
      "lower",
      {
        "camelCaseSvgKeywords": true
      }
    ]
  },
  "ignoreFiles": [
    "node_modules/**",
    "build/**",
    "dist/**",
    "coverage/**",
    "**/*.js",
    "**/*.jsx",
    "**/*.ts",
    "**/*.tsx"
  ]
}


frontend/jest.config.js
--------------------------------------

module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  roots: ['<rootDir>/src'],
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/index.tsx',
    '!src/serviceWorker.ts',
    '!src/reportWebVitals.ts',
    '!src/react-app-env.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
    '!src/mocks/**',
    '!src/types/**',
    '!src/styles/**'
  ],
  coverageThreshold: {
    global: {
      branches: 75,
      functions: 75,
      lines: 75,
      statements: 75
    }
  },
  coverageDirectory: '<rootDir>/coverage',
  setupFilesAfterEnv: [
    '<rootDir>/src/setupTests.ts'
  ],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@components/(.*)$': '<rootDir>/src/components/$1',
    '^@core/(.*)$': '<rootDir>/src/core/$1',
    '^@services/(.*)$': '<rootDir>/src/services/$1',
    '^@hooks/(.*)$': '<rootDir>/src/hooks/$1',
    '^@contexts/(.*)$': '<rootDir>/src/contexts/$1',
    '^@utils/(.*)$': '<rootDir>/src/utils/$1',
    '^@types/(.*)$': '<rootDir>/src/types/$1',
    '^@styles/(.*)$': '<rootDir>/src/styles/$1',
    '^@selenium/(.*)$': '<rootDir>/src/selenium/$1',
    '^@playwright/(.*)$': '<rootDir>/src/playwright/$1',
    '\\.(css|scss|sass)$': 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|webp|avif|svg)$': '<rootDir>/src/__mocks__/fileMock.js'
  },
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{js,jsx,ts,tsx}',
    '<rootDir>/src/**/*.{spec,test}.{js,jsx,ts,tsx}'
  ],
  transform: {
    '^.+\\.(js|jsx|ts|tsx)$': ['ts-jest', {
      tsconfig: 'tsconfig.json',
      isolatedModules: true
    }],
    '^.+\\.css$': '<rootDir>/config/jest/cssTransform.js',
    '^(?!.*\\.(js|jsx|ts|tsx|css|json)$)': '<rootDir>/config/jest/fileTransform.js'
  },
  transformIgnorePatterns: [
    '[/\\\\]node_modules[/\\\\].+\\.(js|jsx|ts|tsx)$',
    '^.+\\.module\\.(css|sass|scss)$'
  ],
  moduleFileExtensions: [
    'ts',
    'tsx',
    'js',
    'jsx',
    'json',
    'node'
  ],
  watchPlugins: [
    'jest-watch-typeahead/filename',
    'jest-watch-typeahead/testname'
  ],
  resetMocks: true,
  testTimeout: 10000,
  globals: {
    'ts-jest': {
      tsconfig: 'tsconfig.json',
      isolatedModules: true,
      diagnostics: {
        warnOnly: true
      }
    }
  },
  verbose: true,
  reporters: [
    'default',
    ['jest-junit', {
      outputDirectory: 'reports/junit',
      outputName: 'js-test-results.xml',
      ancestorSeparator: '  ',
      uniqueOutputName: 'false',
      suiteNameTemplate: '{filepath}',
      classNameTemplate: '{classname}',
      titleTemplate: '{title}'
    }]
  ],
  maxWorkers: '50%',
  errorOnDeprecated: true,
  cacheDirectory: '<rootDir>/node_modules/.cache/jest'
};


LICENSE
----------------------------------
PROPRIETARY LICENSE AGREEMENT

CSTestForge Automation Framework
Version 1.0.0
Copyright (c) 2025 CSTestForge Team. All Rights Reserved.

1. GRANT OF LICENSE

This is a license agreement ("Agreement") between you (either an individual or an entity) and CSTestForge Team ("Licensor"). By installing, copying, or otherwise using CSTestForge Automation Framework ("Software"), you agree to be bound by the terms of this Agreement.

Subject to the terms and conditions of this Agreement, Licensor hereby grants to you a non-exclusive, non-transferable license to use the Software for internal business purposes only.

2. OWNERSHIP AND COPYRIGHT

The Software is owned by Licensor and is protected by copyright laws and international copyright treaties, as well as other intellectual property laws and treaties. The Software is licensed, not sold.

3. RESTRICTIONS

You may not:
a) Copy, modify, adapt, translate, or create derivative works based upon the Software;
b) Reverse engineer, decompile, disassemble, or otherwise attempt to discover the source code of the Software, except and only to the extent that such activity is expressly permitted by applicable law notwithstanding this limitation;
c) Rent, lease, lend, sell, redistribute, sublicense, or transfer the Software;
d) Remove, alter, or obscure any proprietary notices on the Software;
e) Use the Software for any purpose that is illegal or prohibited by this Agreement;
f) Use the Software to create a competing product;
g) Export the Software in violation of applicable export laws and regulations.

4. SUPPORT AND MAINTENANCE

Licensor is not obligated to provide any support, maintenance, or updates for the Software under this Agreement.

5. DISCLAIMER OF WARRANTY

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

6. LIMITATION OF LIABILITY

IN NO EVENT SHALL LICENSOR BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THE SOFTWARE, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

7. TERM AND TERMINATION

This Agreement is effective until terminated. Your rights under this Agreement will terminate automatically without notice from Licensor if you fail to comply with any term of this Agreement. Upon termination of this Agreement, you shall cease all use of the Software and destroy all copies, full or partial, of the Software.

8. GOVERNING LAW

This Agreement shall be governed by the laws of the jurisdiction in which Licensor is located, excluding its conflicts of law rules. You consent to the exclusive jurisdiction and venue in the courts sitting in the jurisdiction in which Licensor is located.

9. ENTIRE AGREEMENT

This Agreement constitutes the entire agreement between you and Licensor concerning the Software and supersedes all prior or contemporaneous oral or written agreements.

10. SEVERABILITY

If any provision of this Agreement is held to be unenforceable, that provision will be removed and the remaining provisions will remain in full force.

11. WAIVER

The failure of Licensor to enforce any right or provision in this Agreement will not constitute a waiver of such right or provision unless acknowledged and agreed to by Licensor in writing.

By using the Software, you acknowledge that you have read this Agreement, understand it, and agree to be bound by its terms and conditions.




recorder/common/base-injector.js
-------------------------------------------------------

/**
 * CSTestForge Base Injector Script
 * This script serves as the foundation for all browser-specific injectors.
 * It provides common functionality for capturing browser events, monitoring the DOM,
 * identifying elements, and communicating with the CSTestForge application.
 * 
 * @version 1.0.0
 * @copyright CSTestForge Team
 */

(function() {
    'use strict';

    /** Constants */
    const CSTESTFORGE_PREFIX = '__cstestforge__';
    const EVENT_TYPES = {
        CLICK: 'click',
        DBLCLICK: 'dblclick',
        CHANGE: 'change',
        INPUT: 'input',
        KEYDOWN: 'keydown',
        KEYUP: 'keyup',
        KEYPRESS: 'keypress',
        FOCUS: 'focus',
        BLUR: 'blur',
        SUBMIT: 'submit',
        CONTEXTMENU: 'contextmenu',
        MOUSEDOWN: 'mousedown',
        MOUSEUP: 'mouseup',
        MOUSEOVER: 'mouseover',
        MOUSEOUT: 'mouseout',
        DRAG: 'drag',
        DRAGSTART: 'dragstart',
        DRAGEND: 'dragend',
        DROP: 'drop'
    };
    const IGNORED_TAG_TYPES = ['html', 'head', 'meta', 'script', 'style', 'link', 'title', 'wbr', 'br'];
    const DEFAULT_CONFIG = {
        captureClicks: true,
        captureInputs: true,
        captureKeyboard: true,
        captureForms: true,
        captureHover: false,
        captureContextMenu: false,
        captureDrag: false,
        ignoredTagNames: IGNORED_TAG_TYPES,
        ignoredClassPattern: /hidden|d-none|invisible|ng-hide|sr-only/,
        domObserverEnabled: true,
        networkMonitorEnabled: true,
        performanceTimingEnabled: true,
        smartWaitDetection: true,
        maxEventBatchSize: 10,
        eventBatchInterval: 500,
        maxLogSize: 1000,
        highlightColor: '#C54B8C',
        highlightDuration: 500,
        scrollIntoViewOnHighlight: true,
        debugMode: false
    };

    /** Private variables */
    let _config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
    let _initialized = false;
    let _paused = false;
    let _recordingId = null;
    let _sessionId = null;
    let _pendingEvents = [];
    let _eventBatchTimer = null;
    let _domObserver = null;
    let _highlightedElements = new Set();
    let _activeHighlights = new Map();
    let _elementRegistry = new Map();
    let _iframeRegistry = new Map();
    let _eventHandlers = new Map();
    let _messageHandlers = new Map();
    let _performanceTimings = [];
    let _networkRequests = [];
    let _eventCount = 0;
    let _domMutationCount = 0;
    let _isRecording = false;
    let _recordingStartTime = null;
    let _lastEventTime = null;
    let _browserInfo = null;
    let _styleEl = null;
    let _readyState = false;
    let _connectionStatus = 'disconnected';
    let _featureDetectionResults = null;
    
    /** Class representing the CSTestForge Injector */
    class CSTestForgeInjector {
        /**
         * Create a new CSTestForge injector instance
         * @param {Object} config - Configuration options
         */
        constructor(config = {}) {
            this._mergeConfig(config);
            this._detectBrowser();
            this._detectFeatures();
            this._initialized = false;
            
            // Bind methods to preserve 'this' context
            this.init = this.init.bind(this);
            this.start = this.start.bind(this);
            this.stop = this.stop.bind(this);
            this.pause = this.pause.bind(this);
            this.resume = this.resume.bind(this);
            this.reset = this.reset.bind(this);
            this.highlightElement = this.highlightElement.bind(this);
            this.clearHighlights = this.clearHighlights.bind(this);
            this._handleEvent = this._handleEvent.bind(this);
            this._handleMessage = this._handleMessage.bind(this);
            this._processPendingEvents = this._processPendingEvents.bind(this);
            this._observeDom = this._observeDom.bind(this);
            this._handleDomMutations = this._handleDomMutations.bind(this);
            this._monitorNetworkActivity = this._monitorNetworkActivity.bind(this);
            this._collectPerformanceTimings = this._collectPerformanceTimings.bind(this);
            this._setupMessageChannel = this._setupMessageChannel.bind(this);
            this._injectCSS = this._injectCSS.bind(this);
            this._getUniqueElementId = this._getUniqueElementId.bind(this);
            this._getElementInfo = this._getElementInfo.bind(this);
            this._generateXPath = this._generateXPath.bind(this);
            this._generateCssSelector = this._generateCssSelector.bind(this);
            this._getElementAttributes = this._getElementAttributes.bind(this);
            this._scanIframes = this._scanIframes.bind(this);
            this._injectIntoIframe = this._injectIntoIframe.bind(this);
            this._log = this._log.bind(this);
            this._error = this._error.bind(this);
            this._warn = this._warn.bind(this);
            this._debug = this._debug.bind(this);
            
            // Set up auto-initialization when document is ready
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                setTimeout(this.init, 1);
            } else {
                document.addEventListener('DOMContentLoaded', this.init);
            }
        }
        
        /**
         * Merges custom config with default config
         * @param {Object} customConfig - User provided configuration
         * @private
         */
        _mergeConfig(customConfig) {
            _config = Object.assign({}, DEFAULT_CONFIG, customConfig);
        }
        
        /**
         * Updates the injector configuration
         * @param {Object} configUpdates - Configuration properties to update
         * @public
         */
        updateConfig(configUpdates) {
            if (!configUpdates || typeof configUpdates !== 'object') return;
            this._mergeConfig(configUpdates);
            
            // Reinitialize components that depend on config
            if (_domObserver && 'domObserverEnabled' in configUpdates) {
                this._observeDom();
            }
            
            if ('networkMonitorEnabled' in configUpdates) {
                this._monitorNetworkActivity();
            }
            
            if ('performanceTimingEnabled' in configUpdates) {
                this._collectPerformanceTimings();
            }
            
            if ('highlightColor' in configUpdates && _styleEl) {
                this._injectCSS();
            }
            
            this._sendMessage('configUpdated', { config: _config });
        }
        
        /**
         * Initializes the injector
         * @public
         */
        init() {
            if (_initialized) return;
            
            this._log('Initializing CSTestForge Injector');
            
            try {
                // Create a unique session ID
                _sessionId = this._generateUUID();
                
                // Set up message channel
                this._setupMessageChannel();
                
                // Inject required CSS
                this._injectCSS();
                
                // Set up event listeners
                this._setupEventListeners();
                
                // Initialize DOM observer
                if (_config.domObserverEnabled) {
                    this._observeDom();
                }
                
                // Initialize network monitor
                if (_config.networkMonitorEnabled) {
                    this._monitorNetworkActivity();
                }
                
                // Initialize performance timing collection
                if (_config.performanceTimingEnabled) {
                    this._collectPerformanceTimings();
                }
                
                // Scan for iframes
                this._scanIframes();
                
                // Mark as initialized
                _initialized = true;
                _readyState = true;
                
                // Notify that we're ready
                this._sendMessage('injectorReady', {
                    sessionId: _sessionId,
                    browserInfo: _browserInfo,
                    featureDetection: _featureDetectionResults,
                    url: window.location.href,
                    title: document.title,
                    timestamp: Date.now()
                });
                
                this._debug('CSTestForge Injector initialized successfully');
            } catch (err) {
                this._error('Failed to initialize CSTestForge Injector', err);
                throw err;
            }
        }
        
        /**
         * Starts recording browser events
         * @param {Object} options - Recording options
         * @public
         */
        start(options = {}) {
            if (!_initialized) {
                this.init();
            }
            
            if (_isRecording) {
                this._warn('Recording already in progress');
                return;
            }
            
            _recordingId = options.recordingId || this._generateUUID();
            _isRecording = true;
            _paused = false;
            _recordingStartTime = Date.now();
            _lastEventTime = _recordingStartTime;
            _pendingEvents = [];
            _performanceTimings = [];
            _networkRequests = [];
            _eventCount = 0;
            _domMutationCount = 0;
            
            // Start event batching
            if (_eventBatchTimer) {
                clearInterval(_eventBatchTimer);
            }
            _eventBatchTimer = setInterval(this._processPendingEvents, _config.eventBatchInterval);
            
            this._log('Started recording with ID: ' + _recordingId);
            
            // Notify that recording has started
            this._sendMessage('recordingStarted', {
                recordingId: _recordingId,
                timestamp: _recordingStartTime,
                url: window.location.href,
                title: document.title,
                browserInfo: _browserInfo
            });
        }
        
        /**
         * Stops recording browser events
         * @public
         */
        stop() {
            if (!_isRecording) {
                this._warn('No recording in progress');
                return;
            }
            
            // Process any remaining events
            this._processPendingEvents();
            
            // Clear event batching timer
            if (_eventBatchTimer) {
                clearInterval(_eventBatchTimer);
                _eventBatchTimer = null;
            }
            
            const recordingDuration = Date.now() - _recordingStartTime;
            
            this._log('Stopped recording. Duration: ' + recordingDuration + 'ms, Events: ' + _eventCount);
            
            // Notify that recording has stopped
            this._sendMessage('recordingStopped', {
                recordingId: _recordingId,
                timestamp: Date.now(),
                duration: recordingDuration,
                eventCount: _eventCount,
                mutationCount: _domMutationCount
            });
            
            _isRecording = false;
            _paused = false;
            _recordingId = null;
            _recordingStartTime = null;
            _lastEventTime = null;
        }
        
        /**
         * Pauses the current recording
         * @public
         */
        pause() {
            if (!_isRecording) {
                this._warn('No recording in progress');
                return;
            }
            
            if (_paused) {
                this._warn('Recording already paused');
                return;
            }
            
            _paused = true;
            
            // Process any pending events
            this._processPendingEvents();
            
            this._log('Paused recording');
            
            // Notify that recording has paused
            this._sendMessage('recordingPaused', {
                recordingId: _recordingId,
                timestamp: Date.now()
            });
        }
        
        /**
         * Resumes a paused recording
         * @public
         */
        resume() {
            if (!_isRecording) {
                this._warn('No recording in progress');
                return;
            }
            
            if (!_paused) {
                this._warn('Recording is not paused');
                return;
            }
            
            _paused = false;
            _lastEventTime = Date.now();
            
            this._log('Resumed recording');
            
            // Notify that recording has resumed
            this._sendMessage('recordingResumed', {
                recordingId: _recordingId,
                timestamp: _lastEventTime
            });
        }
        
        /**
         * Resets the injector state
         * @public
         */
        reset() {
            // Stop recording if active
            if (_isRecording) {
                this.stop();
            }
            
            // Clear observers
            if (_domObserver) {
                _domObserver.disconnect();
                _domObserver = null;
            }
            
            // Clear timers
            if (_eventBatchTimer) {
                clearInterval(_eventBatchTimer);
                _eventBatchTimer = null;
            }
            
            // Clear highlights
            this.clearHighlights();
            
            // Reset state
            _initialized = false;
            _paused = false;
            _recordingId = null;
            _sessionId = null;
            _pendingEvents = [];
            _highlightedElements = new Set();
            _activeHighlights = new Map();
            _elementRegistry = new Map();
            _iframeRegistry = new Map();
            _performanceTimings = [];
            _networkRequests = [];
            _eventCount = 0;
            _domMutationCount = 0;
            _isRecording = false;
            _recordingStartTime = null;
            _lastEventTime = null;
            _readyState = false;
            
            // Remove event listeners
            this._removeEventListeners();
            
            // Remove injected styles
            if (_styleEl && _styleEl.parentNode) {
                _styleEl.parentNode.removeChild(_styleEl);
                _styleEl = null;
            }
            
            this._log('Reset CSTestForge Injector state');
            
            // Notify that injector has been reset
            this._sendMessage('injectorReset', {
                sessionId: _sessionId,
                timestamp: Date.now()
            });
        }
        
        /**
         * Highlights an element on the page
         * @param {Element|string} element - Element or selector to highlight
         * @param {Object} options - Highlighting options
         * @public
         */
        highlightElement(element, options = {}) {
            const targetElement = typeof element === 'string' 
                ? document.querySelector(element) 
                : element;
            
            if (!targetElement || !(targetElement instanceof Element)) {
                this._warn('Invalid element for highlighting');
                return;
            }
            
            const highlightOptions = Object.assign({
                duration: _config.highlightDuration,
                color: _config.highlightColor,
                scrollIntoView: _config.scrollIntoViewOnHighlight,
                pulseEffect: true,
                borderWidth: '2px',
                borderStyle: 'solid',
                showInfo: false
            }, options);
            
            // Generate a unique ID for this highlight
            const highlightId = this._generateUUID();
            
            // Create highlight element
            const highlightEl = document.createElement('div');
            highlightEl.id = `${CSTESTFORGE_PREFIX}highlight_${highlightId}`;
            highlightEl.className = `${CSTESTFORGE_PREFIX}highlight`;
            
            // Position the highlight
            const rect = targetElement.getBoundingClientRect();
            const scrollX = window.scrollX || window.pageXOffset;
            const scrollY = window.scrollY || window.pageYOffset;
            
            highlightEl.style.position = 'absolute';
            highlightEl.style.top = `${rect.top + scrollY}px`;
            highlightEl.style.left = `${rect.left + scrollX}px`;
            highlightEl.style.width = `${rect.width}px`;
            highlightEl.style.height = `${rect.height}px`;
            highlightEl.style.backgroundColor = 'transparent';
            highlightEl.style.border = `${highlightOptions.borderWidth} ${highlightOptions.borderStyle} ${highlightOptions.color}`;
            highlightEl.style.pointerEvents = 'none';
            highlightEl.style.zIndex = '2147483647';
            highlightEl.style.boxSizing = 'border-box';
            
            if (highlightOptions.pulseEffect) {
                highlightEl.style.animation = `${CSTESTFORGE_PREFIX}pulse 1s infinite`;
            }
            
            // Add info tooltip if requested
            if (highlightOptions.showInfo) {
                const infoEl = document.createElement('div');
                infoEl.className = `${CSTESTFORGE_PREFIX}highlight-info`;
                infoEl.textContent = targetElement.tagName.toLowerCase() + 
                    (targetElement.id ? `#${targetElement.id}` : '') +
                    (targetElement.className && typeof targetElement.className === 'string' ? 
                        `.${targetElement.className.split(' ')[0]}` : '');
                
                infoEl.style.position = 'absolute';
                infoEl.style.bottom = '100%';
                infoEl.style.left = '0';
                infoEl.style.backgroundColor = highlightOptions.color;
                infoEl.style.color = '#fff';
                infoEl.style.padding = '4px 8px';
                infoEl.style.fontSize = '12px';
                infoEl.style.borderTopLeftRadius = '4px';
                infoEl.style.borderTopRightRadius = '4px';
                infoEl.style.whiteSpace = 'nowrap';
                
                highlightEl.appendChild(infoEl);
            }
            
            // Append to document
            document.body.appendChild(highlightEl);
            
            // Scroll into view if needed
            if (highlightOptions.scrollIntoView) {
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'center'
                });
            }
            
            // Track highlighted elements
            _highlightedElements.add(targetElement);
            _activeHighlights.set(highlightId, {
                element: targetElement,
                highlightEl,
                createdAt: Date.now()
            });
            
            // Auto-remove highlight after duration
            if (highlightOptions.duration > 0) {
                setTimeout(() => {
                    this._removeHighlight(highlightId);
                }, highlightOptions.duration);
            }
            
            return highlightId;
        }
        
        /**
         * Removes a specific highlight
         * @param {string} highlightId - ID of the highlight to remove
         * @private
         */
        _removeHighlight(highlightId) {
            const highlight = _activeHighlights.get(highlightId);
            if (!highlight) return;
            
            const { highlightEl, element } = highlight;
            
            // Remove highlight element
            if (highlightEl && highlightEl.parentNode) {
                highlightEl.parentNode.removeChild(highlightEl);
            }
            
            // Update tracking
            _activeHighlights.delete(highlightId);
            _highlightedElements.delete(element);
        }
        
        /**
         * Clears all active highlights
         * @public
         */
        clearHighlights() {
            // Remove all highlight elements
            for (const [highlightId, highlight] of _activeHighlights.entries()) {
                if (highlight.highlightEl && highlight.highlightEl.parentNode) {
                    highlight.highlightEl.parentNode.removeChild(highlight.highlightEl);
                }
            }
            
            // Clear tracking
            _activeHighlights.clear();
            _highlightedElements.clear();
        }
        
        /**
         * Sets up event listeners for capturing browser events
         * @private
         */
        _setupEventListeners() {
            // Define the event types to listen for based on configuration
            const eventTypes = [];
            
            if (_config.captureClicks) {
                eventTypes.push(EVENT_TYPES.CLICK, EVENT_TYPES.DBLCLICK);
            }
            
            if (_config.captureInputs) {
                eventTypes.push(EVENT_TYPES.CHANGE, EVENT_TYPES.INPUT);
            }
            
            if (_config.captureKeyboard) {
                eventTypes.push(EVENT_TYPES.KEYDOWN, EVENT_TYPES.KEYUP, EVENT_TYPES.KEYPRESS);
            }
            
            if (_config.captureForms) {
                eventTypes.push(EVENT_TYPES.FOCUS, EVENT_TYPES.BLUR, EVENT_TYPES.SUBMIT);
            }
            
            if (_config.captureHover) {
                eventTypes.push(EVENT_TYPES.MOUSEOVER, EVENT_TYPES.MOUSEOUT);
            }
            
            if (_config.captureContextMenu) {
                eventTypes.push(EVENT_TYPES.CONTEXTMENU);
            }
            
            if (_config.captureDrag) {
                eventTypes.push(EVENT_TYPES.DRAG, EVENT_TYPES.DRAGSTART, EVENT_TYPES.DRAGEND, EVENT_TYPES.DROP);
            }
            
            // Always listen for these events regardless of configuration
            eventTypes.push(EVENT_TYPES.MOUSEDOWN, EVENT_TYPES.MOUSEUP);
            
            // Register event listeners
            for (const eventType of eventTypes) {
                const handler = this._handleEvent.bind(this, eventType);
                document.addEventListener(eventType, handler, true);
                _eventHandlers.set(eventType, handler);
            }
            
            // Listen for navigation events
            window.addEventListener('beforeunload', this._handleBeforeUnload.bind(this));
            window.addEventListener('popstate', this._handlePopState.bind(this));
            window.addEventListener('hashchange', this._handleHashChange.bind(this));
            
            // Listen for iframe load events
            window.addEventListener('message', this._handleIframeMessage.bind(this));
            
            this._debug('Event listeners registered for: ' + eventTypes.join(', '));
        }
        
        /**
         * Removes all registered event listeners
         * @private
         */
        _removeEventListeners() {
            // Remove event handlers
            for (const [eventType, handler] of _eventHandlers.entries()) {
                document.removeEventListener(eventType, handler, true);
            }
            
            // Clear event handler map
            _eventHandlers.clear();
            
            // Remove navigation listeners
            window.removeEventListener('beforeunload', this._handleBeforeUnload.bind(this));
            window.removeEventListener('popstate', this._handlePopState.bind(this));
            window.removeEventListener('hashchange', this._handleHashChange.bind(this));
            
            // Remove iframe message listener
            window.removeEventListener('message', this._handleIframeMessage.bind(this));
            
            this._debug('Event listeners removed');
        }
        
        /**
         * Handles browser events
         * @param {string} eventType - Type of the event
         * @param {Event} event - The browser event
         * @private
         */
        _handleEvent(eventType, event) {
            if (!_isRecording || _paused) return;
            
            const targetElement = event.target;
            
            // Ignore events on specific elements
            if (this._shouldIgnoreElement(targetElement)) {
                return;
            }
            
            // Special handling for different event types
            switch (eventType) {
                case EVENT_TYPES.CLICK:
                    if (targetElement.tagName === 'A' && targetElement.href) {
                        // Handle link clicks
                        const isNewTab = targetElement.target === '_blank' || 
                            event.ctrlKey || event.metaKey;
                        
                        if (!isNewTab) {
                            // This link will navigate the page, capture it specially
                            this._captureNavigationEvent(event, targetElement.href);
                        }
                    }
                    break;
                
                case EVENT_TYPES.SUBMIT:
                    // Capture form submissions
                    this._captureFormSubmission(event);
                    break;
                
                case EVENT_TYPES.KEYDOWN:
                case EVENT_TYPES.KEYUP:
                case EVENT_TYPES.KEYPRESS:
                    // Only capture specific keys or key combinations
                    if (!this._shouldCaptureKeyEvent(event)) {
                        return;
                    }
                    break;
            }
            
            // Get element info and create event object
            const elementInfo = this._getElementInfo(targetElement);
            const eventData = this._createEventData(eventType, event, elementInfo);
            
            // Queue the event
            _pendingEvents.push(eventData);
            _eventCount++;
            
            // Process immediately if batch size limit reached
            if (_pendingEvents.length >= _config.maxEventBatchSize) {
                this._processPendingEvents();
            }
        }
        
        /**
         * Determines if an element should be ignored for event capturing
         * @param {Element} element - The element to check
         * @returns {boolean} True if the element should be ignored
         * @private
         */
        _shouldIgnoreElement(element) {
            if (!element || !element.tagName) {
                return true;
            }
            
            const tagName = element.tagName.toLowerCase();
            
            // Ignore elements with ignored tag types
            if (_config.ignoredTagNames.includes(tagName)) {
                return true;
            }
            
            // Ignore elements with matching class pattern
            if (_config.ignoredClassPattern && element.className && 
                typeof element.className === 'string' && 
                _config.ignoredClassPattern.test(element.className)) {
                return true;
            }
            
            // Ignore elements that are not visible
            if (element.offsetParent === null && 
                window.getComputedStyle(element).display !== 'fixed' &&
                window.getComputedStyle(element).position !== 'fixed') {
                return true;
            }
            
            // Ignore CSTestForge's own elements
            if (element.id && element.id.startsWith(CSTESTFORGE_PREFIX)) {
                return true;
            }
            
            if (element.className && typeof element.className === 'string' && 
                element.className.includes(CSTESTFORGE_PREFIX)) {
                return true;
            }
            
            return false;
        }
        
        /**
         * Determines if a keyboard event should be captured
         * @param {KeyboardEvent} event - The keyboard event
         * @returns {boolean} True if the event should be captured
         * @private
         */
        _shouldCaptureKeyEvent(event) {
            // Always capture Enter, Tab, Escape, and arrow keys
            const importantKeys = ['Enter', 'Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
            if (importantKeys.includes(event.key)) {
                return true;
            }
            
            // Capture key combinations with modifier keys
            if (event.ctrlKey || event.altKey || event.metaKey) {
                return true;
            }
            
            // Ignore most keydown/keyup events on input elements to reduce noise
            // Only capture when the target is an input, textarea, or has contenteditable
            const isEditableTarget = event.target.tagName === 'INPUT' || 
                event.target.tagName === 'TEXTAREA' || 
                event.target.isContentEditable;
                
            // For editable fields, we already capture via change/input events,
            // so we only need to capture specific keys
            if (isEditableTarget && event.type === 'keydown') {
                return importantKeys.includes(event.key);
            }
            
            return true;
        }
        
        /**
         * Creates standardized event data object
         * @param {string} eventType - Type of the event
         * @param {Event} event - The original browser event
         * @param {Object} elementInfo - Information about the target element
         * @returns {Object} Standardized event data
         * @private
         */
        _createEventData(eventType, event, elementInfo) {
            const now = Date.now();
            const timeSinceLastEvent = _lastEventTime ? now - _lastEventTime : 0;
            _lastEventTime = now;
            
            // Base event data
            const eventData = {
                id: this._generateUUID(),
                recordingId: _recordingId,
                type: eventType,
                timestamp: now,
                timeSinceLastEvent,
                url: window.location.href,
                target: elementInfo,
                pageTitle: document.title
            };
            
            // Add event-specific data
            switch (eventType) {
                case EVENT_TYPES.CLICK:
                case EVENT_TYPES.DBLCLICK:
                case EVENT_TYPES.MOUSEDOWN:
                case EVENT_TYPES.MOUSEUP:
                case EVENT_TYPES.CONTEXTMENU:
                    eventData.button = event.button;
                    eventData.clientX = event.clientX;
                    eventData.clientY = event.clientY;
                    eventData.pageX = event.pageX;
                    eventData.pageY = event.pageY;
                    eventData.modifiers = this._captureModifiers(event);
                    break;
                
                case EVENT_TYPES.CHANGE:
                case EVENT_TYPES.INPUT:
                    eventData.value = this._getElementValue(event.target);
                    break;
                
                case EVENT_TYPES.KEYDOWN:
                case EVENT_TYPES.KEYUP:
                case EVENT_TYPES.KEYPRESS:
                    eventData.key = event.key;
                    eventData.code = event.code;
                    eventData.modifiers = this._captureModifiers(event);
                    // Don't store the actual input for security reasons
                    break;
                
                case EVENT_TYPES.SUBMIT:
                    eventData.formData = this._captureFormData(event.target);
                    break;
                
                case EVENT_TYPES.DRAG:
                case EVENT_TYPES.DRAGSTART:
                case EVENT_TYPES.DRAGEND:
                case EVENT_TYPES.DROP:
                    eventData.clientX = event.clientX;
                    eventData.clientY = event.clientY;
                    eventData.pageX = event.pageX;
                    eventData.pageY = event.pageY;
                    if (event.dataTransfer && event.dataTransfer.types) {
                        eventData.dataTransferTypes = Array.from(event.dataTransfer.types);
                    }
                    break;
            }
            
            return eventData;
        }
        
        /**
         * Captures modifier keys state
         * @param {Event} event - The event to extract modifiers from
         * @returns {Object} Object containing modifier states
         * @private
         */
        _captureModifiers(event) {
            return {
                ctrlKey: event.ctrlKey || false,
                shiftKey: event.shiftKey || false,
                altKey: event.altKey || false,
                metaKey: event.metaKey || false
            };
        }
        
        /**
         * Gets the value of an element
         * @param {Element} element - The element to get value from
         * @returns {string|boolean|Array} Element value
         * @private
         */
        _getElementValue(element) {
            if (!element) return null;
            
            const tagName = element.tagName.toLowerCase();
            
            if (tagName === 'input') {
                const inputType = (element.type || 'text').toLowerCase();
                
                if (inputType === 'checkbox' || inputType === 'radio') {
                    return element.checked;
                } else if (inputType === 'file') {
                    // Don't capture file names for security
                    return element.files ? `${element.files.length} file(s) selected` : '';
                } else if (inputType === 'password') {
                    // Don't capture password values
                    return '********';
                } else {
                    return element.value;
                }
            } else if (tagName === 'textarea') {
                return element.value;
            } else if (tagName === 'select') {
                if (element.multiple) {
                    return Array.from(element.selectedOptions).map(opt => opt.value);
                } else {
                    return element.value;
                }
            } else if (element.isContentEditable) {
                return element.textContent;
            }
            
            return null;
        }
        
        /**
         * Captures form data for form submission events
         * @param {HTMLFormElement} form - The form element
         * @returns {Object} Form data as key-value pairs
         * @private
         */
        _captureFormData(form) {
            if (!form || form.tagName.toLowerCase() !== 'form') {
                return null;
            }
            
            const formData = {};
            const elements = form.elements;
            
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                const name = element.name || element.id || `field_${i}`;
                
                // Skip elements without a name
                if (!name) continue;
                
                const tagName = element.tagName.toLowerCase();
                const elementType = element.type ? element.type.toLowerCase() : 'text';
                
                // Handle different element types
                if (tagName === 'input') {
                    if (elementType === 'checkbox' || elementType === 'radio') {
                        if (element.checked) {
                            formData[name] = element.value || 'on';
                        }
                    } else if (elementType === 'file') {
                        // Don't capture file names for security
                        formData[name] = element.files ? `${element.files.length} file(s)` : '';
                    } else if (elementType === 'password') {
                        // Don't capture password values
                        formData[name] = '********';
                    } else {
                        formData[name] = element.value;
                    }
                } else if (tagName === 'textarea') {
                    formData[name] = element.value;
                } else if (tagName === 'select') {
                    if (element.multiple) {
                        formData[name] = Array.from(element.selectedOptions).map(opt => opt.value);
                    } else {
                        formData[name] = element.value;
                    }
                }
            }
            
            return formData;
        }
        
        /**
         * Captures a navigation event
         * @param {Event} event - The original event
         * @param {string} href - The destination URL
         * @private
         */
        _captureNavigationEvent(event, href) {
            if (!_isRecording || _paused) return;
            
            const targetElement = event.target;
            const elementInfo = this._getElementInfo(targetElement);
            
            const navigationEvent = {
                id: this._generateUUID(),
                recordingId: _recordingId,
                type: 'navigation',
                navigationType: 'link',
                timestamp: Date.now(),
                timeSinceLastEvent: _lastEventTime ? Date.now() - _lastEventTime : 0,
                url: window.location.href,
                destinationUrl: href,
                target: elementInfo,
                pageTitle: document.title
            };
            
            // Process any pending events
            this._processPendingEvents();
            
            // Send navigation event immediately
            this._sendMessage('event', navigationEvent);
            
            _lastEventTime = Date.now();
            _eventCount++;
        }
        
        /**
         * Captures a form submission
         * @param {Event} event - The form submission event
         * @private
         */
        _captureFormSubmission(event) {
            if (!_isRecording || _paused) return;
            
            const form = event.target;
            if (!form || form.tagName.toLowerCase() !== 'form') return;
            
            // Extract form info
            const formInfo = this._getElementInfo(form);
            const formData = this._captureFormData(form);
            const action = form.action || window.location.href;
            const method = (form.method || 'get').toLowerCase();
            
            const formEvent = {
                id: this._generateUUID(),
                recordingId: _recordingId,
                type: 'form_submit',
                timestamp: Date.now(),
                timeSinceLastEvent: _lastEventTime ? Date.now() - _lastEventTime : 0,
                url: window.location.href,
                target: formInfo,
                pageTitle: document.title,
                formAction: action,
                formMethod: method,
                formData: formData
            };
            
            // Add to pending events
            _pendingEvents.push(formEvent);
            _eventCount++;
            
            // Process immediately since form submission may navigate away
            this._processPendingEvents();
        }
        
        /**
         * Handles beforeunload event
         * @param {Event} event - The beforeunload event
         * @private
         */
        _handleBeforeUnload(event) {
            if (!_isRecording || _paused) return;
            
            // Capture the unload event
            const unloadEvent = {
                id: this._generateUUID(),
                recordingId: _recordingId,
                type: 'navigation',
                navigationType: 'unload',
                timestamp: Date.now(),
                timeSinceLastEvent: _lastEventTime ? Date.now() - _lastEventTime : 0,
                url: window.location.href,
                pageTitle: document.title
            };
            
            // Process any pending events
            this._processPendingEvents();
            
            // Send unload event immediately
            this._sendMessage('event', unloadEvent);
            
            _lastEventTime = Date.now();
            _eventCount++;
        }
        
        /**
         * Handles popstate event (browser back/forward)
         * @param {Event} event - The popstate event
         * @private
         */
        _handlePopState(event) {
            if (!_isRecording || _paused) return;
            
            // Capture the navigation event
            const navEvent = {
                id: this._generateUUID(),
                recordingId: _recordingId,
                type: 'navigation',
                navigationType: 'popstate',
                timestamp: Date.now(),
                timeSinceLastEvent: _lastEventTime ? Date.now() - _lastEventTime : 0,
                url: window.location.href,
                pageTitle: document.title,
                state: event.state ? JSON.stringify(event.state) : null
            };
            
            // Add to pending events
            _pendingEvents.push(navEvent);
            _eventCount++;
            
            // Process immediately
            this._processPendingEvents();
        }
        
        /**
         * Handles hashchange event
         * @param {Event} event - The hashchange event
         * @private
         */
        _handleHashChange(event) {
            if (!_isRecording || _paused) return;
            
            // Capture the hash change event
            const hashEvent = {
                id: this._generateUUID(),
                recordingId: _recordingId,
                type: 'navigation',
                navigationType: 'hashchange',
                timestamp: Date.now(),
                timeSinceLastEvent: _lastEventTime ? Date.now() - _lastEventTime : 0,
                url: window.location.href,
                pageTitle: document.title,
                oldUrl: event.oldURL,
                newUrl: event.newURL
            };
            
            // Add to pending events
            _pendingEvents.push(hashEvent);
            _eventCount++;
            
            // Process immediately
            this._processPendingEvents();
        }
        
        /**
         * Handles messages from iframes
         * @param {MessageEvent} event - The message event
         * @private
         */
        _handleIframeMessage(event) {
            // Verify that the message is from a known iframe
            const iframe = Array.from(_iframeRegistry.values())
                .find(entry => entry.contentWindow === event.source);
                
            if (!iframe) return;
            
            // Verify that it's a CSTestForge message
            const data = event.data;
            if (!data || !data.cstestforge) return;
            
            // Process the message based on its type
            switch (data.type) {
                case 'event':
                    // Add iframe info to the event
                    data.payload.iframeInfo = this._getElementInfo(iframe.element);
                    
                    // Add to pending events
                    if (_isRecording && !_paused) {
                        _pendingEvents.push(data.payload);
                        _eventCount++;
                        
                        // Process if batch size limit reached
                        if (_pendingEvents.length >= _config.maxEventBatchSize) {
                            this._processPendingEvents();
                        }
                    }
                    break;
                    
                case 'injectorReady':
                    this._debug('Injector ready in iframe', iframe.element.id || iframe.element.name);
                    break;
                    
                // Handle other message types...
            }
        }
        
        /**
         * Processes pending events by sending them to the application
         * @private
         */
        _processPendingEvents() {
            if (_pendingEvents.length === 0) return;
            
            // Create a copy of pending events
            const events = [..._pendingEvents];
            
            // Clear pending events
            _pendingEvents = [];
            
            // Send events
            this._sendMessage('events', { events });
            
            this._debug(`Processed ${events.length} events`);
        }
        
        /**
         * Observes DOM for mutations
         * @private
         */
        _observeDom() {
            // Disconnect existing observer if any
            if (_domObserver) {
                _domObserver.disconnect();
                _domObserver = null;
            }
            
            // Exit if DOM observation is disabled
            if (!_config.domObserverEnabled) {
                return;
            }
            
            // Create new observer
            _domObserver = new MutationObserver(this._handleDomMutations);
            
            // Start observing
            _domObserver.observe(document.documentElement, {
                childList: true,
                attributes: true,
                characterData: true,
                subtree: true,
                attributeOldValue: true,
                characterDataOldValue: true
            });
            
            this._debug('DOM observer started');
        }
        
        /**
         * Handles DOM mutations
         * @param {MutationRecord[]} mutations - Array of mutation records
         * @private
         */
        _handleDomMutations(mutations) {
            if (!_isRecording || _paused) return;
            
            // Filter out mutations that should be ignored
            const significantMutations = mutations.filter(mutation => {
                // Ignore mutations on elements we should ignore
                if (this._shouldIgnoreElement(mutation.target)) {
                    return false;
                }
                
                // Ignore mutations on our own elements
                if (mutation.target.id && mutation.target.id.startsWith(CSTESTFORGE_PREFIX)) {
                    return false;
                }
                
                // For attribute mutations, ignore certain attributes
                if (mutation.type === 'attributes') {
                    const ignoredAttributes = [
                        'data-reactid', 'aria-expanded', 'aria-selected',
                        'data-hover', 'data-focus', 'data-clicked',
                        'style' // Often changes for UI effects
                    ];
                    
                    if (ignoredAttributes.includes(mutation.attributeName)) {
                        return false;
                    }
                    
                    // Ignore class changes that only affect UI state
                    if (mutation.attributeName === 'class' && 
                        mutation.oldValue && 
                        mutation.target.className) {
                        const oldClasses = new Set(mutation.oldValue.split(/\s+/));
                        const newClasses = new Set(mutation.target.className.split(/\s+/));
                        
                        // If only UI state classes changed, ignore
                        const stateClassPatterns = [
                            /\bhover\b/, /\bactive\b/, /\bfocus\b/, /\bselected\b/,
                            /\bopen\b/, /\bclosed\b/, /\bexpanded\b/, /\bcollapsed\b/
                        ];
                        
                        const changedClasses = [...new Set([
                            ...Array.from(oldClasses).filter(c => !newClasses.has(c)),
                            ...Array.from(newClasses).filter(c => !oldClasses.has(c))
                        ])];
                        
                        const onlyStateChanged = changedClasses.every(className => 
                            stateClassPatterns.some(pattern => pattern.test(className))
                        );
                        
                        if (onlyStateChanged) {
                            return false;
                        }
                    }
                }
                
                return true;
            });
            
            if (significantMutations.length === 0) {
                return;
            }
            
            // Process mutations
            _domMutationCount += significantMutations.length;
            
            // Scan for new iframes
            const hasNewIframes = significantMutations.some(mutation => {
                if (mutation.type !== 'childList') return false;
                
                return Array.from(mutation.addedNodes).some(node => 
                    node.nodeType === Node.ELEMENT_NODE && 
                    (node.tagName === 'IFRAME' || 
                     node.querySelectorAll('iframe').length > 0)
                );
            });
            
            if (hasNewIframes) {
                this._scanIframes();
            }
            
            // If smart wait detection is enabled, analyze mutations to detect AJAX content loading
            if (_config.smartWaitDetection) {
                this._detectContentLoading(significantMutations);
            }
        }
        
        /**
         * Detects content loading through DOM mutations
         * @param {MutationRecord[]} mutations - Array of mutation records
         * @private
         */
        _detectContentLoading(mutations) {
            // Look for patterns that suggest AJAX content loading
            const hasSignificantAdditions = mutations.some(mutation => {
                if (mutation.type !== 'childList') return false;
                
                // Check if multiple elements were added (common in AJAX)
                if (mutation.addedNodes.length > 3) return true;
                
                // Check if significant elements were added
                return Array.from(mutation.addedNodes).some(node => {
                    if (node.nodeType !== Node.ELEMENT_NODE) return false;
                    
                    // Consider it significant if it has many children or is a container
                    const significantTags = ['div', 'table', 'ul', 'ol', 'section', 'article', 'main'];
                    const isSignificantTag = significantTags.includes(node.tagName.toLowerCase());
                    const hasMultipleChildren = node.children && node.children.length > 3;
                    
                    return isSignificantTag && hasMultipleChildren;
                });
            });
            
            if (hasSignificantAdditions) {
                // Send a content loading event
                const loadingEvent = {
                    id: this._generateUUID(),
                    recordingId: _recordingId,
                    type: 'content_change',
                    changeType: 'loading_complete',
                    timestamp: Date.now(),
                    timeSinceLastEvent: _lastEventTime ? Date.now() - _lastEventTime : 0,
                    url: window.location.href,
                    pageTitle: document.title
                };
                
                // Add to pending events
                _pendingEvents.push(loadingEvent);
                _eventCount++;
                
                this._debug('Detected content loading through DOM mutations');
            }
        }
        
        /**
         * Monitors network activity
         * @private
         */
        _monitorNetworkActivity() {
            if (!_config.networkMonitorEnabled) return;
            
            // We can't directly monitor network, but we can use Performance API
            // to get network timing information
            
            // Create a PerformanceObserver to watch for resource timing entries
            if (window.PerformanceObserver) {
                try {
                    const observer = new PerformanceObserver(list => {
                        if (!_isRecording || _paused) return;
                        
                        const entries = list.getEntries();
                        for (const entry of entries) {
                            if (entry.entryType === 'resource') {
                                this._processResourceTiming(entry);
                            }
                        }
                    });
                    
                    observer.observe({ entryTypes: ['resource'] });
                    
                    this._debug('Network activity monitoring started');
                } catch (err) {
                    this._warn('Failed to set up PerformanceObserver', err);
                }
            }
            
            // Patch XMLHttpRequest to monitor AJAX requests
            this._patchXHR();
            
            // Patch Fetch API
            this._patchFetch();
        }
        
        /**
         * Processes a resource timing entry
         * @param {PerformanceResourceTiming} entry - The resource timing entry
         * @private
         */
        _processResourceTiming(entry) {
            // Ignore very small resources (likely not important)
            if (entry.transferSize < 100 && entry.duration < 50) {
                return;
            }
            
            const request = {
                url: entry.name,
                startTime: _recordingStartTime ? entry.startTime + _recordingStartTime :entry.startTime,
                endTime: _recordingStartTime ? entry.startTime + entry.duration + _recordingStartTime : entry.startTime + entry.duration,
                initiatorType: entry.initiatorType,
                duration: entry.duration,
                transferSize: entry.transferSize,
                decodedBodySize: entry.decodedBodySize,
                encodedBodySize: entry.encodedBodySize
            };
            
            // Track the request
            _networkRequests.push(request);
            
            // If this looks like a major resource, send an event
            if (this._isSignificantResource(entry)) {
                const networkEvent = {
                    id: this._generateUUID(),
                    recordingId: _recordingId,
                    type: 'network',
                    networkType: 'resource',
                    timestamp: Date.now(),
                    timeSinceLastEvent: _lastEventTime ? Date.now() - _lastEventTime : 0,
                    url: window.location.href,
                    pageTitle: document.title,
                    resourceUrl: entry.name,
                    resourceType: this._getResourceType(entry),
                    duration: entry.duration,
                    size: entry.transferSize
                };
                
                // Add to pending events
                _pendingEvents.push(networkEvent);
                _eventCount++;
            }
        }
        
        /**
         * Determines if a resource is significant enough to track
         * @param {PerformanceResourceTiming} entry - The resource timing entry
         * @returns {boolean} True if the resource is significant
         * @private
         */
        _isSignificantResource(entry) {
            // Consider JS, CSS, and large resources as significant
            const isJS = entry.name.endsWith('.js') || entry.name.includes('.js?');
            const isCSS = entry.name.endsWith('.css') || entry.name.includes('.css?');
            const isLarge = entry.transferSize > 50000; // 50KB
            const isLongLoading = entry.duration > 500; // 500ms
            
            return isJS || isCSS || isLarge || isLongLoading;
        }
        
        /**
         * Gets the resource type from a performance entry
         * @param {PerformanceResourceTiming} entry - The resource timing entry
         * @returns {string} Resource type
         * @private
         */
        _getResourceType(entry) {
            const url = entry.name.toLowerCase();
            
            if (url.endsWith('.js') || url.includes('.js?')) return 'script';
            if (url.endsWith('.css') || url.includes('.css?')) return 'stylesheet';
            if (url.match(/\.(jpg|jpeg|png|gif|webp|svg|ico)($|\?)/)) return 'image';
            if (url.match(/\.(mp4|webm|ogv)($|\?)/)) return 'video';
            if (url.match(/\.(mp3|ogg|wav)($|\?)/)) return 'audio';
            if (url.match(/\.(woff|woff2|ttf|eot|otf)($|\?)/)) return 'font';
            if (url.match(/\.(json|xml)($|\?)/)) return 'data';
            if (url.includes('/api/') || url.includes('/service/')) return 'api';
            
            return entry.initiatorType || 'other';
        }
        
        /**
         * Patches XMLHttpRequest to monitor AJAX requests
         * @private
         */
        _patchXHR() {
            const originalOpen = XMLHttpRequest.prototype.open;
            const originalSend = XMLHttpRequest.prototype.send;
            const self = this;
            
            XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
                this._cstestforge_data = {
                    method,
                    url,
                    startTime: Date.now()
                };
                
                originalOpen.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function(body) {
                if (!this._cstestforge_data) {
                    this._cstestforge_data = {
                        startTime: Date.now()
                    };
                }
                
                if (body && typeof body === 'string') {
                    this._cstestforge_data.requestBody = body.length > 1000 ? 
                        body.substring(0, 1000) + '... [truncated]' : body;
                }
                
                const self = this;
                
                this.addEventListener('load', function() {
                    if (!_isRecording || _paused) return;
                    
                    const endTime = Date.now();
                    const duration = endTime - self._cstestforge_data.startTime;
                    
                    // Check if this is a significant request (took more than 500ms or has status != 200)
                    if (duration > 500 || this.status !== 200) {
                        const ajaxEvent = {
                            id: _this._generateUUID(),
                            recordingId: _recordingId,
                            type: 'network',
                            networkType: 'xhr',
                            timestamp: endTime,
                            timeSinceLastEvent: _lastEventTime ? endTime - _lastEventTime : 0,
                            url: window.location.href,
                            pageTitle: document.title,
                            requestUrl: self._cstestforge_data.url,
                            requestMethod: self._cstestforge_data.method,
                            status: this.status,
                            statusText: this.statusText,
                            duration: duration,
                            contentType: this.getResponseHeader('Content-Type') || ''
                        };
                        
                        // Add to pending events
                        _pendingEvents.push(ajaxEvent);
                        _eventCount++;
                        
                        // Check if this might be the end of an AJAX content load
                        if (_config.smartWaitDetection) {
                            // Wait a bit to let the DOM update
                            setTimeout(() => {
                                const loadingEvent = {
                                    id: _this._generateUUID(),
                                    recordingId: _recordingId,
                                    type: 'content_change',
                                    changeType: 'ajax_complete',
                                    timestamp: Date.now(),
                                    timeSinceLastEvent: _lastEventTime ? Date.now() - _lastEventTime : 0,
                                    url: window.location.href,
                                    pageTitle: document.title,
                                    triggerUrl: self._cstestforge_data.url
                                };
                                
                                // Add to pending events
                                _pendingEvents.push(loadingEvent);
                                _eventCount++;
                            }, 500);
                        }
                    }
                });
                
                this.addEventListener('error', function() {
                    if (!_isRecording || _paused) return;
                    
                    const endTime = Date.now();
                    
                    const errorEvent = {
                        id: _this._generateUUID(),
                        recordingId: _recordingId,
                        type: 'network',
                        networkType: 'xhr_error',
                        timestamp: endTime,
                        timeSinceLastEvent: _lastEventTime ? endTime - _lastEventTime : 0,
                        url: window.location.href,
                        pageTitle: document.title,
                        requestUrl: self._cstestforge_data.url,
                        requestMethod: self._cstestforge_data.method,
                        duration: endTime - self._cstestforge_data.startTime
                    };
                    
                    // Add to pending events
                    _pendingEvents.push(errorEvent);
                    _eventCount++;
                });
                
                // Call original method
                originalSend.apply(this, arguments);
            };
        }
        
        /**
         * Patches Fetch API to monitor fetch requests
         * @private
         */
        _patchFetch() {
            const originalFetch = window.fetch;
            const self = this;
            
            window.fetch = function(input, init) {
                if (!_isRecording || _paused) {
                    return originalFetch.apply(this, arguments);
                }
                
                const startTime = Date.now();
                
                let url = '';
                let method = 'GET';
                
                if (typeof input === 'string') {
                    url = input;
                } else if (input instanceof Request) {
                    url = input.url;
                    method = input.method || 'GET';
                }
                
                if (init && init.method) {
                    method = init.method;
                }
                
                // Call original fetch
                const fetchPromise = originalFetch.apply(this, arguments);
                
                // Add listeners to track the request
                fetchPromise.then(response => {
                    const endTime = Date.now();
                    const duration = endTime - startTime;
                    
                    // Check if this is a significant request (took more than 500ms or has status != 200)
                    if (duration > 500 || !response.ok) {
                        const fetchEvent = {
                            id: self._generateUUID(),
                            recordingId: _recordingId,
                            type: 'network',
                            networkType: 'fetch',
                            timestamp: endTime,
                            timeSinceLastEvent: _lastEventTime ? endTime - _lastEventTime : 0,
                            url: window.location.href,
                            pageTitle: document.title,
                            requestUrl: url,
                            requestMethod: method,
                            status: response.status,
                            statusText: response.statusText,
                            duration: duration,
                            contentType: response.headers.get('Content-Type') || ''
                        };
                        
                        // Add to pending events
                        _pendingEvents.push(fetchEvent);
                        _eventCount++;
                        
                        // Check if this might be the end of an AJAX content load
                        if (_config.smartWaitDetection) {
                            // Wait a bit to let the DOM update
                            setTimeout(() => {
                                const loadingEvent = {
                                    id: self._generateUUID(),
                                    recordingId: _recordingId,
                                    type: 'content_change',
                                    changeType: 'ajax_complete',
                                    timestamp: Date.now(),
                                    timeSinceLastEvent: _lastEventTime ? Date.now() - _lastEventTime : 0,
                                    url: window.location.href,
                                    pageTitle: document.title,
                                    triggerUrl: url
                                };
                                
                                // Add to pending events
                                _pendingEvents.push(loadingEvent);
                                _eventCount++;
                            }, 500);
                        }
                    }
                }).catch(error => {
                    const endTime = Date.now();
                    
                    const errorEvent = {
                        id: self._generateUUID(),
                        recordingId: _recordingId,
                        type: 'network',
                        networkType: 'fetch_error',
                        timestamp: endTime,
                        timeSinceLastEvent: _lastEventTime ? endTime - _lastEventTime : 0,
                        url: window.location.href,
                        pageTitle: document.title,
                        requestUrl: url,
                        requestMethod: method,
                        duration: endTime - startTime,
                        errorMessage: error.message
                    };
                    
                    // Add to pending events
                    _pendingEvents.push(errorEvent);
                    _eventCount++;
                });
                
                return fetchPromise;
            };
        }
        
        /**
         * Collects performance timings
         * @private
         */
        _collectPerformanceTimings() {
            if (!_config.performanceTimingEnabled || !window.performance) return;
            
            // Collect navigation timing data
            if (window.performance.timing) {
                const timing = window.performance.timing;
                
                const timingData = {
                    navigationStart: timing.navigationStart,
                    unloadEventStart: timing.unloadEventStart,
                    unloadEventEnd: timing.unloadEventEnd,
                    redirectStart: timing.redirectStart,
                    redirectEnd: timing.redirectEnd,
                    fetchStart: timing.fetchStart,
                    domainLookupStart: timing.domainLookupStart,
                    domainLookupEnd: timing.domainLookupEnd,
                    connectStart: timing.connectStart,
                    connectEnd: timing.connectEnd,
                    secureConnectionStart: timing.secureConnectionStart,
                    requestStart: timing.requestStart,
                    responseStart: timing.responseStart,
                    responseEnd: timing.responseEnd,
                    domLoading: timing.domLoading,
                    domInteractive: timing.domInteractive,
                    domContentLoadedEventStart: timing.domContentLoadedEventStart,
                    domContentLoadedEventEnd: timing.domContentLoadedEventEnd,
                    domComplete: timing.domComplete,
                    loadEventStart: timing.loadEventStart,
                    loadEventEnd: timing.loadEventEnd
                };
                
                _performanceTimings.push({
                    type: 'navigation',
                    timestamp: Date.now(),
                    url: window.location.href,
                    data: timingData
                });
            }
            
            // Set up an observer for the Paint Timing API
            if (window.PerformanceObserver && PerformanceObserver.supportedEntryTypes && 
                PerformanceObserver.supportedEntryTypes.includes('paint')) {
                
                try {
                    const observer = new PerformanceObserver(list => {
                        const entries = list.getEntries();
                        
                        for (const entry of entries) {
                            _performanceTimings.push({
                                type: 'paint',
                                timestamp: Date.now(),
                                url: window.location.href,
                                data: {
                                    name: entry.name,
                                    startTime: entry.startTime,
                                    duration: entry.duration
                                }
                            });
                        }
                    });
                    
                    observer.observe({ entryTypes: ['paint'] });
                } catch (err) {
                    this._warn('Failed to set up Paint Timing observer', err);
                }
            }
            
            // Set up an observer for Largest Contentful Paint
            if (window.PerformanceObserver && PerformanceObserver.supportedEntryTypes && 
                PerformanceObserver.supportedEntryTypes.includes('largest-contentful-paint')) {
                
                try {
                    const observer = new PerformanceObserver(list => {
                        const entries = list.getEntries();
                        
                        // We only care about the most recent LCP event
                        if (entries.length > 0) {
                            const entry = entries[entries.length - 1];
                            
                            _performanceTimings.push({
                                type: 'largest-contentful-paint',
                                timestamp: Date.now(),
                                url: window.location.href,
                                data: {
                                    startTime: entry.startTime,
                                    size: entry.size,
                                    id: entry.id,
                                    url: entry.url
                                }
                            });
                        }
                    });
                    
                    observer.observe({ entryTypes: ['largest-contentful-paint'] });
                } catch (err) {
                    this._warn('Failed to set up LCP observer', err);
                }
            }
            
            // Set up an observer for First Input Delay
            if (window.PerformanceObserver && PerformanceObserver.supportedEntryTypes && 
                PerformanceObserver.supportedEntryTypes.includes('first-input')) {
                
                try {
                    const observer = new PerformanceObserver(list => {
                        const entries = list.getEntries();
                        
                        if (entries.length > 0) {
                            const entry = entries[0];
                            
                            _performanceTimings.push({
                                type: 'first-input-delay',
                                timestamp: Date.now(),
                                url: window.location.href,
                                data: {
                                    startTime: entry.startTime,
                                    processingStart: entry.processingStart,
                                    processingEnd: entry.processingEnd,
                                    duration: entry.duration,
                                    name: entry.name
                                }
                            });
                        }
                    });
                    
                    observer.observe({ entryTypes: ['first-input'] });
                } catch (err) {
                    this._warn('Failed to set up FID observer', err);
                }
            }
            
            // Set up an observer for Layout Shifts
            if (window.PerformanceObserver && PerformanceObserver.supportedEntryTypes && 
                PerformanceObserver.supportedEntryTypes.includes('layout-shift')) {
                
                try {
                    let cumulativeLayoutShift = 0;
                    
                    const observer = new PerformanceObserver(list => {
                        for (const entry of list.getEntries()) {
                            // Only count layout shifts without recent user input
                            if (!entry.hadRecentInput) {
                                cumulativeLayoutShift += entry.value;
                            }
                        }
                        
                        _performanceTimings.push({
                            type: 'layout-shift',
                            timestamp: Date.now(),
                            url: window.location.href,
                            data: {
                                cumulativeLayoutShift
                            }
                        });
                    });
                    
                    observer.observe({ entryTypes: ['layout-shift'] });
                } catch (err) {
                    this._warn('Failed to set up CLS observer', err);
                }
            }
        }
        
        /**
         * Sets up the message channel for communication with the application
         * @private
         */
        _setupMessageChannel() {
            // Set up message passing
            window.addEventListener('message', this._handleMessage, false);
            
            // Register message handlers
            this._registerMessageHandlers();
            
            // Check if we're in an iframe
            const isIframe = window !== window.top;
            
            if (isIframe) {
                // We're in an iframe, so use postMessage to communicate with parent
                _connectionStatus = 'iframe';
                
                // Let parent know we're ready
                this._sendMessageToParent('iframeInjectorReady', {
                    sessionId: _sessionId,
                    url: window.location.href,
                    title: document.title
                });
            } else {
                // We're in the main window
                
                // Try to connect to the extension if available
                try {
                    if (window.chrome && window.chrome.runtime && window.chrome.runtime.connect) {
                        const port = window.chrome.runtime.connect({ name: 'cstestforge-injector' });
                        
                        port.onMessage.addListener(message => {
                            this._processIncomingMessage(message);
                        });
                        
                        port.onDisconnect.addListener(() => {
                            this._debug('Disconnected from extension');
                            _connectionStatus = 'disconnected';
                        });
                        
                        _connectionStatus = 'extension';
                        
                        // Let the extension know we're ready
                        port.postMessage({
                            type: 'injectorReady',
                            payload: {
                                sessionId: _sessionId,
                                browserInfo: _browserInfo,
                                url: window.location.href,
                                title: document.title
                            }
                        });
                    }
                } catch (err) {
                    this._warn('Failed to connect to extension', err);
                }
                
                // Fall back to direct messaging
                if (_connectionStatus === 'disconnected') {
                    _connectionStatus = 'direct';
                    
                    // Let application know we're ready via a custom event
                    const readyEvent = new CustomEvent('cstestforge-injector-ready', {
                        detail: {
                            sessionId: _sessionId,
                            browserInfo: _browserInfo,
                            url: window.location.href,
                            title: document.title
                        }
                    });
                    
                    window.dispatchEvent(readyEvent);
                }
            }
        }
        
        /**
         * Registers message handlers
         * @private
         */
        _registerMessageHandlers() {
            // Register handlers for different message types
            _messageHandlers.set('ping', payload => {
                this._sendMessage('pong', {
                    timestamp: Date.now(),
                    echoing: payload
                });
            });
            
            _messageHandlers.set('startRecording', payload => {
                this.start(payload);
            });
            
            _messageHandlers.set('stopRecording', () => {
                this.stop();
            });
            
            _messageHandlers.set('pauseRecording', () => {
                this.pause();
            });
            
            _messageHandlers.set('resumeRecording', () => {
                this.resume();
            });
            
            _messageHandlers.set('updateConfig', payload => {
                this.updateConfig(payload.config);
            });
            
            _messageHandlers.set('highlight', payload => {
                let targetElement;
                
                if (payload.selector) {
                    targetElement = document.querySelector(payload.selector);
                } else if (payload.xpath) {
                    targetElement = this._getElementByXPath(payload.xpath);
                } else if (payload.elementId) {
                    targetElement = this._getRegisteredElement(payload.elementId);
                }
                
                if (targetElement) {
                    return this.highlightElement(targetElement, payload.options);
                } else {
                    return null;
                }
            });
            
            _messageHandlers.set('clearHighlights', () => {
                this.clearHighlights();
            });
            
            _messageHandlers.set('getElementInfo', payload => {
                let targetElement;
                
                if (payload.selector) {
                    targetElement = document.querySelector(payload.selector);
                } else if (payload.xpath) {
                    targetElement = this._getElementByXPath(payload.xpath);
                } else if (payload.elementId) {
                    targetElement = this._getRegisteredElement(payload.elementId);
                }
                
                if (targetElement) {
                    return this._getElementInfo(targetElement);
                } else {
                    return null;
                }
            });
            
            _messageHandlers.set('executeScript', payload => {
                try {
                    // Use Function constructor to create a function from the script
                    // This is safer than eval and provides proper scope
                    const scriptFn = new Function(payload.script);
                    const result = scriptFn();
                    
                    return {
                        success: true,
                        result
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            });
            
            _messageHandlers.set('reset', () => {
                this.reset();
            });
        }
        
        /**
         * Handles incoming messages
         * @param {MessageEvent} event - The message event
         * @private
         */
        _handleMessage(event) {
            // Verify message format
            if (!event.data || !event.data.cstestforge || !event.data.type) {
                return;
            }
            
            this._processIncomingMessage(event.data);
        }
        
        /**
         * Processes an incoming message
         * @param {Object} message - The message to process
         * @private
         */
        _processIncomingMessage(message) {
            const { type, payload } = message;
            
            // Look up handler for this message type
            const handler = _messageHandlers.get(type);
            
            if (handler) {
                try {
                    // Call the handler
                    const result = handler(payload);
                    
                    // Send response if a result was returned
                    if (result !== undefined) {
                        this._sendMessage(type + 'Response', {
                            requestId: payload.requestId,
                            result
                        });
                    }
                } catch (error) {
                    // Send error response
                    this._sendMessage(type + 'Error', {
                        requestId: payload.requestId,
                        error: error.message
                    });
                    
                    this._error(`Error handling message of type ${type}`, error);
                }
            } else {
                this._warn(`No handler for message type: ${type}`);
            }
        }
        
        /**
         * Sends a message to the application
         * @param {string} type - Message type
         * @param {Object} payload - Message payload
         * @private
         */
        _sendMessage(type, payload) {
            const message = {
                cstestforge: true,
                type,
                payload,
                timestamp: Date.now(),
                sessionId: _sessionId
            };
            
            // Send message based on connection type
            switch (_connectionStatus) {
                case 'iframe':
                    this._sendMessageToParent(type, payload);
                    break;
                    
                case 'extension':
                    if (window.chrome && window.chrome.runtime) {
                        try {
                            window.chrome.runtime.sendMessage(message);
                        } catch (err) {
                            this._warn('Failed to send message to extension', err);
                            
                            // Fall back to custom event
                            this._dispatchCustomEvent(type, payload);
                        }
                    }
                    break;
                    
                case 'direct':
                    // Dispatch a custom event
                    this._dispatchCustomEvent(type, payload);
                    break;
                    
                default:
                    this._warn('No connection available for sending message');
            }
        }
        
        /**
         * Sends a message to the parent window
         * @param {string} type - Message type
         * @param {Object} payload - Message payload
         * @private
         */
        _sendMessageToParent(type, payload) {
            if (window.parent && window.parent !== window) {
                const message = {
                    cstestforge: true,
                    type,
                    payload,
                    timestamp: Date.now(),
                    sessionId: _sessionId
                };
                
                window.parent.postMessage(message, '*');
            }
        }
        
        /**
         * Dispatches a custom event
         * @param {string} type - Event type
         * @param {Object} payload - Event payload
         * @private
         */
        _dispatchCustomEvent(type, payload) {
            const event = new CustomEvent('cstestforge-' + type, {
                detail: {
                    type,
                    payload,
                    timestamp: Date.now(),
                    sessionId: _sessionId
                }
            });
            
            window.dispatchEvent(event);
        }
        
        /**
         * Handles messages from iframes
         * @param {MessageEvent} event - The iframe message event
         * @private
         */
        _handleIframeMessage(event) {
            // Verify that the message is from a known iframe
            const iframe = Array.from(document.querySelectorAll('iframe')).find(iframe => {
                try {
                    return iframe.contentWindow === event.source;
                } catch (err) {
                    // Same-origin policy might prevent access
                    return false;
                }
            });
            
            if (!iframe) return;
            
            // Verify that it's a CSTestForge message
            const data = event.data;
            if (!data || !data.cstestforge) return;
            
            // Process the message
            switch (data.type) {
                case 'iframeInjectorReady':
                    // Register the iframe
                    const iframeId = data.payload.sessionId;
                    _iframeRegistry.set(iframeId, {
                        element: iframe,
                        contentWindow: iframe.contentWindow,
                        url: data.payload.url,
                        title: data.payload.title
                    });
                    
                    this._debug('Injector ready in iframe', iframeId);
                    
                    // If recording is active, tell the iframe to start recording
                    if (_isRecording && !_paused) {
                        iframe.contentWindow.postMessage({
                            cstestforge: true,
                            type: 'startRecording',
                            payload: {
                                recordingId: _recordingId
                            }
                        }, '*');
                    }
                    break;
                    
                case 'event':
                case 'events':
                    // Forward events from iframe to the application
                    if (_isRecording && !_paused) {
                        // Add iframe info to each event
                        const iframeInfo = this._getElementInfo(iframe);
                        
                        if (data.type === 'event') {
                            data.payload.iframeInfo = iframeInfo;
                            _pendingEvents.push(data.payload);
                            _eventCount++;
                        } else if (data.type === 'events' && data.payload.events) {
                            for (const event of data.payload.events) {
                                event.iframeInfo = iframeInfo;
                                _pendingEvents.push(event);
                                _eventCount++;
                            }
                        }
                        
                        // Process if batch size limit reached
                        if (_pendingEvents.length >= _config.maxEventBatchSize) {
                            this._processPendingEvents();
                        }
                    }
                    break;
            }
        }
        
        /**
         * Injects CSS styles for the injector
         * @private
         */
        _injectCSS() {
            // Remove any existing style element
            if (_styleEl && _styleEl.parentNode) {
                _styleEl.parentNode.removeChild(_styleEl);
            }
            
            // Create a new style element
            _styleEl = document.createElement('style');
            _styleEl.id = `${CSTESTFORGE_PREFIX}styles`;
            _styleEl.type = 'text/css';
            
            // Add highlight styles
            const css = `
                @keyframes ${CSTESTFORGE_PREFIX}pulse {
                    0% { opacity: 0.6; }
                    50% { opacity: 1; }
                    100% { opacity: 0.6; }
                }
                
                .${CSTESTFORGE_PREFIX}highlight {
                    position: absolute;
                    box-sizing: border-box;
                    pointer-events: none;
                    z-index: 2147483647;
                    border: 2px solid ${_config.highlightColor};
                    background-color: rgba(0, 0, 0, 0);
                }
                
                .${CSTESTFORGE_PREFIX}highlight-info {
                    position: absolute;
                    bottom: 100%;
                    left: 0;
                    background-color: ${_config.highlightColor};
                    color: #fff;
                    padding: 4px 8px;
                    font-size: 12px;
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                    white-space: nowrap;
                    font-family: sans-serif;
                }
                
                .${CSTESTFORGE_PREFIX}recording-indicator {
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    width: 15px;
                    height: 15px;
                    border-radius: 50%;
                    background-color: #f00;
                    z-index: 2147483647;
                    animation: ${CSTESTFORGE_PREFIX}pulse 1s infinite;
                }
                
                .${CSTESTFORGE_PREFIX}paused-indicator {
                    background-color: #f80;
                }
            `;
            
            // Add the CSS to the style element
            if (_styleEl.styleSheet) {
                // IE
                _styleEl.styleSheet.cssText = css;
            } else {
                // Other browsers
                _styleEl.textContent = css;
            }
            
            // Add the style element to the page
            document.head.appendChild(_styleEl);
        }
        
        /**
         * Scans for iframes and injects the script into them
         * @private
         */
        _scanIframes() {
            const iframes = document.querySelectorAll('iframe');
            
            for (const iframe of iframes) {
                this._injectIntoIframe(iframe);
            }
        }
        
        /**
         * Injects the script into an iframe
         * @param {HTMLIFrameElement} iframe - The iframe to inject into
         * @private
         */
        _injectIntoIframe(iframe) {
            // Skip if already registered
            for (const entry of _iframeRegistry.values()) {
                if (entry.element === iframe) {
                    return;
                }
            }
            
            // Check if we can access the iframe (same-origin policy)
            try {
                // Accessing iframe.contentWindow.document will throw if cross-origin
                const iframeDoc = iframe.contentWindow.document;
                
                // Skip if the iframe is empty or not fully loaded
                if (!iframeDoc || !iframeDoc.documentElement) {
                    return;
                }
                
                // Check if already injected
                if (iframeDoc.getElementById(`${CSTESTFORGE_PREFIX}script`)) {
                    return;
                }
                
                // Create a script element
                const script = iframeDoc.createElement('script');
                script.id = `${CSTESTFORGE_PREFIX}script`;
                script.text = `(${CSTestForgeInjector.toString()})(${JSON.stringify(_config)});`;
                
                // Append to iframe document
                iframeDoc.head.appendChild(script);
                
                this._debug('Injected into iframe', iframe.src || 'about:blank');
            } catch (err) {
                // Cross-origin iframe, can't inject
                this._debug('Cannot inject into cross-origin iframe', iframe.src);
            }
        }
        
        /**
         * Gets element information
         * @param {Element} element - The element to get info for
         * @returns {Object} Element information
         * @private
         */
        _getElementInfo(element) {
            if (!element || !element.tagName) {
                return null;
            }
            
            // Get element ID from registry or create a new one
            const elementId = this._getUniqueElementId(element);
            
            // Basic element info
            const elementInfo = {
                elementId,
                tagName: element.tagName.toLowerCase(),
                id: element.id,
                name: element.name,
                className: element.className,
                type: element.type,
                value: this._getElementValue(element),
                text: this._getElementText(element),
                attributes: this._getElementAttributes(element),
                xpath: this._generateXPath(element),
                cssSelector: this._generateCssSelector(element),
                rect: this._getElementRect(element)
            };
            
            return elementInfo;
        }
        
        /**
         * Gets a unique ID for an element
         * @param {Element} element - The element
         * @returns {string} Unique element ID
         * @private
         */
        _getUniqueElementId(element) {
            // Check if element already has an ID in the registry
            for (const [id, el] of _elementRegistry.entries()) {
                if (el === element) {
                    return id;
                }
            }
            
            // Generate a new ID
            const elementId = `element-${this._generateUUID()}`;
            
            // Add to registry
            _elementRegistry.set(elementId, element);
            
            return elementId;
        }
        
        /**
         * Gets an element by its registered ID
         * @param {string} elementId - The element ID
         * @returns {Element} The element
         * @private
         */
        _getRegisteredElement(elementId) {
            return _elementRegistry.get(elementId);
        }
        
        /**
         * Gets element text content
         * @param {Element} element - The element
         * @returns {string} Element text content
         * @private
         */
        _getElementText(element) {
            if (!element) return '';
            
            // For input elements, get the value
            if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                return element.value;
            }
            
            // For select elements, get the selected option text
            if (element.tagName === 'SELECT') {
                return element.options[element.selectedIndex]?.text || '';
            }
            
            // For other elements, get text content
            return element.textContent?.trim() || '';
        }
        
        /**
         * Gets element attributes
         * @param {Element} element - The element
         * @returns {Object} Element attributes
         * @private
         */
        _getElementAttributes(element) {
            if (!element || !element.attributes) {
                return {};
            }
            
            const attributes = {};
            
            // Convert NamedNodeMap to a regular object
            for (let i = 0; i < element.attributes.length; i++) {
                const attr = element.attributes[i];
                attributes[attr.name] = attr.value;
            }
            
            return attributes;
        }
        
        /**
         * Gets element bounding rectangle
         * @param {Element} element - The element
         * @returns {Object} Element rectangle
         * @private
         */
        _getElementRect(element) {
            if (!element) return null;
            
            const rect = element.getBoundingClientRect();
            const scrollX = window.scrollX || window.pageXOffset;
            const scrollY = window.scrollY || window.pageYOffset;
            
            return {
                top: rect.top + scrollY,
                left: rect.left + scrollX,
                width: rect.width,
                height: rect.height,
                bottom: rect.bottom + scrollY,
                right: rect.right + scrollX
            };
        }
        
        /**
         * Generates an XPath for an element
         * @param {Element} element - The element
         * @returns {string} XPath
         * @private
         */
        _generateXPath(element) {
            if (!element) return '';
            
            // Check if element has an ID
            if (element.id) {
                return `//*[@id="${element.id}"]`;
            }
            
            // Generate a path relative to the document
            let paths = [];
            let currentElement = element;
            
            while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {
                let index = 0;
                let siblingFound = false;
                
                // Count siblings with same tag
                for (let sibling = currentElement.previousSibling; sibling; sibling = sibling.previousSibling) {
                    if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === currentElement.tagName) {
                        index++;
                        siblingFound = true;
                    }
                }
                
                // Determine the index part of the path
                let pathIndex = '';
                if (siblingFound || index > 0) {
                    pathIndex = `[${index + 1}]`;
                }
                
                // Create the path segment
                const tagName = currentElement.tagName.toLowerCase();
                const path = `/${tagName}${pathIndex}`;
                
                // Add to paths
                paths.unshift(path);
                
                // Move to parent
                currentElement = currentElement.parentNode;
                
                // Stop at document
                if (currentElement === document) {
                    break;
                }
            }
            
            return paths.join('') || '/';
        }
        
        /**
         * Gets an element by XPath
         * @param {string} xpath - The XPath
         * @returns {Element} The element
         * @private
         */
        _getElementByXPath(xpath) {
            try {
                return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
            } catch (err) {
                this._warn('Invalid XPath', xpath, err);
                return null;
            }
        }
        
        /**
         * Generates a CSS selector for an element
         * @param {Element} element - The element
         * @returns {string} CSS selector
         * @private
         */
        _generateCssSelector(element) {
            if (!element) return '';
            
            // Check if element has an ID
            if (element.id) {
                return `#${element.id}`;
            }
            
            // Check for element with a unique class
            if (element.className && typeof element.className === 'string') {
                const classes = element.className.trim().split(/\s+/);
                
                for (const className of classes) {
                    if (className && document.querySelectorAll(`.${className}`).length === 1) {
                        return `.${className}`;
                    }
                }
            }
            
            // Generate a path of elements with classes or attributes
            let path = [];
            let currentElement = element;
            
            while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {
                let selector = currentElement.tagName.toLowerCase();
                
                // Add ID if present
                if (currentElement.id) {
                    selector = `${selector}#${currentElement.id}`;
                    path.unshift(selector);
                    break;
                }
                
                // Add classes if present
                if (currentElement.className && typeof currentElement.className === 'string') {
                    const classes = currentElement.className.trim().split(/\s+/).filter(Boolean);
                    
                    if (classes.length) {
                        selector += `.${classes.join('.')}`;
                    }
                }
                
                // Add a useful attribute if present
                const attributes = ['name', 'type', 'role', 'data-test-id', 'data-testid', 'data-cy', 'data-e2e'];
                
                for (const attr of attributes) {
                    if (currentElement.hasAttribute(attr)) {
                        selector += `[${attr}="${currentElement.getAttribute(attr)}"]`;
                        break;
                    }
                }
                
                // Add position if needed
                const siblings = Array.from(currentElement.parentNode?.children || [])
                    .filter(el => el.tagName === currentElement.tagName);
                
                if (siblings.length > 1) {
                    const index = siblings.indexOf(currentElement) + 1;
                    selector += `:nth-child(${index})`;
                }
                
                // Add to path
                path.unshift(selector);
                
                // Move to parent
                currentElement = currentElement.parentNode;
                
                // Stop at body
                if (currentElement === document.body) {
                    path.unshift('body');
                    break;
                }
            }
            
            return path.join(' > ');
        }
        
        /**
         * Detects the browser
         * @private
         */
        _detectBrowser() {
            const userAgent = window.navigator.userAgent;
            let browserName = 'Unknown';
            let browserVersion = 'Unknown';
            
            // Chrome
            const chromeMatch = userAgent.match(/Chrome\/(\d+\.\d+)/);
            if (chromeMatch) {
                browserName = 'Chrome';
                browserVersion = chromeMatch[1];
                
                // Edge (Chromium-based)
                if (userAgent.indexOf('Edg/') !== -1) {
                    const edgeMatch = userAgent.match(/Edg\/(\d+\.\d+)/);
                    if (edgeMatch) {
                        browserName = 'Edge';
                        browserVersion = edgeMatch[1];
                    }
                }
                
                // Opera
                if (userAgent.indexOf('OPR/') !== -1) {
                    const operaMatch = userAgent.match(/OPR\/(\d+\.\d+)/);
                    if (operaMatch) {
                        browserName = 'Opera';
                        browserVersion = operaMatch[1];
                    }
                }
            }
            
            // Firefox
            const firefoxMatch = userAgent.match(/Firefox\/(\d+\.\d+)/);
            if (firefoxMatch) {
                browserName = 'Firefox';
                browserVersion = firefoxMatch[1];
            }
            
            // Safari
            const safariMatch = userAgent.match(/Version\/(\d+\.\d+).*Safari/);
            if (safariMatch && userAgent.indexOf('Chrome') === -1) {
                browserName = 'Safari';
                browserVersion = safariMatch[1];
            }
            
            // Internet Explorer
            if (userAgent.indexOf('Trident/') !== -1) {
                browserName = 'Internet Explorer';
                const ieMatch = userAgent.match(/rv:(\d+\.\d+)/);
                if (ieMatch) {
                    browserVersion = ieMatch[1];
                }
            }
            
            _browserInfo = {
                name: browserName,
                version: browserVersion,
                userAgent,
                platform: window.navigator.platform,
                language: window.navigator.language,
                cookies: window.navigator.cookieEnabled,
                screenWidth: window.screen.width,
                screenHeight: window.screen.height,
                viewportWidth: window.innerWidth,
                viewportHeight: window.innerHeight,
                pixelRatio: window.devicePixelRatio || 1
            };
        }
        
        /**
         * Detects browser features
         * @private
         */
        _detectFeatures() {
            _featureDetectionResults = {
                localStorage: this._testFeature(() => window.localStorage !== undefined),
                sessionStorage: this._testFeature(() => window.sessionStorage !== undefined),
                cookies: window.navigator.cookieEnabled,
                webSockets: this._testFeature(() => window.WebSocket !== undefined),
                webWorkers: this._testFeature(() => window.Worker !== undefined),
                indexedDB: this._testFeature(() => window.indexedDB !== undefined),
                serviceWorkers: this._testFeature(() => navigator.serviceWorker !== undefined),
                fetch: this._testFeature(() => window.fetch !== undefined),
                promise: this._testFeature(() => window.Promise !== undefined),
                geolocation: this._testFeature(() => navigator.geolocation !== undefined),
                webRTC: this._testFeature(() => window.RTCPeerConnection !== undefined),
                webGL: this._testFeature(() => {
                    const canvas = document.createElement('canvas');
                    return !!canvas.getContext('webgl') || !!canvas.getContext('experimental-webgl');
                }),
                canvas: this._testFeature(() => {
                    const canvas = document.createElement('canvas');
                    return !!canvas.getContext('2d');
                }),
                svg: this._testFeature(() => document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')),
                webAudio: this._testFeature(() => window.AudioContext !== undefined || window.webkitAudioContext !== undefined),
                touchEvents: this._testFeature(() => 'ontouchstart' in window || navigator.maxTouchPoints > 0),
                customElements: this._testFeature(() => window.customElements !== undefined),
                shadowDOM: this._testFeature(() => document.head.attachShadow !== undefined),
                notifications: this._testFeature(() => window.Notification !== undefined),
                mediaDevices: this._testFeature(() => navigator.mediaDevices !== undefined && navigator.mediaDevices.getUserMedia !== undefined),
                performanceAPI: this._testFeature(() => window.performance !== undefined),
                mutationObserver: this._testFeature(() => window.MutationObserver !== undefined),
                intersectionObserver: this._testFeature(() => window.IntersectionObserver !== undefined),
                resizeObserver: this._testFeature(() => window.ResizeObserver !== undefined),
                performanceObserver: this._testFeature(() => window.PerformanceObserver !== undefined),
                requestAnimationFrame: this._testFeature(() => window.requestAnimationFrame !== undefined),
                deviceOrientation: this._testFeature(() => window.DeviceOrientationEvent !== undefined),
                speechRecognition: this._testFeature(() => window.SpeechRecognition !== undefined || window.webkitSpeechRecognition !== undefined),
                clipboardAPI: this._testFeature(() => navigator.clipboard !== undefined),
                batteryAPI: this._testFeature(() => navigator.getBattery !== undefined),
                paymentRequest: this._testFeature(() => window.PaymentRequest !== undefined),
                webShare: this._testFeature(() => navigator.share !== undefined),
                webVR: this._testFeature(() => navigator.getVRDisplays !== undefined),
                webXR: this._testFeature(() => navigator.xr !== undefined),
                credentials: this._testFeature(() => navigator.credentials !== undefined)
            };
        }
        
        /**
         * Tests a feature
         * @param {Function} testFn - Function that tests the feature
         * @returns {boolean} Whether the feature is supported
         * @private
         */
        _testFeature(testFn) {
            try {
                return testFn();
            } catch (err) {
                return false;
            }
        }
        
        /**
         * Generates a UUID
         * @returns {string} UUID
         * @private
         */
        _generateUUID() {
            let d = new Date().getTime();
            
            if (window.performance && typeof window.performance.now === 'function') {
                d += window.performance.now();
            }
            
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = (d + Math.random() * 16) % 16 | 0;
                d = Math.floor(d / 16);
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
        
        /**
         * Logs a message
         * @param {...*} args - Log arguments
         * @private
         */
        _log(...args) {
            if (window.console && window.console.log) {
                window.console.log('[CSTestForge]', ...args);
            }
        }
        
        /**
         * Logs an error
         * @param {...*} args - Error arguments
         * @private
         */
        _error(...args) {
            if (window.console && window.console.error) {
                window.console.error('[CSTestForge]', ...args);
            }
        }
        
        /**
         * Logs a warning
         * @param {...*} args - Warning arguments
         * @private
         */
        _warn(...args) {
            if (window.console && window.console.warn) {
                window.console.warn('[CSTestForge]', ...args);
            }
        }
        
        /**
         * Logs debug information
         * @param {...*} args - Debug arguments
         * @private
         */
        _debug(...args) {
            if (_config.debugMode && window.console && window.console.debug) {
                window.console.debug('[CSTestForge]', ...args);
            }
        }
    }
    
    // Create the global injector instance
    window[`${CSTESTFORGE_PREFIX}injector`] = new CSTestForgeInjector(_config);
})();



