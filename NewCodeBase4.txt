package com.cstestforge.framework.playwright.java.base;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.annotations.CSFindBy;
import com.cstestforge.framework.playwright.java.annotations.CSPage;
import com.cstestforge.framework.playwright.java.element.CSElement;
import com.cstestforge.framework.playwright.java.element.CSElementList;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.WaitForSelectorState;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.ParameterizedType;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Factory class for initializing page objects with Playwright
 * This is a comprehensive implementation that manages the creation of page objects
 * and initialization of their elements using reflection and annotations.
 */
public class CSPageFactory {
    private static final CSLogger logger = CSLogger.getLogger(CSPageFactory.class);
    private static final ConcurrentHashMap<Class<?>, Constructor<?>> constructorCache = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<Field, CSFindBy> fieldAnnotationCache = new ConcurrentHashMap<>();

    /**
     * Initializes a page object using the given Playwright Page instance.
     * Processes all CSFindBy annotations and initializes elements.
     *
     * @param page      Playwright Page instance
     * @param pageClass The class of the page object to initialize
     * @param <T>       The type of the page object
     * @return Initialized page object instance
     */
    public static <T> T initElements(Page page, Class<T> pageClass) {
        T page0;
        try {
            Constructor<T> constructor = findConstructor(pageClass);
            page0 = constructor.newInstance(page);
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException("Failed to create instance of " + pageClass.getName(), e);
        }

        initElements(page, page0);
        navigateIfURLSpecified(page, pageClass);
        return page0;
    }

    /**
     * Finds and caches the constructor for the given page class.
     * Prefers constructor with Page parameter, falls back to default constructor.
     *
     * @param pageClass The class to find the constructor for
     * @param <T>       The type of the page class
     * @return Constructor instance for the page class
     */
    @SuppressWarnings("unchecked")
    private static <T> Constructor<T> findConstructor(Class<T> pageClass) {
        Constructor<?> constructor = constructorCache.get(pageClass);
        if (constructor == null) {
            try {
                constructor = pageClass.getConstructor(Page.class);
            } catch (NoSuchMethodException e) {
                try {
                    constructor = pageClass.getDeclaredConstructor();
                    constructor.setAccessible(true);
                } catch (NoSuchMethodException e1) {
                    throw new RuntimeException(
                            "No suitable constructor found for page class " + pageClass.getName() +
                                    ". Ensure it has a constructor taking a Page parameter or a default constructor.", e1);
                }
            }
            constructorCache.put(pageClass, constructor);
        }
        return (Constructor<T>) constructor;
    }

    /**
     * Initializes fields in the page object that are annotated with CSFindBy.
     *
     * @param page      Playwright Page instance
     * @param pageObject The page object to initialize elements in
     */
    public static void initElements(Page page, Object pageObject) {
        Class<?> proxyIn = pageObject.getClass();
        while (proxyIn != Object.class) {
            for (Field field : proxyIn.getDeclaredFields()) {
                CSFindBy findByAnnotation = getAnnotation(field);
                if (findByAnnotation != null) {
                    try {
                        field.setAccessible(true);
                        Object elementInstance;
                        
                        // Handle CSElement vs CSElementList
                        if (field.getType().equals(CSElement.class)) {
                            elementInstance = createCSElement(page, findByAnnotation);
                        } else if (field.getType().equals(CSElementList.class)) {
                            elementInstance = createCSElementList(page, findByAnnotation);
                        } else if (List.class.isAssignableFrom(field.getType())) {
                            // Handle List<WebElement> case - check generic type
                            ParameterizedType listType = (ParameterizedType) field.getGenericType();
                            Class<?> listGenericType = (Class<?>) listType.getActualTypeArguments()[0];
                            
                            if (CSElement.class.isAssignableFrom(listGenericType)) {
                                elementInstance = createCSElementList(page, findByAnnotation);
                            } else {
                                logger.warn("Unsupported list generic type: " + listGenericType.getName() + 
                                          " for field: " + field.getName());
                                continue;
                            }
                        } else {
                            logger.warn("Unsupported field type: " + field.getType() + 
                                      " for field: " + field.getName());
                            continue;
                        }
                        
                        field.set(pageObject, elementInstance);
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Failed to initialize elements in " + pageObject.getClass().getName(), e);
                    }
                }
            }
            proxyIn = proxyIn.getSuperclass();
        }
    }

    /**
     * Gets the CSFindBy annotation for a field, with caching for performance.
     *
     * @param field The field to get the annotation for
     * @return CSFindBy annotation or null if not present
     */
    private static CSFindBy getAnnotation(Field field) {
        if (fieldAnnotationCache.containsKey(field)) {
            return fieldAnnotationCache.get(field);
        }
        
        CSFindBy annotation = field.getAnnotation(CSFindBy.class);
        if (annotation != null) {
            fieldAnnotationCache.put(field, annotation);
        }
        return annotation;
    }

    /**
     * Creates a CSElement instance based on the provided annotation.
     *
     * @param page       Playwright Page instance
     * @param annotation CSFindBy annotation
     * @return CSElement instance
     */
    private static CSElement createCSElement(Page page, CSFindBy annotation) {
        Locator locator = createLocator(page, annotation);
        
        // Create element with timeout settings from annotation
        CSElement element = new CSElement(locator, annotation.timeoutInSeconds());
        
        // Apply additional settings from annotation
        if (annotation.waitForVisible()) {
            element.setWaitForSelector(WaitForSelectorState.VISIBLE);
        } else if (annotation.waitForHidden()) {
            element.setWaitForSelector(WaitForSelectorState.HIDDEN);
        } else if (annotation.waitForAttached()) {
            element.setWaitForSelector(WaitForSelectorState.ATTACHED);
        } else if (annotation.waitForDetached()) {
            element.setWaitForSelector(WaitForSelectorState.DETACHED);
        }
        
        return element;
    }

    /**
     * Creates a CSElementList instance based on the provided annotation.
     *
     * @param page       Playwright Page instance
     * @param annotation CSFindBy annotation
     * @return CSElementList instance
     */
    private static CSElementList createCSElementList(Page page, CSFindBy annotation) {
        Locator locator = createLocator(page, annotation);
        return new CSElementList(locator, annotation.timeoutInSeconds());
    }

    /**
     * Creates a Playwright Locator based on the CSFindBy annotation.
     *
     * @param page       Playwright Page instance
     * @param annotation CSFindBy annotation
     * @return Playwright Locator
     */
    private static Locator createLocator(Page page, CSFindBy annotation) {
        // Try each locator strategy in a specific precedence order
        if (!annotation.id().isEmpty()) {
            return page.locator("#" + annotation.id());
        } else if (!annotation.css().isEmpty()) {
            return page.locator(annotation.css());
        } else if (!annotation.xpath().isEmpty()) {
            return page.locator(annotation.xpath());
        } else if (!annotation.text().isEmpty()) {
            return page.locator("text=" + annotation.text());
        } else if (!annotation.textExact().isEmpty()) {
            return page.locator("text=" + annotation.textExact(), 
                    new Page.LocatorOptions().setExact(true));
        } else if (!annotation.testId().isEmpty()) {
            return page.locator("data-testid=" + annotation.testId());
        } else if (!annotation.role().isEmpty()) {
            return page.getByRole(annotation.role(), 
                    new Page.GetByRoleOptions().setName(annotation.name()));
        } else if (!annotation.placeholder().isEmpty()) {
            return page.getByPlaceholder(annotation.placeholder());
        } else if (!annotation.label().isEmpty()) {
            return page.getByLabel(annotation.label());
        } else if (!annotation.altText().isEmpty()) {
            return page.getByAltText(annotation.altText());
        } else if (!annotation.title().isEmpty()) {
            return page.getByTitle(annotation.title());
        } else {
            throw new IllegalArgumentException("No valid locator strategy specified in @CSFindBy annotation");
        }
    }

    /**
     * Navigates to the URL specified in the CSPage annotation if present.
     *
     * @param page      Playwright Page instance
     * @param pageClass The class of the page object
     */
    private static void navigateIfURLSpecified(Page page, Class<?> pageClass) {
        CSPage pageAnnotation = pageClass.getAnnotation(CSPage.class);
        if (pageAnnotation != null && !pageAnnotation.url().isEmpty()) {
            logger.info("Navigating to URL defined in @CSPage: " + pageAnnotation.url());
            page.navigate(pageAnnotation.url());
        }
    }
}


CSLocatorProcessor.java
---------------------------

package com.cstestforge.framework.playwright.java.annotations;

import com.cstestforge.framework.core.ai.SelfHealingLocatorService;
import com.cstestforge.framework.core.ai.SmartLocatorService;
import com.cstestforge.framework.core.utils.CSLogger;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.AriaRole;

import java.util.HashMap;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Function;

/**
 * Processor for CSFindBy annotations to create Playwright Locators.
 * This class provides static methods to process annotation values and
 * create corresponding Playwright locators.
 */
public class CSLocatorProcessor {
    private static final CSLogger logger = CSLogger.getLogger(CSLocatorProcessor.class);
    private static final SelfHealingLocatorService selfHealingService = new SelfHealingLocatorService();
    private static final SmartLocatorService smartLocatorService = new SmartLocatorService();
    
    // Cache for processed locators to improve performance
    private static final Map<String, Locator> locatorCache = new HashMap<>();
    
    /**
     * Process a CSFindBy annotation and return a Playwright Locator.
     * This method selects the appropriate locator strategy based on the annotation.
     *
     * @param page       The Playwright Page instance
     * @param annotation The CSFindBy annotation
     * @return Playwright Locator created based on the annotation
     */
    public static Locator processLocator(Page page, CSFindBy annotation) {
        if (annotation == null) {
            throw new IllegalArgumentException("CSFindBy annotation cannot be null");
        }
        
        // Generate a cache key based on annotation values
        String cacheKey = generateCacheKey(page, annotation);
        
        // Check if locator is in cache
        if (locatorCache.containsKey(cacheKey)) {
            logger.debug("Using cached locator for " + cacheKey);
            return locatorCache.get(cacheKey);
        }
        
        // Process based on locator strategy
        Locator locator;
        try {
            locator = createLocatorFromAnnotation(page, annotation);
            
            // Apply smart locator enhancement if enabled
            if (annotation.smart()) {
                locator = enhanceWithSmartLocator(page, locator, annotation);
            }
            
            // Apply self-healing if enabled
            if (annotation.selfHealing()) {
                locator = registerForSelfHealing(locator, annotation);
            }
            
            // Cache the locator
            locatorCache.put(cacheKey, locator);
            return locator;
        } catch (Exception e) {
            logger.error("Failed to process locator from annotation", e);
            throw new RuntimeException("Failed to process locator from annotation", e);
        }
    }
    
    /**
     * Creates a unique cache key for the locator based on page instance and annotation values.
     *
     * @param page       The Playwright Page instance
     * @param annotation The CSFindBy annotation
     * @return A unique cache key
     */
    private static String generateCacheKey(Page page, CSFindBy annotation) {
        StringBuilder key = new StringBuilder();
        key.append(page.hashCode()).append(":");
        
        // Append all locator strategies from annotation
        appendIfNotEmpty(key, "id:", annotation.id());
        appendIfNotEmpty(key, "css:", annotation.css());
        appendIfNotEmpty(key, "xpath:", annotation.xpath());
        appendIfNotEmpty(key, "text:", annotation.text());
        appendIfNotEmpty(key, "textExact:", annotation.textExact());
        appendIfNotEmpty(key, "testId:", annotation.testId());
        appendIfNotEmpty(key, "role:", annotation.role());
        appendIfNotEmpty(key, "name:", annotation.name());
        appendIfNotEmpty(key, "placeholder:", annotation.placeholder());
        appendIfNotEmpty(key, "label:", annotation.label());
        appendIfNotEmpty(key, "altText:", annotation.altText());
        appendIfNotEmpty(key, "title:", annotation.title());
        
        return key.toString();
    }
    
    /**
     * Helper method to append non-empty values to the cache key.
     *
     * @param builder The StringBuilder to append to
     * @param prefix  The prefix for the value
     * @param value   The value to append
     */
    private static void appendIfNotEmpty(StringBuilder builder, String prefix, String value) {
        if (value != null && !value.isEmpty()) {
            builder.append(prefix).append(value).append("|");
        }
    }
    
    /**
     * Create a Playwright Locator based on the annotation values.
     *
     * @param page       The Playwright Page instance
     * @param annotation The CSFindBy annotation
     * @return The created Locator
     */
    private static Locator createLocatorFromAnnotation(Page page, CSFindBy annotation) {
        // Try each locator strategy in precedence order
        if (!annotation.id().isEmpty()) {
            return page.locator("#" + annotation.id());
        } else if (!annotation.css().isEmpty()) {
            return page.locator(annotation.css());
        } else if (!annotation.xpath().isEmpty()) {
            return page.locator(annotation.xpath());
        } else if (!annotation.text().isEmpty()) {
            return page.locator("text=" + annotation.text());
        } else if (!annotation.textExact().isEmpty()) {
            return page.locator("text=" + annotation.textExact(), 
                    new Page.LocatorOptions().setExact(true));
        } else if (!annotation.testId().isEmpty()) {
            return page.locator("data-testid=" + annotation.testId());
        } else if (!annotation.role().isEmpty()) {
            try {
                AriaRole role = AriaRole.valueOf(annotation.role().toUpperCase());
                return page.getByRole(role, 
                        new Page.GetByRoleOptions().setName(annotation.name()));
            } catch (IllegalArgumentException e) {
                logger.error("Invalid role value: " + annotation.role(), e);
                throw new IllegalArgumentException("Invalid role value: " + annotation.role(), e);
            }
        } else if (!annotation.placeholder().isEmpty()) {
            return page.getByPlaceholder(annotation.placeholder());
        } else if (!annotation.label().isEmpty()) {
            return page.getByLabel(annotation.label());
        } else if (!annotation.altText().isEmpty()) {
            return page.getByAltText(annotation.altText());
        } else if (!annotation.title().isEmpty()) {
            return page.getByTitle(annotation.title());
        } else if (annotation.smart()) {
            // If no explicit selector but smart is enabled, use AI to generate locator
            return generateSmartLocator(page, annotation);
        } else {
            throw new IllegalArgumentException("No valid locator strategy specified in @CSFindBy annotation");
        }
    }
    
    /**
     * Enhance the locator with AI-powered smart locator generation.
     *
     * @param page       The Playwright Page instance
     * @param locator    The original locator
     * @param annotation The CSFindBy annotation
     * @return Enhanced locator
     */
    private static Locator enhanceWithSmartLocator(Page page, Locator locator, CSFindBy annotation) {
        try {
            // Extract element information to provide context for smart locator
            Map<String, String> elementInfo = new HashMap<>();
            elementInfo.put("description", annotation.description());
            elementInfo.put("contextName", annotation.contextName());
            
            // Use the SmartLocatorService to enhance the locator
            return smartLocatorService.enhanceLocator(page, locator, elementInfo);
        } catch (Exception e) {
            logger.warn("Failed to enhance locator with smart locator service", e);
            return locator; // Fall back to original locator
        }
    }
    
    /**
     * Generate a smart locator using AI when no explicit locator is provided.
     *
     * @param page       The Playwright Page instance
     * @param annotation The CSFindBy annotation
     * @return AI-generated locator
     */
    private static Locator generateSmartLocator(Page page, CSFindBy annotation) {
        try {
            // Collect context information for AI locator generation
            Map<String, String> contextInfo = new HashMap<>();
            contextInfo.put("description", annotation.description());
            contextInfo.put("contextName", annotation.contextName());
            
            // Generate smart locator
            return smartLocatorService.generateLocator(page, contextInfo);
        } catch (Exception e) {
            logger.error("Failed to generate smart locator", e);
            throw new RuntimeException("Failed to generate smart locator. Please provide an explicit locator strategy.", e);
        }
    }
    
    /**
     * Register a locator for self-healing capabilities.
     *
     * @param locator    The original locator
     * @param annotation The CSFindBy annotation
     * @return Self-healing enabled locator
     */
    private static Locator registerForSelfHealing(Locator locator, CSFindBy annotation) {
        try {
            // Extract fingerprint information for self-healing
            Map<String, String> fingerprintInfo = new HashMap<>();
            fingerprintInfo.put("description", annotation.description());
            fingerprintInfo.put("contextName", annotation.contextName());
            
            // Register with self-healing service
            return selfHealingService.registerLocator(locator, fingerprintInfo);
        } catch (Exception e) {
            logger.warn("Failed to register locator for self-healing", e);
            return locator; // Fall back to original locator
        }
    }
    
    /**
     * Clear the locator cache when necessary (e.g., when navigating to a new page).
     */
    public static void clearCache() {
        logger.debug("Clearing locator cache");
        locatorCache.clear();
    }
    
    /**
     * Clear specific entries from the cache based on the page instance.
     *
     * @param page The Playwright Page instance
     */
    public static void clearCache(Page page) {
        if (page == null) {
            return;
        }
        
        int pageHash = page.hashCode();
        locatorCache.entrySet().removeIf(entry -> entry.getKey().startsWith(pageHash + ":"));
    }
}


CSPage.java
-------------------

package com.cstestforge.framework.playwright.java.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for Page Object classes in the CSTestForge framework.
 * Provides metadata about the page for enhanced functionality.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CSPage {
    /**
     * The name of the page, used for logging and reporting
     */
    String value() default "";
    
    /**
     * The URL of the page, used for automatic navigation
     */
    String url() default "";
    
    /**
     * The title of the page, used for verification
     */
    String title() default "";
    
    /**
     * The timeout for page load in seconds
     */
    int loadTimeoutInSeconds() default 30;
    
    /**
     * Whether to automatically verify the page is loaded
     */
    boolean verifyLoaded() default true;
    
    /**
     * CSS selector to verify page is loaded
     */
    String verifySelector() default "";
    
    /**
     * Expected text to verify page is loaded
     */
    String verifyText() default "";
    
    /**
     * Whether to automatically navigate to the page URL on initialization
     */
    boolean autoNavigate() default false;
    
    /**
     * Whether to wait for network idle on page load
     */
    boolean waitForNetworkIdle() default true;
    
    /**
     * Whether to wait for DOM content loaded on page load
     */
    boolean waitForDomContentLoaded() default true;
    
    /**
     * Whether to wait for page load event on navigation
     */
    boolean waitForLoadEvent() default true;
    
    /**
     * Path where screenshots of this page will be saved (relative to base screenshot directory)
     */
    String screenshotPath() default "";
    
    /**
     * Localization key prefix for this page
     */
    String localizationPrefix() default "";
    
    /**
     * Tags for organizing and filtering pages
     */
    String[] tags() default {};
    
    /**
     * Description of the page for documentation
     */
    String description() default "";
    
    /**
     * Whether this page is part of a component library
     */
    boolean isComponent() default false;
    
    /**
     * Names of required page sections or components
     */
    String[] sections() default {};
    
    /**
     * Whether to use self-healing locators on this page
     */
    boolean useSelfHealing() default true;
    
    /**
     * Whether to use smart locators on this page
     */
    boolean useSmartLocators() default true;
    
    /**
     * Whether to capture performance metrics for this page
     */
    boolean capturePerformanceMetrics() default false;
    
    /**
     * Whether to capture network requests for this page
     */
    boolean captureNetworkRequests() default false;
    
    /**
     * Whether to capture console logs for this page
     */
    boolean captureConsoleLogs() default false;
    
    /**
     * Whether this page requires authentication
     */
    boolean requiresAuthentication() default false;
    
    /**
     * Authentication profile to use, if applicable
     */
    String authProfile() default "";
    
    /**
     * Base URL override for this page
     */
    String baseUrl() default "";
    
    /**
     * Timeout for AJAX requests in seconds
     */
    int ajaxTimeoutInSeconds() default 30;
    
    /**
     * Custom initialization script to run when page is loaded
     */
    String initScript() default "";
    
    /**
     * Whether to store this page in page context for reuse
     */
    boolean cacheInContext() default true;
    
    /**
     * Resource types to wait for during page load
     */
    String[] waitForResources() default {};
}


CSWaitStrategy.java
----------------------------

package com.cstestforge.framework.playwright.java.wait;

import com.cstestforge.framework.playwright.java.element.CSElement;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;

import java.util.List;
import java.util.function.Supplier;

/**
 * Interface defining wait strategies for Playwright elements.
 * Provides methods for waiting for various conditions on elements and pages.
 */
public interface CSWaitStrategy {
    
    /**
     * Wait for a condition on an element with default timeout.
     *
     * @param element The element to wait for
     * @return The element after waiting
     */
    CSElement waitFor(CSElement element);
    
    /**
     * Wait for a condition on an element with specified timeout.
     *
     * @param element          The element to wait for
     * @param timeoutInSeconds The timeout in seconds
     * @return The element after waiting
     */
    CSElement waitFor(CSElement element, int timeoutInSeconds);
    
    /**
     * Wait for a condition on a Playwright Locator with default timeout.
     *
     * @param locator The locator to wait for
     * @return The locator after waiting
     */
    Locator waitFor(Locator locator);
    
    /**
     * Wait for a condition on a Playwright Locator with specified timeout.
     *
     * @param locator          The locator to wait for
     * @param timeoutInSeconds The timeout in seconds
     * @return The locator after waiting
     */
    Locator waitFor(Locator locator, int timeoutInSeconds);
    
    /**
     * Wait for a condition on a list of elements with default timeout.
     *
     * @param elements The list of elements to wait for
     * @return The list of elements after waiting
     */
    List<CSElement> waitFor(List<CSElement> elements);
    
    /**
     * Wait for a condition on a list of elements with specified timeout.
     *
     * @param elements         The list of elements to wait for
     * @param timeoutInSeconds The timeout in seconds
     * @return The list of elements after waiting
     */
    List<CSElement> waitFor(List<CSElement> elements, int timeoutInSeconds);
    
    /**
     * Wait for a specified duration.
     *
     * @param durationInSeconds The duration to wait in seconds
     */
    void waitForDuration(double durationInSeconds);
    
    /**
     * Wait until a condition is true with default timeout.
     *
     * @param condition The condition to wait for
     * @return True if the condition was met before timeout, false otherwise
     */
    boolean waitUntil(Supplier<Boolean> condition);
    
    /**
     * Wait until a condition is true with specified timeout.
     *
     * @param condition        The condition to wait for
     * @param timeoutInSeconds The timeout in seconds
     * @return True if the condition was met before timeout, false otherwise
     */
    boolean waitUntil(Supplier<Boolean> condition, int timeoutInSeconds);
    
    /**
     * Wait until a condition is true with specified timeout and polling interval.
     *
     * @param condition        The condition to wait for
     * @param timeoutInSeconds The timeout in seconds
     * @param pollingInterval  The polling interval in milliseconds
     * @return True if the condition was met before timeout, false otherwise
     */
    boolean waitUntil(Supplier<Boolean> condition, int timeoutInSeconds, int pollingInterval);
    
    /**
     * Set the page context for this wait strategy.
     *
     * @param page The Playwright Page instance
     * @return This wait strategy instance for chaining
     */
    CSWaitStrategy withPage(Page page);
    
    /**
     * Get the current timeout in seconds.
     *
     * @return The current timeout in seconds
     */
    int getTimeoutInSeconds();
    
    /**
     * Set the timeout in seconds.
     *
     * @param timeoutInSeconds The timeout in seconds
     * @return This wait strategy instance for chaining
     */
    CSWaitStrategy withTimeout(int timeoutInSeconds);
    
    /**
     * Set the polling interval in milliseconds.
     *
     * @param pollingIntervalInMs The polling interval in milliseconds
     * @return This wait strategy instance for chaining
     */
    CSWaitStrategy withPollingInterval(int pollingIntervalInMs);
    
    /**
     * Set whether to ignore exceptions during polling.
     *
     * @param ignoreExceptions Whether to ignore exceptions
     * @return This wait strategy instance for chaining
     */
    CSWaitStrategy ignoreExceptions(boolean ignoreExceptions);
    
    /**
     * Wait for page load events.
     *
     * @param waitForLoad      Whether to wait for load event
     * @param waitForDomLoaded Whether to wait for DOMContentLoaded event
     * @param waitForNetworkIdle Whether to wait for network idle
     * @return This wait strategy instance for chaining
     */
    CSWaitStrategy withPageLoadWait(boolean waitForLoad, boolean waitForDomLoaded, boolean waitForNetworkIdle);
    
    /**
     * Get a description of this wait strategy.
     *
     * @return A description of this wait strategy
     */
    String getDescription();
}



CSAbstractWaitStrategy.java
---------------------------------

package com.cstestforge.framework.playwright.java.wait;

import com.cstestforge.framework.core.utils.CSConstants;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.element.CSElement;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.LoadState;
import com.microsoft.playwright.options.WaitForLoadStateOptions;
import com.microsoft.playwright.options.WaitForOptions;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

/**
 * Abstract base class for all wait strategies.
 * Provides common functionality for waiting operations.
 */
public abstract class CSAbstractWaitStrategy implements CSWaitStrategy {
    
    private static final CSLogger logger = CSLogger.getLogger(CSAbstractWaitStrategy.class);
    
    protected Page page;
    protected int timeoutInSeconds = CSConstants.DEFAULT_TIMEOUT_SECONDS;
    protected int pollingIntervalInMs = CSConstants.DEFAULT_POLLING_INTERVAL_MS;
    protected boolean ignoreExceptions = true;
    protected boolean waitForLoad = true;
    protected boolean waitForDomLoaded = true;
    protected boolean waitForNetworkIdle = false;
    
    /**
     * Constructor with page instance.
     *
     * @param page The Playwright Page instance
     */
    protected CSAbstractWaitStrategy(Page page) {
        this.page = page;
    }
    
    /**
     * Constructor with page instance and timeout.
     *
     * @param page             The Playwright Page instance
     * @param timeoutInSeconds The timeout in seconds
     */
    protected CSAbstractWaitStrategy(Page page, int timeoutInSeconds) {
        this.page = page;
        this.timeoutInSeconds = timeoutInSeconds;
    }
    
    /**
     * Default constructor.
     */
    protected CSAbstractWaitStrategy() {
    }
    
    @Override
    public CSElement waitFor(CSElement element) {
        return waitFor(element, timeoutInSeconds);
    }
    
    @Override
    public Locator waitFor(Locator locator) {
        return waitFor(locator, timeoutInSeconds);
    }
    
    @Override
    public List<CSElement> waitFor(List<CSElement> elements) {
        return waitFor(elements, timeoutInSeconds);
    }
    
    @Override
    public List<CSElement> waitFor(List<CSElement> elements, int timeoutInSeconds) {
        List<CSElement> waitedElements = new ArrayList<>();
        for (CSElement element : elements) {
            waitedElements.add(waitFor(element, timeoutInSeconds));
        }
        return waitedElements;
    }
    
    @Override
    public void waitForDuration(double durationInSeconds) {
        try {
            logger.debug("Waiting for " + durationInSeconds + " seconds");
            page.waitForTimeout(durationInSeconds * 1000);
        } catch (Exception e) {
            logger.error("Error while waiting for duration", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait operation failed", e);
            }
        }
    }
    
    @Override
    public boolean waitUntil(Supplier<Boolean> condition) {
        return waitUntil(condition, timeoutInSeconds);
    }
    
    @Override
    public boolean waitUntil(Supplier<Boolean> condition, int timeoutInSeconds) {
        return waitUntil(condition, timeoutInSeconds, pollingIntervalInMs);
    }
    
    @Override
    public boolean waitUntil(Supplier<Boolean> condition, int timeoutInSeconds, int pollingInterval) {
        long startTime = System.currentTimeMillis();
        long timeout = timeoutInSeconds * 1000L;
        long endTime = startTime + timeout;
        
        logger.debug("Waiting until condition is met with timeout " + timeoutInSeconds + 
                    " seconds and polling interval " + pollingInterval + " ms");
        
        while (System.currentTimeMillis() < endTime) {
            try {
                if (condition.get()) {
                    logger.debug("Condition met after " + 
                                (System.currentTimeMillis() - startTime) + " ms");
                    return true;
                }
            } catch (Exception e) {
                if (!ignoreExceptions) {
                    logger.error("Exception while waiting for condition", e);
                    throw new RuntimeException("Wait operation failed", e);
                }
                logger.debug("Ignoring exception during wait polling: " + e.getMessage());
            }
            
            try {
                Thread.sleep(pollingInterval);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                logger.error("Wait operation interrupted", e);
                return false;
            }
        }
        
        logger.debug("Condition not met within timeout of " + timeoutInSeconds + " seconds");
        return false;
    }
    
    @Override
    public CSWaitStrategy withPage(Page page) {
        this.page = page;
        return this;
    }
    
    @Override
    public int getTimeoutInSeconds() {
        return timeoutInSeconds;
    }
    
    @Override
    public CSWaitStrategy withTimeout(int timeoutInSeconds) {
        this.timeoutInSeconds = timeoutInSeconds;
        return this;
    }
    
    @Override
    public CSWaitStrategy withPollingInterval(int pollingIntervalInMs) {
        this.pollingIntervalInMs = pollingIntervalInMs;
        return this;
    }
    
    @Override
    public CSWaitStrategy ignoreExceptions(boolean ignoreExceptions) {
        this.ignoreExceptions = ignoreExceptions;
        return this;
    }
    
    @Override
    public CSWaitStrategy withPageLoadWait(boolean waitForLoad, boolean waitForDomLoaded, boolean waitForNetworkIdle) {
        this.waitForLoad = waitForLoad;
        this.waitForDomLoaded = waitForDomLoaded;
        this.waitForNetworkIdle = waitForNetworkIdle;
        return this;
    }
    
    /**
     * Ensure the page is available before performing wait operations.
     *
     * @throws IllegalStateException if page is not set
     */
    protected void ensurePageAvailable() {
        if (page == null) {
            throw new IllegalStateException("Page must be set before using wait strategy");
        }
    }
    
    /**
     * Wait for page load states according to configuration.
     */
    protected void waitForPageLoadStates() {
        ensurePageAvailable();
        
        WaitForLoadStateOptions options = new WaitForLoadStateOptions()
                .setTimeout(timeoutInSeconds * 1000);
        
        try {
            if (waitForDomLoaded) {
                logger.debug("Waiting for DOMContentLoaded event");
                page.waitForLoadState(LoadState.DOMCONTENTLOADED, options);
            }
            
            if (waitForLoad) {
                logger.debug("Waiting for Load event");
                page.waitForLoadState(LoadState.LOAD, options);
            }
            
            if (waitForNetworkIdle) {
                logger.debug("Waiting for Network Idle");
                page.waitForLoadState(LoadState.NETWORKIDLE, options);
            }
        } catch (Exception e) {
            logger.error("Error while waiting for page load states", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for page load states failed", e);
            }
        }
    }
    
    /**
     * Convert timeout in seconds to a WaitForOptions object.
     *
     * @param timeoutInSeconds The timeout in seconds
     * @return A WaitForOptions object with the specified timeout
     */
    protected WaitForOptions toWaitForOptions(int timeoutInSeconds) {
        return new WaitForOptions().setTimeout(timeoutInSeconds * 1000);
    }
}



CSVisibilityWait.java
-------------------------------


package com.cstestforge.framework.playwright.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.element.CSElement;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.WaitForSelectorOptions;
import com.microsoft.playwright.options.WaitForSelectorState;

/**
 * Wait strategy for element visibility.
 * Waits until an element is visible in the DOM.
 */
public class CSVisibilityWait extends CSAbstractWaitStrategy {
    
    private static final CSLogger logger = CSLogger.getLogger(CSVisibilityWait.class);
    
    /**
     * Constructor with page instance.
     *
     * @param page The Playwright Page instance
     */
    public CSVisibilityWait(Page page) {
        super(page);
    }
    
    /**
     * Constructor with page instance and timeout.
     *
     * @param page             The Playwright Page instance
     * @param timeoutInSeconds The timeout in seconds
     */
    public CSVisibilityWait(Page page, int timeoutInSeconds) {
        super(page, timeoutInSeconds);
    }
    
    /**
     * Default constructor.
     */
    public CSVisibilityWait() {
        super();
    }
    
    @Override
    public CSElement waitFor(CSElement element, int timeoutInSeconds) {
        if (element == null) {
            throw new IllegalArgumentException("Element cannot be null");
        }
        
        logger.debug("Waiting for element to be visible with timeout " + timeoutInSeconds + " seconds");
        
        try {
            Locator locator = element.getLocator();
            locator.waitFor(new WaitForSelectorOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutInSeconds * 1000));
            return element;
        } catch (Exception e) {
            logger.error("Error while waiting for element to be visible", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for visibility failed", e);
            }
            return element;
        }
    }
    
    @Override
    public Locator waitFor(Locator locator, int timeoutInSeconds) {
        if (locator == null) {
            throw new IllegalArgumentException("Locator cannot be null");
        }
        
        logger.debug("Waiting for locator to be visible with timeout " + timeoutInSeconds + " seconds");
        
        try {
            locator.waitFor(new WaitForSelectorOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutInSeconds * 1000));
            return locator;
        } catch (Exception e) {
            logger.error("Error while waiting for locator to be visible", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for visibility failed", e);
            }
            return locator;
        }
    }
    
    /**
     * Wait for an element to be visible with custom assertion message.
     *
     * @param element           The element to wait for
     * @param timeoutInSeconds  The timeout in seconds
     * @param assertionMessage  Custom assertion message if wait fails
     * @return The element after waiting
     */
    public CSElement waitFor(CSElement element, int timeoutInSeconds, String assertionMessage) {
        try {
            return waitFor(element, timeoutInSeconds);
        } catch (RuntimeException e) {
            throw new RuntimeException(assertionMessage, e);
        }
    }
    
    /**
     * Wait for multiple elements to be visible.
     *
     * @param elements The list of elements to wait for
     * @param timeoutInSeconds The timeout in seconds for each element
     * @param waitForAll Whether to wait for all elements or any element
     * @return The list of elements after waiting
     */
    public boolean waitForElements(Locator elements, int timeoutInSeconds, boolean waitForAll) {
        if (elements == null) {
            throw new IllegalArgumentException("Elements locator cannot be null");
        }
        
        logger.debug("Waiting for elements to be visible with timeout " + timeoutInSeconds + 
                    " seconds, waitForAll=" + waitForAll);
        
        try {
            if (waitForAll) {
                return waitUntil(() -> {
                    int count = elements.count();
                    if (count == 0) return false;
                    
                    for (int i = 0; i < count; i++) {
                        if (!elements.nth(i).isVisible()) {
                            return false;
                        }
                    }
                    return true;
                }, timeoutInSeconds);
            } else {
                return waitUntil(() -> elements.first().isVisible(), timeoutInSeconds);
            }
        } catch (Exception e) {
            logger.error("Error while waiting for elements to be visible", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for visibility failed", e);
            }
            return false;
        }
    }
    
    /**
     * Wait until at least a minimum number of elements are visible.
     *
     * @param elements The locator for multiple elements
     * @param minimumCount The minimum number of elements to wait for
     * @param timeoutInSeconds The timeout in seconds
     * @return True if at least minimumCount elements became visible, false otherwise
     */
    public boolean waitForMinimumElements(Locator elements, int minimumCount, int timeoutInSeconds) {
        if (elements == null) {
            throw new IllegalArgumentException("Elements locator cannot be null");
        }
        
        logger.debug("Waiting for at least " + minimumCount + " elements to be visible with timeout " + 
                    timeoutInSeconds + " seconds");
        
        try {
            return waitUntil(() -> {
                int visibleCount = 0;
                int count = elements.count();
                
                for (int i = 0; i < count; i++) {
                    if (elements.nth(i).isVisible()) {
                        visibleCount++;
                        if (visibleCount >= minimumCount) {
                            return true;
                        }
                    }
                }
                return false;
            }, timeoutInSeconds);
        } catch (Exception e) {
            logger.error("Error while waiting for minimum elements to be visible", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for minimum visibility failed", e);
            }
            return false;
        }
    }
    
    @Override
    public String getDescription() {
        return "Wait for element visibility";
    }
}



CSClickableWait.java
---------------------------------------------------

package com.cstestforge.framework.playwright.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.element.CSElement;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.WaitForSelectorOptions;
import com.microsoft.playwright.options.WaitForSelectorState;

import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Wait strategy for element to be clickable.
 * Waits until an element is both visible and enabled (clickable).
 */
public class CSClickableWait extends CSAbstractWaitStrategy {
    
    private static final CSLogger logger = CSLogger.getLogger(CSClickableWait.class);
    
    /**
     * Constructor with page instance.
     *
     * @param page The Playwright Page instance
     */
    public CSClickableWait(Page page) {
        super(page);
    }
    
    /**
     * Constructor with page instance and timeout.
     *
     * @param page             The Playwright Page instance
     * @param timeoutInSeconds The timeout in seconds
     */
    public CSClickableWait(Page page, int timeoutInSeconds) {
        super(page, timeoutInSeconds);
    }
    
    /**
     * Default constructor.
     */
    public CSClickableWait() {
        super();
    }
    
    @Override
    public CSElement waitFor(CSElement element, int timeoutInSeconds) {
        if (element == null) {
            throw new IllegalArgumentException("Element cannot be null");
        }
        
        logger.debug("Waiting for element to be clickable with timeout " + timeoutInSeconds + " seconds");
        
        try {
            Locator locator = element.getLocator();
            
            // First wait for visibility
            locator.waitFor(new WaitForSelectorOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutInSeconds * 1000));
            
            // Then check if enabled
            boolean isEnabled = waitUntil(() -> {
                try {
                    return locator.isEnabled();
                } catch (Exception e) {
                    logger.debug("Error checking if element is enabled, will retry: " + e.getMessage());
                    return false;
                }
            }, timeoutInSeconds);
            
            if (!isEnabled) {
                logger.warn("Element is visible but not enabled after timeout");
                if (!ignoreExceptions) {
                    throw new RuntimeException("Element is visible but not enabled after timeout of " + 
                                              timeoutInSeconds + " seconds");
                }
            }
            
            return element;
        } catch (Exception e) {
            logger.error("Error while waiting for element to be clickable", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for clickable failed", e);
            }
            return element;
        }
    }
    
    @Override
    public Locator waitFor(Locator locator, int timeoutInSeconds) {
        if (locator == null) {
            throw new IllegalArgumentException("Locator cannot be null");
        }
        
        logger.debug("Waiting for locator to be clickable with timeout " + timeoutInSeconds + " seconds");
        
        try {
            // First wait for visibility
            locator.waitFor(new WaitForSelectorOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutInSeconds * 1000));
            
            // Then check if enabled
            boolean isEnabled = waitUntil(() -> {
                try {
                    return locator.isEnabled();
                } catch (Exception e) {
                    logger.debug("Error checking if element is enabled, will retry: " + e.getMessage());
                    return false;
                }
            }, timeoutInSeconds);
            
            if (!isEnabled) {
                logger.warn("Element is visible but not enabled after timeout");
                if (!ignoreExceptions) {
                    throw new RuntimeException("Element is visible but not enabled after timeout of " + 
                                              timeoutInSeconds + " seconds");
                }
            }
            
            return locator;
        } catch (Exception e) {
            logger.error("Error while waiting for locator to be clickable", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for clickable failed", e);
            }
            return locator;
        }
    }
    
    /**
     * Wait for an element to be clickable with custom assertion message.
     *
     * @param element           The element to wait for
     * @param timeoutInSeconds  The timeout in seconds
     * @param assertionMessage  Custom assertion message if wait fails
     * @return The element after waiting
     */
    public CSElement waitFor(CSElement element, int timeoutInSeconds, String assertionMessage) {
        try {
            return waitFor(element, timeoutInSeconds);
        } catch (RuntimeException e) {
            throw new RuntimeException(assertionMessage, e);
        }
    }
    
    /**
     * Check if an element is currently clickable without waiting.
     *
     * @param element The element to check
     * @return True if the element is currently clickable, false otherwise
     */
    public boolean isClickable(CSElement element) {
        if (element == null) {
            return false;
        }
        
        try {
            Locator locator = element.getLocator();
            return locator.isVisible() && locator.isEnabled();
        } catch (Exception e) {
            logger.debug("Error checking if element is clickable: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Check if a locator is currently clickable without waiting.
     *
     * @param locator The locator to check
     * @return True if the element is currently clickable, false otherwise
     */
    public boolean isClickable(Locator locator) {
        if (locator == null) {
            return false;
        }
        
        try {
            return locator.isVisible() && locator.isEnabled();
        } catch (Exception e) {
            logger.debug("Error checking if locator is clickable: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Wait for any element in a collection to become clickable.
     *
     * @param elements The locator for multiple elements
     * @param timeoutInSeconds The timeout in seconds
     * @return Index of the first clickable element, or -1 if none became clickable
     */
    public int waitForAnyClickable(Locator elements, int timeoutInSeconds) {
        if (elements == null) {
            throw new IllegalArgumentException("Elements locator cannot be null");
        }
        
        logger.debug("Waiting for any element to be clickable with timeout " + timeoutInSeconds + " seconds");
        
        AtomicBoolean found = new AtomicBoolean(false);
        AtomicBoolean completed = new AtomicBoolean(false);
        final int[] resultIndex = {-1};
        
        try {
            waitUntil(() -> {
                try {
                    int count = elements.count();
                    
                    for (int i = 0; i < count; i++) {
                        Locator element = elements.nth(i);
                        if (element.isVisible() && element.isEnabled()) {
                            resultIndex[0] = i;
                            found.set(true);
                            return true;
                        }
                    }
                    
                    return false;
                } catch (Exception e) {
                    logger.debug("Error during wait iteration, will retry: " + e.getMessage());
                    return false;
                } finally {
                    if (!found.get()) {
                        completed.set(true);
                    }
                }
            }, timeoutInSeconds);
            
            return resultIndex[0];
        } catch (Exception e) {
            logger.error("Error while waiting for any element to be clickable", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for any clickable failed", e);
            }
            return -1;
        }
    }
    
    @Override
    public String getDescription() {
        return "Wait for element to be clickable (visible and enabled)";
    }
}



CSTextWait.java
----------------------------

package com.cstestforge.framework.playwright.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.element.CSElement;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.WaitForSelectorOptions;
import com.microsoft.playwright.options.WaitForSelectorState;

import java.util.regex.Pattern;

/**
 * Wait strategy for element text.
 * Waits until an element contains, equals, or matches expected text.
 */
public class CSTextWait extends CSAbstractWaitStrategy {
    
    private static final CSLogger logger = CSLogger.getLogger(CSTextWait.class);
    
    /**
     * Text matching strategies
     */
    public enum TextMatchStrategy {
        EQUALS,
        CONTAINS,
        STARTS_WITH,
        ENDS_WITH,
        REGEX
    }
    
    private String expectedText;
    private TextMatchStrategy matchStrategy = TextMatchStrategy.CONTAINS;
    private boolean caseSensitive = true;
    private Pattern pattern;
    
    /**
     * Constructor with page instance.
     *
     * @param page The Playwright Page instance
     */
    public CSTextWait(Page page) {
        super(page);
    }
    
    /**
     * Constructor with page instance and expected text.
     *
     * @param page         The Playwright Page instance
     * @param expectedText The expected text
     */
    public CSTextWait(Page page, String expectedText) {
        super(page);
        this.expectedText = expectedText;
    }
    
    /**
     * Constructor with page instance, expected text, and match strategy.
     *
     * @param page          The Playwright Page instance
     * @param expectedText  The expected text
     * @param matchStrategy The text matching strategy
     */
    public CSTextWait(Page page, String expectedText, TextMatchStrategy matchStrategy) {
        super(page);
        this.expectedText = expectedText;
        this.matchStrategy = matchStrategy;
        if (matchStrategy == TextMatchStrategy.REGEX) {
            this.pattern = Pattern.compile(expectedText);
        }
    }
    
    /**
     * Full constructor.
     *
     * @param page          The Playwright Page instance
     * @param expectedText  The expected text
     * @param matchStrategy The text matching strategy
     * @param caseSensitive Whether to match case sensitively
     */
    public CSTextWait(Page page, String expectedText, TextMatchStrategy matchStrategy, boolean caseSensitive) {
        super(page);
        this.expectedText = expectedText;
        this.matchStrategy = matchStrategy;
        this.caseSensitive = caseSensitive;
        if (matchStrategy == TextMatchStrategy.REGEX) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedText, flags);
        }
    }
    
    /**
     * Default constructor.
     */
    public CSTextWait() {
        super();
    }
    
    /**
     * Set the expected text and match strategy.
     *
     * @param expectedText  The expected text
     * @param matchStrategy The text matching strategy
     * @return This wait strategy instance for chaining
     */
    public CSTextWait withText(String expectedText, TextMatchStrategy matchStrategy) {
        this.expectedText = expectedText;
        this.matchStrategy = matchStrategy;
        if (matchStrategy == TextMatchStrategy.REGEX) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedText, flags);
        }
        return this;
    }
    
    /**
     * Set the expected text.
     *
     * @param expectedText The expected text
     * @return This wait strategy instance for chaining
     */
    public CSTextWait withText(String expectedText) {
        this.expectedText = expectedText;
        if (matchStrategy == TextMatchStrategy.REGEX) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedText, flags);
        }
        return this;
    }
    
    /**
     * Set the match strategy.
     *
     * @param matchStrategy The text matching strategy
     * @return This wait strategy instance for chaining
     */
    public CSTextWait withMatchStrategy(TextMatchStrategy matchStrategy) {
        this.matchStrategy = matchStrategy;
        if (matchStrategy == TextMatchStrategy.REGEX && expectedText != null) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedText, flags);
        }
        return this;
    }
    
    /**
     * Set whether to match case sensitively.
     *
     * @param caseSensitive Whether to match case sensitively
     * @return This wait strategy instance for chaining
     */
    public CSTextWait withCaseSensitivity(boolean caseSensitive) {
        this.caseSensitive = caseSensitive;
        if (matchStrategy == TextMatchStrategy.REGEX && expectedText != null) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedText, flags);
        }
        return this;
    }
    
    @Override
    public CSElement waitFor(CSElement element, int timeoutInSeconds) {
        if (element == null) {
            throw new IllegalArgumentException("Element cannot be null");
        }
        
        if (expectedText == null) {
            throw new IllegalStateException("Expected text must be set before waiting");
        }
        
        logger.debug("Waiting for element text with strategy " + matchStrategy + 
                    " and timeout " + timeoutInSeconds + " seconds");
        
        try {
            Locator locator = element.getLocator();
            
            // First ensure element is visible
            locator.waitFor(new WaitForSelectorOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutInSeconds * 1000));
            
            // Then wait for the expected text
            boolean textMatched = waitUntil(() -> {
                try {
                    String actualText = locator.textContent();
                    return matchesText(actualText);
                } catch (Exception e) {
                    logger.debug("Error getting element text, will retry: " + e.getMessage());
                    return false;
                }
            }, timeoutInSeconds);
            
            if (!textMatched) {
                String actualText = locator.textContent();
                String message = "Expected text condition not met after timeout. " +
                                "Expected: " + matchStrategy + " '" + expectedText + "', " +
                                "Actual: '" + actualText + "'";
                logger.warn(message);
                
                if (!ignoreExceptions) {
                    throw new RuntimeException(message);
                }
            }
            
            return element;
        } catch (Exception e) {
            logger.error("Error while waiting for element text", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for text failed", e);
            }
            return element;
        }
    }
    
    @Override
    public Locator waitFor(Locator locator, int timeoutInSeconds) {
        if (locator == null) {
            throw new IllegalArgumentException("Locator cannot be null");
        }
        
        if (expectedText == null) {
            throw new IllegalStateException("Expected text must be set before waiting");
        }
        
        logger.debug("Waiting for locator text with strategy " + matchStrategy + 
                    " and timeout " + timeoutInSeconds + " seconds");
        
        try {
            // First ensure element is visible
            locator.waitFor(new WaitForSelectorOptions()
                    .setState(WaitForSelectorState.VISIBLE)
                    .setTimeout(timeoutInSeconds * 1000));
            
            // Then wait for the expected text
            boolean textMatched = waitUntil(() -> {
                try {
                    String actualText = locator.textContent();
                    return matchesText(actualText);
                } catch (Exception e) {
                    logger.debug("Error getting locator text, will retry: " + e.getMessage());
                    return false;
                }
            }, timeoutInSeconds);
            
            if (!textMatched) {
                String actualText = locator.textContent();
                String message = "Expected text condition not met after timeout. " +
                                "Expected: " + matchStrategy + " '" + expectedText + "', " +
                                "Actual: '" + actualText + "'";
                logger.warn(message);
                
                if (!ignoreExceptions) {
                    throw new RuntimeException(message);
                }
            }
            
            return locator;
        } catch (Exception e) {
            logger.error("Error while waiting for locator text", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for text failed", e);
            }
            return locator;
        }
    }
    
    /**
     * Wait for an element to have the expected text with custom assertion message.
     *
     * @param element           The element to wait for
     * @param timeoutInSeconds  The timeout in seconds
     * @param assertionMessage  Custom assertion message if wait fails
     * @return The element after waiting
     */
    public CSElement waitFor(CSElement element, int timeoutInSeconds, String assertionMessage) {
        try {
            return waitFor(element, timeoutInSeconds);
        } catch (RuntimeException e) {
            throw new RuntimeException(assertionMessage, e);
        }
    }
    
    /**
     * Wait for an element to have the specified text.
     *
     * @param element           The element to wait for
     * @param expectedText      The expected text
     * @param matchStrategy     The text matching strategy
     * @param timeoutInSeconds  The timeout in seconds
     * @return The element after waiting
     */
    public CSElement waitForText(CSElement element, String expectedText, 
                              TextMatchStrategy matchStrategy, int timeoutInSeconds) {
        withText(expectedText, matchStrategy);
        return waitFor(element, timeoutInSeconds);
    }
    
    /**
     * Wait for page content to contain expected text.
     *
     * @param expectedText     The expected text
     * @param timeoutInSeconds The timeout in seconds
     * @return True if the text was found, false otherwise
     */
    public boolean waitForPageContent(String expectedText, int timeoutInSeconds) {
        ensurePageAvailable();
        
        this.expectedText = expectedText;
        this.matchStrategy = TextMatchStrategy.CONTAINS;
        
        logger.debug("Waiting for page content to contain '" + expectedText + 
                    "' with timeout " + timeoutInSeconds + " seconds");
        
        try {
            return waitUntil(() -> {
                try {
                    String content = page.content();
                    return content.contains(expectedText);
                } catch (Exception e) {
                    logger.debug("Error getting page content, will retry: " + e.getMessage());
                    return false;
                }
            }, timeoutInSeconds);
        } catch (Exception e) {
            logger.error("Error while waiting for page content", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for page content failed", e);
            }
            return false;
        }
    }
    
    /**
     * Wait for a specific element to have a specific attribute value.
     * 
     * @param element           The element to check
     * @param attributeName     The name of the attribute
     * @param expectedValue     The expected attribute value
     * @param timeoutInSeconds  The timeout in seconds
     * @return The element after waiting
     */
    public CSElement waitForAttribute(CSElement element, String attributeName, 
                                   String expectedValue, int timeoutInSeconds) {
        if (element == null) {
            throw new IllegalArgumentException("Element cannot be null");
        }
        
        logger.debug("Waiting for element attribute " + attributeName + 
                    " to have value '" + expectedValue + 
                    "' with timeout " + timeoutInSeconds + " seconds");
        
        try {
            Locator locator = element.getLocator();
            
            boolean attributeMatched = waitUntil(() -> {
                try {
                    String actualValue = locator.getAttribute(attributeName);
                    return expectedValue.equals(actualValue);
                } catch (Exception e) {
                    logger.debug("Error getting element attribute, will retry: " + e.getMessage());
                    return false;
                }
            }, timeoutInSeconds);
            
            if (!attributeMatched) {
                String actualValue = locator.getAttribute(attributeName);
                String message = "Expected attribute value not met after timeout. " +
                                "Attribute: " + attributeName + ", " +
                                "Expected: '" + expectedValue + "', " +
                                "Actual: '" + actualValue + "'";
                logger.warn(message);
                
                if (!ignoreExceptions) {
                    throw new RuntimeException(message);
                }
            }
            
            return element;
        } catch (Exception e) {
            logger.error("Error while waiting for element attribute", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for attribute failed", e);
            }
            return element;
        }
    }
    
    /**
     * Check if the actual text matches the expected text according to the match strategy.
     *
     * @param actualText The actual text to check
     * @return True if the text matches, false otherwise
     */
    private boolean matchesText(String actualText) {
        if (actualText == null) {
            return false;
        }
        
        if (!caseSensitive && matchStrategy != TextMatchStrategy.REGEX) {
            actualText = actualText.toLowerCase();
            String expectedTextLower = expectedText.toLowerCase();
            
            switch (matchStrategy) {
                case EQUALS:
                    return actualText.equals(expectedTextLower);
                case CONTAINS:
                    return actualText.contains(expectedTextLower);
                case STARTS_WITH:
                    return actualText.startsWith(expectedTextLower);
                case ENDS_WITH:
                    return actualText.endsWith(expectedTextLower);
                default:
                    return false;
            }
        } else {
            switch (matchStrategy) {
                case EQUALS:
                    return actualText.equals(expectedText);
                case CONTAINS:
                    return actualText.contains(expectedText);
                case STARTS_WITH:
                    return actualText.startsWith(expectedText);
                case ENDS_WITH:
                    return actualText.endsWith(expectedText);
                case REGEX:
                    return pattern.matcher(actualText).find();
                default:
                    return false;
            }
        }
    }
    
    @Override
    public String getDescription() {
        return "Wait for element text with strategy " + matchStrategy + 
               (expectedText != null ? " and text '" + expectedText + "'" : "");
    }
}



CSAttributeWait.java
-----------------------------

package com.cstestforge.framework.playwright.java.wait;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.playwright.java.element.CSElement;
import com.microsoft.playwright.Locator;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.WaitForSelectorOptions;
import com.microsoft.playwright.options.WaitForSelectorState;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * Wait strategy for element attributes.
 * Waits until an element has the expected attribute value.
 */
public class CSAttributeWait extends CSAbstractWaitStrategy {
    
    private static final CSLogger logger = CSLogger.getLogger(CSAttributeWait.class);
    
    /**
     * Attribute matching strategies
     */
    public enum AttributeMatchStrategy {
        EQUALS,
        CONTAINS,
        STARTS_WITH,
        ENDS_WITH,
        REGEX,
        EXISTS,
        NOT_EXISTS
    }
    
    private String attributeName;
    private String expectedValue;
    private AttributeMatchStrategy matchStrategy = AttributeMatchStrategy.EQUALS;
    private boolean caseSensitive = true;
    private Pattern pattern;
    private Map<String, AttributeMatchStrategy> multipleAttributes;
    
    /**
     * Constructor with page instance.
     *
     * @param page The Playwright Page instance
     */
    public CSAttributeWait(Page page) {
        super(page);
    }
    
    /**
     * Constructor with page, attribute name, and expected value.
     *
     * @param page          The Playwright Page instance
     * @param attributeName The attribute name
     * @param expectedValue The expected attribute value
     */
    public CSAttributeWait(Page page, String attributeName, String expectedValue) {
        super(page);
        this.attributeName = attributeName;
        this.expectedValue = expectedValue;
    }
    
    /**
     * Constructor with page, attribute name, expected value, and match strategy.
     *
     * @param page          The Playwright Page instance
     * @param attributeName The attribute name
     * @param expectedValue The expected attribute value
     * @param matchStrategy The attribute matching strategy
     */
    public CSAttributeWait(Page page, String attributeName, String expectedValue, 
                          AttributeMatchStrategy matchStrategy) {
        super(page);
        this.attributeName = attributeName;
        this.expectedValue = expectedValue;
        this.matchStrategy = matchStrategy;
        
        if (matchStrategy == AttributeMatchStrategy.REGEX && expectedValue != null) {
            this.pattern = Pattern.compile(expectedValue);
        }
    }
    
    /**
     * Full constructor.
     *
     * @param page          The Playwright Page instance
     * @param attributeName The attribute name
     * @param expectedValue The expected attribute value
     * @param matchStrategy The attribute matching strategy
     * @param caseSensitive Whether to match case sensitively
     */
    public CSAttributeWait(Page page, String attributeName, String expectedValue, 
                          AttributeMatchStrategy matchStrategy, boolean caseSensitive) {
        super(page);
        this.attributeName = attributeName;
        this.expectedValue = expectedValue;
        this.matchStrategy = matchStrategy;
        this.caseSensitive = caseSensitive;
        
        if (matchStrategy == AttributeMatchStrategy.REGEX && expectedValue != null) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedValue, flags);
        }
    }
    
    /**
     * Default constructor.
     */
    public CSAttributeWait() {
        super();
    }
    
    /**
     * Set the attribute name and expected value.
     *
     * @param attributeName The attribute name
     * @param expectedValue The expected attribute value
     * @return This wait strategy instance for chaining
     */
    public CSAttributeWait withAttribute(String attributeName, String expectedValue) {
        this.attributeName = attributeName;
        this.expectedValue = expectedValue;
        
        if (matchStrategy == AttributeMatchStrategy.REGEX && expectedValue != null) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedValue, flags);
        }
        
        return this;
    }
    
    /**
     * Set the attribute name, expected value, and match strategy.
     *
     * @param attributeName The attribute name
     * @param expectedValue The expected attribute value
     * @param matchStrategy The attribute matching strategy
     * @return This wait strategy instance for chaining
     */
    public CSAttributeWait withAttribute(String attributeName, String expectedValue, 
                                      AttributeMatchStrategy matchStrategy) {
        this.attributeName = attributeName;
        this.expectedValue = expectedValue;
        this.matchStrategy = matchStrategy;
        
        if (matchStrategy == AttributeMatchStrategy.REGEX && expectedValue != null) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedValue, flags);
        }
        
        return this;
    }
    
    /**
     * Add multiple attributes to wait for (all conditions must be satisfied).
     *
     * @param attributes Map of attribute names to expected values
     * @param matchStrategy The matching strategy for all attributes
     * @return This wait strategy instance for chaining
     */
    public CSAttributeWait withMultipleAttributes(Map<String, String> attributes, 
                                              AttributeMatchStrategy matchStrategy) {
        if (attributes == null || attributes.isEmpty()) {
            throw new IllegalArgumentException("Attributes map cannot be null or empty");
        }
        
        this.multipleAttributes = new HashMap<>();
        
        for (Map.Entry<String, String> entry : attributes.entrySet()) {
            this.multipleAttributes.put(entry.getKey() + "=" + entry.getValue(), matchStrategy);
        }
        
        return this;
    }
    
    /**
     * Add multiple attributes with different matching strategies.
     *
     * @param attributeMatchers Map of "attribute=value" strings to match strategies
     * @return This wait strategy instance for chaining
     */
    public CSAttributeWait withMultipleAttributeMatchers(Map<String, AttributeMatchStrategy> attributeMatchers) {
        if (attributeMatchers == null || attributeMatchers.isEmpty()) {
            throw new IllegalArgumentException("Attribute matchers map cannot be null or empty");
        }
        
        this.multipleAttributes = new HashMap<>(attributeMatchers);
        return this;
    }
    
    /**
     * Set the match strategy.
     *
     * @param matchStrategy The attribute matching strategy
     * @return This wait strategy instance for chaining
     */
    public CSAttributeWait withMatchStrategy(AttributeMatchStrategy matchStrategy) {
        this.matchStrategy = matchStrategy;
        
        if (matchStrategy == AttributeMatchStrategy.REGEX && expectedValue != null) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedValue, flags);
        }
        
        return this;
    }
    
    /**
     * Set whether to match case sensitively.
     *
     * @param caseSensitive Whether to match case sensitively
     * @return This wait strategy instance for chaining
     */
    public CSAttributeWait withCaseSensitivity(boolean caseSensitive) {
        this.caseSensitive = caseSensitive;
        
        if (matchStrategy == AttributeMatchStrategy.REGEX && expectedValue != null) {
            int flags = caseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
            this.pattern = Pattern.compile(expectedValue, flags);
        }
        
        return this;
    }
    
    @Override
    public CSElement waitFor(CSElement element, int timeoutInSeconds) {
        if (element == null) {
            throw new IllegalArgumentException("Element cannot be null");
        }
        
        if (attributeName == null && (multipleAttributes == null || multipleAttributes.isEmpty())) {
            throw new IllegalStateException("Either attribute name or multiple attributes must be set before waiting");
        }
        
        logger.debug("Waiting for element attribute" + 
                    (multipleAttributes != null ? "s" : " '" + attributeName + "'") + 
                    " with timeout " + timeoutInSeconds + " seconds");
        
        try {
            Locator locator = element.getLocator();
            
            // First ensure element is attached to DOM
            locator.waitFor(new WaitForSelectorOptions()
                    .setState(WaitForSelectorState.ATTACHED)
                    .setTimeout(timeoutInSeconds * 1000));
            
            // Then wait for the attribute condition
            boolean attributeMatched;
            
            if (multipleAttributes != null && !multipleAttributes.isEmpty()) {
                attributeMatched = waitUntil(() -> {
                    try {
                        return checkMultipleAttributes(locator);
                    } catch (Exception e) {
                        logger.debug("Error checking element attributes, will retry: " + e.getMessage());
                        return false;
                    }
                }, timeoutInSeconds);
            } else {
                attributeMatched = waitUntil(() -> {
                    try {
                        return checkAttribute(locator, attributeName, expectedValue, matchStrategy);
                    } catch (Exception e) {
                        logger.debug("Error checking element attribute, will retry: " + e.getMessage());
                        return false;
                    }
                }, timeoutInSeconds);
            }
            
            if (!attributeMatched) {
                String message;
                
                if (multipleAttributes != null && !multipleAttributes.isEmpty()) {
                    message = "Expected attribute conditions not met after timeout for attributes: " + 
                             multipleAttributes.keySet();
                } else {
                    String actualValue = locator.getAttribute(attributeName);
                    message = "Expected attribute condition not met after timeout. " +
                             "Attribute: " + attributeName + ", " +
                             "Expected: " + matchStrategy + " '" + expectedValue + "', " +
                             "Actual: '" + actualValue + "'";
                }
                
                logger.warn(message);
                
                if (!ignoreExceptions) {
                    throw new RuntimeException(message);
                }
            }
            
            return element;
        } catch (Exception e) {
            logger.error("Error while waiting for element attribute", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for attribute failed", e);
            }
            return element;
        }
    }
    
    @Override
    public Locator waitFor(Locator locator, int timeoutInSeconds) {
        if (locator == null) {
            throw new IllegalArgumentException("Locator cannot be null");
        }
        
        if (attributeName == null && (multipleAttributes == null || multipleAttributes.isEmpty())) {
            throw new IllegalStateException("Either attribute name or multiple attributes must be set before waiting");
        }
        
        logger.debug("Waiting for locator attribute" + 
                    (multipleAttributes != null ? "s" : " '" + attributeName + "'") + 
                    " with timeout " + timeoutInSeconds + " seconds");
        
        try {
            // First ensure element is attached to DOM
            locator.waitFor(new WaitForSelectorOptions()
                    .setState(WaitForSelectorState.ATTACHED)
                    .setTimeout(timeoutInSeconds * 1000));
            
            // Then wait for the attribute condition
            boolean attributeMatched;
            
            if (multipleAttributes != null && !multipleAttributes.isEmpty()) {
                attributeMatched = waitUntil(() -> {
                    try {
                        return checkMultipleAttributes(locator);
                    } catch (Exception e) {
                        logger.debug("Error checking locator attributes, will retry: " + e.getMessage());
                        return false;
                    }
                }, timeoutInSeconds);
            } else {
                attributeMatched = waitUntil(() -> {
                    try {
                        return checkAttribute(locator, attributeName, expectedValue, matchStrategy);
                    } catch (Exception e) {
                        logger.debug("Error checking locator attribute, will retry: " + e.getMessage());
                        return false;
                    }
                }, timeoutInSeconds);
            }
            
            if (!attributeMatched) {
                String message;
                
                if (multipleAttributes != null && !multipleAttributes.isEmpty()) {
                    message = "Expected attribute conditions not met after timeout for attributes: " + 
                             multipleAttributes.keySet();
                } else {
                    String actualValue = locator.getAttribute(attributeName);
                    message = "Expected attribute condition not met after timeout. " +
                             "Attribute: " + attributeName + ", " +
                             "Expected: " + matchStrategy + " '" + expectedValue + "', " +
                             "Actual: '" + actualValue + "'";
                }
                
                logger.warn(message);
                
                if (!ignoreExceptions) {
                    throw new RuntimeException(message);
                }
            }
            
            return locator;
        } catch (Exception e) {
            logger.error("Error while waiting for locator attribute", e);
            if (!ignoreExceptions) {
                throw new RuntimeException("Wait for attribute failed", e);
            }
            return locator;
        }
    }
    
    /**
     * Wait for an element to have the expected attribute with custom assertion message.
     *
     * @param element           The element to wait for
     * @param timeoutInSeconds  The timeout in seconds
     * @param assertionMessage  Custom assertion message if wait fails
     * @return The element after waiting
     */
    public CSElement waitFor(CSElement element, int timeoutInSeconds, String assertionMessage) {
        try {
            return waitFor(element, timeoutInSeconds);
        } catch (RuntimeException e) {
            throw new RuntimeException(assertionMessage, e);
        }
    }
    
    /**
     * Wait for an element to have a class.
     *
     * @param element          The element to wait for
     * @param className        The class name to wait for
     * @param timeoutInSeconds The timeout in seconds
     * @return The element after waiting
     */
    public CSElement waitForClass(CSElement element, String className, int timeoutInSeconds) {
        return waitForAttribute(element, "class", className, AttributeMatchStrategy.CONTAINS, timeoutInSeconds);
    }
    
    /**
     * Wait for an element to have the specified attribute.
     *
     * @param element           The element to wait for
     * @param attributeName     The attribute name
     * @param expectedValue     The expected attribute value
     * @param matchStrategy     The attribute matching strategy
     * @param timeoutInSeconds  The timeout in seconds
     * @return The element after waiting
     */
    public CSElement waitForAttribute(CSElement element, String attributeName, String expectedValue, 
                                    AttributeMatchStrategy matchStrategy, int timeoutInSeconds) {
        withAttribute(attributeName, expectedValue, matchStrategy);
        return waitFor(element, timeoutInSeconds);
    }
    
    /**
     * Check if the attribute matches the expected value according to the match strategy.
     *
     * @param locator       The locator to check
     * @param attributeName The attribute name
     * @param expectedValue The expected attribute value
     * @param matchStrategy The attribute matching strategy
     * @return True if the attribute matches, false otherwise
     */
    private boolean checkAttribute(Locator locator, String attributeName, 
                                 String expectedValue, AttributeMatchStrategy matchStrategy) {
        String actualValue = locator.getAttribute(attributeName);
        
        // Handle special cases first
        if (matchStrategy == AttributeMatchStrategy.EXISTS) {
            return actualValue != null;
        } else if (matchStrategy == AttributeMatchStrategy.NOT_EXISTS) {
            return actualValue == null;
        } else if (actualValue == null) {
            return false;
        }
        
        // Handle case sensitivity
        if (!caseSensitive && matchStrategy != AttributeMatchStrategy.REGEX) {
            actualValue = actualValue.toLowerCase();
            String expectedValueLower = expectedValue.toLowerCase();
            
            switch (matchStrategy) {
                case EQUALS:
                    return actualValue.equals(expectedValueLower);
                case CONTAINS:
                    return actualValue.contains(expectedValueLower);
                case STARTS_WITH:
                    return actualValue.startsWith(expectedValueLower);
                case ENDS_WITH:
                    return actualValue.endsWith(expectedValueLower);
                default:
                    return false;
            }
        } else {
            switch (matchStrategy) {
                case EQUALS:
                    return actualValue.equals(expectedValue);
                case CONTAINS:
                    return actualValue.contains(expectedValue);
                case STARTS_WITH:
                    return actualValue.startsWith(expectedValue);
                case ENDS_WITH:
                    return actualValue.endsWith(expectedValue);
                case REGEX:
                    return pattern.matcher(actualValue).find();
                default:
                    return false;
            }
        }
    }
    
    /**
     * Check if all the multiple attributes match their expected values.
     *
     * @param locator The locator to check
     * @return True if all attributes match, false otherwise
     */
    private boolean checkMultipleAttributes(Locator locator) {
        for (Map.Entry<String, AttributeMatchStrategy> entry : multipleAttributes.entrySet()) {
            String attributeSpec = entry.getKey();
            AttributeMatchStrategy strategy = entry.getValue();
            
            // Parse attribute name and value
            String[] parts = attributeSpec.split("=", 2);
            String attrName = parts[0];
            String attrValue = parts.length > 1 ? parts[1] : null;
            
            if (!checkAttribute(locator, attrName, attrValue, strategy)) {
                return false;
            }
        }
        
        return true;
    }
    
    @Override
    public String getDescription() {
        if (multipleAttributes != null && !multipleAttributes.isEmpty()) {
            return "Wait for element attributes: " + multipleAttributes.keySet();
        } else {
            return "Wait for element attribute '" + attributeName + "' with strategy " + matchStrategy + 
                   (expectedValue != null ? " and value '" + expectedValue + "'" : "");
        }
    }
}


CSWaitFactory.java
----------------------------


package com.cstestforge.framework.playwright.java.wait;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.utils.CSConstants;
import com.cstestforge.framework.playwright.java.wait.CSAttributeWait.AttributeMatchStrategy;
import com.cstestforge.framework.playwright.java.wait.CSTextWait.TextMatchStrategy;
import com.microsoft.playwright.Page;

/**
 * Factory for creating wait strategies.
 * Provides convenient methods for creating different wait strategies.
 */
public class CSWaitFactory {
    
    private final Page page;
    private final int defaultTimeoutInSeconds;
    private final int defaultPollingIntervalInMs;
    private boolean ignoreExceptions = true;
    private boolean waitForLoad = true;
    private boolean waitForDomLoaded = true;
    private boolean waitForNetworkIdle = false;
    
    /**
     * Constructor with page instance.
     *
     * @param page The Playwright Page instance
     */
    public CSWaitFactory(Page page) {
        this.page = page;
        this.defaultTimeoutInSeconds = ConfigurationManager.getInstance()
                .getFrameworkConfig().getInt("wait.timeout.seconds", CSConstants.DEFAULT_TIMEOUT_SECONDS);
        this.defaultPollingIntervalInMs = ConfigurationManager.getInstance()
                .getFrameworkConfig().getInt("wait.polling.interval.ms", CSConstants.DEFAULT_POLLING_INTERVAL_MS);
    }
    
    /**
     * Constructor with page instance and timeout.
     *
     * @param page             The Playwright Page instance
     * @param timeoutInSeconds The timeout in seconds
     */
    public CSWaitFactory(Page page, int timeoutInSeconds) {
        this.page = page;
        this.defaultTimeoutInSeconds = timeoutInSeconds;
        this.defaultPollingIntervalInMs = ConfigurationManager.getInstance()
                .getFrameworkConfig().getInt("wait.polling.interval.ms", CSConstants.DEFAULT_POLLING_INTERVAL_MS);
    }
    
    /**
     * Full constructor.
     *
     * @param page                   The Playwright Page instance
     * @param timeoutInSeconds       The timeout in seconds
     * @param pollingIntervalInMs    The polling interval in milliseconds
     * @param ignoreExceptions       Whether to ignore exceptions during waiting
     * @param waitForLoad            Whether to wait for page load event
     * @param waitForDomLoaded       Whether to wait for DOMContentLoaded event
     * @param waitForNetworkIdle     Whether to wait for network idle
     */
    public CSWaitFactory(Page page, int timeoutInSeconds, int pollingIntervalInMs,
                      boolean ignoreExceptions, boolean waitForLoad, 
                      boolean waitForDomLoaded, boolean waitForNetworkIdle) {
        this.page = page;
        this.defaultTimeoutInSeconds = timeoutInSeconds;
        this.defaultPollingIntervalInMs = pollingIntervalInMs;
        this.ignoreExceptions = ignoreExceptions;
        this.waitForLoad = waitForLoad;
        this.waitForDomLoaded = waitForDomLoaded;
        this.waitForNetworkIdle = waitForNetworkIdle;
    }
    
    /**
     * Create a wait strategy for element visibility.
     *
     * @return A new visibility wait strategy
     */
    public CSVisibilityWait forVisibility() {
        return (CSVisibilityWait) new CSVisibilityWait(page)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element visibility with custom timeout.
     *
     * @param timeoutInSeconds The timeout in seconds
     * @return A new visibility wait strategy
     */
    public CSVisibilityWait forVisibility(int timeoutInSeconds) {
        return (CSVisibilityWait) new CSVisibilityWait(page)
                .withTimeout(timeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element invisibility.
     *
     * @return A new invisibility wait strategy
     */
    public CSInvisibilityWait forInvisibility() {
        return (CSInvisibilityWait) new CSInvisibilityWait(page)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element invisibility with custom timeout.
     *
     * @param timeoutInSeconds The timeout in seconds
     * @return A new invisibility wait strategy
     */
    public CSInvisibilityWait forInvisibility(int timeoutInSeconds) {
        return (CSInvisibilityWait) new CSInvisibilityWait(page)
                .withTimeout(timeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element to be clickable.
     *
     * @return A new clickable wait strategy
     */
    public CSClickableWait forClickable() {
        return (CSClickableWait) new CSClickableWait(page)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element to be clickable with custom timeout.
     *
     * @param timeoutInSeconds The timeout in seconds
     * @return A new clickable wait strategy
     */
    public CSClickableWait forClickable(int timeoutInSeconds) {
        return (CSClickableWait) new CSClickableWait(page)
                .withTimeout(timeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element presence.
     *
     * @return A new presence wait strategy
     */
    public CSPresenceWait forPresence() {
        return (CSPresenceWait) new CSPresenceWait(page)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element presence with custom timeout.
     *
     * @param timeoutInSeconds The timeout in seconds
     * @return A new presence wait strategy
     */
    public CSPresenceWait forPresence(int timeoutInSeconds) {
        return (CSPresenceWait) new CSPresenceWait(page)
                .withTimeout(timeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element text.
     *
     * @param expectedText The expected text
     * @return A new text wait strategy
     */
    public CSTextWait forText(String expectedText) {
        return (CSTextWait) new CSTextWait(page, expectedText)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element text with match strategy.
     *
     * @param expectedText  The expected text
     * @param matchStrategy The text matching strategy
     * @return A new text wait strategy
     */
    public CSTextWait forText(String expectedText, TextMatchStrategy matchStrategy) {
        return (CSTextWait) new CSTextWait(page, expectedText, matchStrategy)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element text with match strategy and case sensitivity.
     *
     * @param expectedText  The expected text
     * @param matchStrategy The text matching strategy
     * @param caseSensitive Whether to match case sensitively
     * @return A new text wait strategy
     */
    public CSTextWait forText(String expectedText, TextMatchStrategy matchStrategy, boolean caseSensitive) {
        return (CSTextWait) new CSTextWait(page, expectedText, matchStrategy, caseSensitive)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element attribute.
     *
     * @param attributeName The attribute name
     * @param expectedValue The expected attribute value
     * @return A new attribute wait strategy
     */
    public CSAttributeWait forAttribute(String attributeName, String expectedValue) {
        return (CSAttributeWait) new CSAttributeWait(page, attributeName, expectedValue)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element attribute with match strategy.
     *
     * @param attributeName The attribute name
     * @param expectedValue The expected attribute value
     * @param matchStrategy The attribute matching strategy
     * @return A new attribute wait strategy
     */
    public CSAttributeWait forAttribute(String attributeName, String expectedValue, 
                                     AttributeMatchStrategy matchStrategy) {
        return (CSAttributeWait) new CSAttributeWait(page, attributeName, expectedValue, matchStrategy)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a wait strategy for element attribute with match strategy and case sensitivity.
     *
     * @param attributeName The attribute name
     * @param expectedValue The expected attribute value
     * @param matchStrategy The attribute matching strategy
     * @param caseSensitive Whether to match case sensitively
     * @return A new attribute wait strategy
     */
    public CSAttributeWait forAttribute(String attributeName, String expectedValue, 
                                     AttributeMatchStrategy matchStrategy, boolean caseSensitive) {
        return (CSAttributeWait) new CSAttributeWait(page, attributeName, expectedValue, matchStrategy, caseSensitive)
                .withTimeout(defaultTimeoutInSeconds)
                .withPollingInterval(defaultPollingIntervalInMs)
                .ignoreExceptions(ignoreExceptions)
                .withPageLoadWait(waitForLoad, waitForDomLoaded, waitForNetworkIdle);
    }
    
    /**
     * Create a custom wait strategy builder.
     *
     * @return A new custom wait strategy builder
     */
    public CustomWaitBuilder custom() {
        return new CustomWaitBuilder();
    }
    
    /**
     * Set whether to ignore exceptions during waiting.
     *
     * @param ignoreExceptions Whether to ignore exceptions
     * @return This factory instance for chaining
     */
    public CSWaitFactory ignoreExceptions(boolean ignoreExceptions) {
        this.ignoreExceptions = ignoreExceptions;
        return this;
    }
    
    /**
     * Set page load wait settings.
     *
     * @param waitForLoad      Whether to wait for load event
     * @param waitForDomLoaded Whether to wait for DOMContentLoaded event
     * @param waitForNetworkIdle Whether to wait for network idle
     * @return This factory instance for chaining
     */
    public CSWaitFactory withPageLoadWait(boolean waitForLoad, boolean waitForDomLoaded, boolean waitForNetworkIdle) {
        this.waitForLoad = waitForLoad;
        this.waitForDomLoaded = waitForDomLoaded;
        this.waitForNetworkIdle = waitForNetworkIdle;
        return this;
    }
    
    /**
     * Custom wait strategy builder.
     */
    public class CustomWaitBuilder {
        private int timeoutInSeconds = defaultTimeoutInSeconds;
        private int pollingIntervalInMs = defaultPollingIntervalInMs;
        private boolean builderIgnoreExceptions = ignoreExceptions;
        private boolean builderWaitForLoad = waitForLoad;
        private boolean builderWaitForDomLoaded = waitForDomLoaded;
        private boolean builderWaitForNetworkIdle = waitForNetworkIdle;
        
        /**
         * Set the timeout in seconds.
         *
         * @param timeoutInSeconds The timeout in seconds
         * @return This builder instance for chaining
         */
        public CustomWaitBuilder withTimeout(int timeoutInSeconds) {
            this.timeoutInSeconds = timeoutInSeconds;
            return this;
        }
        
        /**
         * Set the polling interval in milliseconds.
         *
         * @param pollingIntervalInMs The polling interval in milliseconds
         * @return This builder instance for chaining
         */
        public CustomWaitBuilder withPollingInterval(int pollingIntervalInMs) {
            this.pollingIntervalInMs = pollingIntervalInMs;
            return this;
        }
        
        /**
         * Set whether to ignore exceptions during waiting.
         *
         * @param ignoreExceptions Whether to ignore exceptions
         * @return This builder instance for chaining
         */
        public CustomWaitBuilder ignoreExceptions(boolean ignoreExceptions) {
            this.builderIgnoreExceptions = ignoreExceptions;
            return this;
        }
        
        /**
         * Set page load wait settings.
         *
         * @param waitForLoad      Whether to wait for load event
         * @param waitForDomLoaded Whether to wait for DOMContentLoaded event
         * @param waitForNetworkIdle Whether to wait for network idle
         * @return This builder instance for chaining
         */
        public CustomWaitBuilder withPageLoadWait(boolean waitForLoad, boolean waitForDomLoaded, 
                                              boolean waitForNetworkIdle) {
            this.builderWaitForLoad = waitForLoad;
            this.builderWaitForDomLoaded = waitForDomLoaded;
            this.builderWaitForNetworkIdle = waitForNetworkIdle;
            return this;
        }
        
        /**
         * Build a visibility wait strategy.
         *
         * @return A new visibility wait strategy
         */
        public CSVisibilityWait forVisibility() {
            return (CSVisibilityWait) new CSVisibilityWait(page)
                    .withTimeout(timeoutInSeconds)
                    .withPollingInterval(pollingIntervalInMs)
                    .ignoreExceptions(builderIgnoreExceptions)
                    .withPageLoadWait(builderWaitForLoad, builderWaitForDomLoaded, builderWaitForNetworkIdle);
        }
        
        /**
         * Build an invisibility wait strategy.
         *
         * @return A new invisibility wait strategy
         */
        public CSInvisibilityWait forInvisibility() {
            return (CSInvisibilityWait) new CSInvisibilityWait(page)
                    .withTimeout(timeoutInSeconds)
                    .withPollingInterval(pollingIntervalInMs)
                    .ignoreExceptions(builderIgnoreExceptions)
                    .withPageLoadWait(builderWaitForLoad, builderWaitForDomLoaded, builderWaitForNetworkIdle);
        }
        
        /**
         * Build a clickable wait strategy.
         *
         * @return A new clickable wait strategy
         */
        public CSClickableWait forClickable() {
            return (CSClickableWait) new CSClickableWait(page)
                    .withTimeout(timeoutInSeconds)
                    .withPollingInterval(pollingIntervalInMs)
                    .ignoreExceptions(builderIgnoreExceptions)
                    .withPageLoadWait(builderWaitForLoad, builderWaitForDomLoaded, builderWaitForNetworkIdle);
        }
        
        /**
         * Build a presence wait strategy.
         *
         * @return A new presence wait strategy
         */
        public CSPresenceWait forPresence() {
            return (CSPresenceWait) new CSPresenceWait(page)
                    .withTimeout(timeoutInSeconds)
                    .withPollingInterval(pollingIntervalInMs)
                    .ignoreExceptions(builderIgnoreExceptions)
                    .withPageLoadWait(builderWaitForLoad, builderWaitForDomLoaded, builderWaitForNetworkIdle);
        }
        
        /**
         * Build a text wait strategy.
         *
         * @param expectedText The expected text
         * @return A new text wait strategy
         */
        public CSTextWait forText(String expectedText) {
            return (CSTextWait) new CSTextWait(page, expectedText)
                    .withTimeout(timeoutInSeconds)
                    .withPollingInterval(pollingIntervalInMs)
                    .ignoreExceptions(builderIgnoreExceptions)
                    .withPageLoadWait(builderWaitForLoad, builderWaitForDomLoaded, builderWaitForNetworkIdle);
        }
        
        /**
         * Build a text wait strategy with match strategy.
         *
         * @param expectedText  The expected text
         * @param matchStrategy The text matching strategy
         * @return A new text wait strategy
         */
        public CSTextWait forText(String expectedText, TextMatchStrategy matchStrategy) {
            return (CSTextWait) new CSTextWait(page, expectedText, matchStrategy)
                    .withTimeout(timeoutInSeconds)
                    .withPollingInterval(pollingIntervalInMs)
                    .ignoreExceptions(builderIgnoreExceptions)
                    .withPageLoadWait(builderWaitForLoad, builderWaitForDomLoaded, builderWaitForNetworkIdle);
        }
        
        /**
         * Build an attribute wait strategy.
         *
         * @param attributeName The attribute name
         * @param expectedValue The expected attribute value
         * @return A new attribute wait strategy
         */
        public CSAttributeWait forAttribute(String attributeName, String expectedValue) {
            return (CSAttributeWait) new CSAttributeWait(page, attributeName, expectedValue)
                    .withTimeout(timeoutInSeconds)
                    .withPollingInterval(pollingIntervalInMs)
                    .ignoreExceptions(builderIgnoreExceptions)
                    .withPageLoadWait(builderWaitForLoad, builderWaitForDomLoaded, builderWaitForNetworkIdle);
        }
        
        /**
         * Build an attribute wait strategy with match strategy.
         *
         * @param attributeName The attribute name
         * @param expectedValue The expected attribute value
         * @param matchStrategy The attribute matching strategy
         * @return A new attribute wait strategy
         */
        public CSAttributeWait forAttribute(String attributeName, String expectedValue, 
                                         AttributeMatchStrategy matchStrategy) {
            return (CSAttributeWait) new CSAttributeWait(page, attributeName, expectedValue, matchStrategy)
                    .withTimeout(timeoutInSeconds)
                    .withPollingInterval(pollingIntervalInMs)
                    .ignoreExceptions(builderIgnoreExceptions)
                    .withPageLoadWait(builderWaitForLoad, builderWaitForDomLoaded, builderWaitForNetworkIdle);
        }
    }
}



RecordingSession.java
--------------------------------

package com.cstestforge.model.recorder;

import com.cstestforge.framework.core.utils.CSLogger;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Model representing a test recording session.
 * This class tracks the entire recording session including all actions,
 * browser information, and metadata.
 */
public class RecordingSession implements Serializable {
    
    private static final long serialVersionUID = 1L;
    private static final CSLogger logger = CSLogger.getLogger(RecordingSession.class);
    
    @JsonProperty("sessionId")
    private String sessionId;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("createdBy")
    private String createdBy;
    
    @JsonProperty("projectId")
    private String projectId;
    
    @JsonProperty("projectName")
    private String projectName;
    
    @JsonProperty("startTime")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS")
    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
    @JsonSerialize(using = LocalDateTimeSerializer.class)
    private LocalDateTime startTime;
    
    @JsonProperty("endTime")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS")
    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
    @JsonSerialize(using = LocalDateTimeSerializer.class)
    private LocalDateTime endTime;
    
    @JsonProperty("lastModifiedTime")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS")
    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
    @JsonSerialize(using = LocalDateTimeSerializer.class)
    private LocalDateTime lastModifiedTime;
    
    @JsonProperty("browserInfo")
    private BrowserInfo browserInfo;
    
    @JsonProperty("tags")
    private Set<String> tags;
    
    @JsonProperty("actions")
    private List<RecordingAction> actions;
    
    @JsonProperty("state")
    private RecorderState state;
    
    @JsonProperty("baseUrl")
    private String baseUrl;
    
    @JsonProperty("frameworkType")
    private String frameworkType;
    
    @JsonProperty("languageType")
    private String languageType;
    
    @JsonProperty("testType")
    private String testType;
    
    @JsonProperty("metadata")
    private Map<String, String> metadata;
    
    @JsonProperty("screenshots")
    private Map<String, String> screenshots;
    
    @JsonProperty("variables")
    private Map<String, Object> variables;
    
    @JsonProperty("stepDefinitions")
    private List<StepDefinition> stepDefinitions;
    
    @JsonIgnore
    private final AtomicInteger actionSequence = new AtomicInteger(0);
    
    /**
     * Default constructor.
     */
    public RecordingSession() {
        this.sessionId = UUID.randomUUID().toString();
        this.startTime = LocalDateTime.now();
        this.lastModifiedTime = LocalDateTime.now();
        this.actions = new CopyOnWriteArrayList<>();
        this.tags = new HashSet<>();
        this.state = RecorderState.CREATED;
        this.metadata = new HashMap<>();
        this.screenshots = new HashMap<>();
        this.variables = new HashMap<>();
        this.stepDefinitions = new ArrayList<>();
    }
    
    /**
     * Constructor with name and browser info.
     *
     * @param name        The name of the recording session
     * @param browserInfo Browser information
     */
    public RecordingSession(String name, BrowserInfo browserInfo) {
        this();
        this.name = name;
        this.browserInfo = browserInfo;
    }
    
    /**
     * Full constructor.
     *
     * @param name           The name of the recording session
     * @param description    Description of the recording session
     * @param createdBy      Creator of the recording session
     * @param projectId      ID of the project this session belongs to
     * @param projectName    Name of the project this session belongs to
     * @param browserInfo    Browser information
     * @param frameworkType  Type of testing framework (e.g., "Selenium", "Playwright")
     * @param languageType   Type of programming language (e.g., "Java", "TypeScript")
     * @param testType       Type of test (e.g., "TestNG", "BDD")
     * @param baseUrl        Base URL for the application under test
     */
    public RecordingSession(String name, String description, String createdBy, 
                          String projectId, String projectName, BrowserInfo browserInfo,
                          String frameworkType, String languageType, String testType, 
                          String baseUrl) {
        this();
        this.name = name;
        this.description = description;
        this.createdBy = createdBy;
        this.projectId = projectId;
        this.projectName = projectName;
        this.browserInfo = browserInfo;
        this.frameworkType = frameworkType;
        this.languageType = languageType;
        this.testType = testType;
        this.baseUrl = baseUrl;
    }
    
    /**
     * Add an action to the recording session.
     *
     * @param action The action to add
     * @return The added action with sequence number assigned
     */
    public RecordingAction addAction(RecordingAction action) {
        if (action == null) {
            throw new IllegalArgumentException("Action cannot be null");
        }
        
        // Set sequence number and timestamp if not already set
        if (action.getSequence() <= 0) {
            action.setSequence(actionSequence.incrementAndGet());
        } else {
            // If the action already has a sequence number, make sure our counter is ahead
            actionSequence.updateAndGet(current -> Math.max(current, action.getSequence()));
        }
        
        if (action.getTimestamp() == null) {
            action.setTimestamp(LocalDateTime.now());
        }
        
        // Add the action and update last modified time
        actions.add(action);
        lastModifiedTime = LocalDateTime.now();
        
        // Log the action addition
        logger.debug("Added action: " + action.getType() + " at sequence " + action.getSequence());
        
        return action;
    }
    
    /**
     * Add multiple actions to the recording session.
     *
     * @param actionList The list of actions to add
     * @return The list of added actions with sequence numbers assigned
     */
    public List<RecordingAction> addActions(List<RecordingAction> actionList) {
        if (actionList == null || actionList.isEmpty()) {
            return Collections.emptyList();
        }
        
        List<RecordingAction> addedActions = new ArrayList<>();
        for (RecordingAction action : actionList) {
            addedActions.add(addAction(action));
        }
        
        return addedActions;
    }
    
    /**
     * Remove an action from the recording session.
     *
     * @param actionId The ID of the action to remove
     * @return True if the action was removed, false otherwise
     */
    public boolean removeAction(String actionId) {
        if (actionId == null || actionId.isEmpty()) {
            return false;
        }
        
        boolean removed = actions.removeIf(action -> actionId.equals(action.getId()));
        
        if (removed) {
            lastModifiedTime = LocalDateTime.now();
            logger.debug("Removed action with ID: " + actionId);
        }
        
        return removed;
    }
    
    /**
     * Remove an action from the recording session by sequence number.
     *
     * @param sequence The sequence number of the action to remove
     * @return True if the action was removed, false otherwise
     */
    public boolean removeActionBySequence(int sequence) {
        if (sequence <= 0) {
            return false;
        }
        
        boolean removed = actions.removeIf(action -> action.getSequence() == sequence);
        
        if (removed) {
            lastModifiedTime = LocalDateTime.now();
            logger.debug("Removed action with sequence: " + sequence);
        }
        
        return removed;
    }
    
    /**
     * Get an action by its ID.
     *
     * @param actionId The ID of the action to retrieve
     * @return The action, or null if not found
     */
    public RecordingAction getAction(String actionId) {
        if (actionId == null || actionId.isEmpty()) {
            return null;
        }
        
        return actions.stream()
                .filter(action -> actionId.equals(action.getId()))
                .findFirst()
                .orElse(null);
    }
    
    /**
     * Get an action by its sequence number.
     *
     * @param sequence The sequence number of the action to retrieve
     * @return The action, or null if not found
     */
    public RecordingAction getActionBySequence(int sequence) {
        if (sequence <= 0) {
            return null;
        }
        
        return actions.stream()
                .filter(action -> action.getSequence() == sequence)
                .findFirst()
                .orElse(null);
    }
    
    /**
     * Update an existing action.
     *
     * @param actionId The ID of the action to update
     * @param updatedAction The updated action
     * @return True if the action was updated, false otherwise
     */
    public boolean updateAction(String actionId, RecordingAction updatedAction) {
        if (actionId == null || actionId.isEmpty() || updatedAction == null) {
            return false;
        }
        
        for (int i = 0; i < actions.size(); i++) {
            RecordingAction action = actions.get(i);
            if (actionId.equals(action.getId())) {
                // Preserve the original sequence number and ID
                updatedAction.setSequence(action.getSequence());
                updatedAction.setId(action.getId());
                
                // Update the timestamp
                updatedAction.setTimestamp(LocalDateTime.now());
                
                // Replace the action
                actions.set(i, updatedAction);
                lastModifiedTime = LocalDateTime.now();
                
                logger.debug("Updated action: " + updatedAction.getType() + 
                            " at sequence " + updatedAction.getSequence());
                
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Reorder actions.
     *
     * @param actionIds List of action IDs in the desired order
     * @return True if the actions were reordered, false otherwise
     */
    public boolean reorderActions(List<String> actionIds) {
        if (actionIds == null || actionIds.isEmpty()) {
            return false;
        }
        
        // Check if all IDs are valid
        Set<String> existingIds = actions.stream()
                .map(RecordingAction::getId)
                .collect(Collectors.toSet());
        
        if (!existingIds.containsAll(actionIds)) {
            return false;
        }
        
        // Create a new ordered list
        List<RecordingAction> orderedActions = new ArrayList<>();
        
        // Add actions in the specified order
        for (String actionId : actionIds) {
            RecordingAction action = getAction(actionId);
            if (action != null) {
                orderedActions.add(action);
            }
        }
        
        // Add any remaining actions
        for (RecordingAction action : actions) {
            if (!actionIds.contains(action.getId())) {
                orderedActions.add(action);
            }
        }
        
        // Update sequence numbers
        for (int i = 0; i < orderedActions.size(); i++) {
            orderedActions.get(i).setSequence(i + 1);
        }
        
        // Replace the actions list
        actions.clear();
        actions.addAll(orderedActions);
        
        // Update the sequence counter
        actionSequence.set(orderedActions.size());
        
        lastModifiedTime = LocalDateTime.now();
        logger.debug("Reordered " + orderedActions.size() + " actions");
        
        return true;
    }
    
    /**
     * Start the recording session.
     */
    public void start() {
        if (state == RecorderState.CREATED || state == RecorderState.PAUSED) {
            state = RecorderState.RECORDING;
            if (startTime == null) {
                startTime = LocalDateTime.now();
            }
            lastModifiedTime = LocalDateTime.now();
            logger.info("Started recording session: " + sessionId);
        } else {
            logger.warn("Cannot start recording session in state: " + state);
        }
    }
    
    /**
     * Pause the recording session.
     */
    public void pause() {
        if (state == RecorderState.RECORDING) {
            state = RecorderState.PAUSED;
            lastModifiedTime = LocalDateTime.now();
            logger.info("Paused recording session: " + sessionId);
        } else {
            logger.warn("Cannot pause recording session in state: " + state);
        }
    }
    
    /**
     * Stop the recording session.
     */
    public void stop() {
        if (state == RecorderState.RECORDING || state == RecorderState.PAUSED) {
            state = RecorderState.COMPLETED;
            endTime = LocalDateTime.now();
            lastModifiedTime = LocalDateTime.now();
            logger.info("Stopped recording session: " + sessionId);
        } else {
            logger.warn("Cannot stop recording session in state: " + state);
        }
    }
    
    /**
     * Add a screenshot to the recording session.
     *
     * @param screenshotId   The ID of the screenshot
     * @param screenshotData The screenshot data as Base64 string
     */
    public void addScreenshot(String screenshotId, String screenshotData) {
        if (screenshotId == null || screenshotId.isEmpty() || 
            screenshotData == null || screenshotData.isEmpty()) {
            return;
        }
        
        screenshots.put(screenshotId, screenshotData);
        lastModifiedTime = LocalDateTime.now();
        logger.debug("Added screenshot: " + screenshotId);
    }
    
    /**
     * Remove a screenshot from the recording session.
     *
     * @param screenshotId The ID of the screenshot to remove
     * @return True if the screenshot was removed, false otherwise
     */
    public boolean removeScreenshot(String screenshotId) {
        if (screenshotId == null || screenshotId.isEmpty()) {
            return false;
        }
        
        String removed = screenshots.remove(screenshotId);
        
        if (removed != null) {
            lastModifiedTime = LocalDateTime.now();
            logger.debug("Removed screenshot: " + screenshotId);
            return true;
        }
        
        return false;
    }
    
    /**
     * Add a step definition to the recording session.
     *
     * @param stepDefinition The step definition to add
     * @return The added step definition
     */
    public StepDefinition addStepDefinition(StepDefinition stepDefinition) {
        if (stepDefinition == null) {
            throw new IllegalArgumentException("Step definition cannot be null");
        }
        
        stepDefinitions.add(stepDefinition);
        lastModifiedTime = LocalDateTime.now();
        logger.debug("Added step definition: " + stepDefinition.getPattern());
        
        return stepDefinition;
    }
    
    /**
     * Remove a step definition from the recording session.
     *
     * @param stepDefinitionId The ID of the step definition to remove
     * @return True if the step definition was removed, false otherwise
     */
    public boolean removeStepDefinition(String stepDefinitionId) {
        if (stepDefinitionId == null || stepDefinitionId.isEmpty()) {
            return false;
        }
        
        boolean removed = stepDefinitions.removeIf(step -> stepDefinitionId.equals(step.getId()));
        
        if (removed) {
            lastModifiedTime = LocalDateTime.now();
            logger.debug("Removed step definition with ID: " + stepDefinitionId);
        }
        
        return removed;
    }
    
    /**
     * Get a step definition by its ID.
     *
     * @param stepDefinitionId The ID of the step definition to retrieve
     * @return The step definition, or null if not found
     */
    public StepDefinition getStepDefinition(String stepDefinitionId) {
        if (stepDefinitionId == null || stepDefinitionId.isEmpty()) {
            return null;
        }
        
        return stepDefinitions.stream()
                .filter(step -> stepDefinitionId.equals(step.getId()))
                .findFirst()
                .orElse(null);
    }
    
    /**
     * Set a variable in the recording session.
     *
     * @param name  The name of the variable
     * @param value The value of the variable
     */
    public void setVariable(String name, Object value) {
        if (name == null || name.isEmpty()) {
            return;
        }
        
        variables.put(name, value);
        lastModifiedTime = LocalDateTime.now();
        logger.debug("Set variable: " + name);
    }
    
    /**
     * Get a variable from the recording session.
     *
     * @param name The name of the variable
     * @return The value of the variable, or null if not found
     */
    public Object getVariable(String name) {
        if (name == null || name.isEmpty()) {
            return null;
        }
        
        return variables.get(name);
    }
    
    /**
     * Remove a variable from the recording session.
     *
     * @param name The name of the variable to remove
     * @return True if the variable was removed, false otherwise
     */
    public boolean removeVariable(String name) {
        if (name == null || name.isEmpty()) {
            return false;
        }
        
        Object removed = variables.remove(name);
        
        if (removed != null) {
            lastModifiedTime = LocalDateTime.now();
            logger.debug("Removed variable: " + name);
            return true;
        }
        
        return false;
    }
    
    /**
     * Add a tag to the recording session.
     *
     * @param tag The tag to add
     * @return True if the tag was added, false if it already existed
     */
    public boolean addTag(String tag) {
        if (tag == null || tag.isEmpty()) {
            return false;
        }
        
        boolean added = tags.add(tag);
        
        if (added) {
            lastModifiedTime = LocalDateTime.now();
            logger.debug("Added tag: " + tag);
        }
        
        return added;
    }
    
    /**
     * Remove a tag from the recording session.
     *
     * @param tag The tag to remove
     * @return True if the tag was removed, false otherwise
     */
    public boolean removeTag(String tag) {
        if (tag == null || tag.isEmpty()) {
            return false;
        }
        
        boolean removed = tags.remove(tag);
        
        if (removed) {
            lastModifiedTime = LocalDateTime.now();
            logger.debug("Removed tag: " + tag);
        }
        
        return removed;
    }
    
    /**
     * Set metadata for the recording session.
     *
     * @param key   The metadata key
     * @param value The metadata value
     */
    public void setMetadata(String key, String value) {
        if (key == null || key.isEmpty()) {
            return;
        }
        
        metadata.put(key, value);
        lastModifiedTime = LocalDateTime.now();
        logger.debug("Set metadata: " + key);
    }
    
    /**
     * Get metadata from the recording session.
     *
     * @param key The metadata key
     * @return The metadata value, or null if not found
     */
    public String getMetadata(String key) {
        if (key == null || key.isEmpty()) {
            return null;
        }
        
        return metadata.get(key);
    }
    
    /**
     * Remove metadata from the recording session.
     *
     * @param key The metadata key to remove
     * @return True if the metadata was removed, false otherwise
     */
    public boolean removeMetadata(String key) {
        if (key == null || key.isEmpty()) {
            return false;
        }
        
        String removed = metadata.remove(key);
        
        if (removed != null) {
            lastModifiedTime = LocalDateTime.now();
            logger.debug("Removed metadata: " + key);
            return true;
        }
        
        return false;
    }
    
    /**
     * Get the duration of the recording session in milliseconds.
     *
     * @return The duration in milliseconds, or -1 if the session is still in progress
     */
    @JsonIgnore
    public long getDurationInMillis() {
        if (startTime == null) {
            return 0;
        }
        
        LocalDateTime end = endTime != null ? endTime : LocalDateTime.now();
        return java.time.Duration.between(startTime, end).toMillis();
    }
    
    /**
     * Get the current sequence number.
     *
     * @return The current sequence number
     */
    @JsonIgnore
    public int getCurrentSequence() {
        return actionSequence.get();
    }
    
    /**
     * Check if the recording session is in progress.
     *
     * @return True if the session is in progress, false otherwise
     */
    @JsonIgnore
    public boolean isInProgress() {
        return state == RecorderState.RECORDING || state == RecorderState.PAUSED;
    }
    
    /**
     * Check if the recording session is completed.
     *
     * @return True if the session is completed, false otherwise
     */
    @JsonIgnore
    public boolean isCompleted() {
        return state == RecorderState.COMPLETED;
    }
    
    /**
     * Get filtered actions by type.
     *
     * @param type The action type to filter by
     * @return List of actions of the specified type
     */
    public List<RecordingAction> getActionsByType(String type) {
        if (type == null || type.isEmpty()) {
            return Collections.emptyList();
        }
        
        return actions.stream()
                .filter(action -> type.equals(action.getType()))
                .collect(Collectors.toList());
    }
    
    /**
     * Get actions within a time range.
     *
     * @param start The start time
     * @param end   The end time
     * @return List of actions within the time range
     */
    public List<RecordingAction> getActionsInTimeRange(LocalDateTime start, LocalDateTime end) {
        if (start == null || end == null || start.isAfter(end)) {
            return Collections.emptyList();
        }
        
        return actions.stream()
                .filter(action -> {
                    LocalDateTime timestamp = action.getTimestamp();
                    return timestamp != null && 
                           (timestamp.isEqual(start) || timestamp.isAfter(start)) && 
                           (timestamp.isEqual(end) || timestamp.isBefore(end));
                })
                .collect(Collectors.toList());
    }
    
    // Getters and setters
    
    public String getSessionId() {
        return sessionId;
    }
    
    public void setSessionId(String sessionId) {
        this.sessionId = sessionId;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public String getCreatedBy() {
        return createdBy;
    }
    
    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
    
    public String getProjectId() {
        return projectId;
    }
    
    public void setProjectId(String projectId) {
        this.projectId = projectId;
    }
    
    public String getProjectName() {
        return projectName;
    }
    
    public void setProjectName(String projectName) {
        this.projectName = projectName;
    }
    
    public LocalDateTime getStartTime() {
        return startTime;
    }
    
    public void setStartTime(LocalDateTime startTime) {
        this.startTime = startTime;
    }
    
    public LocalDateTime getEndTime() {
        return endTime;
    }
    
    public void setEndTime(LocalDateTime endTime) {
        this.endTime = endTime;
    }
    
    public LocalDateTime getLastModifiedTime() {
        return lastModifiedTime;
    }
    
    public void setLastModifiedTime(LocalDateTime lastModifiedTime) {
        this.lastModifiedTime = lastModifiedTime;
    }
    
    public BrowserInfo getBrowserInfo() {
        return browserInfo;
    }
    
    public void setBrowserInfo(BrowserInfo browserInfo) {
        this.browserInfo = browserInfo;
    }
    
    public Set<String> getTags() {
        return tags;
    }
    
    public void setTags(Set<String> tags) {
        this.tags = tags != null ? tags : new HashSet<>();
    }
    
    public List<RecordingAction> getActions() {
        return actions;
    }
    
    public void setActions(List<RecordingAction> actions) {
        this.actions = actions != null ? new CopyOnWriteArrayList<>(actions) : new CopyOnWriteArrayList<>();
        
        // Update the sequence counter
        if (actions != null && !actions.isEmpty()) {
            int maxSequence = actions.stream()
                    .mapToInt(RecordingAction::getSequence)
                    .max()
                    .orElse(0);
            actionSequence.set(maxSequence);
        }
    }
    
    public RecorderState getState() {
        return state;
    }
    
    public void setState(RecorderState state) {
        this.state = state;
    }
    
    public String getBaseUrl() {
        return baseUrl;
    }
    
    public void setBaseUrl(String baseUrl) {
        this.baseUrl = baseUrl;
    }
    
    public String getFrameworkType() {
        return frameworkType;
    }
    
    public void setFrameworkType(String frameworkType) {
        this.frameworkType = frameworkType;
    }
    
    public String getLanguageType() {
        return languageType;
    }
    
    public void setLanguageType(String languageType) {
        this.languageType = languageType;
    }
    
    public String getTestType() {
        return testType;
    }
    
    public void setTestType(String testType) {
        this.testType = testType;
    }
    
    public Map<String, String> getMetadata() {
        return metadata;
    }
    
    public void setMetadata(Map<String, String> metadata) {
        this.metadata = metadata != null ? metadata : new HashMap<>();
    }
    
    public Map<String, String> getScreenshots() {
        return screenshots;
    }
    
    public void setScreenshots(Map<String, String> screenshots) {
        this.screenshots = screenshots != null ? screenshots : new HashMap<>();
    }
    
    public Map<String, Object> getVariables() {
        return variables;
    }
    
    public void setVariables(Map<String, Object> variables) {
        this.variables = variables != null ? variables : new HashMap<>();
    }
    
    public List<StepDefinition> getStepDefinitions() {
        return stepDefinitions;
    }
    
    public void setStepDefinitions(List<StepDefinition> stepDefinitions) {
        this.stepDefinitions = stepDefinitions != null ? stepDefinitions : new ArrayList<>();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RecordingSession that = (RecordingSession) o;
        return Objects.equals(sessionId, that.sessionId);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(sessionId);
    }
    
    @Override
    public String toString() {
        return "RecordingSession{" +
                "sessionId='" + sessionId + '\'' +
                ", name='" + name + '\'' +
                ", state=" + state +
                ", actions=" + actions.size() +
                ", frameworkType='" + frameworkType + '\'' +
                ", languageType='" + languageType + '\'' +
                ", testType='" + testType + '\'' +
                '}';
    }
}


BrowserInfo.java
-------------------------

package com.cstestforge.model.recorder;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * Model class representing browser information for a recording session.
 * Contains detailed information about the browser, operating system, and device used during recording.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class BrowserInfo implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("browserName")
    private String browserName;
    
    @JsonProperty("browserVersion")
    private String browserVersion;
    
    @JsonProperty("userAgent")
    private String userAgent;
    
    @JsonProperty("platform")
    private String platform;
    
    @JsonProperty("platformVersion")
    private String platformVersion;
    
    @JsonProperty("deviceName")
    private String deviceName;
    
    @JsonProperty("deviceType")
    private String deviceType;
    
    @JsonProperty("osName")
    private String osName;
    
    @JsonProperty("osVersion")
    private String osVersion;
    
    @JsonProperty("language")
    private String language;
    
    @JsonProperty("timezone")
    private String timezone;
    
    @JsonProperty("screenWidth")
    private int screenWidth;
    
    @JsonProperty("screenHeight")
    private int screenHeight;
    
    @JsonProperty("viewportWidth")
    private int viewportWidth;
    
    @JsonProperty("viewportHeight")
    private int viewportHeight;
    
    @JsonProperty("colorDepth")
    private int colorDepth;
    
    @JsonProperty("pixelRatio")
    private double pixelRatio;
    
    @JsonProperty("touchSupported")
    private boolean touchSupported;
    
    @JsonProperty("cookiesEnabled")
    private boolean cookiesEnabled;
    
    @JsonProperty("localStorageSupported")
    private boolean localStorageSupported;
    
    @JsonProperty("sessionStorageSupported")
    private boolean sessionStorageSupported;
    
    @JsonProperty("webGLSupported")
    private boolean webGLSupported;
    
    @JsonProperty("orientation")
    private String orientation;
    
    @JsonProperty("networkType")
    private String networkType;
    
    @JsonProperty("networkEffectiveType")
    private String networkEffectiveType;
    
    @JsonProperty("networkDownlink")
    private double networkDownlink;
    
    @JsonProperty("networkRtt")
    private double networkRtt;
    
    @JsonProperty("plugins")
    private Map<String, String> plugins;
    
    @JsonProperty("mimeTypes")
    private Map<String, String> mimeTypes;
    
    @JsonProperty("timestamp")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS")
    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
    @JsonSerialize(using = LocalDateTimeSerializer.class)
    private LocalDateTime timestamp;
    
    @JsonProperty("capabilities")
    private Map<String, Object> capabilities;
    
    @JsonProperty("extensions")
    private Map<String, Object> extensions;
    
    /**
     * Default constructor.
     */
    public BrowserInfo() {
        this.id = java.util.UUID.randomUUID().toString();
        this.timestamp = LocalDateTime.now();
        this.plugins = new HashMap<>();
        this.mimeTypes = new HashMap<>();
        this.capabilities = new HashMap<>();
        this.extensions = new HashMap<>();
    }
    
    /**
     * Constructor with essential browser information.
     *
     * @param browserName    The name of the browser
     * @param browserVersion The version of the browser
     * @param userAgent      The user agent string
     * @param platform       The platform (e.g., Windows, macOS, Linux)
     */
    public BrowserInfo(String browserName, String browserVersion, String userAgent, String platform) {
        this();
        this.browserName = browserName;
        this.browserVersion = browserVersion;
        this.userAgent = userAgent;
        this.platform = platform;
    }
    
    /**
     * Comprehensive constructor with viewport and screen information.
     *
     * @param browserName    The name of the browser
     * @param browserVersion The version of the browser
     * @param userAgent      The user agent string
     * @param platform       The platform
     * @param osName         The operating system name
     * @param osVersion      The operating system version
     * @param screenWidth    The screen width in pixels
     * @param screenHeight   The screen height in pixels
     * @param viewportWidth  The viewport width in pixels
     * @param viewportHeight The viewport height in pixels
     */
    public BrowserInfo(String browserName, String browserVersion, String userAgent, String platform,
                     String osName, String osVersion, int screenWidth, int screenHeight,
                     int viewportWidth, int viewportHeight) {
        this();
        this.browserName = browserName;
        this.browserVersion = browserVersion;
        this.userAgent = userAgent;
        this.platform = platform;
        this.osName = osName;
        this.osVersion = osVersion;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
        this.viewportWidth = viewportWidth;
        this.viewportHeight = viewportHeight;
    }
    
    /**
     * Add a plugin to the browser information.
     *
     * @param name    The plugin name
     * @param version The plugin version
     */
    public void addPlugin(String name, String version) {
        if (name != null && !name.isEmpty()) {
            plugins.put(name, version);
        }
    }
    
    /**
     * Add a MIME type to the browser information.
     *
     * @param type        The MIME type
     * @param description The MIME type description
     */
    public void addMimeType(String type, String description) {
        if (type != null && !type.isEmpty()) {
            mimeTypes.put(type, description);
        }
    }
    
    /**
     * Add a capability to the browser information.
     *
     * @param name  The capability name
     * @param value The capability value
     */
    public void addCapability(String name, Object value) {
        if (name != null && !name.isEmpty()) {
            capabilities.put(name, value);
        }
    }
    
    /**
     * Add an extension to the browser information.
     *
     * @param name  The extension name
     * @param value The extension value
     */
    public void addExtension(String name, Object value) {
        if (name != null && !name.isEmpty()) {
            extensions.put(name, value);
        }
    }
    
    /**
     * Get the aspect ratio of the viewport.
     *
     * @return The aspect ratio as width/height, or 0 if height is 0
     */
    public double getViewportAspectRatio() {
        return viewportHeight > 0 ? (double) viewportWidth / viewportHeight : 0;
    }
    
    /**
     * Check if the browser is a mobile browser.
     *
     * @return True if the browser is a mobile browser, false otherwise
     */
    public boolean isMobileBrowser() {
        if (deviceType != null) {
            return deviceType.equalsIgnoreCase("mobile") || deviceType.equalsIgnoreCase("tablet");
        }
        
        if (userAgent != null) {
            String ua = userAgent.toLowerCase();
            return ua.contains("mobile") || ua.contains("android") || ua.contains("iphone") || 
                   ua.contains("ipad") || ua.contains("ipod");
        }
        
        return false;
    }
    
    /**
     * Check if the browser is a specific browser.
     *
     * @param name The browser name to check (case-insensitive)
     * @return True if the browser matches the given name, false otherwise
     */
    public boolean isBrowser(String name) {
        if (browserName == null || name == null) {
            return false;
        }
        
        return browserName.toLowerCase().contains(name.toLowerCase());
    }
    
    /**
     * Get the browser version as a numeric value.
     *
     * @return The browser version as a double, or 0 if not parseable
     */
    public double getNumericBrowserVersion() {
        if (browserVersion == null || browserVersion.isEmpty()) {
            return 0;
        }
        
        try {
            // Extract the first numeric part of the version string
            String[] parts = browserVersion.split("\\.");
            if (parts.length > 0) {
                String majorVersion = parts[0].replaceAll("[^0-9]", "");
                if (!majorVersion.isEmpty()) {
                    return Double.parseDouble(majorVersion);
                }
            }
            return 0;
        } catch (NumberFormatException e) {
            return 0;
        }
    }
    
    /**
     * Check if the browser supports a specific feature.
     *
     * @param featureName The feature name to check
     * @return True if the feature is supported, false otherwise or if unknown
     */
    public boolean supportsFeature(String featureName) {
        if (featureName == null || featureName.isEmpty()) {
            return false;
        }
        
        switch (featureName.toLowerCase()) {
            case "touch":
                return touchSupported;
            case "cookies":
                return cookiesEnabled;
            case "localstorage":
                return localStorageSupported;
            case "sessionstorage":
                return sessionStorageSupported;
            case "webgl":
                return webGLSupported;
            default:
                // Check capabilities for the feature
                return capabilities.containsKey(featureName) && 
                       capabilities.get(featureName) instanceof Boolean && 
                       (Boolean) capabilities.get(featureName);
        }
    }
    
    /**
     * Create a summary string of the browser information.
     *
     * @return A summary string with browser name, version, and platform
     */
    public String createSummary() {
        StringBuilder summary = new StringBuilder();
        
        if (browserName != null) {
            summary.append(browserName);
            
            if (browserVersion != null) {
                summary.append(" ").append(browserVersion);
            }
        }
        
        if (platform != null) {
            if (summary.length() > 0) {
                summary.append(" on ");
            }
            summary.append(platform);
            
            if (osVersion != null) {
                summary.append(" ").append(osVersion);
            }
        }
        
        if (deviceName != null) {
            if (summary.length() > 0) {
                summary.append(" (");
            }
            summary.append(deviceName);
            if (summary.length() > 0) {
                summary.append(")");
            }
        }
        
        return summary.toString();
    }
    
    // Getters and setters
    
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getBrowserName() {
        return browserName;
    }

    public void setBrowserName(String browserName) {
        this.browserName = browserName;
    }

    public String getBrowserVersion() {
        return browserVersion;
    }

    public void setBrowserVersion(String browserVersion) {
        this.browserVersion = browserVersion;
    }

    public String getUserAgent() {
        return userAgent;
    }

    public void setUserAgent(String userAgent) {
        this.userAgent = userAgent;
    }

    public String getPlatform() {
        return platform;
    }

    public void setPlatform(String platform) {
        this.platform = platform;
    }

    public String getPlatformVersion() {
        return platformVersion;
    }

    public void setPlatformVersion(String platformVersion) {
        this.platformVersion = platformVersion;
    }

    public String getDeviceName() {
        return deviceName;
    }

    public void setDeviceName(String deviceName) {
        this.deviceName = deviceName;
    }

    public String getDeviceType() {
        return deviceType;
    }

    public void setDeviceType(String deviceType) {
        this.deviceType = deviceType;
    }

    public String getOsName() {
        return osName;
    }

    public void setOsName(String osName) {
        this.osName = osName;
    }

    public String getOsVersion() {
        return osVersion;
    }

    public void setOsVersion(String osVersion) {
        this.osVersion = osVersion;
    }

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language;
    }

    public String getTimezone() {
        return timezone;
    }

    public void setTimezone(String timezone) {
        this.timezone = timezone;
    }

    public int getScreenWidth() {
        return screenWidth;
    }

    public void setScreenWidth(int screenWidth) {
        this.screenWidth = screenWidth;
    }

    public int getScreenHeight() {
        return screenHeight;
    }

    public void setScreenHeight(int screenHeight) {
        this.screenHeight = screenHeight;
    }

    public int getViewportWidth() {
        return viewportWidth;
    }

    public void setViewportWidth(int viewportWidth) {
        this.viewportWidth = viewportWidth;
    }

    public int getViewportHeight() {
        return viewportHeight;
    }

    public void setViewportHeight(int viewportHeight) {
        this.viewportHeight = viewportHeight;
    }

    public int getColorDepth() {
        return colorDepth;
    }

    public void setColorDepth(int colorDepth) {
        this.colorDepth = colorDepth;
    }

    public double getPixelRatio() {
        return pixelRatio;
    }

    public void setPixelRatio(double pixelRatio) {
        this.pixelRatio = pixelRatio;
    }

    public boolean isTouchSupported() {
        return touchSupported;
    }

    public void setTouchSupported(boolean touchSupported) {
        this.touchSupported = touchSupported;
    }

    public boolean isCookiesEnabled() {
        return cookiesEnabled;
    }

    public void setCookiesEnabled(boolean cookiesEnabled) {
        this.cookiesEnabled = cookiesEnabled;
    }

    public boolean isLocalStorageSupported() {
        return localStorageSupported;
    }

    public void setLocalStorageSupported(boolean localStorageSupported) {
        this.localStorageSupported = localStorageSupported;
    }

    public boolean isSessionStorageSupported() {
        return sessionStorageSupported;
    }

    public void setSessionStorageSupported(boolean sessionStorageSupported) {
        this.sessionStorageSupported = sessionStorageSupported;
    }

    public boolean isWebGLSupported() {
        return webGLSupported;
    }

    public void setWebGLSupported(boolean webGLSupported) {
        this.webGLSupported = webGLSupported;
    }

    public String getOrientation() {
        return orientation;
    }

    public void setOrientation(String orientation) {
        this.orientation = orientation;
    }

    public String getNetworkType() {
        return networkType;
    }

    public void setNetworkType(String networkType) {
        this.networkType = networkType;
    }

    public String getNetworkEffectiveType() {
        return networkEffectiveType;
    }

    public void setNetworkEffectiveType(String networkEffectiveType) {
        this.networkEffectiveType = networkEffectiveType;
    }

    public double getNetworkDownlink() {
        return networkDownlink;
    }

    public void setNetworkDownlink(double networkDownlink) {
        this.networkDownlink = networkDownlink;
    }

    public double getNetworkRtt() {
        return networkRtt;
    }

    public void setNetworkRtt(double networkRtt) {
        this.networkRtt = networkRtt;
    }

    public Map<String, String> getPlugins() {
        return plugins;
    }

    public void setPlugins(Map<String, String> plugins) {
        this.plugins = plugins != null ? plugins : new HashMap<>();
    }

    public Map<String, String> getMimeTypes() {
        return mimeTypes;
    }

    public void setMimeTypes(Map<String, String> mimeTypes) {
        this.mimeTypes = mimeTypes != null ? mimeTypes : new HashMap<>();
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public Map<String, Object> getCapabilities() {
        return capabilities;
    }

    public void setCapabilities(Map<String, Object> capabilities) {
        this.capabilities = capabilities != null ? capabilities : new HashMap<>();
    }

    public Map<String, Object> getExtensions() {
        return extensions;
    }

    public void setExtensions(Map<String, Object> extensions) {
        this.extensions = extensions != null ? extensions : new HashMap<>();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BrowserInfo that = (BrowserInfo) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "BrowserInfo{" +
                "browserName='" + browserName + '\'' +
                ", browserVersion='" + browserVersion + '\'' +
                ", platform='" + platform + '\'' +
                ", deviceType='" + deviceType + '\'' +
                ", screenWidth=" + screenWidth +
                ", screenHeight=" + screenHeight +
                '}';
    }
}


RecordingAction.java
----------------------------------

package com.cstestforge.model.recorder;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

/**
 * Model class representing a recorded action during a test recording session.
 * Captures all details about a specific action including type, target element, parameters, etc.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class RecordingAction implements Serializable, Comparable<RecordingAction> {
    
    private static final long serialVersionUID = 1L;
    
    /**
     * Action types enumeration
     */
    public static final class Types {
        public static final String NAVIGATE = "navigate";
        public static final String CLICK = "click";
        public static final String DOUBLE_CLICK = "doubleClick";
        public static final String RIGHT_CLICK = "rightClick";
        public static final String TYPE = "type";
        public static final String CLEAR = "clear";
        public static final String SELECT = "select";
        public static final String DRAG_AND_DROP = "dragAndDrop";
        public static final String HOVER = "hover";
        public static final String CHECK = "check";
        public static final String UNCHECK = "uncheck";
        public static final String PRESS_KEY = "pressKey";
        public static final String UPLOAD_FILE = "uploadFile";
        public static final String SCREENSHOT = "screenshot";
        public static final String WAIT = "wait";
        public static final String SCROLL = "scroll";
        public static final String ASSERT_ELEMENT = "assertElement";
        public static final String ASSERT_TEXT = "assertText";
        public static final String ASSERT_ATTRIBUTE = "assertAttribute";
        public static final String ASSERT_URL = "assertUrl";
        public static final String ASSERT_TITLE = "assertTitle";
        public static final String EXECUTE_SCRIPT = "executeScript";
        public static final String SET_VARIABLE = "setVariable";
        public static final String IF_CONDITION = "ifCondition";
        public static final String LOOP = "loop";
        public static final String DATA_DRIVEN = "dataDriven";
        public static final String SWITCH_FRAME = "switchFrame";
        public static final String SWITCH_WINDOW = "switchWindow";
        public static final String CUSTOM = "custom";
        public static final String API_REQUEST = "apiRequest";
        public static final String COMMENT = "comment";
        public static final String GROUP_START = "groupStart";
        public static final String GROUP_END = "groupEnd";
        
        // Prevent instantiation
        private Types() {}
    }
    
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("sessionId")
    private String sessionId;
    
    @JsonProperty("type")
    private String type;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("sequence")
    private int sequence;
    
    @JsonProperty("timestamp")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS")
    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
    @JsonSerialize(using = LocalDateTimeSerializer.class)
    private LocalDateTime timestamp;
    
    @JsonProperty("url")
    private String url;
    
    @JsonProperty("elementInfo")
    private ElementInfo elementInfo;
    
    @JsonProperty("targetElementInfo")
    private ElementInfo targetElementInfo;
    
    @JsonProperty("value")
    private String value;
    
    @JsonProperty("keys")
    private String keys;
    
    @JsonProperty("parameters")
    private Map<String, Object> parameters;
    
    @JsonProperty("screenshotId")
    private String screenshotId;
    
    @JsonProperty("screenshotBefore")
    private String screenshotBefore;
    
    @JsonProperty("screenshotAfter")
    private String screenshotAfter;
    
    @JsonProperty("success")
    private Boolean success;
    
    @JsonProperty("error")
    private String error;
    
    @JsonProperty("duration")
    private Long duration;
    
    @JsonProperty("parentId")
    private String parentId;
    
    @JsonProperty("groupId")
    private String groupId;
    
    @JsonProperty("config")
    private ActionConfig config;
    
    @JsonProperty("disabled")
    private boolean disabled;
    
    @JsonProperty("metadata")
    private Map<String, String> metadata;
    
    /**
     * Default constructor.
     */
    public RecordingAction() {
        this.id = UUID.randomUUID().toString();
        this.timestamp = LocalDateTime.now();
        this.parameters = new HashMap<>();
        this.metadata = new HashMap<>();
        this.disabled = false;
    }
    
    /**
     * Constructor with type.
     *
     * @param type The action type
     */
    public RecordingAction(String type) {
        this();
        this.type = type;
    }
    
    /**
     * Constructor with type and element info.
     *
     * @param type        The action type
     * @param elementInfo The element information
     */
    public RecordingAction(String type, ElementInfo elementInfo) {
        this();
        this.type = type;
        this.elementInfo = elementInfo;
    }
    
    /**
     * Full constructor.
     *
     * @param type         The action type
     * @param description  Description of the action
     * @param elementInfo  The element information
     * @param value        The value for the action (e.g., text to type)
     * @param parameters   Additional parameters for the action
     */
    public RecordingAction(String type, String description, ElementInfo elementInfo, 
                         String value, Map<String, Object> parameters) {
        this();
        this.type = type;
        this.description = description;
        this.elementInfo = elementInfo;
        this.value = value;
        if (parameters != null) {
            this.parameters.putAll(parameters);
        }
    }
    
    /**
     * Add a parameter to the action.
     *
     * @param name  The parameter name
     * @param value The parameter value
     */
    public void addParameter(String name, Object value) {
        if (name != null && !name.isEmpty()) {
            parameters.put(name, value);
        }
    }
    
    /**
     * Get a parameter value.
     *
     * @param name The parameter name
     * @param <T>  The expected parameter type
     * @return The parameter value, or null if not found
     */
    @SuppressWarnings("unchecked")
    public <T> T getParameterValue(String name) {
        if (name == null || name.isEmpty() || !parameters.containsKey(name)) {
            return null;
        }
        
        try {
            return (T) parameters.get(name);
        } catch (ClassCastException e) {
            return null;
        }
    }
    
    /**
     * Add metadata to the action.
     *
     * @param key   The metadata key
     * @param value The metadata value
     */
    public void addMetadata(String key, String value) {
        if (key != null && !key.isEmpty()) {
            metadata.put(key, value);
        }
    }
    
    /**
     * Check if this action is a navigation action.
     *
     * @return True if this is a navigation action, false otherwise
     */
    @JsonIgnore
    public boolean isNavigationAction() {
        return Types.NAVIGATE.equals(type);
    }
    
    /**
     * Check if this action is an input action.
     *
     * @return True if this is an input action, false otherwise
     */
    @JsonIgnore
    public boolean isInputAction() {
        return Types.TYPE.equals(type) || Types.CLEAR.equals(type) || 
               Types.SELECT.equals(type) || Types.CHECK.equals(type) || 
               Types.UNCHECK.equals(type) || Types.PRESS_KEY.equals(type) || 
               Types.UPLOAD_FILE.equals(type);
    }
    
    /**
     * Check if this action is a click action.
     *
     * @return True if this is a click action, false otherwise
     */
    @JsonIgnore
    public boolean isClickAction() {
        return Types.CLICK.equals(type) || Types.DOUBLE_CLICK.equals(type) || 
               Types.RIGHT_CLICK.equals(type);
    }
    
    /**
     * Check if this action is an assertion action.
     *
     * @return True if this is an assertion action, false otherwise
     */
    @JsonIgnore
    public boolean isAssertionAction() {
        return Types.ASSERT_ELEMENT.equals(type) || Types.ASSERT_TEXT.equals(type) || 
               Types.ASSERT_ATTRIBUTE.equals(type) || Types.ASSERT_URL.equals(type) || 
               Types.ASSERT_TITLE.equals(type);
    }
    
    /**
     * Check if this action is a control flow action.
     *
     * @return True if this is a control flow action, false otherwise
     */
    @JsonIgnore
    public boolean isControlFlowAction() {
        return Types.IF_CONDITION.equals(type) || Types.LOOP.equals(type) || 
               Types.DATA_DRIVEN.equals(type) || Types.GROUP_START.equals(type) || 
               Types.GROUP_END.equals(type);
    }
    
    /**
     * Check if this action requires an element.
     *
     * @return True if this action requires an element, false otherwise
     */
    @JsonIgnore
    public boolean requiresElement() {
        return !Types.NAVIGATE.equals(type) && !Types.WAIT.equals(type) && 
               !Types.SCREENSHOT.equals(type) && !Types.ASSERT_URL.equals(type) && 
               !Types.ASSERT_TITLE.equals(type) && !Types.EXECUTE_SCRIPT.equals(type) && 
               !Types.SET_VARIABLE.equals(type) && !Types.IF_CONDITION.equals(type) && 
               !Types.LOOP.equals(type) && !Types.DATA_DRIVEN.equals(type) && 
               !Types.SWITCH_WINDOW.equals(type) && !Types.API_REQUEST.equals(type) && 
               !Types.COMMENT.equals(type) && !Types.GROUP_START.equals(type) && 
               !Types.GROUP_END.equals(type);
    }
    
    /**
     * Generate a human-readable description of the action if not already set.
     *
     * @return A human-readable description of the action
     */
    @JsonIgnore
    public String generateDescription() {
        if (description != null && !description.isEmpty()) {
            return description;
        }
        
        StringBuilder desc = new StringBuilder();
        
        switch (type) {
            case Types.NAVIGATE:
                desc.append("Navigate to ").append(url);
                break;
            case Types.CLICK:
                desc.append("Click on ");
                appendElementDescription(desc);
                break;
            case Types.DOUBLE_CLICK:
                desc.append("Double-click on ");
                appendElementDescription(desc);
                break;
            case Types.RIGHT_CLICK:
                desc.append("Right-click on ");
                appendElementDescription(desc);
                break;
            case Types.TYPE:
                desc.append("Type '").append(value).append("' into ");
                appendElementDescription(desc);
                break;
            case Types.CLEAR:
                desc.append("Clear ");
                appendElementDescription(desc);
                break;
            case Types.SELECT:
                desc.append("Select '").append(value).append("' from ");
                appendElementDescription(desc);
                break;
            case Types.DRAG_AND_DROP:
                desc.append("Drag ");
                appendElementDescription(desc);
                desc.append(" and drop to target");
                break;
            case Types.HOVER:
                desc.append("Hover over ");
                appendElementDescription(desc);
                break;
            case Types.CHECK:
                desc.append("Check ");
                appendElementDescription(desc);
                break;
            case Types.UNCHECK:
                desc.append("Uncheck ");
                appendElementDescription(desc);
                break;
            case Types.PRESS_KEY:
                desc.append("Press key ").append(keys);
                break;
            case Types.UPLOAD_FILE:
                desc.append("Upload file to ");
                appendElementDescription(desc);
                break;
            case Types.SCREENSHOT:
                desc.append("Take screenshot");
                break;
            case Types.WAIT:
                Object waitTime = parameters.get("waitTime");
                if (waitTime != null) {
                    desc.append("Wait for ").append(waitTime).append(" ms");
                } else {
                    desc.append("Wait for condition");
                }
                break;
            case Types.SCROLL:
                desc.append("Scroll ");
                if (elementInfo != null) {
                    desc.append("to ");
                    appendElementDescription(desc);
                } else {
                    Object direction = parameters.get("direction");
                    if (direction != null) {
                        desc.append(direction.toString());
                    } else {
                        desc.append("by coordinates");
                    }
                }
                break;
            case Types.ASSERT_ELEMENT:
                desc.append("Assert element ");
                appendElementDescription(desc);
                Object condition = parameters.get("condition");
                if (condition != null) {
                    desc.append(" ").append(condition);
                }
                break;
            case Types.ASSERT_TEXT:
                desc.append("Assert text '").append(value).append("'");
                if (elementInfo != null) {
                    desc.append(" in ");
                    appendElementDescription(desc);
                }
                break;
            case Types.ASSERT_ATTRIBUTE:
                desc.append("Assert attribute of ");
                appendElementDescription(desc);
                break;
            case Types.ASSERT_URL:
                desc.append("Assert URL ").append(parameters.get("condition")).append(" '")
                    .append(url).append("'");
                break;
            case Types.ASSERT_TITLE:
                desc.append("Assert title ").append(parameters.get("condition")).append(" '")
                    .append(value).append("'");
                break;
            case Types.EXECUTE_SCRIPT:
                desc.append("Execute JavaScript");
                break;
            case Types.SET_VARIABLE:
                desc.append("Set variable '").append(parameters.get("name")).append("'");
                break;
            case Types.IF_CONDITION:
                desc.append("If condition");
                break;
            case Types.LOOP:
                desc.append("Loop");
                Object loopType = parameters.get("loopType");
                if (loopType != null) {
                    desc.append(" (").append(loopType).append(")");
                }
                break;
            case Types.DATA_DRIVEN:
                desc.append("Data-driven test");
                break;
            case Types.SWITCH_FRAME:
                desc.append("Switch to frame");
                if (elementInfo != null) {
                    desc.append(" ");
                    appendElementDescription(desc);
                }
                break;
            case Types.SWITCH_WINDOW:
                desc.append("Switch to window");
                break;
            case Types.API_REQUEST:
                desc.append("API request");
                Object method = parameters.get("method");
                Object endpoint = parameters.get("endpoint");
                if (method != null && endpoint != null) {
                    desc.append(" ").append(method).append(" ").append(endpoint);
                }
                break;
            case Types.COMMENT:
                desc.append("Comment: ").append(value);
                break;
            case Types.GROUP_START:
                desc.append("Start group");
                if (value != null) {
                    desc.append(": ").append(value);
                }
                break;
            case Types.GROUP_END:
                desc.append("End group");
                if (value != null) {
                    desc.append(": ").append(value);
                }
                break;
            case Types.CUSTOM:
                desc.append("Custom action");
                if (value != null) {
                    desc.append(": ").append(value);
                }
                break;
            default:
                desc.append("Unknown action type: ").append(type);
                break;
        }
        
        return desc.toString();
    }
    
    /**
     * Append element description to a StringBuilder.
     *
     * @param sb The StringBuilder to append to
     */
    private void appendElementDescription(StringBuilder sb) {
        if (elementInfo == null) {
            sb.append("element");
            return;
        }
        
        if (elementInfo.getElementName() != null && !elementInfo.getElementName().isEmpty()) {
            sb.append(elementInfo.getElementName());
        } else if (elementInfo.getTagName() != null && !elementInfo.getTagName().isEmpty()) {
            if (elementInfo.getText() != null && !elementInfo.getText().isEmpty()) {
                sb.append(elementInfo.getTagName()).append(" with text '")
                  .append(limitText(elementInfo.getText(), 30)).append("'");
            } else if (elementInfo.getId() != null && !elementInfo.getId().isEmpty()) {
                sb.append(elementInfo.getTagName()).append(" with ID '")
                  .append(elementInfo.getId()).append("'");
            } else if (elementInfo.getClassName() != null && !elementInfo.getClassName().isEmpty()) {
                sb.append(elementInfo.getTagName()).append(" with class '")
                  .append(elementInfo.getClassName()).append("'");
            } else {
                sb.append(elementInfo.getTagName()).append(" element");
            }
        } else {
            sb.append("element");
        }
    }
    
    /**
     * Limit text to a specified length.
     *
     * @param text   The text to limit
     * @param length The maximum length
     * @return The limited text
     */
    private String limitText(String text, int length) {
        if (text == null || text.length() <= length) {
            return text;
        }
        
        return text.substring(0, length - 3) + "...";
    }
    
    /**
     * Create a copy of this action.
     *
     * @return A copy of this action
     */
    public RecordingAction copy() {
        RecordingAction copy = new RecordingAction();
        copy.type = this.type;
        copy.description = this.description;
        copy.sessionId = this.sessionId;
        copy.sequence = this.sequence;
        copy.timestamp = this.timestamp;
        copy.url = this.url;
        copy.elementInfo = this.elementInfo != null ? this.elementInfo.copy() : null;
        copy.targetElementInfo = this.targetElementInfo != null ? this.targetElementInfo.copy() : null;
        copy.value = this.value;
        copy.keys = this.keys;
        copy.parameters.putAll(this.parameters);
        copy.screenshotId = this.screenshotId;
        copy.screenshotBefore = this.screenshotBefore;
        copy.screenshotAfter = this.screenshotAfter;
        copy.success = this.success;
        copy.error = this.error;
        copy.duration = this.duration;
        copy.parentId = this.parentId;
        copy.groupId = this.groupId;
        copy.config = this.config;
        copy.disabled = this.disabled;
        copy.metadata.putAll(this.metadata);
        
        return copy;
    }
    
    /**
     * Check if the action has screenshots.
     *
     * @return True if the action has screenshots, false otherwise
     */
    @JsonIgnore
    public boolean hasScreenshots() {
        return screenshotId != null || screenshotBefore != null || screenshotAfter != null;
    }
    
    /**
     * Check if the action has errors.
     *
     * @return True if the action has errors, false otherwise
     */
    @JsonIgnore
    public boolean hasError() {
        return error != null && !error.isEmpty();
    }
    
    /**
     * Mark the action as successful.
     *
     * @param durationMs The duration of the action in milliseconds
     */
    public void markSuccess(long durationMs) {
        this.success = true;
        this.duration = durationMs;
    }
    
    /**
     * Mark the action as failed.
     *
     * @param errorMessage The error message
     * @param durationMs   The duration of the action in milliseconds
     */
    public void markFailed(String errorMessage, long durationMs) {
        this.success = false;
        this.error = errorMessage;
        this.duration = durationMs;
    }
    
    /**
     * Get the frame target for frame switch actions.
     *
     * @return The frame target, or null if not a frame switch action
     */
    @JsonIgnore
    public Object getFrameTarget() {
        if (!Types.SWITCH_FRAME.equals(type)) {
            return null;
        }
        
        if (elementInfo != null) {
            return elementInfo;
        }
        
        return parameters.get("frameIndex");
    }
    
    /**
     * Convert the action to a different type.
     *
     * @param newType The new action type
     * @return A new action of the specified type
     */
    public RecordingAction convertTo(String newType) {
        RecordingAction converted = copy();
        converted.id = UUID.randomUUID().toString();
        converted.type = newType;
        converted.description = null; // Will be regenerated
        
        return converted;
    }
    
    /**
     * Compare this action to another action by sequence number.
     *
     * @param other The other action to compare to
     * @return The comparison result
     */
    @Override
    public int compareTo(RecordingAction other) {
        return Integer.compare(this.sequence, other.sequence);
    }
    
    // Getters and setters
    
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getSessionId() {
        return sessionId;
    }

    public void setSessionId(String sessionId) {
        this.sessionId = sessionId;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public int getSequence() {
        return sequence;
    }

    public void setSequence(int sequence) {
        this.sequence = sequence;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public ElementInfo getElementInfo() {
        return elementInfo;
    }

    public void setElementInfo(ElementInfo elementInfo) {
        this.elementInfo = elementInfo;
    }

    public ElementInfo getTargetElementInfo() {
        return targetElementInfo;
    }

    public void setTargetElementInfo(ElementInfo targetElementInfo) {
        this.targetElementInfo = targetElementInfo;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public String getKeys() {
        return keys;
    }

    public void setKeys(String keys) {
        this.keys = keys;
    }

    public Map<String, Object> getParameters() {
        return parameters;
    }

    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters != null ? parameters : new HashMap<>();
    }

    public String getScreenshotId() {
        return screenshotId;
    }

    public void setScreenshotId(String screenshotId) {
        this.screenshotId = screenshotId;
    }

    public String getScreenshotBefore() {
        return screenshotBefore;
    }

    public void setScreenshotBefore(String screenshotBefore) {
        this.screenshotBefore = screenshotBefore;
    }

    public String getScreenshotAfter() {
        return screenshotAfter;
    }

    public void setScreenshotAfter(String screenshotAfter) {
        this.screenshotAfter = screenshotAfter;
    }

    public Boolean getSuccess() {
        return success;
    }

    public void setSuccess(Boolean success) {
        this.success = success;
    }

    public String getError() {
        return error;
    }

    public void setError(String error) {
        this.error = error;
    }

    public Long getDuration() {
        return duration;
    }

    public void setDuration(Long duration) {
        this.duration = duration;
    }

    public String getParentId() {
        return parentId;
    }

    public void setParentId(String parentId) {
        this.parentId = parentId;
    }

    public String getGroupId() {
        return groupId;
    }

    public void setGroupId(String groupId) {
        this.groupId = groupId;
    }

    public ActionConfig getConfig() {
        return config;
    }

    public void setConfig(ActionConfig config) {
        this.config = config;
    }

    public boolean isDisabled() {
        return disabled;
    }

    public void setDisabled(boolean disabled) {
        this.disabled = disabled;
    }

    public Map<String, String> getMetadata() {
        return metadata;
    }

    public void setMetadata(Map<String, String> metadata) {
        this.metadata = metadata != null ? metadata : new HashMap<>();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RecordingAction that = (RecordingAction) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "RecordingAction{" +
                "id='" + id + '\'' +
                ", type='" + type + '\'' +
                ", sequence=" + sequence +
                ", description='" + (description != null ? description : generateDescription()) + '\'' +
                '}';
    }
}



ElementInfo.java
-------------------------

package com.cstestforge.model.recorder;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

/**
 * Model class representing information about a DOM element during recording.
 * Contains all the necessary information to identify and interact with an element.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ElementInfo implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    /**
     * Selector types enumeration
     */
    public static final class SelectorTypes {
        public static final String XPATH = "xpath";
        public static final String CSS = "css";
        public static final String ID = "id";
        public static final String NAME = "name";
        public static final String LINK_TEXT = "linkText";
        public static final String PARTIAL_LINK_TEXT = "partialLinkText";
        public static final String TAG_NAME = "tagName";
        public static final String CLASS_NAME = "className";
        public static final String ACCESSIBILITY_ID = "accessibilityId";
        public static final String DATA_TEST_ID = "dataTestId";
        public static final String SMART = "smart";
        public static final String TEXT = "text";
        public static final String PLAYWRIGHT_ROLE = "role";
        
        // Prevent instantiation
        private SelectorTypes() {}
    }
    
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("elementName")
    private String elementName;
    
    @JsonProperty("tagName")
    private String tagName;
    
    @JsonProperty("xpath")
    private String xpath;
    
    @JsonProperty("css")
    private String css;
    
    @JsonProperty("elementId")
    private String elementId;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("className")
    private String className;
    
    @JsonProperty("linkText")
    private String linkText;
    
    @JsonProperty("accessibilityId")
    private String accessibilityId;
    
    @JsonProperty("dataTestId")
    private String dataTestId;
    
    @JsonProperty("text")
    private String text;
    
    @JsonProperty("value")
    private String value;
    
    @JsonProperty("placeholder")
    private String placeholder;
    
    @JsonProperty("index")
    private Integer index;
    
    @JsonProperty("x")
    private Integer x;
    
    @JsonProperty("y")
    private Integer y;
    
    @JsonProperty("width")
    private Integer width;
    
    @JsonProperty("height")
    private Integer height;
    
    @JsonProperty("centerX")
    private Integer centerX;
    
    @JsonProperty("centerY")
    private Integer centerY;
    
    @JsonProperty("visible")
    private Boolean visible;
    
    @JsonProperty("enabled")
    private Boolean enabled;
    
    @JsonProperty("selected")
    private Boolean selected;
    
    @JsonProperty("checked")
    private Boolean checked;
    
    @JsonProperty("displayed")
    private Boolean displayed;
    
    @JsonProperty("attributes")
    private Map<String, String> attributes;
    
    @JsonProperty("styles")
    private Map<String, String> styles;
    
    @JsonProperty("role")
    private String role;
    
    @JsonProperty("selectors")
    private Map<String, String> selectors;
    
    @JsonProperty("selectedSelector")
    private String selectedSelector;
    
    @JsonProperty("screenshot")
    private String screenshot;
    
    @JsonProperty("fingerprint")
    private String fingerprint;
    
    @JsonProperty("isSelfHealing")
    private Boolean isSelfHealing;
    
    @JsonProperty("locatorStrategies")
    private List<LocatorStrategy> locatorStrategies;
    
    /**
     * Default constructor.
     */
    public ElementInfo() {
        this.id = UUID.randomUUID().toString();
        this.attributes = new HashMap<>();
        this.styles = new HashMap<>();
        this.selectors = new HashMap<>();
        this.locatorStrategies = new ArrayList<>();
        this.isSelfHealing = false;
    }
    
    /**
     * Constructor with tag name and ID.
     *
     * @param tagName The tag name of the element
     * @param elementId The ID of the element
     */
    public ElementInfo(String tagName, String elementId) {
        this();
        this.tagName = tagName;
        this.elementId = elementId;
    }
    
    /**
     * Full constructor with essential properties.
     *
     * @param tagName    The tag name of the element
     * @param xpath      The XPath of the element
     * @param css        The CSS selector of the element
     * @param elementId  The ID of the element
     * @param className  The class name of the element
     * @param text       The text of the element
     */
    public ElementInfo(String tagName, String xpath, String css, String elementId, 
                     String className, String text) {
        this();
        this.tagName = tagName;
        this.xpath = xpath;
        this.css = css;
        this.elementId = elementId;
        this.className = className;
        this.text = text;
        
        // Initialize selectors map
        if (xpath != null && !xpath.isEmpty()) {
            selectors.put(SelectorTypes.XPATH, xpath);
        }
        
        if (css != null && !css.isEmpty()) {
            selectors.put(SelectorTypes.CSS, css);
        }
        
        if (elementId != null && !elementId.isEmpty()) {
            selectors.put(SelectorTypes.ID, elementId);
        }
        
        if (className != null && !className.isEmpty()) {
            selectors.put(SelectorTypes.CLASS_NAME, className);
        }
        
        // Set the selected selector based on availability
        if (elementId != null && !elementId.isEmpty()) {
            selectedSelector = SelectorTypes.ID;
        } else if (css != null && !css.isEmpty()) {
            selectedSelector = SelectorTypes.CSS;
        } else if (xpath != null && !xpath.isEmpty()) {
            selectedSelector = SelectorTypes.XPATH;
        }
    }
    
    /**
     * Add an attribute to the element.
     *
     * @param name  The attribute name
     * @param value The attribute value
     */
    public void addAttribute(String name, String value) {
        if (name != null && !name.isEmpty()) {
            attributes.put(name, value);
        }
    }
    
    /**
     * Add a style to the element.
     *
     * @param name  The style name
     * @param value The style value
     */
    public void addStyle(String name, String value) {
        if (name != null && !name.isEmpty()) {
            styles.put(name, value);
        }
    }
    
    /**
     * Add a selector to the element.
     *
     * @param type  The selector type
     * @param value The selector value
     */
    public void addSelector(String type, String value) {
        if (type != null && !type.isEmpty() && value != null && !value.isEmpty()) {
            selectors.put(type, value);
        }
    }
    
    /**
     * Add a locator strategy to the element.
     *
     * @param strategy The locator strategy
     */
    public void addLocatorStrategy(LocatorStrategy strategy) {
        if (strategy != null) {
            locatorStrategies.add(strategy);
        }
    }
    
    /**
     * Get the selector value for the selected selector type.
     *
     * @return The selector value, or null if no selector is selected
     */
    @JsonIgnore
    public String getSelectedSelectorValue() {
        if (selectedSelector == null || selectedSelector.isEmpty()) {
            return null;
        }
        
        return selectors.get(selectedSelector);
    }
    
    /**
     * Get the selector value for a specific selector type.
     *
     * @param selectorType The selector type
     * @return The selector value, or null if not found
     */
    public String getSelectorValue(String selectorType) {
        if (selectorType == null || selectorType.isEmpty()) {
            return null;
        }
        
        return selectors.get(selectorType);
    }
    
    /**
     * Check if the element has a specific selector type.
     *
     * @param selectorType The selector type
     * @return True if the element has the selector type, false otherwise
     */
    public boolean hasSelector(String selectorType) {
        if (selectorType == null || selectorType.isEmpty()) {
            return false;
        }
        
        return selectors.containsKey(selectorType) && 
               selectors.get(selectorType) != null && 
               !selectors.get(selectorType).isEmpty();
    }
    
    /**
     * Get the element's ID attribute value.
     *
     * @return The ID attribute value, or null if not set
     */
    public String getId() {
        return elementId;
    }
    
    /**
     * Get the best available locator for the element.
     *
     * @param preferredType The preferred selector type
     * @return A LocatorStrategy object, or null if no suitable locator is available
     */
    public LocatorStrategy getBestLocator(String preferredType) {
        if (locatorStrategies != null && !locatorStrategies.isEmpty()) {
            // First try to find the preferred type
            if (preferredType != null && !preferredType.isEmpty()) {
                for (LocatorStrategy strategy : locatorStrategies) {
                    if (preferredType.equals(strategy.getType())) {
                        return strategy;
                    }
                }
            }
            
            // Then try to find the highest ranked strategy
            LocatorStrategy best = null;
            double highestRank = -1;
            
            for (LocatorStrategy strategy : locatorStrategies) {
                if (strategy.getRank() > highestRank) {
                    highestRank = strategy.getRank();
                    best = strategy;
                }
            }
            
            return best;
        }
        
        // If no locator strategies are available, create one from selectors
        if (selectedSelector != null && !selectedSelector.isEmpty()) {
            String value = selectors.get(selectedSelector);
            if (value != null && !value.isEmpty()) {
                return new LocatorStrategy(selectedSelector, value, 1.0);
            }
        }
        
        // Try to create a locator strategy from element properties
        if (elementId != null && !elementId.isEmpty()) {
            return new LocatorStrategy(SelectorTypes.ID, elementId, 0.9);
        } else if (css != null && !css.isEmpty()) {
            return new LocatorStrategy(SelectorTypes.CSS, css, 0.8);
        } else if (xpath != null && !xpath.isEmpty()) {
            return new LocatorStrategy(SelectorTypes.XPATH, xpath, 0.7);
        }
        
        return null;
    }
    
    /**
     * Generate a human-readable description of the element.
     *
     * @return A human-readable description of the element
     */
    @JsonIgnore
    public String generateDescription() {
        StringBuilder description = new StringBuilder();
        
        if (elementName != null && !elementName.isEmpty()) {
            return elementName;
        }
        
        if (tagName != null && !tagName.isEmpty()) {
            description.append(tagName);
            
            if (elementId != null && !elementId.isEmpty()) {
                description.append(" with ID '").append(elementId).append("'");
            } else if (text != null && !text.isEmpty()) {
                String displayText = text.length() > 20 ? text.substring(0, 17) + "..." : text;
                description.append(" with text '").append(displayText).append("'");
            } else if (className != null && !className.isEmpty()) {
                description.append(" with class '").append(className).append("'");
            } else if (name != null && !name.isEmpty()) {
                description.append(" with name '").append(name).append("'");
            } else if (placeholder != null && !placeholder.isEmpty()) {
                description.append(" with placeholder '").append(placeholder).append("'");
            }
        } else {
            description.append("Element");
        }
        
        return description.toString();
    }
    
    /**
     * Create a copy of this element info.
     *
     * @return A copy of this element info
     */
    public ElementInfo copy() {
        ElementInfo copy = new ElementInfo();
        copy.elementName = this.elementName;
        copy.tagName = this.tagName;
        copy.xpath = this.xpath;
        copy.css = this.css;
        copy.elementId = this.elementId;
        copy.name = this.name;
        copy.className = this.className;
        copy.linkText = this.linkText;
        copy.accessibilityId = this.accessibilityId;
        copy.dataTestId = this.dataTestId;
        copy.text = this.text;
        copy.value = this.value;
        copy.placeholder = this.placeholder;
        copy.index = this.index;
        copy.x = this.x;
        copy.y = this.y;
        copy.width = this.width;
        copy.height = this.height;
        copy.centerX = this.centerX;
        copy.centerY = this.centerY;
        copy.visible = this.visible;
        copy.enabled = this.enabled;
        copy.selected = this.selected;
        copy.checked = this.checked;
        copy.displayed = this.displayed;
        copy.role = this.role;
        copy.fingerprint = this.fingerprint;
        copy.isSelfHealing = this.isSelfHealing;
        
        copy.attributes.putAll(this.attributes);
        copy.styles.putAll(this.styles);
        copy.selectors.putAll(this.selectors);
        
        for (LocatorStrategy strategy : this.locatorStrategies) {
            copy.locatorStrategies.add(strategy.copy());
        }
        
        copy.selectedSelector = this.selectedSelector;
        copy.screenshot = this.screenshot;
        
        return copy;
    }
    
    /**
     * Create a minimal copy of this element info with only essential identification properties.
     *
     * @return A minimal copy of this element info
     */
    @JsonIgnore
    public ElementInfo createMinimalCopy() {
        ElementInfo copy = new ElementInfo();
        copy.elementName = this.elementName;
        copy.tagName = this.tagName;
        copy.xpath = this.xpath;
        copy.css = this.css;
        copy.elementId = this.elementId;
        copy.name = this.name;
        copy.className = this.className;
        copy.text = this.text;
        copy.selectors.putAll(this.selectors);
        copy.selectedSelector = this.selectedSelector;
        copy.fingerprint = this.fingerprint;
        copy.isSelfHealing = this.isSelfHealing;
        
        for (LocatorStrategy strategy : this.locatorStrategies) {
            copy.locatorStrategies.add(strategy.copy());
        }
        
        return copy;
    }
    
    /**
     * Generate fingerprint for the element based on its properties.
     *
     * @return A fingerprint string
     */
    @JsonIgnore
    public String generateFingerprint() {
        StringBuilder fpBuilder = new StringBuilder();
        
        // Add element type and attributes
        fpBuilder.append("tag:").append(tagName != null ? tagName : "").append("|");
        fpBuilder.append("id:").append(elementId != null ? elementId : "").append("|");
        fpBuilder.append("class:").append(className != null ? className : "").append("|");
        fpBuilder.append("name:").append(name != null ? name : "").append("|");
        fpBuilder.append("text:").append(text != null ? text : "").append("|");
        
        // Add dimension and position info
        if (width != null && height != null && x != null && y != null) {
            fpBuilder.append("dims:").append(width).append("x").append(height).append("|");
            fpBuilder.append("pos:").append(x).append(",").append(y).append("|");
        }
        
        // Add element state
        fpBuilder.append("state:");
        if (visible != null) fpBuilder.append(visible ? "v" : "-");
        if (enabled != null) fpBuilder.append(enabled ? "e" : "-");
        if (selected != null) fpBuilder.append(selected ? "s" : "-");
        if (checked != null) fpBuilder.append(checked ? "c" : "-");
        
        return fpBuilder.toString();
    }
    
    // Getters and setters
    
    public String getUniqueId() {
        return id;
    }

    public void setUniqueId(String id) {
        this.id = id;
    }

    public String getElementName() {
        return elementName;
    }

    public void setElementName(String elementName) {
        this.elementName = elementName;
    }

    public String getTagName() {
        return tagName;
    }

    public void setTagName(String tagName) {
        this.tagName = tagName;
    }

    public String getXpath() {
        return xpath;
    }

    public void setXpath(String xpath) {
        this.xpath = xpath;
        if (xpath != null && !xpath.isEmpty()) {
            selectors.put(SelectorTypes.XPATH, xpath);
        }
    }

    public String getCss() {
        return css;
    }

    public void setCss(String css) {
        this.css = css;
        if (css != null && !css.isEmpty()) {
            selectors.put(SelectorTypes.CSS, css);
        }
    }

    public String getElementId() {
        return elementId;
    }

    public void setElementId(String elementId) {
        this.elementId = elementId;
        if (elementId != null && !elementId.isEmpty()) {
            selectors.put(SelectorTypes.ID, elementId);
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        if (name != null && !name.isEmpty()) {
            selectors.put(SelectorTypes.NAME, name);
        }
    }

    public String getClassName() {
        return className;
    }

    public void setClassName(String className) {
        this.className = className;
        if (className != null && !className.isEmpty()) {
            selectors.put(SelectorTypes.CLASS_NAME, className);
        }
    }

    public String getLinkText() {
        return linkText;
    }

    public void setLinkText(String linkText) {
        this.linkText = linkText;
        if (linkText != null && !linkText.isEmpty()) {
            selectors.put(SelectorTypes.LINK_TEXT, linkText);
        }
    }

    public String getAccessibilityId() {
        return accessibilityId;
    }

    public void setAccessibilityId(String accessibilityId) {
        this.accessibilityId = accessibilityId;
        if (accessibilityId != null && !accessibilityId.isEmpty()) {
            selectors.put(SelectorTypes.ACCESSIBILITY_ID, accessibilityId);
        }
    }

    public String getDataTestId() {
        return dataTestId;
    }

    public void setDataTestId(String dataTestId) {
        this.dataTestId = dataTestId;
        if (dataTestId != null && !dataTestId.isEmpty()) {
            selectors.put(SelectorTypes.DATA_TEST_ID, dataTestId);
        }
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
        if (text != null && !text.isEmpty()) {
            selectors.put(SelectorTypes.TEXT, text);
        }
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public String getPlaceholder() {
        return placeholder;
    }

    public void setPlaceholder(String placeholder) {
        this.placeholder = placeholder;
    }

    public Integer getIndex() {
        return index;
    }

    public void setIndex(Integer index) {
        this.index = index;
    }

    public Integer getX() {
        return x;
    }

    public void setX(Integer x) {
        this.x = x;
    }

    public Integer getY() {
        return y;
    }

    public void setY(Integer y) {
        this.y = y;
    }

    public Integer getWidth() {
        return width;
    }

    public void setWidth(Integer width) {
        this.width = width;
    }

    public Integer getHeight() {
        return height;
    }

    public void setHeight(Integer height) {
        this.height = height;
    }

    public Integer getCenterX() {
        return centerX;
    }

    public void setCenterX(Integer centerX) {
        this.centerX = centerX;
    }

    public Integer getCenterY() {
        return centerY;
    }

    public void setCenterY(Integer centerY) {
        this.centerY = centerY;
    }

    public Boolean getVisible() {
        return visible;
    }

    public void setVisible(Boolean visible) {
        this.visible = visible;
    }

    public Boolean getEnabled() {
        return enabled;
    }

    public void setEnabled(Boolean enabled) {
        this.enabled = enabled;
    }

    public Boolean getSelected() {
        return selected;
    }

    public void setSelected(Boolean selected) {
        this.selected = selected;
    }

    public Boolean getChecked() {
        return checked;
    }

    public void setChecked(Boolean checked) {
        this.checked = checked;
    }

    public Boolean getDisplayed() {
        return displayed;
    }

    public void setDisplayed(Boolean displayed) {
        this.displayed = displayed;
    }

    public Map<String, String> getAttributes() {
        return attributes;
    }

    public void setAttributes(Map<String, String> attributes) {
        this.attributes = attributes != null ? attributes : new HashMap<>();
    }

    public Map<String, String> getStyles() {
        return styles;
    }

    public void setStyles(Map<String, String> styles) {
        this.styles = styles != null ? styles : new HashMap<>();
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
        if (role != null && !role.isEmpty()) {
            selectors.put(SelectorTypes.PLAYWRIGHT_ROLE, role);
        }
    }

    public Map<String, String> getSelectors() {
        return selectors;
    }

    public void setSelectors(Map<String, String> selectors) {
        this.selectors = selectors != null ? selectors : new HashMap<>();
    }

    public String getSelectedSelector() {
        return selectedSelector;
    }

    public void setSelectedSelector(String selectedSelector) {
        this.selectedSelector = selectedSelector;
    }

    public String getScreenshot() {
        return screenshot;
    }

    public void setScreenshot(String screenshot) {
        this.screenshot = screenshot;
    }

    public String getFingerprint() {
        if (fingerprint == null || fingerprint.isEmpty()) {
            fingerprint = generateFingerprint();
        }
        return fingerprint;
    }

    public void setFingerprint(String fingerprint) {
        this.fingerprint = fingerprint;
    }

    public Boolean getIsSelfHealing() {
        return isSelfHealing;
    }

    public void setIsSelfHealing(Boolean isSelfHealing) {
        this.isSelfHealing = isSelfHealing;
    }

    public List<LocatorStrategy> getLocatorStrategies() {
        return locatorStrategies;
    }

    public void setLocatorStrategies(List<LocatorStrategy> locatorStrategies) {
        this.locatorStrategies = locatorStrategies != null ? locatorStrategies : new ArrayList<>();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ElementInfo that = (ElementInfo) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "ElementInfo{" +
                "tagName='" + tagName + '\'' +
                ", id='" + elementId + '\'' +
                ", text='" + (text != null ? (text.length() > 20 ? text.substring(0, 17) + "..." : text) : "") + '\'' +
                ", selectedSelector='" + selectedSelector + '\'' +
                '}';
    }
    
    /**
     * Inner class representing a locator strategy for an element.
     */
    public static class LocatorStrategy implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        @JsonProperty("type")
        private String type;
        
        @JsonProperty("value")
        private String value;
        
        @JsonProperty("rank")
        private double rank;
        
        @JsonProperty("params")
        private Map<String, Object> params;
        
        /**
         * Default constructor.
         */
        public LocatorStrategy() {
            this.params = new HashMap<>();
            this.rank = 0.0;
        }
        
        /**
         * Constructor with type, value, and rank.
         *
         * @param type  The locator type
         * @param value The locator value
         * @param rank  The locator rank (0.0 to 1.0)
         */
        public LocatorStrategy(String type, String value, double rank) {
            this();
            this.type = type;
            this.value = value;
            this.rank = rank;
        }
        
        /**
         * Add a parameter to the locator strategy.
         *
         * @param name  The parameter name
         * @param value The parameter value
         */
        public void addParameter(String name, Object value) {
            if (name != null && !name.isEmpty()) {
                params.put(name, value);
            }
        }
        
        /**
         * Create a copy of this locator strategy.
         *
         * @return A copy of this locator strategy
         */
        public LocatorStrategy copy() {
            LocatorStrategy copy = new LocatorStrategy();
            copy.type = this.type;
            copy.value = this.value;
            copy.rank = this.rank;
            copy.params.putAll(this.params);
            
            return copy;
        }
        
        // Getters and setters
        
        public String getType() {
            return type;
        }
        
        public void setType(String type) {
            this.type = type;
        }
        
        public String getValue() {
            return value;
        }
        
        public void setValue(String value) {
            this.value = value;
        }
        
        public double getRank() {
            return rank;
        }
        
        public void setRank(double rank) {
            this.rank = rank;
        }
        
        public Map<String, Object> getParams() {
            return params;
        }
        
        public void setParams(Map<String, Object> params) {
            this.params = params != null ? params : new HashMap<>();
        }
        
        @Override
        public String toString() {
            return "LocatorStrategy{" +
                    "type='" + type + '\'' +
                    ", value='" + value + '\'' +
                    ", rank=" + rank +
                    '}';
        }
    }
}



RecorderState.java
-------------------------------

package com.cstestforge.model.recorder;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;

import java.util.HashMap;
import java.util.Map;

/**
 * Enumeration representing the possible states of a recording session.
 */
public enum RecorderState {
    CREATED("created"),
    RECORDING("recording"),
    PAUSED("paused"),
    COMPLETED("completed"),
    FAILED("failed"),
    CANCELLED("cancelled"),
    EXPORTED("exported");
    
    private static final Map<String, RecorderState> BY_VALUE = new HashMap<>();
    
    static {
        for (RecorderState state : values()) {
            BY_VALUE.put(state.getValue(), state);
        }
    }
    
    private final String value;
    
    /**
     * Constructor.
     *
     * @param value The string value of the state
     */
    RecorderState(String value) {
        this.value = value;
    }
    
    /**
     * Get the string value of the state.
     *
     * @return The string value
     */
    @JsonValue
    public String getValue() {
        return value;
    }
    
    /**
     * Get the RecorderState enum from a string value.
     *
     * @param value The string value
     * @return The RecorderState enum, or null if not found
     */
    @JsonCreator
    public static RecorderState fromValue(String value) {
        return value != null ? BY_VALUE.get(value.toLowerCase()) : null;
    }
    
    /**
     * Check if the state is active.
     *
     * @return True if the state is active, false otherwise
     */
    public boolean isActive() {
        return this == RECORDING || this == PAUSED;
    }
    
    /**
     * Check if the state is terminal.
     *
     * @return True if the state is terminal, false otherwise
     */
    public boolean isTerminal() {
        return this == COMPLETED || this == FAILED || this == CANCELLED || this == EXPORTED;
    }
    
    /**
     * Check if transition to another state is allowed.
     *
     * @param targetState The target state
     * @return True if the transition is allowed, false otherwise
     */
    public boolean canTransitionTo(RecorderState targetState) {
        switch (this) {
            case CREATED:
                return targetState == RECORDING || targetState == CANCELLED;
                
            case RECORDING:
                return targetState == PAUSED || targetState == COMPLETED || 
                       targetState == FAILED || targetState == CANCELLED;
                
            case PAUSED:
                return targetState == RECORDING || targetState == COMPLETED || 
                       targetState == FAILED || targetState == CANCELLED;
                
            case COMPLETED:
                return targetState == EXPORTED;
                
            case FAILED:
            case CANCELLED:
            case EXPORTED:
                return false;
                
            default:
                return false;
        }
    }
    
    @Override
    public String toString() {
        return value;
    }
}


ActionConfig.java
---------------------------

package com.cstestforge.model.recorder;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

/**
 * Base class for action configuration.
 * This class provides the basic configuration properties for an action.
 * Specific action types have their own derived configuration classes.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "configType")
@JsonSubTypes({
    @JsonSubTypes.Type(value = ConditionalActionConfig.class, name = "conditional"),
    @JsonSubTypes.Type(value = LoopActionConfig.class, name = "loop"),
    @JsonSubTypes.Type(value = DataProviderActionConfig.class, name = "dataProvider"),
    @JsonSubTypes.Type(value = WaitActionConfig.class, name = "wait"),
    @JsonSubTypes.Type(value = AssertionActionConfig.class, name = "assertion"),
    @JsonSubTypes.Type(value = CustomActionConfig.class, name = "custom")
})
public class ActionConfig implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("configType")
    private String configType;
    
    @JsonProperty("actionId")
    private String actionId;
    
    @JsonProperty("timeoutInSeconds")
    private Integer timeoutInSeconds;
    
    @JsonProperty("retry")
    private Boolean retry;
    
    @JsonProperty("maxRetries")
    private Integer maxRetries;
    
    @JsonProperty("retryIntervalInSeconds")
    private Integer retryIntervalInSeconds;
    
    @JsonProperty("continueOnError")
    private Boolean continueOnError;
    
    @JsonProperty("screenshotOnError")
    private Boolean screenshotOnError;
    
    @JsonProperty("screenshotOnSuccess")
    private Boolean screenshotOnSuccess;
    
    @JsonProperty("logLevel")
    private String logLevel;
    
    @JsonProperty("metadata")
    private Map<String, String> metadata;
    
    /**
     * Default constructor.
     */
    public ActionConfig() {
        this.id = UUID.randomUUID().toString();
        this.metadata = new HashMap<>();
        setDefaultValues();
    }
    
    /**
     * Constructor with config type.
     *
     * @param configType The config type
     */
    public ActionConfig(String configType) {
        this();
        this.configType = configType;
    }
    
    /**
     * Constructor with config type and action ID.
     *
     * @param configType The config type
     * @param actionId   The ID of the action this config belongs to
     */
    public ActionConfig(String configType, String actionId) {
        this();
        this.configType = configType;
        this.actionId = actionId;
    }
    
    /**
     * Set default values for the configuration.
     */
    private void setDefaultValues() {
        this.timeoutInSeconds = 30;
        this.retry = false;
        this.maxRetries = 3;
        this.retryIntervalInSeconds = 2;
        this.continueOnError = false;
        this.screenshotOnError = true;
        this.screenshotOnSuccess = false;
        this.logLevel = "INFO";
    }
    
    /**
     * Add metadata to the action configuration.
     *
     * @param key   The metadata key
     * @param value The metadata value
     */
    public void addMetadata(String key, String value) {
        if (key != null && !key.isEmpty()) {
            metadata.put(key, value);
        }
    }
    
    /**
     * Check if the action should be retried on failure.
     *
     * @return True if the action should be retried, false otherwise
     */
    @JsonIgnore
    public boolean shouldRetry() {
        return Boolean.TRUE.equals(retry) && maxRetries != null && maxRetries > 0;
    }
    
    /**
     * Check if a screenshot should be taken.
     *
     * @param isError True if the action has failed, false otherwise
     * @return True if a screenshot should be taken, false otherwise
     */
    public boolean shouldTakeScreenshot(boolean isError) {
        if (isError) {
            return Boolean.TRUE.equals(screenshotOnError);
        } else {
            return Boolean.TRUE.equals(screenshotOnSuccess);
        }
    }
    
    /**
     * Create a copy of this action configuration.
     *
     * @return A copy of this action configuration
     */
    public ActionConfig copy() {
        ActionConfig copy = new ActionConfig();
        copy.configType = this.configType;
        copy.actionId = this.actionId;
        copy.timeoutInSeconds = this.timeoutInSeconds;
        copy.retry = this.retry;
        copy.maxRetries = this.maxRetries;
        copy.retryIntervalInSeconds = this.retryIntervalInSeconds;
        copy.continueOnError = this.continueOnError;
        copy.screenshotOnError = this.screenshotOnError;
        copy.screenshotOnSuccess = this.screenshotOnSuccess;
        copy.logLevel = this.logLevel;
        copy.metadata.putAll(this.metadata);
        
        return copy;
    }
    
    /**
     * Validate the action configuration.
     *
     * @return True if the configuration is valid, false otherwise
     */
    @JsonIgnore
    public boolean isValid() {
        return configType != null && !configType.isEmpty();
    }
    
    /**
     * Get validation error messages.
     *
     * @return A string containing validation error messages, or null if the configuration is valid
     */
    @JsonIgnore
    public String getValidationErrors() {
        StringBuilder errors = new StringBuilder();
        
        if (configType == null || configType.isEmpty()) {
            errors.append("Config type is required. ");
        }
        
        if (timeoutInSeconds != null && timeoutInSeconds <= 0) {
            errors.append("Timeout must be greater than 0. ");
        }
        
        if (Boolean.TRUE.equals(retry)) {
            if (maxRetries == null || maxRetries <= 0) {
                errors.append("Max retries must be greater than 0 when retry is enabled. ");
            }
            
            if (retryIntervalInSeconds == null || retryIntervalInSeconds <= 0) {
                errors.append("Retry interval must be greater than 0 when retry is enabled. ");
            }
        }
        
        return errors.length() > 0 ? errors.toString() : null;
    }
    
    // Getters and setters
    
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getConfigType() {
        return configType;
    }

    public void setConfigType(String configType) {
        this.configType = configType;
    }

    public String getActionId() {
        return actionId;
    }

    public void setActionId(String actionId) {
        this.actionId = actionId;
    }

    public Integer getTimeoutInSeconds() {
        return timeoutInSeconds;
    }

    public void setTimeoutInSeconds(Integer timeoutInSeconds) {
        this.timeoutInSeconds = timeoutInSeconds;
    }

    public Boolean getRetry() {
        return retry;
    }

    public void setRetry(Boolean retry) {
        this.retry = retry;
    }

    public Integer getMaxRetries() {
        return maxRetries;
    }

    public void setMaxRetries(Integer maxRetries) {
        this.maxRetries = maxRetries;
    }

    public Integer getRetryIntervalInSeconds() {
        return retryIntervalInSeconds;
    }

    public void setRetryIntervalInSeconds(Integer retryIntervalInSeconds) {
        this.retryIntervalInSeconds = retryIntervalInSeconds;
    }

    public Boolean getContinueOnError() {
        return continueOnError;
    }

    public void setContinueOnError(Boolean continueOnError) {
        this.continueOnError = continueOnError;
    }

    public Boolean getScreenshotOnError() {
        return screenshotOnError;
    }

    public void setScreenshotOnError(Boolean screenshotOnError) {
        this.screenshotOnError = screenshotOnError;
    }

    public Boolean getScreenshotOnSuccess() {
        return screenshotOnSuccess;
    }

    public void setScreenshotOnSuccess(Boolean screenshotOnSuccess) {
        this.screenshotOnSuccess = screenshotOnSuccess;
    }

    public String getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(String logLevel) {
        this.logLevel = logLevel;
    }

    public Map<String, String> getMetadata() {
        return metadata;
    }

    public void setMetadata(Map<String, String> metadata) {
        this.metadata = metadata != null ? metadata : new HashMap<>();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ActionConfig that = (ActionConfig) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "ActionConfig{" +
                "configType='" + configType + '\'' +
                ", actionId='" + actionId + '\'' +
                ", timeoutInSeconds=" + timeoutInSeconds +
                ", retry=" + retry +
                ", continueOnError=" + continueOnError +
                '}';
    }
}



ConditionalActionConfig.java
------------------------------------

package com.cstestforge.model.recorder;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Configuration for conditional actions.
 * This class extends ActionConfig to provide specific properties for conditional actions.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ConditionalActionConfig extends ActionConfig {
    
    private static final long serialVersionUID = 1L;
    
    /**
     * Condition types enumeration
     */
    public static final class ConditionTypes {
        public static final String ELEMENT_EXISTS = "elementExists";
        public static final String ELEMENT_VISIBLE = "elementVisible";
        public static final String ELEMENT_CLICKABLE = "elementClickable";
        public static final String ELEMENT_SELECTED = "elementSelected";
        public static final String ELEMENT_HAS_TEXT = "elementHasText";
        public static final String ELEMENT_HAS_ATTRIBUTE = "elementHasAttribute";
        public static final String TEXT_EQUALS = "textEquals";
        public static final String TEXT_CONTAINS = "textContains";
        public static final String TEXT_MATCHES = "textMatches";
        public static final String URL_EQUALS = "urlEquals";
        public static final String URL_CONTAINS = "urlContains";
        public static final String URL_MATCHES = "urlMatches";
        public static final String TITLE_EQUALS = "titleEquals";
        public static final String TITLE_CONTAINS = "titleContains";
        public static final String TITLE_MATCHES = "titleMatches";
        public static final String VARIABLE_EQUALS = "variableEquals";
        public static final String VARIABLE_CONTAINS = "variableContains";
        public static final String VARIABLE_MATCHES = "variableMatches";
        public static final String JAVASCRIPT = "javascript";
        public static final String EXPRESSION = "expression";
        public static final String CUSTOM = "custom";
        
        // Prevent instantiation
        private ConditionTypes() {}
    }
    
    @JsonProperty("conditionType")
    private String conditionType;
    
    @JsonProperty("elementInfo")
    private ElementInfo elementInfo;
    
    @JsonProperty("expectedValue")
    private String expectedValue;
    
    @JsonProperty("caseSensitive")
    private Boolean caseSensitive;
    
    @JsonProperty("negateCondition")
    private Boolean negateCondition;
    
    @JsonProperty("attributeName")
    private String attributeName;
    
    @JsonProperty("variableName")
    private String variableName;
    
    @JsonProperty("expression")
    private String expression;
    
    @JsonProperty("script")
    private String script;
    
    @JsonProperty("thenActions")
    private List<String> thenActions;
    
    @JsonProperty("elseActions")
    private List<String> elseActions;
    
    @JsonProperty("customConditionConfig")
    private CustomActionConfig customConditionConfig;
    
    /**
     * Default constructor.
     */
    public ConditionalActionConfig() {
        super("conditional");
        this.thenActions = new ArrayList<>();
        this.elseActions = new ArrayList<>();
        this.caseSensitive = true;
        this.negateCondition = false;
    }
    
    /**
     * Constructor with condition type.
     *
     * @param conditionType The condition type
     */
    public ConditionalActionConfig(String conditionType) {
        this();
        this.conditionType = conditionType;
    }
    
    /**
     * Constructor with action ID and condition type.
     *
     * @param actionId      The ID of the action this config belongs to
     * @param conditionType The condition type
     */
    public ConditionalActionConfig(String actionId, String conditionType) {
        super("conditional", actionId);
        this.conditionType = conditionType;
        this.thenActions = new ArrayList<>();
        this.elseActions = new ArrayList<>();
        this.caseSensitive = true;
        this.negateCondition = false;
    }
    
    /**
     * Constructor with action ID, condition type, and element info.
     *
     * @param actionId      The ID of the action this config belongs to
     * @param conditionType The condition type
     * @param elementInfo   The element information for the condition
     */
    public ConditionalActionConfig(String actionId, String conditionType, ElementInfo elementInfo) {
        this(actionId, conditionType);
        this.elementInfo = elementInfo;
    }
    
    /**
     * Constructor with action ID, condition type, and expected value.
     *
     * @param actionId      The ID of the action this config belongs to
     * @param conditionType The condition type
     * @param expectedValue The expected value for the condition
     */
    public ConditionalActionConfig(String actionId, String conditionType, String expectedValue) {
        this(actionId, conditionType);
        this.expectedValue = expectedValue;
    }
    
    /**
     * Add an action to the "then" branch.
     *
     * @param actionId The ID of the action to add
     */
    public void addThenAction(String actionId) {
        if (actionId != null && !actionId.isEmpty()) {
            thenActions.add(actionId);
        }
    }
    
    /**
     * Add an action to the "else" branch.
     *
     * @param actionId The ID of the action to add
     */
    public void addElseAction(String actionId) {
        if (actionId != null && !actionId.isEmpty()) {
            elseActions.add(actionId);
        }
    }
    
    /**
     * Remove an action from the "then" branch.
     *
     * @param actionId The ID of the action to remove
     * @return True if the action was removed, false otherwise
     */
    public boolean removeThenAction(String actionId) {
        if (actionId != null && !actionId.isEmpty()) {
            return thenActions.remove(actionId);
        }
        return false;
    }
    
    /**
     * Remove an action from the "else" branch.
     *
     * @param actionId The ID of the action to remove
     * @return True if the action was removed, false otherwise
     */
    public boolean removeElseAction(String actionId) {
        if (actionId != null && !actionId.isEmpty()) {
            return elseActions.remove(actionId);
        }
        return false;
    }
    
    /**
     * Check if the condition requires an element.
     *
     * @return True if the condition requires an element, false otherwise
     */
    @JsonIgnore
    public boolean requiresElement() {
        return ConditionTypes.ELEMENT_EXISTS.equals(conditionType) ||
               ConditionTypes.ELEMENT_VISIBLE.equals(conditionType) ||
               ConditionTypes.ELEMENT_CLICKABLE.equals(conditionType) ||
               ConditionTypes.ELEMENT_SELECTED.equals(conditionType) ||
               ConditionTypes.ELEMENT_HAS_TEXT.equals(conditionType) ||
               ConditionTypes.ELEMENT_HAS_ATTRIBUTE.equals(conditionType);
    }
    
    /**
     * Check if the condition requires a value.
     *
     * @return True if the condition requires a value, false otherwise
     */
    @JsonIgnore
    public boolean requiresValue() {
        return ConditionTypes.ELEMENT_HAS_TEXT.equals(conditionType) ||
               ConditionTypes.ELEMENT_HAS_ATTRIBUTE.equals(conditionType) ||
               ConditionTypes.TEXT_EQUALS.equals(conditionType) ||
               ConditionTypes.TEXT_CONTAINS.equals(conditionType) ||
               ConditionTypes.TEXT_MATCHES.equals(conditionType) ||
               ConditionTypes.URL_EQUALS.equals(conditionType) ||
               ConditionTypes.URL_CONTAINS.equals(conditionType) ||
               ConditionTypes.URL_MATCHES.equals(conditionType) ||
               ConditionTypes.TITLE_EQUALS.equals(conditionType) ||
               ConditionTypes.TITLE_CONTAINS.equals(conditionType) ||
               ConditionTypes.TITLE_MATCHES.equals(conditionType) ||
               ConditionTypes.VARIABLE_EQUALS.equals(conditionType) ||
               ConditionTypes.VARIABLE_CONTAINS.equals(conditionType) ||
               ConditionTypes.VARIABLE_MATCHES.equals(conditionType);
    }
    
    /**
     * Check if the condition requires an attribute name.
     *
     * @return True if the condition requires an attribute name, false otherwise
     */
    @JsonIgnore
    public boolean requiresAttributeName() {
        return ConditionTypes.ELEMENT_HAS_ATTRIBUTE.equals(conditionType);
    }
    
    /**
     * Check if the condition requires a variable name.
     *
     * @return True if the condition requires a variable name, false otherwise
     */
    @JsonIgnore
    public boolean requiresVariableName() {
        return ConditionTypes.VARIABLE_EQUALS.equals(conditionType) ||
               ConditionTypes.VARIABLE_CONTAINS.equals(conditionType) ||
               ConditionTypes.VARIABLE_MATCHES.equals(conditionType);
    }
    
    /**
     * Check if the condition requires a script.
     *
     * @return True if the condition requires a script, false otherwise
     */
    @JsonIgnore
    public boolean requiresScript() {
        return ConditionTypes.JAVASCRIPT.equals(conditionType);
    }
    
    /**
     * Check if the condition requires an expression.
     *
     * @return True if the condition requires an expression, false otherwise
     */
    @JsonIgnore
    public boolean requiresExpression() {
        return ConditionTypes.EXPRESSION.equals(conditionType);
    }
    
    /**
     * Create a human-readable description of the condition.
     *
     * @return A human-readable description of the condition
     */
    @JsonIgnore
    public String getConditionDescription() {
        StringBuilder desc = new StringBuilder();
        
        if (Boolean.TRUE.equals(negateCondition)) {
            desc.append("NOT ");
        }
        
        switch (conditionType) {
            case ConditionTypes.ELEMENT_EXISTS:
                desc.append("Element exists");
                if (elementInfo != null) {
                    desc.append(": ").append(elementInfo.generateDescription());
                }
                break;
                
            case ConditionTypes.ELEMENT_VISIBLE:
                desc.append("Element is visible");
                if (elementInfo != null) {
                    desc.append(": ").append(elementInfo.generateDescription());
                }
                break;
                
            case ConditionTypes.ELEMENT_CLICKABLE:
                desc.append("Element is clickable");
                if (elementInfo != null) {
                    desc.append(": ").append(elementInfo.generateDescription());
                }
                break;
                
            case ConditionTypes.ELEMENT_SELECTED:
                desc.append("Element is selected");
                if (elementInfo != null) {
                    desc.append(": ").append(elementInfo.generateDescription());
                }
                break;
                
            case ConditionTypes.ELEMENT_HAS_TEXT:
                desc.append("Element text ");
                if (expectedValue != null) {
                    desc.append("equals '").append(expectedValue).append("'");
                }
                if (elementInfo != null) {
                    desc.append(" for ").append(elementInfo.generateDescription());
                }
                break;
                
            case ConditionTypes.ELEMENT_HAS_ATTRIBUTE:
                desc.append("Element attribute ");
                if (attributeName != null) {
                    desc.append("'").append(attributeName).append("' ");
                }
                if (expectedValue != null) {
                    desc.append("equals '").append(expectedValue).append("'");
                }
                if (elementInfo != null) {
                    desc.append(" for ").append(elementInfo.generateDescription());
                }
                break;
                
            case ConditionTypes.TEXT_EQUALS:
                desc.append("Text equals '").append(expectedValue).append("'");
                break;
                
            case ConditionTypes.TEXT_CONTAINS:
                desc.append("Text contains '").append(expectedValue).append("'");
                break;
                
            case ConditionTypes.TEXT_MATCHES:
                desc.append("Text matches regex '").append(expectedValue).append("'");
                break;
                
            case ConditionTypes.URL_EQUALS:
                desc.append("URL equals '").append(expectedValue).append("'");
                break;
                
            case ConditionTypes.URL_CONTAINS:
                desc.append("URL contains '").append(expectedValue).append("'");
                break;
                
            case ConditionTypes.URL_MATCHES:
                desc.append("URL matches regex '").append(expectedValue).append("'");
                break;
                
            case ConditionTypes.TITLE_EQUALS:
                desc.append("Title equals '").append(expectedValue).append("'");
                break;
                
            case ConditionTypes.TITLE_CONTAINS:
                desc.append("Title contains '").append(expectedValue).append("'");
                break;
                
            case ConditionTypes.TITLE_MATCHES:
                desc.append("Title matches regex '").append(expectedValue).append("'");
                break;
                
            case ConditionTypes.VARIABLE_EQUALS:
                desc.append("Variable '").append(variableName).append("' equals '")
                    .append(expectedValue).append("'");
                break;
                
            case ConditionTypes.VARIABLE_CONTAINS:
                desc.append("Variable '").append(variableName).append("' contains '")
                    .append(expectedValue).append("'");
                break;
                
            case ConditionTypes.VARIABLE_MATCHES:
                desc.append("Variable '").append(variableName).append("' matches regex '")
                    .append(expectedValue).append("'");
                break;
                
            case ConditionTypes.JAVASCRIPT:
                desc.append("JavaScript condition");
                if (script != null && script.length() <= 30) {
                    desc.append(": ").append(script);
                }
                break;
                
            case ConditionTypes.EXPRESSION:
                desc.append("Expression condition");
                if (expression != null && expression.length() <= 30) {
                    desc.append(": ").append(expression);
                }
                break;
                
            case ConditionTypes.CUSTOM:
                desc.append("Custom condition");
                if (customConditionConfig != null && customConditionConfig.getName() != null) {
                    desc.append(": ").append(customConditionConfig.getName());
                }
                break;
                
            default:
                desc.append("Unknown condition type: ").append(conditionType);
                break;
        }
        
        return desc.toString();
    }
    
    @Override
    @JsonIgnore
    public boolean isValid() {
        if (!super.isValid()) {
            return false;
        }
        
        if (conditionType == null || conditionType.isEmpty()) {
            return false;
        }
        
        if (requiresElement() && elementInfo == null) {
            return false;
        }
        
        if (requiresValue() && (expectedValue == null || expectedValue.isEmpty())) {
            return false;
        }
        
        if (requiresAttributeName() && (attributeName == null || attributeName.isEmpty())) {
            return false;
        }
        
        if (requiresVariableName() && (variableName == null || variableName.isEmpty())) {
            return false;
        }
        
        if (requiresScript() && (script == null || script.isEmpty())) {
            return false;
        }
        
        if (requiresExpression() && (expression == null || expression.isEmpty())) {
            return false;
        }
        
        if (ConditionTypes.CUSTOM.equals(conditionType) && customConditionConfig == null) {
            return false;
        }
        
        return true;
    }
    
    @Override
    @JsonIgnore
    public String getValidationErrors() {
        StringBuilder errors = new StringBuilder();
        
        String baseErrors = super.getValidationErrors();
        if (baseErrors != null) {
            errors.append(baseErrors);
        }
        
        if (conditionType == null || conditionType.isEmpty()) {
            errors.append("Condition type is required. ");
        }
        
        if (requiresElement() && elementInfo == null) {
            errors.append("Element info is required for this condition type. ");
        }
        
        if (requiresValue() && (expectedValue == null || expectedValue.isEmpty())) {
            errors.append("Expected value is required for this condition type. ");
        }
        
        if (requiresAttributeName() && (attributeName == null || attributeName.isEmpty())) {
            errors.append("Attribute name is required for this condition type. ");
        }
        
        if (requiresVariableName() && (variableName == null || variableName.isEmpty())) {
            errors.append("Variable name is required for this condition type. ");
        }
        
        if (requiresScript() && (script == null || script.isEmpty())) {
            errors.append("Script is required for this condition type. ");
        }
        
        if (requiresExpression() && (expression == null || expression.isEmpty())) {
            errors.append("Expression is required for this condition type. ");
        }
        
        if (ConditionTypes.CUSTOM.equals(conditionType) && customConditionConfig == null) {
            errors.append("Custom condition configuration is required for custom condition type. ");
        }
        
        return errors.length() > 0 ? errors.toString() : null;
    }
    
    @Override
    public ConditionalActionConfig copy() {
        ConditionalActionConfig copy = new ConditionalActionConfig();
        
        // Copy base properties
        copy.setId(this.getId());
        copy.setActionId(this.getActionId());
        copy.setTimeoutInSeconds(this.getTimeoutInSeconds());
        copy.setRetry(this.getRetry());
        copy.setMaxRetries(this.getMaxRetries());
        copy.setRetryIntervalInSeconds(this.getRetryIntervalInSeconds());
        copy.setContinueOnError(this.getContinueOnError());
        copy.setScreenshotOnError(this.getScreenshotOnError());
        copy.setScreenshotOnSuccess(this.getScreenshotOnSuccess());
        copy.setLogLevel(this.getLogLevel());
        copy.getMetadata().putAll(this.getMetadata());
        
        // Copy conditional properties
        copy.conditionType = this.conditionType;
        copy.elementInfo = this.elementInfo != null ? this.elementInfo.copy() : null;
        copy.expectedValue = this.expectedValue;
        copy.caseSensitive = this.caseSensitive;
        copy.negateCondition = this.negateCondition;
        copy.attributeName = this.attributeName;
        copy.variableName = this.variableName;
        copy.expression = this.expression;
        copy.script = this.script;
        copy.thenActions.addAll(this.thenActions);
        copy.elseActions.addAll(this.elseActions);
        copy.customConditionConfig = this.customConditionConfig != null ? 
                (CustomActionConfig) this.customConditionConfig.copy() : null;
        
        return copy;
    }
    
    // Getters and setters
    
    public String getConditionType() {
        return conditionType;
    }

    public void setConditionType(String conditionType) {
        this.conditionType = conditionType;
    }

    public ElementInfo getElementInfo() {
        return elementInfo;
    }

    public void setElementInfo(ElementInfo elementInfo) {
        this.elementInfo = elementInfo;
    }

    public String getExpectedValue() {
        return expectedValue;
    }

    public void setExpectedValue(String expectedValue) {
        this.expectedValue = expectedValue;
    }

    public Boolean getCaseSensitive() {
        return caseSensitive;
    }

    public void setCaseSensitive(Boolean caseSensitive) {
        this.caseSensitive = caseSensitive;
    }

    public Boolean getNegateCondition() {
        return negateCondition;
    }

    public void setNegateCondition(Boolean negateCondition) {
        this.negateCondition = negateCondition;
    }

    public String getAttributeName() {
        return attributeName;
    }

    public void setAttributeName(String attributeName) {
        this.attributeName = attributeName;
    }

    public String getVariableName() {
        return variableName;
    }

    public void setVariableName(String variableName) {
        this.variableName = variableName;
    }

    public String getExpression() {
        return expression;
    }

    public void setExpression(String expression) {
        this.expression = expression;
    }

    public String getScript() {
        return script;
    }

    public void setScript(String script) {
        this.script = script;
    }

    public List<String> getThenActions() {
        return thenActions;
    }

    public void setThenActions(List<String> thenActions) {
        this.thenActions = thenActions != null ? thenActions : new ArrayList<>();
    }

    public List<String> getElseActions() {
        return elseActions;
    }

    public void setElseActions(List<String> elseActions) {
        this.elseActions = elseActions != null ? elseActions : new ArrayList<>();
    }

    public CustomActionConfig getCustomConditionConfig() {
        return customConditionConfig;
    }

    public void setCustomConditionConfig(CustomActionConfig customConditionConfig) {
        this.customConditionConfig = customConditionConfig;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        ConditionalActionConfig that = (ConditionalActionConfig) o;
        return Objects.equals(conditionType, that.conditionType) &&
               Objects.equals(getActionId(), that.getActionId());
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), conditionType, getActionId());
    }

    @Override
    public String toString() {
        return "ConditionalActionConfig{" +
                "conditionType='" + conditionType + '\'' +
                ", description='" + getConditionDescription() + '\'' +
                ", thenActions=" + thenActions.size() +
                ", elseActions=" + elseActions.size() +
                '}';
    }
}


StepDefinition.java
---------------------------------
package com.cstestforge.model.recorder;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Model representing a step definition for BDD tests.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class StepDefinition implements Serializable {
    
    private static final long serialVersionUID = 1L;
    private static final Pattern PARAMETER_PATTERN = Pattern.compile("\\{([^}]+)}");
    
    /**
     * Step types enumeration
     */
    public static final class StepTypes {
        public static final String GIVEN = "given";
        public static final String WHEN = "when";
        public static final String THEN = "then";
        public static final String AND = "and";
        public static final String BUT = "but";
        
        // Prevent instantiation
        private StepTypes() {}
    }
    
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("pattern")
    private String pattern;
    
    @JsonProperty("stepType")
    private String stepType;
    
    @JsonProperty("displayName")
    private String displayName;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("createdBy")
    private String createdBy;
    
    @JsonProperty("createdAt")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS")
    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
    @JsonSerialize(using = LocalDateTimeSerializer.class)
    private LocalDateTime createdAt;
    
    @JsonProperty("updatedAt")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS")
    @JsonDeserialize(using = LocalDateTimeDeserializer.class)
    @JsonSerialize(using = LocalDateTimeSerializer.class)
    private LocalDateTime updatedAt;
    
    @JsonProperty("parameters")
    private List<Parameter> parameters;
    
    @JsonProperty("actions")
    private List<String> actions;
    
    @JsonProperty("tags")
    private List<String> tags;
    
    @JsonProperty("metadata")
    private Map<String, String> metadata;
    
    /**
     * Default constructor.
     */
    public StepDefinition() {
        this.id = UUID.randomUUID().toString();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
        this.parameters = new ArrayList<>();
        this.actions = new ArrayList<>();
        this.tags = new ArrayList<>();
        this.metadata = new HashMap<>();
    }
    
    /**
     * Constructor with pattern.
     *
     * @param pattern The step pattern
     */
    public StepDefinition(String pattern) {
        this();
        this.pattern = pattern;
        extractParameters();
    }
    
    /**
     * Constructor with pattern and step type.
     *
     * @param pattern  The step pattern
     * @param stepType The step type
     */
    public StepDefinition(String pattern, String stepType) {
        this(pattern);
        this.stepType = stepType;
    }
    
    /**
     * Full constructor.
     *
     * @param pattern      The step pattern
     * @param stepType     The step type
     * @param displayName  The display name
     * @param description  The description
     * @param createdBy    The creator of the step definition
     */
    public StepDefinition(String pattern, String stepType, String displayName, 
                        String description, String createdBy) {
        this(pattern, stepType);
        this.displayName = displayName;
        this.description = description;
        this.createdBy = createdBy;
    }
    
    /**
     * Extract parameters from the pattern.
     */
    private void extractParameters() {
        if (pattern == null || pattern.isEmpty()) {
            return;
        }
        
        parameters.clear();
        
        Matcher matcher = PARAMETER_PATTERN.matcher(pattern);
        while (matcher.find()) {
            String paramContent = matcher.group(1);
            String[] parts = paramContent.split(":", 2);
            
            String name = parts[0].trim();
            String type = parts.length > 1 ? parts[1].trim() : "string";
            
            parameters.add(new Parameter(name, type));
        }
    }
    
    /**
     * Add an action to the step definition.
     *
     * @param actionId The ID of the action to add
     */
    public void addAction(String actionId) {
        if (actionId != null && !actionId.isEmpty()) {
            actions.add(actionId);
            updatedAt = LocalDateTime.now();
        }
    }
    
    /**
     * Remove an action from the step definition.
     *
     * @param actionId The ID of the action to remove
     * @return True if the action was removed, false otherwise
     */
    public boolean removeAction(String actionId) {
        if (actionId != null && !actionId.isEmpty()) {
            boolean removed = actions.remove(actionId);
            if (removed) {
                updatedAt = LocalDateTime.now();
            }
            return removed;
        }
        return false;
    }
    
    /**
     * Add a tag to the step definition.
     *
     * @param tag The tag to add
     */
    public void addTag(String tag) {
        if (tag != null && !tag.isEmpty()) {
            tags.add(tag);
            updatedAt = LocalDateTime.now();
        }
    }
    
    /**
     * Remove a tag from the step definition.
     *
     * @param tag The tag to remove
     * @return True if the tag was removed, false otherwise
     */
    public boolean removeTag(String tag) {
        if (tag != null && !tag.isEmpty()) {
            boolean removed = tags.remove(tag);
            if (removed) {
                updatedAt = LocalDateTime.now();
            }
            return removed;
        }
        return false;
    }
    
    /**
     * Add metadata to the step definition.
     *
     * @param key   The metadata key
     * @param value The metadata value
     */
    public void addMetadata(String key, String value) {
        if (key != null && !key.isEmpty()) {
            metadata.put(key, value);
            updatedAt = LocalDateTime.now();
        }
    }
    
    /**
     * Compile the step pattern to a regular expression pattern.
     *
     * @return The Pattern object for matching steps
     */
    @JsonIgnore
    public Pattern compilePattern() {
        if (pattern == null || pattern.isEmpty()) {
            return null;
        }
        
        String regex = pattern;
        
        // Replace {name:type} parameters with regex capture groups
        Matcher matcher = PARAMETER_PATTERN.matcher(pattern);
        StringBuffer sb = new StringBuffer();
        
        while (matcher.find()) {
            String paramContent = matcher.group(1);
            String[] parts = paramContent.split(":", 2);
            
            String type = parts.length > 1 ? parts[1].trim() : "string";
            String replacement = getRegexForType(type);
            
            matcher.appendReplacement(sb, "(" + replacement + ")");
        }
        
        matcher.appendTail(sb);
        regex = sb.toString();
        
        return Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
    }
    
    /**
     * Get a regular expression for a parameter type.
     *
     * @param type The parameter type
     * @return A regular expression pattern string
     */
    private String getRegexForType(String type) {
        switch (type.toLowerCase()) {
            case "int":
            case "integer":
                return "-?\\d+";
            case "double":
            case "float":
            case "number":
                return "-?\\d+(\\.\\d+)?";
            case "word":
                return "\\w+";
            case "boolean":
                return "true|false";
            case "date":
                return "\\d{4}-\\d{2}-\\d{2}|\\d{2}/\\d{2}/\\d{4}";
            case "time":
                return "\\d{1,2}:\\d{2}(:\\d{2})?( [aApP][mM])?";
            case "email":
                return "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}";
            case "url":
                return "(https?|ftp)://[^\\s/$.?#].[^\\s]*";
            default:
                return "[^\\s]+";
        }
    }
    
    /**
     * Match a step text against this step definition.
     *
     * @param stepText The step text to match
     * @return True if the step text matches this step definition, false otherwise
     */
    public boolean matches(String stepText) {
        if (stepText == null || stepText.isEmpty() || pattern == null || pattern.isEmpty()) {
            return false;
        }
        
        Pattern regex = compilePattern();
        return regex != null && regex.matcher(stepText).matches();
    }
    
    /**
     * Extract parameter values from a matching step text.
     *
     * @param stepText The step text to extract values from
     * @return A map of parameter names to values, or null if the step text doesn't match
     */
    public Map<String, String> extractParameterValues(String stepText) {
        if (!matches(stepText)) {
            return null;
        }
        
        Map<String, String> values = new HashMap<>();
        Pattern regex = compilePattern();
        Matcher matcher = regex.matcher(stepText);
        
        if (matcher.matches()) {
            for (int i = 0; i < parameters.size(); i++) {
                Parameter param = parameters.get(i);
                String value = matcher.group(i + 1);
                values.put(param.getName(), value);
            }
        }
        
        return values;
    }
    
    /**
     * Create a formatted Gherkin step string.
     *
     * @return The formatted Gherkin step string
     */
    @JsonIgnore
    public String getGherkinStep() {
        if (pattern == null || pattern.isEmpty()) {
            return "";
        }
        
        String prefix = stepType != null && !stepType.isEmpty() ? 
                stepType.substring(0, 1).toUpperCase() + stepType.substring(1) : "Given";
        
        return prefix + " " + pattern;
    }
    
    /**
     * Create a copy of this step definition.
     *
     * @return A copy of this step definition
     */
    public StepDefinition copy() {
        StepDefinition copy = new StepDefinition();
        copy.pattern = this.pattern;
        copy.stepType = this.stepType;
        copy.displayName = this.displayName;
        copy.description = this.description;
        copy.createdBy = this.createdBy;
        copy.createdAt = this.createdAt;
        copy.updatedAt = LocalDateTime.now();
        
        for (Parameter param : this.parameters) {
            copy.parameters.add(param.copy());
        }
        
        copy.actions.addAll(this.actions);
        copy.tags.addAll(this.tags);
        copy.metadata.putAll(this.metadata);
        
        return copy;
    }
    
    // Getters and setters
    
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPattern() {
        return pattern;
    }

    public void setPattern(String pattern) {
        this.pattern = pattern;
        extractParameters();
        updatedAt = LocalDateTime.now();
    }

    public String getStepType() {
        return stepType;
    }

    public void setStepType(String stepType) {
        this.stepType = stepType;
        updatedAt = LocalDateTime.now();
    }

    public String getDisplayName() {
        return displayName;
    }

    public void setDisplayName(String displayName) {
        this.displayName = displayName;
        updatedAt = LocalDateTime.now();
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
        updatedAt = LocalDateTime.now();
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    public List<Parameter> getParameters() {
        return parameters;
    }

    public void setParameters(List<Parameter> parameters) {
        this.parameters = parameters != null ? parameters : new ArrayList<>();
        updatedAt = LocalDateTime.now();
    }

    public List<String> getActions() {
        return actions;
    }

    public void setActions(List<String> actions) {
        this.actions = actions != null ? actions : new ArrayList<>();
        updatedAt = LocalDateTime.now();
    }

    public List<String> getTags() {
        return tags;
    }

    public void setTags(List<String> tags) {
        this.tags = tags != null ? tags : new ArrayList<>();
        updatedAt = LocalDateTime.now();
    }

    public Map<String, String> getMetadata() {
        return metadata;
    }

    public void setMetadata(Map<String, String> metadata) {
        this.metadata = metadata != null ? metadata : new HashMap<>();
        updatedAt = LocalDateTime.now();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        StepDefinition that = (StepDefinition) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "StepDefinition{" +
                "pattern='" + pattern + '\'' +
                ", stepType='" + stepType + '\'' +
                ", parameters=" + parameters.size() +
                ", actions=" + actions.size() +
                '}';
    }
    
    /**
     * Inner class representing a parameter for a step definition.
     */
    public static class Parameter implements Serializable {
        
        private static final long serialVersionUID = 1L;
        
        @JsonProperty("name")
        private String name;
        
        @JsonProperty("type")
        private String type;
        
        @JsonProperty("description")
        private String description;
        
        @JsonProperty("defaultValue")
        private String defaultValue;
        
        @JsonProperty("optional")
        private Boolean optional;
        
        /**
         * Default constructor.
         */
        public Parameter() {
            this.optional = false;
        }
        
        /**
         * Constructor with name and type.
         *
         * @param name The parameter name
         * @param type The parameter type
         */
        public Parameter(String name, String type) {
            this();
            this.name = name;
            this.type = type;
        }
        
        /**
         * Full constructor.
         *
         * @param name         The parameter name
         * @param type         The parameter type
         * @param description  The parameter description
         * @param defaultValue The default value of the parameter
         * @param optional     Whether the parameter is optional
         */
        public Parameter(String name, String type, String description, 
                       String defaultValue, Boolean optional) {
            this.name = name;
            this.type = type;
            this.description = description;
            this.defaultValue = defaultValue;
            this.optional = optional;
        }
        
        /**
         * Create a copy of this parameter.
         *
         * @return A copy of this parameter
         */
        public Parameter copy() {
            return new Parameter(
                    this.name,
                    this.type,
                    this.description,
                    this.defaultValue,
                    this.optional
            );
        }
        
        // Getters and setters
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public String getType() {
            return type;
        }
        
        public void setType(String type) {
            this.type = type;
        }
        
        public String getDescription() {
            return description;
        }
        
        public void setDescription(String description) {
            this.description = description;
        }
        
        public String getDefaultValue() {
            return defaultValue;
        }
        
        public void setDefaultValue(String defaultValue) {
            this.defaultValue = defaultValue;
        }
        
        public Boolean getOptional() {
            return optional;
        }
        
        public void setOptional(Boolean optional) {
            this.optional = optional;
        }
        
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Parameter parameter = (Parameter) o;
            return Objects.equals(name, parameter.name);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(name);
        }
        
        @Override
        public String toString() {
            return "Parameter{" +
                    "name='" + name + '\'' +
                    ", type='" + type + '\'' +
                    '}';
        }
    }
}


CustomActionConfig.java
---------------------------------

package com.cstestforge.model.recorder;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * Configuration for custom actions.
 * This class extends ActionConfig to provide specific properties for custom actions.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CustomActionConfig extends ActionConfig {
    
    private static final long serialVersionUID = 1L;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("script")
    private String script;
    
    @JsonProperty("scriptLanguage")
    private String scriptLanguage;
    
    @JsonProperty("parameters")
    private Map<String, Object> parameters;
    
    @JsonProperty("returnType")
    private String returnType;
    
    @JsonProperty("returnVariableName")
    private String returnVariableName;
    
    @JsonProperty("elementInfo")
    private ElementInfo elementInfo;
    
    @JsonProperty("isShared")
    private Boolean isShared;
    
    @JsonProperty("addToLibrary")
    private Boolean addToLibrary;
    
    @JsonProperty("category")
    private String category;
    
    @JsonProperty("icon")
    private String icon;
    
    @JsonProperty("documentation")
    private String documentation;
    
    @JsonProperty("implementationType")
    private String implementationType;
    
    /**
     * Default constructor.
     */
    public CustomActionConfig() {
        super("custom");
        this.parameters = new HashMap<>();
        this.scriptLanguage = "javascript";
        this.isShared = false;
        this.addToLibrary = false;
        this.implementationType = "script";
    }
    
    /**
     * Constructor with name and script.
     *
     * @param name   The name of the custom action
     * @param script The script to execute
     */
    public CustomActionConfig(String name, String script) {
        this();
        this.name = name;
        this.script = script;
    }
    
    /**
     * Constructor with action ID, name, and script.
     *
     * @param actionId The ID of the action this config belongs to
     * @param name     The name of the custom action
     * @param script   The script to execute
     */
    public CustomActionConfig(String actionId, String name, String script) {
        super("custom", actionId);
        this.name = name;
        this.script = script;
        this.parameters = new HashMap<>();
        this.scriptLanguage = "javascript";
        this.isShared = false;
        this.addToLibrary = false;
        this.implementationType = "script";
    }
    
    /**
     * Full constructor.
     *
     * @param actionId           The ID of the action this config belongs to
     * @param name               The name of the custom action
     * @param description        The description of the custom action
     * @param script             The script to execute
     * @param scriptLanguage     The language of the script
     * @param returnType         The return type of the script
     * @param returnVariableName The name of the variable to store the return value
     * @param isShared           Whether the custom action is shared
     * @param addToLibrary       Whether to add the custom action to the library
     */
    public CustomActionConfig(String actionId, String name, String description, String script,
                            String scriptLanguage, String returnType, String returnVariableName,
                            Boolean isShared, Boolean addToLibrary) {
        super("custom", actionId);
        this.name = name;
        this.description = description;
        this.script = script;
        this.scriptLanguage = scriptLanguage;
        this.returnType = returnType;
        this.returnVariableName = returnVariableName;
        this.isShared = isShared;
        this.addToLibrary = addToLibrary;
        this.parameters = new HashMap<>();
        this.implementationType = "script";
    }
    
    /**
     * Add a parameter to the custom action.
     *
     * @param name  The parameter name
     * @param value The parameter value
     */
    public void addParameter(String name, Object value) {
        if (name != null && !name.isEmpty()) {
            parameters.put(name, value);
        }
    }
    
    /**
     * Remove a parameter from the custom action.
     *
     * @param name The parameter name
     * @return The removed parameter value, or null if the parameter was not found
     */
    public Object removeParameter(String name) {
        if (name != null && !name.isEmpty()) {
            return parameters.remove(name);
        }
        return null;
    }
    
    /**
     * Check if the custom action has a specific parameter.
     *
     * @param name The parameter name
     * @return True if the custom action has the parameter, false otherwise
     */
    public boolean hasParameter(String name) {
        return name != null && !name.isEmpty() && parameters.containsKey(name);
    }
    
    /**
     * Get a parameter value.
     *
     * @param name    The parameter name
     * @param <T>     The parameter type
     * @return The parameter value, or null if the parameter was not found
     */
    @SuppressWarnings("unchecked")
    public <T> T getParameterValue(String name) {
        if (name == null || name.isEmpty() || !parameters.containsKey(name)) {
            return null;
        }
        
        try {
            return (T) parameters.get(name);
        } catch (ClassCastException e) {
            return null;
        }
    }
    
    /**
     * Check if the custom action implementation type is script.
     *
     * @return True if the implementation type is script, false otherwise
     */
    @JsonIgnore
    public boolean isScriptImplementation() {
        return "script".equals(implementationType);
    }
    
    /**
     * Check if the custom action implementation type is Java.
     *
     * @return True if the implementation type is Java, false otherwise
     */
    @JsonIgnore
    public boolean isJavaImplementation() {
        return "java".equals(implementationType);
    }
    
    /**
     * Check if the custom action implementation type is library.
     *
     * @return True if the implementation type is library, false otherwise
     */
    @JsonIgnore
    public boolean isLibraryImplementation() {
        return "library".equals(implementationType);
    }
    
    @Override
    @JsonIgnore
    public boolean isValid() {
        if (!super.isValid()) {
            return false;
        }
        
        if (name == null || name.isEmpty()) {
            return false;
        }
        
        if (isScriptImplementation() && (script == null || script.isEmpty())) {
            return false;
        }
        
        if (isJavaImplementation() && (
                parameters.get("className") == null || 
                ((String) parameters.get("className")).isEmpty() ||
                parameters.get("methodName") == null || 
                ((String) parameters.get("methodName")).isEmpty()
            )) {
            return false;
        }
        
        if (isLibraryImplementation() && (
                parameters.get("libraryName") == null || 
                ((String) parameters.get("libraryName")).isEmpty() ||
                parameters.get("functionName") == null || 
                ((String) parameters.get("functionName")).isEmpty()
            )) {
            return false;
        }
        
        return true;
    }
    
    @Override
    @JsonIgnore
    public String getValidationErrors() {
        StringBuilder errors = new StringBuilder();
        
        String baseErrors = super.getValidationErrors();
        if (baseErrors != null) {
            errors.append(baseErrors);
        }
        
        if (name == null || name.isEmpty()) {
            errors.append("Name is required. ");
        }
        
        if (isScriptImplementation() && (script == null || script.isEmpty())) {
            errors.append("Script is required for script implementation. ");
        }
        
        if (isJavaImplementation()) {
            if (parameters.get("className") == null || ((String) parameters.get("className")).isEmpty()) {
                errors.append("Class name is required for Java implementation. ");
            }
            
            if (parameters.get("methodName") == null || ((String) parameters.get("methodName")).isEmpty()) {
                errors.append("Method name is required for Java implementation. ");
            }
        }
        
        if (isLibraryImplementation()) {
            if (parameters.get("libraryName") == null || ((String) parameters.get("libraryName")).isEmpty()) {
                errors.append("Library name is required for library implementation. ");
            }
            
            if (parameters.get("functionName") == null || ((String) parameters.get("functionName")).isEmpty()) {
                errors.append("Function name is required for library implementation. ");
            }
        }
        
        return errors.length() > 0 ? errors.toString() : null;
    }
    
    @Override
    public CustomActionConfig copy() {
        CustomActionConfig copy = new CustomActionConfig();
        
        // Copy base properties
        copy.setId(this.getId());
        copy.setActionId(this.getActionId());
        copy.setTimeoutInSeconds(this.getTimeoutInSeconds());
        copy.setRetry(this.getRetry());
        copy.setMaxRetries(this.getMaxRetries());
        copy.setRetryIntervalInSeconds(this.getRetryIntervalInSeconds());
        copy.setContinueOnError(this.getContinueOnError());
        copy.setScreenshotOnError(this.getScreenshotOnError());
        copy.setScreenshotOnSuccess(this.getScreenshotOnSuccess());
        copy.setLogLevel(this.getLogLevel());
        copy.getMetadata().putAll(this.getMetadata());
        
        // Copy custom action properties
        copy.name = this.name;
        copy.description = this.description;
        copy.script = this.script;
        copy.scriptLanguage = this.scriptLanguage;
        copy.parameters.putAll(this.parameters);
        copy.returnType = this.returnType;
        copy.returnVariableName = this.returnVariableName;
        copy.elementInfo = this.elementInfo != null ? this.elementInfo.copy() : null;
        copy.isShared = this.isShared;
        copy.addToLibrary = this.addToLibrary;
        copy.category = this.category;
        copy.icon = this.icon;
        copy.documentation = this.documentation;
        copy.implementationType = this.implementationType;
        
        return copy;
    }
    
    /**
     * Create a sanitized version of this action for library storage.
     * This removes any sensitive information and configuration not relevant for library storage.
     *
     * @return A sanitized version of this action config
     */
    @JsonIgnore
    public CustomActionConfig createLibraryVersion() {
        CustomActionConfig libraryVersion = new CustomActionConfig();
        
        // Copy essential properties
        libraryVersion.name = this.name;
        libraryVersion.description = this.description;
        libraryVersion.script = this.script;
        libraryVersion.scriptLanguage = this.scriptLanguage;
        libraryVersion.returnType = this.returnType;
        libraryVersion.category = this.category;
        libraryVersion.icon = this.icon;
        libraryVersion.documentation = this.documentation;
        libraryVersion.implementationType = this.implementationType;
        
        // Copy parameters structure but not values
        for (Map.Entry<String, Object> entry : this.parameters.entrySet()) {
            if (entry.getValue() != null) {
                if (entry.getValue() instanceof String) {
                    libraryVersion.parameters.put(entry.getKey(), "");
                } else if (entry.getValue() instanceof Number) {
                    libraryVersion.parameters.put(entry.getKey(), 0);
                } else if (entry.getValue() instanceof Boolean) {
                    libraryVersion.parameters.put(entry.getKey(), false);
                } else {
                    // For complex objects, just store the class name
                    libraryVersion.parameters.put(entry.getKey(), entry.getValue().getClass().getSimpleName());
                }
            }
        }
        
        // Set library-specific properties
        libraryVersion.isShared = true;
        libraryVersion.addToLibrary = true;
        
        return libraryVersion;
    }
    
    /**
     * Create a copy of this action configuration with parameters filled from a given map.
     *
     * @param parameterValues Map of parameter values to fill
     * @return A new instance with the parameters filled
     */
    public CustomActionConfig fillParameters(Map<String, Object> parameterValues) {
        if (parameterValues == null || parameterValues.isEmpty()) {
            return this.copy();
        }
        
        CustomActionConfig filledConfig = this.copy();
        
        for (Map.Entry<String, Object> entry : parameterValues.entrySet()) {
            if (parameters.containsKey(entry.getKey())) {
                filledConfig.parameters.put(entry.getKey(), entry.getValue());
            }
        }
        
        return filledConfig;
    }
    
    /**
     * Get a JavaScript-safe version of the script.
     * This handles any necessary escaping and wrapping.
     *
     * @return A JavaScript-safe version of the script
     */
    @JsonIgnore
    public String getJavaScriptSafeScript() {
        if (script == null || script.isEmpty()) {
            return "";
        }
        
        // If the script is already wrapped in a function declaration, return it as-is
        if (script.trim().startsWith("function") || script.trim().startsWith("async function")) {
            return script;
        }
        
        // Otherwise, wrap it in an anonymous async function
        StringBuilder wrappedScript = new StringBuilder();
        wrappedScript.append("async function() {\n");
        wrappedScript.append("  try {\n");
        
        // Indent each line of the script
        String[] lines = script.split("\n");
        for (String line : lines) {
            wrappedScript.append("    ").append(line).append("\n");
        }
        
        wrappedScript.append("  } catch (error) {\n");
        wrappedScript.append("    console.error('Error in custom action: ' + error.message);\n");
        wrappedScript.append("    throw error;\n");
        wrappedScript.append("  }\n");
        wrappedScript.append("}");
        
        return wrappedScript.toString();
    }
    
    /**
     * Generate a method signature for Java implementation.
     *
     * @return A Java method signature as a string
     */
    @JsonIgnore
    public String generateJavaMethodSignature() {
        if (!isJavaImplementation()) {
            return "";
        }
        
        String className = (String) parameters.getOrDefault("className", "");
        String methodName = (String) parameters.getOrDefault("methodName", "");
        
        if (className.isEmpty() || methodName.isEmpty()) {
            return "";
        }
        
        StringBuilder signature = new StringBuilder();
        
        // Add return type if specified
        if (returnType != null && !returnType.isEmpty()) {
            signature.append(returnType);
        } else {
            signature.append("void");
        }
        
        // Add method name and open parenthesis
        signature.append(" ").append(methodName).append("(");
        
        // Add parameter list
        boolean first = true;
        
        for (Map.Entry<String, Object> entry : parameters.entrySet()) {
            // Skip internal parameters
            if (entry.getKey().equals("className") || entry.getKey().equals("methodName")) {
                continue;
            }
            
            if (entry.getValue() != null) {
                if (!first) {
                    signature.append(", ");
                }
                
                first = false;
                
                if (entry.getValue() instanceof String) {
                    signature.append("String ").append(entry.getKey());
                } else if (entry.getValue() instanceof Integer) {
                    signature.append("int ").append(entry.getKey());
                } else if (entry.getValue() instanceof Long) {
                    signature.append("long ").append(entry.getKey());
                } else if (entry.getValue() instanceof Double) {
                    signature.append("double ").append(entry.getKey());
                } else if (entry.getValue() instanceof Boolean) {
                    signature.append("boolean ").append(entry.getKey());
                } else if (entry.getValue() instanceof ElementInfo) {
                    signature.append("ElementInfo ").append(entry.getKey());
                } else {
                    // For complex objects, use Object
                    signature.append("Object ").append(entry.getKey());
                }
            }
        }
        
        // Close parenthesis
        signature.append(")");
        
        return signature.toString();
    }
    
    /**
     * Generate documentation for the custom action.
     *
     * @return Generated documentation string
     */
    @JsonIgnore
    public String generateDocumentation() {
        StringBuilder doc = new StringBuilder();
        
        // Add name and description
        doc.append("# ").append(name).append("\n\n");
        
        if (description != null && !description.isEmpty()) {
            doc.append(description).append("\n\n");
        }
        
        // Add implementation type
        doc.append("## Implementation Type\n\n");
        
        if (isScriptImplementation()) {
            doc.append("Script (").append(scriptLanguage).append(")\n\n");
        } else if (isJavaImplementation()) {
            doc.append("Java\n\n");
            doc.append("Class: ").append(parameters.getOrDefault("className", "")).append("\n");
            doc.append("Method: ").append(parameters.getOrDefault("methodName", "")).append("\n\n");
        } else if (isLibraryImplementation()) {
            doc.append("Library\n\n");
            doc.append("Library: ").append(parameters.getOrDefault("libraryName", "")).append("\n");
            doc.append("Function: ").append(parameters.getOrDefault("functionName", "")).append("\n\n");
        }
        
        // Add parameters section if there are parameters
        if (!parameters.isEmpty()) {
            doc.append("## Parameters\n\n");
            
            for (Map.Entry<String, Object> entry : parameters.entrySet()) {
                // Skip internal parameters
                if (entry.getKey().equals("className") || entry.getKey().equals("methodName") || 
                    entry.getKey().equals("libraryName") || entry.getKey().equals("functionName")) {
                    continue;
                }
                
                doc.append("- **").append(entry.getKey()).append("**: ");
                
                if (entry.getValue() != null) {
                    doc.append(entry.getValue().getClass().getSimpleName());
                } else {
                    doc.append("Object");
                }
                
                doc.append("\n");
            }
            
            doc.append("\n");
        }
        
        // Add return value section if there is a return value
        if (returnType != null && !returnType.isEmpty()) {
            doc.append("## Return Value\n\n");
            doc.append("Type: ").append(returnType).append("\n");
            
            if (returnVariableName != null && !returnVariableName.isEmpty()) {
                doc.append("Stored in variable: ").append(returnVariableName).append("\n");
            }
            
            doc.append("\n");
        }
        
        // Add additional documentation
        if (documentation != null && !documentation.isEmpty()) {
            doc.append("## Additional Information\n\n");
            doc.append(documentation).append("\n");
        }
        
        return doc.toString();
    }
    
    // Getters and setters
    
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getScript() {
        return script;
    }

    public void setScript(String script) {
        this.script = script;
    }

    public String getScriptLanguage() {
        return scriptLanguage;
    }

    public void setScriptLanguage(String scriptLanguage) {
        this.scriptLanguage = scriptLanguage;
    }

    public Map<String, Object> getParameters() {
        return parameters;
    }

    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters != null ? parameters : new HashMap<>();
    }

    public String getReturnType() {
        return returnType;
    }

    public void setReturnType(String returnType) {
        this.returnType = returnType;
    }

    public String getReturnVariableName() {
        return returnVariableName;
    }

    public void setReturnVariableName(String returnVariableName) {
        this.returnVariableName = returnVariableName;
    }

    public ElementInfo getElementInfo() {
        return elementInfo;
    }

    public void setElementInfo(ElementInfo elementInfo) {
        this.elementInfo = elementInfo;
    }

    public Boolean getIsShared() {
        return isShared;
    }

    public void setIsShared(Boolean isShared) {
        this.isShared = isShared;
    }

    public Boolean getAddToLibrary() {
        return addToLibrary;
    }

    public void setAddToLibrary(Boolean addToLibrary) {
        this.addToLibrary = addToLibrary;
    }

    public String getCategory() {
        return category;
    }

    public void setCategory(String category) {
        this.category = category;
    }

    public String getIcon() {
        return icon;
    }

    public void setIcon(String icon) {
        this.icon = icon;
    }

    public String getDocumentation() {
        return documentation;
    }

    public void setDocumentation(String documentation) {
        this.documentation = documentation;
    }

    public String getImplementationType() {
        return implementationType;
    }

    public void setImplementationType(String implementationType) {
        this.implementationType = implementationType;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        CustomActionConfig that = (CustomActionConfig) o;
        return Objects.equals(name, that.name) && 
               Objects.equals(getActionId(), that.getActionId());
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), name, getActionId());
    }

    @Override
    public String toString() {
        return "CustomActionConfig{" +
                "name='" + name + '\'' +
                ", scriptLanguage='" + scriptLanguage + '\'' +
                ", implementationType='" + implementationType + '\'' +
                ", parameters=" + parameters.size() +
                '}';
    }
}

